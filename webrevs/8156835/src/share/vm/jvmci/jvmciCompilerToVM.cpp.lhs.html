<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "code/codeCache.hpp"
  27 #include "code/scopeDesc.hpp"
  28 #include "interpreter/linkResolver.hpp"
  29 #include "memory/oopFactory.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "oops/generateOopMap.hpp"
  32 #include "oops/fieldStreams.hpp"
  33 #include "oops/oop.inline.hpp"
  34 #include "oops/objArrayOop.inline.hpp"
  35 #include "runtime/fieldDescriptor.hpp"
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"
  56 
  57 
  58 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  59 #define C2V_VMENTRY(result_type, name, signature) \
  60   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  61   TRACE_jvmci_1("CompilerToVM::" #name); \
  62   TRACE_CALL(result_type, jvmci_ ## name signature) \
  63   JVMCI_VM_ENTRY_MARK; \
  64 
  65 #define C2V_END }
  66 
  67 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  68   if (method() != NULL) {
  69     JavaValue result(T_OBJECT);
  70     JavaCallArguments args;
  71     args.push_long((jlong) (address) method());
  72     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  73 
  74     return (oop)result.get_jobject();
  75   }
  76   return NULL;
  77 }
  78 
  79 oop CompilerToVM::get_jvmci_type(KlassHandle klass, TRAPS) {
  80   if (klass() != NULL) {
  81     JavaValue result(T_OBJECT);
  82     JavaCallArguments args;
  83     args.push_oop(klass-&gt;java_mirror());
  84     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  85 
  86     return (oop)result.get_jobject();
  87   }
  88   return NULL;
  89 }
  90 
  91 extern "C" {
  92 extern VMStructEntry* jvmciHotSpotVMStructs;
  93 extern uint64_t jvmciHotSpotVMStructEntryTypeNameOffset;
  94 extern uint64_t jvmciHotSpotVMStructEntryFieldNameOffset;
  95 extern uint64_t jvmciHotSpotVMStructEntryTypeStringOffset;
  96 extern uint64_t jvmciHotSpotVMStructEntryIsStaticOffset;
  97 extern uint64_t jvmciHotSpotVMStructEntryOffsetOffset;
  98 extern uint64_t jvmciHotSpotVMStructEntryAddressOffset;
  99 extern uint64_t jvmciHotSpotVMStructEntryArrayStride;
 100 
 101 extern VMTypeEntry* jvmciHotSpotVMTypes;
 102 extern uint64_t jvmciHotSpotVMTypeEntryTypeNameOffset;
 103 extern uint64_t jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 104 extern uint64_t jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 105 extern uint64_t jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 106 extern uint64_t jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 107 extern uint64_t jvmciHotSpotVMTypeEntrySizeOffset;
 108 extern uint64_t jvmciHotSpotVMTypeEntryArrayStride;
 109 
 110 extern VMIntConstantEntry* jvmciHotSpotVMIntConstants;
 111 extern uint64_t jvmciHotSpotVMIntConstantEntryNameOffset;
 112 extern uint64_t jvmciHotSpotVMIntConstantEntryValueOffset;
 113 extern uint64_t jvmciHotSpotVMIntConstantEntryArrayStride;
 114 
 115 extern VMLongConstantEntry* jvmciHotSpotVMLongConstants;
 116 extern uint64_t jvmciHotSpotVMLongConstantEntryNameOffset;
 117 extern uint64_t jvmciHotSpotVMLongConstantEntryValueOffset;
 118 extern uint64_t jvmciHotSpotVMLongConstantEntryArrayStride;
 119 
 120 extern VMAddressEntry* jvmciHotSpotVMAddresses;
 121 extern uint64_t jvmciHotSpotVMAddressEntryNameOffset;
 122 extern uint64_t jvmciHotSpotVMAddressEntryValueOffset;
 123 extern uint64_t jvmciHotSpotVMAddressEntryArrayStride;
 124 }
 125 
 126 int CompilerToVM::Data::Klass_vtable_start_offset;
 127 int CompilerToVM::Data::Klass_vtable_length_offset;
 128 
 129 int CompilerToVM::Data::Method_extra_stack_entries;
 130 
 131 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
 132 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
 133 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
 134 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 135 
 136 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 137 
 138 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 139 int CompilerToVM::Data::Universe_base_vtable_size;
 140 address CompilerToVM::Data::Universe_narrow_oop_base;
 141 int CompilerToVM::Data::Universe_narrow_oop_shift;
 142 address CompilerToVM::Data::Universe_narrow_klass_base;
 143 int CompilerToVM::Data::Universe_narrow_klass_shift;
 144 void* CompilerToVM::Data::Universe_non_oop_bits;
 145 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 146 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 147 
 148 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 149 HeapWord** CompilerToVM::Data::_heap_end_addr;
 150 HeapWord** CompilerToVM::Data::_heap_top_addr;
 151 
 152 jbyte* CompilerToVM::Data::cardtable_start_address;
 153 int CompilerToVM::Data::cardtable_shift;
 154 
 155 int CompilerToVM::Data::vm_page_size;
 156 
 157 address CompilerToVM::Data::dsin;
 158 address CompilerToVM::Data::dcos;
 159 address CompilerToVM::Data::dtan;
 160 address CompilerToVM::Data::dexp;
 161 address CompilerToVM::Data::dlog;
 162 address CompilerToVM::Data::dlog10;
 163 address CompilerToVM::Data::dpow;
 164 
 165 void CompilerToVM::Data::initialize() {
 166   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 167   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 168 
 169   Method_extra_stack_entries = Method::extra_stack_entries();
 170 
 171   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 172   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 173   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 174   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 175 
 176   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 177 
 178   Universe_collectedHeap = Universe::heap();
 179   Universe_base_vtable_size = Universe::base_vtable_size();
 180   Universe_narrow_oop_base = Universe::narrow_oop_base();
 181   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 182   Universe_narrow_klass_base = Universe::narrow_klass_base();
 183   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 184   Universe_non_oop_bits = Universe::non_oop_word();
 185   Universe_verify_oop_mask = Universe::verify_oop_mask();
 186   Universe_verify_oop_bits = Universe::verify_oop_bits();
 187 
 188   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 189   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 190   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord**) -1;
 191 
 192   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 193   switch (bs-&gt;kind()) {
 194   case BarrierSet::CardTableModRef:
 195   case BarrierSet::CardTableForRS:
 196   case BarrierSet::CardTableExtension:
 197   case BarrierSet::G1SATBCT:
 198   case BarrierSet::G1SATBCTLogging: {
 199     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 200     assert(base != 0, "unexpected byte_map_base");
 201     cardtable_start_address = base;
 202     cardtable_shift = CardTableModRefBS::card_shift;
 203     break;
 204   }
 205   case BarrierSet::ModRef:
 206     cardtable_start_address = 0;
 207     cardtable_shift = 0;
 208     // No post barriers
 209     break;
 210   default:
 211     ShouldNotReachHere();
 212     break;
 213   }
 214 
 215   vm_page_size = os::vm_page_size();
 216 
 217 #define SET_TRIGFUNC(name)                                      \
 218   if (StubRoutines::name() != NULL) {                           \
 219     name = StubRoutines::name();                                \
 220   } else {                                                      \
 221     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 222   }
 223 
 224   SET_TRIGFUNC(dsin);
 225   SET_TRIGFUNC(dcos);
 226   SET_TRIGFUNC(dtan);
 227   SET_TRIGFUNC(dexp);
 228   SET_TRIGFUNC(dlog10);
 229   SET_TRIGFUNC(dlog);
 230   SET_TRIGFUNC(dpow);
 231 
 232 #undef SET_TRIGFUNC
 233 }
 234 
 235 /**
 236  * We put all jvmciHotSpotVM values in an array so we can read them easily from Java.
 237  */
 238 static uintptr_t ciHotSpotVMData[28];
 239 
 240 C2V_VMENTRY(jlong, initializeConfiguration, (JNIEnv *env, jobject))
 241   ciHotSpotVMData[0] = (uintptr_t) jvmciHotSpotVMStructs;
 242   ciHotSpotVMData[1] = jvmciHotSpotVMStructEntryTypeNameOffset;
 243   ciHotSpotVMData[2] = jvmciHotSpotVMStructEntryFieldNameOffset;
 244   ciHotSpotVMData[3] = jvmciHotSpotVMStructEntryTypeStringOffset;
 245   ciHotSpotVMData[4] = jvmciHotSpotVMStructEntryIsStaticOffset;
 246   ciHotSpotVMData[5] = jvmciHotSpotVMStructEntryOffsetOffset;
 247   ciHotSpotVMData[6] = jvmciHotSpotVMStructEntryAddressOffset;
 248   ciHotSpotVMData[7] = jvmciHotSpotVMStructEntryArrayStride;
 249 
 250   ciHotSpotVMData[8] = (uintptr_t) jvmciHotSpotVMTypes;
 251   ciHotSpotVMData[9] = jvmciHotSpotVMTypeEntryTypeNameOffset;
 252   ciHotSpotVMData[10] = jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 253   ciHotSpotVMData[11] = jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 254   ciHotSpotVMData[12] = jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 255   ciHotSpotVMData[13] = jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 256   ciHotSpotVMData[14] = jvmciHotSpotVMTypeEntrySizeOffset;
 257   ciHotSpotVMData[15] = jvmciHotSpotVMTypeEntryArrayStride;
 258 
 259   ciHotSpotVMData[16] = (uintptr_t) jvmciHotSpotVMIntConstants;
 260   ciHotSpotVMData[17] = jvmciHotSpotVMIntConstantEntryNameOffset;
 261   ciHotSpotVMData[18] = jvmciHotSpotVMIntConstantEntryValueOffset;
 262   ciHotSpotVMData[19] = jvmciHotSpotVMIntConstantEntryArrayStride;
 263 
 264   ciHotSpotVMData[20] = (uintptr_t) jvmciHotSpotVMLongConstants;
 265   ciHotSpotVMData[21] = jvmciHotSpotVMLongConstantEntryNameOffset;
 266   ciHotSpotVMData[22] = jvmciHotSpotVMLongConstantEntryValueOffset;
 267   ciHotSpotVMData[23] = jvmciHotSpotVMLongConstantEntryArrayStride;
 268 
 269   ciHotSpotVMData[24] = (uintptr_t) jvmciHotSpotVMAddresses;
 270   ciHotSpotVMData[25] = jvmciHotSpotVMAddressEntryNameOffset;
 271   ciHotSpotVMData[26] = jvmciHotSpotVMAddressEntryValueOffset;
 272   ciHotSpotVMData[27] = jvmciHotSpotVMAddressEntryArrayStride;
 273 
 274   CompilerToVM::Data::initialize();
 275 
 276   return (jlong) (address) &amp;ciHotSpotVMData;
 277 C2V_END
 278 
 279 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 280   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 281   ResourceMark rm;
 282 
 283   int code_size = method-&gt;code_size();
 284   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 285 
 286   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 287   // iterate over all bytecodes and replace non-Java bytecodes
 288 
 289   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 290     Bytecodes::Code code = s.code();
 291     Bytecodes::Code raw_code = s.raw_code();
 292     int bci = s.bci();
 293     int len = s.instruction_size();
 294 
 295     // Restore original byte code.
 296     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 297     if (len &gt; 1) {
 298       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);
 299     }
 300 
 301     if (len &gt; 1) {
 302       // Restore the big-endian constant pool indexes.
 303       // Cf. Rewriter::scan_method
 304       switch (code) {
 305         case Bytecodes::_getstatic:
 306         case Bytecodes::_putstatic:
 307         case Bytecodes::_getfield:
 308         case Bytecodes::_putfield:
 309         case Bytecodes::_invokevirtual:
 310         case Bytecodes::_invokespecial:
 311         case Bytecodes::_invokestatic:
 312         case Bytecodes::_invokeinterface:
 313         case Bytecodes::_invokehandle: {
 314           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 315           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 316           break;
 317         }
 318 
 319         case Bytecodes::_invokedynamic:
 320           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 321           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);
 322           break;
 323       }
 324 
 325       // Not all ldc byte code are rewritten.
 326       switch (raw_code) {
 327         case Bytecodes::_fast_aldc: {
 328           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;
 329           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 330           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 331           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);
 332           break;
 333         }
 334 
 335         case Bytecodes::_fast_aldc_w: {
 336           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 337           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 338           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 339           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 340           break;
 341         }
 342       }
 343     }
 344   }
 345 
 346   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);
 347 C2V_END
 348 
 349 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 350   ResourceMark rm;
 351   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 352   return method-&gt;exception_table_length();
 353 C2V_END
 354 
 355 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 356   ResourceMark rm;
 357   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 358   if (method-&gt;exception_table_length() == 0) {
 359     return 0L;
 360   }
 361   return (jlong) (address) method-&gt;exception_table_start();
 362 C2V_END
 363 
 364 C2V_VMENTRY(jobject, getResolvedJavaMethodAtSlot, (JNIEnv *, jobject, jclass holder_handle, jint slot))
 365   oop java_class = JNIHandles::resolve(holder_handle);
 366   Klass* holder = java_lang_Class::as_Klass(java_class);
 367   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 368   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 369   return JNIHandles::make_local(THREAD, result);
 370 }
 371 
 372 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))
 373   methodHandle method;
 374   oop base_object = JNIHandles::resolve(base);
 375   if (base_object == NULL) {
 376     method = *((Method**)(offset));
 377   } else if (base_object-&gt;is_a(SystemDictionary::MemberName_klass())) {
 378     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);
 379   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 380     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));
 381   } else {
 382     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 383                 err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 384   }
 385   assert (method.is_null() || method-&gt;is_method(), "invalid read");
 386   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 387   return JNIHandles::make_local(THREAD, result);
 388 }
 389 
 390 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject base, jlong offset))
 391   constantPoolHandle cp;
 392   oop base_object = JNIHandles::resolve(base);
 393   jlong base_address = 0;
 394   if (base_object != NULL) {
 395     if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 396       base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 397     } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 398       base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 399     } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 400       base_address = (jlong) CompilerToVM::asKlass(base_object);
 401     } else {
 402       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 403                   err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 404     }
 405   }
 406   cp = *((ConstantPool**) (intptr_t) (base_address + offset));
 407   if (!cp.is_null()) {
 408     JavaValue method_result(T_OBJECT);
 409     JavaCallArguments args;
 410     args.push_long((jlong) (address) cp());
 411     JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 412     return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());
 413   }
 414   return NULL;
 415 }
 416 
 417 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))
 418   KlassHandle klass;
 419   oop base_object = JNIHandles::resolve(base);
 420   jlong base_address = 0;
 421   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 422     klass = base_object-&gt;klass();
 423   } else if (!compressed) {
 424     if (base_object != NULL) {
 425       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 426         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 427       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 428         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 429       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 430         base_address = (jlong) CompilerToVM::asKlass(base_object);
 431       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {
 432         base_address = (jlong) (address) base_object;
 433       } else {
 434         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 435                     err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 436       }
 437     }
 438     klass = *((Klass**) (intptr_t) (base_address + offset));
 439   } else {
 440     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 441                 err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 442   }
 443   assert (klass.is_null() || klass-&gt;is_klass(), "invalid read");
 444   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 445   return JNIHandles::make_local(THREAD, result);
 446 }
 447 
 448 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 449   ResourceMark rm;
 450   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 451   KlassHandle holder = CompilerToVM::asKlass(jvmci_type);
 452   if (holder-&gt;is_interface()) {
 453     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", holder-&gt;external_name()));
 454   }
 455 
 456   methodHandle ucm;
 457   {
 458     MutexLocker locker(Compile_lock);
 459     ucm = Dependencies::find_unique_concrete_method(holder(), method());
 460   }
 461   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);
 462   return JNIHandles::make_local(THREAD, result);
 463 C2V_END
 464 
 465 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))
 466   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 467   oop implementor = CompilerToVM::get_jvmci_type(klass-&gt;implementor(), CHECK_NULL);
 468   return JNIHandles::make_local(THREAD, implementor);
 469 C2V_END
 470 
 471 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))
 472   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 473   return method-&gt;is_ignored_by_security_stack_walk();
 474 C2V_END
 475 
 476 C2V_VMENTRY(jboolean, canInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 477   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 478   // In hosted mode ignore the not_compilable flags since they are never set by
 479   // the JVMCI compiler.
 480   bool is_compilable = UseJVMCICompiler ? !method-&gt;is_not_compilable(CompLevel_full_optimization) : true;
 481   return is_compilable &amp;&amp; !CompilerOracle::should_not_inline(method) &amp;&amp; !method-&gt;dont_inline();
 482 C2V_END
 483 
 484 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 485   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 486   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 487 C2V_END
 488 
 489 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 490   ResourceMark rm;
 491   Handle name = JNIHandles::resolve(jname);
 492   Symbol* class_name = java_lang_String::as_symbol(name, CHECK_0);
 493   if (java_lang_String::length(name()) &lt;= 1) {
 494     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Primitive type %s should be handled in Java code", class_name-&gt;as_C_string()));
 495   }
 496 
 497   Klass* resolved_klass = NULL;
 498   Handle class_loader;
 499   Handle protection_domain;
 500   if (JNIHandles::resolve(accessing_class) == NULL) {
 501     THROW_0(vmSymbols::java_lang_NullPointerException());
 502   }
 503   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));
 504   class_loader = accessing_klass-&gt;class_loader();
 505   protection_domain = accessing_klass-&gt;protection_domain();
 506 
 507   if (resolve) {
 508     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 509   } else {
 510     if (class_name-&gt;byte_at(0) == 'L' &amp;&amp;
 511       class_name-&gt;byte_at(class_name-&gt;utf8_length()-1) == ';') {
 512       // This is a name from a signature.  Strip off the trimmings.
 513       // Call recursive to keep scope of strippedsym.
 514       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 515                                                           class_name-&gt;utf8_length()-2,
 516                                                           CHECK_0);
 517       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 518     } else if (FieldType::is_array(class_name)) {
 519       FieldArrayInfo fd;
 520       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 521       // of this call
 522       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 523       if (t == T_OBJECT) {
 524         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 525                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 526                                                             CHECK_0);
 527         // naked oop "k" is OK here -- we assign back into it
 528         resolved_klass = SystemDictionary::find(strippedsym,
 529                                                              class_loader,
 530                                                              protection_domain,
 531                                                              CHECK_0);
 532         if (resolved_klass != NULL) {
 533           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 534         }
 535       } else {
 536         resolved_klass = Universe::typeArrayKlassObj(t);
 537         resolved_klass = TypeArrayKlass::cast(resolved_klass)-&gt;array_klass(fd.dimension(), CHECK_0);
 538       }
 539     }
 540   }
 541   Handle result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 542   return JNIHandles::make_local(THREAD, result());
 543 C2V_END
 544 
 545 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 546   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 547   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);
 548   return JNIHandles::make_local(THREAD, result);
 549 C2V_END
 550 
 551 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 552   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 553   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 554   return JNIHandles::make_local(THREAD, result);
 555 C2V_END
 556 
 557 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 558   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 559   return cp-&gt;name_and_type_ref_index_at(index);
 560 C2V_END
 561 
 562 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 563   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 564   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);
 565   return JNIHandles::make_local(THREAD, sym());
 566 C2V_END
 567 
 568 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 569   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 570   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);
 571   return JNIHandles::make_local(THREAD, sym());
 572 C2V_END
 573 
 574 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 575   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 576   return cp-&gt;klass_ref_index_at(index);
 577 C2V_END
 578 
 579 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 580   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 581   Klass* resolved_klass = cp-&gt;klass_at(index, CHECK_NULL);
 582   Handle klass = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 583   return JNIHandles::make_local(THREAD, klass());
 584 C2V_END
 585 
 586 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 587   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 588   KlassHandle loading_klass(cp-&gt;pool_holder());
 589   bool is_accessible = false;
 590   KlassHandle klass = JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass);
 591   Symbol* symbol = NULL;
 592   if (klass.is_null()) {
 593     symbol = cp-&gt;klass_name_at(index);
 594   }
 595   Handle result;
 596   if (!klass.is_null()) {
 597     result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 598   } else {
 599     result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
 600   }
 601   return JNIHandles::make_local(THREAD, result());
 602 C2V_END
 603 
 604 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 605   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 606   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 607   return JNIHandles::make_local(THREAD, appendix_oop);
 608 C2V_END
 609 
 610 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 611   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 612   instanceKlassHandle pool_holder(cp-&gt;pool_holder());
 613   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 614   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 615   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 616   return JNIHandles::make_local(THREAD, result);
 617 C2V_END
 618 
 619 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 620   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 621   return cp-&gt;remap_instruction_operand_from_cache(index);
 622 C2V_END
 623 
 624 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode, jlongArray info_handle))
 625   ResourceMark rm;
 626   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 627   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 628   fieldDescriptor fd;
 629   LinkInfo link_info(cp, index, CHECK_0);
 630   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 631   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
 632   assert(info != NULL &amp;&amp; info-&gt;length() == 2, "must be");
 633   info-&gt;long_at_put(0, (jlong) fd.access_flags().as_int());
 634   info-&gt;long_at_put(1, (jlong) fd.offset());
 635   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 636   return JNIHandles::make_local(THREAD, field_holder);
 637 C2V_END
 638 
 639 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 640   ResourceMark rm;
 641   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 642   Method* method = CompilerToVM::asMethod(jvmci_method);
 643   if (klass-&gt;is_interface()) {
 644     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 645   }
 646   if (!method-&gt;method_holder()-&gt;is_interface()) {
 647     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 648   }
 649   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 650     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 651   }
 652   return LinkResolver::vtable_index_of_interface_method(klass, method);
 653 C2V_END
 654 
 655 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 656   KlassHandle recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);
 657   KlassHandle caller_klass = CompilerToVM::asKlass(caller_jvmci_type);
 658   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 659 
 660   KlassHandle h_resolved   (THREAD, method-&gt;method_holder());
 661   Symbol* h_name      = method-&gt;name();
 662   Symbol* h_signature = method-&gt;signature();
 663 
 664   bool check_access = true;
 665   LinkInfo link_info(h_resolved, h_name, h_signature, caller_klass, check_access);
 666   methodHandle m;
 667   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 668   // the vtable has not been setup, and the LinkResolver will fail.
 669   if (recv_klass-&gt;is_array_klass() ||
 670       InstanceKlass::cast(recv_klass())-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface()) {
 671     if (h_resolved-&gt;is_interface()) {
 672       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 673     } else {
 674       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 675     }
 676   }
 677 
 678   if (m.is_null()) {
 679     // Return NULL only if there was a problem with lookup (uninitialized class, etc.)
 680     return NULL;
 681   }
 682 
 683   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);
 684   return JNIHandles::make_local(THREAD, result);
 685 C2V_END
 686 
 687 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))
 688   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 689   assert(klass != NULL, "method must not be called for primitive types");
 690   return Dependencies::find_finalizable_subclass(klass) != NULL;
 691 C2V_END
 692 
 693 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))
 694   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 695   oop result = CompilerToVM::get_jvmci_method(klass-&gt;class_initializer(), CHECK_NULL);
 696   return JNIHandles::make_local(THREAD, result);
 697 C2V_END
 698 
 699 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))
 700   address target_addr = (address) addr;
 701   if (target_addr != 0x0) {
 702     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 703     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 704     return MAX2(ABS(off_low), ABS(off_high));
 705   }
 706   return -1;
 707 C2V_END
 708 
 709 C2V_VMENTRY(void, doNotInlineOrCompile,(JNIEnv *, jobject,  jobject jvmci_method))
 710   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 711   method-&gt;set_not_c1_compilable();
 712   method-&gt;set_not_c2_compilable();
 713   method-&gt;set_dont_inline(true);
 714 C2V_END
 715 
 716 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))
 717   ResourceMark rm;
 718   HandleMark hm;
 719   Handle target_handle = JNIHandles::resolve(target);
 720   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 721   CodeBlob* cb = NULL;
 722   Handle installed_code_handle = JNIHandles::resolve(installed_code);
 723   Handle speculation_log_handle = JNIHandles::resolve(speculation_log);
 724 
 725   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK_JNI_ERR);
 726 
 727   TraceTime install_time("installCode", JVMCICompiler::codeInstallTimer());
 728   CodeInstaller installer;
 729   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);
 730 
 731   if (PrintCodeCacheOnCompilation) {
 732     stringStream s;
 733     // Dump code cache  into a buffer before locking the tty,
 734     {
 735       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 736       CodeCache::print_summary(&amp;s, false);
 737     }
 738     ttyLocker ttyl;
 739     tty-&gt;print_raw_cr(s.as_string());
 740   }
 741 
 742   if (result != JVMCIEnv::ok) {
 743     assert(cb == NULL, "should be");
 744   } else {
 745     if (!installed_code_handle.is_null()) {
 746       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), "wrong type");
 747       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);
 748       {
 749         // Ensure that all updates to the InstalledCode fields are consistent.
 750         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
 751         InstalledCode::set_address(installed_code_handle, (jlong) cb);
 752         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);
 753         if (cb-&gt;is_nmethod()) {
 754           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());
 755         } else {
 756           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());
 757         }
 758         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {
 759           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());
 760           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());
 761           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());
 762         }
 763       }
 764       nmethod* nm = cb-&gt;as_nmethod_or_null();
 765       if (nm != NULL &amp;&amp; installed_code_handle-&gt;is_scavengable()) {
 766         assert(nm-&gt;detect_scavenge_root_oops(), "nm should be scavengable if installed_code is scavengable");
 767         if (!UseG1GC) {
 768           assert(nm-&gt;on_scavenge_root_list(), "nm should be on scavengable list");
 769         }
 770       }
 771     }
 772   }
 773   return result;
 774 C2V_END
 775 
 776 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))
 777   ResourceMark rm;
 778   HandleMark hm;
 779 
 780   Handle target_handle = JNIHandles::resolve(target);
 781   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 782   Handle metadata_handle = JNIHandles::resolve(metadata);
 783 
<a name="1" id="anc1"></a><span class="removed"> 784   HotSpotOopMap::klass()-&gt;initialize(thread);</span>
<span class="removed"> 785 </span>
 786   CodeMetadata code_metadata;
 787   CodeBlob *cb = NULL;
 788   CodeInstaller installer;
 789 
<a name="2" id="anc2"></a><span class="changed"> 790   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0); //cb, pc_descs, nr_pc_descs, scopes_descs, scopes_size, reloc_buffer);</span>
 791   if (result != JVMCIEnv::ok) {
 792     return result;
 793   }
 794 
 795   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 796     typeArrayHandle pcArrayOop = oopFactory::new_byteArray(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));
 797     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());
 798     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());
 799   }
 800 
 801   if (code_metadata.get_scopes_size() &gt; 0) {
 802     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));
 803     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());
 804     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());
 805   }
 806 
 807   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
 808   typeArrayHandle relocArrayOop = oopFactory::new_byteArray((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));
 809   if (reloc_buffer-&gt;size() &gt; 0) {
 810     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());
 811   }
 812   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());
 813 
 814   const OopMapSet* oopMapSet = installer.oopMapSet();
 815   {
 816     ResourceMark mark;
 817     ImmutableOopMapBuilder builder(oopMapSet);
 818     int oopmap_size = builder.heap_size();
 819     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray(oopmap_size, CHECK_(JVMCIEnv::cache_full));
 820     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));
 821     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());
 822   }
 823 
 824   HotSpotMetaData::set_metadata(metadata_handle, NULL);
 825 
 826   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 827   int table_size = handler-&gt;size_in_bytes();
 828   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray(table_size, CHECK_(JVMCIEnv::cache_full));
 829 
 830   if (table_size &gt; 0) {
 831     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));
 832   }
 833   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());
 834 
 835   return result;
 836 C2V_END
 837 
 838 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))
 839   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK);
 840   CompilerStatistics* stats = compiler-&gt;stats();
 841   stats-&gt;_standard.reset();
 842   stats-&gt;_osr.reset();
 843 C2V_END
 844 
 845 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))
 846   ResourceMark rm;
 847   HandleMark hm;
 848 
 849   if (installedCode == NULL) {
 850     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), "installedCode is null");
 851   }
 852 
 853   jlong codeBlob = InstalledCode::address(installedCode);
 854   if (codeBlob == 0L) {
 855     return NULL;
 856   }
 857 
 858   CodeBlob* cb = (CodeBlob*) (address) codeBlob;
 859   if (cb == NULL) {
 860     return NULL;
 861   }
 862 
 863   // We don't want the stringStream buffer to resize during disassembly as it
 864   // uses scoped resource memory. If a nested function called during disassembly uses
 865   // a ResourceMark and the buffer expands within the scope of the mark,
 866   // the buffer becomes garbage when that scope is exited. Experience shows that
 867   // the disassembled code is typically about 10x the code size so a fixed buffer
 868   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 869   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 870   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 871   stringStream st(buffer, bufferSize);
 872   if (cb-&gt;is_nmethod()) {
 873     nmethod* nm = (nmethod*) cb;
 874     if (!nm-&gt;is_alive()) {
 875       return NULL;
 876     }
 877   }
 878   Disassembler::decode(cb, &amp;st);
 879   if (st.size() &lt;= 0) {
 880     return NULL;
 881   }
 882 
 883   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);
 884   return JNIHandles::make_local(THREAD, result());
 885 C2V_END
 886 
 887 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))
 888   ResourceMark rm;
 889   HandleMark hm;
 890 
 891   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 892   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);
 893   return JNIHandles::make_local(THREAD, element);
 894 C2V_END
 895 
 896 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))
 897   ResourceMark rm;
 898   HandleMark hm;
 899 
 900   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);
 901   if (nmethodValue == 0L) {
 902     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
 903   }
 904   nmethod* nm = (nmethod*) (address) nmethodValue;
 905   methodHandle mh = nm-&gt;method();
 906   Symbol* signature = mh-&gt;signature();
 907   JavaCallArguments jca(mh-&gt;size_of_parameters());
 908 
 909   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
 910   JavaValue result(jap.get_ret_type());
 911   jca.set_alternative_target(nm);
 912   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
 913 
 914   if (jap.get_ret_type() == T_VOID) {
 915     return NULL;
 916   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
 917     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
 918   } else {
 919     jvalue *value = (jvalue *) result.get_value_addr();
 920     // Narrow the value down if required (Important on big endian machines)
 921     switch (jap.get_ret_type()) {
 922       case T_BOOLEAN:
 923        value-&gt;z = (jboolean) value-&gt;i;
 924        break;
 925       case T_BYTE:
 926        value-&gt;b = (jbyte) value-&gt;i;
 927        break;
 928       case T_CHAR:
 929        value-&gt;c = (jchar) value-&gt;i;
 930        break;
 931       case T_SHORT:
 932        value-&gt;s = (jshort) value-&gt;i;
 933        break;
 934      }
 935     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);
 936     return JNIHandles::make_local(THREAD, o);
 937   }
 938 C2V_END
 939 
 940 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))
 941   Method* method = CompilerToVM::asMethod(jvmci_method);
 942   if (!method-&gt;has_linenumber_table()) {
 943     return NULL;
 944   }
 945   u2 num_entries = 0;
 946   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
 947   while (streamForSize.read_pair()) {
 948     num_entries++;
 949   }
 950 
 951   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
 952   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);
 953 
 954   int i = 0;
 955   jlong value;
 956   while (stream.read_pair()) {
 957     value = ((long) stream.bci());
 958     result-&gt;long_at_put(i, value);
 959     value = ((long) stream.line());
 960     result-&gt;long_at_put(i + 1, value);
 961     i += 2;
 962   }
 963 
 964   return (jlongArray) JNIHandles::make_local(THREAD, result);
 965 C2V_END
 966 
 967 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 968   ResourceMark rm;
 969   Method* method = CompilerToVM::asMethod(jvmci_method);
 970   if (!method-&gt;has_localvariable_table()) {
 971     return 0;
 972   }
 973   return (jlong) (address) method-&gt;localvariable_table_start();
 974 C2V_END
 975 
 976 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 977   ResourceMark rm;
 978   Method* method = CompilerToVM::asMethod(jvmci_method);
 979   return method-&gt;localvariable_table_length();
 980 C2V_END
 981 
 982 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))
 983   Method* method = CompilerToVM::asMethod(jvmci_method);
 984   MethodCounters* mcs = method-&gt;method_counters();
 985   if (mcs != NULL) {
 986     mcs-&gt;clear_counters();
 987   }
 988   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
 989 
 990   CompiledMethod* code = method-&gt;code();
 991   if (code != NULL) {
 992     code-&gt;make_not_entrant();
 993   }
 994 
 995   MethodData* method_data = method-&gt;method_data();
 996   if (method_data == NULL) {
 997     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
 998     method_data = MethodData::allocate(loader_data, method, CHECK);
 999     method-&gt;set_method_data(method_data);
1000   } else {
1001     method_data-&gt;initialize();
1002   }
1003 C2V_END
1004 
1005 
1006 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))
1007   Handle installed_code_handle = JNIHandles::resolve(installed_code);
1008   nmethod::invalidate_installed_code(installed_code_handle, CHECK);
1009 C2V_END
1010 
1011 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))
1012   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);
1013   JavaThread::collect_counters(arrayOop);
1014   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);
1015 C2V_END
1016 
1017 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))
1018   HandleMark hm;
1019   ResourceMark rm;
1020   if (JNIHandles::resolve(jvmci_method) == NULL) {
1021     THROW_0(vmSymbols::java_lang_NullPointerException());
1022   }
1023   Method* method = CompilerToVM::asMethod(jvmci_method);
1024   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1025     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Unexpected bci %d", entry_bci));
1026   }
1027   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1028 C2V_END
1029 
1030 
1031 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))
1032   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1033   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1034 C2V_END
1035 
1036 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1037   Method* method = CompilerToVM::asMethod(jvmci_method);
1038   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1039 C2V_END
1040 
1041 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))
1042   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);
1043   return JNIHandles::make_local(THREAD, sym());
1044 C2V_END
1045 
1046 bool matches(jobjectArray methods, Method* method) {
1047   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1048 
1049   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1050     oop resolved = methods_oop-&gt;obj_at(i);
1051     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {
1052       return true;
1053     }
1054   }
1055   return false;
1056 }
1057 
1058 C2V_VMENTRY(jobject, getNextStackFrame, (JNIEnv*, jobject compilerToVM, jobject hs_frame, jobjectArray methods, jint initialSkip))
1059   ResourceMark rm;
1060 
1061   if (!thread-&gt;has_last_Java_frame()) return NULL;
1062   Handle result = HotSpotStackFrameReference::klass()-&gt;allocate_instance(thread);
1063   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1064 
1065   StackFrameStream fst(thread);
1066   if (hs_frame != NULL) {
1067     // look for the correct stack frame if one is given
1068     intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1069     while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1070       fst.next();
1071     }
1072     if (fst.current()-&gt;sp() != stack_pointer) {
1073       THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1074     }
1075   }
1076 
1077   int frame_number = 0;
1078   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1079   if (hs_frame != NULL) {
1080     // look for the correct vframe within the stack frame if one is given
1081     int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1082     while (frame_number &lt; last_frame_number) {
1083       if (vf-&gt;is_top()) {
1084         THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1085       }
1086       vf = vf-&gt;sender();
1087       frame_number ++;
1088     }
1089     // move one frame forward
1090     if (vf-&gt;is_top()) {
1091       if (fst.is_done()) {
1092         return NULL;
1093       }
1094       fst.next();
1095       vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1096       frame_number = 0;
1097     } else {
1098       vf = vf-&gt;sender();
1099       frame_number++;
1100     }
1101   }
1102 
1103   while (true) {
1104     // look for the given method
1105     while (true) {
1106       StackValueCollection* locals = NULL;
1107       if (vf-&gt;is_compiled_frame()) {
1108         // compiled method frame
1109         compiledVFrame* cvf = compiledVFrame::cast(vf);
1110         if (methods == NULL || matches(methods, cvf-&gt;method())) {
1111           if (initialSkip &gt; 0) {
1112             initialSkip --;
1113           } else {
1114             ScopeDesc* scope = cvf-&gt;scope();
1115             // native wrapper do not have a scope
1116             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1117               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), scope-&gt;objects(), THREAD);
1118               Deoptimization::reassign_fields(fst.current(), fst.register_map(), scope-&gt;objects(), realloc_failures, false);
1119 
1120               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1121               typeArrayHandle array = oopFactory::new_boolArray(local_values-&gt;length(), thread);
1122               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1123                 ScopeValue* value = local_values-&gt;at(i);
1124                 if (value-&gt;is_object()) {
1125                   array-&gt;bool_at_put(i, true);
1126                 }
1127               }
1128               HotSpotStackFrameReference::set_localIsVirtual(result, array());
1129             } else {
1130               HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1131             }
1132 
1133             locals = cvf-&gt;locals();
1134             HotSpotStackFrameReference::set_bci(result, cvf-&gt;bci());
1135             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);
1136             HotSpotStackFrameReference::set_method(result, method);
1137           }
1138         }
1139       } else if (vf-&gt;is_interpreted_frame()) {
1140         // interpreted method frame
1141         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1142         if (methods == NULL || matches(methods, ivf-&gt;method())) {
1143           if (initialSkip &gt; 0) {
1144             initialSkip --;
1145           } else {
1146             locals = ivf-&gt;locals();
1147             HotSpotStackFrameReference::set_bci(result, ivf-&gt;bci());
1148             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);
1149             HotSpotStackFrameReference::set_method(result, method);
1150             HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1151           }
1152         }
1153       }
1154 
1155       // locals != NULL means that we found a matching frame and result is already partially initialized
1156       if (locals != NULL) {
1157         HotSpotStackFrameReference::set_compilerToVM(result, JNIHandles::resolve(compilerToVM));
1158         HotSpotStackFrameReference::set_stackPointer(result, (jlong) fst.current()-&gt;sp());
1159         HotSpotStackFrameReference::set_frameNumber(result, frame_number);
1160 
1161         // initialize the locals array
1162         objArrayHandle array = oopFactory::new_objectArray(locals-&gt;size(), thread);
1163         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1164           StackValue* var = locals-&gt;at(i);
1165           if (var-&gt;type() == T_OBJECT) {
1166             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1167           }
1168         }
1169         HotSpotStackFrameReference::set_locals(result, array());
1170 
1171         return JNIHandles::make_local(thread, result());
1172       }
1173 
1174       if (vf-&gt;is_top()) {
1175         break;
1176       }
1177       frame_number++;
1178       vf = vf-&gt;sender();
1179     } // end of vframe loop
1180 
1181     if (fst.is_done()) {
1182       break;
1183     }
1184     fst.next();
1185     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1186     frame_number = 0;
1187   } // end of frame loop
1188 
1189   // the end was reached without finding a matching method
1190   return NULL;
1191 C2V_END
1192 
1193 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1194   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1195   CallInfo callInfo;
1196   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1197   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1198   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1199 C2V_END
1200 
1201 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1202   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1203   CallInfo callInfo;
1204   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1205   ConstantPoolCacheEntry* cp_cache_entry = cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1206   cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1207 C2V_END
1208 
1209 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))
1210   //see compute_recording_non_safepoints in debugInfroRec.cpp
1211   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1212     return true;
1213   }
1214   return DebugNonSafepoints;
1215 C2V_END
1216 
1217 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1218 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))
1219   ResourceMark rm;
1220 
1221   if (hs_frame == NULL) {
1222     THROW_MSG(vmSymbols::java_lang_NullPointerException(), "stack frame is null")
1223   }
1224 
1225   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1226 
1227   // look for the given stack frame
1228   StackFrameStream fst(thread);
1229   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1230   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1231     fst.next();
1232   }
1233   if (fst.current()-&gt;sp() != stack_pointer) {
1234     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1235   }
1236 
1237   if (invalidate) {
1238     if (!fst.current()-&gt;is_compiled_frame()) {
1239       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1240     }
1241     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), "nmethod expected");
1242     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1243   }
1244   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1245   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1246   StackFrameStream fstAfterDeopt(thread);
1247   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1248     fstAfterDeopt.next();
1249   }
1250   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1251     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found after deopt")
1252   }
1253 
1254   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1255   if (!vf-&gt;is_compiled_frame()) {
1256     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1257   }
1258 
1259   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1260   while (true) {
1261     assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1262     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1263     if (vf-&gt;is_top()) {
1264       break;
1265     }
1266     vf = vf-&gt;sender();
1267   }
1268 
1269   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1270   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1271     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1272   }
1273 
1274   // Reallocate the non-escaping objects and restore their fields.
1275   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,"invalid scope");
1276   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1277 
1278   if (objects == NULL) {
1279     // no objects to materialize
1280     return;
1281   }
1282 
1283   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, THREAD);
1284   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1285 
1286   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1287     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1288 
1289     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1290     StackValueCollection* locals = cvf-&gt;locals();
1291 
1292     if (locals != NULL) {
1293       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1294         StackValue* var = locals-&gt;at(i2);
1295         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1296           jvalue val;
1297           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1298           cvf-&gt;update_local(T_OBJECT, i2, val);
1299         }
1300       }
1301     }
1302   }
1303 
1304   // all locals are materialized by now
1305   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);
1306 
1307   // update the locals array
1308   objArrayHandle array = HotSpotStackFrameReference::locals(hs_frame);
1309   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1310   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1311     StackValue* var = locals-&gt;at(i);
1312     if (var-&gt;type() == T_OBJECT) {
1313       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1314     }
1315   }
1316 C2V_END
1317 
1318 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))
1319   if (bytes == NULL) {
1320     THROW(vmSymbols::java_lang_NullPointerException());
1321   }
1322   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);
1323 
1324   // Check if offset and length are non negative.
1325   if (offset &lt; 0 || length &lt; 0) {
1326     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1327   }
1328   // Check if the range is valid.
1329   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {
1330     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1331   }
1332   while (length &gt; 0) {
1333     jbyte* start = array-&gt;byte_at_addr(offset);
1334     tty-&gt;write((char*) start, MIN2(length, O_BUFLEN));
1335     length -= O_BUFLEN;
1336     offset += O_BUFLEN;
1337   }
1338 C2V_END
1339 
1340 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))
1341   tty-&gt;flush();
1342 C2V_END
1343 
1344 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))
1345   ResourceMark rm;
1346   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1347   ProfileData* profile_data = mdo-&gt;data_at(position);
1348   if (mdo-&gt;is_valid(profile_data)) {
1349     return profile_data-&gt;size_in_bytes();
1350   }
1351   DataLayout* data    = mdo-&gt;extra_data_base();
1352   DataLayout* end   = mdo-&gt;extra_data_limit();
1353   for (;; data = mdo-&gt;next_extra(data)) {
1354     assert(data &lt; end, "moved past end of extra data");
1355     profile_data = data-&gt;data_in();
1356     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1357       return profile_data-&gt;size_in_bytes();
1358     }
1359   }
1360   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Invalid profile data position %d", position));
1361 C2V_END
1362 
1363 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))
1364   if (bytecode_frame_handle == NULL) {
1365     THROW_0(vmSymbols::java_lang_NullPointerException());
1366   }
1367 
1368   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);
1369   oop bytecode_frame = top_bytecode_frame;
1370   int size = 0;
1371   int callee_parameters = 0;
1372   int callee_locals = 0;
1373   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1374   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);
1375 
1376   while (bytecode_frame != NULL) {
1377     int locks = BytecodeFrame::numLocks(bytecode_frame);
1378     int temps = BytecodeFrame::numStack(bytecode_frame);
1379     bool is_top_frame = (bytecode_frame == top_bytecode_frame);
1380     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1381 
1382     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1383                                                                  temps + callee_parameters,
1384                                                                  extra_args,
1385                                                                  locks,
1386                                                                  callee_parameters,
1387                                                                  callee_locals,
1388                                                                  is_top_frame);
1389     size += frame_size;
1390 
1391     callee_parameters = method-&gt;size_of_parameters();
1392     callee_locals = method-&gt;max_locals();
1393     extra_args = 0;
1394     bytecode_frame = BytecodePosition::caller(bytecode_frame);
1395   }
1396   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1397 C2V_END
1398 
1399 
1400 #define CC (char*)  /*cast a literal from (const char*)*/
1401 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1402 
1403 #define STRING                "Ljava/lang/String;"
1404 #define OBJECT                "Ljava/lang/Object;"
1405 #define CLASS                 "Ljava/lang/Class;"
1406 #define STACK_TRACE_ELEMENT   "Ljava/lang/StackTraceElement;"
1407 #define INSTALLED_CODE        "Ljdk/vm/ci/code/InstalledCode;"
1408 #define TARGET_DESCRIPTION    "Ljdk/vm/ci/code/TargetDescription;"
1409 #define BYTECODE_FRAME        "Ljdk/vm/ci/code/BytecodeFrame;"
1410 #define RESOLVED_METHOD       "Ljdk/vm/ci/meta/ResolvedJavaMethod;"
1411 #define HS_RESOLVED_METHOD    "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;"
1412 #define HS_RESOLVED_KLASS     "Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;"
1413 #define HS_CONSTANT_POOL      "Ljdk/vm/ci/hotspot/HotSpotConstantPool;"
1414 #define HS_COMPILED_CODE      "Ljdk/vm/ci/hotspot/HotSpotCompiledCode;"
1415 #define HS_CONFIG             "Ljdk/vm/ci/hotspot/HotSpotVMConfig;"
1416 #define HS_METADATA           "Ljdk/vm/ci/hotspot/HotSpotMetaData;"
1417 #define HS_STACK_FRAME_REF    "Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;"
1418 #define HS_SPECULATION_LOG    "Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;"
1419 #define METASPACE_METHOD_DATA "J"
1420 
1421 JNINativeMethod CompilerToVM::methods[] = {
1422   {CC "getBytecode",                                  CC "(" HS_RESOLVED_METHOD ")[B",                                                      FN_PTR(getBytecode)},
1423   {CC "getExceptionTableStart",                       CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getExceptionTableStart)},
1424   {CC "getExceptionTableLength",                      CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getExceptionTableLength)},
1425   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1426   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1427   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1428   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1429   {CC "doNotInlineOrCompile",                         CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(doNotInlineOrCompile)},
1430   {CC "canInlineMethod",                              CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(canInlineMethod)},
1431   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1432   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1433   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1434   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1435   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1436   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1437   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1438   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1439   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1440   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1441   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1442   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1443   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
1444   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "IB[J)" HS_RESOLVED_KLASS,                                    FN_PTR(resolveFieldInPool)},
1445   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1446   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1447   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1448   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1449   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1450   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1451   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1452   {CC "getResolvedJavaMethodAtSlot",                  CC "(" CLASS "I)" HS_RESOLVED_METHOD,                                                 FN_PTR(getResolvedJavaMethodAtSlot)},
1453   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1454   {CC "getConstantPool",                              CC "(Ljava/lang/Object;J)" HS_CONSTANT_POOL,                                          FN_PTR(getConstantPool)},
1455   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1456   {CC "initializeConfiguration",                      CC "(" HS_CONFIG ")J",                                                                FN_PTR(initializeConfiguration)},
1457   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1458   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1459   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1460   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1461   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1462   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1463   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1464   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1465   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1466   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1467   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1468   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1469   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1470   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1471   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1472   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1473   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1474   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1475   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1476   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1477   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1478   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1479 };
1480 
1481 int CompilerToVM::methods_count() {
1482   return sizeof(methods) / sizeof(JNINativeMethod);
1483 }
1484 
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="3" type="hidden" /></form></body></html>
