<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "code/codeCache.hpp"
  27 #include "code/scopeDesc.hpp"
  28 #include "interpreter/linkResolver.hpp"
  29 #include "memory/oopFactory.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "oops/generateOopMap.hpp"
  32 #include "oops/fieldStreams.hpp"
  33 #include "oops/oop.inline.hpp"
  34 #include "oops/objArrayOop.inline.hpp"
  35 #include "runtime/fieldDescriptor.hpp"
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"
  56 
  57 
  58 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  59 #define C2V_VMENTRY(result_type, name, signature) \
  60   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  61   TRACE_jvmci_1("CompilerToVM::" #name); \
  62   TRACE_CALL(result_type, jvmci_ ## name signature) \
  63   JVMCI_VM_ENTRY_MARK; \
  64 
  65 #define C2V_END }
  66 
  67 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  68   if (method() != NULL) {
  69     JavaValue result(T_OBJECT);
  70     JavaCallArguments args;
  71     args.push_long((jlong) (address) method());
  72     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  73 
  74     return (oop)result.get_jobject();
  75   }
  76   return NULL;
  77 }
  78 
  79 oop CompilerToVM::get_jvmci_type(KlassHandle klass, TRAPS) {
  80   if (klass() != NULL) {
  81     JavaValue result(T_OBJECT);
  82     JavaCallArguments args;
  83     args.push_oop(klass-&gt;java_mirror());
  84     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  85 
  86     return (oop)result.get_jobject();
  87   }
  88   return NULL;
  89 }
  90 
  91 extern "C" {
  92 extern VMStructEntry* jvmciHotSpotVMStructs;
  93 extern uint64_t jvmciHotSpotVMStructEntryTypeNameOffset;
  94 extern uint64_t jvmciHotSpotVMStructEntryFieldNameOffset;
  95 extern uint64_t jvmciHotSpotVMStructEntryTypeStringOffset;
  96 extern uint64_t jvmciHotSpotVMStructEntryIsStaticOffset;
  97 extern uint64_t jvmciHotSpotVMStructEntryOffsetOffset;
  98 extern uint64_t jvmciHotSpotVMStructEntryAddressOffset;
  99 extern uint64_t jvmciHotSpotVMStructEntryArrayStride;
 100 
 101 extern VMTypeEntry* jvmciHotSpotVMTypes;
 102 extern uint64_t jvmciHotSpotVMTypeEntryTypeNameOffset;
 103 extern uint64_t jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 104 extern uint64_t jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 105 extern uint64_t jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 106 extern uint64_t jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 107 extern uint64_t jvmciHotSpotVMTypeEntrySizeOffset;
 108 extern uint64_t jvmciHotSpotVMTypeEntryArrayStride;
 109 
 110 extern VMIntConstantEntry* jvmciHotSpotVMIntConstants;
 111 extern uint64_t jvmciHotSpotVMIntConstantEntryNameOffset;
 112 extern uint64_t jvmciHotSpotVMIntConstantEntryValueOffset;
 113 extern uint64_t jvmciHotSpotVMIntConstantEntryArrayStride;
 114 
 115 extern VMLongConstantEntry* jvmciHotSpotVMLongConstants;
 116 extern uint64_t jvmciHotSpotVMLongConstantEntryNameOffset;
 117 extern uint64_t jvmciHotSpotVMLongConstantEntryValueOffset;
 118 extern uint64_t jvmciHotSpotVMLongConstantEntryArrayStride;
 119 
 120 extern VMAddressEntry* jvmciHotSpotVMAddresses;
 121 extern uint64_t jvmciHotSpotVMAddressEntryNameOffset;
 122 extern uint64_t jvmciHotSpotVMAddressEntryValueOffset;
 123 extern uint64_t jvmciHotSpotVMAddressEntryArrayStride;
 124 }
 125 
 126 int CompilerToVM::Data::Klass_vtable_start_offset;
 127 int CompilerToVM::Data::Klass_vtable_length_offset;
 128 
 129 int CompilerToVM::Data::Method_extra_stack_entries;
 130 
 131 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
 132 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
 133 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
 134 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 135 
 136 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 137 
 138 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 139 int CompilerToVM::Data::Universe_base_vtable_size;
 140 address CompilerToVM::Data::Universe_narrow_oop_base;
 141 int CompilerToVM::Data::Universe_narrow_oop_shift;
 142 address CompilerToVM::Data::Universe_narrow_klass_base;
 143 int CompilerToVM::Data::Universe_narrow_klass_shift;
 144 void* CompilerToVM::Data::Universe_non_oop_bits;
 145 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 146 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 147 
 148 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 149 HeapWord** CompilerToVM::Data::_heap_end_addr;
 150 HeapWord** CompilerToVM::Data::_heap_top_addr;
 151 
 152 jbyte* CompilerToVM::Data::cardtable_start_address;
 153 int CompilerToVM::Data::cardtable_shift;
 154 
 155 int CompilerToVM::Data::vm_page_size;
 156 
 157 address CompilerToVM::Data::dsin;
 158 address CompilerToVM::Data::dcos;
 159 address CompilerToVM::Data::dtan;
 160 address CompilerToVM::Data::dexp;
 161 address CompilerToVM::Data::dlog;
 162 address CompilerToVM::Data::dlog10;
 163 address CompilerToVM::Data::dpow;
 164 
 165 void CompilerToVM::Data::initialize() {
 166   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 167   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 168 
 169   Method_extra_stack_entries = Method::extra_stack_entries();
 170 
 171   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 172   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 173   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 174   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 175 
 176   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 177 
 178   Universe_collectedHeap = Universe::heap();
 179   Universe_base_vtable_size = Universe::base_vtable_size();
 180   Universe_narrow_oop_base = Universe::narrow_oop_base();
 181   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 182   Universe_narrow_klass_base = Universe::narrow_klass_base();
 183   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 184   Universe_non_oop_bits = Universe::non_oop_word();
 185   Universe_verify_oop_mask = Universe::verify_oop_mask();
 186   Universe_verify_oop_bits = Universe::verify_oop_bits();
 187 
 188   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 189   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 190   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord**) -1;
 191 
 192   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 193   switch (bs-&gt;kind()) {
 194   case BarrierSet::CardTableModRef:
 195   case BarrierSet::CardTableForRS:
 196   case BarrierSet::CardTableExtension:
 197   case BarrierSet::G1SATBCT:
 198   case BarrierSet::G1SATBCTLogging: {
 199     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 200     assert(base != 0, "unexpected byte_map_base");
 201     cardtable_start_address = base;
 202     cardtable_shift = CardTableModRefBS::card_shift;
 203     break;
 204   }
 205   case BarrierSet::ModRef:
 206     cardtable_start_address = 0;
 207     cardtable_shift = 0;
 208     // No post barriers
 209     break;
 210   default:
 211     ShouldNotReachHere();
 212     break;
 213   }
 214 
 215   vm_page_size = os::vm_page_size();
 216 
 217 #define SET_TRIGFUNC(name)                                      \
 218   if (StubRoutines::name() != NULL) {                           \
 219     name = StubRoutines::name();                                \
 220   } else {                                                      \
 221     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 222   }
 223 
 224   SET_TRIGFUNC(dsin);
 225   SET_TRIGFUNC(dcos);
 226   SET_TRIGFUNC(dtan);
 227   SET_TRIGFUNC(dexp);
 228   SET_TRIGFUNC(dlog10);
 229   SET_TRIGFUNC(dlog);
 230   SET_TRIGFUNC(dpow);
 231 
 232 #undef SET_TRIGFUNC
 233 }
 234 
 235 /**
 236  * We put all jvmciHotSpotVM values in an array so we can read them easily from Java.
 237  */
 238 static uintptr_t ciHotSpotVMData[28];
 239 
 240 C2V_VMENTRY(jlong, initializeConfiguration, (JNIEnv *env, jobject))
 241   ciHotSpotVMData[0] = (uintptr_t) jvmciHotSpotVMStructs;
 242   ciHotSpotVMData[1] = jvmciHotSpotVMStructEntryTypeNameOffset;
 243   ciHotSpotVMData[2] = jvmciHotSpotVMStructEntryFieldNameOffset;
 244   ciHotSpotVMData[3] = jvmciHotSpotVMStructEntryTypeStringOffset;
 245   ciHotSpotVMData[4] = jvmciHotSpotVMStructEntryIsStaticOffset;
 246   ciHotSpotVMData[5] = jvmciHotSpotVMStructEntryOffsetOffset;
 247   ciHotSpotVMData[6] = jvmciHotSpotVMStructEntryAddressOffset;
 248   ciHotSpotVMData[7] = jvmciHotSpotVMStructEntryArrayStride;
 249 
 250   ciHotSpotVMData[8] = (uintptr_t) jvmciHotSpotVMTypes;
 251   ciHotSpotVMData[9] = jvmciHotSpotVMTypeEntryTypeNameOffset;
 252   ciHotSpotVMData[10] = jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 253   ciHotSpotVMData[11] = jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 254   ciHotSpotVMData[12] = jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 255   ciHotSpotVMData[13] = jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 256   ciHotSpotVMData[14] = jvmciHotSpotVMTypeEntrySizeOffset;
 257   ciHotSpotVMData[15] = jvmciHotSpotVMTypeEntryArrayStride;
 258 
 259   ciHotSpotVMData[16] = (uintptr_t) jvmciHotSpotVMIntConstants;
 260   ciHotSpotVMData[17] = jvmciHotSpotVMIntConstantEntryNameOffset;
 261   ciHotSpotVMData[18] = jvmciHotSpotVMIntConstantEntryValueOffset;
 262   ciHotSpotVMData[19] = jvmciHotSpotVMIntConstantEntryArrayStride;
 263 
 264   ciHotSpotVMData[20] = (uintptr_t) jvmciHotSpotVMLongConstants;
 265   ciHotSpotVMData[21] = jvmciHotSpotVMLongConstantEntryNameOffset;
 266   ciHotSpotVMData[22] = jvmciHotSpotVMLongConstantEntryValueOffset;
 267   ciHotSpotVMData[23] = jvmciHotSpotVMLongConstantEntryArrayStride;
 268 
 269   ciHotSpotVMData[24] = (uintptr_t) jvmciHotSpotVMAddresses;
 270   ciHotSpotVMData[25] = jvmciHotSpotVMAddressEntryNameOffset;
 271   ciHotSpotVMData[26] = jvmciHotSpotVMAddressEntryValueOffset;
 272   ciHotSpotVMData[27] = jvmciHotSpotVMAddressEntryArrayStride;
 273 
 274   CompilerToVM::Data::initialize();
 275 
 276   return (jlong) (address) &amp;ciHotSpotVMData;
 277 C2V_END
 278 
 279 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 280   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 281   ResourceMark rm;
 282 
 283   int code_size = method-&gt;code_size();
 284   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 285 
 286   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 287   // iterate over all bytecodes and replace non-Java bytecodes
 288 
 289   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 290     Bytecodes::Code code = s.code();
 291     Bytecodes::Code raw_code = s.raw_code();
 292     int bci = s.bci();
 293     int len = s.instruction_size();
 294 
 295     // Restore original byte code.
 296     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 297     if (len &gt; 1) {
 298       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);
 299     }
 300 
 301     if (len &gt; 1) {
 302       // Restore the big-endian constant pool indexes.
 303       // Cf. Rewriter::scan_method
 304       switch (code) {
 305         case Bytecodes::_getstatic:
 306         case Bytecodes::_putstatic:
 307         case Bytecodes::_getfield:
 308         case Bytecodes::_putfield:
 309         case Bytecodes::_invokevirtual:
 310         case Bytecodes::_invokespecial:
 311         case Bytecodes::_invokestatic:
 312         case Bytecodes::_invokeinterface:
 313         case Bytecodes::_invokehandle: {
 314           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 315           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 316           break;
 317         }
 318 
 319         case Bytecodes::_invokedynamic:
 320           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 321           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);
 322           break;
 323       }
 324 
 325       // Not all ldc byte code are rewritten.
 326       switch (raw_code) {
 327         case Bytecodes::_fast_aldc: {
 328           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;
 329           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 330           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 331           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);
 332           break;
 333         }
 334 
 335         case Bytecodes::_fast_aldc_w: {
 336           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 337           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 338           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 339           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 340           break;
 341         }
 342       }
 343     }
 344   }
 345 
 346   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);
 347 C2V_END
 348 
 349 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 350   ResourceMark rm;
 351   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 352   return method-&gt;exception_table_length();
 353 C2V_END
 354 
 355 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 356   ResourceMark rm;
 357   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 358   if (method-&gt;exception_table_length() == 0) {
 359     return 0L;
 360   }
 361   return (jlong) (address) method-&gt;exception_table_start();
 362 C2V_END
 363 
 364 C2V_VMENTRY(jobject, getResolvedJavaMethodAtSlot, (JNIEnv *, jobject, jclass holder_handle, jint slot))
 365   oop java_class = JNIHandles::resolve(holder_handle);
 366   Klass* holder = java_lang_Class::as_Klass(java_class);
 367   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 368   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 369   return JNIHandles::make_local(THREAD, result);
 370 }
 371 
 372 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))
 373   methodHandle method;
 374   oop base_object = JNIHandles::resolve(base);
 375   if (base_object == NULL) {
 376     method = *((Method**)(offset));
 377   } else if (base_object-&gt;is_a(SystemDictionary::MemberName_klass())) {
 378     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);
 379   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 380     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));
 381   } else {
 382     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 383                 err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 384   }
 385   assert (method.is_null() || method-&gt;is_method(), "invalid read");
 386   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 387   return JNIHandles::make_local(THREAD, result);
 388 }
 389 
 390 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject base, jlong offset))
 391   constantPoolHandle cp;
 392   oop base_object = JNIHandles::resolve(base);
 393   jlong base_address = 0;
 394   if (base_object != NULL) {
 395     if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 396       base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 397     } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 398       base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 399     } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 400       base_address = (jlong) CompilerToVM::asKlass(base_object);
 401     } else {
 402       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 403                   err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 404     }
 405   }
 406   cp = *((ConstantPool**) (intptr_t) (base_address + offset));
 407   if (!cp.is_null()) {
 408     JavaValue method_result(T_OBJECT);
 409     JavaCallArguments args;
 410     args.push_long((jlong) (address) cp());
 411     JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 412     return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());
 413   }
 414   return NULL;
 415 }
 416 
 417 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))
 418   KlassHandle klass;
 419   oop base_object = JNIHandles::resolve(base);
 420   jlong base_address = 0;
 421   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 422     klass = base_object-&gt;klass();
 423   } else if (!compressed) {
 424     if (base_object != NULL) {
 425       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 426         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 427       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 428         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 429       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 430         base_address = (jlong) CompilerToVM::asKlass(base_object);
 431       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {
 432         base_address = (jlong) (address) base_object;
 433       } else {
 434         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 435                     err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 436       }
 437     }
 438     klass = *((Klass**) (intptr_t) (base_address + offset));
 439   } else {
 440     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 441                 err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 442   }
 443   assert (klass.is_null() || klass-&gt;is_klass(), "invalid read");
 444   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 445   return JNIHandles::make_local(THREAD, result);
 446 }
 447 
 448 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 449   ResourceMark rm;
 450   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 451   KlassHandle holder = CompilerToVM::asKlass(jvmci_type);
 452   if (holder-&gt;is_interface()) {
 453     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", holder-&gt;external_name()));
 454   }
 455 
 456   methodHandle ucm;
 457   {
 458     MutexLocker locker(Compile_lock);
 459     ucm = Dependencies::find_unique_concrete_method(holder(), method());
 460   }
 461   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);
 462   return JNIHandles::make_local(THREAD, result);
 463 C2V_END
 464 
 465 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))
 466   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 467   oop implementor = CompilerToVM::get_jvmci_type(klass-&gt;implementor(), CHECK_NULL);
 468   return JNIHandles::make_local(THREAD, implementor);
 469 C2V_END
 470 
 471 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))
 472   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 473   return method-&gt;is_ignored_by_security_stack_walk();
 474 C2V_END
 475 
 476 C2V_VMENTRY(jboolean, canInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 477   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 478   // In hosted mode ignore the not_compilable flags since they are never set by
 479   // the JVMCI compiler.
 480   bool is_compilable = UseJVMCICompiler ? !method-&gt;is_not_compilable(CompLevel_full_optimization) : true;
 481   return is_compilable &amp;&amp; !CompilerOracle::should_not_inline(method) &amp;&amp; !method-&gt;dont_inline();
 482 C2V_END
 483 
 484 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 485   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 486   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 487 C2V_END
 488 
 489 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 490   ResourceMark rm;
 491   Handle name = JNIHandles::resolve(jname);
 492   Symbol* class_name = java_lang_String::as_symbol(name, CHECK_0);
 493   if (java_lang_String::length(name()) &lt;= 1) {
 494     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Primitive type %s should be handled in Java code", class_name-&gt;as_C_string()));
 495   }
 496 
 497   Klass* resolved_klass = NULL;
 498   Handle class_loader;
 499   Handle protection_domain;
 500   if (JNIHandles::resolve(accessing_class) == NULL) {
 501     THROW_0(vmSymbols::java_lang_NullPointerException());
 502   }
 503   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));
 504   class_loader = accessing_klass-&gt;class_loader();
 505   protection_domain = accessing_klass-&gt;protection_domain();
 506 
 507   if (resolve) {
 508     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 509   } else {
 510     if (class_name-&gt;byte_at(0) == 'L' &amp;&amp;
 511       class_name-&gt;byte_at(class_name-&gt;utf8_length()-1) == ';') {
 512       // This is a name from a signature.  Strip off the trimmings.
 513       // Call recursive to keep scope of strippedsym.
 514       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 515                                                           class_name-&gt;utf8_length()-2,
 516                                                           CHECK_0);
 517       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 518     } else if (FieldType::is_array(class_name)) {
 519       FieldArrayInfo fd;
 520       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 521       // of this call
 522       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 523       if (t == T_OBJECT) {
 524         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 525                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 526                                                             CHECK_0);
 527         // naked oop "k" is OK here -- we assign back into it
 528         resolved_klass = SystemDictionary::find(strippedsym,
 529                                                              class_loader,
 530                                                              protection_domain,
 531                                                              CHECK_0);
 532         if (resolved_klass != NULL) {
 533           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 534         }
 535       } else {
 536         resolved_klass = Universe::typeArrayKlassObj(t);
 537         resolved_klass = TypeArrayKlass::cast(resolved_klass)-&gt;array_klass(fd.dimension(), CHECK_0);
 538       }
 539     }
 540   }
 541   Handle result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 542   return JNIHandles::make_local(THREAD, result());
 543 C2V_END
 544 
 545 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 546   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 547   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);
 548   return JNIHandles::make_local(THREAD, result);
 549 C2V_END
 550 
 551 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 552   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 553   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 554   return JNIHandles::make_local(THREAD, result);
 555 C2V_END
 556 
 557 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 558   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 559   return cp-&gt;name_and_type_ref_index_at(index);
 560 C2V_END
 561 
 562 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 563   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 564   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);
 565   return JNIHandles::make_local(THREAD, sym());
 566 C2V_END
 567 
 568 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 569   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 570   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);
 571   return JNIHandles::make_local(THREAD, sym());
 572 C2V_END
 573 
 574 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 575   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 576   return cp-&gt;klass_ref_index_at(index);
 577 C2V_END
 578 
 579 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 580   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 581   Klass* resolved_klass = cp-&gt;klass_at(index, CHECK_NULL);
 582   Handle klass = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 583   return JNIHandles::make_local(THREAD, klass());
 584 C2V_END
 585 
 586 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 587   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 588   KlassHandle loading_klass(cp-&gt;pool_holder());
 589   bool is_accessible = false;
 590   KlassHandle klass = JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass);
 591   Symbol* symbol = NULL;
 592   if (klass.is_null()) {
 593     symbol = cp-&gt;klass_name_at(index);
 594   }
 595   Handle result;
 596   if (!klass.is_null()) {
 597     result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 598   } else {
 599     result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
 600   }
 601   return JNIHandles::make_local(THREAD, result());
 602 C2V_END
 603 
 604 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 605   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 606   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 607   return JNIHandles::make_local(THREAD, appendix_oop);
 608 C2V_END
 609 
 610 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 611   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 612   instanceKlassHandle pool_holder(cp-&gt;pool_holder());
 613   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 614   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 615   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 616   return JNIHandles::make_local(THREAD, result);
 617 C2V_END
 618 
 619 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 620   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 621   return cp-&gt;remap_instruction_operand_from_cache(index);
 622 C2V_END
 623 
 624 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode, jlongArray info_handle))
 625   ResourceMark rm;
 626   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 627   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 628   fieldDescriptor fd;
 629   LinkInfo link_info(cp, index, CHECK_0);
 630   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 631   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
 632   assert(info != NULL &amp;&amp; info-&gt;length() == 2, "must be");
 633   info-&gt;long_at_put(0, (jlong) fd.access_flags().as_int());
 634   info-&gt;long_at_put(1, (jlong) fd.offset());
 635   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 636   return JNIHandles::make_local(THREAD, field_holder);
 637 C2V_END
 638 
 639 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 640   ResourceMark rm;
 641   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 642   Method* method = CompilerToVM::asMethod(jvmci_method);
 643   if (klass-&gt;is_interface()) {
 644     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 645   }
 646   if (!method-&gt;method_holder()-&gt;is_interface()) {
 647     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 648   }
 649   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 650     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 651   }
 652   return LinkResolver::vtable_index_of_interface_method(klass, method);
 653 C2V_END
 654 
 655 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 656   KlassHandle recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);
 657   KlassHandle caller_klass = CompilerToVM::asKlass(caller_jvmci_type);
 658   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 659 
 660   KlassHandle h_resolved   (THREAD, method-&gt;method_holder());
 661   Symbol* h_name      = method-&gt;name();
 662   Symbol* h_signature = method-&gt;signature();
 663 
 664   bool check_access = true;
 665   LinkInfo link_info(h_resolved, h_name, h_signature, caller_klass, check_access);
 666   methodHandle m;
 667   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 668   // the vtable has not been setup, and the LinkResolver will fail.
 669   if (recv_klass-&gt;is_array_klass() ||
 670       InstanceKlass::cast(recv_klass())-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface()) {
 671     if (h_resolved-&gt;is_interface()) {
 672       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 673     } else {
 674       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 675     }
 676   }
 677 
 678   if (m.is_null()) {
 679     // Return NULL only if there was a problem with lookup (uninitialized class, etc.)
 680     return NULL;
 681   }
 682 
 683   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);
 684   return JNIHandles::make_local(THREAD, result);
 685 C2V_END
 686 
 687 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))
 688   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 689   assert(klass != NULL, "method must not be called for primitive types");
 690   return Dependencies::find_finalizable_subclass(klass) != NULL;
 691 C2V_END
 692 
 693 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))
 694   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 695   oop result = CompilerToVM::get_jvmci_method(klass-&gt;class_initializer(), CHECK_NULL);
 696   return JNIHandles::make_local(THREAD, result);
 697 C2V_END
 698 
 699 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))
 700   address target_addr = (address) addr;
 701   if (target_addr != 0x0) {
 702     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 703     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 704     return MAX2(ABS(off_low), ABS(off_high));
 705   }
 706   return -1;
 707 C2V_END
 708 
 709 C2V_VMENTRY(void, doNotInlineOrCompile,(JNIEnv *, jobject,  jobject jvmci_method))
 710   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 711   method-&gt;set_not_c1_compilable();
 712   method-&gt;set_not_c2_compilable();
 713   method-&gt;set_dont_inline(true);
 714 C2V_END
 715 
 716 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))
 717   ResourceMark rm;
 718   HandleMark hm;
 719   Handle target_handle = JNIHandles::resolve(target);
 720   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 721   CodeBlob* cb = NULL;
 722   Handle installed_code_handle = JNIHandles::resolve(installed_code);
 723   Handle speculation_log_handle = JNIHandles::resolve(speculation_log);
 724 
 725   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK_JNI_ERR);
 726 
 727   TraceTime install_time("installCode", JVMCICompiler::codeInstallTimer());
 728   CodeInstaller installer;
 729   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);
 730 
 731   if (PrintCodeCacheOnCompilation) {
 732     stringStream s;
 733     // Dump code cache  into a buffer before locking the tty,
 734     {
 735       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 736       CodeCache::print_summary(&amp;s, false);
 737     }
 738     ttyLocker ttyl;
 739     tty-&gt;print_raw_cr(s.as_string());
 740   }
 741 
 742   if (result != JVMCIEnv::ok) {
 743     assert(cb == NULL, "should be");
 744   } else {
 745     if (!installed_code_handle.is_null()) {
 746       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), "wrong type");
 747       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);
 748       {
 749         // Ensure that all updates to the InstalledCode fields are consistent.
 750         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
 751         InstalledCode::set_address(installed_code_handle, (jlong) cb);
 752         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);
 753         if (cb-&gt;is_nmethod()) {
 754           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());
 755         } else {
 756           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());
 757         }
 758         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {
 759           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());
 760           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());
 761           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());
 762         }
 763       }
 764       nmethod* nm = cb-&gt;as_nmethod_or_null();
 765       if (nm != NULL &amp;&amp; installed_code_handle-&gt;is_scavengable()) {
 766         assert(nm-&gt;detect_scavenge_root_oops(), "nm should be scavengable if installed_code is scavengable");
 767         if (!UseG1GC) {
 768           assert(nm-&gt;on_scavenge_root_list(), "nm should be on scavengable list");
 769         }
 770       }
 771     }
 772   }
 773   return result;
 774 C2V_END
 775 
 776 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))
 777   ResourceMark rm;
 778   HandleMark hm;
 779 
 780   Handle target_handle = JNIHandles::resolve(target);
 781   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 782   Handle metadata_handle = JNIHandles::resolve(metadata);
 783 
<a name="1" id="anc1"></a>

 784   CodeMetadata code_metadata;
 785   CodeBlob *cb = NULL;
 786   CodeInstaller installer;
 787 
<a name="2" id="anc2"></a><span class="changed"> 788   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);</span>
 789   if (result != JVMCIEnv::ok) {
 790     return result;
 791   }
 792 
 793   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 794     typeArrayHandle pcArrayOop = oopFactory::new_byteArray(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));
 795     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());
 796     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());
 797   }
 798 
 799   if (code_metadata.get_scopes_size() &gt; 0) {
 800     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));
 801     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());
 802     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());
 803   }
 804 
 805   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
 806   typeArrayHandle relocArrayOop = oopFactory::new_byteArray((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));
 807   if (reloc_buffer-&gt;size() &gt; 0) {
 808     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());
 809   }
 810   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());
 811 
 812   const OopMapSet* oopMapSet = installer.oopMapSet();
 813   {
 814     ResourceMark mark;
 815     ImmutableOopMapBuilder builder(oopMapSet);
 816     int oopmap_size = builder.heap_size();
 817     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray(oopmap_size, CHECK_(JVMCIEnv::cache_full));
 818     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));
 819     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());
 820   }
 821 
 822   HotSpotMetaData::set_metadata(metadata_handle, NULL);
 823 
 824   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 825   int table_size = handler-&gt;size_in_bytes();
 826   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray(table_size, CHECK_(JVMCIEnv::cache_full));
 827 
 828   if (table_size &gt; 0) {
 829     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));
 830   }
 831   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());
 832 
 833   return result;
 834 C2V_END
 835 
 836 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))
 837   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK);
 838   CompilerStatistics* stats = compiler-&gt;stats();
 839   stats-&gt;_standard.reset();
 840   stats-&gt;_osr.reset();
 841 C2V_END
 842 
 843 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))
 844   ResourceMark rm;
 845   HandleMark hm;
 846 
 847   if (installedCode == NULL) {
 848     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), "installedCode is null");
 849   }
 850 
 851   jlong codeBlob = InstalledCode::address(installedCode);
 852   if (codeBlob == 0L) {
 853     return NULL;
 854   }
 855 
 856   CodeBlob* cb = (CodeBlob*) (address) codeBlob;
 857   if (cb == NULL) {
 858     return NULL;
 859   }
 860 
 861   // We don't want the stringStream buffer to resize during disassembly as it
 862   // uses scoped resource memory. If a nested function called during disassembly uses
 863   // a ResourceMark and the buffer expands within the scope of the mark,
 864   // the buffer becomes garbage when that scope is exited. Experience shows that
 865   // the disassembled code is typically about 10x the code size so a fixed buffer
 866   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 867   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 868   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 869   stringStream st(buffer, bufferSize);
 870   if (cb-&gt;is_nmethod()) {
 871     nmethod* nm = (nmethod*) cb;
 872     if (!nm-&gt;is_alive()) {
 873       return NULL;
 874     }
 875   }
 876   Disassembler::decode(cb, &amp;st);
 877   if (st.size() &lt;= 0) {
 878     return NULL;
 879   }
 880 
 881   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);
 882   return JNIHandles::make_local(THREAD, result());
 883 C2V_END
 884 
 885 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))
 886   ResourceMark rm;
 887   HandleMark hm;
 888 
 889   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 890   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);
 891   return JNIHandles::make_local(THREAD, element);
 892 C2V_END
 893 
 894 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))
 895   ResourceMark rm;
 896   HandleMark hm;
 897 
 898   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);
 899   if (nmethodValue == 0L) {
 900     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
 901   }
 902   nmethod* nm = (nmethod*) (address) nmethodValue;
 903   methodHandle mh = nm-&gt;method();
 904   Symbol* signature = mh-&gt;signature();
 905   JavaCallArguments jca(mh-&gt;size_of_parameters());
 906 
 907   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
 908   JavaValue result(jap.get_ret_type());
 909   jca.set_alternative_target(nm);
 910   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
 911 
 912   if (jap.get_ret_type() == T_VOID) {
 913     return NULL;
 914   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
 915     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
 916   } else {
 917     jvalue *value = (jvalue *) result.get_value_addr();
 918     // Narrow the value down if required (Important on big endian machines)
 919     switch (jap.get_ret_type()) {
 920       case T_BOOLEAN:
 921        value-&gt;z = (jboolean) value-&gt;i;
 922        break;
 923       case T_BYTE:
 924        value-&gt;b = (jbyte) value-&gt;i;
 925        break;
 926       case T_CHAR:
 927        value-&gt;c = (jchar) value-&gt;i;
 928        break;
 929       case T_SHORT:
 930        value-&gt;s = (jshort) value-&gt;i;
 931        break;
 932      }
 933     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);
 934     return JNIHandles::make_local(THREAD, o);
 935   }
 936 C2V_END
 937 
 938 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))
 939   Method* method = CompilerToVM::asMethod(jvmci_method);
 940   if (!method-&gt;has_linenumber_table()) {
 941     return NULL;
 942   }
 943   u2 num_entries = 0;
 944   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
 945   while (streamForSize.read_pair()) {
 946     num_entries++;
 947   }
 948 
 949   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
 950   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);
 951 
 952   int i = 0;
 953   jlong value;
 954   while (stream.read_pair()) {
 955     value = ((long) stream.bci());
 956     result-&gt;long_at_put(i, value);
 957     value = ((long) stream.line());
 958     result-&gt;long_at_put(i + 1, value);
 959     i += 2;
 960   }
 961 
 962   return (jlongArray) JNIHandles::make_local(THREAD, result);
 963 C2V_END
 964 
 965 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 966   ResourceMark rm;
 967   Method* method = CompilerToVM::asMethod(jvmci_method);
 968   if (!method-&gt;has_localvariable_table()) {
 969     return 0;
 970   }
 971   return (jlong) (address) method-&gt;localvariable_table_start();
 972 C2V_END
 973 
 974 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 975   ResourceMark rm;
 976   Method* method = CompilerToVM::asMethod(jvmci_method);
 977   return method-&gt;localvariable_table_length();
 978 C2V_END
 979 
 980 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))
 981   Method* method = CompilerToVM::asMethod(jvmci_method);
 982   MethodCounters* mcs = method-&gt;method_counters();
 983   if (mcs != NULL) {
 984     mcs-&gt;clear_counters();
 985   }
 986   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
 987 
 988   CompiledMethod* code = method-&gt;code();
 989   if (code != NULL) {
 990     code-&gt;make_not_entrant();
 991   }
 992 
 993   MethodData* method_data = method-&gt;method_data();
 994   if (method_data == NULL) {
 995     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
 996     method_data = MethodData::allocate(loader_data, method, CHECK);
 997     method-&gt;set_method_data(method_data);
 998   } else {
 999     method_data-&gt;initialize();
1000   }
1001 C2V_END
1002 
1003 
1004 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))
1005   Handle installed_code_handle = JNIHandles::resolve(installed_code);
1006   nmethod::invalidate_installed_code(installed_code_handle, CHECK);
1007 C2V_END
1008 
1009 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))
1010   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);
1011   JavaThread::collect_counters(arrayOop);
1012   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);
1013 C2V_END
1014 
1015 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))
1016   HandleMark hm;
1017   ResourceMark rm;
1018   if (JNIHandles::resolve(jvmci_method) == NULL) {
1019     THROW_0(vmSymbols::java_lang_NullPointerException());
1020   }
1021   Method* method = CompilerToVM::asMethod(jvmci_method);
1022   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1023     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Unexpected bci %d", entry_bci));
1024   }
1025   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1026 C2V_END
1027 
1028 
1029 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))
1030   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1031   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1032 C2V_END
1033 
1034 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1035   Method* method = CompilerToVM::asMethod(jvmci_method);
1036   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1037 C2V_END
1038 
1039 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))
1040   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);
1041   return JNIHandles::make_local(THREAD, sym());
1042 C2V_END
1043 
1044 bool matches(jobjectArray methods, Method* method) {
1045   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1046 
1047   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1048     oop resolved = methods_oop-&gt;obj_at(i);
1049     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {
1050       return true;
1051     }
1052   }
1053   return false;
1054 }
1055 
1056 C2V_VMENTRY(jobject, getNextStackFrame, (JNIEnv*, jobject compilerToVM, jobject hs_frame, jobjectArray methods, jint initialSkip))
1057   ResourceMark rm;
1058 
1059   if (!thread-&gt;has_last_Java_frame()) return NULL;
1060   Handle result = HotSpotStackFrameReference::klass()-&gt;allocate_instance(thread);
1061   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1062 
1063   StackFrameStream fst(thread);
1064   if (hs_frame != NULL) {
1065     // look for the correct stack frame if one is given
1066     intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1067     while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1068       fst.next();
1069     }
1070     if (fst.current()-&gt;sp() != stack_pointer) {
1071       THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1072     }
1073   }
1074 
1075   int frame_number = 0;
1076   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1077   if (hs_frame != NULL) {
1078     // look for the correct vframe within the stack frame if one is given
1079     int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1080     while (frame_number &lt; last_frame_number) {
1081       if (vf-&gt;is_top()) {
1082         THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1083       }
1084       vf = vf-&gt;sender();
1085       frame_number ++;
1086     }
1087     // move one frame forward
1088     if (vf-&gt;is_top()) {
1089       if (fst.is_done()) {
1090         return NULL;
1091       }
1092       fst.next();
1093       vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1094       frame_number = 0;
1095     } else {
1096       vf = vf-&gt;sender();
1097       frame_number++;
1098     }
1099   }
1100 
1101   while (true) {
1102     // look for the given method
1103     while (true) {
1104       StackValueCollection* locals = NULL;
1105       if (vf-&gt;is_compiled_frame()) {
1106         // compiled method frame
1107         compiledVFrame* cvf = compiledVFrame::cast(vf);
1108         if (methods == NULL || matches(methods, cvf-&gt;method())) {
1109           if (initialSkip &gt; 0) {
1110             initialSkip --;
1111           } else {
1112             ScopeDesc* scope = cvf-&gt;scope();
1113             // native wrapper do not have a scope
1114             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1115               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), scope-&gt;objects(), THREAD);
1116               Deoptimization::reassign_fields(fst.current(), fst.register_map(), scope-&gt;objects(), realloc_failures, false);
1117 
1118               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1119               typeArrayHandle array = oopFactory::new_boolArray(local_values-&gt;length(), thread);
1120               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1121                 ScopeValue* value = local_values-&gt;at(i);
1122                 if (value-&gt;is_object()) {
1123                   array-&gt;bool_at_put(i, true);
1124                 }
1125               }
1126               HotSpotStackFrameReference::set_localIsVirtual(result, array());
1127             } else {
1128               HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1129             }
1130 
1131             locals = cvf-&gt;locals();
1132             HotSpotStackFrameReference::set_bci(result, cvf-&gt;bci());
1133             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);
1134             HotSpotStackFrameReference::set_method(result, method);
1135           }
1136         }
1137       } else if (vf-&gt;is_interpreted_frame()) {
1138         // interpreted method frame
1139         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1140         if (methods == NULL || matches(methods, ivf-&gt;method())) {
1141           if (initialSkip &gt; 0) {
1142             initialSkip --;
1143           } else {
1144             locals = ivf-&gt;locals();
1145             HotSpotStackFrameReference::set_bci(result, ivf-&gt;bci());
1146             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);
1147             HotSpotStackFrameReference::set_method(result, method);
1148             HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1149           }
1150         }
1151       }
1152 
1153       // locals != NULL means that we found a matching frame and result is already partially initialized
1154       if (locals != NULL) {
1155         HotSpotStackFrameReference::set_compilerToVM(result, JNIHandles::resolve(compilerToVM));
1156         HotSpotStackFrameReference::set_stackPointer(result, (jlong) fst.current()-&gt;sp());
1157         HotSpotStackFrameReference::set_frameNumber(result, frame_number);
1158 
1159         // initialize the locals array
1160         objArrayHandle array = oopFactory::new_objectArray(locals-&gt;size(), thread);
1161         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1162           StackValue* var = locals-&gt;at(i);
1163           if (var-&gt;type() == T_OBJECT) {
1164             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1165           }
1166         }
1167         HotSpotStackFrameReference::set_locals(result, array());
1168 
1169         return JNIHandles::make_local(thread, result());
1170       }
1171 
1172       if (vf-&gt;is_top()) {
1173         break;
1174       }
1175       frame_number++;
1176       vf = vf-&gt;sender();
1177     } // end of vframe loop
1178 
1179     if (fst.is_done()) {
1180       break;
1181     }
1182     fst.next();
1183     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1184     frame_number = 0;
1185   } // end of frame loop
1186 
1187   // the end was reached without finding a matching method
1188   return NULL;
1189 C2V_END
1190 
1191 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1192   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1193   CallInfo callInfo;
1194   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1195   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1196   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1197 C2V_END
1198 
1199 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1200   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1201   CallInfo callInfo;
1202   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1203   ConstantPoolCacheEntry* cp_cache_entry = cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1204   cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1205 C2V_END
1206 
1207 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))
1208   //see compute_recording_non_safepoints in debugInfroRec.cpp
1209   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1210     return true;
1211   }
1212   return DebugNonSafepoints;
1213 C2V_END
1214 
1215 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1216 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))
1217   ResourceMark rm;
1218 
1219   if (hs_frame == NULL) {
1220     THROW_MSG(vmSymbols::java_lang_NullPointerException(), "stack frame is null")
1221   }
1222 
1223   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1224 
1225   // look for the given stack frame
1226   StackFrameStream fst(thread);
1227   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1228   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1229     fst.next();
1230   }
1231   if (fst.current()-&gt;sp() != stack_pointer) {
1232     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1233   }
1234 
1235   if (invalidate) {
1236     if (!fst.current()-&gt;is_compiled_frame()) {
1237       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1238     }
1239     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), "nmethod expected");
1240     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1241   }
1242   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1243   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1244   StackFrameStream fstAfterDeopt(thread);
1245   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1246     fstAfterDeopt.next();
1247   }
1248   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1249     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found after deopt")
1250   }
1251 
1252   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1253   if (!vf-&gt;is_compiled_frame()) {
1254     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1255   }
1256 
1257   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1258   while (true) {
1259     assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1260     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1261     if (vf-&gt;is_top()) {
1262       break;
1263     }
1264     vf = vf-&gt;sender();
1265   }
1266 
1267   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1268   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1269     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1270   }
1271 
1272   // Reallocate the non-escaping objects and restore their fields.
1273   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,"invalid scope");
1274   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1275 
1276   if (objects == NULL) {
1277     // no objects to materialize
1278     return;
1279   }
1280 
1281   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, THREAD);
1282   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1283 
1284   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1285     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1286 
1287     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1288     StackValueCollection* locals = cvf-&gt;locals();
1289 
1290     if (locals != NULL) {
1291       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1292         StackValue* var = locals-&gt;at(i2);
1293         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1294           jvalue val;
1295           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1296           cvf-&gt;update_local(T_OBJECT, i2, val);
1297         }
1298       }
1299     }
1300   }
1301 
1302   // all locals are materialized by now
1303   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);
1304 
1305   // update the locals array
1306   objArrayHandle array = HotSpotStackFrameReference::locals(hs_frame);
1307   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1308   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1309     StackValue* var = locals-&gt;at(i);
1310     if (var-&gt;type() == T_OBJECT) {
1311       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1312     }
1313   }
1314 C2V_END
1315 
1316 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))
1317   if (bytes == NULL) {
1318     THROW(vmSymbols::java_lang_NullPointerException());
1319   }
1320   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);
1321 
1322   // Check if offset and length are non negative.
1323   if (offset &lt; 0 || length &lt; 0) {
1324     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1325   }
1326   // Check if the range is valid.
1327   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {
1328     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1329   }
1330   while (length &gt; 0) {
1331     jbyte* start = array-&gt;byte_at_addr(offset);
1332     tty-&gt;write((char*) start, MIN2(length, O_BUFLEN));
1333     length -= O_BUFLEN;
1334     offset += O_BUFLEN;
1335   }
1336 C2V_END
1337 
1338 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))
1339   tty-&gt;flush();
1340 C2V_END
1341 
1342 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))
1343   ResourceMark rm;
1344   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1345   ProfileData* profile_data = mdo-&gt;data_at(position);
1346   if (mdo-&gt;is_valid(profile_data)) {
1347     return profile_data-&gt;size_in_bytes();
1348   }
1349   DataLayout* data    = mdo-&gt;extra_data_base();
1350   DataLayout* end   = mdo-&gt;extra_data_limit();
1351   for (;; data = mdo-&gt;next_extra(data)) {
1352     assert(data &lt; end, "moved past end of extra data");
1353     profile_data = data-&gt;data_in();
1354     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1355       return profile_data-&gt;size_in_bytes();
1356     }
1357   }
1358   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Invalid profile data position %d", position));
1359 C2V_END
1360 
1361 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))
1362   if (bytecode_frame_handle == NULL) {
1363     THROW_0(vmSymbols::java_lang_NullPointerException());
1364   }
1365 
1366   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);
1367   oop bytecode_frame = top_bytecode_frame;
1368   int size = 0;
1369   int callee_parameters = 0;
1370   int callee_locals = 0;
1371   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1372   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);
1373 
1374   while (bytecode_frame != NULL) {
1375     int locks = BytecodeFrame::numLocks(bytecode_frame);
1376     int temps = BytecodeFrame::numStack(bytecode_frame);
1377     bool is_top_frame = (bytecode_frame == top_bytecode_frame);
1378     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1379 
1380     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1381                                                                  temps + callee_parameters,
1382                                                                  extra_args,
1383                                                                  locks,
1384                                                                  callee_parameters,
1385                                                                  callee_locals,
1386                                                                  is_top_frame);
1387     size += frame_size;
1388 
1389     callee_parameters = method-&gt;size_of_parameters();
1390     callee_locals = method-&gt;max_locals();
1391     extra_args = 0;
1392     bytecode_frame = BytecodePosition::caller(bytecode_frame);
1393   }
1394   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1395 C2V_END
1396 
1397 
1398 #define CC (char*)  /*cast a literal from (const char*)*/
1399 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1400 
1401 #define STRING                "Ljava/lang/String;"
1402 #define OBJECT                "Ljava/lang/Object;"
1403 #define CLASS                 "Ljava/lang/Class;"
1404 #define STACK_TRACE_ELEMENT   "Ljava/lang/StackTraceElement;"
1405 #define INSTALLED_CODE        "Ljdk/vm/ci/code/InstalledCode;"
1406 #define TARGET_DESCRIPTION    "Ljdk/vm/ci/code/TargetDescription;"
1407 #define BYTECODE_FRAME        "Ljdk/vm/ci/code/BytecodeFrame;"
1408 #define RESOLVED_METHOD       "Ljdk/vm/ci/meta/ResolvedJavaMethod;"
1409 #define HS_RESOLVED_METHOD    "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;"
1410 #define HS_RESOLVED_KLASS     "Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;"
1411 #define HS_CONSTANT_POOL      "Ljdk/vm/ci/hotspot/HotSpotConstantPool;"
1412 #define HS_COMPILED_CODE      "Ljdk/vm/ci/hotspot/HotSpotCompiledCode;"
1413 #define HS_CONFIG             "Ljdk/vm/ci/hotspot/HotSpotVMConfig;"
1414 #define HS_METADATA           "Ljdk/vm/ci/hotspot/HotSpotMetaData;"
1415 #define HS_STACK_FRAME_REF    "Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;"
1416 #define HS_SPECULATION_LOG    "Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;"
1417 #define METASPACE_METHOD_DATA "J"
1418 
1419 JNINativeMethod CompilerToVM::methods[] = {
1420   {CC "getBytecode",                                  CC "(" HS_RESOLVED_METHOD ")[B",                                                      FN_PTR(getBytecode)},
1421   {CC "getExceptionTableStart",                       CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getExceptionTableStart)},
1422   {CC "getExceptionTableLength",                      CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getExceptionTableLength)},
1423   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1424   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1425   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1426   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1427   {CC "doNotInlineOrCompile",                         CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(doNotInlineOrCompile)},
1428   {CC "canInlineMethod",                              CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(canInlineMethod)},
1429   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1430   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1431   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1432   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1433   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1434   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1435   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1436   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1437   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1438   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1439   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1440   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1441   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
1442   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "IB[J)" HS_RESOLVED_KLASS,                                    FN_PTR(resolveFieldInPool)},
1443   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1444   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1445   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1446   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1447   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1448   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1449   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1450   {CC "getResolvedJavaMethodAtSlot",                  CC "(" CLASS "I)" HS_RESOLVED_METHOD,                                                 FN_PTR(getResolvedJavaMethodAtSlot)},
1451   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1452   {CC "getConstantPool",                              CC "(Ljava/lang/Object;J)" HS_CONSTANT_POOL,                                          FN_PTR(getConstantPool)},
1453   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1454   {CC "initializeConfiguration",                      CC "(" HS_CONFIG ")J",                                                                FN_PTR(initializeConfiguration)},
1455   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1456   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1457   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1458   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1459   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1460   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1461   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1462   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1463   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1464   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1465   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1466   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1467   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1468   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1469   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1470   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1471   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1472   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1473   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1474   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1475   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1476   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1477 };
1478 
1479 int CompilerToVM::methods_count() {
1480   return sizeof(methods) / sizeof(JNINativeMethod);
1481 }
1482 
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="3" type="hidden" /></form></body></html>
