<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64 </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotJVMCIBackendFactory.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.amd64/src/jdk/vm/ci/hotspot/amd64/AMD64HotSpotJVMCIBackendFactory.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotRegisterConfig.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 179 
 180         allAllocatableAreCallerSaved = true;
 181         attributesMap = RegisterAttributes.createMap(this, AArch64.allRegisters);
 182     }
 183 
 184     @Override
 185     public Register[] getCallerSaveRegisters() {
 186         return callerSaved;
 187     }
 188 
 189     public Register[] getCalleeSaveRegisters() {
 190         return null;
 191     }
 192 
 193     @Override
 194     public boolean areAllAllocatableRegistersCallerSaved() {
 195         return allAllocatableAreCallerSaved;
 196     }
 197 
 198     @Override
<span class="removed"> 199     public Register getRegisterForRole(int index) {</span>
<span class="removed"> 200         throw new UnsupportedOperationException();</span>
<span class="removed"> 201     }</span>
<span class="removed"> 202 </span>
<span class="removed"> 203     @Override</span>
 204     public CallingConvention getCallingConvention(Type type, JavaType returnType, JavaType[] parameterTypes, ValueKindFactory&lt;?&gt; valueKindFactory) {
 205         HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
 206         if (type == HotSpotCallingConventionType.NativeCall) {
 207             return callingConvention(nativeGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);
 208         }
 209         // On x64, parameter locations are the same whether viewed
 210         // from the caller or callee perspective
 211         return callingConvention(javaGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);
 212     }
 213 
 214     @Override
 215     public Register[] getCallingConventionRegisters(Type type, JavaKind kind) {
 216         HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
 217         switch (kind) {
 218             case Boolean:
 219             case Byte:
 220             case Short:
 221             case Char:
 222             case Int:
 223             case Long:

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 179 
 180         allAllocatableAreCallerSaved = true;
 181         attributesMap = RegisterAttributes.createMap(this, AArch64.allRegisters);
 182     }
 183 
 184     @Override
 185     public Register[] getCallerSaveRegisters() {
 186         return callerSaved;
 187     }
 188 
 189     public Register[] getCalleeSaveRegisters() {
 190         return null;
 191     }
 192 
 193     @Override
 194     public boolean areAllAllocatableRegistersCallerSaved() {
 195         return allAllocatableAreCallerSaved;
 196     }
 197 
 198     @Override





 199     public CallingConvention getCallingConvention(Type type, JavaType returnType, JavaType[] parameterTypes, ValueKindFactory&lt;?&gt; valueKindFactory) {
 200         HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
 201         if (type == HotSpotCallingConventionType.NativeCall) {
 202             return callingConvention(nativeGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);
 203         }
 204         // On x64, parameter locations are the same whether viewed
 205         // from the caller or callee perspective
 206         return callingConvention(javaGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);
 207     }
 208 
 209     @Override
 210     public Register[] getCallingConventionRegisters(Type type, JavaKind kind) {
 211         HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
 212         switch (kind) {
 213             case Boolean:
 214             case Byte:
 215             case Short:
 216             case Char:
 217             case Int:
 218             case Long:

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotJVMCIBackendFactory.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.amd64/src/jdk/vm/ci/hotspot/amd64/AMD64HotSpotJVMCIBackendFactory.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
