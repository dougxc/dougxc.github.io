<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  30 
  31 import java.lang.annotation.Annotation;
  32 import java.lang.reflect.Array;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.Method;
  35 import java.lang.reflect.Modifier;
  36 import java.nio.ByteOrder;
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.HashMap;
  40 
  41 import jdk.vm.ci.common.JVMCIError;
  42 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  43 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  45 import jdk.vm.ci.meta.Assumptions.LeafType;
  46 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  47 import jdk.vm.ci.meta.Constant;
  48 import jdk.vm.ci.meta.JavaConstant;
  49 import jdk.vm.ci.meta.JavaKind;
  50 import jdk.vm.ci.meta.JavaType;
  51 import jdk.vm.ci.meta.ModifiersProvider;
  52 import jdk.vm.ci.meta.ResolvedJavaField;
  53 import jdk.vm.ci.meta.ResolvedJavaMethod;
  54 import jdk.vm.ci.meta.ResolvedJavaType;
  55 
  56 /**
  57  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.
  58  */
<a name="1" id="anc1"></a><span class="changed">  59 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceWrapperObject {</span>
  60 
  61     /**
  62      * The Java class this type represents.
  63      */
  64     private final Class&lt;?&gt; javaClass;
  65     private HashMap&lt;Long, HotSpotResolvedJavaField&gt; fieldCache;
  66     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCache;
  67     private HotSpotResolvedJavaField[] instanceFields;
  68     private HotSpotResolvedObjectTypeImpl[] interfaces;
  69     private HotSpotConstantPool constantPool;
  70     final HotSpotJVMCIMetaAccessContext context;
  71     private HotSpotResolvedObjectType arrayOfType;
  72 
  73     /**
  74      * Gets the JVMCI mirror for a {@link Class} object.
  75      *
  76      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}
  77      */
  78     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {
  79         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);
  80     }
  81 
  82     /**
  83      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the
  84      * underlying Klass*, it is used instead of the raw Klass*.
  85      *
  86      * Called from the VM.
  87      *
  88      * @param javaClass a {@link Class} object
  89      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
  90      */
  91     @SuppressWarnings("unused")
  92     private static HotSpotResolvedObjectTypeImpl fromMetaspace(Class&lt;?&gt; javaClass) {
  93         return fromObjectClass(javaClass);
  94     }
  95 
  96     /**
  97      * Creates the JVMCI mirror for a {@link Class} object.
  98      *
  99      * &lt;p&gt;
 100      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
 101      * {@link Class} type. Use {@link #fromObjectClass(Class)} or {@link #fromMetaspace(Class)}
 102      * instead.
 103      * &lt;/p&gt;
 104      *
 105      * @param javaClass the Class to create the mirror for
 106      * @param context
 107      */
 108     HotSpotResolvedObjectTypeImpl(Class&lt;?&gt; javaClass, HotSpotJVMCIMetaAccessContext context) {
 109         super(getSignatureName(javaClass));
 110         this.javaClass = javaClass;
 111         this.context = context;
 112         assert getName().charAt(0) != '[' || isArray() : getName();
 113     }
 114 
 115     /**
 116      * Returns the name of this type as it would appear in a signature.
 117      */
 118     private static String getSignatureName(Class&lt;?&gt; javaClass) {
 119         if (javaClass.isArray()) {
 120             return javaClass.getName().replace('.', '/');
 121         }
 122         return "L" + javaClass.getName().replace('.', '/') + ";";
 123     }
 124 
 125     /**
 126      * Gets the metaspace Klass for this type.
 127      */
 128     long getMetaspaceKlass() {
 129         if (HotSpotJVMCIRuntime.getHostWordKind() == JavaKind.Long) {
<a name="2" id="anc2"></a><span class="changed"> 130             return UNSAFE.getLong(javaClass, config().klassOffset);</span>
 131         }
<a name="3" id="anc3"></a><span class="changed"> 132         return UNSAFE.getInt(javaClass, config().klassOffset) &amp; 0xFFFFFFFFL;</span>
 133     }
 134 
 135     public long getMetaspacePointer() {
 136         return getMetaspaceKlass();
 137     }
 138 
 139     @Override
 140     public int getModifiers() {
 141         if (isArray()) {
 142             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 143         } else {
 144             return getAccessFlags() &amp; ModifiersProvider.jvmClassModifiers();
 145         }
 146     }
 147 
 148     public int getAccessFlags() {
 149         HotSpotVMConfig config = config();
 150         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 151     }
 152 
 153     @Override
 154     public HotSpotResolvedObjectType getArrayClass() {
 155         if (arrayOfType == null) {
 156             arrayOfType = fromObjectClass(Array.newInstance(mirror(), 0).getClass());
 157         }
 158         return arrayOfType;
 159     }
 160 
 161     @Override
 162     public ResolvedJavaType getComponentType() {
 163         Class&lt;?&gt; javaComponentType = mirror().getComponentType();
 164         return javaComponentType == null ? null : runtime().fromClass(javaComponentType);
 165     }
 166 
 167     @Override
 168     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 169         if (isLeaf()) {
 170             // No assumptions are required.
 171             return new AssumptionResult&lt;&gt;(this);
 172         }
 173         HotSpotVMConfig config = config();
 174         if (isArray()) {
 175             ResolvedJavaType elementalType = getElementalType();
 176             AssumptionResult&lt;ResolvedJavaType&gt; elementType = elementalType.findLeafConcreteSubtype();
 177             if (elementType != null &amp;&amp; elementType.getResult().equals(elementalType)) {
 178                 /*
 179                  * If the elementType is leaf then the array is leaf under the same assumptions but
 180                  * only if the element type is exactly the leaf type. The element type can be
 181                  * abstract even if there is only one implementor of the abstract type.
 182                  */
 183                 AssumptionResult&lt;ResolvedJavaType&gt; result = new AssumptionResult&lt;&gt;(this);
 184                 result.add(elementType);
 185                 return result;
 186             }
 187             return null;
 188         } else if (isInterface()) {
 189             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
 190             /*
 191              * If the implementor field contains itself that indicates that the interface has more
 192              * than one implementors (see: InstanceKlass::add_implementor).
 193              */
 194             if (implementor == null || implementor.equals(this)) {
 195                 return null;
 196             }
 197 
 198             assert !implementor.isInterface();
 199             if (implementor.isAbstract() || !implementor.isLeafClass()) {
 200                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
 201                 if (leafConcreteSubtype != null) {
 202                     assert !leafConcreteSubtype.getResult().equals(implementor);
 203                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
 204                     // Accumulate leaf assumptions and return the combined result.
 205                     newResult.add(leafConcreteSubtype);
 206                     return newResult;
 207                 }
 208                 return null;
 209             }
 210             return concreteSubtype(implementor);
 211         } else {
 212             HotSpotResolvedObjectTypeImpl type = this;
 213             while (type.isAbstract()) {
 214                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
 215                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
 216                     return null;
 217                 }
 218                 type = subklass;
 219             }
 220             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
 221                 return null;
 222             }
 223             if (this.isAbstract()) {
 224                 return concreteSubtype(type);
 225             } else {
 226                 assert this.equals(type);
 227                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 228             }
 229         }
 230     }
 231 
 232     private AssumptionResult&lt;ResolvedJavaType&gt; concreteSubtype(HotSpotResolvedObjectTypeImpl type) {
 233         if (type.isLeaf()) {
 234             return new AssumptionResult&lt;&gt;(type, new ConcreteSubtype(this, type));
 235         } else {
 236             return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 237         }
 238     }
 239 
 240     /**
 241      * Returns if type {@code type} is a leaf class. This is the case if the
 242      * {@code Klass::_subklass} field of the underlying class is zero.
 243      *
 244      * @return true if the type is a leaf class
 245      */
 246     private boolean isLeafClass() {
 247         return getSubklass() == null;
 248     }
 249 
 250     /**
 251      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 252      * type {@code type}.
 253      *
 254      * @return value of the subklass field as metaspace klass pointer
 255      */
 256     private HotSpotResolvedObjectTypeImpl getSubklass() {
 257         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 258     }
 259 
 260     @Override
 261     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 262         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();
 263         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);
 264     }
 265 
 266     @Override
 267     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 268         if (interfaces == null) {
 269             Class&lt;?&gt;[] javaInterfaces = mirror().getInterfaces();
 270             HotSpotResolvedObjectTypeImpl[] result = new HotSpotResolvedObjectTypeImpl[javaInterfaces.length];
 271             for (int i = 0; i &lt; javaInterfaces.length; i++) {
 272                 result[i] = fromObjectClass(javaInterfaces[i]);
 273             }
 274             interfaces = result;
 275         }
 276         return interfaces;
 277     }
 278 
 279     @Override
 280     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 281         if (!isInterface()) {
 282             throw new JVMCIError("Cannot call getSingleImplementor() on a non-interface type: %s", this);
 283         }
 284         return compilerToVM().getImplementor(this);
 285     }
 286 
 287     public HotSpotResolvedObjectTypeImpl getSupertype() {
 288         if (isArray()) {
 289             ResolvedJavaType componentType = getComponentType();
 290             if (mirror() == Object[].class || componentType.isPrimitive()) {
 291                 return fromObjectClass(Object.class);
 292             }
 293             return (HotSpotResolvedObjectTypeImpl) ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype().getArrayClass();
 294         }
 295         if (isInterface()) {
 296             return fromObjectClass(Object.class);
 297         }
 298         return getSuperclass();
 299     }
 300 
 301     @Override
 302     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 303         if (otherType.isPrimitive()) {
 304             return null;
 305         } else {
 306             HotSpotResolvedObjectTypeImpl t1 = this;
 307             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 308             while (true) {
 309                 if (t1.isAssignableFrom(t2)) {
 310                     return t1;
 311                 }
 312                 if (t2.isAssignableFrom(t1)) {
 313                     return t2;
 314                 }
 315                 t1 = t1.getSupertype();
 316                 t2 = t2.getSupertype();
 317             }
 318         }
 319     }
 320 
 321     @Override
<a name="4" id="anc4"></a>




 322     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 323         assert !isArray();
 324         if (!compilerToVM().hasFinalizableSubclass(this)) {
 325             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 326         }
 327         return new AssumptionResult&lt;&gt;(true);
 328     }
 329 
 330     @Override
 331     public boolean hasFinalizer() {
 332         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 333     }
 334 
 335     @Override
 336     public boolean isPrimitive() {
 337         return false;
 338     }
 339 
 340     @Override
 341     public boolean isArray() {
 342         return mirror().isArray();
 343     }
 344 
 345     @Override
 346     public boolean isInitialized() {
 347         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 348     }
 349 
 350     @Override
 351     public boolean isLinked() {
 352         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 353     }
 354 
 355     /**
 356      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 357      * klass.
 358      *
 359      * @return state field value of this type
 360      */
 361     private int getInitState() {
 362         assert !isArray() : "_init_state only exists in InstanceKlass";
 363         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 364     }
 365 
 366     @Override
 367     public void initialize() {
 368         if (!isInitialized()) {
 369             UNSAFE.ensureClassInitialized(mirror());
 370             assert isInitialized();
 371         }
 372     }
 373 
 374     @Override
 375     public boolean isInstance(JavaConstant obj) {
 376         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
 377             return mirror().isInstance(((HotSpotObjectConstantImpl) obj).object());
 378         }
 379         return false;
 380     }
 381 
 382     @Override
 383     public boolean isInstanceClass() {
 384         return !isArray() &amp;&amp; !isInterface();
 385     }
 386 
 387     @Override
 388     public boolean isInterface() {
 389         return mirror().isInterface();
 390     }
 391 
 392     @Override
 393     public boolean isAssignableFrom(ResolvedJavaType other) {
 394         assert other != null;
 395         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 396             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
 397             return mirror().isAssignableFrom(otherType.mirror());
 398         }
 399         return false;
 400     }
 401 
 402     @Override
 403     public boolean isJavaLangObject() {
 404         return javaClass.equals(Object.class);
 405     }
 406 
 407     @Override
 408     public JavaKind getJavaKind() {
 409         return JavaKind.Object;
 410     }
 411 
 412     @Override
 413     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 414         assert !callerType.isArray();
 415         if (isInterface()) {
 416             // Methods can only be resolved against concrete types
 417             return null;
 418         }
 419         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic()) {
 420             return method;
 421         }
 422         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 423             return null;
 424         }
 425         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
 426         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
 427         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
 428     }
 429 
 430     public HotSpotConstantPool getConstantPool() {
 431         if (constantPool == null) {
 432             constantPool = compilerToVM().getConstantPool(this, config().instanceKlassConstantsOffset);
 433         }
 434         return constantPool;
 435     }
 436 
 437     /**
 438      * Gets the instance size of this type. If an instance of this type cannot be fast path
 439      * allocated, then the returned value is negative (its absolute value gives the size). Must not
 440      * be called if this is an array or interface type.
 441      */
 442     public int instanceSize() {
 443         assert !isArray();
 444         assert !isInterface();
 445 
 446         HotSpotVMConfig config = config();
 447         final int layoutHelper = layoutHelper();
 448         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : "must be instance";
 449 
 450         // See: Klass::layout_helper_size_in_bytes
 451         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 452 
 453         // See: Klass::layout_helper_needs_slow_path
 454         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 455 
 456         return needsSlowPath ? -size : size;
 457     }
 458 
 459     public int layoutHelper() {
 460         HotSpotVMConfig config = config();
 461         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 462     }
 463 
 464     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {
 465         HotSpotResolvedJavaMethodImpl method = null;
 466         if (methodCache == null) {
 467             methodCache = new HashMap&lt;&gt;(8);
 468         } else {
 469             method = methodCache.get(metaspaceMethod);
 470         }
 471         if (method == null) {
 472             method = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);
 473             methodCache.put(metaspaceMethod, method);
 474             context.add(method);
 475         }
 476         return method;
 477     }
 478 
 479     public int getVtableLength() {
 480         HotSpotVMConfig config = config();
 481         if (isInterface() || isArray()) {
 482             /* Everything has the core vtable of java.lang.Object */
 483             return config.baseVtableLength();
 484         }
 485         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 486         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + " " + config.vtableEntrySize;
 487         return result;
 488     }
 489 
 490     synchronized HotSpotResolvedJavaField createField(String fieldName, JavaType type, long offset, int rawFlags) {
 491         HotSpotResolvedJavaField result = null;
 492 
 493         final int flags = rawFlags &amp; ModifiersProvider.jvmFieldModifiers();
 494 
 495         final long id = offset + ((long) flags &lt;&lt; 32);
 496 
 497         // Must cache the fields, because the local load elimination only works if the
 498         // objects from two field lookups are identical.
 499         if (fieldCache == null) {
 500             fieldCache = new HashMap&lt;&gt;(8);
 501         } else {
 502             result = fieldCache.get(id);
 503         }
 504 
 505         if (result == null) {
 506             result = new HotSpotResolvedJavaFieldImpl(this, fieldName, type, offset, rawFlags);
 507             fieldCache.put(id, result);
 508         } else {
 509             assert result.getName().equals(fieldName);
 510             /*
 511              * Comparing the types directly is too strict, because the type in the cache could be
 512              * resolved while the incoming type is unresolved. The name comparison is sufficient
 513              * because the type will always be resolved in the context of the holder.
 514              */
 515             assert result.getType().getName().equals(type.getName());
 516             assert result.offset() == offset;
 517             assert result.getModifiers() == flags;
 518         }
 519 
 520         return result;
 521     }
 522 
 523     @Override
 524     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 525         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 526         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 527         /*
 528          * Sometimes the receiver type in the graph hasn't stabilized to a subtype of declared
 529          * holder, usually because of phis, so make sure that the type is related to the declared
 530          * type before using it for lookup. Unlinked types should also be ignored because we can't
 531          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 532          * a deopt instead since they can't really be used if they aren't linked yet.
 533          */
 534         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 535             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 536             if (result != null) {
 537                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 538             }
 539             return null;
 540         }
 541         /*
 542          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 543          * the correct method for the subtype.
 544          */
 545         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 546         if (resolvedMethod == null) {
 547             // The type isn't known to implement the method.
 548             return null;
 549         }
 550 
 551         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 552         if (result != null) {
 553             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 554         }
 555         return null;
 556     }
 557 
 558     /**
 559      * This class represents the field information for one field contained in the fields array of an
 560      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 561      */
 562     private class FieldInfo {
 563         /**
 564          * Native pointer into the array of Java shorts.
 565          */
 566         private final long metaspaceData;
 567 
 568         /**
 569          * Creates a field info for the field in the fields array at index {@code index}.
 570          *
 571          * @param index index to the fields array
 572          */
 573         FieldInfo(int index) {
 574             HotSpotVMConfig config = config();
 575             // Get Klass::_fields
 576             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 577             assert config.fieldInfoFieldSlots == 6 : "revisit the field parsing code";
 578             metaspaceData = metaspaceFields + config.arrayU2DataOffset + config.fieldInfoFieldSlots * Short.BYTES * index;
 579         }
 580 
 581         private int getAccessFlags() {
 582             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
 583         }
 584 
 585         private int getNameIndex() {
 586             return readFieldSlot(config().fieldInfoNameIndexOffset);
 587         }
 588 
 589         private int getSignatureIndex() {
 590             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
 591         }
 592 
 593         public int getOffset() {
 594             HotSpotVMConfig config = config();
 595             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
 596             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
 597             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
 598             return offset;
 599         }
 600 
 601         /**
 602          * Helper method to read an entry (slot) from the field array. Currently field info is laid
 603          * on top an array of Java shorts.
 604          */
 605         private int readFieldSlot(int index) {
 606             return UNSAFE.getChar(metaspaceData + Short.BYTES * index);
 607         }
 608 
 609         /**
 610          * Returns the name of this field as a {@link String}. If the field is an internal field the
 611          * name index is pointing into the vmSymbols table.
 612          */
 613         public String getName() {
 614             final int nameIndex = getNameIndex();
 615             return isInternal() ? HotSpotVmSymbols.symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
 616         }
 617 
 618         /**
 619          * Returns the signature of this field as {@link String}. If the field is an internal field
 620          * the signature index is pointing into the vmSymbols table.
 621          */
 622         public String getSignature() {
 623             final int signatureIndex = getSignatureIndex();
 624             return isInternal() ? HotSpotVmSymbols.symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
 625         }
 626 
 627         public JavaType getType() {
 628             String signature = getSignature();
 629             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 630         }
 631 
 632         private boolean isInternal() {
 633             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 634         }
 635 
 636         public boolean isStatic() {
 637             return Modifier.isStatic(getAccessFlags());
 638         }
 639 
 640         public boolean hasGenericSignature() {
 641             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 642         }
 643     }
 644 
 645     private static class OffsetComparator implements java.util.Comparator&lt;HotSpotResolvedJavaField&gt; {
 646         @Override
 647         public int compare(HotSpotResolvedJavaField o1, HotSpotResolvedJavaField o2) {
 648             return o1.offset() - o2.offset();
 649         }
 650     }
 651 
 652     @Override
 653     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 654         if (instanceFields == null) {
 655             if (isArray() || isInterface()) {
 656                 instanceFields = new HotSpotResolvedJavaField[0];
 657             } else {
 658                 final int fieldCount = getFieldCount();
 659                 ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 660 
 661                 for (int i = 0; i &lt; fieldCount; i++) {
 662                     FieldInfo field = new FieldInfo(i);
 663 
 664                     // We are only interested in instance fields.
 665                     if (!field.isStatic()) {
 666                         HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 667                         fieldsArray.add(resolvedJavaField);
 668                     }
 669                 }
 670 
 671                 fieldsArray.sort(new OffsetComparator());
 672 
 673                 HotSpotResolvedJavaField[] myFields = fieldsArray.toArray(new HotSpotResolvedJavaField[0]);
 674 
 675                 if (mirror() != Object.class) {
 676                     HotSpotResolvedJavaField[] superFields = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 677                     HotSpotResolvedJavaField[] fields = Arrays.copyOf(superFields, superFields.length + myFields.length);
 678                     System.arraycopy(myFields, 0, fields, superFields.length, myFields.length);
 679                     instanceFields = fields;
 680                 } else {
 681                     assert myFields.length == 0 : "java.lang.Object has fields!";
 682                     instanceFields = myFields;
 683                 }
 684 
 685             }
 686         }
 687         if (!includeSuperclasses) {
 688             int myFieldsStart = 0;
 689             while (myFieldsStart &lt; instanceFields.length &amp;&amp; !instanceFields[myFieldsStart].getDeclaringClass().equals(this)) {
 690                 myFieldsStart++;
 691             }
 692             if (myFieldsStart == 0) {
 693                 return instanceFields;
 694             }
 695             if (myFieldsStart == instanceFields.length) {
 696                 return new HotSpotResolvedJavaField[0];
 697             }
 698             return Arrays.copyOfRange(instanceFields, myFieldsStart, instanceFields.length);
 699         }
 700         return instanceFields;
 701     }
 702 
 703     @Override
 704     public ResolvedJavaField[] getStaticFields() {
 705         if (isArray()) {
 706             return new HotSpotResolvedJavaField[0];
 707         } else {
 708             final int fieldCount = getFieldCount();
 709             ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 710 
 711             for (int i = 0; i &lt; fieldCount; i++) {
 712                 FieldInfo field = new FieldInfo(i);
 713 
 714                 // We are only interested in static fields.
 715                 if (field.isStatic()) {
 716                     HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 717                     fieldsArray.add(resolvedJavaField);
 718                 }
 719             }
 720 
 721             fieldsArray.sort(new OffsetComparator());
 722             return fieldsArray.toArray(new HotSpotResolvedJavaField[fieldsArray.size()]);
 723         }
 724     }
 725 
 726     /**
 727      * Returns the actual field count of this class's internal {@code InstanceKlass::_fields} array
 728      * by walking the array and discounting the generic signature slots at the end of the array.
 729      *
 730      * &lt;p&gt;
 731      * See {@code FieldStreamBase::init_generic_signature_start_slot}
 732      */
 733     private int getFieldCount() {
 734         HotSpotVMConfig config = config();
 735         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 736         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
 737         int fieldCount = 0;
 738 
 739         for (int i = 0, index = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
 740             FieldInfo field = new FieldInfo(index);
 741             if (field.hasGenericSignature()) {
 742                 metaspaceFieldsLength--;
 743             }
 744             fieldCount++;
 745         }
 746         return fieldCount;
 747     }
 748 
 749     @Override
 750     public Class&lt;?&gt; mirror() {
 751         return javaClass;
 752     }
 753 
 754     @Override
 755     public String getSourceFileName() {
 756         HotSpotVMConfig config = config();
 757         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
 758         if (sourceFileNameIndex == 0) {
 759             return null;
 760         }
 761         return getConstantPool().lookupUtf8(sourceFileNameIndex);
 762     }
 763 
 764     @Override
 765     public Annotation[] getAnnotations() {
 766         return mirror().getAnnotations();
 767     }
 768 
 769     @Override
 770     public Annotation[] getDeclaredAnnotations() {
 771         return mirror().getDeclaredAnnotations();
 772     }
 773 
 774     @Override
 775     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 776         return mirror().getAnnotation(annotationClass);
 777     }
 778 
 779     /**
 780      * Performs a fast-path check that this type is resolved in the context of a given accessing
 781      * class. A negative result does not mean this type is not resolved with respect to
 782      * {@code accessingClass}. That can only be determined by
 783      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 784      * re-resolving} the type.
 785      */
 786     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 787         assert accessingClass != null;
 788         ResolvedJavaType elementType = getElementalType();
 789         if (elementType.isPrimitive()) {
 790             // Primitive type resolution is context free.
 791             return true;
 792         }
 793         if (elementType.getName().startsWith("Ljava/")) {
 794             // Classes in a java.* package can only be defined by the
 795             // boot class loader. This is enforced by ClassLoader.preDefineClass()
 796             assert mirror().getClassLoader() == null;
 797             return true;
 798         }
 799         ClassLoader thisCl = mirror().getClassLoader();
 800         ClassLoader accessingClassCl = ((HotSpotResolvedObjectTypeImpl) accessingClass).mirror().getClassLoader();
 801         return thisCl == accessingClassCl;
 802     }
 803 
 804     @Override
 805     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 806         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 807             return this;
 808         }
 809         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 810         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 811     }
 812 
 813     /**
 814      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 815      */
 816     public Constant klass() {
 817         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 818     }
 819 
 820     public boolean isPrimaryType() {
 821         return config().secondarySuperCacheOffset != superCheckOffset();
 822     }
 823 
 824     public int superCheckOffset() {
 825         HotSpotVMConfig config = config();
 826         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
 827     }
 828 
 829     public long prototypeMarkWord() {
 830         HotSpotVMConfig config = config();
 831         if (isArray()) {
 832             return config.arrayPrototypeMarkWord();
 833         } else {
 834             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 835         }
 836     }
 837 
 838     @Override
 839     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 840         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 841         for (ResolvedJavaField field : declaredFields) {
 842             HotSpotResolvedJavaField resolvedField = (HotSpotResolvedJavaField) field;
 843             long resolvedFieldOffset = resolvedField.offset();
 844             // @formatter:off
 845             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN  &amp;&amp;
 846                             expectedEntryKind.isPrimitive() &amp;&amp;
 847                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;
 848                             resolvedField.getJavaKind().isPrimitive()) {
 849                 resolvedFieldOffset +=
 850                                 resolvedField.getJavaKind().getByteCount() -
 851                                 Math.min(resolvedField.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());
 852             }
 853             if (resolvedFieldOffset == offset) {
 854                 return field;
 855             }
 856             // @formatter:on
 857         }
 858         return null;
 859     }
 860 
 861     @Override
 862     public boolean isLocal() {
 863         return mirror().isLocalClass();
 864     }
 865 
 866     @Override
 867     public boolean isMember() {
 868         return mirror().isMemberClass();
 869     }
 870 
 871     @Override
 872     public HotSpotResolvedObjectTypeImpl getEnclosingType() {
 873         final Class&lt;?&gt; encl = mirror().getEnclosingClass();
 874         return encl == null ? null : fromObjectClass(encl);
 875     }
 876 
 877     @Override
 878     public ResolvedJavaMethod[] getDeclaredConstructors() {
 879         Constructor&lt;?&gt;[] constructors = mirror().getDeclaredConstructors();
 880         ResolvedJavaMethod[] result = new ResolvedJavaMethod[constructors.length];
 881         for (int i = 0; i &lt; constructors.length; i++) {
 882             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(constructors[i]);
 883             assert result[i].isConstructor();
 884         }
 885         return result;
 886     }
 887 
 888     @Override
 889     public ResolvedJavaMethod[] getDeclaredMethods() {
 890         Method[] methods = mirror().getDeclaredMethods();
 891         ResolvedJavaMethod[] result = new ResolvedJavaMethod[methods.length];
 892         for (int i = 0; i &lt; methods.length; i++) {
 893             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(methods[i]);
 894             assert !result[i].isConstructor();
 895         }
 896         return result;
 897     }
 898 
 899     public ResolvedJavaMethod getClassInitializer() {
 900         return compilerToVM().getClassInitializer(this);
 901     }
 902 
 903     @Override
 904     public String toString() {
 905         return "HotSpotType&lt;" + getName() + ", resolved&gt;";
 906     }
 907 
 908     @Override
 909     public boolean isCloneableWithAllocation() {
 910         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
 911     }
 912 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="5" type="hidden" /></form></body></html>
