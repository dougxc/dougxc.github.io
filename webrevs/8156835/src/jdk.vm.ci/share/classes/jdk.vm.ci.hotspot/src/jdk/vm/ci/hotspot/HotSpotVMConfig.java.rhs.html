<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
<a name="1" id="anc1"></a>
  25 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  26 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  27 
  28 import java.lang.reflect.Field;
  29 import java.lang.reflect.Modifier;
  30 import java.util.HashMap;
  31 import java.util.Iterator;
  32 
<a name="2" id="anc2"></a><span class="new">  33 import jdk.internal.misc.Unsafe;</span>
  34 import jdk.internal.vm.annotation.Stable;
  35 import jdk.vm.ci.common.JVMCIError;
  36 import jdk.vm.ci.hotspotvmconfig.HotSpotVMAddress;
  37 import jdk.vm.ci.hotspotvmconfig.HotSpotVMConstant;
  38 import jdk.vm.ci.hotspotvmconfig.HotSpotVMData;
  39 import jdk.vm.ci.hotspotvmconfig.HotSpotVMField;
  40 import jdk.vm.ci.hotspotvmconfig.HotSpotVMFlag;
  41 import jdk.vm.ci.hotspotvmconfig.HotSpotVMType;
<a name="3" id="anc3"></a>


  42 
  43 /**
  44  * Used to access native configuration details.
  45  *
  46  * All non-static, public fields in this class are so that they can be compiled as constants.
  47  */
  48 public class HotSpotVMConfig {
  49 
  50     /**
  51      * Gets the configuration associated with the singleton {@link HotSpotJVMCIRuntime}.
  52      */
  53     public static HotSpotVMConfig config() {
  54         return runtime().getConfig();
  55     }
  56 
  57     /**
  58      * Maximum allowed size of allocated area for a frame.
  59      */
  60     public final int maxFrameSize = 16 * 1024;
  61 
  62     public HotSpotVMConfig(CompilerToVM compilerToVm) {
  63         // Get raw pointer to the array that contains all gHotSpotVM values.
  64         final long gHotSpotVMData = compilerToVm.initializeConfiguration(this);
  65         assert gHotSpotVMData != 0;
  66 
  67         // Make FindBugs happy.
  68         jvmciHotSpotVMStructs = 0;
  69         jvmciHotSpotVMTypes = 0;
  70         jvmciHotSpotVMIntConstants = 0;
  71         jvmciHotSpotVMLongConstants = 0;
  72         jvmciHotSpotVMAddresses = 0;
  73 
  74         // Initialize the gHotSpotVM fields.
  75         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
  76             if (f.isAnnotationPresent(HotSpotVMData.class)) {
  77                 HotSpotVMData annotation = f.getAnnotation(HotSpotVMData.class);
  78                 final int index = annotation.index();
  79                 final long value = UNSAFE.getAddress(gHotSpotVMData + Unsafe.ADDRESS_SIZE * index);
  80                 try {
  81                     f.setLong(this, value);
  82                 } catch (IllegalAccessException e) {
  83                     throw new JVMCIError("index " + index, e);
  84                 }
  85             }
  86         }
  87 
  88         // Quick sanity check.
  89         assert jvmciHotSpotVMStructs != 0;
  90         assert jvmciHotSpotVMTypes != 0;
  91         assert jvmciHotSpotVMIntConstants != 0;
  92         assert jvmciHotSpotVMLongConstants != 0;
  93         assert jvmciHotSpotVMAddresses != 0;
  94 
  95         initialize();
  96 
  97         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift, logMinObjAlignment());
  98         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift, logKlassAlignment);
  99 
 100         assert check();
 101         assert HotSpotVMConfigVerifier.check();
 102     }
 103 
 104     @Override
 105     public String toString() {
 106         return getClass().getSimpleName();
 107     }
 108 
 109     /**
<a name="4" id="anc4"></a><span class="new"> 110      * Reads a {@code '\0'} terminated C string from native memory and converts it to a</span>
<span class="new"> 111      * {@link String}.</span>
<span class="new"> 112      *</span>
<span class="new"> 113      * @return a Java string</span>
<span class="new"> 114      */</span>
<span class="new"> 115     private static String readCString(Unsafe unsafe, long address) {</span>
<span class="new"> 116         if (address == 0) {</span>
<span class="new"> 117             return null;</span>
<span class="new"> 118         }</span>
<span class="new"> 119         StringBuilder sb = new StringBuilder();</span>
<span class="new"> 120         for (int i = 0;; i++) {</span>
<span class="new"> 121             char c = (char) unsafe.getByte(address + i);</span>
<span class="new"> 122             if (c == 0) {</span>
<span class="new"> 123                 break;</span>
<span class="new"> 124             }</span>
<span class="new"> 125             sb.append(c);</span>
<span class="new"> 126         }</span>
<span class="new"> 127         return sb.toString();</span>
<span class="new"> 128     }</span>
<span class="new"> 129 </span>
<span class="new"> 130     /**</span>
 131      * Initialize fields by reading their values from vmStructs.
 132      */
 133     private void initialize() {
 134         // Fill the VM fields hash map.
 135         HashMap&lt;String, VMFields.Field&gt; vmFields = new HashMap&lt;&gt;();
 136         for (VMFields.Field e : new VMFields(jvmciHotSpotVMStructs)) {
 137             vmFields.put(e.getName(), e);
 138         }
 139 
 140         // Fill the VM types hash map.
 141         HashMap&lt;String, VMTypes.Type&gt; vmTypes = new HashMap&lt;&gt;();
 142         for (VMTypes.Type e : new VMTypes(jvmciHotSpotVMTypes)) {
 143             vmTypes.put(e.getTypeName(), e);
 144         }
 145 
 146         // Fill the VM constants hash map.
 147         HashMap&lt;String, AbstractConstant&gt; vmConstants = new HashMap&lt;&gt;();
 148         for (AbstractConstant e : new VMIntConstants(jvmciHotSpotVMIntConstants)) {
 149             vmConstants.put(e.getName(), e);
 150         }
 151         for (AbstractConstant e : new VMLongConstants(jvmciHotSpotVMLongConstants)) {
 152             vmConstants.put(e.getName(), e);
 153         }
 154 
 155         // Fill the VM addresses hash map.
 156         HashMap&lt;String, VMAddresses.Address&gt; vmAddresses = new HashMap&lt;&gt;();
 157         for (VMAddresses.Address e : new VMAddresses(jvmciHotSpotVMAddresses)) {
 158             vmAddresses.put(e.getName(), e);
 159         }
 160 
 161         // Fill the flags hash map.
 162         HashMap&lt;String, Flags.Flag&gt; flags = new HashMap&lt;&gt;();
 163         for (Flags.Flag e : new Flags(vmFields, vmTypes)) {
 164             flags.put(e.getName(), e);
 165         }
 166 
 167         String osName = getHostOSName();
 168         String osArch = getHostArchitectureName();
 169 
 170         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
 171             if (f.isAnnotationPresent(HotSpotVMField.class)) {
 172                 HotSpotVMField annotation = f.getAnnotation(HotSpotVMField.class);
 173                 String name = annotation.name();
 174                 String type = annotation.type();
 175                 VMFields.Field entry = vmFields.get(name);
 176                 if (entry == null) {
 177                     if (!isRequired(osArch, annotation.archs())) {
 178                         continue;
 179                     }
 180                     throw new JVMCIError(f.getName() + ": expected VM field not found: " + name);
 181                 }
 182 
 183                 // Make sure the native type is still the type we expect.
 184                 if (!type.isEmpty()) {
 185                     if (!type.equals(entry.getTypeString())) {
 186                         throw new JVMCIError(f.getName() + ": compiler expects type " + type + " but VM field " + name + " is of type " + entry.getTypeString());
 187                     }
 188                 }
 189 
 190                 switch (annotation.get()) {
 191                     case OFFSET:
 192                         setField(f, entry.getOffset());
 193                         break;
 194                     case ADDRESS:
 195                         setField(f, entry.getAddress());
 196                         break;
 197                     case VALUE:
 198                         setField(f, entry.getValue());
 199                         break;
 200                     default:
 201                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
 202                 }
 203             } else if (f.isAnnotationPresent(HotSpotVMType.class)) {
 204                 HotSpotVMType annotation = f.getAnnotation(HotSpotVMType.class);
 205                 String name = annotation.name();
 206                 VMTypes.Type entry = vmTypes.get(name);
 207                 if (entry == null) {
 208                     throw new JVMCIError(f.getName() + ": expected VM type not found: " + name);
 209                 }
 210 
 211                 switch (annotation.get()) {
 212                     case SIZE:
 213                         setField(f, entry.getSize());
 214                         break;
 215                     default:
 216                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
 217                 }
 218             } else if (f.isAnnotationPresent(HotSpotVMConstant.class)) {
 219                 HotSpotVMConstant annotation = f.getAnnotation(HotSpotVMConstant.class);
 220                 String name = annotation.name();
 221                 AbstractConstant entry = vmConstants.get(name);
 222                 if (entry == null) {
 223                     if (!isRequired(osArch, annotation.archs())) {
 224                         continue;
 225                     }
 226                     throw new JVMCIError(f.getName() + ": expected VM constant not found: " + name);
 227                 }
 228                 setField(f, entry.getValue());
 229             } else if (f.isAnnotationPresent(HotSpotVMAddress.class)) {
 230                 HotSpotVMAddress annotation = f.getAnnotation(HotSpotVMAddress.class);
 231                 String name = annotation.name();
 232                 VMAddresses.Address entry = vmAddresses.get(name);
 233                 if (entry == null) {
 234                     if (!isRequired(osName, annotation.os())) {
 235                         continue;
 236                     }
 237                     throw new JVMCIError(f.getName() + ": expected VM address not found: " + name);
 238                 }
 239                 setField(f, entry.getValue());
 240             } else if (f.isAnnotationPresent(HotSpotVMFlag.class)) {
 241                 HotSpotVMFlag annotation = f.getAnnotation(HotSpotVMFlag.class);
 242                 String name = annotation.name();
 243                 Flags.Flag entry = flags.get(name);
 244                 if (entry == null) {
 245                     if (annotation.optional() || !isRequired(osArch, annotation.archs())) {
 246                         continue;
 247                     }
 248                     throw new JVMCIError(f.getName() + ": expected VM flag not found: " + name);
 249 
 250                 }
 251                 setField(f, entry.getValue());
 252             }
 253         }
 254     }
 255 
 256     private final CompressEncoding oopEncoding;
 257     private final CompressEncoding klassEncoding;
 258 
 259     public CompressEncoding getOopEncoding() {
 260         return oopEncoding;
 261     }
 262 
 263     public CompressEncoding getKlassEncoding() {
 264         return klassEncoding;
 265     }
 266 
 267     private void setField(Field field, Object value) {
 268         try {
 269             Class&lt;?&gt; fieldType = field.getType();
 270             if (fieldType == boolean.class) {
 271                 if (value instanceof String) {
 272                     field.setBoolean(this, Boolean.valueOf((String) value));
 273                 } else if (value instanceof Boolean) {
 274                     field.setBoolean(this, (boolean) value);
 275                 } else if (value instanceof Long) {
 276                     field.setBoolean(this, ((long) value) != 0);
 277                 } else {
 278                     throw new JVMCIError(value.getClass().getSimpleName());
 279                 }
 280             } else if (fieldType == byte.class) {
 281                 if (value instanceof Long) {
 282                     field.setByte(this, (byte) (long) value);
 283                 } else {
 284                     throw new JVMCIError(value.getClass().getSimpleName());
 285                 }
 286             } else if (fieldType == int.class) {
 287                 if (value instanceof Integer) {
 288                     field.setInt(this, (int) value);
 289                 } else if (value instanceof Long) {
 290                     field.setInt(this, (int) (long) value);
 291                 } else {
 292                     throw new JVMCIError(value.getClass().getSimpleName());
 293                 }
 294             } else if (fieldType == long.class) {
 295                 field.setLong(this, (long) value);
 296             } else {
 297                 throw new JVMCIError(field.toString());
 298             }
 299         } catch (IllegalAccessException e) {
 300             throw new JVMCIError("%s: %s", field, e);
 301         }
 302     }
 303 
 304     /**
 305      * Gets the host operating system name.
 306      */
 307     private static String getHostOSName() {
 308         String osName = System.getProperty("os.name");
 309         switch (osName) {
 310             case "Linux":
 311                 osName = "linux";
 312                 break;
 313             case "SunOS":
 314                 osName = "solaris";
 315                 break;
 316             case "Mac OS X":
 317                 osName = "bsd";
 318                 break;
 319             default:
 320                 // Of course Windows is different...
 321                 if (osName.startsWith("Windows")) {
 322                     osName = "windows";
 323                 } else {
 324                     throw new JVMCIError("Unexpected OS name: " + osName);
 325                 }
 326         }
 327         return osName;
 328     }
 329 
 330     /**
 331      * Gets the host architecture name for the purpose of finding the corresponding
 332      * {@linkplain HotSpotJVMCIBackendFactory backend}.
 333      */
 334     public String getHostArchitectureName() {
 335         String arch = System.getProperty("os.arch");
 336         switch (arch) {
 337             case "x86_64":
 338                 arch = "amd64";
 339                 break;
 340             case "sparcv9":
 341                 arch = "sparc";
 342                 break;
 343         }
 344         return arch;
 345     }
 346 
 347     /**
 348      * Determines if the current specification is included in a given set of specifications.
 349      *
 350      * @param current
 351      * @param specification specifies a set of specifications, e.g. architectures or operating
 352      *            systems. A zero length value implies all.
 353      */
 354     private static boolean isRequired(String current, String[] specification) {
 355         if (specification.length == 0) {
 356             return true;
 357         }
 358         for (String arch : specification) {
 359             if (arch.equals(current)) {
 360                 return true;
 361             }
 362         }
 363         return false;
 364     }
 365 
 366     /**
 367      * VMStructEntry (see {@code vmStructs.hpp}).
 368      */
 369     @HotSpotVMData(index = 0) @Stable private long jvmciHotSpotVMStructs;
 370     @HotSpotVMData(index = 1) @Stable private long jvmciHotSpotVMStructEntryTypeNameOffset;
 371     @HotSpotVMData(index = 2) @Stable private long jvmciHotSpotVMStructEntryFieldNameOffset;
 372     @HotSpotVMData(index = 3) @Stable private long jvmciHotSpotVMStructEntryTypeStringOffset;
 373     @HotSpotVMData(index = 4) @Stable private long jvmciHotSpotVMStructEntryIsStaticOffset;
 374     @HotSpotVMData(index = 5) @Stable private long jvmciHotSpotVMStructEntryOffsetOffset;
 375     @HotSpotVMData(index = 6) @Stable private long jvmciHotSpotVMStructEntryAddressOffset;
 376     @HotSpotVMData(index = 7) @Stable private long jvmciHotSpotVMStructEntryArrayStride;
 377 
 378     final class VMFields implements Iterable&lt;VMFields.Field&gt; {
 379 
 380         private final long address;
 381 
 382         VMFields(long address) {
 383             this.address = address;
 384         }
 385 
 386         public Iterator&lt;VMFields.Field&gt; iterator() {
 387             return new Iterator&lt;VMFields.Field&gt;() {
 388 
 389                 private int index = 0;
 390 
 391                 private Field current() {
 392                     return new Field(address + jvmciHotSpotVMStructEntryArrayStride * index);
 393                 }
 394 
 395                 /**
 396                  * The last entry is identified by a NULL fieldName.
 397                  */
 398                 public boolean hasNext() {
 399                     Field entry = current();
 400                     return entry.getFieldName() != null;
 401                 }
 402 
 403                 public Field next() {
 404                     Field entry = current();
 405                     index++;
 406                     return entry;
 407                 }
 408             };
 409         }
 410 
 411         final class Field {
 412 
 413             private final long entryAddress;
 414 
 415             Field(long address) {
 416                 this.entryAddress = address;
 417             }
 418 
 419             public String getTypeName() {
 420                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeNameOffset);
 421                 return readCString(UNSAFE, typeNameAddress);
 422             }
 423 
 424             public String getFieldName() {
 425                 long fieldNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryFieldNameOffset);
 426                 return readCString(UNSAFE, fieldNameAddress);
 427             }
 428 
 429             public String getTypeString() {
 430                 long typeStringAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeStringOffset);
 431                 return readCString(UNSAFE, typeStringAddress);
 432             }
 433 
 434             public boolean isStatic() {
 435                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMStructEntryIsStaticOffset) != 0;
 436             }
 437 
 438             public long getOffset() {
 439                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMStructEntryOffsetOffset);
 440             }
 441 
 442             public long getAddress() {
 443                 return UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryAddressOffset);
 444             }
 445 
 446             public String getName() {
 447                 String typeName = getTypeName();
 448                 String fieldName = getFieldName();
 449                 return typeName + "::" + fieldName;
 450             }
 451 
 452             public long getValue() {
 453                 String type = getTypeString();
 454                 switch (type) {
 455                     case "bool":
 456                         return UNSAFE.getByte(getAddress());
 457                     case "int":
 458                         return UNSAFE.getInt(getAddress());
 459                     case "uint64_t":
 460                         return UNSAFE.getLong(getAddress());
 461                     case "address":
 462                     case "intptr_t":
 463                     case "uintptr_t":
 464                     case "size_t":
 465                         return UNSAFE.getAddress(getAddress());
 466                     default:
 467                         // All foo* types are addresses.
 468                         if (type.endsWith("*")) {
 469                             return UNSAFE.getAddress(getAddress());
 470                         }
 471                         throw new JVMCIError(type);
 472                 }
 473             }
 474 
 475             @Override
 476             public String toString() {
 477                 return String.format("Field[typeName=%s, fieldName=%s, typeString=%s, isStatic=%b, offset=%d, address=0x%x]", getTypeName(), getFieldName(), getTypeString(), isStatic(), getOffset(),
 478                                 getAddress());
 479             }
 480         }
 481     }
 482 
 483     /**
 484      * VMTypeEntry (see vmStructs.hpp).
 485      */
 486     @HotSpotVMData(index = 8) @Stable private long jvmciHotSpotVMTypes;
 487     @HotSpotVMData(index = 9) @Stable private long jvmciHotSpotVMTypeEntryTypeNameOffset;
 488     @HotSpotVMData(index = 10) @Stable private long jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 489     @HotSpotVMData(index = 11) @Stable private long jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 490     @HotSpotVMData(index = 12) @Stable private long jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 491     @HotSpotVMData(index = 13) @Stable private long jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 492     @HotSpotVMData(index = 14) @Stable private long jvmciHotSpotVMTypeEntrySizeOffset;
 493     @HotSpotVMData(index = 15) @Stable private long jvmciHotSpotVMTypeEntryArrayStride;
 494 
 495     final class VMTypes implements Iterable&lt;VMTypes.Type&gt; {
 496 
 497         private final long address;
 498 
 499         VMTypes(long address) {
 500             this.address = address;
 501         }
 502 
 503         public Iterator&lt;VMTypes.Type&gt; iterator() {
 504             return new Iterator&lt;VMTypes.Type&gt;() {
 505 
 506                 private int index = 0;
 507 
 508                 private Type current() {
 509                     return new Type(address + jvmciHotSpotVMTypeEntryArrayStride * index);
 510                 }
 511 
 512                 /**
 513                  * The last entry is identified by a NULL type name.
 514                  */
 515                 public boolean hasNext() {
 516                     Type entry = current();
 517                     return entry.getTypeName() != null;
 518                 }
 519 
 520                 public Type next() {
 521                     Type entry = current();
 522                     index++;
 523                     return entry;
 524                 }
 525             };
 526         }
 527 
 528         final class Type {
 529 
 530             private final long entryAddress;
 531 
 532             Type(long address) {
 533                 this.entryAddress = address;
 534             }
 535 
 536             public String getTypeName() {
 537                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntryTypeNameOffset);
 538                 return readCString(UNSAFE, typeNameAddress);
 539             }
 540 
 541             public String getSuperclassName() {
 542                 long superclassNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntrySuperclassNameOffset);
 543                 return readCString(UNSAFE, superclassNameAddress);
 544             }
 545 
 546             public boolean isOopType() {
 547                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsOopTypeOffset) != 0;
 548             }
 549 
 550             public boolean isIntegerType() {
 551                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsIntegerTypeOffset) != 0;
 552             }
 553 
 554             public boolean isUnsigned() {
 555                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsUnsignedOffset) != 0;
 556             }
 557 
 558             public long getSize() {
 559                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMTypeEntrySizeOffset);
 560             }
 561 
 562             @Override
 563             public String toString() {
 564                 return String.format("Type[typeName=%s, superclassName=%s, isOopType=%b, isIntegerType=%b, isUnsigned=%b, size=%d]", getTypeName(), getSuperclassName(), isOopType(), isIntegerType(),
 565                                 isUnsigned(), getSize());
 566             }
 567         }
 568     }
 569 
 570     public abstract class AbstractConstant {
 571 
 572         protected final long address;
 573         protected final long nameOffset;
 574         protected final long valueOffset;
 575 
 576         AbstractConstant(long address, long nameOffset, long valueOffset) {
 577             this.address = address;
 578             this.nameOffset = nameOffset;
 579             this.valueOffset = valueOffset;
 580         }
 581 
 582         public String getName() {
 583             long nameAddress = UNSAFE.getAddress(address + nameOffset);
 584             return readCString(UNSAFE, nameAddress);
 585         }
 586 
 587         public abstract long getValue();
 588     }
 589 
 590     /**
 591      * VMIntConstantEntry (see vmStructs.hpp).
 592      */
 593     @HotSpotVMData(index = 16) @Stable private long jvmciHotSpotVMIntConstants;
 594     @HotSpotVMData(index = 17) @Stable private long jvmciHotSpotVMIntConstantEntryNameOffset;
 595     @HotSpotVMData(index = 18) @Stable private long jvmciHotSpotVMIntConstantEntryValueOffset;
 596     @HotSpotVMData(index = 19) @Stable private long jvmciHotSpotVMIntConstantEntryArrayStride;
 597 
 598     final class VMIntConstants implements Iterable&lt;VMIntConstants.Constant&gt; {
 599 
 600         private final long address;
 601 
 602         VMIntConstants(long address) {
 603             this.address = address;
 604         }
 605 
 606         public Iterator&lt;VMIntConstants.Constant&gt; iterator() {
 607             return new Iterator&lt;VMIntConstants.Constant&gt;() {
 608 
 609                 private int index = 0;
 610 
 611                 private Constant current() {
 612                     return new Constant(address + jvmciHotSpotVMIntConstantEntryArrayStride * index);
 613                 }
 614 
 615                 /**
 616                  * The last entry is identified by a NULL name.
 617                  */
 618                 public boolean hasNext() {
 619                     Constant entry = current();
 620                     return entry.getName() != null;
 621                 }
 622 
 623                 public Constant next() {
 624                     Constant entry = current();
 625                     index++;
 626                     return entry;
 627                 }
 628             };
 629         }
 630 
 631         final class Constant extends AbstractConstant {
 632 
 633             Constant(long address) {
 634                 super(address, jvmciHotSpotVMIntConstantEntryNameOffset, jvmciHotSpotVMIntConstantEntryValueOffset);
 635             }
 636 
 637             @Override
 638             public long getValue() {
 639                 return UNSAFE.getInt(address + valueOffset);
 640             }
 641 
 642             @Override
 643             public String toString() {
 644                 return String.format("IntConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 645             }
 646         }
 647     }
 648 
 649     /**
 650      * VMLongConstantEntry (see vmStructs.hpp).
 651      */
 652     @HotSpotVMData(index = 20) @Stable private long jvmciHotSpotVMLongConstants;
 653     @HotSpotVMData(index = 21) @Stable private long jvmciHotSpotVMLongConstantEntryNameOffset;
 654     @HotSpotVMData(index = 22) @Stable private long jvmciHotSpotVMLongConstantEntryValueOffset;
 655     @HotSpotVMData(index = 23) @Stable private long jvmciHotSpotVMLongConstantEntryArrayStride;
 656 
 657     final class VMLongConstants implements Iterable&lt;VMLongConstants.Constant&gt; {
 658 
 659         private final long address;
 660 
 661         VMLongConstants(long address) {
 662             this.address = address;
 663         }
 664 
 665         public Iterator&lt;VMLongConstants.Constant&gt; iterator() {
 666             return new Iterator&lt;VMLongConstants.Constant&gt;() {
 667 
 668                 private int index = 0;
 669 
 670                 private Constant currentEntry() {
 671                     return new Constant(address + jvmciHotSpotVMLongConstantEntryArrayStride * index);
 672                 }
 673 
 674                 /**
 675                  * The last entry is identified by a NULL name.
 676                  */
 677                 public boolean hasNext() {
 678                     Constant entry = currentEntry();
 679                     return entry.getName() != null;
 680                 }
 681 
 682                 public Constant next() {
 683                     Constant entry = currentEntry();
 684                     index++;
 685                     return entry;
 686                 }
 687             };
 688         }
 689 
 690         final class Constant extends AbstractConstant {
 691 
 692             Constant(long address) {
 693                 super(address, jvmciHotSpotVMLongConstantEntryNameOffset, jvmciHotSpotVMLongConstantEntryValueOffset);
 694             }
 695 
 696             @Override
 697             public long getValue() {
 698                 return UNSAFE.getLong(address + valueOffset);
 699             }
 700 
 701             @Override
 702             public String toString() {
 703                 return String.format("LongConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 704             }
 705         }
 706     }
 707 
 708     /**
 709      * VMAddressEntry (see vmStructs.hpp).
 710      */
 711     @HotSpotVMData(index = 24) @Stable private long jvmciHotSpotVMAddresses;
 712     @HotSpotVMData(index = 25) @Stable private long jvmciHotSpotVMAddressEntryNameOffset;
 713     @HotSpotVMData(index = 26) @Stable private long jvmciHotSpotVMAddressEntryValueOffset;
 714     @HotSpotVMData(index = 27) @Stable private long jvmciHotSpotVMAddressEntryArrayStride;
 715 
 716     final class VMAddresses implements Iterable&lt;VMAddresses.Address&gt; {
 717 
 718         private final long address;
 719 
 720         VMAddresses(long address) {
 721             this.address = address;
 722         }
 723 
 724         public Iterator&lt;VMAddresses.Address&gt; iterator() {
 725             return new Iterator&lt;VMAddresses.Address&gt;() {
 726 
 727                 private int index = 0;
 728 
 729                 private Address currentEntry() {
 730                     return new Address(address + jvmciHotSpotVMAddressEntryArrayStride * index);
 731                 }
 732 
 733                 /**
 734                  * The last entry is identified by a NULL name.
 735                  */
 736                 public boolean hasNext() {
 737                     Address entry = currentEntry();
 738                     return entry.getName() != null;
 739                 }
 740 
 741                 public Address next() {
 742                     Address entry = currentEntry();
 743                     index++;
 744                     return entry;
 745                 }
 746             };
 747         }
 748 
 749         final class Address extends AbstractConstant {
 750 
 751             Address(long address) {
 752                 super(address, jvmciHotSpotVMAddressEntryNameOffset, jvmciHotSpotVMAddressEntryValueOffset);
 753             }
 754 
 755             @Override
 756             public long getValue() {
 757                 return UNSAFE.getLong(address + valueOffset);
 758             }
 759 
 760             @Override
 761             public String toString() {
 762                 return String.format("Address[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 763             }
 764         }
 765     }
 766 
 767     final class Flags implements Iterable&lt;Flags.Flag&gt; {
 768 
 769         private final long address;
 770         private final long entrySize;
 771         private final long typeOffset;
 772         private final long nameOffset;
 773         private final long addrOffset;
 774 
 775         Flags(HashMap&lt;String, VMFields.Field&gt; vmStructs, HashMap&lt;String, VMTypes.Type&gt; vmTypes) {
 776             address = vmStructs.get("Flag::flags").getValue();
 777             entrySize = vmTypes.get("Flag").getSize();
 778             typeOffset = vmStructs.get("Flag::_type").getOffset();
 779             nameOffset = vmStructs.get("Flag::_name").getOffset();
 780             addrOffset = vmStructs.get("Flag::_addr").getOffset();
 781 
 782             assert vmTypes.get("bool").getSize() == Byte.BYTES;
 783             assert vmTypes.get("intx").getSize() == Long.BYTES;
 784             assert vmTypes.get("uintx").getSize() == Long.BYTES;
 785         }
 786 
 787         public Iterator&lt;Flags.Flag&gt; iterator() {
 788             return new Iterator&lt;Flags.Flag&gt;() {
 789 
 790                 private int index = 0;
 791 
 792                 private Flag current() {
 793                     return new Flag(address + entrySize * index);
 794                 }
 795 
 796                 /**
 797                  * The last entry is identified by a NULL name.
 798                  */
 799                 public boolean hasNext() {
 800                     Flag entry = current();
 801                     return entry.getName() != null;
 802                 }
 803 
 804                 public Flag next() {
 805                     Flag entry = current();
 806                     index++;
 807                     return entry;
 808                 }
 809             };
 810         }
 811 
 812         final class Flag {
 813 
 814             private final long entryAddress;
 815 
 816             Flag(long address) {
 817                 this.entryAddress = address;
 818             }
 819 
 820             public String getType() {
 821                 long typeAddress = UNSAFE.getAddress(entryAddress + typeOffset);
 822                 return readCString(UNSAFE, typeAddress);
 823             }
 824 
 825             public String getName() {
 826                 long nameAddress = UNSAFE.getAddress(entryAddress + nameOffset);
 827                 return readCString(UNSAFE, nameAddress);
 828             }
 829 
 830             public long getAddr() {
 831                 return UNSAFE.getAddress(entryAddress + addrOffset);
 832             }
 833 
 834             public Object getValue() {
 835                 switch (getType()) {
 836                     case "bool":
 837                         return Boolean.valueOf(UNSAFE.getByte(getAddr()) != 0);
 838                     case "intx":
 839                     case "uintx":
 840                     case "uint64_t":
 841                         return Long.valueOf(UNSAFE.getLong(getAddr()));
 842                     case "double":
 843                         return Double.valueOf(UNSAFE.getDouble(getAddr()));
 844                     case "ccstr":
 845                     case "ccstrlist":
 846                         return readCString(UNSAFE, getAddr());
 847                     default:
 848                         throw new JVMCIError(getType());
 849                 }
 850             }
 851 
 852             @Override
 853             public String toString() {
 854                 return String.format("Flag[type=%s, name=%s, value=%s]", getType(), getName(), getValue());
 855             }
 856         }
 857     }
 858 
 859     @HotSpotVMConstant(name = "ASSERT") @Stable public boolean cAssertions;
 860     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
 861     public final boolean linuxOs = System.getProperty("os.name", "").startsWith("Linux");
 862 
 863     @HotSpotVMFlag(name = "CodeEntryAlignment") @Stable public int codeEntryAlignment;
 864     @HotSpotVMFlag(name = "VerifyOops") @Stable public boolean verifyOops;
 865     @HotSpotVMFlag(name = "CITime") @Stable public boolean ciTime;
 866     @HotSpotVMFlag(name = "CITimeEach") @Stable public boolean ciTimeEach;
 867     @HotSpotVMFlag(name = "CompileTheWorldStartAt", optional = true) @Stable public int compileTheWorldStartAt;
 868     @HotSpotVMFlag(name = "CompileTheWorldStopAt", optional = true) @Stable public int compileTheWorldStopAt;
 869     @HotSpotVMFlag(name = "DontCompileHugeMethods") @Stable public boolean dontCompileHugeMethods;
 870     @HotSpotVMFlag(name = "HugeMethodLimit") @Stable public int hugeMethodLimit;
 871     @HotSpotVMFlag(name = "PrintInlining") @Stable public boolean printInlining;
 872     @HotSpotVMFlag(name = "Inline") @Stable public boolean inline;
 873     @HotSpotVMFlag(name = "JVMCIUseFastLocking") @Stable public boolean useFastLocking;
 874     @HotSpotVMFlag(name = "ForceUnreachable") @Stable public boolean forceUnreachable;
 875     @HotSpotVMFlag(name = "CodeCacheSegmentSize") @Stable public int codeSegmentSize;
 876     @HotSpotVMFlag(name = "FoldStableValues") @Stable public boolean foldStableValues;
 877 
 878     @HotSpotVMFlag(name = "UseTLAB") @Stable public boolean useTLAB;
 879     @HotSpotVMFlag(name = "UseBiasedLocking") @Stable public boolean useBiasedLocking;
 880     @HotSpotVMFlag(name = "UsePopCountInstruction") @Stable public boolean usePopCountInstruction;
 881     @HotSpotVMFlag(name = "UseCountLeadingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountLeadingZerosInstruction;
 882     @HotSpotVMFlag(name = "UseCountTrailingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountTrailingZerosInstruction;
 883     @HotSpotVMFlag(name = "UseAESIntrinsics") @Stable public boolean useAESIntrinsics;
 884     @HotSpotVMFlag(name = "UseCRC32Intrinsics") @Stable public boolean useCRC32Intrinsics;
 885     @HotSpotVMFlag(name = "UseG1GC") @Stable public boolean useG1GC;
 886     @HotSpotVMFlag(name = "UseConcMarkSweepGC") @Stable public boolean useCMSGC;
 887 
 888     @HotSpotVMFlag(name = "AllocatePrefetchStyle") @Stable public int allocatePrefetchStyle;
 889     @HotSpotVMFlag(name = "AllocatePrefetchInstr") @Stable public int allocatePrefetchInstr;
 890     @HotSpotVMFlag(name = "AllocatePrefetchLines") @Stable public int allocatePrefetchLines;
 891     @HotSpotVMFlag(name = "AllocateInstancePrefetchLines") @Stable public int allocateInstancePrefetchLines;
 892     @HotSpotVMFlag(name = "AllocatePrefetchStepSize") @Stable public int allocatePrefetchStepSize;
 893     @HotSpotVMFlag(name = "AllocatePrefetchDistance") @Stable public int allocatePrefetchDistance;
 894 
 895     @HotSpotVMFlag(name = "FlightRecorder", optional = true) @Stable public boolean flightRecorder;
 896 
 897     @HotSpotVMField(name = "CompilerToVM::Data::Universe_collectedHeap", type = "CollectedHeap*", get = HotSpotVMField.Type.VALUE) @Stable private long universeCollectedHeap;
 898     @HotSpotVMField(name = "CollectedHeap::_total_collections", type = "unsigned int", get = HotSpotVMField.Type.OFFSET) @Stable private int collectedHeapTotalCollectionsOffset;
 899 
 900     public long gcTotalCollectionsAddress() {
 901         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
 902     }
 903 
 904     @HotSpotVMFlag(name = "ReduceInitialCardMarks") @Stable public boolean useDeferredInitBarriers;
 905 
 906     // Compressed Oops related values.
 907     @HotSpotVMFlag(name = "UseCompressedOops") @Stable public boolean useCompressedOops;
 908     @HotSpotVMFlag(name = "UseCompressedClassPointers") @Stable public boolean useCompressedClassPointers;
 909 
 910     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowOopBase;
 911     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowOopShift;
 912     @HotSpotVMFlag(name = "ObjectAlignmentInBytes") @Stable public int objectAlignment;
 913 
 914     public final int minObjAlignment() {
 915         return objectAlignment / heapWordSize;
 916     }
 917 
 918     public final int logMinObjAlignment() {
 919         return (int) (Math.log(objectAlignment) / Math.log(2));
 920     }
 921 
 922     @HotSpotVMType(name = "narrowKlass", get = HotSpotVMType.Type.SIZE) @Stable public int narrowKlassSize;
 923     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowKlassBase;
 924     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowKlassShift;
 925     @HotSpotVMConstant(name = "LogKlassAlignmentInBytes") @Stable public int logKlassAlignment;
 926 
 927     // CPU capabilities
 928     @HotSpotVMFlag(name = "UseSSE") @Stable public int useSSE;
 929     @HotSpotVMFlag(name = "UseAVX", archs = {"amd64"}) @Stable public int useAVX;
 930 
 931     @HotSpotVMField(name = "Abstract_VM_Version::_features", type = "uint64_t", get = HotSpotVMField.Type.VALUE) @Stable public long vmVersionFeatures;
 932 
 933     // AMD64 specific values
 934     @HotSpotVMConstant(name = "VM_Version::CPU_CX8", archs = {"amd64"}) @Stable public long amd64CX8;
 935     @HotSpotVMConstant(name = "VM_Version::CPU_CMOV", archs = {"amd64"}) @Stable public long amd64CMOV;
 936     @HotSpotVMConstant(name = "VM_Version::CPU_FXSR", archs = {"amd64"}) @Stable public long amd64FXSR;
 937     @HotSpotVMConstant(name = "VM_Version::CPU_HT", archs = {"amd64"}) @Stable public long amd64HT;
 938     @HotSpotVMConstant(name = "VM_Version::CPU_MMX", archs = {"amd64"}) @Stable public long amd64MMX;
 939     @HotSpotVMConstant(name = "VM_Version::CPU_3DNOW_PREFETCH", archs = {"amd64"}) @Stable public long amd643DNOWPREFETCH;
 940     @HotSpotVMConstant(name = "VM_Version::CPU_SSE", archs = {"amd64"}) @Stable public long amd64SSE;
 941     @HotSpotVMConstant(name = "VM_Version::CPU_SSE2", archs = {"amd64"}) @Stable public long amd64SSE2;
 942     @HotSpotVMConstant(name = "VM_Version::CPU_SSE3", archs = {"amd64"}) @Stable public long amd64SSE3;
 943     @HotSpotVMConstant(name = "VM_Version::CPU_SSSE3", archs = {"amd64"}) @Stable public long amd64SSSE3;
 944     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4A", archs = {"amd64"}) @Stable public long amd64SSE4A;
 945     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_1", archs = {"amd64"}) @Stable public long amd64SSE41;
 946     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_2", archs = {"amd64"}) @Stable public long amd64SSE42;
 947     @HotSpotVMConstant(name = "VM_Version::CPU_POPCNT", archs = {"amd64"}) @Stable public long amd64POPCNT;
 948     @HotSpotVMConstant(name = "VM_Version::CPU_LZCNT", archs = {"amd64"}) @Stable public long amd64LZCNT;
 949     @HotSpotVMConstant(name = "VM_Version::CPU_TSC", archs = {"amd64"}) @Stable public long amd64TSC;
 950     @HotSpotVMConstant(name = "VM_Version::CPU_TSCINV", archs = {"amd64"}) @Stable public long amd64TSCINV;
 951     @HotSpotVMConstant(name = "VM_Version::CPU_AVX", archs = {"amd64"}) @Stable public long amd64AVX;
 952     @HotSpotVMConstant(name = "VM_Version::CPU_AVX2", archs = {"amd64"}) @Stable public long amd64AVX2;
 953     @HotSpotVMConstant(name = "VM_Version::CPU_AES", archs = {"amd64"}) @Stable public long amd64AES;
 954     @HotSpotVMConstant(name = "VM_Version::CPU_ERMS", archs = {"amd64"}) @Stable public long amd64ERMS;
 955     @HotSpotVMConstant(name = "VM_Version::CPU_CLMUL", archs = {"amd64"}) @Stable public long amd64CLMUL;
 956     @HotSpotVMConstant(name = "VM_Version::CPU_BMI1", archs = {"amd64"}) @Stable public long amd64BMI1;
 957     @HotSpotVMConstant(name = "VM_Version::CPU_BMI2", archs = {"amd64"}) @Stable public long amd64BMI2;
 958     @HotSpotVMConstant(name = "VM_Version::CPU_RTM", archs = {"amd64"}) @Stable public long amd64RTM;
 959     @HotSpotVMConstant(name = "VM_Version::CPU_ADX", archs = {"amd64"}) @Stable public long amd64ADX;
 960     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512F", archs = {"amd64"}) @Stable public long amd64AVX512F;
 961     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512DQ", archs = {"amd64"}) @Stable public long amd64AVX512DQ;
 962     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512PF", archs = {"amd64"}) @Stable public long amd64AVX512PF;
 963     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512ER", archs = {"amd64"}) @Stable public long amd64AVX512ER;
 964     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512CD", archs = {"amd64"}) @Stable public long amd64AVX512CD;
 965     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512BW", archs = {"amd64"}) @Stable public long amd64AVX512BW;
 966     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512VL", archs = {"amd64"}) @Stable public long amd64AVX512VL;
 967     @HotSpotVMConstant(name = "VM_Version::CPU_SHA", archs = {"amd64"}) @Stable public long amd64SHA;
 968 
 969     // SPARC specific values
 970     @HotSpotVMConstant(name = "VM_Version::vis3_instructions_m", archs = {"sparc"}) @Stable public int sparcVis3Instructions;
 971     @HotSpotVMConstant(name = "VM_Version::vis2_instructions_m", archs = {"sparc"}) @Stable public int sparcVis2Instructions;
 972     @HotSpotVMConstant(name = "VM_Version::vis1_instructions_m", archs = {"sparc"}) @Stable public int sparcVis1Instructions;
 973     @HotSpotVMConstant(name = "VM_Version::cbcond_instructions_m", archs = {"sparc"}) @Stable public int sparcCbcondInstructions;
 974     @HotSpotVMConstant(name = "VM_Version::v8_instructions_m", archs = {"sparc"}) @Stable public int sparcV8Instructions;
 975     @HotSpotVMConstant(name = "VM_Version::hardware_mul32_m", archs = {"sparc"}) @Stable public int sparcHardwareMul32;
 976     @HotSpotVMConstant(name = "VM_Version::hardware_div32_m", archs = {"sparc"}) @Stable public int sparcHardwareDiv32;
 977     @HotSpotVMConstant(name = "VM_Version::hardware_fsmuld_m", archs = {"sparc"}) @Stable public int sparcHardwareFsmuld;
 978     @HotSpotVMConstant(name = "VM_Version::hardware_popc_m", archs = {"sparc"}) @Stable public int sparcHardwarePopc;
 979     @HotSpotVMConstant(name = "VM_Version::v9_instructions_m", archs = {"sparc"}) @Stable public int sparcV9Instructions;
 980     @HotSpotVMConstant(name = "VM_Version::sun4v_m", archs = {"sparc"}) @Stable public int sparcSun4v;
 981     @HotSpotVMConstant(name = "VM_Version::blk_init_instructions_m", archs = {"sparc"}) @Stable public int sparcBlkInitInstructions;
 982     @HotSpotVMConstant(name = "VM_Version::fmaf_instructions_m", archs = {"sparc"}) @Stable public int sparcFmafInstructions;
 983     @HotSpotVMConstant(name = "VM_Version::fmau_instructions_m", archs = {"sparc"}) @Stable public int sparcFmauInstructions;
 984     @HotSpotVMConstant(name = "VM_Version::sparc64_family_m", archs = {"sparc"}) @Stable public int sparcSparc64Family;
 985     @HotSpotVMConstant(name = "VM_Version::M_family_m", archs = {"sparc"}) @Stable public int sparcMFamily;
 986     @HotSpotVMConstant(name = "VM_Version::T_family_m", archs = {"sparc"}) @Stable public int sparcTFamily;
 987     @HotSpotVMConstant(name = "VM_Version::T1_model_m", archs = {"sparc"}) @Stable public int sparcT1Model;
 988     @HotSpotVMConstant(name = "VM_Version::sparc5_instructions_m", archs = {"sparc"}) @Stable public int sparcSparc5Instructions;
 989     @HotSpotVMConstant(name = "VM_Version::aes_instructions_m", archs = {"sparc"}) @Stable public int sparcAesInstructions;
 990     @HotSpotVMConstant(name = "VM_Version::sha1_instruction_m", archs = {"sparc"}) @Stable public int sparcSha1Instruction;
 991     @HotSpotVMConstant(name = "VM_Version::sha256_instruction_m", archs = {"sparc"}) @Stable public int sparcSha256Instruction;
 992     @HotSpotVMConstant(name = "VM_Version::sha512_instruction_m", archs = {"sparc"}) @Stable public int sparcSha512Instruction;
 993 
 994     @HotSpotVMFlag(name = "UseBlockZeroing", archs = {"sparc"}) @Stable public boolean useBlockZeroing;
 995     @HotSpotVMFlag(name = "BlockZeroingLowLimit", archs = {"sparc"}) @Stable public int blockZeroingLowLimit;
 996 
 997     @HotSpotVMFlag(name = "StackShadowPages") @Stable public int stackShadowPages;
 998     @HotSpotVMFlag(name = "StackReservedPages") @Stable public int stackReservedPages;
 999     @HotSpotVMFlag(name = "UseStackBanging") @Stable public boolean useStackBanging;
1000     @HotSpotVMConstant(name = "STACK_BIAS") @Stable public int stackBias;
1001     @HotSpotVMField(name = "CompilerToVM::Data::vm_page_size", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int vmPageSize;
1002 
1003     // offsets, ...
1004     @HotSpotVMField(name = "oopDesc::_mark", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int markOffset;
1005     @HotSpotVMField(name = "oopDesc::_metadata._klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int hubOffset;
1006 
1007     @HotSpotVMField(name = "Klass::_prototype_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int prototypeMarkWordOffset;
1008     @HotSpotVMField(name = "Klass::_subklass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int subklassOffset;
1009     @HotSpotVMField(name = "Klass::_next_sibling", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int nextSiblingOffset;
1010     @HotSpotVMField(name = "Klass::_super_check_offset", type = "juint", get = HotSpotVMField.Type.OFFSET) @Stable public int superCheckOffsetOffset;
1011     @HotSpotVMField(name = "Klass::_secondary_super_cache", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySuperCacheOffset;
1012     @HotSpotVMField(name = "Klass::_secondary_supers", type = "Array&lt;Klass*&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySupersOffset;
1013 
1014     /**
1015      * The offset of the _java_mirror field (of type {@link Class}) in a Klass.
1016      */
1017     @HotSpotVMField(name = "Klass::_java_mirror", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int classMirrorOffset;
1018 
1019     @HotSpotVMField(name = "Klass::_super", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int klassSuperKlassOffset;
1020     @HotSpotVMField(name = "Klass::_modifier_flags", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassModifierFlagsOffset;
1021     @HotSpotVMField(name = "Klass::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int klassAccessFlagsOffset;
1022     @HotSpotVMField(name = "Klass::_layout_helper", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassLayoutHelperOffset;
1023     @HotSpotVMField(name = "Klass::_name", type = "Symbol*", get = HotSpotVMField.Type.OFFSET) @Stable public int klassNameOffset;
1024 
1025     @HotSpotVMConstant(name = "Klass::_lh_neutral_value") @Stable public int klassLayoutHelperNeutralValue;
1026     @HotSpotVMConstant(name = "Klass::_lh_instance_slow_path_bit") @Stable public int klassLayoutHelperInstanceSlowPathBit;
1027     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_shift") @Stable public int layoutHelperLog2ElementSizeShift;
1028     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_mask") @Stable public int layoutHelperLog2ElementSizeMask;
1029     @HotSpotVMConstant(name = "Klass::_lh_element_type_shift") @Stable public int layoutHelperElementTypeShift;
1030     @HotSpotVMConstant(name = "Klass::_lh_element_type_mask") @Stable public int layoutHelperElementTypeMask;
1031     @HotSpotVMConstant(name = "Klass::_lh_header_size_shift") @Stable public int layoutHelperHeaderSizeShift;
1032     @HotSpotVMConstant(name = "Klass::_lh_header_size_mask") @Stable public int layoutHelperHeaderSizeMask;
1033     @HotSpotVMConstant(name = "Klass::_lh_array_tag_shift") @Stable public int layoutHelperArrayTagShift;
1034     @HotSpotVMConstant(name = "Klass::_lh_array_tag_type_value") @Stable public int layoutHelperArrayTagTypeValue;
1035     @HotSpotVMConstant(name = "Klass::_lh_array_tag_obj_value") @Stable public int layoutHelperArrayTagObjectValue;
1036 
1037     /**
1038      * This filters out the bit that differentiates a type array from an object array.
1039      */
1040     public int layoutHelperElementTypePrimitiveInPlace() {
1041         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
1042     }
1043 
1044     /**
1045      * Bit pattern in the klass layout helper that can be used to identify arrays.
1046      */
1047     public final int arrayKlassLayoutHelperIdentifier = 0x80000000;
1048 
1049     @HotSpotVMType(name = "vtableEntry", get = HotSpotVMType.Type.SIZE) @Stable public int vtableEntrySize;
1050     @HotSpotVMField(name = "vtableEntry::_method", type = "Method*", get = HotSpotVMField.Type.OFFSET) @Stable public int vtableEntryMethodOffset;
1051 
1052     @HotSpotVMType(name = "InstanceKlass", get = HotSpotVMType.Type.SIZE) @Stable public int instanceKlassSize;
1053     @HotSpotVMField(name = "InstanceKlass::_source_file_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassSourceFileNameIndexOffset;
1054     @HotSpotVMField(name = "InstanceKlass::_init_state", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassInitStateOffset;
1055     @HotSpotVMField(name = "InstanceKlass::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassConstantsOffset;
1056     @HotSpotVMField(name = "InstanceKlass::_fields", type = "Array&lt;u2&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassFieldsOffset;
1057     @HotSpotVMField(name = "CompilerToVM::Data::Klass_vtable_start_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassVtableStartOffset;
1058     @HotSpotVMField(name = "CompilerToVM::Data::Klass_vtable_length_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassVtableLengthOffset;
1059 
1060     @HotSpotVMConstant(name = "InstanceKlass::linked") @Stable public int instanceKlassStateLinked;
1061     @HotSpotVMConstant(name = "InstanceKlass::fully_initialized") @Stable public int instanceKlassStateFullyInitialized;
1062 
1063     @HotSpotVMType(name = "arrayOopDesc", get = HotSpotVMType.Type.SIZE) @Stable public int arrayOopDescSize;
1064 
1065     /**
1066      * The offset of the array length word in an array object's header.
1067      *
1068      * See {@code arrayOopDesc::length_offset_in_bytes()}.
1069      */
1070     public final int arrayOopDescLengthOffset() {
1071         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
1072     }
1073 
1074     @HotSpotVMField(name = "Array&lt;int&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1LengthOffset;
1075     @HotSpotVMField(name = "Array&lt;u1&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1DataOffset;
1076     @HotSpotVMField(name = "Array&lt;u2&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU2DataOffset;
1077     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayLengthOffset;
1078     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_data[0]", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayBaseOffset;
1079 
1080     @HotSpotVMField(name = "ObjArrayKlass::_element_klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayClassElementOffset;
1081 
1082     @HotSpotVMConstant(name = "FieldInfo::access_flags_offset") @Stable public int fieldInfoAccessFlagsOffset;
1083     @HotSpotVMConstant(name = "FieldInfo::name_index_offset") @Stable public int fieldInfoNameIndexOffset;
1084     @HotSpotVMConstant(name = "FieldInfo::signature_index_offset") @Stable public int fieldInfoSignatureIndexOffset;
1085     @HotSpotVMConstant(name = "FieldInfo::initval_index_offset") @Stable public int fieldInfoInitvalIndexOffset;
1086     @HotSpotVMConstant(name = "FieldInfo::low_packed_offset") @Stable public int fieldInfoLowPackedOffset;
1087     @HotSpotVMConstant(name = "FieldInfo::high_packed_offset") @Stable public int fieldInfoHighPackedOffset;
1088     @HotSpotVMConstant(name = "FieldInfo::field_slots") @Stable public int fieldInfoFieldSlots;
1089 
1090     @HotSpotVMConstant(name = "FIELDINFO_TAG_SIZE") @Stable public int fieldInfoTagSize;
1091 
1092     @HotSpotVMConstant(name = "JVM_ACC_MONITOR_MATCH") @Stable public int jvmAccMonitorMatch;
1093     @HotSpotVMConstant(name = "JVM_ACC_HAS_MONITOR_BYTECODES") @Stable public int jvmAccHasMonitorBytecodes;
1094     @HotSpotVMConstant(name = "JVM_ACC_HAS_FINALIZER") @Stable public int jvmAccHasFinalizer;
1095     @HotSpotVMConstant(name = "JVM_ACC_FIELD_INTERNAL") @Stable public int jvmAccFieldInternal;
1096     @HotSpotVMConstant(name = "JVM_ACC_FIELD_STABLE") @Stable public int jvmAccFieldStable;
1097     @HotSpotVMConstant(name = "JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE") @Stable public int jvmAccFieldHasGenericSignature;
1098     @HotSpotVMConstant(name = "JVM_ACC_WRITTEN_FLAGS") @Stable public int jvmAccWrittenFlags;
1099     @HotSpotVMConstant(name = "JVM_ACC_IS_CLONEABLE_FAST") @Stable public int jvmAccIsCloneableFast;
1100 
1101     // Modifier.SYNTHETIC is not public so we get it via vmStructs.
1102     @HotSpotVMConstant(name = "JVM_ACC_SYNTHETIC") @Stable public int jvmAccSynthetic;
1103 
1104     /**
1105      * @see HotSpotResolvedObjectTypeImpl#createField
1106      */
1107     @HotSpotVMConstant(name = "JVM_RECOGNIZED_FIELD_MODIFIERS") @Stable public int recognizedFieldModifiers;
1108 
1109     @HotSpotVMField(name = "Thread::_tlab", type = "ThreadLocalAllocBuffer", get = HotSpotVMField.Type.OFFSET) @Stable public int threadTlabOffset;
1110 
1111     @HotSpotVMField(name = "JavaThread::_anchor", type = "JavaFrameAnchor", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadAnchorOffset;
1112     @HotSpotVMField(name = "JavaThread::_threadObj", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectOffset;
1113     @HotSpotVMField(name = "JavaThread::_osthread", type = "OSThread*", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadOffset;
1114     @HotSpotVMField(name = "JavaThread::_dirty_card_queue", type = "DirtyCardQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadDirtyCardQueueOffset;
1115     @HotSpotVMField(name = "JavaThread::_is_method_handle_return", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int threadIsMethodHandleReturnOffset;
1116     @HotSpotVMField(name = "JavaThread::_satb_mark_queue", type = "SATBMarkQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadSatbMarkQueueOffset;
1117     @HotSpotVMField(name = "JavaThread::_vm_result", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectResultOffset;
1118     @HotSpotVMField(name = "JavaThread::_jvmci_counters", type = "jlong*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciCountersThreadOffset;
1119     @HotSpotVMField(name = "JavaThread::_reserved_stack_activation", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadReservedStackActivationOffset;
1120 
1121     /**
1122      * An invalid value for {@link #rtldDefault}.
1123      */
1124     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
1125 
1126     /**
1127      * Address of the library lookup routine. The C signature of this routine is:
1128      *
1129      * &lt;pre&gt;
1130      *     void* (const char *filename, char *ebuf, int ebuflen)
1131      * &lt;/pre&gt;
1132      */
1133     @HotSpotVMAddress(name = "os::dll_load") @Stable public long dllLoad;
1134 
1135     /**
1136      * Address of the library lookup routine. The C signature of this routine is:
1137      *
1138      * &lt;pre&gt;
1139      *     void* (void* handle, const char* name)
1140      * &lt;/pre&gt;
1141      */
1142     @HotSpotVMAddress(name = "os::dll_lookup") @Stable public long dllLookup;
1143 
1144     /**
1145      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
1146      * return the first occurrence of the desired symbol using the default library search order. If
1147      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
1148      * the current platform.
1149      */
1150     @HotSpotVMAddress(name = "RTLD_DEFAULT", os = {"bsd", "linux"}) @Stable public long rtldDefault = INVALID_RTLD_DEFAULT_HANDLE;
1151 
1152     /**
1153      * This field is used to pass exception objects into and out of the runtime system during
1154      * exception handling for compiled code.
1155      */
1156     @HotSpotVMField(name = "JavaThread::_exception_oop", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionOopOffset;
1157     @HotSpotVMField(name = "JavaThread::_exception_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionPcOffset;
1158     @HotSpotVMField(name = "ThreadShadow::_pending_exception", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingExceptionOffset;
1159 
1160     @HotSpotVMField(name = "JavaThread::_pending_deoptimization", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingDeoptimizationOffset;
1161     @HotSpotVMField(name = "JavaThread::_pending_failed_speculation", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingFailedSpeculationOffset;
1162     @HotSpotVMField(name = "JavaThread::_pending_transfer_to_interpreter", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingTransferToInterpreterOffset;
1163 
1164     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_sp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaSpOffset;
1165     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaPcOffset;
1166     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_fp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET, archs = {"aarch64, amd64"}) @Stable private int javaFrameAnchorLastJavaFpOffset;
1167     @HotSpotVMField(name = "JavaFrameAnchor::_flags", type = "int", get = HotSpotVMField.Type.OFFSET, archs = {"sparc"}) @Stable private int javaFrameAnchorFlagsOffset;
1168 
1169     public int threadLastJavaSpOffset() {
1170         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
1171     }
1172 
1173     public int threadLastJavaPcOffset() {
1174         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
1175     }
1176 
1177     public int threadLastJavaFpOffset() {
1178         assert getHostArchitectureName().equals("aarch64") || getHostArchitectureName().equals("amd64");
1179         return javaThreadAnchorOffset + javaFrameAnchorLastJavaFpOffset;
1180     }
1181 
1182     /**
1183      * This value is only valid on SPARC.
1184      */
1185     public int threadJavaFrameAnchorFlagsOffset() {
1186         // TODO add an assert for SPARC
1187         return javaThreadAnchorOffset + javaFrameAnchorFlagsOffset;
1188     }
1189 
1190     // These are only valid on AMD64.
1191     @HotSpotVMConstant(name = "frame::arg_reg_save_area_bytes", archs = {"amd64"}) @Stable public int runtimeCallStackSize;
1192     @HotSpotVMConstant(name = "frame::interpreter_frame_sender_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameSenderSpOffset;
1193     @HotSpotVMConstant(name = "frame::interpreter_frame_last_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameLastSpOffset;
1194 
1195     @HotSpotVMConstant(name = "dirtyCardQueueBufferOffset") @Stable private int dirtyCardQueueBufferOffset;
1196     @HotSpotVMConstant(name = "dirtyCardQueueIndexOffset") @Stable private int dirtyCardQueueIndexOffset;
1197 
1198     @HotSpotVMConstant(name = "satbMarkQueueBufferOffset") @Stable private int satbMarkQueueBufferOffset;
1199     @HotSpotVMConstant(name = "satbMarkQueueIndexOffset") @Stable private int satbMarkQueueIndexOffset;
1200     @HotSpotVMConstant(name = "satbMarkQueueActiveOffset") @Stable private int satbMarkQueueActiveOffset;
1201 
1202     @HotSpotVMField(name = "OSThread::_interrupted", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadInterruptedOffset;
1203 
1204     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public long markOopDescHashShift;
1205 
1206     @HotSpotVMConstant(name = "markOopDesc::biased_lock_mask_in_place") @Stable public int biasedLockMaskInPlace;
1207     @HotSpotVMConstant(name = "markOopDesc::age_mask_in_place") @Stable public int ageMaskInPlace;
1208     @HotSpotVMConstant(name = "markOopDesc::epoch_mask_in_place") @Stable public int epochMaskInPlace;
1209     @HotSpotVMConstant(name = "markOopDesc::hash_mask") @Stable public long markOopDescHashMask;
1210     @HotSpotVMConstant(name = "markOopDesc::hash_mask_in_place") @Stable public long markOopDescHashMaskInPlace;
1211 
1212     @HotSpotVMConstant(name = "markOopDesc::unlocked_value") @Stable public int unlockedMask;
1213     @HotSpotVMConstant(name = "markOopDesc::biased_lock_pattern") @Stable public int biasedLockPattern;
1214 
1215     @HotSpotVMConstant(name = "markOopDesc::no_hash_in_place") @Stable public int markWordNoHashInPlace;
1216     @HotSpotVMConstant(name = "markOopDesc::no_lock_in_place") @Stable public int markWordNoLockInPlace;
1217 
1218     /**
1219      * See {@code markOopDesc::prototype()}.
1220      */
1221     public long arrayPrototypeMarkWord() {
1222         return markWordNoHashInPlace | markWordNoLockInPlace;
1223     }
1224 
1225     /**
1226      * See {@code markOopDesc::copy_set_hash()}.
1227      */
1228     public long tlabIntArrayMarkWord() {
1229         long tmp = arrayPrototypeMarkWord() &amp; (~markOopDescHashMaskInPlace);
1230         tmp |= ((0x2 &amp; markOopDescHashMask) &lt;&lt; markOopDescHashShift);
1231         return tmp;
1232     }
1233 
1234     /**
1235      * Mark word right shift to get identity hash code.
1236      */
1237     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public int identityHashCodeShift;
1238 
1239     /**
1240      * Identity hash code value when uninitialized.
1241      */
1242     @HotSpotVMConstant(name = "markOopDesc::no_hash") @Stable public int uninitializedIdentityHashCodeValue;
1243 
1244     @HotSpotVMField(name = "Method::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int methodAccessFlagsOffset;
1245     @HotSpotVMField(name = "Method::_constMethod", type = "ConstMethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodConstMethodOffset;
1246     @HotSpotVMField(name = "Method::_intrinsic_id", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodIntrinsicIdOffset;
1247     @HotSpotVMField(name = "Method::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodFlagsOffset;
1248     @HotSpotVMField(name = "Method::_vtable_index", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodVtableIndexOffset;
1249 
1250     @HotSpotVMField(name = "Method::_method_counters", type = "MethodCounters*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCountersOffset;
1251     @HotSpotVMField(name = "Method::_method_data", type = "MethodData*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOffset;
1252     @HotSpotVMField(name = "Method::_from_compiled_entry", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCompiledEntryOffset;
1253     @HotSpotVMField(name = "Method::_code", type = "CompiledMethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCodeOffset;
1254 
1255     @HotSpotVMConstant(name = "Method::_jfr_towrite") @Stable public int methodFlagsJfrTowrite;
1256     @HotSpotVMConstant(name = "Method::_caller_sensitive") @Stable public int methodFlagsCallerSensitive;
1257     @HotSpotVMConstant(name = "Method::_force_inline") @Stable public int methodFlagsForceInline;
1258     @HotSpotVMConstant(name = "Method::_dont_inline") @Stable public int methodFlagsDontInline;
1259     @HotSpotVMConstant(name = "Method::_hidden") @Stable public int methodFlagsHidden;
1260     @HotSpotVMConstant(name = "Method::_reserved_stack_access") @Stable public int methodFlagsReservedStackAccess;
1261     @HotSpotVMConstant(name = "Method::nonvirtual_vtable_index") @Stable public int nonvirtualVtableIndex;
1262     @HotSpotVMConstant(name = "Method::invalid_vtable_index") @Stable public int invalidVtableIndex;
1263 
1264     @HotSpotVMField(name = "MethodCounters::_invocation_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int invocationCounterOffset;
1265     @HotSpotVMField(name = "MethodCounters::_backedge_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int backedgeCounterOffset;
1266     @HotSpotVMConstant(name = "InvocationCounter::count_increment") @Stable public int invocationCounterIncrement;
1267     @HotSpotVMConstant(name = "InvocationCounter::count_shift") @Stable public int invocationCounterShift;
1268 
1269     @HotSpotVMField(name = "MethodData::_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataSize;
1270     @HotSpotVMField(name = "MethodData::_data_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataDataSize;
1271     @HotSpotVMField(name = "MethodData::_data[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopDataOffset;
1272     @HotSpotVMField(name = "MethodData::_trap_hist._array[0]", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopTrapHistoryOffset;
1273     @HotSpotVMField(name = "MethodData::_jvmci_ir_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataIRSizeOffset;
1274 
1275     @HotSpotVMField(name = "nmethod::_verified_entry_point", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodEntryOffset;
1276     @HotSpotVMField(name = "nmethod::_comp_level", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodCompLevelOffset;
1277 
1278     @HotSpotVMConstant(name = "CompLevel_none") @Stable public int compilationLevelNone;
1279     @HotSpotVMConstant(name = "CompLevel_simple") @Stable public int compilationLevelSimple;
1280     @HotSpotVMConstant(name = "CompLevel_limited_profile") @Stable public int compilationLevelLimitedProfile;
1281     @HotSpotVMConstant(name = "CompLevel_full_profile") @Stable public int compilationLevelFullProfile;
1282     @HotSpotVMConstant(name = "CompLevel_full_optimization") @Stable public int compilationLevelFullOptimization;
1283 
1284     @HotSpotVMConstant(name = "JVMCIRuntime::none") @Stable public int compLevelAdjustmentNone;
1285     @HotSpotVMConstant(name = "JVMCIRuntime::by_holder") @Stable public int compLevelAdjustmentByHolder;
1286     @HotSpotVMConstant(name = "JVMCIRuntime::by_full_signature") @Stable public int compLevelAdjustmentByFullSignature;
1287 
1288     @HotSpotVMConstant(name = "InvocationEntryBci") @Stable public int invocationEntryBci;
1289 
1290     @HotSpotVMField(name = "JVMCIEnv::_task", type = "CompileTask*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvTaskOffset;
1291     @HotSpotVMField(name = "JVMCIEnv::_jvmti_can_hotswap_or_post_breakpoint", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvJvmtiCanHotswapOrPostBreakpointOffset;
1292     @HotSpotVMField(name = "CompileTask::_num_inlined_bytecodes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int compileTaskNumInlinedBytecodesOffset;
1293 
1294     @HotSpotVMField(name = "CompilerToVM::Data::Method_extra_stack_entries", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int extraStackEntries;
1295 
1296     @HotSpotVMField(name = "ConstMethod::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodConstantsOffset;
1297     @HotSpotVMField(name = "ConstMethod::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodFlagsOffset;
1298     @HotSpotVMField(name = "ConstMethod::_code_size", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodCodeSizeOffset;
1299     @HotSpotVMField(name = "ConstMethod::_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodNameIndexOffset;
1300     @HotSpotVMField(name = "ConstMethod::_signature_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodSignatureIndexOffset;
1301     @HotSpotVMField(name = "ConstMethod::_max_stack", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodMaxStackOffset;
1302     @HotSpotVMField(name = "ConstMethod::_max_locals", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodMaxLocalsOffset;
1303 
1304     @HotSpotVMConstant(name = "ConstMethod::_has_linenumber_table") @Stable public int constMethodHasLineNumberTable;
1305     @HotSpotVMConstant(name = "ConstMethod::_has_localvariable_table") @Stable public int constMethodHasLocalVariableTable;
1306     @HotSpotVMConstant(name = "ConstMethod::_has_exception_table") @Stable public int constMethodHasExceptionTable;
1307 
1308     @HotSpotVMType(name = "ExceptionTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int exceptionTableElementSize;
1309     @HotSpotVMField(name = "ExceptionTableElement::start_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementStartPcOffset;
1310     @HotSpotVMField(name = "ExceptionTableElement::end_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementEndPcOffset;
1311     @HotSpotVMField(name = "ExceptionTableElement::handler_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementHandlerPcOffset;
1312     @HotSpotVMField(name = "ExceptionTableElement::catch_type_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementCatchTypeIndexOffset;
1313 
1314     @HotSpotVMType(name = "LocalVariableTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int localVariableTableElementSize;
1315     @HotSpotVMField(name = "LocalVariableTableElement::start_bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementStartBciOffset;
1316     @HotSpotVMField(name = "LocalVariableTableElement::length", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementLengthOffset;
1317     @HotSpotVMField(name = "LocalVariableTableElement::name_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementNameCpIndexOffset;
1318     @HotSpotVMField(name = "LocalVariableTableElement::descriptor_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementDescriptorCpIndexOffset;
1319     @HotSpotVMField(name = "LocalVariableTableElement::signature_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSignatureCpIndexOffset;
1320     @HotSpotVMField(name = "LocalVariableTableElement::slot", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSlotOffset;
1321 
1322     @HotSpotVMType(name = "ConstantPool", get = HotSpotVMType.Type.SIZE) @Stable public int constantPoolSize;
1323     @HotSpotVMField(name = "ConstantPool::_tags", type = "Array&lt;u1&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolTagsOffset;
1324     @HotSpotVMField(name = "ConstantPool::_pool_holder", type = "InstanceKlass*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolHolderOffset;
1325     @HotSpotVMField(name = "ConstantPool::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolLengthOffset;
1326 
1327     @HotSpotVMConstant(name = "ConstantPool::CPCACHE_INDEX_TAG") @Stable public int constantPoolCpCacheIndexTag;
1328 
1329     @HotSpotVMConstant(name = "JVM_CONSTANT_Utf8") @Stable public int jvmConstantUtf8;
1330     @HotSpotVMConstant(name = "JVM_CONSTANT_Integer") @Stable public int jvmConstantInteger;
1331     @HotSpotVMConstant(name = "JVM_CONSTANT_Long") @Stable public int jvmConstantLong;
1332     @HotSpotVMConstant(name = "JVM_CONSTANT_Float") @Stable public int jvmConstantFloat;
1333     @HotSpotVMConstant(name = "JVM_CONSTANT_Double") @Stable public int jvmConstantDouble;
1334     @HotSpotVMConstant(name = "JVM_CONSTANT_Class") @Stable public int jvmConstantClass;
1335     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClass") @Stable public int jvmConstantUnresolvedClass;
1336     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClassInError") @Stable public int jvmConstantUnresolvedClassInError;
1337     @HotSpotVMConstant(name = "JVM_CONSTANT_String") @Stable public int jvmConstantString;
1338     @HotSpotVMConstant(name = "JVM_CONSTANT_Fieldref") @Stable public int jvmConstantFieldref;
1339     @HotSpotVMConstant(name = "JVM_CONSTANT_Methodref") @Stable public int jvmConstantMethodref;
1340     @HotSpotVMConstant(name = "JVM_CONSTANT_InterfaceMethodref") @Stable public int jvmConstantInterfaceMethodref;
1341     @HotSpotVMConstant(name = "JVM_CONSTANT_NameAndType") @Stable public int jvmConstantNameAndType;
1342     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandle") @Stable public int jvmConstantMethodHandle;
1343     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandleInError") @Stable public int jvmConstantMethodHandleInError;
1344     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodType") @Stable public int jvmConstantMethodType;
1345     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodTypeInError") @Stable public int jvmConstantMethodTypeInError;
1346     @HotSpotVMConstant(name = "JVM_CONSTANT_InvokeDynamic") @Stable public int jvmConstantInvokeDynamic;
1347 
1348     @HotSpotVMConstant(name = "JVM_CONSTANT_ExternalMax") @Stable public int jvmConstantExternalMax;
1349     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMin") @Stable public int jvmConstantInternalMin;
1350     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMax") @Stable public int jvmConstantInternalMax;
1351 
1352     @HotSpotVMConstant(name = "HeapWordSize") @Stable public int heapWordSize;
1353 
1354     @HotSpotVMType(name = "Symbol*", get = HotSpotVMType.Type.SIZE) @Stable public int symbolPointerSize;
1355 
1356     @HotSpotVMField(name = "vmSymbols::_symbols[0]", type = "Symbol*", get = HotSpotVMField.Type.ADDRESS) @Stable public long vmSymbolsSymbols;
1357     @HotSpotVMConstant(name = "vmSymbols::FIRST_SID") @Stable public int vmSymbolsFirstSID;
1358     @HotSpotVMConstant(name = "vmSymbols::SID_LIMIT") @Stable public int vmSymbolsSIDLimit;
1359 
1360     /**
1361      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
1362      * are allowed to look like (respectively) the high or low bits of a real oop.
1363      */
1364     @HotSpotVMField(name = "CompilerToVM::Data::Universe_non_oop_bits", type = "void*", get = HotSpotVMField.Type.VALUE) @Stable public long nonOopBits;
1365 
1366     @HotSpotVMField(name = "StubRoutines::_verify_oop_count", type = "jint", get = HotSpotVMField.Type.ADDRESS) @Stable public long verifyOopCounterAddress;
1367     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_mask", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopMask;
1368     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_bits", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopBits;
1369     @HotSpotVMField(name = "CompilerToVM::Data::Universe_base_vtable_size", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int universeBaseVtableSize;
1370 
1371     public final int baseVtableLength() {
1372         return universeBaseVtableSize / vtableEntrySize;
1373     }
1374 
1375     @HotSpotVMField(name = "HeapRegion::LogOfHRGrainBytes", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int logOfHRGrainBytes;
1376 
1377     @HotSpotVMConstant(name = "CardTableModRefBS::dirty_card") @Stable public byte dirtyCardValue;
1378     @HotSpotVMConstant(name = "G1SATBCardTableModRefBS::g1_young_gen") @Stable public byte g1YoungCardValue;
1379 
1380     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_start_address", type = "jbyte*", get = HotSpotVMField.Type.VALUE) @Stable private long cardtableStartAddress;
1381     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable private int cardtableShift;
1382 
1383     public long cardtableStartAddress() {
1384         return cardtableStartAddress;
1385     }
1386 
1387     public int cardtableShift() {
1388         return cardtableShift;
1389     }
1390 
1391     @HotSpotVMField(name = "os::_polling_page", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long safepointPollingAddress;
1392 
1393     // G1 Collector Related Values.
1394 
1395     public int g1CardQueueIndexOffset() {
1396         return javaThreadDirtyCardQueueOffset + dirtyCardQueueIndexOffset;
1397     }
1398 
1399     public int g1CardQueueBufferOffset() {
1400         return javaThreadDirtyCardQueueOffset + dirtyCardQueueBufferOffset;
1401     }
1402 
1403     public int g1SATBQueueMarkingOffset() {
1404         return javaThreadSatbMarkQueueOffset + satbMarkQueueActiveOffset;
1405     }
1406 
1407     public int g1SATBQueueIndexOffset() {
1408         return javaThreadSatbMarkQueueOffset + satbMarkQueueIndexOffset;
1409     }
1410 
1411     public int g1SATBQueueBufferOffset() {
1412         return javaThreadSatbMarkQueueOffset + satbMarkQueueBufferOffset;
1413     }
1414 
1415     @HotSpotVMField(name = "java_lang_Class::_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassOffset;
1416     @HotSpotVMField(name = "java_lang_Class::_array_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int arrayKlassOffset;
1417 
1418     @HotSpotVMType(name = "BasicLock", get = HotSpotVMType.Type.SIZE) @Stable public int basicLockSize;
1419     @HotSpotVMField(name = "BasicLock::_displaced_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int basicLockDisplacedHeaderOffset;
1420 
1421     @HotSpotVMField(name = "Thread::_allocated_bytes", type = "jlong", get = HotSpotVMField.Type.OFFSET) @Stable public int threadAllocatedBytesOffset;
1422 
1423     @HotSpotVMFlag(name = "TLABWasteIncrement") @Stable public int tlabRefillWasteIncrement;
1424 
1425     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_start", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferStartOffset;
1426     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_end", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferEndOffset;
1427     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferTopOffset;
1428     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_pf_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferPfTopOffset;
1429     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_slow_allocations", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferSlowAllocationsOffset;
1430     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_fast_refill_waste", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferFastRefillWasteOffset;
1431     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_number_of_refills", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferNumberOfRefillsOffset;
1432     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_refill_waste_limit", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferRefillWasteLimitOffset;
1433     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_desired_size", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferDesiredSizeOffset;
1434 
1435     public int tlabSlowAllocationsOffset() {
1436         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
1437     }
1438 
1439     public int tlabFastRefillWasteOffset() {
1440         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
1441     }
1442 
1443     public int tlabNumberOfRefillsOffset() {
1444         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
1445     }
1446 
1447     public int tlabRefillWasteLimitOffset() {
1448         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
1449     }
1450 
1451     public int threadTlabSizeOffset() {
1452         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
1453     }
1454 
1455     public int threadTlabStartOffset() {
1456         return threadTlabOffset + threadLocalAllocBufferStartOffset;
1457     }
1458 
1459     public int threadTlabEndOffset() {
1460         return threadTlabOffset + threadLocalAllocBufferEndOffset;
1461     }
1462 
1463     public int threadTlabTopOffset() {
1464         return threadTlabOffset + threadLocalAllocBufferTopOffset;
1465     }
1466 
1467     public int threadTlabPfTopOffset() {
1468         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
1469     }
1470 
1471     @HotSpotVMField(name = "CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve", type = "size_t", get = HotSpotVMField.Type.VALUE) @Stable public int tlabAlignmentReserve;
1472 
1473     @HotSpotVMFlag(name = "TLABStats") @Stable public boolean tlabStats;
1474 
1475     // FIXME This is only temporary until the GC code is changed.
1476     @HotSpotVMField(name = "CompilerToVM::Data::_supports_inline_contig_alloc", type = "bool", get = HotSpotVMField.Type.VALUE) @Stable public boolean inlineContiguousAllocationSupported;
1477     @HotSpotVMField(name = "CompilerToVM::Data::_heap_end_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapEndAddress;
1478     @HotSpotVMField(name = "CompilerToVM::Data::_heap_top_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapTopAddress;
1479 
1480     /**
1481      * The DataLayout header size is the same as the cell size.
1482      */
1483     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutHeaderSize;
1484     @HotSpotVMField(name = "DataLayout::_header._struct._tag", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutTagOffset;
1485     @HotSpotVMField(name = "DataLayout::_header._struct._flags", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutFlagsOffset;
1486     @HotSpotVMField(name = "DataLayout::_header._struct._bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutBCIOffset;
1487     @HotSpotVMField(name = "DataLayout::_cells[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutCellsOffset;
1488     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutCellSize;
1489 
1490     @HotSpotVMConstant(name = "DataLayout::no_tag") @Stable public int dataLayoutNoTag;
1491     @HotSpotVMConstant(name = "DataLayout::bit_data_tag") @Stable public int dataLayoutBitDataTag;
1492     @HotSpotVMConstant(name = "DataLayout::counter_data_tag") @Stable public int dataLayoutCounterDataTag;
1493     @HotSpotVMConstant(name = "DataLayout::jump_data_tag") @Stable public int dataLayoutJumpDataTag;
1494     @HotSpotVMConstant(name = "DataLayout::receiver_type_data_tag") @Stable public int dataLayoutReceiverTypeDataTag;
1495     @HotSpotVMConstant(name = "DataLayout::virtual_call_data_tag") @Stable public int dataLayoutVirtualCallDataTag;
1496     @HotSpotVMConstant(name = "DataLayout::ret_data_tag") @Stable public int dataLayoutRetDataTag;
1497     @HotSpotVMConstant(name = "DataLayout::branch_data_tag") @Stable public int dataLayoutBranchDataTag;
1498     @HotSpotVMConstant(name = "DataLayout::multi_branch_data_tag") @Stable public int dataLayoutMultiBranchDataTag;
1499     @HotSpotVMConstant(name = "DataLayout::arg_info_data_tag") @Stable public int dataLayoutArgInfoDataTag;
1500     @HotSpotVMConstant(name = "DataLayout::call_type_data_tag") @Stable public int dataLayoutCallTypeDataTag;
1501     @HotSpotVMConstant(name = "DataLayout::virtual_call_type_data_tag") @Stable public int dataLayoutVirtualCallTypeDataTag;
1502     @HotSpotVMConstant(name = "DataLayout::parameters_type_data_tag") @Stable public int dataLayoutParametersTypeDataTag;
1503     @HotSpotVMConstant(name = "DataLayout::speculative_trap_data_tag") @Stable public int dataLayoutSpeculativeTrapDataTag;
1504 
1505     @HotSpotVMFlag(name = "BciProfileWidth") @Stable public int bciProfileWidth;
1506     @HotSpotVMFlag(name = "TypeProfileWidth") @Stable public int typeProfileWidth;
1507     @HotSpotVMFlag(name = "MethodProfileWidth") @Stable public int methodProfileWidth;
1508 
1509     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_ic_miss_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long inlineCacheMissStub;
1510     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleWrongMethodStub;
1511 
1512     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_unpack", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleDeoptStub;
1513     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long uncommonTrapStub;
1514 
1515     @HotSpotVMField(name = "CodeCache::_low_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheLowBound;
1516     @HotSpotVMField(name = "CodeCache::_high_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheHighBound;
1517 
1518     @HotSpotVMField(name = "StubRoutines::_aescrypt_encryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptEncryptBlockStub;
1519     @HotSpotVMField(name = "StubRoutines::_aescrypt_decryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptDecryptBlockStub;
1520     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_encryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingEncryptAESCryptStub;
1521     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_decryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingDecryptAESCryptStub;
1522     @HotSpotVMField(name = "StubRoutines::_updateBytesCRC32", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long updateBytesCRC32Stub;
1523     @HotSpotVMField(name = "StubRoutines::_crc_table_adr", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long crcTableAddress;
1524 
1525     @HotSpotVMField(name = "StubRoutines::_throw_delayed_StackOverflowError_entry", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long throwDelayedStackOverflowErrorEntry;
1526 
1527     @HotSpotVMField(name = "StubRoutines::_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteArraycopy;
1528     @HotSpotVMField(name = "StubRoutines::_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortArraycopy;
1529     @HotSpotVMField(name = "StubRoutines::_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintArraycopy;
1530     @HotSpotVMField(name = "StubRoutines::_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongArraycopy;
1531     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopy;
1532     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopyUninit;
1533     @HotSpotVMField(name = "StubRoutines::_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteDisjointArraycopy;
1534     @HotSpotVMField(name = "StubRoutines::_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortDisjointArraycopy;
1535     @HotSpotVMField(name = "StubRoutines::_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintDisjointArraycopy;
1536     @HotSpotVMField(name = "StubRoutines::_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongDisjointArraycopy;
1537     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopy;
1538     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopyUninit;
1539     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedArraycopy;
1540     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedArraycopy;
1541     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedArraycopy;
1542     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedArraycopy;
1543     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopy;
1544     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopyUninit;
1545     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedDisjointArraycopy;
1546     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedDisjointArraycopy;
1547     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedDisjointArraycopy;
1548     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedDisjointArraycopy;
1549     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopy;
1550     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopyUninit;
1551     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopy;
1552     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopyUninit;
1553     @HotSpotVMField(name = "StubRoutines::_unsafe_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long unsafeArraycopy;
1554     @HotSpotVMField(name = "StubRoutines::_generic_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long genericArraycopy;
1555 
1556     @HotSpotVMAddress(name = "JVMCIRuntime::new_instance") @Stable public long newInstanceAddress;
1557     @HotSpotVMAddress(name = "JVMCIRuntime::new_array") @Stable public long newArrayAddress;
1558     @HotSpotVMAddress(name = "JVMCIRuntime::new_multi_array") @Stable public long newMultiArrayAddress;
1559     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_array") @Stable public long dynamicNewArrayAddress;
1560     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_instance") @Stable public long dynamicNewInstanceAddress;
1561 
1562     @HotSpotVMAddress(name = "JVMCIRuntime::thread_is_interrupted") @Stable public long threadIsInterruptedAddress;
1563     @HotSpotVMAddress(name = "JVMCIRuntime::vm_message") @Stable public long vmMessageAddress;
1564     @HotSpotVMAddress(name = "JVMCIRuntime::identity_hash_code") @Stable public long identityHashCodeAddress;
1565     @HotSpotVMAddress(name = "JVMCIRuntime::exception_handler_for_pc") @Stable public long exceptionHandlerForPcAddress;
1566     @HotSpotVMAddress(name = "JVMCIRuntime::monitorenter") @Stable public long monitorenterAddress;
1567     @HotSpotVMAddress(name = "JVMCIRuntime::monitorexit") @Stable public long monitorexitAddress;
1568     @HotSpotVMAddress(name = "JVMCIRuntime::throw_and_post_jvmti_exception") @Stable public long throwAndPostJvmtiExceptionAddress;
1569     @HotSpotVMAddress(name = "JVMCIRuntime::throw_klass_external_name_exception") @Stable public long throwKlassExternalNameExceptionAddress;
1570     @HotSpotVMAddress(name = "JVMCIRuntime::throw_class_cast_exception") @Stable public long throwClassCastExceptionAddress;
1571     @HotSpotVMAddress(name = "JVMCIRuntime::log_primitive") @Stable public long logPrimitiveAddress;
1572     @HotSpotVMAddress(name = "JVMCIRuntime::log_object") @Stable public long logObjectAddress;
1573     @HotSpotVMAddress(name = "JVMCIRuntime::log_printf") @Stable public long logPrintfAddress;
1574     @HotSpotVMAddress(name = "JVMCIRuntime::vm_error") @Stable public long vmErrorAddress;
1575     @HotSpotVMAddress(name = "JVMCIRuntime::load_and_clear_exception") @Stable public long loadAndClearExceptionAddress;
1576     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_pre") @Stable public long writeBarrierPreAddress;
1577     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_post") @Stable public long writeBarrierPostAddress;
1578     @HotSpotVMAddress(name = "JVMCIRuntime::validate_object") @Stable public long validateObject;
1579 
1580     @HotSpotVMAddress(name = "JVMCIRuntime::test_deoptimize_call_int") @Stable public long testDeoptimizeCallInt;
1581 
1582     @HotSpotVMAddress(name = "SharedRuntime::register_finalizer") @Stable public long registerFinalizerAddress;
1583     @HotSpotVMAddress(name = "SharedRuntime::exception_handler_for_return_address") @Stable public long exceptionHandlerForReturnAddressAddress;
1584     @HotSpotVMAddress(name = "SharedRuntime::OSR_migration_end") @Stable public long osrMigrationEndAddress;
1585     @HotSpotVMAddress(name = "SharedRuntime::enable_stack_reserved_zone") @Stable public long enableStackReservedZoneAddress;
1586 
1587     @HotSpotVMAddress(name = "os::javaTimeMillis") @Stable public long javaTimeMillisAddress;
1588     @HotSpotVMAddress(name = "os::javaTimeNanos") @Stable public long javaTimeNanosAddress;
1589     @HotSpotVMField(name = "CompilerToVM::Data::dsin", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticSinAddress;
1590     @HotSpotVMField(name = "CompilerToVM::Data::dcos", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticCosAddress;
1591     @HotSpotVMField(name = "CompilerToVM::Data::dtan", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticTanAddress;
1592     @HotSpotVMField(name = "CompilerToVM::Data::dexp", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticExpAddress;
1593     @HotSpotVMField(name = "CompilerToVM::Data::dlog", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticLogAddress;
1594     @HotSpotVMField(name = "CompilerToVM::Data::dlog10", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticLog10Address;
1595     @HotSpotVMField(name = "CompilerToVM::Data::dpow", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticPowAddress;
1596 
1597     @HotSpotVMFlag(name = "JVMCICounterSize") @Stable public int jvmciCountersSize;
1598 
1599     @HotSpotVMAddress(name = "Deoptimization::fetch_unroll_info") @Stable public long deoptimizationFetchUnrollInfo;
1600     @HotSpotVMAddress(name = "Deoptimization::uncommon_trap") @Stable public long deoptimizationUncommonTrap;
1601     @HotSpotVMAddress(name = "Deoptimization::unpack_frames") @Stable public long deoptimizationUnpackFrames;
1602 
1603     @HotSpotVMConstant(name = "Deoptimization::Reason_none") @Stable public int deoptReasonNone;
1604     @HotSpotVMConstant(name = "Deoptimization::Reason_null_check") @Stable public int deoptReasonNullCheck;
1605     @HotSpotVMConstant(name = "Deoptimization::Reason_range_check") @Stable public int deoptReasonRangeCheck;
1606     @HotSpotVMConstant(name = "Deoptimization::Reason_class_check") @Stable public int deoptReasonClassCheck;
1607     @HotSpotVMConstant(name = "Deoptimization::Reason_array_check") @Stable public int deoptReasonArrayCheck;
1608     @HotSpotVMConstant(name = "Deoptimization::Reason_unreached0") @Stable public int deoptReasonUnreached0;
1609     @HotSpotVMConstant(name = "Deoptimization::Reason_type_checked_inlining") @Stable public int deoptReasonTypeCheckInlining;
1610     @HotSpotVMConstant(name = "Deoptimization::Reason_optimized_type_check") @Stable public int deoptReasonOptimizedTypeCheck;
1611     @HotSpotVMConstant(name = "Deoptimization::Reason_not_compiled_exception_handler") @Stable public int deoptReasonNotCompiledExceptionHandler;
1612     @HotSpotVMConstant(name = "Deoptimization::Reason_unresolved") @Stable public int deoptReasonUnresolved;
1613     @HotSpotVMConstant(name = "Deoptimization::Reason_jsr_mismatch") @Stable public int deoptReasonJsrMismatch;
1614     @HotSpotVMConstant(name = "Deoptimization::Reason_div0_check") @Stable public int deoptReasonDiv0Check;
1615     @HotSpotVMConstant(name = "Deoptimization::Reason_constraint") @Stable public int deoptReasonConstraint;
1616     @HotSpotVMConstant(name = "Deoptimization::Reason_loop_limit_check") @Stable public int deoptReasonLoopLimitCheck;
1617     @HotSpotVMConstant(name = "Deoptimization::Reason_aliasing") @Stable public int deoptReasonAliasing;
1618     @HotSpotVMConstant(name = "Deoptimization::Reason_transfer_to_interpreter") @Stable public int deoptReasonTransferToInterpreter;
1619     @HotSpotVMConstant(name = "Deoptimization::Reason_LIMIT") @Stable public int deoptReasonOSROffset;
1620 
1621     @HotSpotVMConstant(name = "Deoptimization::Action_none") @Stable public int deoptActionNone;
1622     @HotSpotVMConstant(name = "Deoptimization::Action_maybe_recompile") @Stable public int deoptActionMaybeRecompile;
1623     @HotSpotVMConstant(name = "Deoptimization::Action_reinterpret") @Stable public int deoptActionReinterpret;
1624     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_entrant") @Stable public int deoptActionMakeNotEntrant;
1625     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_compilable") @Stable public int deoptActionMakeNotCompilable;
1626 
1627     @HotSpotVMConstant(name = "Deoptimization::_action_bits") @Stable public int deoptimizationActionBits;
1628     @HotSpotVMConstant(name = "Deoptimization::_reason_bits") @Stable public int deoptimizationReasonBits;
1629     @HotSpotVMConstant(name = "Deoptimization::_debug_id_bits") @Stable public int deoptimizationDebugIdBits;
1630     @HotSpotVMConstant(name = "Deoptimization::_action_shift") @Stable public int deoptimizationActionShift;
1631     @HotSpotVMConstant(name = "Deoptimization::_reason_shift") @Stable public int deoptimizationReasonShift;
1632     @HotSpotVMConstant(name = "Deoptimization::_debug_id_shift") @Stable public int deoptimizationDebugIdShift;
1633 
1634     @HotSpotVMConstant(name = "Deoptimization::Unpack_deopt") @Stable public int deoptimizationUnpackDeopt;
1635     @HotSpotVMConstant(name = "Deoptimization::Unpack_exception") @Stable public int deoptimizationUnpackException;
1636     @HotSpotVMConstant(name = "Deoptimization::Unpack_uncommon_trap") @Stable public int deoptimizationUnpackUncommonTrap;
1637     @HotSpotVMConstant(name = "Deoptimization::Unpack_reexecute") @Stable public int deoptimizationUnpackReexecute;
1638 
1639     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_size_of_deoptimized_frame", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockSizeOfDeoptimizedFrameOffset;
1640     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_caller_adjustment", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockCallerAdjustmentOffset;
1641     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_number_of_frames", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockNumberOfFramesOffset;
1642     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_total_frame_sizes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockTotalFrameSizesOffset;
1643     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_unpack_kind", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockUnpackKindOffset;
1644     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_sizes", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFrameSizesOffset;
1645     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_pcs", type = "address*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFramePcsOffset;
1646     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_initial_info", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockInitialInfoOffset;
1647 
1648     @HotSpotVMConstant(name = "vmIntrinsics::_invokeBasic") @Stable public int vmIntrinsicInvokeBasic;
1649     @HotSpotVMConstant(name = "vmIntrinsics::_linkToVirtual") @Stable public int vmIntrinsicLinkToVirtual;
1650     @HotSpotVMConstant(name = "vmIntrinsics::_linkToStatic") @Stable public int vmIntrinsicLinkToStatic;
1651     @HotSpotVMConstant(name = "vmIntrinsics::_linkToSpecial") @Stable public int vmIntrinsicLinkToSpecial;
1652     @HotSpotVMConstant(name = "vmIntrinsics::_linkToInterface") @Stable public int vmIntrinsicLinkToInterface;
1653 
1654     @HotSpotVMConstant(name = "JVMCIEnv::ok") @Stable public int codeInstallResultOk;
1655     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_failed") @Stable public int codeInstallResultDependenciesFailed;
1656     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_invalid") @Stable public int codeInstallResultDependenciesInvalid;
1657     @HotSpotVMConstant(name = "JVMCIEnv::cache_full") @Stable public int codeInstallResultCacheFull;
1658     @HotSpotVMConstant(name = "JVMCIEnv::code_too_large") @Stable public int codeInstallResultCodeTooLarge;
1659 
1660     public String getCodeInstallResultDescription(int codeInstallResult) {
1661         if (codeInstallResult == codeInstallResultOk) {
1662             return "ok";
1663         }
1664         if (codeInstallResult == codeInstallResultDependenciesFailed) {
1665             return "dependencies failed";
1666         }
1667         if (codeInstallResult == codeInstallResultDependenciesInvalid) {
1668             return "dependencies invalid";
1669         }
1670         if (codeInstallResult == codeInstallResultCacheFull) {
1671             return "code cache is full";
1672         }
1673         if (codeInstallResult == codeInstallResultCodeTooLarge) {
1674             return "code is too large";
1675         }
1676         assert false : codeInstallResult;
1677         return "unknown";
1678     }
1679 
1680     // Checkstyle: stop
1681     @HotSpotVMConstant(name = "CodeInstaller::VERIFIED_ENTRY") @Stable public int MARKID_VERIFIED_ENTRY;
1682     @HotSpotVMConstant(name = "CodeInstaller::UNVERIFIED_ENTRY") @Stable public int MARKID_UNVERIFIED_ENTRY;
1683     @HotSpotVMConstant(name = "CodeInstaller::OSR_ENTRY") @Stable public int MARKID_OSR_ENTRY;
1684     @HotSpotVMConstant(name = "CodeInstaller::EXCEPTION_HANDLER_ENTRY") @Stable public int MARKID_EXCEPTION_HANDLER_ENTRY;
1685     @HotSpotVMConstant(name = "CodeInstaller::DEOPT_HANDLER_ENTRY") @Stable public int MARKID_DEOPT_HANDLER_ENTRY;
1686     @HotSpotVMConstant(name = "CodeInstaller::INVOKEINTERFACE") @Stable public int MARKID_INVOKEINTERFACE;
1687     @HotSpotVMConstant(name = "CodeInstaller::INVOKEVIRTUAL") @Stable public int MARKID_INVOKEVIRTUAL;
1688     @HotSpotVMConstant(name = "CodeInstaller::INVOKESTATIC") @Stable public int MARKID_INVOKESTATIC;
1689     @HotSpotVMConstant(name = "CodeInstaller::INVOKESPECIAL") @Stable public int MARKID_INVOKESPECIAL;
1690     @HotSpotVMConstant(name = "CodeInstaller::INLINE_INVOKE") @Stable public int MARKID_INLINE_INVOKE;
1691     @HotSpotVMConstant(name = "CodeInstaller::POLL_NEAR") @Stable public int MARKID_POLL_NEAR;
1692     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_NEAR") @Stable public int MARKID_POLL_RETURN_NEAR;
1693     @HotSpotVMConstant(name = "CodeInstaller::POLL_FAR") @Stable public int MARKID_POLL_FAR;
1694     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_FAR") @Stable public int MARKID_POLL_RETURN_FAR;
1695     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_SHIFT") @Stable public int MARKID_CARD_TABLE_SHIFT;
1696     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_ADDRESS") @Stable public int MARKID_CARD_TABLE_ADDRESS;
1697     @HotSpotVMConstant(name = "CodeInstaller::HEAP_TOP_ADDRESS") @Stable public int MARKID_HEAP_TOP_ADDRESS;
1698     @HotSpotVMConstant(name = "CodeInstaller::HEAP_END_ADDRESS") @Stable public int MARKID_HEAP_END_ADDRESS;
1699     @HotSpotVMConstant(name = "CodeInstaller::NARROW_KLASS_BASE_ADDRESS") @Stable public int MARKID_NARROW_KLASS_BASE_ADDRESS;
1700     @HotSpotVMConstant(name = "CodeInstaller::CRC_TABLE_ADDRESS") @Stable public int MARKID_CRC_TABLE_ADDRESS;
1701     @HotSpotVMConstant(name = "CodeInstaller::INVOKE_INVALID") @Stable public int MARKID_INVOKE_INVALID;
1702 
1703     @HotSpotVMConstant(name = "BitData::exception_seen_flag") @Stable public int bitDataExceptionSeenFlag;
1704     @HotSpotVMConstant(name = "BitData::null_seen_flag") @Stable public int bitDataNullSeenFlag;
1705     @HotSpotVMConstant(name = "CounterData::count_off") @Stable public int methodDataCountOffset;
1706     @HotSpotVMConstant(name = "JumpData::taken_off_set") @Stable public int jumpDataTakenOffset;
1707     @HotSpotVMConstant(name = "JumpData::displacement_off_set") @Stable public int jumpDataDisplacementOffset;
1708     @HotSpotVMConstant(name = "ReceiverTypeData::nonprofiled_count_off_set") @Stable public int receiverTypeDataNonprofiledCountOffset;
1709     @HotSpotVMConstant(name = "ReceiverTypeData::receiver_type_row_cell_count") @Stable public int receiverTypeDataReceiverTypeRowCellCount;
1710     @HotSpotVMConstant(name = "ReceiverTypeData::receiver0_offset") @Stable public int receiverTypeDataReceiver0Offset;
1711     @HotSpotVMConstant(name = "ReceiverTypeData::count0_offset") @Stable public int receiverTypeDataCount0Offset;
1712     @HotSpotVMConstant(name = "BranchData::not_taken_off_set") @Stable public int branchDataNotTakenOffset;
1713     @HotSpotVMConstant(name = "ArrayData::array_len_off_set") @Stable public int arrayDataArrayLenOffset;
1714     @HotSpotVMConstant(name = "ArrayData::array_start_off_set") @Stable public int arrayDataArrayStartOffset;
1715     @HotSpotVMConstant(name = "MultiBranchData::per_case_cell_count") @Stable public int multiBranchDataPerCaseCellCount;
1716 
1717     // Checkstyle: resume
1718 
1719     private boolean check() {
1720         for (Field f : getClass().getDeclaredFields()) {
1721             int modifiers = f.getModifiers();
1722             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
1723                 assert Modifier.isFinal(modifiers) || f.getAnnotation(Stable.class) != null : "field should either be final or @Stable: " + f;
1724             }
1725         }
1726 
1727         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
1728         assert (layoutHelperArrayTagObjectValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "object array must have first bit set";
1729         assert (layoutHelperArrayTagTypeValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "type array must have first bit set";
1730 
1731         return true;
1732     }
1733 
1734     /**
1735      * A compact representation of the different encoding strategies for Objects and metadata.
1736      */
1737     public static class CompressEncoding {
1738         public final long base;
1739         public final int shift;
1740         public final int alignment;
1741 
1742         CompressEncoding(long base, int shift, int alignment) {
1743             this.base = base;
1744             this.shift = shift;
1745             this.alignment = alignment;
1746         }
1747 
1748         public int compress(long ptr) {
1749             if (ptr == 0L) {
1750                 return 0;
1751             } else {
1752                 return (int) ((ptr - base) &gt;&gt;&gt; shift);
1753             }
1754         }
1755 
1756         public long uncompress(int ptr) {
1757             if (ptr == 0) {
1758                 return 0L;
1759             } else {
1760                 return ((ptr &amp; 0xFFFFFFFFL) &lt;&lt; shift) + base;
1761             }
1762         }
1763 
1764         @Override
1765         public String toString() {
1766             return "base: " + base + " shift: " + shift + " alignment: " + alignment;
1767         }
1768 
1769         @Override
1770         public int hashCode() {
1771             final int prime = 31;
1772             int result = 1;
1773             result = prime * result + alignment;
1774             result = prime * result + (int) (base ^ (base &gt;&gt;&gt; 32));
1775             result = prime * result + shift;
1776             return result;
1777         }
1778 
1779         @Override
1780         public boolean equals(Object obj) {
1781             if (obj instanceof CompressEncoding) {
1782                 CompressEncoding other = (CompressEncoding) obj;
1783                 return alignment == other.alignment &amp;&amp; base == other.base &amp;&amp; shift == other.shift;
1784             } else {
1785                 return false;
1786             }
1787         }
1788     }
1789 
1790 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="5" type="hidden" /></form></body></html>
