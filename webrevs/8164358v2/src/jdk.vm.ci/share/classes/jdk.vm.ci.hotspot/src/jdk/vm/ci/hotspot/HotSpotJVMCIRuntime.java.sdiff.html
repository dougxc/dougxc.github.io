<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethod.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 480                 String value = field.value == null ? "null" : String.format("%d[0x%x]", field.value, field.value);
 481                 printConfigLine(vm, "[vmconfig:static field] %s %s = %s {address=0x%x}%n", field.type, field.name, value, field.address);
 482             }
 483         }
 484         TreeMap&lt;String, VMFlag&gt; flags = new TreeMap&lt;&gt;(store.getFlags());
 485         for (VMFlag flag : flags.values()) {
 486             printConfigLine(vm, "[vmconfig:flag] %s %s = %s%n", flag.type, flag.name, flag.value);
 487         }
 488         TreeMap&lt;String, Long&gt; addresses = new TreeMap&lt;&gt;(store.getAddresses());
 489         for (Map.Entry&lt;String, Long&gt; e : addresses.entrySet()) {
 490             printConfigLine(vm, "[vmconfig:address] %s = %d[0x%x]%n", e.getKey(), e.getValue(), e.getValue());
 491         }
 492         TreeMap&lt;String, Long&gt; constants = new TreeMap&lt;&gt;(store.getConstants());
 493         for (Map.Entry&lt;String, Long&gt; e : constants.entrySet()) {
 494             printConfigLine(vm, "[vmconfig:constant] %s = %d[0x%x]%n", e.getKey(), e.getValue(), e.getValue());
 495         }
 496         TreeMap&lt;String, Long&gt; typeSizes = new TreeMap&lt;&gt;(store.getTypeSizes());
 497         for (Map.Entry&lt;String, Long&gt; e : typeSizes.entrySet()) {
 498             printConfigLine(vm, "[vmconfig:type size] %s = %d%n", e.getKey(), e.getValue());
 499         }



 500     }
 501 
 502     public OutputStream getLogStream() {
 503         return new OutputStream() {
 504 
 505             @Override
 506             public void write(byte[] b, int off, int len) throws IOException {
 507                 if (b == null) {
 508                     throw new NullPointerException();
 509                 } else if (off &lt; 0 || off &gt; b.length || len &lt; 0 || (off + len) &gt; b.length || (off + len) &lt; 0) {
 510                     throw new IndexOutOfBoundsException();
 511                 } else if (len == 0) {
 512                     return;
 513                 }
 514                 compilerToVm.writeDebugOutput(b, off, len);
 515             }
 516 
 517             @Override
 518             public void write(int b) throws IOException {
 519                 write(new byte[]{(byte) b}, 0, 1);
</pre></td><td><pre>

</pre><hr></hr><pre>
 480                 String value = field.value == null ? "null" : String.format("%d[0x%x]", field.value, field.value);
 481                 printConfigLine(vm, "[vmconfig:static field] %s %s = %s {address=0x%x}%n", field.type, field.name, value, field.address);
 482             }
 483         }
 484         TreeMap&lt;String, VMFlag&gt; flags = new TreeMap&lt;&gt;(store.getFlags());
 485         for (VMFlag flag : flags.values()) {
 486             printConfigLine(vm, "[vmconfig:flag] %s %s = %s%n", flag.type, flag.name, flag.value);
 487         }
 488         TreeMap&lt;String, Long&gt; addresses = new TreeMap&lt;&gt;(store.getAddresses());
 489         for (Map.Entry&lt;String, Long&gt; e : addresses.entrySet()) {
 490             printConfigLine(vm, "[vmconfig:address] %s = %d[0x%x]%n", e.getKey(), e.getValue(), e.getValue());
 491         }
 492         TreeMap&lt;String, Long&gt; constants = new TreeMap&lt;&gt;(store.getConstants());
 493         for (Map.Entry&lt;String, Long&gt; e : constants.entrySet()) {
 494             printConfigLine(vm, "[vmconfig:constant] %s = %d[0x%x]%n", e.getKey(), e.getValue(), e.getValue());
 495         }
 496         TreeMap&lt;String, Long&gt; typeSizes = new TreeMap&lt;&gt;(store.getTypeSizes());
 497         for (Map.Entry&lt;String, Long&gt; e : typeSizes.entrySet()) {
 498             printConfigLine(vm, "[vmconfig:type size] %s = %d%n", e.getKey(), e.getValue());
 499         }
<span class="new"> 500         for (VMIntrinsicMethod e : store.getIntrinsics()) {</span>
<span class="new"> 501             printConfigLine(vm, "[vmconfig:intrinsic] %d = %s.%s %s%n", e.id, e.declaringClass, e.name, e.descriptor);</span>
<span class="new"> 502         }</span>
 503     }
 504 
 505     public OutputStream getLogStream() {
 506         return new OutputStream() {
 507 
 508             @Override
 509             public void write(byte[] b, int off, int len) throws IOException {
 510                 if (b == null) {
 511                     throw new NullPointerException();
 512                 } else if (off &lt; 0 || off &gt; b.length || len &lt; 0 || (off + len) &gt; b.length || (off + len) &lt; 0) {
 513                     throw new IndexOutOfBoundsException();
 514                 } else if (len == 0) {
 515                     return;
 516                 }
 517                 compilerToVm.writeDebugOutput(b, off, len);
 518             }
 519 
 520             @Override
 521             public void write(int b) throws IOException {
 522                 write(new byte[]{(byte) b}, 0, 1);
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethod.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
