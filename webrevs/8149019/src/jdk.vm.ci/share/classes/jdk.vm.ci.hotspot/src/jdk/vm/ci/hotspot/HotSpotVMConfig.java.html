<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfig.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.UnsafeUtil.readCString;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  27 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  28 
  29 import java.lang.reflect.Field;
  30 import java.lang.reflect.Modifier;
  31 import java.util.HashMap;
  32 import java.util.Iterator;
  33 
  34 import jdk.vm.ci.common.JVMCIError;
  35 import jdk.vm.ci.hotspotvmconfig.HotSpotVMAddress;
  36 import jdk.vm.ci.hotspotvmconfig.HotSpotVMConstant;
  37 import jdk.vm.ci.hotspotvmconfig.HotSpotVMData;
  38 import jdk.vm.ci.hotspotvmconfig.HotSpotVMField;
  39 import jdk.vm.ci.hotspotvmconfig.HotSpotVMFlag;
  40 import jdk.vm.ci.hotspotvmconfig.HotSpotVMType;
  41 import sun.misc.Unsafe;
  42 
  43 //JaCoCo Exclude
  44 
  45 /**
  46  * Used to access native configuration details.
  47  *
  48  * All non-static, public fields in this class are so that they can be compiled as constants.
  49  */
  50 public class HotSpotVMConfig {
  51 
  52     /**
  53      * Gets the configuration associated with the singleton {@link HotSpotJVMCIRuntime}.
  54      */
  55     public static HotSpotVMConfig config() {
  56         return runtime().getConfig();
  57     }
  58 
  59     /**
  60      * Maximum allowed size of allocated area for a frame.
  61      */
  62     public final int maxFrameSize = 16 * 1024;
  63 
  64     public HotSpotVMConfig(CompilerToVM compilerToVm) {
  65         // Get raw pointer to the array that contains all gHotSpotVM values.
  66         final long gHotSpotVMData = compilerToVm.initializeConfiguration(this);
  67         assert gHotSpotVMData != 0;
  68 
  69         // Make FindBugs happy.
  70         jvmciHotSpotVMStructs = 0;
  71         jvmciHotSpotVMTypes = 0;
  72         jvmciHotSpotVMIntConstants = 0;
  73         jvmciHotSpotVMLongConstants = 0;
  74         jvmciHotSpotVMAddresses = 0;
  75 
  76         // Initialize the gHotSpotVM fields.
  77         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
  78             if (f.isAnnotationPresent(HotSpotVMData.class)) {
  79                 HotSpotVMData annotation = f.getAnnotation(HotSpotVMData.class);
  80                 final int index = annotation.index();
  81                 final long value = UNSAFE.getAddress(gHotSpotVMData + Unsafe.ADDRESS_SIZE * index);
  82                 try {
  83                     f.setLong(this, value);
  84                 } catch (IllegalAccessException e) {
  85                     throw new JVMCIError("index " + index, e);
  86                 }
  87             }
  88         }
  89 
  90         // Quick sanity check.
  91         assert jvmciHotSpotVMStructs != 0;
  92         assert jvmciHotSpotVMTypes != 0;
  93         assert jvmciHotSpotVMIntConstants != 0;
  94         assert jvmciHotSpotVMLongConstants != 0;
  95         assert jvmciHotSpotVMAddresses != 0;
  96 
  97         initialize();
  98 
  99         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift, logMinObjAlignment());
 100         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift, logKlassAlignment);
 101 
 102         assert check();
 103         assert HotSpotVMConfigVerifier.check();
 104     }
 105 
 106     @Override
 107     public String toString() {
 108         return getClass().getSimpleName();
 109     }
 110 
 111     /**
 112      * Initialize fields by reading their values from vmStructs.
 113      */
 114     private void initialize() {
 115         // Fill the VM fields hash map.
 116         HashMap&lt;String, VMFields.Field&gt; vmFields = new HashMap&lt;&gt;();
 117         for (VMFields.Field e : new VMFields(jvmciHotSpotVMStructs)) {
 118             vmFields.put(e.getName(), e);
 119         }
 120 
 121         // Fill the VM types hash map.
 122         HashMap&lt;String, VMTypes.Type&gt; vmTypes = new HashMap&lt;&gt;();
 123         for (VMTypes.Type e : new VMTypes(jvmciHotSpotVMTypes)) {
 124             vmTypes.put(e.getTypeName(), e);
 125         }
 126 
 127         // Fill the VM constants hash map.
 128         HashMap&lt;String, AbstractConstant&gt; vmConstants = new HashMap&lt;&gt;();
 129         for (AbstractConstant e : new VMIntConstants(jvmciHotSpotVMIntConstants)) {
 130             vmConstants.put(e.getName(), e);
 131         }
 132         for (AbstractConstant e : new VMLongConstants(jvmciHotSpotVMLongConstants)) {
 133             vmConstants.put(e.getName(), e);
 134         }
 135 
 136         // Fill the VM addresses hash map.
 137         HashMap&lt;String, VMAddresses.Address&gt; vmAddresses = new HashMap&lt;&gt;();
 138         for (VMAddresses.Address e : new VMAddresses(jvmciHotSpotVMAddresses)) {
 139             vmAddresses.put(e.getName(), e);
 140         }
 141 
 142         // Fill the flags hash map.
 143         HashMap&lt;String, Flags.Flag&gt; flags = new HashMap&lt;&gt;();
 144         for (Flags.Flag e : new Flags(vmFields, vmTypes)) {
 145             flags.put(e.getName(), e);
 146         }
 147 
 148         String osName = getHostOSName();
 149         String osArch = getHostArchitectureName();
 150 
 151         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
 152             if (f.isAnnotationPresent(HotSpotVMField.class)) {
 153                 HotSpotVMField annotation = f.getAnnotation(HotSpotVMField.class);
 154                 String name = annotation.name();
 155                 String type = annotation.type();
 156                 VMFields.Field entry = vmFields.get(name);
 157                 if (entry == null) {
 158                     if (!isRequired(osArch, annotation.archs())) {
 159                         continue;
 160                     }
 161                     throw new JVMCIError(f.getName() + ": expected VM field not found: " + name);
 162                 }
 163 
 164                 // Make sure the native type is still the type we expect.
 165                 if (!type.isEmpty()) {
 166                     if (!type.equals(entry.getTypeString())) {
 167                         throw new JVMCIError(f.getName() + ": compiler expects type " + type + " but VM field " + name + " is of type " + entry.getTypeString());
 168                     }
 169                 }
 170 
 171                 switch (annotation.get()) {
 172                     case OFFSET:
 173                         setField(f, entry.getOffset());
 174                         break;
 175                     case ADDRESS:
 176                         setField(f, entry.getAddress());
 177                         break;
 178                     case VALUE:
 179                         setField(f, entry.getValue());
 180                         break;
 181                     default:
 182                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
 183                 }
 184             } else if (f.isAnnotationPresent(HotSpotVMType.class)) {
 185                 HotSpotVMType annotation = f.getAnnotation(HotSpotVMType.class);
 186                 String name = annotation.name();
 187                 VMTypes.Type entry = vmTypes.get(name);
 188                 if (entry == null) {
 189                     throw new JVMCIError(f.getName() + ": expected VM type not found: " + name);
 190                 }
 191 
 192                 switch (annotation.get()) {
 193                     case SIZE:
 194                         setField(f, entry.getSize());
 195                         break;
 196                     default:
 197                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
 198                 }
 199             } else if (f.isAnnotationPresent(HotSpotVMConstant.class)) {
 200                 HotSpotVMConstant annotation = f.getAnnotation(HotSpotVMConstant.class);
 201                 String name = annotation.name();
 202                 AbstractConstant entry = vmConstants.get(name);
 203                 if (entry == null) {
 204                     if (!isRequired(osArch, annotation.archs())) {
 205                         continue;
 206                     }
 207                     throw new JVMCIError(f.getName() + ": expected VM constant not found: " + name);
 208                 }
 209                 setField(f, entry.getValue());
 210             } else if (f.isAnnotationPresent(HotSpotVMAddress.class)) {
 211                 HotSpotVMAddress annotation = f.getAnnotation(HotSpotVMAddress.class);
 212                 String name = annotation.name();
 213                 VMAddresses.Address entry = vmAddresses.get(name);
 214                 if (entry == null) {
 215                     if (!isRequired(osName, annotation.os())) {
 216                         continue;
 217                     }
 218                     throw new JVMCIError(f.getName() + ": expected VM address not found: " + name);
 219                 }
 220                 setField(f, entry.getValue());
 221             } else if (f.isAnnotationPresent(HotSpotVMFlag.class)) {
 222                 HotSpotVMFlag annotation = f.getAnnotation(HotSpotVMFlag.class);
 223                 String name = annotation.name();
 224                 Flags.Flag entry = flags.get(name);
 225                 if (entry == null) {
 226                     if (annotation.optional() || !isRequired(osArch, annotation.archs())) {
 227                         continue;
 228                     }
 229                     throw new JVMCIError(f.getName() + ": expected VM flag not found: " + name);
 230 
 231                 }
 232                 setField(f, entry.getValue());
 233             }
 234         }
 235     }
 236 
 237     private final CompressEncoding oopEncoding;
 238     private final CompressEncoding klassEncoding;
 239 
 240     public CompressEncoding getOopEncoding() {
 241         return oopEncoding;
 242     }
 243 
 244     public CompressEncoding getKlassEncoding() {
 245         return klassEncoding;
 246     }
 247 
 248     private void setField(Field field, Object value) {
 249         try {
 250             Class&lt;?&gt; fieldType = field.getType();
 251             if (fieldType == boolean.class) {
 252                 if (value instanceof String) {
 253                     field.setBoolean(this, Boolean.valueOf((String) value));
 254                 } else if (value instanceof Boolean) {
 255                     field.setBoolean(this, (boolean) value);
 256                 } else if (value instanceof Long) {
 257                     field.setBoolean(this, ((long) value) != 0);
 258                 } else {
 259                     throw new JVMCIError(value.getClass().getSimpleName());
 260                 }
 261             } else if (fieldType == byte.class) {
 262                 if (value instanceof Long) {
 263                     field.setByte(this, (byte) (long) value);
 264                 } else {
 265                     throw new JVMCIError(value.getClass().getSimpleName());
 266                 }
 267             } else if (fieldType == int.class) {
 268                 if (value instanceof Integer) {
 269                     field.setInt(this, (int) value);
 270                 } else if (value instanceof Long) {
 271                     field.setInt(this, (int) (long) value);
 272                 } else {
 273                     throw new JVMCIError(value.getClass().getSimpleName());
 274                 }
 275             } else if (fieldType == long.class) {
 276                 field.setLong(this, (long) value);
 277             } else {
 278                 throw new JVMCIError(field.toString());
 279             }
 280         } catch (IllegalAccessException e) {
 281             throw new JVMCIError("%s: %s", field, e);
 282         }
 283     }
 284 
 285     /**
 286      * Gets the host operating system name.
 287      */
 288     private static String getHostOSName() {
 289         String osName = System.getProperty("os.name");
 290         switch (osName) {
 291             case "Linux":
 292                 osName = "linux";
 293                 break;
 294             case "SunOS":
 295                 osName = "solaris";
 296                 break;
 297             case "Mac OS X":
 298                 osName = "bsd";
 299                 break;
 300             default:
 301                 // Of course Windows is different...
 302                 if (osName.startsWith("Windows")) {
 303                     osName = "windows";
 304                 } else {
 305                     throw new JVMCIError("Unexpected OS name: " + osName);
 306                 }
 307         }
 308         return osName;
 309     }
 310 
 311     /**
 312      * Gets the host architecture name for the purpose of finding the corresponding
 313      * {@linkplain HotSpotJVMCIBackendFactory backend}.
 314      */
 315     public String getHostArchitectureName() {
 316         String arch = System.getProperty("os.arch");
 317         switch (arch) {
 318             case "x86_64":
 319                 arch = "amd64";
 320                 break;
 321             case "sparcv9":
 322                 arch = "sparc";
 323                 break;
 324         }
 325         return arch;
 326     }
 327 
 328     /**
 329      * Determines if the current specification is included in a given set of specifications.
 330      *
 331      * @param current
 332      * @param specification specifies a set of specifications, e.g. architectures or operating
 333      *            systems. A zero length value implies all.
 334      */
 335     private static boolean isRequired(String current, String[] specification) {
 336         if (specification.length == 0) {
 337             return true;
 338         }
 339         for (String arch : specification) {
 340             if (arch.equals(current)) {
 341                 return true;
 342             }
 343         }
 344         return false;
 345     }
 346 
 347     /**
 348      * VMStructEntry (see {@code vmStructs.hpp}).
 349      */
 350     @HotSpotVMData(index = 0) @Stable private long jvmciHotSpotVMStructs;
 351     @HotSpotVMData(index = 1) @Stable private long jvmciHotSpotVMStructEntryTypeNameOffset;
 352     @HotSpotVMData(index = 2) @Stable private long jvmciHotSpotVMStructEntryFieldNameOffset;
 353     @HotSpotVMData(index = 3) @Stable private long jvmciHotSpotVMStructEntryTypeStringOffset;
 354     @HotSpotVMData(index = 4) @Stable private long jvmciHotSpotVMStructEntryIsStaticOffset;
 355     @HotSpotVMData(index = 5) @Stable private long jvmciHotSpotVMStructEntryOffsetOffset;
 356     @HotSpotVMData(index = 6) @Stable private long jvmciHotSpotVMStructEntryAddressOffset;
 357     @HotSpotVMData(index = 7) @Stable private long jvmciHotSpotVMStructEntryArrayStride;
 358 
 359     final class VMFields implements Iterable&lt;VMFields.Field&gt; {
 360 
 361         private final long address;
 362 
 363         VMFields(long address) {
 364             this.address = address;
 365         }
 366 
 367         public Iterator&lt;VMFields.Field&gt; iterator() {
 368             return new Iterator&lt;VMFields.Field&gt;() {
 369 
 370                 private int index = 0;
 371 
 372                 private Field current() {
 373                     return new Field(address + jvmciHotSpotVMStructEntryArrayStride * index);
 374                 }
 375 
 376                 /**
 377                  * The last entry is identified by a NULL fieldName.
 378                  */
 379                 public boolean hasNext() {
 380                     Field entry = current();
 381                     return entry.getFieldName() != null;
 382                 }
 383 
 384                 public Field next() {
 385                     Field entry = current();
 386                     index++;
 387                     return entry;
 388                 }
 389             };
 390         }
 391 
 392         final class Field {
 393 
 394             private final long entryAddress;
 395 
 396             Field(long address) {
 397                 this.entryAddress = address;
 398             }
 399 
 400             public String getTypeName() {
 401                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeNameOffset);
 402                 return readCString(UNSAFE, typeNameAddress);
 403             }
 404 
 405             public String getFieldName() {
 406                 long fieldNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryFieldNameOffset);
 407                 return readCString(UNSAFE, fieldNameAddress);
 408             }
 409 
 410             public String getTypeString() {
 411                 long typeStringAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeStringOffset);
 412                 return readCString(UNSAFE, typeStringAddress);
 413             }
 414 
 415             public boolean isStatic() {
 416                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMStructEntryIsStaticOffset) != 0;
 417             }
 418 
 419             public long getOffset() {
 420                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMStructEntryOffsetOffset);
 421             }
 422 
 423             public long getAddress() {
 424                 return UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryAddressOffset);
 425             }
 426 
 427             public String getName() {
 428                 String typeName = getTypeName();
 429                 String fieldName = getFieldName();
 430                 return typeName + "::" + fieldName;
 431             }
 432 
 433             public long getValue() {
 434                 String type = getTypeString();
 435                 switch (type) {
 436                     case "bool":
 437                         return UNSAFE.getByte(getAddress());
 438                     case "int":
 439                         return UNSAFE.getInt(getAddress());
 440                     case "uint64_t":
 441                         return UNSAFE.getLong(getAddress());
 442                     case "address":
 443                     case "intptr_t":
 444                     case "uintptr_t":
 445                     case "size_t":
 446                         return UNSAFE.getAddress(getAddress());
 447                     default:
 448                         // All foo* types are addresses.
 449                         if (type.endsWith("*")) {
 450                             return UNSAFE.getAddress(getAddress());
 451                         }
 452                         throw new JVMCIError(type);
 453                 }
 454             }
 455 
 456             @Override
 457             public String toString() {
 458                 return String.format("Field[typeName=%s, fieldName=%s, typeString=%s, isStatic=%b, offset=%d, address=0x%x]", getTypeName(), getFieldName(), getTypeString(), isStatic(), getOffset(),
 459                                 getAddress());
 460             }
 461         }
 462     }
 463 
 464     /**
 465      * VMTypeEntry (see vmStructs.hpp).
 466      */
 467     @HotSpotVMData(index = 8) @Stable private long jvmciHotSpotVMTypes;
 468     @HotSpotVMData(index = 9) @Stable private long jvmciHotSpotVMTypeEntryTypeNameOffset;
 469     @HotSpotVMData(index = 10) @Stable private long jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 470     @HotSpotVMData(index = 11) @Stable private long jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 471     @HotSpotVMData(index = 12) @Stable private long jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 472     @HotSpotVMData(index = 13) @Stable private long jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 473     @HotSpotVMData(index = 14) @Stable private long jvmciHotSpotVMTypeEntrySizeOffset;
 474     @HotSpotVMData(index = 15) @Stable private long jvmciHotSpotVMTypeEntryArrayStride;
 475 
 476     final class VMTypes implements Iterable&lt;VMTypes.Type&gt; {
 477 
 478         private final long address;
 479 
 480         VMTypes(long address) {
 481             this.address = address;
 482         }
 483 
 484         public Iterator&lt;VMTypes.Type&gt; iterator() {
 485             return new Iterator&lt;VMTypes.Type&gt;() {
 486 
 487                 private int index = 0;
 488 
 489                 private Type current() {
 490                     return new Type(address + jvmciHotSpotVMTypeEntryArrayStride * index);
 491                 }
 492 
 493                 /**
 494                  * The last entry is identified by a NULL type name.
 495                  */
 496                 public boolean hasNext() {
 497                     Type entry = current();
 498                     return entry.getTypeName() != null;
 499                 }
 500 
 501                 public Type next() {
 502                     Type entry = current();
 503                     index++;
 504                     return entry;
 505                 }
 506             };
 507         }
 508 
 509         final class Type {
 510 
 511             private final long entryAddress;
 512 
 513             Type(long address) {
 514                 this.entryAddress = address;
 515             }
 516 
 517             public String getTypeName() {
 518                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntryTypeNameOffset);
 519                 return readCString(UNSAFE, typeNameAddress);
 520             }
 521 
 522             public String getSuperclassName() {
 523                 long superclassNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntrySuperclassNameOffset);
 524                 return readCString(UNSAFE, superclassNameAddress);
 525             }
 526 
 527             public boolean isOopType() {
 528                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsOopTypeOffset) != 0;
 529             }
 530 
 531             public boolean isIntegerType() {
 532                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsIntegerTypeOffset) != 0;
 533             }
 534 
 535             public boolean isUnsigned() {
 536                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsUnsignedOffset) != 0;
 537             }
 538 
 539             public long getSize() {
 540                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMTypeEntrySizeOffset);
 541             }
 542 
 543             @Override
 544             public String toString() {
 545                 return String.format("Type[typeName=%s, superclassName=%s, isOopType=%b, isIntegerType=%b, isUnsigned=%b, size=%d]", getTypeName(), getSuperclassName(), isOopType(), isIntegerType(),
 546                                 isUnsigned(), getSize());
 547             }
 548         }
 549     }
 550 
 551     public abstract class AbstractConstant {
 552 
 553         protected final long address;
 554         protected final long nameOffset;
 555         protected final long valueOffset;
 556 
 557         AbstractConstant(long address, long nameOffset, long valueOffset) {
 558             this.address = address;
 559             this.nameOffset = nameOffset;
 560             this.valueOffset = valueOffset;
 561         }
 562 
 563         public String getName() {
 564             long nameAddress = UNSAFE.getAddress(address + nameOffset);
 565             return readCString(UNSAFE, nameAddress);
 566         }
 567 
 568         public abstract long getValue();
 569     }
 570 
 571     /**
 572      * VMIntConstantEntry (see vmStructs.hpp).
 573      */
 574     @HotSpotVMData(index = 16) @Stable private long jvmciHotSpotVMIntConstants;
 575     @HotSpotVMData(index = 17) @Stable private long jvmciHotSpotVMIntConstantEntryNameOffset;
 576     @HotSpotVMData(index = 18) @Stable private long jvmciHotSpotVMIntConstantEntryValueOffset;
 577     @HotSpotVMData(index = 19) @Stable private long jvmciHotSpotVMIntConstantEntryArrayStride;
 578 
 579     final class VMIntConstants implements Iterable&lt;VMIntConstants.Constant&gt; {
 580 
 581         private final long address;
 582 
 583         VMIntConstants(long address) {
 584             this.address = address;
 585         }
 586 
 587         public Iterator&lt;VMIntConstants.Constant&gt; iterator() {
 588             return new Iterator&lt;VMIntConstants.Constant&gt;() {
 589 
 590                 private int index = 0;
 591 
 592                 private Constant current() {
 593                     return new Constant(address + jvmciHotSpotVMIntConstantEntryArrayStride * index);
 594                 }
 595 
 596                 /**
 597                  * The last entry is identified by a NULL name.
 598                  */
 599                 public boolean hasNext() {
 600                     Constant entry = current();
 601                     return entry.getName() != null;
 602                 }
 603 
 604                 public Constant next() {
 605                     Constant entry = current();
 606                     index++;
 607                     return entry;
 608                 }
 609             };
 610         }
 611 
 612         final class Constant extends AbstractConstant {
 613 
 614             Constant(long address) {
 615                 super(address, jvmciHotSpotVMIntConstantEntryNameOffset, jvmciHotSpotVMIntConstantEntryValueOffset);
 616             }
 617 
 618             @Override
 619             public long getValue() {
 620                 return UNSAFE.getInt(address + valueOffset);
 621             }
 622 
 623             @Override
 624             public String toString() {
 625                 return String.format("IntConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 626             }
 627         }
 628     }
 629 
 630     /**
 631      * VMLongConstantEntry (see vmStructs.hpp).
 632      */
 633     @HotSpotVMData(index = 20) @Stable private long jvmciHotSpotVMLongConstants;
 634     @HotSpotVMData(index = 21) @Stable private long jvmciHotSpotVMLongConstantEntryNameOffset;
 635     @HotSpotVMData(index = 22) @Stable private long jvmciHotSpotVMLongConstantEntryValueOffset;
 636     @HotSpotVMData(index = 23) @Stable private long jvmciHotSpotVMLongConstantEntryArrayStride;
 637 
 638     final class VMLongConstants implements Iterable&lt;VMLongConstants.Constant&gt; {
 639 
 640         private final long address;
 641 
 642         VMLongConstants(long address) {
 643             this.address = address;
 644         }
 645 
 646         public Iterator&lt;VMLongConstants.Constant&gt; iterator() {
 647             return new Iterator&lt;VMLongConstants.Constant&gt;() {
 648 
 649                 private int index = 0;
 650 
 651                 private Constant currentEntry() {
 652                     return new Constant(address + jvmciHotSpotVMLongConstantEntryArrayStride * index);
 653                 }
 654 
 655                 /**
 656                  * The last entry is identified by a NULL name.
 657                  */
 658                 public boolean hasNext() {
 659                     Constant entry = currentEntry();
 660                     return entry.getName() != null;
 661                 }
 662 
 663                 public Constant next() {
 664                     Constant entry = currentEntry();
 665                     index++;
 666                     return entry;
 667                 }
 668             };
 669         }
 670 
 671         final class Constant extends AbstractConstant {
 672 
 673             Constant(long address) {
 674                 super(address, jvmciHotSpotVMLongConstantEntryNameOffset, jvmciHotSpotVMLongConstantEntryValueOffset);
 675             }
 676 
 677             @Override
 678             public long getValue() {
 679                 return UNSAFE.getLong(address + valueOffset);
 680             }
 681 
 682             @Override
 683             public String toString() {
 684                 return String.format("LongConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 685             }
 686         }
 687     }
 688 
 689     /**
 690      * VMAddressEntry (see vmStructs.hpp).
 691      */
 692     @HotSpotVMData(index = 24) @Stable private long jvmciHotSpotVMAddresses;
 693     @HotSpotVMData(index = 25) @Stable private long jvmciHotSpotVMAddressEntryNameOffset;
 694     @HotSpotVMData(index = 26) @Stable private long jvmciHotSpotVMAddressEntryValueOffset;
 695     @HotSpotVMData(index = 27) @Stable private long jvmciHotSpotVMAddressEntryArrayStride;
 696 
 697     final class VMAddresses implements Iterable&lt;VMAddresses.Address&gt; {
 698 
 699         private final long address;
 700 
 701         VMAddresses(long address) {
 702             this.address = address;
 703         }
 704 
 705         public Iterator&lt;VMAddresses.Address&gt; iterator() {
 706             return new Iterator&lt;VMAddresses.Address&gt;() {
 707 
 708                 private int index = 0;
 709 
 710                 private Address currentEntry() {
 711                     return new Address(address + jvmciHotSpotVMAddressEntryArrayStride * index);
 712                 }
 713 
 714                 /**
 715                  * The last entry is identified by a NULL name.
 716                  */
 717                 public boolean hasNext() {
 718                     Address entry = currentEntry();
 719                     return entry.getName() != null;
 720                 }
 721 
 722                 public Address next() {
 723                     Address entry = currentEntry();
 724                     index++;
 725                     return entry;
 726                 }
 727             };
 728         }
 729 
 730         final class Address extends AbstractConstant {
 731 
 732             Address(long address) {
 733                 super(address, jvmciHotSpotVMAddressEntryNameOffset, jvmciHotSpotVMAddressEntryValueOffset);
 734             }
 735 
 736             @Override
 737             public long getValue() {
 738                 return UNSAFE.getLong(address + valueOffset);
 739             }
 740 
 741             @Override
 742             public String toString() {
 743                 return String.format("Address[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 744             }
 745         }
 746     }
 747 
 748     final class Flags implements Iterable&lt;Flags.Flag&gt; {
 749 
 750         private final long address;
 751         private final long entrySize;
 752         private final long typeOffset;
 753         private final long nameOffset;
 754         private final long addrOffset;
 755 
 756         Flags(HashMap&lt;String, VMFields.Field&gt; vmStructs, HashMap&lt;String, VMTypes.Type&gt; vmTypes) {
 757             address = vmStructs.get("Flag::flags").getValue();
 758             entrySize = vmTypes.get("Flag").getSize();
 759             typeOffset = vmStructs.get("Flag::_type").getOffset();
 760             nameOffset = vmStructs.get("Flag::_name").getOffset();
 761             addrOffset = vmStructs.get("Flag::_addr").getOffset();
 762 
 763             assert vmTypes.get("bool").getSize() == Byte.BYTES;
 764             assert vmTypes.get("intx").getSize() == Long.BYTES;
 765             assert vmTypes.get("uintx").getSize() == Long.BYTES;
 766         }
 767 
 768         public Iterator&lt;Flags.Flag&gt; iterator() {
 769             return new Iterator&lt;Flags.Flag&gt;() {
 770 
 771                 private int index = 0;
 772 
 773                 private Flag current() {
 774                     return new Flag(address + entrySize * index);
 775                 }
 776 
 777                 /**
 778                  * The last entry is identified by a NULL name.
 779                  */
 780                 public boolean hasNext() {
 781                     Flag entry = current();
 782                     return entry.getName() != null;
 783                 }
 784 
 785                 public Flag next() {
 786                     Flag entry = current();
 787                     index++;
 788                     return entry;
 789                 }
 790             };
 791         }
 792 
 793         final class Flag {
 794 
 795             private final long entryAddress;
 796 
 797             Flag(long address) {
 798                 this.entryAddress = address;
 799             }
 800 
 801             public String getType() {
 802                 long typeAddress = UNSAFE.getAddress(entryAddress + typeOffset);
 803                 return readCString(UNSAFE, typeAddress);
 804             }
 805 
 806             public String getName() {
 807                 long nameAddress = UNSAFE.getAddress(entryAddress + nameOffset);
 808                 return readCString(UNSAFE, nameAddress);
 809             }
 810 
 811             public long getAddr() {
 812                 return UNSAFE.getAddress(entryAddress + addrOffset);
 813             }
 814 
 815             public Object getValue() {
 816                 switch (getType()) {
 817                     case "bool":
 818                         return Boolean.valueOf(UNSAFE.getByte(getAddr()) != 0);
 819                     case "intx":
 820                     case "uintx":
 821                     case "uint64_t":
 822                         return Long.valueOf(UNSAFE.getLong(getAddr()));
 823                     case "double":
 824                         return Double.valueOf(UNSAFE.getDouble(getAddr()));
 825                     case "ccstr":
 826                     case "ccstrlist":
 827                         return readCString(UNSAFE, getAddr());
 828                     default:
 829                         throw new JVMCIError(getType());
 830                 }
 831             }
 832 
 833             @Override
 834             public String toString() {
 835                 return String.format("Flag[type=%s, name=%s, value=%s]", getType(), getName(), getValue());
 836             }
 837         }
 838     }
 839 
 840     @HotSpotVMConstant(name = "ASSERT") @Stable public boolean cAssertions;
 841     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
 842     public final boolean linuxOs = System.getProperty("os.name", "").startsWith("Linux");
 843 
 844     @HotSpotVMFlag(name = "CodeEntryAlignment") @Stable public int codeEntryAlignment;
 845     @HotSpotVMFlag(name = "VerifyOops") @Stable public boolean verifyOops;
 846     @HotSpotVMFlag(name = "CITime") @Stable public boolean ciTime;
 847     @HotSpotVMFlag(name = "CITimeEach") @Stable public boolean ciTimeEach;
 848     @HotSpotVMFlag(name = "CompileTheWorldStartAt", optional = true) @Stable public int compileTheWorldStartAt;
 849     @HotSpotVMFlag(name = "CompileTheWorldStopAt", optional = true) @Stable public int compileTheWorldStopAt;
 850     @HotSpotVMFlag(name = "DontCompileHugeMethods") @Stable public boolean dontCompileHugeMethods;
 851     @HotSpotVMFlag(name = "HugeMethodLimit") @Stable public int hugeMethodLimit;
 852     @HotSpotVMFlag(name = "PrintInlining") @Stable public boolean printInlining;
 853     @HotSpotVMFlag(name = "JVMCIUseFastLocking") @Stable public boolean useFastLocking;
 854     @HotSpotVMFlag(name = "ForceUnreachable") @Stable public boolean forceUnreachable;
 855     @HotSpotVMFlag(name = "CodeCacheSegmentSize") @Stable public int codeSegmentSize;
 856     @HotSpotVMFlag(name = "FoldStableValues") @Stable public boolean foldStableValues;
 857 
 858     @HotSpotVMFlag(name = "UseTLAB") @Stable public boolean useTLAB;
 859     @HotSpotVMFlag(name = "UseBiasedLocking") @Stable public boolean useBiasedLocking;
 860     @HotSpotVMFlag(name = "UsePopCountInstruction") @Stable public boolean usePopCountInstruction;
 861     @HotSpotVMFlag(name = "UseCountLeadingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountLeadingZerosInstruction;
 862     @HotSpotVMFlag(name = "UseCountTrailingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountTrailingZerosInstruction;
 863     @HotSpotVMFlag(name = "UseAESIntrinsics") @Stable public boolean useAESIntrinsics;
 864     @HotSpotVMFlag(name = "UseCRC32Intrinsics") @Stable public boolean useCRC32Intrinsics;
 865     @HotSpotVMFlag(name = "UseG1GC") @Stable public boolean useG1GC;
 866     @HotSpotVMFlag(name = "UseConcMarkSweepGC") @Stable public boolean useCMSGC;
 867 
 868     @HotSpotVMFlag(name = "AllocatePrefetchStyle") @Stable public int allocatePrefetchStyle;
 869     @HotSpotVMFlag(name = "AllocatePrefetchInstr") @Stable public int allocatePrefetchInstr;
 870     @HotSpotVMFlag(name = "AllocatePrefetchLines") @Stable public int allocatePrefetchLines;
 871     @HotSpotVMFlag(name = "AllocateInstancePrefetchLines") @Stable public int allocateInstancePrefetchLines;
 872     @HotSpotVMFlag(name = "AllocatePrefetchStepSize") @Stable public int allocatePrefetchStepSize;
 873     @HotSpotVMFlag(name = "AllocatePrefetchDistance") @Stable public int allocatePrefetchDistance;
 874 
 875     @HotSpotVMFlag(name = "FlightRecorder", optional = true) @Stable public boolean flightRecorder;
 876 
 877     @HotSpotVMField(name = "CompilerToVM::Data::Universe_collectedHeap", type = "CollectedHeap*", get = HotSpotVMField.Type.VALUE) @Stable private long universeCollectedHeap;
 878     @HotSpotVMField(name = "CollectedHeap::_total_collections", type = "unsigned int", get = HotSpotVMField.Type.OFFSET) @Stable private int collectedHeapTotalCollectionsOffset;
 879 
 880     public long gcTotalCollectionsAddress() {
 881         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
 882     }
 883 
 884     @HotSpotVMFlag(name = "ReduceInitialCardMarks") @Stable public boolean useDeferredInitBarriers;
 885 
 886     // Compressed Oops related values.
 887     @HotSpotVMFlag(name = "UseCompressedOops") @Stable public boolean useCompressedOops;
 888     @HotSpotVMFlag(name = "UseCompressedClassPointers") @Stable public boolean useCompressedClassPointers;
 889 
 890     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowOopBase;
 891     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowOopShift;
 892     @HotSpotVMFlag(name = "ObjectAlignmentInBytes") @Stable public int objectAlignment;
 893 
 894     public final int minObjAlignment() {
 895         return objectAlignment / heapWordSize;
 896     }
 897 
 898     public final int logMinObjAlignment() {
 899         return (int) (Math.log(objectAlignment) / Math.log(2));
 900     }
 901 
 902     @HotSpotVMType(name = "narrowKlass", get = HotSpotVMType.Type.SIZE) @Stable public int narrowKlassSize;
 903     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowKlassBase;
 904     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowKlassShift;
 905     @HotSpotVMConstant(name = "LogKlassAlignmentInBytes") @Stable public int logKlassAlignment;
 906 
 907     // CPU capabilities
 908     @HotSpotVMFlag(name = "UseSSE") @Stable public int useSSE;
 909     @HotSpotVMFlag(name = "UseAVX", archs = {"amd64"}) @Stable public int useAVX;
 910 
 911     @HotSpotVMField(name = "Abstract_VM_Version::_features", type = "uint64_t", get = HotSpotVMField.Type.VALUE) @Stable public long vmVersionFeatures;
 912 
 913     // AMD64 specific values
 914     @HotSpotVMConstant(name = "VM_Version::CPU_CX8", archs = {"amd64"}) @Stable public long amd64CX8;
 915     @HotSpotVMConstant(name = "VM_Version::CPU_CMOV", archs = {"amd64"}) @Stable public long amd64CMOV;
 916     @HotSpotVMConstant(name = "VM_Version::CPU_FXSR", archs = {"amd64"}) @Stable public long amd64FXSR;
 917     @HotSpotVMConstant(name = "VM_Version::CPU_HT", archs = {"amd64"}) @Stable public long amd64HT;
 918     @HotSpotVMConstant(name = "VM_Version::CPU_MMX", archs = {"amd64"}) @Stable public long amd64MMX;
 919     @HotSpotVMConstant(name = "VM_Version::CPU_3DNOW_PREFETCH", archs = {"amd64"}) @Stable public long amd643DNOWPREFETCH;
 920     @HotSpotVMConstant(name = "VM_Version::CPU_SSE", archs = {"amd64"}) @Stable public long amd64SSE;
 921     @HotSpotVMConstant(name = "VM_Version::CPU_SSE2", archs = {"amd64"}) @Stable public long amd64SSE2;
 922     @HotSpotVMConstant(name = "VM_Version::CPU_SSE3", archs = {"amd64"}) @Stable public long amd64SSE3;
 923     @HotSpotVMConstant(name = "VM_Version::CPU_SSSE3", archs = {"amd64"}) @Stable public long amd64SSSE3;
 924     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4A", archs = {"amd64"}) @Stable public long amd64SSE4A;
 925     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_1", archs = {"amd64"}) @Stable public long amd64SSE41;
 926     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_2", archs = {"amd64"}) @Stable public long amd64SSE42;
 927     @HotSpotVMConstant(name = "VM_Version::CPU_POPCNT", archs = {"amd64"}) @Stable public long amd64POPCNT;
 928     @HotSpotVMConstant(name = "VM_Version::CPU_LZCNT", archs = {"amd64"}) @Stable public long amd64LZCNT;
 929     @HotSpotVMConstant(name = "VM_Version::CPU_TSC", archs = {"amd64"}) @Stable public long amd64TSC;
 930     @HotSpotVMConstant(name = "VM_Version::CPU_TSCINV", archs = {"amd64"}) @Stable public long amd64TSCINV;
 931     @HotSpotVMConstant(name = "VM_Version::CPU_AVX", archs = {"amd64"}) @Stable public long amd64AVX;
 932     @HotSpotVMConstant(name = "VM_Version::CPU_AVX2", archs = {"amd64"}) @Stable public long amd64AVX2;
 933     @HotSpotVMConstant(name = "VM_Version::CPU_AES", archs = {"amd64"}) @Stable public long amd64AES;
 934     @HotSpotVMConstant(name = "VM_Version::CPU_ERMS", archs = {"amd64"}) @Stable public long amd64ERMS;
 935     @HotSpotVMConstant(name = "VM_Version::CPU_CLMUL", archs = {"amd64"}) @Stable public long amd64CLMUL;
 936     @HotSpotVMConstant(name = "VM_Version::CPU_BMI1", archs = {"amd64"}) @Stable public long amd64BMI1;
 937     @HotSpotVMConstant(name = "VM_Version::CPU_BMI2", archs = {"amd64"}) @Stable public long amd64BMI2;
 938     @HotSpotVMConstant(name = "VM_Version::CPU_RTM", archs = {"amd64"}) @Stable public long amd64RTM;
 939     @HotSpotVMConstant(name = "VM_Version::CPU_ADX", archs = {"amd64"}) @Stable public long amd64ADX;
 940     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512F", archs = {"amd64"}) @Stable public long amd64AVX512F;
 941     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512DQ", archs = {"amd64"}) @Stable public long amd64AVX512DQ;
 942     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512PF", archs = {"amd64"}) @Stable public long amd64AVX512PF;
 943     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512ER", archs = {"amd64"}) @Stable public long amd64AVX512ER;
 944     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512CD", archs = {"amd64"}) @Stable public long amd64AVX512CD;
 945     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512BW", archs = {"amd64"}) @Stable public long amd64AVX512BW;
 946     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512VL", archs = {"amd64"}) @Stable public long amd64AVX512VL;
 947 
 948     // SPARC specific values
 949     @HotSpotVMConstant(name = "VM_Version::vis3_instructions_m", archs = {"sparc"}) @Stable public int sparcVis3Instructions;
 950     @HotSpotVMConstant(name = "VM_Version::vis2_instructions_m", archs = {"sparc"}) @Stable public int sparcVis2Instructions;
 951     @HotSpotVMConstant(name = "VM_Version::vis1_instructions_m", archs = {"sparc"}) @Stable public int sparcVis1Instructions;
 952     @HotSpotVMConstant(name = "VM_Version::cbcond_instructions_m", archs = {"sparc"}) @Stable public int sparcCbcondInstructions;
 953     @HotSpotVMConstant(name = "VM_Version::v8_instructions_m", archs = {"sparc"}) @Stable public int sparcV8Instructions;
 954     @HotSpotVMConstant(name = "VM_Version::hardware_mul32_m", archs = {"sparc"}) @Stable public int sparcHardwareMul32;
 955     @HotSpotVMConstant(name = "VM_Version::hardware_div32_m", archs = {"sparc"}) @Stable public int sparcHardwareDiv32;
 956     @HotSpotVMConstant(name = "VM_Version::hardware_fsmuld_m", archs = {"sparc"}) @Stable public int sparcHardwareFsmuld;
 957     @HotSpotVMConstant(name = "VM_Version::hardware_popc_m", archs = {"sparc"}) @Stable public int sparcHardwarePopc;
 958     @HotSpotVMConstant(name = "VM_Version::v9_instructions_m", archs = {"sparc"}) @Stable public int sparcV9Instructions;
 959     @HotSpotVMConstant(name = "VM_Version::sun4v_m", archs = {"sparc"}) @Stable public int sparcSun4v;
 960     @HotSpotVMConstant(name = "VM_Version::blk_init_instructions_m", archs = {"sparc"}) @Stable public int sparcBlkInitInstructions;
 961     @HotSpotVMConstant(name = "VM_Version::fmaf_instructions_m", archs = {"sparc"}) @Stable public int sparcFmafInstructions;
 962     @HotSpotVMConstant(name = "VM_Version::fmau_instructions_m", archs = {"sparc"}) @Stable public int sparcFmauInstructions;
 963     @HotSpotVMConstant(name = "VM_Version::sparc64_family_m", archs = {"sparc"}) @Stable public int sparcSparc64Family;
 964     @HotSpotVMConstant(name = "VM_Version::M_family_m", archs = {"sparc"}) @Stable public int sparcMFamily;
 965     @HotSpotVMConstant(name = "VM_Version::T_family_m", archs = {"sparc"}) @Stable public int sparcTFamily;
 966     @HotSpotVMConstant(name = "VM_Version::T1_model_m", archs = {"sparc"}) @Stable public int sparcT1Model;
 967     @HotSpotVMConstant(name = "VM_Version::sparc5_instructions_m", archs = {"sparc"}) @Stable public int sparcSparc5Instructions;
 968     @HotSpotVMConstant(name = "VM_Version::aes_instructions_m", archs = {"sparc"}) @Stable public int sparcAesInstructions;
 969     @HotSpotVMConstant(name = "VM_Version::sha1_instruction_m", archs = {"sparc"}) @Stable public int sparcSha1Instruction;
 970     @HotSpotVMConstant(name = "VM_Version::sha256_instruction_m", archs = {"sparc"}) @Stable public int sparcSha256Instruction;
 971     @HotSpotVMConstant(name = "VM_Version::sha512_instruction_m", archs = {"sparc"}) @Stable public int sparcSha512Instruction;
 972 
 973     @HotSpotVMFlag(name = "UseBlockZeroing", archs = {"sparc"}) @Stable public boolean useBlockZeroing;
 974     @HotSpotVMFlag(name = "BlockZeroingLowLimit", archs = {"sparc"}) @Stable public int blockZeroingLowLimit;
 975 
 976     @HotSpotVMFlag(name = "StackShadowPages") @Stable public int stackShadowPages;
 977     @HotSpotVMFlag(name = "UseStackBanging") @Stable public boolean useStackBanging;
 978     @HotSpotVMConstant(name = "STACK_BIAS") @Stable public int stackBias;
 979     @HotSpotVMField(name = "CompilerToVM::Data::vm_page_size", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int vmPageSize;
 980 
 981     // offsets, ...
 982     @HotSpotVMField(name = "oopDesc::_mark", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int markOffset;
 983     @HotSpotVMField(name = "oopDesc::_metadata._klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int hubOffset;
 984 
 985     @HotSpotVMField(name = "Klass::_prototype_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int prototypeMarkWordOffset;
 986     @HotSpotVMField(name = "Klass::_subklass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int subklassOffset;
 987     @HotSpotVMField(name = "Klass::_next_sibling", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int nextSiblingOffset;
 988     @HotSpotVMField(name = "Klass::_super_check_offset", type = "juint", get = HotSpotVMField.Type.OFFSET) @Stable public int superCheckOffsetOffset;
 989     @HotSpotVMField(name = "Klass::_secondary_super_cache", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySuperCacheOffset;
 990     @HotSpotVMField(name = "Klass::_secondary_supers", type = "Array&lt;Klass*&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySupersOffset;
 991 
 992     /**
 993      * The offset of the _java_mirror field (of type {@link Class}) in a Klass.
 994      */
 995     @HotSpotVMField(name = "Klass::_java_mirror", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int classMirrorOffset;
 996 
 997     @HotSpotVMField(name = "Klass::_super", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int klassSuperKlassOffset;
 998     @HotSpotVMField(name = "Klass::_modifier_flags", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassModifierFlagsOffset;
 999     @HotSpotVMField(name = "Klass::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int klassAccessFlagsOffset;
1000     @HotSpotVMField(name = "Klass::_layout_helper", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassLayoutHelperOffset;
1001 
1002     @HotSpotVMConstant(name = "Klass::_lh_neutral_value") @Stable public int klassLayoutHelperNeutralValue;
1003     @HotSpotVMConstant(name = "Klass::_lh_instance_slow_path_bit") @Stable public int klassLayoutHelperInstanceSlowPathBit;
1004     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_shift") @Stable public int layoutHelperLog2ElementSizeShift;
1005     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_mask") @Stable public int layoutHelperLog2ElementSizeMask;
1006     @HotSpotVMConstant(name = "Klass::_lh_element_type_shift") @Stable public int layoutHelperElementTypeShift;
1007     @HotSpotVMConstant(name = "Klass::_lh_element_type_mask") @Stable public int layoutHelperElementTypeMask;
1008     @HotSpotVMConstant(name = "Klass::_lh_header_size_shift") @Stable public int layoutHelperHeaderSizeShift;
1009     @HotSpotVMConstant(name = "Klass::_lh_header_size_mask") @Stable public int layoutHelperHeaderSizeMask;
1010     @HotSpotVMConstant(name = "Klass::_lh_array_tag_shift") @Stable public int layoutHelperArrayTagShift;
1011     @HotSpotVMConstant(name = "Klass::_lh_array_tag_type_value") @Stable public int layoutHelperArrayTagTypeValue;
1012     @HotSpotVMConstant(name = "Klass::_lh_array_tag_obj_value") @Stable public int layoutHelperArrayTagObjectValue;
1013 
1014     /**
1015      * This filters out the bit that differentiates a type array from an object array.
1016      */
1017     public int layoutHelperElementTypePrimitiveInPlace() {
1018         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
1019     }
1020 
1021     /**
1022      * Bit pattern in the klass layout helper that can be used to identify arrays.
1023      */
1024     public final int arrayKlassLayoutHelperIdentifier = 0x80000000;
1025 
1026     @HotSpotVMType(name = "vtableEntry", get = HotSpotVMType.Type.SIZE) @Stable public int vtableEntrySize;
1027     @HotSpotVMField(name = "vtableEntry::_method", type = "Method*", get = HotSpotVMField.Type.OFFSET) @Stable public int vtableEntryMethodOffset;
1028 
1029     @HotSpotVMType(name = "InstanceKlass", get = HotSpotVMType.Type.SIZE) @Stable public int instanceKlassSize;
1030     @HotSpotVMField(name = "InstanceKlass::_source_file_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassSourceFileNameIndexOffset;
1031     @HotSpotVMField(name = "InstanceKlass::_init_state", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassInitStateOffset;
1032     @HotSpotVMField(name = "InstanceKlass::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassConstantsOffset;
1033     @HotSpotVMField(name = "InstanceKlass::_fields", type = "Array&lt;u2&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassFieldsOffset;
1034     @HotSpotVMField(name = "CompilerToVM::Data::InstanceKlass_vtable_start_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int instanceKlassVtableStartOffset;
1035     @HotSpotVMField(name = "CompilerToVM::Data::InstanceKlass_vtable_length_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int instanceKlassVtableLengthOffset;
1036 
1037     @HotSpotVMConstant(name = "InstanceKlass::linked") @Stable public int instanceKlassStateLinked;
1038     @HotSpotVMConstant(name = "InstanceKlass::fully_initialized") @Stable public int instanceKlassStateFullyInitialized;
1039 
1040     /**
1041      * See {@code InstanceKlass::vtable_start_offset()}.
1042      */
1043     public final int instanceKlassVtableStartOffset() {
1044         return instanceKlassVtableStartOffset * heapWordSize;
1045     }
1046 
1047     @HotSpotVMType(name = "arrayOopDesc", get = HotSpotVMType.Type.SIZE) @Stable public int arrayOopDescSize;
1048 
1049     /**
1050      * The offset of the array length word in an array object's header.
1051      *
1052      * See {@code arrayOopDesc::length_offset_in_bytes()}.
1053      */
1054     public final int arrayOopDescLengthOffset() {
1055         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
1056     }
1057 
1058     @HotSpotVMField(name = "Array&lt;int&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1LengthOffset;
1059     @HotSpotVMField(name = "Array&lt;u1&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1DataOffset;
1060     @HotSpotVMField(name = "Array&lt;u2&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU2DataOffset;
1061     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayLengthOffset;
1062     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_data[0]", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayBaseOffset;
1063 
1064     @HotSpotVMField(name = "ObjArrayKlass::_element_klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayClassElementOffset;
1065 
1066     @HotSpotVMConstant(name = "FieldInfo::access_flags_offset") @Stable public int fieldInfoAccessFlagsOffset;
1067     @HotSpotVMConstant(name = "FieldInfo::name_index_offset") @Stable public int fieldInfoNameIndexOffset;
1068     @HotSpotVMConstant(name = "FieldInfo::signature_index_offset") @Stable public int fieldInfoSignatureIndexOffset;
1069     @HotSpotVMConstant(name = "FieldInfo::initval_index_offset") @Stable public int fieldInfoInitvalIndexOffset;
1070     @HotSpotVMConstant(name = "FieldInfo::low_packed_offset") @Stable public int fieldInfoLowPackedOffset;
1071     @HotSpotVMConstant(name = "FieldInfo::high_packed_offset") @Stable public int fieldInfoHighPackedOffset;
1072     @HotSpotVMConstant(name = "FieldInfo::field_slots") @Stable public int fieldInfoFieldSlots;
1073 
1074     @HotSpotVMConstant(name = "FIELDINFO_TAG_SIZE") @Stable public int fieldInfoTagSize;
1075 
1076     @HotSpotVMConstant(name = "JVM_ACC_MONITOR_MATCH") @Stable public int jvmAccMonitorMatch;
1077     @HotSpotVMConstant(name = "JVM_ACC_HAS_MONITOR_BYTECODES") @Stable public int jvmAccHasMonitorBytecodes;
1078     @HotSpotVMConstant(name = "JVM_ACC_HAS_FINALIZER") @Stable public int jvmAccHasFinalizer;
1079     @HotSpotVMConstant(name = "JVM_ACC_FIELD_INTERNAL") @Stable public int jvmAccFieldInternal;
1080     @HotSpotVMConstant(name = "JVM_ACC_FIELD_STABLE") @Stable public int jvmAccFieldStable;
1081     @HotSpotVMConstant(name = "JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE") @Stable public int jvmAccFieldHasGenericSignature;
1082     @HotSpotVMConstant(name = "JVM_ACC_WRITTEN_FLAGS") @Stable public int jvmAccWrittenFlags;
1083 
1084     // Modifier.SYNTHETIC is not public so we get it via vmStructs.
1085     @HotSpotVMConstant(name = "JVM_ACC_SYNTHETIC") @Stable public int jvmAccSynthetic;
1086 
1087     /**
1088      * @see HotSpotResolvedObjectTypeImpl#createField
1089      */
1090     @HotSpotVMConstant(name = "JVM_RECOGNIZED_FIELD_MODIFIERS") @Stable public int recognizedFieldModifiers;
1091 
1092     @HotSpotVMField(name = "Thread::_tlab", type = "ThreadLocalAllocBuffer", get = HotSpotVMField.Type.OFFSET) @Stable public int threadTlabOffset;
1093 
1094     @HotSpotVMField(name = "JavaThread::_anchor", type = "JavaFrameAnchor", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadAnchorOffset;
1095     @HotSpotVMField(name = "JavaThread::_threadObj", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectOffset;
1096     @HotSpotVMField(name = "JavaThread::_osthread", type = "OSThread*", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadOffset;
1097     @HotSpotVMField(name = "JavaThread::_dirty_card_queue", type = "DirtyCardQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadDirtyCardQueueOffset;
1098     @HotSpotVMField(name = "JavaThread::_is_method_handle_return", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int threadIsMethodHandleReturnOffset;
1099     @HotSpotVMField(name = "JavaThread::_satb_mark_queue", type = "SATBMarkQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadSatbMarkQueueOffset;
1100     @HotSpotVMField(name = "JavaThread::_vm_result", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectResultOffset;
1101     @HotSpotVMField(name = "JavaThread::_jvmci_counters", type = "jlong*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciCountersThreadOffset;
1102 
1103     /**
1104      * An invalid value for {@link #rtldDefault}.
1105      */
1106     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
1107 
1108     /**
1109      * Address of the library lookup routine. The C signature of this routine is:
1110      *
1111      * &lt;pre&gt;
1112      *     void* (const char *filename, char *ebuf, int ebuflen)
1113      * &lt;/pre&gt;
1114      */
1115     @HotSpotVMAddress(name = "os::dll_load") @Stable public long dllLoad;
1116 
1117     /**
1118      * Address of the library lookup routine. The C signature of this routine is:
1119      *
1120      * &lt;pre&gt;
1121      *     void* (void* handle, const char* name)
1122      * &lt;/pre&gt;
1123      */
1124     @HotSpotVMAddress(name = "os::dll_lookup") @Stable public long dllLookup;
1125 
1126     /**
1127      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
1128      * return the first occurrence of the desired symbol using the default library search order. If
1129      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
1130      * the current platform.
1131      */
1132     @HotSpotVMAddress(name = "RTLD_DEFAULT", os = {"bsd", "linux"}) @Stable public long rtldDefault = INVALID_RTLD_DEFAULT_HANDLE;
1133 
1134     /**
1135      * This field is used to pass exception objects into and out of the runtime system during
1136      * exception handling for compiled code.
1137      */
1138     @HotSpotVMField(name = "JavaThread::_exception_oop", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionOopOffset;
1139     @HotSpotVMField(name = "JavaThread::_exception_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionPcOffset;
1140     @HotSpotVMField(name = "ThreadShadow::_pending_exception", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingExceptionOffset;
1141 
1142     @HotSpotVMField(name = "JavaThread::_pending_deoptimization", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingDeoptimizationOffset;
1143     @HotSpotVMField(name = "JavaThread::_pending_failed_speculation", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingFailedSpeculationOffset;
1144     @HotSpotVMField(name = "JavaThread::_pending_transfer_to_interpreter", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingTransferToInterpreterOffset;
1145 
1146     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_sp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaSpOffset;
1147     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaPcOffset;
1148     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_fp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET, archs = {"amd64"}) @Stable private int javaFrameAnchorLastJavaFpOffset;
1149     @HotSpotVMField(name = "JavaFrameAnchor::_flags", type = "int", get = HotSpotVMField.Type.OFFSET, archs = {"sparc"}) @Stable private int javaFrameAnchorFlagsOffset;
1150 
1151     public int threadLastJavaSpOffset() {
1152         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
1153     }
1154 
1155     public int threadLastJavaPcOffset() {
1156         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
1157     }
1158 
1159     /**
1160      * This value is only valid on AMD64.
1161      */
1162     public int threadLastJavaFpOffset() {
1163         // TODO add an assert for AMD64
1164         return javaThreadAnchorOffset + javaFrameAnchorLastJavaFpOffset;
1165     }
1166 
1167     /**
1168      * This value is only valid on SPARC.
1169      */
1170     public int threadJavaFrameAnchorFlagsOffset() {
1171         // TODO add an assert for SPARC
1172         return javaThreadAnchorOffset + javaFrameAnchorFlagsOffset;
1173     }
1174 
1175     // These are only valid on AMD64.
1176     @HotSpotVMConstant(name = "frame::arg_reg_save_area_bytes", archs = {"amd64"}) @Stable public int runtimeCallStackSize;
1177     @HotSpotVMConstant(name = "frame::interpreter_frame_sender_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameSenderSpOffset;
1178     @HotSpotVMConstant(name = "frame::interpreter_frame_last_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameLastSpOffset;
1179 
1180     @HotSpotVMConstant(name = "dirtyCardQueueBufferOffset") @Stable private int dirtyCardQueueBufferOffset;
1181     @HotSpotVMConstant(name = "dirtyCardQueueIndexOffset") @Stable private int dirtyCardQueueIndexOffset;
1182 
1183     @HotSpotVMConstant(name = "satbMarkQueueBufferOffset") @Stable private int satbMarkQueueBufferOffset;
1184     @HotSpotVMConstant(name = "satbMarkQueueIndexOffset") @Stable private int satbMarkQueueIndexOffset;
1185     @HotSpotVMConstant(name = "satbMarkQueueActiveOffset") @Stable private int satbMarkQueueActiveOffset;
1186 
1187     @HotSpotVMField(name = "OSThread::_interrupted", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadInterruptedOffset;
1188 
1189     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public long markOopDescHashShift;
1190 
1191     @HotSpotVMConstant(name = "markOopDesc::biased_lock_mask_in_place") @Stable public int biasedLockMaskInPlace;
1192     @HotSpotVMConstant(name = "markOopDesc::age_mask_in_place") @Stable public int ageMaskInPlace;
1193     @HotSpotVMConstant(name = "markOopDesc::epoch_mask_in_place") @Stable public int epochMaskInPlace;
1194     @HotSpotVMConstant(name = "markOopDesc::hash_mask") @Stable public long markOopDescHashMask;
1195     @HotSpotVMConstant(name = "markOopDesc::hash_mask_in_place") @Stable public long markOopDescHashMaskInPlace;
1196 
1197     @HotSpotVMConstant(name = "markOopDesc::unlocked_value") @Stable public int unlockedMask;
1198     @HotSpotVMConstant(name = "markOopDesc::biased_lock_pattern") @Stable public int biasedLockPattern;
1199 
1200     @HotSpotVMConstant(name = "markOopDesc::no_hash_in_place") @Stable public int markWordNoHashInPlace;
1201     @HotSpotVMConstant(name = "markOopDesc::no_lock_in_place") @Stable public int markWordNoLockInPlace;
1202 
1203     /**
1204      * See {@code markOopDesc::prototype()}.
1205      */
1206     public long arrayPrototypeMarkWord() {
1207         return markWordNoHashInPlace | markWordNoLockInPlace;
1208     }
1209 
1210     /**
1211      * See {@code markOopDesc::copy_set_hash()}.
1212      */
1213     public long tlabIntArrayMarkWord() {
1214         long tmp = arrayPrototypeMarkWord() &amp; (~markOopDescHashMaskInPlace);
1215         tmp |= ((0x2 &amp; markOopDescHashMask) &lt;&lt; markOopDescHashShift);
1216         return tmp;
1217     }
1218 
1219     /**
1220      * Mark word right shift to get identity hash code.
1221      */
1222     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public int identityHashCodeShift;
1223 
1224     /**
1225      * Identity hash code value when uninitialized.
1226      */
1227     @HotSpotVMConstant(name = "markOopDesc::no_hash") @Stable public int uninitializedIdentityHashCodeValue;
1228 
1229     @HotSpotVMField(name = "Method::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int methodAccessFlagsOffset;
1230     @HotSpotVMField(name = "Method::_constMethod", type = "ConstMethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodConstMethodOffset;
1231     @HotSpotVMField(name = "Method::_intrinsic_id", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodIntrinsicIdOffset;
1232     @HotSpotVMField(name = "Method::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodFlagsOffset;
1233     @HotSpotVMField(name = "Method::_vtable_index", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodVtableIndexOffset;
1234 
1235     @HotSpotVMField(name = "Method::_method_counters", type = "MethodCounters*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCountersOffset;
1236     @HotSpotVMField(name = "Method::_method_data", type = "MethodData*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOffset;
1237     @HotSpotVMField(name = "Method::_from_compiled_entry", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCompiledEntryOffset;
1238     @HotSpotVMField(name = "Method::_code", type = "nmethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCodeOffset;
1239 
1240     @HotSpotVMConstant(name = "Method::_jfr_towrite") @Stable public int methodFlagsJfrTowrite;
1241     @HotSpotVMConstant(name = "Method::_caller_sensitive") @Stable public int methodFlagsCallerSensitive;
1242     @HotSpotVMConstant(name = "Method::_force_inline") @Stable public int methodFlagsForceInline;
1243     @HotSpotVMConstant(name = "Method::_dont_inline") @Stable public int methodFlagsDontInline;
1244     @HotSpotVMConstant(name = "Method::_hidden") @Stable public int methodFlagsHidden;
1245     @HotSpotVMConstant(name = "Method::nonvirtual_vtable_index") @Stable public int nonvirtualVtableIndex;
1246     @HotSpotVMConstant(name = "Method::invalid_vtable_index") @Stable public int invalidVtableIndex;
1247 
1248     @HotSpotVMField(name = "MethodCounters::_invocation_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int invocationCounterOffset;
1249     @HotSpotVMField(name = "MethodCounters::_backedge_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int backedgeCounterOffset;
1250     @HotSpotVMConstant(name = "InvocationCounter::count_increment") @Stable public int invocationCounterIncrement;
1251     @HotSpotVMConstant(name = "InvocationCounter::count_shift") @Stable public int invocationCounterShift;
1252 
1253     @HotSpotVMField(name = "MethodData::_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataSize;
1254     @HotSpotVMField(name = "MethodData::_data_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataDataSize;
1255     @HotSpotVMField(name = "MethodData::_data[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopDataOffset;
1256     @HotSpotVMField(name = "MethodData::_trap_hist._array[0]", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopTrapHistoryOffset;
1257     @HotSpotVMField(name = "MethodData::_jvmci_ir_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataIRSizeOffset;
1258 
1259     @HotSpotVMField(name = "nmethod::_verified_entry_point", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodEntryOffset;
1260     @HotSpotVMField(name = "nmethod::_comp_level", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodCompLevelOffset;
1261 
1262     @HotSpotVMConstant(name = "CompLevel_full_optimization") @Stable public int compilationLevelFullOptimization;
1263 
1264     @HotSpotVMConstant(name = "InvocationEntryBci") @Stable public int invocationEntryBci;
1265 
1266     @HotSpotVMField(name = "JVMCIEnv::_task", type = "CompileTask*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvTaskOffset;
1267     @HotSpotVMField(name = "JVMCIEnv::_jvmti_can_hotswap_or_post_breakpoint", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvJvmtiCanHotswapOrPostBreakpointOffset;
1268     @HotSpotVMField(name = "CompileTask::_num_inlined_bytecodes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int compileTaskNumInlinedBytecodesOffset;
1269 
1270     @HotSpotVMField(name = "CompilerToVM::Data::Method_extra_stack_entries", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int extraStackEntries;
1271 
1272     @HotSpotVMField(name = "ConstMethod::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodConstantsOffset;
1273     @HotSpotVMField(name = "ConstMethod::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodFlagsOffset;
1274     @HotSpotVMField(name = "ConstMethod::_code_size", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodCodeSizeOffset;
1275     @HotSpotVMField(name = "ConstMethod::_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodNameIndexOffset;
1276     @HotSpotVMField(name = "ConstMethod::_signature_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodSignatureIndexOffset;
1277     @HotSpotVMField(name = "ConstMethod::_max_stack", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodMaxStackOffset;
1278     @HotSpotVMField(name = "ConstMethod::_max_locals", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodMaxLocalsOffset;
1279 
1280     @HotSpotVMConstant(name = "ConstMethod::_has_linenumber_table") @Stable public int constMethodHasLineNumberTable;
1281     @HotSpotVMConstant(name = "ConstMethod::_has_localvariable_table") @Stable public int constMethodHasLocalVariableTable;
1282     @HotSpotVMConstant(name = "ConstMethod::_has_exception_table") @Stable public int constMethodHasExceptionTable;
1283 
1284     @HotSpotVMType(name = "ExceptionTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int exceptionTableElementSize;
1285     @HotSpotVMField(name = "ExceptionTableElement::start_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementStartPcOffset;
1286     @HotSpotVMField(name = "ExceptionTableElement::end_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementEndPcOffset;
1287     @HotSpotVMField(name = "ExceptionTableElement::handler_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementHandlerPcOffset;
1288     @HotSpotVMField(name = "ExceptionTableElement::catch_type_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementCatchTypeIndexOffset;
1289 
1290     @HotSpotVMType(name = "LocalVariableTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int localVariableTableElementSize;
1291     @HotSpotVMField(name = "LocalVariableTableElement::start_bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementStartBciOffset;
1292     @HotSpotVMField(name = "LocalVariableTableElement::length", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementLengthOffset;
1293     @HotSpotVMField(name = "LocalVariableTableElement::name_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementNameCpIndexOffset;
1294     @HotSpotVMField(name = "LocalVariableTableElement::descriptor_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementDescriptorCpIndexOffset;
1295     @HotSpotVMField(name = "LocalVariableTableElement::signature_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSignatureCpIndexOffset;
1296     @HotSpotVMField(name = "LocalVariableTableElement::slot", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSlotOffset;
1297 
1298     @HotSpotVMType(name = "ConstantPool", get = HotSpotVMType.Type.SIZE) @Stable public int constantPoolSize;
1299     @HotSpotVMField(name = "ConstantPool::_tags", type = "Array&lt;u1&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolTagsOffset;
1300     @HotSpotVMField(name = "ConstantPool::_pool_holder", type = "InstanceKlass*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolHolderOffset;
1301     @HotSpotVMField(name = "ConstantPool::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolLengthOffset;
1302 
1303     @HotSpotVMConstant(name = "ConstantPool::CPCACHE_INDEX_TAG") @Stable public int constantPoolCpCacheIndexTag;
1304 
1305     @HotSpotVMConstant(name = "JVM_CONSTANT_Utf8") @Stable public int jvmConstantUtf8;
1306     @HotSpotVMConstant(name = "JVM_CONSTANT_Integer") @Stable public int jvmConstantInteger;
1307     @HotSpotVMConstant(name = "JVM_CONSTANT_Long") @Stable public int jvmConstantLong;
1308     @HotSpotVMConstant(name = "JVM_CONSTANT_Float") @Stable public int jvmConstantFloat;
1309     @HotSpotVMConstant(name = "JVM_CONSTANT_Double") @Stable public int jvmConstantDouble;
1310     @HotSpotVMConstant(name = "JVM_CONSTANT_Class") @Stable public int jvmConstantClass;
1311     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClass") @Stable public int jvmConstantUnresolvedClass;
1312     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClassInError") @Stable public int jvmConstantUnresolvedClassInError;
1313     @HotSpotVMConstant(name = "JVM_CONSTANT_String") @Stable public int jvmConstantString;
1314     @HotSpotVMConstant(name = "JVM_CONSTANT_Fieldref") @Stable public int jvmConstantFieldref;
1315     @HotSpotVMConstant(name = "JVM_CONSTANT_Methodref") @Stable public int jvmConstantMethodref;
1316     @HotSpotVMConstant(name = "JVM_CONSTANT_InterfaceMethodref") @Stable public int jvmConstantInterfaceMethodref;
1317     @HotSpotVMConstant(name = "JVM_CONSTANT_NameAndType") @Stable public int jvmConstantNameAndType;
1318     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandle") @Stable public int jvmConstantMethodHandle;
1319     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandleInError") @Stable public int jvmConstantMethodHandleInError;
1320     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodType") @Stable public int jvmConstantMethodType;
1321     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodTypeInError") @Stable public int jvmConstantMethodTypeInError;
1322     @HotSpotVMConstant(name = "JVM_CONSTANT_InvokeDynamic") @Stable public int jvmConstantInvokeDynamic;
1323 
1324     @HotSpotVMConstant(name = "JVM_CONSTANT_ExternalMax") @Stable public int jvmConstantExternalMax;
1325     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMin") @Stable public int jvmConstantInternalMin;
1326     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMax") @Stable public int jvmConstantInternalMax;
1327 
1328     @HotSpotVMConstant(name = "HeapWordSize") @Stable public int heapWordSize;
1329 
1330     @HotSpotVMType(name = "Symbol*", get = HotSpotVMType.Type.SIZE) @Stable public int symbolPointerSize;
1331 
1332     @HotSpotVMField(name = "vmSymbols::_symbols[0]", type = "Symbol*", get = HotSpotVMField.Type.ADDRESS) @Stable public long vmSymbolsSymbols;
1333     @HotSpotVMConstant(name = "vmSymbols::FIRST_SID") @Stable public int vmSymbolsFirstSID;
1334     @HotSpotVMConstant(name = "vmSymbols::SID_LIMIT") @Stable public int vmSymbolsSIDLimit;
1335 
1336     /**
1337      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
1338      * are allowed to look like (respectively) the high or low bits of a real oop.
1339      */
1340     @HotSpotVMField(name = "CompilerToVM::Data::Universe_non_oop_bits", type = "void*", get = HotSpotVMField.Type.VALUE) @Stable public long nonOopBits;
1341 
1342     @HotSpotVMField(name = "StubRoutines::_verify_oop_count", type = "jint", get = HotSpotVMField.Type.ADDRESS) @Stable public long verifyOopCounterAddress;
1343     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_mask", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopMask;
1344     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_bits", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopBits;
1345     @HotSpotVMField(name = "CompilerToVM::Data::Universe_base_vtable_size", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int universeBaseVtableSize;
1346 
1347     public final int baseVtableLength() {
1348         return universeBaseVtableSize / vtableEntrySize;
1349     }
1350 
1351     @HotSpotVMField(name = "HeapRegion::LogOfHRGrainBytes", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int logOfHRGrainBytes;
1352 
1353     @HotSpotVMConstant(name = "CardTableModRefBS::dirty_card") @Stable public byte dirtyCardValue;
1354     @HotSpotVMConstant(name = "G1SATBCardTableModRefBS::g1_young_gen") @Stable public byte g1YoungCardValue;
1355 
1356     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_start_address", type = "jbyte*", get = HotSpotVMField.Type.VALUE) @Stable private long cardtableStartAddress;
1357     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable private int cardtableShift;
1358 
1359     public long cardtableStartAddress() {
1360         return cardtableStartAddress;
1361     }
1362 
1363     public int cardtableShift() {
1364         return cardtableShift;
1365     }
1366 
1367     @HotSpotVMField(name = "os::_polling_page", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long safepointPollingAddress;
1368 
1369     // G1 Collector Related Values.
1370 
1371     public int g1CardQueueIndexOffset() {
1372         return javaThreadDirtyCardQueueOffset + dirtyCardQueueIndexOffset;
1373     }
1374 
1375     public int g1CardQueueBufferOffset() {
1376         return javaThreadDirtyCardQueueOffset + dirtyCardQueueBufferOffset;
1377     }
1378 
1379     public int g1SATBQueueMarkingOffset() {
1380         return javaThreadSatbMarkQueueOffset + satbMarkQueueActiveOffset;
1381     }
1382 
1383     public int g1SATBQueueIndexOffset() {
1384         return javaThreadSatbMarkQueueOffset + satbMarkQueueIndexOffset;
1385     }
1386 
1387     public int g1SATBQueueBufferOffset() {
1388         return javaThreadSatbMarkQueueOffset + satbMarkQueueBufferOffset;
1389     }
1390 
1391     @HotSpotVMField(name = "java_lang_Class::_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassOffset;
1392     @HotSpotVMField(name = "java_lang_Class::_array_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int arrayKlassOffset;
1393 
1394     @HotSpotVMType(name = "BasicLock", get = HotSpotVMType.Type.SIZE) @Stable public int basicLockSize;
1395     @HotSpotVMField(name = "BasicLock::_displaced_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int basicLockDisplacedHeaderOffset;
1396 
1397     @HotSpotVMField(name = "Thread::_allocated_bytes", type = "jlong", get = HotSpotVMField.Type.OFFSET) @Stable public int threadAllocatedBytesOffset;
1398 
1399     @HotSpotVMFlag(name = "TLABWasteIncrement") @Stable public int tlabRefillWasteIncrement;
1400 
1401     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_start", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferStartOffset;
1402     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_end", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferEndOffset;
1403     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferTopOffset;
1404     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_pf_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferPfTopOffset;
1405     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_slow_allocations", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferSlowAllocationsOffset;
1406     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_fast_refill_waste", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferFastRefillWasteOffset;
1407     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_number_of_refills", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferNumberOfRefillsOffset;
1408     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_refill_waste_limit", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferRefillWasteLimitOffset;
1409     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_desired_size", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferDesiredSizeOffset;
1410 
1411     public int tlabSlowAllocationsOffset() {
1412         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
1413     }
1414 
1415     public int tlabFastRefillWasteOffset() {
1416         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
1417     }
1418 
1419     public int tlabNumberOfRefillsOffset() {
1420         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
1421     }
1422 
1423     public int tlabRefillWasteLimitOffset() {
1424         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
1425     }
1426 
1427     public int threadTlabSizeOffset() {
1428         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
1429     }
1430 
1431     public int threadTlabStartOffset() {
1432         return threadTlabOffset + threadLocalAllocBufferStartOffset;
1433     }
1434 
1435     public int threadTlabEndOffset() {
1436         return threadTlabOffset + threadLocalAllocBufferEndOffset;
1437     }
1438 
1439     public int threadTlabTopOffset() {
1440         return threadTlabOffset + threadLocalAllocBufferTopOffset;
1441     }
1442 
1443     public int threadTlabPfTopOffset() {
1444         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
1445     }
1446 
1447     @HotSpotVMField(name = "CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve", type = "size_t", get = HotSpotVMField.Type.VALUE) @Stable public int tlabAlignmentReserve;
1448 
1449     @HotSpotVMFlag(name = "TLABStats") @Stable public boolean tlabStats;
1450 
1451     // FIXME This is only temporary until the GC code is changed.
1452     @HotSpotVMField(name = "CompilerToVM::Data::_supports_inline_contig_alloc", type = "bool", get = HotSpotVMField.Type.VALUE) @Stable public boolean inlineContiguousAllocationSupported;
1453     @HotSpotVMField(name = "CompilerToVM::Data::_heap_end_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapEndAddress;
1454     @HotSpotVMField(name = "CompilerToVM::Data::_heap_top_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapTopAddress;
1455 
1456     /**
1457      * The DataLayout header size is the same as the cell size.
1458      */
1459     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutHeaderSize;
1460     @HotSpotVMField(name = "DataLayout::_header._struct._tag", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutTagOffset;
1461     @HotSpotVMField(name = "DataLayout::_header._struct._flags", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutFlagsOffset;
1462     @HotSpotVMField(name = "DataLayout::_header._struct._bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutBCIOffset;
1463     @HotSpotVMField(name = "DataLayout::_cells[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutCellsOffset;
1464     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutCellSize;
1465 
1466     @HotSpotVMConstant(name = "DataLayout::no_tag") @Stable public int dataLayoutNoTag;
1467     @HotSpotVMConstant(name = "DataLayout::bit_data_tag") @Stable public int dataLayoutBitDataTag;
1468     @HotSpotVMConstant(name = "DataLayout::counter_data_tag") @Stable public int dataLayoutCounterDataTag;
1469     @HotSpotVMConstant(name = "DataLayout::jump_data_tag") @Stable public int dataLayoutJumpDataTag;
1470     @HotSpotVMConstant(name = "DataLayout::receiver_type_data_tag") @Stable public int dataLayoutReceiverTypeDataTag;
1471     @HotSpotVMConstant(name = "DataLayout::virtual_call_data_tag") @Stable public int dataLayoutVirtualCallDataTag;
1472     @HotSpotVMConstant(name = "DataLayout::ret_data_tag") @Stable public int dataLayoutRetDataTag;
1473     @HotSpotVMConstant(name = "DataLayout::branch_data_tag") @Stable public int dataLayoutBranchDataTag;
1474     @HotSpotVMConstant(name = "DataLayout::multi_branch_data_tag") @Stable public int dataLayoutMultiBranchDataTag;
1475     @HotSpotVMConstant(name = "DataLayout::arg_info_data_tag") @Stable public int dataLayoutArgInfoDataTag;
1476     @HotSpotVMConstant(name = "DataLayout::call_type_data_tag") @Stable public int dataLayoutCallTypeDataTag;
1477     @HotSpotVMConstant(name = "DataLayout::virtual_call_type_data_tag") @Stable public int dataLayoutVirtualCallTypeDataTag;
1478     @HotSpotVMConstant(name = "DataLayout::parameters_type_data_tag") @Stable public int dataLayoutParametersTypeDataTag;
1479     @HotSpotVMConstant(name = "DataLayout::speculative_trap_data_tag") @Stable public int dataLayoutSpeculativeTrapDataTag;
1480 
1481     @HotSpotVMFlag(name = "BciProfileWidth") @Stable public int bciProfileWidth;
1482     @HotSpotVMFlag(name = "TypeProfileWidth") @Stable public int typeProfileWidth;
1483     @HotSpotVMFlag(name = "MethodProfileWidth") @Stable public int methodProfileWidth;
1484 
1485     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_ic_miss_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long inlineCacheMissStub;
1486     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleWrongMethodStub;
1487 
1488     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_unpack", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleDeoptStub;
1489     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long uncommonTrapStub;
1490 
1491     @HotSpotVMField(name = "CodeCache::_low_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheLowBound;
1492     @HotSpotVMField(name = "CodeCache::_high_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheHighBound;
1493 
1494     @HotSpotVMField(name = "StubRoutines::_aescrypt_encryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptEncryptBlockStub;
1495     @HotSpotVMField(name = "StubRoutines::_aescrypt_decryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptDecryptBlockStub;
1496     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_encryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingEncryptAESCryptStub;
1497     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_decryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingDecryptAESCryptStub;
1498     @HotSpotVMField(name = "StubRoutines::_updateBytesCRC32", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long updateBytesCRC32Stub;
1499     @HotSpotVMField(name = "StubRoutines::_crc_table_adr", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long crcTableAddress;
1500 
1501     @HotSpotVMField(name = "StubRoutines::_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteArraycopy;
1502     @HotSpotVMField(name = "StubRoutines::_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortArraycopy;
1503     @HotSpotVMField(name = "StubRoutines::_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintArraycopy;
1504     @HotSpotVMField(name = "StubRoutines::_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongArraycopy;
1505     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopy;
1506     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopyUninit;
1507     @HotSpotVMField(name = "StubRoutines::_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteDisjointArraycopy;
1508     @HotSpotVMField(name = "StubRoutines::_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortDisjointArraycopy;
1509     @HotSpotVMField(name = "StubRoutines::_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintDisjointArraycopy;
1510     @HotSpotVMField(name = "StubRoutines::_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongDisjointArraycopy;
1511     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopy;
1512     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopyUninit;
1513     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedArraycopy;
1514     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedArraycopy;
1515     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedArraycopy;
1516     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedArraycopy;
1517     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopy;
1518     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopyUninit;
1519     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedDisjointArraycopy;
1520     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedDisjointArraycopy;
1521     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedDisjointArraycopy;
1522     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedDisjointArraycopy;
1523     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopy;
1524     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopyUninit;
1525     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopy;
1526     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopyUninit;
1527     @HotSpotVMField(name = "StubRoutines::_unsafe_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long unsafeArraycopy;
1528     @HotSpotVMField(name = "StubRoutines::_generic_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long genericArraycopy;
1529 
1530     @HotSpotVMAddress(name = "JVMCIRuntime::new_instance") @Stable public long newInstanceAddress;
1531     @HotSpotVMAddress(name = "JVMCIRuntime::new_array") @Stable public long newArrayAddress;
1532     @HotSpotVMAddress(name = "JVMCIRuntime::new_multi_array") @Stable public long newMultiArrayAddress;
1533     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_array") @Stable public long dynamicNewArrayAddress;
1534     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_instance") @Stable public long dynamicNewInstanceAddress;
1535 
1536     @HotSpotVMAddress(name = "JVMCIRuntime::thread_is_interrupted") @Stable public long threadIsInterruptedAddress;
1537     @HotSpotVMAddress(name = "JVMCIRuntime::vm_message") @Stable public long vmMessageAddress;
1538     @HotSpotVMAddress(name = "JVMCIRuntime::identity_hash_code") @Stable public long identityHashCodeAddress;
1539     @HotSpotVMAddress(name = "JVMCIRuntime::exception_handler_for_pc") @Stable public long exceptionHandlerForPcAddress;
1540     @HotSpotVMAddress(name = "JVMCIRuntime::monitorenter") @Stable public long monitorenterAddress;
1541     @HotSpotVMAddress(name = "JVMCIRuntime::monitorexit") @Stable public long monitorexitAddress;
1542     @HotSpotVMAddress(name = "JVMCIRuntime::create_null_exception") @Stable public long createNullPointerExceptionAddress;
1543     @HotSpotVMAddress(name = "JVMCIRuntime::create_out_of_bounds_exception") @Stable public long createOutOfBoundsExceptionAddress;
1544     @HotSpotVMAddress(name = "JVMCIRuntime::log_primitive") @Stable public long logPrimitiveAddress;
1545     @HotSpotVMAddress(name = "JVMCIRuntime::log_object") @Stable public long logObjectAddress;
1546     @HotSpotVMAddress(name = "JVMCIRuntime::log_printf") @Stable public long logPrintfAddress;
1547     @HotSpotVMAddress(name = "JVMCIRuntime::vm_error") @Stable public long vmErrorAddress;
1548     @HotSpotVMAddress(name = "JVMCIRuntime::load_and_clear_exception") @Stable public long loadAndClearExceptionAddress;
1549     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_pre") @Stable public long writeBarrierPreAddress;
1550     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_post") @Stable public long writeBarrierPostAddress;
1551     @HotSpotVMAddress(name = "JVMCIRuntime::validate_object") @Stable public long validateObject;
1552 
1553     @HotSpotVMAddress(name = "JVMCIRuntime::test_deoptimize_call_int") @Stable public long testDeoptimizeCallInt;
1554 
1555     @HotSpotVMAddress(name = "SharedRuntime::register_finalizer") @Stable public long registerFinalizerAddress;
1556     @HotSpotVMAddress(name = "SharedRuntime::exception_handler_for_return_address") @Stable public long exceptionHandlerForReturnAddressAddress;
1557     @HotSpotVMAddress(name = "SharedRuntime::OSR_migration_end") @Stable public long osrMigrationEndAddress;
1558 
1559     @HotSpotVMAddress(name = "os::javaTimeMillis") @Stable public long javaTimeMillisAddress;
1560     @HotSpotVMAddress(name = "os::javaTimeNanos") @Stable public long javaTimeNanosAddress;
1561     @HotSpotVMAddress(name = "SharedRuntime::dsin") @Stable public long arithmeticSinAddress;
1562     @HotSpotVMAddress(name = "SharedRuntime::dcos") @Stable public long arithmeticCosAddress;
1563     @HotSpotVMAddress(name = "SharedRuntime::dtan") @Stable public long arithmeticTanAddress;
1564     @HotSpotVMAddress(name = "SharedRuntime::dexp") @Stable public long arithmeticExpAddress;
1565     @HotSpotVMAddress(name = "SharedRuntime::dlog") @Stable public long arithmeticLogAddress;
1566     @HotSpotVMAddress(name = "SharedRuntime::dlog10") @Stable public long arithmeticLog10Address;
1567     @HotSpotVMAddress(name = "SharedRuntime::dpow") @Stable public long arithmeticPowAddress;
1568 
1569     @HotSpotVMFlag(name = "JVMCICounterSize") @Stable public int jvmciCountersSize;
1570 
1571     @HotSpotVMAddress(name = "Deoptimization::fetch_unroll_info") @Stable public long deoptimizationFetchUnrollInfo;
1572     @HotSpotVMAddress(name = "Deoptimization::uncommon_trap") @Stable public long deoptimizationUncommonTrap;
1573     @HotSpotVMAddress(name = "Deoptimization::unpack_frames") @Stable public long deoptimizationUnpackFrames;
1574 
1575     @HotSpotVMConstant(name = "Deoptimization::Reason_none") @Stable public int deoptReasonNone;
1576     @HotSpotVMConstant(name = "Deoptimization::Reason_null_check") @Stable public int deoptReasonNullCheck;
1577     @HotSpotVMConstant(name = "Deoptimization::Reason_range_check") @Stable public int deoptReasonRangeCheck;
1578     @HotSpotVMConstant(name = "Deoptimization::Reason_class_check") @Stable public int deoptReasonClassCheck;
1579     @HotSpotVMConstant(name = "Deoptimization::Reason_array_check") @Stable public int deoptReasonArrayCheck;
1580     @HotSpotVMConstant(name = "Deoptimization::Reason_unreached0") @Stable public int deoptReasonUnreached0;
1581     @HotSpotVMConstant(name = "Deoptimization::Reason_type_checked_inlining") @Stable public int deoptReasonTypeCheckInlining;
1582     @HotSpotVMConstant(name = "Deoptimization::Reason_optimized_type_check") @Stable public int deoptReasonOptimizedTypeCheck;
1583     @HotSpotVMConstant(name = "Deoptimization::Reason_not_compiled_exception_handler") @Stable public int deoptReasonNotCompiledExceptionHandler;
1584     @HotSpotVMConstant(name = "Deoptimization::Reason_unresolved") @Stable public int deoptReasonUnresolved;
1585     @HotSpotVMConstant(name = "Deoptimization::Reason_jsr_mismatch") @Stable public int deoptReasonJsrMismatch;
1586     @HotSpotVMConstant(name = "Deoptimization::Reason_div0_check") @Stable public int deoptReasonDiv0Check;
1587     @HotSpotVMConstant(name = "Deoptimization::Reason_constraint") @Stable public int deoptReasonConstraint;
1588     @HotSpotVMConstant(name = "Deoptimization::Reason_loop_limit_check") @Stable public int deoptReasonLoopLimitCheck;
1589     @HotSpotVMConstant(name = "Deoptimization::Reason_aliasing") @Stable public int deoptReasonAliasing;
1590     @HotSpotVMConstant(name = "Deoptimization::Reason_transfer_to_interpreter") @Stable public int deoptReasonTransferToInterpreter;
1591     @HotSpotVMConstant(name = "Deoptimization::Reason_LIMIT") @Stable public int deoptReasonOSROffset;
1592 
1593     @HotSpotVMConstant(name = "Deoptimization::Action_none") @Stable public int deoptActionNone;
1594     @HotSpotVMConstant(name = "Deoptimization::Action_maybe_recompile") @Stable public int deoptActionMaybeRecompile;
1595     @HotSpotVMConstant(name = "Deoptimization::Action_reinterpret") @Stable public int deoptActionReinterpret;
1596     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_entrant") @Stable public int deoptActionMakeNotEntrant;
1597     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_compilable") @Stable public int deoptActionMakeNotCompilable;
1598 
1599     @HotSpotVMConstant(name = "Deoptimization::_action_bits") @Stable public int deoptimizationActionBits;
1600     @HotSpotVMConstant(name = "Deoptimization::_reason_bits") @Stable public int deoptimizationReasonBits;
1601     @HotSpotVMConstant(name = "Deoptimization::_debug_id_bits") @Stable public int deoptimizationDebugIdBits;
1602     @HotSpotVMConstant(name = "Deoptimization::_action_shift") @Stable public int deoptimizationActionShift;
1603     @HotSpotVMConstant(name = "Deoptimization::_reason_shift") @Stable public int deoptimizationReasonShift;
1604     @HotSpotVMConstant(name = "Deoptimization::_debug_id_shift") @Stable public int deoptimizationDebugIdShift;
1605 
1606     @HotSpotVMConstant(name = "Deoptimization::Unpack_deopt") @Stable public int deoptimizationUnpackDeopt;
1607     @HotSpotVMConstant(name = "Deoptimization::Unpack_exception") @Stable public int deoptimizationUnpackException;
1608     @HotSpotVMConstant(name = "Deoptimization::Unpack_uncommon_trap") @Stable public int deoptimizationUnpackUncommonTrap;
1609     @HotSpotVMConstant(name = "Deoptimization::Unpack_reexecute") @Stable public int deoptimizationUnpackReexecute;
1610 
1611     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_size_of_deoptimized_frame", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockSizeOfDeoptimizedFrameOffset;
1612     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_caller_adjustment", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockCallerAdjustmentOffset;
1613     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_number_of_frames", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockNumberOfFramesOffset;
1614     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_total_frame_sizes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockTotalFrameSizesOffset;
1615     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_unpack_kind", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockUnpackKindOffset;
1616     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_sizes", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFrameSizesOffset;
1617     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_pcs", type = "address*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFramePcsOffset;
1618     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_initial_info", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockInitialInfoOffset;
1619 
1620     @HotSpotVMConstant(name = "vmIntrinsics::_invokeBasic") @Stable public int vmIntrinsicInvokeBasic;
1621     @HotSpotVMConstant(name = "vmIntrinsics::_linkToVirtual") @Stable public int vmIntrinsicLinkToVirtual;
1622     @HotSpotVMConstant(name = "vmIntrinsics::_linkToStatic") @Stable public int vmIntrinsicLinkToStatic;
1623     @HotSpotVMConstant(name = "vmIntrinsics::_linkToSpecial") @Stable public int vmIntrinsicLinkToSpecial;
1624     @HotSpotVMConstant(name = "vmIntrinsics::_linkToInterface") @Stable public int vmIntrinsicLinkToInterface;
1625 
1626     @HotSpotVMConstant(name = "JVMCIEnv::ok") @Stable public int codeInstallResultOk;
1627     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_failed") @Stable public int codeInstallResultDependenciesFailed;
1628     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_invalid") @Stable public int codeInstallResultDependenciesInvalid;
1629     @HotSpotVMConstant(name = "JVMCIEnv::cache_full") @Stable public int codeInstallResultCacheFull;
1630     @HotSpotVMConstant(name = "JVMCIEnv::code_too_large") @Stable public int codeInstallResultCodeTooLarge;
1631 
1632     public String getCodeInstallResultDescription(int codeInstallResult) {
1633         if (codeInstallResult == codeInstallResultOk) {
1634             return "ok";
1635         }
1636         if (codeInstallResult == codeInstallResultDependenciesFailed) {
1637             return "dependencies failed";
1638         }
1639         if (codeInstallResult == codeInstallResultDependenciesInvalid) {
1640             return "dependencies invalid";
1641         }
1642         if (codeInstallResult == codeInstallResultCacheFull) {
1643             return "code cache is full";
1644         }
1645         if (codeInstallResult == codeInstallResultCodeTooLarge) {
1646             return "code is too large";
1647         }
1648         assert false : codeInstallResult;
1649         return "unknown";
1650     }
1651 
1652     // Checkstyle: stop
1653     @HotSpotVMConstant(name = "CodeInstaller::VERIFIED_ENTRY") @Stable public int MARKID_VERIFIED_ENTRY;
1654     @HotSpotVMConstant(name = "CodeInstaller::UNVERIFIED_ENTRY") @Stable public int MARKID_UNVERIFIED_ENTRY;
1655     @HotSpotVMConstant(name = "CodeInstaller::OSR_ENTRY") @Stable public int MARKID_OSR_ENTRY;
1656     @HotSpotVMConstant(name = "CodeInstaller::EXCEPTION_HANDLER_ENTRY") @Stable public int MARKID_EXCEPTION_HANDLER_ENTRY;
1657     @HotSpotVMConstant(name = "CodeInstaller::DEOPT_HANDLER_ENTRY") @Stable public int MARKID_DEOPT_HANDLER_ENTRY;
1658     @HotSpotVMConstant(name = "CodeInstaller::INVOKEINTERFACE") @Stable public int MARKID_INVOKEINTERFACE;
1659     @HotSpotVMConstant(name = "CodeInstaller::INVOKEVIRTUAL") @Stable public int MARKID_INVOKEVIRTUAL;
1660     @HotSpotVMConstant(name = "CodeInstaller::INVOKESTATIC") @Stable public int MARKID_INVOKESTATIC;
1661     @HotSpotVMConstant(name = "CodeInstaller::INVOKESPECIAL") @Stable public int MARKID_INVOKESPECIAL;
1662     @HotSpotVMConstant(name = "CodeInstaller::INLINE_INVOKE") @Stable public int MARKID_INLINE_INVOKE;
1663     @HotSpotVMConstant(name = "CodeInstaller::POLL_NEAR") @Stable public int MARKID_POLL_NEAR;
1664     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_NEAR") @Stable public int MARKID_POLL_RETURN_NEAR;
1665     @HotSpotVMConstant(name = "CodeInstaller::POLL_FAR") @Stable public int MARKID_POLL_FAR;
1666     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_FAR") @Stable public int MARKID_POLL_RETURN_FAR;
1667     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_SHIFT") @Stable public int MARKID_CARD_TABLE_SHIFT;
1668     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_ADDRESS") @Stable public int MARKID_CARD_TABLE_ADDRESS;
1669     @HotSpotVMConstant(name = "CodeInstaller::HEAP_TOP_ADDRESS") @Stable public int MARKID_HEAP_TOP_ADDRESS;
1670     @HotSpotVMConstant(name = "CodeInstaller::HEAP_END_ADDRESS") @Stable public int MARKID_HEAP_END_ADDRESS;
1671     @HotSpotVMConstant(name = "CodeInstaller::NARROW_KLASS_BASE_ADDRESS") @Stable public int MARKID_NARROW_KLASS_BASE_ADDRESS;
1672     @HotSpotVMConstant(name = "CodeInstaller::CRC_TABLE_ADDRESS") @Stable public int MARKID_CRC_TABLE_ADDRESS;
1673     @HotSpotVMConstant(name = "CodeInstaller::INVOKE_INVALID") @Stable public int MARKID_INVOKE_INVALID;
1674 
1675     @HotSpotVMConstant(name = "BitData::exception_seen_flag") @Stable public int bitDataExceptionSeenFlag;
1676     @HotSpotVMConstant(name = "BitData::null_seen_flag") @Stable public int bitDataNullSeenFlag;
1677     @HotSpotVMConstant(name = "CounterData::count_off") @Stable public int methodDataCountOffset;
1678     @HotSpotVMConstant(name = "JumpData::taken_off_set") @Stable public int jumpDataTakenOffset;
1679     @HotSpotVMConstant(name = "JumpData::displacement_off_set") @Stable public int jumpDataDisplacementOffset;
1680     @HotSpotVMConstant(name = "ReceiverTypeData::nonprofiled_count_off_set") @Stable public int receiverTypeDataNonprofiledCountOffset;
1681     @HotSpotVMConstant(name = "ReceiverTypeData::receiver_type_row_cell_count") @Stable public int receiverTypeDataReceiverTypeRowCellCount;
1682     @HotSpotVMConstant(name = "ReceiverTypeData::receiver0_offset") @Stable public int receiverTypeDataReceiver0Offset;
1683     @HotSpotVMConstant(name = "ReceiverTypeData::count0_offset") @Stable public int receiverTypeDataCount0Offset;
1684     @HotSpotVMConstant(name = "BranchData::not_taken_off_set") @Stable public int branchDataNotTakenOffset;
1685     @HotSpotVMConstant(name = "ArrayData::array_len_off_set") @Stable public int arrayDataArrayLenOffset;
1686     @HotSpotVMConstant(name = "ArrayData::array_start_off_set") @Stable public int arrayDataArrayStartOffset;
1687     @HotSpotVMConstant(name = "MultiBranchData::per_case_cell_count") @Stable public int multiBranchDataPerCaseCellCount;
1688 
1689     // Checkstyle: resume
1690 
1691     private boolean check() {
1692         for (Field f : getClass().getDeclaredFields()) {
1693             int modifiers = f.getModifiers();
1694             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
1695                 assert Modifier.isFinal(modifiers) || f.getAnnotation(Stable.class) != null : "field should either be final or @Stable: " + f;
1696             }
1697         }
1698 
1699         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
1700         assert (layoutHelperArrayTagObjectValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "object array must have first bit set";
1701         assert (layoutHelperArrayTagTypeValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "type array must have first bit set";
1702 
1703         return true;
1704     }
1705 
1706     /**
1707      * A compact representation of the different encoding strategies for Objects and metadata.
1708      */
1709     public static class CompressEncoding {
1710         public final long base;
1711         public final int shift;
1712         public final int alignment;
1713 
1714         CompressEncoding(long base, int shift, int alignment) {
1715             this.base = base;
1716             this.shift = shift;
1717             this.alignment = alignment;
1718         }
1719 
1720         public int compress(long ptr) {
1721             if (ptr == 0L) {
1722                 return 0;
1723             } else {
1724                 return (int) ((ptr - base) &gt;&gt;&gt; shift);
1725             }
1726         }
1727 
1728         public long uncompress(int ptr) {
1729             if (ptr == 0) {
1730                 return 0L;
1731             } else {
1732                 return ((ptr &amp; 0xFFFFFFFFL) &lt;&lt; shift) + base;
1733             }
1734         }
1735 
1736         @Override
1737         public String toString() {
1738             return "base: " + base + " shift: " + shift + " alignment: " + alignment;
1739         }
1740 
1741         @Override
1742         public int hashCode() {
1743             final int prime = 31;
1744             int result = 1;
1745             result = prime * result + alignment;
1746             result = prime * result + (int) (base ^ (base &gt;&gt;&gt; 32));
1747             result = prime * result + shift;
1748             return result;
1749         }
1750 
1751         @Override
1752         public boolean equals(Object obj) {
1753             if (obj instanceof CompressEncoding) {
1754                 CompressEncoding other = (CompressEncoding) obj;
1755                 return alignment == other.alignment &amp;&amp; base == other.base &amp;&amp; shift == other.shift;
1756             } else {
1757                 return false;
1758             }
1759         }
1760     }
1761 
1762 }
</pre></body></html>
