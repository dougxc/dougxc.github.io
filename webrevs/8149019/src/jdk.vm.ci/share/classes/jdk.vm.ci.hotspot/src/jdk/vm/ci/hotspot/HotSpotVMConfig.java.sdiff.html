<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot </title>
</head><body id="SUNWwebrev">
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfig.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 343         }
 344         return false;
 345     }
 346 
 347     /**
 348      * VMStructEntry (see {@code vmStructs.hpp}).
 349      */
 350     @HotSpotVMData(index = 0) @Stable private long jvmciHotSpotVMStructs;
 351     @HotSpotVMData(index = 1) @Stable private long jvmciHotSpotVMStructEntryTypeNameOffset;
 352     @HotSpotVMData(index = 2) @Stable private long jvmciHotSpotVMStructEntryFieldNameOffset;
 353     @HotSpotVMData(index = 3) @Stable private long jvmciHotSpotVMStructEntryTypeStringOffset;
 354     @HotSpotVMData(index = 4) @Stable private long jvmciHotSpotVMStructEntryIsStaticOffset;
 355     @HotSpotVMData(index = 5) @Stable private long jvmciHotSpotVMStructEntryOffsetOffset;
 356     @HotSpotVMData(index = 6) @Stable private long jvmciHotSpotVMStructEntryAddressOffset;
 357     @HotSpotVMData(index = 7) @Stable private long jvmciHotSpotVMStructEntryArrayStride;
 358 
 359     final class VMFields implements Iterable&lt;VMFields.Field&gt; {
 360 
 361         private final long address;
 362 
<span class="changed"> 363         public VMFields(long address) {</span>
 364             this.address = address;
 365         }
 366 
 367         public Iterator&lt;VMFields.Field&gt; iterator() {
 368             return new Iterator&lt;VMFields.Field&gt;() {
 369 
 370                 private int index = 0;
 371 
 372                 private Field current() {
 373                     return new Field(address + jvmciHotSpotVMStructEntryArrayStride * index);
 374                 }
 375 
 376                 /**
 377                  * The last entry is identified by a NULL fieldName.
 378                  */
 379                 public boolean hasNext() {
 380                     Field entry = current();
 381                     return entry.getFieldName() != null;
 382                 }
 383 

</pre><hr></hr><pre>
 460             }
 461         }
 462     }
 463 
 464     /**
 465      * VMTypeEntry (see vmStructs.hpp).
 466      */
 467     @HotSpotVMData(index = 8) @Stable private long jvmciHotSpotVMTypes;
 468     @HotSpotVMData(index = 9) @Stable private long jvmciHotSpotVMTypeEntryTypeNameOffset;
 469     @HotSpotVMData(index = 10) @Stable private long jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 470     @HotSpotVMData(index = 11) @Stable private long jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 471     @HotSpotVMData(index = 12) @Stable private long jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 472     @HotSpotVMData(index = 13) @Stable private long jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 473     @HotSpotVMData(index = 14) @Stable private long jvmciHotSpotVMTypeEntrySizeOffset;
 474     @HotSpotVMData(index = 15) @Stable private long jvmciHotSpotVMTypeEntryArrayStride;
 475 
 476     final class VMTypes implements Iterable&lt;VMTypes.Type&gt; {
 477 
 478         private final long address;
 479 
<span class="changed"> 480         public VMTypes(long address) {</span>
 481             this.address = address;
 482         }
 483 
 484         public Iterator&lt;VMTypes.Type&gt; iterator() {
 485             return new Iterator&lt;VMTypes.Type&gt;() {
 486 
 487                 private int index = 0;
 488 
 489                 private Type current() {
 490                     return new Type(address + jvmciHotSpotVMTypeEntryArrayStride * index);
 491                 }
 492 
 493                 /**
 494                  * The last entry is identified by a NULL type name.
 495                  */
 496                 public boolean hasNext() {
 497                     Type entry = current();
 498                     return entry.getTypeName() != null;
 499                 }
 500 

</pre><hr></hr><pre>
 563         public String getName() {
 564             long nameAddress = UNSAFE.getAddress(address + nameOffset);
 565             return readCString(UNSAFE, nameAddress);
 566         }
 567 
 568         public abstract long getValue();
 569     }
 570 
 571     /**
 572      * VMIntConstantEntry (see vmStructs.hpp).
 573      */
 574     @HotSpotVMData(index = 16) @Stable private long jvmciHotSpotVMIntConstants;
 575     @HotSpotVMData(index = 17) @Stable private long jvmciHotSpotVMIntConstantEntryNameOffset;
 576     @HotSpotVMData(index = 18) @Stable private long jvmciHotSpotVMIntConstantEntryValueOffset;
 577     @HotSpotVMData(index = 19) @Stable private long jvmciHotSpotVMIntConstantEntryArrayStride;
 578 
 579     final class VMIntConstants implements Iterable&lt;VMIntConstants.Constant&gt; {
 580 
 581         private final long address;
 582 
<span class="changed"> 583         public VMIntConstants(long address) {</span>
 584             this.address = address;
 585         }
 586 
 587         public Iterator&lt;VMIntConstants.Constant&gt; iterator() {
 588             return new Iterator&lt;VMIntConstants.Constant&gt;() {
 589 
 590                 private int index = 0;
 591 
 592                 private Constant current() {
 593                     return new Constant(address + jvmciHotSpotVMIntConstantEntryArrayStride * index);
 594                 }
 595 
 596                 /**
 597                  * The last entry is identified by a NULL name.
 598                  */
 599                 public boolean hasNext() {
 600                     Constant entry = current();
 601                     return entry.getName() != null;
 602                 }
 603 

</pre><hr></hr><pre>
 622 
 623             @Override
 624             public String toString() {
 625                 return String.format("IntConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 626             }
 627         }
 628     }
 629 
 630     /**
 631      * VMLongConstantEntry (see vmStructs.hpp).
 632      */
 633     @HotSpotVMData(index = 20) @Stable private long jvmciHotSpotVMLongConstants;
 634     @HotSpotVMData(index = 21) @Stable private long jvmciHotSpotVMLongConstantEntryNameOffset;
 635     @HotSpotVMData(index = 22) @Stable private long jvmciHotSpotVMLongConstantEntryValueOffset;
 636     @HotSpotVMData(index = 23) @Stable private long jvmciHotSpotVMLongConstantEntryArrayStride;
 637 
 638     final class VMLongConstants implements Iterable&lt;VMLongConstants.Constant&gt; {
 639 
 640         private final long address;
 641 
<span class="changed"> 642         public VMLongConstants(long address) {</span>
 643             this.address = address;
 644         }
 645 
 646         public Iterator&lt;VMLongConstants.Constant&gt; iterator() {
 647             return new Iterator&lt;VMLongConstants.Constant&gt;() {
 648 
 649                 private int index = 0;
 650 
 651                 private Constant currentEntry() {
 652                     return new Constant(address + jvmciHotSpotVMLongConstantEntryArrayStride * index);
 653                 }
 654 
 655                 /**
 656                  * The last entry is identified by a NULL name.
 657                  */
 658                 public boolean hasNext() {
 659                     Constant entry = currentEntry();
 660                     return entry.getName() != null;
 661                 }
 662 

</pre><hr></hr><pre>
 681 
 682             @Override
 683             public String toString() {
 684                 return String.format("LongConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 685             }
 686         }
 687     }
 688 
 689     /**
 690      * VMAddressEntry (see vmStructs.hpp).
 691      */
 692     @HotSpotVMData(index = 24) @Stable private long jvmciHotSpotVMAddresses;
 693     @HotSpotVMData(index = 25) @Stable private long jvmciHotSpotVMAddressEntryNameOffset;
 694     @HotSpotVMData(index = 26) @Stable private long jvmciHotSpotVMAddressEntryValueOffset;
 695     @HotSpotVMData(index = 27) @Stable private long jvmciHotSpotVMAddressEntryArrayStride;
 696 
 697     final class VMAddresses implements Iterable&lt;VMAddresses.Address&gt; {
 698 
 699         private final long address;
 700 
<span class="changed"> 701         public VMAddresses(long address) {</span>
 702             this.address = address;
 703         }
 704 
 705         public Iterator&lt;VMAddresses.Address&gt; iterator() {
 706             return new Iterator&lt;VMAddresses.Address&gt;() {
 707 
 708                 private int index = 0;
 709 
 710                 private Address currentEntry() {
 711                     return new Address(address + jvmciHotSpotVMAddressEntryArrayStride * index);
 712                 }
 713 
 714                 /**
 715                  * The last entry is identified by a NULL name.
 716                  */
 717                 public boolean hasNext() {
 718                     Address entry = currentEntry();
 719                     return entry.getName() != null;
 720                 }
 721 

</pre><hr></hr><pre>
 736             @Override
 737             public long getValue() {
 738                 return UNSAFE.getLong(address + valueOffset);
 739             }
 740 
 741             @Override
 742             public String toString() {
 743                 return String.format("Address[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 744             }
 745         }
 746     }
 747 
 748     final class Flags implements Iterable&lt;Flags.Flag&gt; {
 749 
 750         private final long address;
 751         private final long entrySize;
 752         private final long typeOffset;
 753         private final long nameOffset;
 754         private final long addrOffset;
 755 
<span class="changed"> 756         public Flags(HashMap&lt;String, VMFields.Field&gt; vmStructs, HashMap&lt;String, VMTypes.Type&gt; vmTypes) {</span>
 757             address = vmStructs.get("Flag::flags").getValue();
 758             entrySize = vmTypes.get("Flag").getSize();
 759             typeOffset = vmStructs.get("Flag::_type").getOffset();
 760             nameOffset = vmStructs.get("Flag::_name").getOffset();
 761             addrOffset = vmStructs.get("Flag::_addr").getOffset();
 762 
 763             assert vmTypes.get("bool").getSize() == Byte.BYTES;
 764             assert vmTypes.get("intx").getSize() == Long.BYTES;
 765             assert vmTypes.get("uintx").getSize() == Long.BYTES;
 766         }
 767 
 768         public Iterator&lt;Flags.Flag&gt; iterator() {
 769             return new Iterator&lt;Flags.Flag&gt;() {
 770 
 771                 private int index = 0;
 772 
 773                 private Flag current() {
 774                     return new Flag(address + entrySize * index);
 775                 }
 776 

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 343         }
 344         return false;
 345     }
 346 
 347     /**
 348      * VMStructEntry (see {@code vmStructs.hpp}).
 349      */
 350     @HotSpotVMData(index = 0) @Stable private long jvmciHotSpotVMStructs;
 351     @HotSpotVMData(index = 1) @Stable private long jvmciHotSpotVMStructEntryTypeNameOffset;
 352     @HotSpotVMData(index = 2) @Stable private long jvmciHotSpotVMStructEntryFieldNameOffset;
 353     @HotSpotVMData(index = 3) @Stable private long jvmciHotSpotVMStructEntryTypeStringOffset;
 354     @HotSpotVMData(index = 4) @Stable private long jvmciHotSpotVMStructEntryIsStaticOffset;
 355     @HotSpotVMData(index = 5) @Stable private long jvmciHotSpotVMStructEntryOffsetOffset;
 356     @HotSpotVMData(index = 6) @Stable private long jvmciHotSpotVMStructEntryAddressOffset;
 357     @HotSpotVMData(index = 7) @Stable private long jvmciHotSpotVMStructEntryArrayStride;
 358 
 359     final class VMFields implements Iterable&lt;VMFields.Field&gt; {
 360 
 361         private final long address;
 362 
<span class="changed"> 363         VMFields(long address) {</span>
 364             this.address = address;
 365         }
 366 
 367         public Iterator&lt;VMFields.Field&gt; iterator() {
 368             return new Iterator&lt;VMFields.Field&gt;() {
 369 
 370                 private int index = 0;
 371 
 372                 private Field current() {
 373                     return new Field(address + jvmciHotSpotVMStructEntryArrayStride * index);
 374                 }
 375 
 376                 /**
 377                  * The last entry is identified by a NULL fieldName.
 378                  */
 379                 public boolean hasNext() {
 380                     Field entry = current();
 381                     return entry.getFieldName() != null;
 382                 }
 383 

</pre><hr></hr><pre>
 460             }
 461         }
 462     }
 463 
 464     /**
 465      * VMTypeEntry (see vmStructs.hpp).
 466      */
 467     @HotSpotVMData(index = 8) @Stable private long jvmciHotSpotVMTypes;
 468     @HotSpotVMData(index = 9) @Stable private long jvmciHotSpotVMTypeEntryTypeNameOffset;
 469     @HotSpotVMData(index = 10) @Stable private long jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 470     @HotSpotVMData(index = 11) @Stable private long jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 471     @HotSpotVMData(index = 12) @Stable private long jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 472     @HotSpotVMData(index = 13) @Stable private long jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 473     @HotSpotVMData(index = 14) @Stable private long jvmciHotSpotVMTypeEntrySizeOffset;
 474     @HotSpotVMData(index = 15) @Stable private long jvmciHotSpotVMTypeEntryArrayStride;
 475 
 476     final class VMTypes implements Iterable&lt;VMTypes.Type&gt; {
 477 
 478         private final long address;
 479 
<span class="changed"> 480         VMTypes(long address) {</span>
 481             this.address = address;
 482         }
 483 
 484         public Iterator&lt;VMTypes.Type&gt; iterator() {
 485             return new Iterator&lt;VMTypes.Type&gt;() {
 486 
 487                 private int index = 0;
 488 
 489                 private Type current() {
 490                     return new Type(address + jvmciHotSpotVMTypeEntryArrayStride * index);
 491                 }
 492 
 493                 /**
 494                  * The last entry is identified by a NULL type name.
 495                  */
 496                 public boolean hasNext() {
 497                     Type entry = current();
 498                     return entry.getTypeName() != null;
 499                 }
 500 

</pre><hr></hr><pre>
 563         public String getName() {
 564             long nameAddress = UNSAFE.getAddress(address + nameOffset);
 565             return readCString(UNSAFE, nameAddress);
 566         }
 567 
 568         public abstract long getValue();
 569     }
 570 
 571     /**
 572      * VMIntConstantEntry (see vmStructs.hpp).
 573      */
 574     @HotSpotVMData(index = 16) @Stable private long jvmciHotSpotVMIntConstants;
 575     @HotSpotVMData(index = 17) @Stable private long jvmciHotSpotVMIntConstantEntryNameOffset;
 576     @HotSpotVMData(index = 18) @Stable private long jvmciHotSpotVMIntConstantEntryValueOffset;
 577     @HotSpotVMData(index = 19) @Stable private long jvmciHotSpotVMIntConstantEntryArrayStride;
 578 
 579     final class VMIntConstants implements Iterable&lt;VMIntConstants.Constant&gt; {
 580 
 581         private final long address;
 582 
<span class="changed"> 583         VMIntConstants(long address) {</span>
 584             this.address = address;
 585         }
 586 
 587         public Iterator&lt;VMIntConstants.Constant&gt; iterator() {
 588             return new Iterator&lt;VMIntConstants.Constant&gt;() {
 589 
 590                 private int index = 0;
 591 
 592                 private Constant current() {
 593                     return new Constant(address + jvmciHotSpotVMIntConstantEntryArrayStride * index);
 594                 }
 595 
 596                 /**
 597                  * The last entry is identified by a NULL name.
 598                  */
 599                 public boolean hasNext() {
 600                     Constant entry = current();
 601                     return entry.getName() != null;
 602                 }
 603 

</pre><hr></hr><pre>
 622 
 623             @Override
 624             public String toString() {
 625                 return String.format("IntConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 626             }
 627         }
 628     }
 629 
 630     /**
 631      * VMLongConstantEntry (see vmStructs.hpp).
 632      */
 633     @HotSpotVMData(index = 20) @Stable private long jvmciHotSpotVMLongConstants;
 634     @HotSpotVMData(index = 21) @Stable private long jvmciHotSpotVMLongConstantEntryNameOffset;
 635     @HotSpotVMData(index = 22) @Stable private long jvmciHotSpotVMLongConstantEntryValueOffset;
 636     @HotSpotVMData(index = 23) @Stable private long jvmciHotSpotVMLongConstantEntryArrayStride;
 637 
 638     final class VMLongConstants implements Iterable&lt;VMLongConstants.Constant&gt; {
 639 
 640         private final long address;
 641 
<span class="changed"> 642         VMLongConstants(long address) {</span>
 643             this.address = address;
 644         }
 645 
 646         public Iterator&lt;VMLongConstants.Constant&gt; iterator() {
 647             return new Iterator&lt;VMLongConstants.Constant&gt;() {
 648 
 649                 private int index = 0;
 650 
 651                 private Constant currentEntry() {
 652                     return new Constant(address + jvmciHotSpotVMLongConstantEntryArrayStride * index);
 653                 }
 654 
 655                 /**
 656                  * The last entry is identified by a NULL name.
 657                  */
 658                 public boolean hasNext() {
 659                     Constant entry = currentEntry();
 660                     return entry.getName() != null;
 661                 }
 662 

</pre><hr></hr><pre>
 681 
 682             @Override
 683             public String toString() {
 684                 return String.format("LongConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 685             }
 686         }
 687     }
 688 
 689     /**
 690      * VMAddressEntry (see vmStructs.hpp).
 691      */
 692     @HotSpotVMData(index = 24) @Stable private long jvmciHotSpotVMAddresses;
 693     @HotSpotVMData(index = 25) @Stable private long jvmciHotSpotVMAddressEntryNameOffset;
 694     @HotSpotVMData(index = 26) @Stable private long jvmciHotSpotVMAddressEntryValueOffset;
 695     @HotSpotVMData(index = 27) @Stable private long jvmciHotSpotVMAddressEntryArrayStride;
 696 
 697     final class VMAddresses implements Iterable&lt;VMAddresses.Address&gt; {
 698 
 699         private final long address;
 700 
<span class="changed"> 701         VMAddresses(long address) {</span>
 702             this.address = address;
 703         }
 704 
 705         public Iterator&lt;VMAddresses.Address&gt; iterator() {
 706             return new Iterator&lt;VMAddresses.Address&gt;() {
 707 
 708                 private int index = 0;
 709 
 710                 private Address currentEntry() {
 711                     return new Address(address + jvmciHotSpotVMAddressEntryArrayStride * index);
 712                 }
 713 
 714                 /**
 715                  * The last entry is identified by a NULL name.
 716                  */
 717                 public boolean hasNext() {
 718                     Address entry = currentEntry();
 719                     return entry.getName() != null;
 720                 }
 721 

</pre><hr></hr><pre>
 736             @Override
 737             public long getValue() {
 738                 return UNSAFE.getLong(address + valueOffset);
 739             }
 740 
 741             @Override
 742             public String toString() {
 743                 return String.format("Address[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 744             }
 745         }
 746     }
 747 
 748     final class Flags implements Iterable&lt;Flags.Flag&gt; {
 749 
 750         private final long address;
 751         private final long entrySize;
 752         private final long typeOffset;
 753         private final long nameOffset;
 754         private final long addrOffset;
 755 
<span class="changed"> 756         Flags(HashMap&lt;String, VMFields.Field&gt; vmStructs, HashMap&lt;String, VMTypes.Type&gt; vmTypes) {</span>
 757             address = vmStructs.get("Flag::flags").getValue();
 758             entrySize = vmTypes.get("Flag").getSize();
 759             typeOffset = vmStructs.get("Flag::_type").getOffset();
 760             nameOffset = vmStructs.get("Flag::_name").getOffset();
 761             addrOffset = vmStructs.get("Flag::_addr").getOffset();
 762 
 763             assert vmTypes.get("bool").getSize() == Byte.BYTES;
 764             assert vmTypes.get("intx").getSize() == Long.BYTES;
 765             assert vmTypes.get("uintx").getSize() == Long.BYTES;
 766         }
 767 
 768         public Iterator&lt;Flags.Flag&gt; iterator() {
 769             return new Iterator&lt;Flags.Flag&gt;() {
 770 
 771                 private int index = 0;
 772 
 773                 private Flag current() {
 774                     return new Flag(address + entrySize * index);
 775                 }
 776 

</pre><hr></hr>
</pre></td>
</tr></table>
</body></html>
