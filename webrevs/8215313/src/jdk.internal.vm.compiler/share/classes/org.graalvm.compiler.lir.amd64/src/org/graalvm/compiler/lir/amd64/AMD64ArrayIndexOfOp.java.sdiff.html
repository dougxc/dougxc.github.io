<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>open Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64 </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../../src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64Assembler.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../../index.html' target='_top'>index</a> next &gt</center>
<h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayIndexOfOp.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */

</pre><hr></hr><pre>
 108         vectorKind = supportsAVX2(tool) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? byteMode(kind) ? AMD64Kind.V256_BYTE : AMD64Kind.V256_WORD
 109                         : byteMode(kind) ? AMD64Kind.V128_BYTE : AMD64Kind.V128_WORD;
 110         vectorCompareVal1 = tool.newVariable(LIRKind.value(vectorKind));
 111         vectorCompareVal2 = nValues &gt; 1 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
 112         vectorCompareVal3 = nValues &gt; 2 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
 113         vectorCompareVal4 = nValues &gt; 3 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
 114         vectorArray1 = tool.newVariable(LIRKind.value(vectorKind));
 115         vectorArray2 = tool.newVariable(LIRKind.value(vectorKind));
 116         vectorArray3 = tool.newVariable(LIRKind.value(vectorKind));
 117         vectorArray4 = tool.newVariable(LIRKind.value(vectorKind));
 118     }
 119 
 120     private static boolean byteMode(JavaKind kind) {
 121         return kind == JavaKind.Byte;
 122     }
 123 
 124     private static boolean charMode(JavaKind kind) {
 125         return kind == JavaKind.Char;
 126     }
 127 








 128     @Override
 129     public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
 130         Register arrayPtr = asRegister(arrayPtrValue);
 131         Register arrayLength = asRegister(arrayLengthValue);
 132         Register result = asRegister(resultValue);
 133         Register slotsRemaining = asRegister(arraySlotsRemaining);
 134         Register[] searchValue = {
 135                         nValues &gt; 0 ? asRegister(searchValue1) : null,
 136                         nValues &gt; 1 ? asRegister(searchValue2) : null,
 137                         nValues &gt; 2 ? asRegister(searchValue3) : null,
 138                         nValues &gt; 3 ? asRegister(searchValue4) : null,
 139         };
 140         Register[] vecCmp = {
 141                         nValues &gt; 0 ? asRegister(vectorCompareVal1) : null,
 142                         nValues &gt; 1 ? asRegister(vectorCompareVal2) : null,
 143                         nValues &gt; 2 ? asRegister(vectorCompareVal3) : null,
 144                         nValues &gt; 3 ? asRegister(vectorCompareVal4) : null,
 145         };
 146         Register[] vecArray = {
 147                         asRegister(vectorArray1),
 148                         asRegister(vectorArray2),
 149                         asRegister(vectorArray3),
 150                         asRegister(vectorArray4),
 151         };
 152         Register[] cmpResult = {
 153                         asRegister(comparisonResult1),
 154                         asRegister(comparisonResult2),
 155                         asRegister(comparisonResult3),
 156                         asRegister(comparisonResult4),
 157         };
 158         Label retFound = new Label();
 159         Label retNotFound = new Label();
 160         Label end = new Label();
 161 
<span class="removed"> 162         AVXKind.AVXSize vectorSize = AVXKind.getDataSize(vectorKind);</span>
<span class="removed"> 163         int nVectors = nValues == 1 ? 4 : nValues == 2 ? 2 : 1;</span>
<span class="removed"> 164 </span>
 165         // load array length
 166         // important: this must be the first register manipulation, since arrayLengthValue is
 167         // annotated with @Use
 168         asm.movl(slotsRemaining, arrayLength);
 169         // load array pointer
 170         asm.movq(result, arrayPtr);
 171         // move search values to vectors
 172         for (int i = 0; i &lt; nValues; i++) {
 173             if (asm.supports(CPUFeature.AVX)) {
 174                 VexMoveOp.VMOVD.emit(asm, AVXKind.AVXSize.DWORD, vecCmp[i], searchValue[i]);
 175             } else {
 176                 asm.movdl(vecCmp[i], searchValue[i]);
 177             }
 178         }
 179         // fill comparison vector with copies of the search value
 180         for (int i = 0; i &lt; nValues; i++) {
<span class="changed"> 181             emitBroadcast(asm, findTwoConsecutive ? (byteMode(kind) ? JavaKind.Char : JavaKind.Int) : kind, vecCmp[i], vecArray[0], vectorSize);</span>
 182         }
 183 
<span class="changed"> 184         emitArrayIndexOfChars(crb, asm, kind, vectorSize, result, slotsRemaining, searchValue, vecCmp, vecArray, cmpResult, retFound, retNotFound, vmPageSize, nValues, nVectors, findTwoConsecutive);</span>
 185 
 186         // return -1 (no match)
 187         asm.bind(retNotFound);
 188         asm.movq(result, -1);
 189         asm.jmpb(end);
 190 
 191         asm.bind(retFound);
 192         // convert array pointer to offset
 193         asm.subq(result, arrayPtr);
 194         if (charMode(kind)) {
 195             asm.shrq(result, 1);
 196         }
 197         asm.bind(end);
 198     }
 199 
<span class="changed"> 200     private static void emitArrayIndexOfChars(CompilationResultBuilder crb, AMD64MacroAssembler asm, JavaKind kind, AVXKind.AVXSize vectorSize,</span>
 201                     Register arrayPtr,
 202                     Register slotsRemaining,
 203                     Register[] searchValue,
 204                     Register[] vecCmp,
 205                     Register[] vecArray,
 206                     Register[] cmpResult,
 207                     Label retFound,
<span class="changed"> 208                     Label retNotFound,</span>
<span class="changed"> 209                     int vmPageSize,</span>
<span class="changed"> 210                     int nValues,</span>
<span class="changed"> 211                     int nVectors,</span>
<span class="changed"> 212                     boolean findTwoCharPrefix) {</span>
 213         Label bulkVectorLoop = new Label();
 214         Label singleVectorLoop = new Label();
 215         Label[] vectorFound = {
 216                         new Label(),
 217                         new Label(),
 218                         new Label(),
 219                         new Label(),
 220         };
 221         Label lessThanVectorSizeRemaining = new Label();
 222         Label lessThanVectorSizeRemainingLoop = new Label();
 223         Label bulkVectorLoopExit = nVectors == 1 ? lessThanVectorSizeRemaining : singleVectorLoop;
 224         int bytesPerVector = vectorSize.getBytes();
 225         int arraySlotsPerVector = vectorSize.getBytes() / kind.getByteCount();
 226         int singleVectorLoopCondition = arraySlotsPerVector;
 227         int bulkSize = arraySlotsPerVector * nVectors;
 228         int bulkSizeBytes = bytesPerVector * nVectors;
 229         int bulkLoopCondition = bulkSize;
 230         int[] vectorOffsets;
 231         JavaKind vectorCompareKind = kind;
<span class="changed"> 232         if (findTwoCharPrefix) {</span>
 233             singleVectorLoopCondition++;
 234             bulkLoopCondition++;
 235             bulkSize /= 2;
 236             bulkSizeBytes /= 2;
 237             vectorOffsets = new int[]{0, kind.getByteCount(), bytesPerVector, bytesPerVector + kind.getByteCount()};
 238             vectorCompareKind = byteMode(kind) ? JavaKind.Char : JavaKind.Int;
 239         } else {
 240             vectorOffsets = new int[]{0, bytesPerVector, bytesPerVector * 2, bytesPerVector * 3};
 241         }
 242 
 243         // load copy of low part of array pointer
 244         Register tmpArrayPtrLow = cmpResult[0];
 245         asm.movl(tmpArrayPtrLow, arrayPtr);
 246 
 247         // check if bulk vector load is in bounds
 248         asm.cmpl(slotsRemaining, bulkLoopCondition);
 249         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);
 250 
 251         // check if array pointer is aligned to bulkSize
 252         asm.andl(tmpArrayPtrLow, bulkSizeBytes - 1);

</pre><hr></hr><pre>
 257         // load copy of low part of array pointer
 258         asm.movl(tmpArrayPtrLow, arrayPtr);
 259         // adjust array pointer
 260         asm.addq(arrayPtr, bulkSizeBytes);
 261         // adjust number of array slots remaining
 262         asm.subl(slotsRemaining, bulkSize);
 263         // get offset to bulk size alignment
 264         asm.andl(tmpArrayPtrLow, bulkSizeBytes - 1);
 265         emitBytesToArraySlots(asm, kind, tmpArrayPtrLow);
 266         // adjust array pointer to bulk size alignment
 267         asm.andq(arrayPtr, ~(bulkSizeBytes - 1));
 268         // adjust number of array slots remaining
 269         asm.addl(slotsRemaining, tmpArrayPtrLow);
 270         // check if there are enough array slots remaining for the bulk loop
 271         asm.cmpl(slotsRemaining, bulkLoopCondition);
 272         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);
 273 
 274         emitAlign(crb, asm);
 275         asm.bind(bulkVectorLoop);
 276         // memory-aligned bulk comparison
<span class="changed"> 277         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, nVectors, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, !findTwoCharPrefix);</span>
 278         // adjust number of array slots remaining
 279         asm.subl(slotsRemaining, bulkSize);
 280         // adjust array pointer
 281         asm.addq(arrayPtr, bulkSizeBytes);
 282         // check if there are enough array slots remaining for the bulk loop
 283         asm.cmpl(slotsRemaining, bulkLoopCondition);
 284         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);
 285         // continue loop
 286         asm.jmp(bulkVectorLoop);
 287 
 288         if (nVectors &gt; 1) {
 289             emitAlign(crb, asm);
 290             // same loop as bulkVectorLoop, with only one vector
 291             asm.bind(singleVectorLoop);
 292             // check if single vector load is in bounds
 293             asm.cmpl(slotsRemaining, singleVectorLoopCondition);
 294             asm.jcc(AMD64Assembler.ConditionFlag.Below, lessThanVectorSizeRemaining);
 295             // compare
<span class="changed"> 296             emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, findTwoCharPrefix ? 2 : 1, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, false);</span>
 297             // adjust number of array slots remaining
 298             asm.subl(slotsRemaining, arraySlotsPerVector);
 299             // adjust array pointer
 300             asm.addq(arrayPtr, bytesPerVector);
 301             // continue loop
 302             asm.jmpb(singleVectorLoop);
 303         }
 304 
 305         asm.bind(lessThanVectorSizeRemaining);
 306         // check if any array slots remain
 307         asm.testl(slotsRemaining, slotsRemaining);
 308         asm.jcc(AMD64Assembler.ConditionFlag.Zero, retNotFound);
 309 
 310         // a vector compare will read out of bounds of the input array.
 311         // check if the out-of-bounds read would cross a memory page boundary.
 312         // load copy of low part of array pointer
 313         asm.movl(tmpArrayPtrLow, arrayPtr);
 314         // check if pointer + vector size would cross the page boundary
 315         asm.andl(tmpArrayPtrLow, (vmPageSize - 1));
<span class="changed"> 316         asm.cmpl(tmpArrayPtrLow, (vmPageSize - (findTwoCharPrefix ? bytesPerVector + kind.getByteCount() : bytesPerVector)));</span>
 317         // if the page boundary would be crossed, do byte/character-wise comparison instead.
 318         asm.jccb(AMD64Assembler.ConditionFlag.Above, lessThanVectorSizeRemainingLoop);
 319 
 320         Label[] overBoundsMatch = {new Label(), new Label()};
 321         // otherwise, do a vector compare that reads beyond array bounds
<span class="changed"> 322         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, findTwoCharPrefix ? 2 : 1, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, overBoundsMatch, false);</span>
 323         // no match
 324         asm.jmp(retNotFound);
<span class="changed"> 325         if (findTwoCharPrefix) {</span>
 326             Label overBoundsFinish = new Label();
 327             asm.bind(overBoundsMatch[1]);
 328             // get match offset of second result
 329             asm.bsfq(cmpResult[1], cmpResult[1]);
 330             asm.addl(cmpResult[1], kind.getByteCount());
 331             // replace first result with second and continue
 332             asm.movl(cmpResult[0], cmpResult[1]);
 333             asm.jmpb(overBoundsFinish);
 334 
 335             asm.bind(overBoundsMatch[0]);
 336             emitFindTwoCharPrefixMinResult(asm, kind, cmpResult, overBoundsFinish);
 337         } else {
 338             asm.bind(overBoundsMatch[0]);
 339             // find match offset
 340             asm.bsfq(cmpResult[0], cmpResult[0]);
 341         }
 342 
 343         // adjust array pointer for match result
 344         asm.addq(arrayPtr, cmpResult[0]);
 345         if (charMode(kind)) {
 346             // convert byte offset to chars
 347             asm.shrl(cmpResult[0], 1);
 348         }
 349         // check if offset of matched value is greater than number of bytes remaining / out of array
 350         // bounds
<span class="changed"> 351         if (findTwoCharPrefix) {</span>
 352             asm.decrementl(slotsRemaining);
 353         }
 354         asm.cmpl(cmpResult[0], slotsRemaining);
 355         // match is out of bounds, return no match
 356         asm.jcc(AMD64Assembler.ConditionFlag.GreaterEqual, retNotFound);
 357         // adjust number of array slots remaining
<span class="changed"> 358         if (findTwoCharPrefix) {</span>
 359             asm.incrementl(slotsRemaining, 1);
 360         }
 361         asm.subl(slotsRemaining, cmpResult[0]);
 362         // match is in bounds, return offset
 363         asm.jmp(retFound);
 364 
 365         // compare remaining slots in the array one-by-one
 366         asm.bind(lessThanVectorSizeRemainingLoop);
 367         // check if enough array slots remain
<span class="changed"> 368         asm.cmpl(slotsRemaining, findTwoCharPrefix ? 1 : 0);</span>
 369         asm.jcc(AMD64Assembler.ConditionFlag.LessEqual, retNotFound);
 370         // load char / byte
 371         if (byteMode(kind)) {
<span class="changed"> 372             if (findTwoCharPrefix) {</span>
 373                 asm.movzwl(cmpResult[0], new AMD64Address(arrayPtr));
 374             } else {
 375                 asm.movzbl(cmpResult[0], new AMD64Address(arrayPtr));
 376             }
 377         } else {
<span class="changed"> 378             if (findTwoCharPrefix) {</span>
 379                 asm.movl(cmpResult[0], new AMD64Address(arrayPtr));
 380             } else {
 381                 asm.movzwl(cmpResult[0], new AMD64Address(arrayPtr));
 382             }
 383         }
 384         // check for match
 385         for (int i = 0; i &lt; nValues; i++) {
<span class="changed"> 386             asm.cmpl(cmpResult[0], searchValue[i]);</span>
 387             asm.jcc(AMD64Assembler.ConditionFlag.Equal, retFound);
 388         }
 389         // adjust number of array slots remaining
 390         asm.decrementl(slotsRemaining);
 391         // adjust array pointer
 392         asm.addq(arrayPtr, kind.getByteCount());
 393         // continue loop
 394         asm.jmpb(lessThanVectorSizeRemainingLoop);
 395 
<span class="changed"> 396         for (int i = 1; i &lt; nVectors; i += (findTwoCharPrefix ? 2 : 1)) {</span>
 397             emitVectorFoundWithOffset(asm, kind, vectorOffsets[i], arrayPtr, cmpResult[i], slotsRemaining, vectorFound[i], retFound);
 398         }
 399 
<span class="changed"> 400         if (findTwoCharPrefix) {</span>
 401             asm.bind(vectorFound[2]);
 402             asm.addq(arrayPtr, vectorOffsets[2]);
 403             // adjust number of array slots remaining
 404             asm.subl(slotsRemaining, charMode(kind) ? vectorOffsets[2] / 2 : vectorOffsets[2]);
 405             asm.movl(cmpResult[0], cmpResult[2]);
 406             asm.movl(cmpResult[1], cmpResult[3]);
 407             asm.bind(vectorFound[0]);
 408             emitFindTwoCharPrefixMinResult(asm, kind, cmpResult, new Label());
 409         } else {
 410             asm.bind(vectorFound[0]);
 411             // find index of first set bit in bit mask
 412             asm.bsfq(cmpResult[0], cmpResult[0]);
 413         }
 414         // add offset to array pointer
 415         asm.addq(arrayPtr, cmpResult[0]);
 416         if (charMode(kind)) {
 417             // convert byte offset to chars
 418             asm.shrl(cmpResult[0], 1);
 419         }
 420         // adjust number of array slots remaining

</pre><hr></hr><pre>
 609                 if (asm.supports(CPUFeature.AVX)) {
 610                     VexRVMOp.VPCMPEQD.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
 611                 } else { // SSE
 612                     asm.pcmpeqd(vecArray, vecCmp);
 613                 }
 614                 break;
 615             default:
 616                 throw new UnsupportedOperationException();
 617         }
 618     }
 619 
 620     private static void emitMOVMSK(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register dst, Register vecSrc) {
 621         if (asm.supports(CPUFeature.AVX)) {
 622             VexRMOp.VPMOVMSKB.emit(asm, vectorSize, dst, vecSrc);
 623         } else {
 624             // SSE
 625             asm.pmovmskb(dst, vecSrc);
 626         }
 627     }
 628 

















 629     private static boolean supportsAVX2(LIRGeneratorTool tool) {
 630         return supports(tool, CPUFeature.AVX2);
 631     }
 632 
 633     private static boolean supports(LIRGeneratorTool tool, CPUFeature cpuFeature) {
 634         return ((AMD64) tool.target().arch).getFeatures().contains(cpuFeature);
 635     }
 636 }
</pre></td><td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2018, 2019 Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */

</pre><hr></hr><pre>
 108         vectorKind = supportsAVX2(tool) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? byteMode(kind) ? AMD64Kind.V256_BYTE : AMD64Kind.V256_WORD
 109                         : byteMode(kind) ? AMD64Kind.V128_BYTE : AMD64Kind.V128_WORD;
 110         vectorCompareVal1 = tool.newVariable(LIRKind.value(vectorKind));
 111         vectorCompareVal2 = nValues &gt; 1 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
 112         vectorCompareVal3 = nValues &gt; 2 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
 113         vectorCompareVal4 = nValues &gt; 3 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
 114         vectorArray1 = tool.newVariable(LIRKind.value(vectorKind));
 115         vectorArray2 = tool.newVariable(LIRKind.value(vectorKind));
 116         vectorArray3 = tool.newVariable(LIRKind.value(vectorKind));
 117         vectorArray4 = tool.newVariable(LIRKind.value(vectorKind));
 118     }
 119 
 120     private static boolean byteMode(JavaKind kind) {
 121         return kind == JavaKind.Byte;
 122     }
 123 
 124     private static boolean charMode(JavaKind kind) {
 125         return kind == JavaKind.Char;
 126     }
 127 
<span class="new"> 128     private JavaKind getComparisonKind() {</span>
<span class="new"> 129         return findTwoConsecutive ? (byteMode(kind) ? JavaKind.Char : JavaKind.Int) : kind;</span>
<span class="new"> 130     }</span>
<span class="new"> 131 </span>
<span class="new"> 132     private AVXKind.AVXSize getVectorSize() {</span>
<span class="new"> 133         return AVXKind.getDataSize(vectorKind);</span>
<span class="new"> 134     }</span>
<span class="new"> 135 </span>
 136     @Override
 137     public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
 138         Register arrayPtr = asRegister(arrayPtrValue);
 139         Register arrayLength = asRegister(arrayLengthValue);
 140         Register result = asRegister(resultValue);
 141         Register slotsRemaining = asRegister(arraySlotsRemaining);
 142         Register[] searchValue = {
 143                         nValues &gt; 0 ? asRegister(searchValue1) : null,
 144                         nValues &gt; 1 ? asRegister(searchValue2) : null,
 145                         nValues &gt; 2 ? asRegister(searchValue3) : null,
 146                         nValues &gt; 3 ? asRegister(searchValue4) : null,
 147         };
 148         Register[] vecCmp = {
 149                         nValues &gt; 0 ? asRegister(vectorCompareVal1) : null,
 150                         nValues &gt; 1 ? asRegister(vectorCompareVal2) : null,
 151                         nValues &gt; 2 ? asRegister(vectorCompareVal3) : null,
 152                         nValues &gt; 3 ? asRegister(vectorCompareVal4) : null,
 153         };
 154         Register[] vecArray = {
 155                         asRegister(vectorArray1),
 156                         asRegister(vectorArray2),
 157                         asRegister(vectorArray3),
 158                         asRegister(vectorArray4),
 159         };
 160         Register[] cmpResult = {
 161                         asRegister(comparisonResult1),
 162                         asRegister(comparisonResult2),
 163                         asRegister(comparisonResult3),
 164                         asRegister(comparisonResult4),
 165         };
 166         Label retFound = new Label();
 167         Label retNotFound = new Label();
 168         Label end = new Label();
 169 



 170         // load array length
 171         // important: this must be the first register manipulation, since arrayLengthValue is
 172         // annotated with @Use
 173         asm.movl(slotsRemaining, arrayLength);
 174         // load array pointer
 175         asm.movq(result, arrayPtr);
 176         // move search values to vectors
 177         for (int i = 0; i &lt; nValues; i++) {
 178             if (asm.supports(CPUFeature.AVX)) {
 179                 VexMoveOp.VMOVD.emit(asm, AVXKind.AVXSize.DWORD, vecCmp[i], searchValue[i]);
 180             } else {
 181                 asm.movdl(vecCmp[i], searchValue[i]);
 182             }
 183         }
 184         // fill comparison vector with copies of the search value
 185         for (int i = 0; i &lt; nValues; i++) {
<span class="changed"> 186             emitBroadcast(asm, getComparisonKind(), vecCmp[i], vecArray[0], getVectorSize());</span>
 187         }
 188 
<span class="changed"> 189         emitArrayIndexOfChars(crb, asm, result, slotsRemaining, searchValue, vecCmp, vecArray, cmpResult, retFound, retNotFound);</span>
 190 
 191         // return -1 (no match)
 192         asm.bind(retNotFound);
 193         asm.movq(result, -1);
 194         asm.jmpb(end);
 195 
 196         asm.bind(retFound);
 197         // convert array pointer to offset
 198         asm.subq(result, arrayPtr);
 199         if (charMode(kind)) {
 200             asm.shrq(result, 1);
 201         }
 202         asm.bind(end);
 203     }
 204 
<span class="changed"> 205     private void emitArrayIndexOfChars(CompilationResultBuilder crb, AMD64MacroAssembler asm,</span>
 206                     Register arrayPtr,
 207                     Register slotsRemaining,
 208                     Register[] searchValue,
 209                     Register[] vecCmp,
 210                     Register[] vecArray,
 211                     Register[] cmpResult,
 212                     Label retFound,
<span class="changed"> 213                     Label retNotFound) {</span>
<span class="changed"> 214         int nVectors = nValues == 1 ? 4 : nValues == 2 ? 2 : 1;</span>
<span class="changed"> 215         AVXKind.AVXSize vectorSize = getVectorSize();</span>
<span class="changed"> 216 </span>

 217         Label bulkVectorLoop = new Label();
 218         Label singleVectorLoop = new Label();
 219         Label[] vectorFound = {
 220                         new Label(),
 221                         new Label(),
 222                         new Label(),
 223                         new Label(),
 224         };
 225         Label lessThanVectorSizeRemaining = new Label();
 226         Label lessThanVectorSizeRemainingLoop = new Label();
 227         Label bulkVectorLoopExit = nVectors == 1 ? lessThanVectorSizeRemaining : singleVectorLoop;
 228         int bytesPerVector = vectorSize.getBytes();
 229         int arraySlotsPerVector = vectorSize.getBytes() / kind.getByteCount();
 230         int singleVectorLoopCondition = arraySlotsPerVector;
 231         int bulkSize = arraySlotsPerVector * nVectors;
 232         int bulkSizeBytes = bytesPerVector * nVectors;
 233         int bulkLoopCondition = bulkSize;
 234         int[] vectorOffsets;
 235         JavaKind vectorCompareKind = kind;
<span class="changed"> 236         if (findTwoConsecutive) {</span>
 237             singleVectorLoopCondition++;
 238             bulkLoopCondition++;
 239             bulkSize /= 2;
 240             bulkSizeBytes /= 2;
 241             vectorOffsets = new int[]{0, kind.getByteCount(), bytesPerVector, bytesPerVector + kind.getByteCount()};
 242             vectorCompareKind = byteMode(kind) ? JavaKind.Char : JavaKind.Int;
 243         } else {
 244             vectorOffsets = new int[]{0, bytesPerVector, bytesPerVector * 2, bytesPerVector * 3};
 245         }
 246 
 247         // load copy of low part of array pointer
 248         Register tmpArrayPtrLow = cmpResult[0];
 249         asm.movl(tmpArrayPtrLow, arrayPtr);
 250 
 251         // check if bulk vector load is in bounds
 252         asm.cmpl(slotsRemaining, bulkLoopCondition);
 253         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);
 254 
 255         // check if array pointer is aligned to bulkSize
 256         asm.andl(tmpArrayPtrLow, bulkSizeBytes - 1);

</pre><hr></hr><pre>
 261         // load copy of low part of array pointer
 262         asm.movl(tmpArrayPtrLow, arrayPtr);
 263         // adjust array pointer
 264         asm.addq(arrayPtr, bulkSizeBytes);
 265         // adjust number of array slots remaining
 266         asm.subl(slotsRemaining, bulkSize);
 267         // get offset to bulk size alignment
 268         asm.andl(tmpArrayPtrLow, bulkSizeBytes - 1);
 269         emitBytesToArraySlots(asm, kind, tmpArrayPtrLow);
 270         // adjust array pointer to bulk size alignment
 271         asm.andq(arrayPtr, ~(bulkSizeBytes - 1));
 272         // adjust number of array slots remaining
 273         asm.addl(slotsRemaining, tmpArrayPtrLow);
 274         // check if there are enough array slots remaining for the bulk loop
 275         asm.cmpl(slotsRemaining, bulkLoopCondition);
 276         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);
 277 
 278         emitAlign(crb, asm);
 279         asm.bind(bulkVectorLoop);
 280         // memory-aligned bulk comparison
<span class="changed"> 281         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, nVectors, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, !findTwoConsecutive);</span>
 282         // adjust number of array slots remaining
 283         asm.subl(slotsRemaining, bulkSize);
 284         // adjust array pointer
 285         asm.addq(arrayPtr, bulkSizeBytes);
 286         // check if there are enough array slots remaining for the bulk loop
 287         asm.cmpl(slotsRemaining, bulkLoopCondition);
 288         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);
 289         // continue loop
 290         asm.jmp(bulkVectorLoop);
 291 
 292         if (nVectors &gt; 1) {
 293             emitAlign(crb, asm);
 294             // same loop as bulkVectorLoop, with only one vector
 295             asm.bind(singleVectorLoop);
 296             // check if single vector load is in bounds
 297             asm.cmpl(slotsRemaining, singleVectorLoopCondition);
 298             asm.jcc(AMD64Assembler.ConditionFlag.Below, lessThanVectorSizeRemaining);
 299             // compare
<span class="changed"> 300             emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, findTwoConsecutive ? 2 : 1, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, false);</span>
 301             // adjust number of array slots remaining
 302             asm.subl(slotsRemaining, arraySlotsPerVector);
 303             // adjust array pointer
 304             asm.addq(arrayPtr, bytesPerVector);
 305             // continue loop
 306             asm.jmpb(singleVectorLoop);
 307         }
 308 
 309         asm.bind(lessThanVectorSizeRemaining);
 310         // check if any array slots remain
 311         asm.testl(slotsRemaining, slotsRemaining);
 312         asm.jcc(AMD64Assembler.ConditionFlag.Zero, retNotFound);
 313 
 314         // a vector compare will read out of bounds of the input array.
 315         // check if the out-of-bounds read would cross a memory page boundary.
 316         // load copy of low part of array pointer
 317         asm.movl(tmpArrayPtrLow, arrayPtr);
 318         // check if pointer + vector size would cross the page boundary
 319         asm.andl(tmpArrayPtrLow, (vmPageSize - 1));
<span class="changed"> 320         asm.cmpl(tmpArrayPtrLow, (vmPageSize - (findTwoConsecutive ? bytesPerVector + kind.getByteCount() : bytesPerVector)));</span>
 321         // if the page boundary would be crossed, do byte/character-wise comparison instead.
 322         asm.jccb(AMD64Assembler.ConditionFlag.Above, lessThanVectorSizeRemainingLoop);
 323 
 324         Label[] overBoundsMatch = {new Label(), new Label()};
 325         // otherwise, do a vector compare that reads beyond array bounds
<span class="changed"> 326         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, findTwoConsecutive ? 2 : 1, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, overBoundsMatch, false);</span>
 327         // no match
 328         asm.jmp(retNotFound);
<span class="changed"> 329         if (findTwoConsecutive) {</span>
 330             Label overBoundsFinish = new Label();
 331             asm.bind(overBoundsMatch[1]);
 332             // get match offset of second result
 333             asm.bsfq(cmpResult[1], cmpResult[1]);
 334             asm.addl(cmpResult[1], kind.getByteCount());
 335             // replace first result with second and continue
 336             asm.movl(cmpResult[0], cmpResult[1]);
 337             asm.jmpb(overBoundsFinish);
 338 
 339             asm.bind(overBoundsMatch[0]);
 340             emitFindTwoCharPrefixMinResult(asm, kind, cmpResult, overBoundsFinish);
 341         } else {
 342             asm.bind(overBoundsMatch[0]);
 343             // find match offset
 344             asm.bsfq(cmpResult[0], cmpResult[0]);
 345         }
 346 
 347         // adjust array pointer for match result
 348         asm.addq(arrayPtr, cmpResult[0]);
 349         if (charMode(kind)) {
 350             // convert byte offset to chars
 351             asm.shrl(cmpResult[0], 1);
 352         }
 353         // check if offset of matched value is greater than number of bytes remaining / out of array
 354         // bounds
<span class="changed"> 355         if (findTwoConsecutive) {</span>
 356             asm.decrementl(slotsRemaining);
 357         }
 358         asm.cmpl(cmpResult[0], slotsRemaining);
 359         // match is out of bounds, return no match
 360         asm.jcc(AMD64Assembler.ConditionFlag.GreaterEqual, retNotFound);
 361         // adjust number of array slots remaining
<span class="changed"> 362         if (findTwoConsecutive) {</span>
 363             asm.incrementl(slotsRemaining, 1);
 364         }
 365         asm.subl(slotsRemaining, cmpResult[0]);
 366         // match is in bounds, return offset
 367         asm.jmp(retFound);
 368 
 369         // compare remaining slots in the array one-by-one
 370         asm.bind(lessThanVectorSizeRemainingLoop);
 371         // check if enough array slots remain
<span class="changed"> 372         asm.cmpl(slotsRemaining, findTwoConsecutive ? 1 : 0);</span>
 373         asm.jcc(AMD64Assembler.ConditionFlag.LessEqual, retNotFound);
 374         // load char / byte
 375         if (byteMode(kind)) {
<span class="changed"> 376             if (findTwoConsecutive) {</span>
 377                 asm.movzwl(cmpResult[0], new AMD64Address(arrayPtr));
 378             } else {
 379                 asm.movzbl(cmpResult[0], new AMD64Address(arrayPtr));
 380             }
 381         } else {
<span class="changed"> 382             if (findTwoConsecutive) {</span>
 383                 asm.movl(cmpResult[0], new AMD64Address(arrayPtr));
 384             } else {
 385                 asm.movzwl(cmpResult[0], new AMD64Address(arrayPtr));
 386             }
 387         }
 388         // check for match
 389         for (int i = 0; i &lt; nValues; i++) {
<span class="changed"> 390             emitCompareInst(asm, getComparisonKind(), cmpResult[0], searchValue[i]);</span>
 391             asm.jcc(AMD64Assembler.ConditionFlag.Equal, retFound);
 392         }
 393         // adjust number of array slots remaining
 394         asm.decrementl(slotsRemaining);
 395         // adjust array pointer
 396         asm.addq(arrayPtr, kind.getByteCount());
 397         // continue loop
 398         asm.jmpb(lessThanVectorSizeRemainingLoop);
 399 
<span class="changed"> 400         for (int i = 1; i &lt; nVectors; i += (findTwoConsecutive ? 2 : 1)) {</span>
 401             emitVectorFoundWithOffset(asm, kind, vectorOffsets[i], arrayPtr, cmpResult[i], slotsRemaining, vectorFound[i], retFound);
 402         }
 403 
<span class="changed"> 404         if (findTwoConsecutive) {</span>
 405             asm.bind(vectorFound[2]);
 406             asm.addq(arrayPtr, vectorOffsets[2]);
 407             // adjust number of array slots remaining
 408             asm.subl(slotsRemaining, charMode(kind) ? vectorOffsets[2] / 2 : vectorOffsets[2]);
 409             asm.movl(cmpResult[0], cmpResult[2]);
 410             asm.movl(cmpResult[1], cmpResult[3]);
 411             asm.bind(vectorFound[0]);
 412             emitFindTwoCharPrefixMinResult(asm, kind, cmpResult, new Label());
 413         } else {
 414             asm.bind(vectorFound[0]);
 415             // find index of first set bit in bit mask
 416             asm.bsfq(cmpResult[0], cmpResult[0]);
 417         }
 418         // add offset to array pointer
 419         asm.addq(arrayPtr, cmpResult[0]);
 420         if (charMode(kind)) {
 421             // convert byte offset to chars
 422             asm.shrl(cmpResult[0], 1);
 423         }
 424         // adjust number of array slots remaining

</pre><hr></hr><pre>
 613                 if (asm.supports(CPUFeature.AVX)) {
 614                     VexRVMOp.VPCMPEQD.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
 615                 } else { // SSE
 616                     asm.pcmpeqd(vecArray, vecCmp);
 617                 }
 618                 break;
 619             default:
 620                 throw new UnsupportedOperationException();
 621         }
 622     }
 623 
 624     private static void emitMOVMSK(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register dst, Register vecSrc) {
 625         if (asm.supports(CPUFeature.AVX)) {
 626             VexRMOp.VPMOVMSKB.emit(asm, vectorSize, dst, vecSrc);
 627         } else {
 628             // SSE
 629             asm.pmovmskb(dst, vecSrc);
 630         }
 631     }
 632 
<span class="new"> 633     private static void emitCompareInst(AMD64MacroAssembler asm, JavaKind kind, Register dst, Register src) {</span>
<span class="new"> 634         switch (kind) {</span>
<span class="new"> 635             case Byte:</span>
<span class="new"> 636                 asm.cmpb(dst, src);</span>
<span class="new"> 637                 break;</span>
<span class="new"> 638             case Short:</span>
<span class="new"> 639             case Char:</span>
<span class="new"> 640                 asm.cmpw(dst, src);</span>
<span class="new"> 641                 break;</span>
<span class="new"> 642             case Int:</span>
<span class="new"> 643                 asm.cmpl(dst, src);</span>
<span class="new"> 644                 break;</span>
<span class="new"> 645             default:</span>
<span class="new"> 646                 asm.cmpq(dst, src);</span>
<span class="new"> 647         }</span>
<span class="new"> 648     }</span>
<span class="new"> 649 </span>
 650     private static boolean supportsAVX2(LIRGeneratorTool tool) {
 651         return supports(tool, CPUFeature.AVX2);
 652     }
 653 
 654     private static boolean supports(LIRGeneratorTool tool, CPUFeature cpuFeature) {
 655         return ((AMD64) tool.target().arch).getFeatures().contains(cpuFeature);
 656     }
 657 }
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../../src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64Assembler.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../../index.html' target='_top'>index</a> next &gt</center>
</body></html>
