<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/hotspot/share/runtime/javaCalls.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_RUNTIME_JAVACALLS_HPP
  26 #define SHARE_RUNTIME_JAVACALLS_HPP
  27 
  28 #include "memory/allocation.hpp"
  29 #include "oops/method.hpp"
  30 #include "runtime/handles.hpp"
  31 #include "runtime/javaFrameAnchor.hpp"
  32 #include "runtime/thread.hpp"
  33 #include "runtime/vmThread.hpp"
  34 #include "utilities/macros.hpp"
  35 
  36 #include CPU_HEADER(jniTypes)
  37 
  38 // A JavaCallWrapper is constructed before each JavaCall and destructed after the call.
  39 // Its purpose is to allocate/deallocate a new handle block and to save/restore the last
  40 // Java fp/sp. A pointer to the JavaCallWrapper is stored on the stack.
  41 
  42 class JavaCallWrapper: StackObj {
  43   friend class VMStructs;
  44  private:
  45   JavaThread*      _thread;                 // the thread to which this call belongs
  46   JNIHandleBlock*  _handles;                // the saved handle block
  47   Method*          _callee_method;          // to be able to collect arguments if entry frame is top frame
  48   oop              _receiver;               // the receiver of the call (if a non-static call)
  49 
  50   JavaFrameAnchor  _anchor;                 // last thread anchor state that we must restore
  51 
  52   JavaValue*       _result;                 // result value
  53 
  54  public:
  55   // Construction/destruction
  56    JavaCallWrapper(const methodHandle&amp; callee_method, Handle receiver, JavaValue* result, TRAPS);
  57   ~JavaCallWrapper();
  58 
  59   // Accessors
  60   JavaThread*      thread() const           { return _thread; }
  61   JNIHandleBlock*  handles() const          { return _handles; }
  62 
  63   JavaFrameAnchor* anchor(void)             { return &amp;_anchor; }
  64 
  65   JavaValue*       result() const           { return _result; }
  66   // GC support
  67   Method*          callee_method()          { return _callee_method; }
  68   oop              receiver()               { return _receiver; }
  69   void             oops_do(OopClosure* f);
  70 
  71   bool             is_first_frame() const   { return _anchor.last_Java_sp() == NULL; }
  72 
  73 };
  74 
  75 
  76 // Encapsulates arguments to a JavaCall (faster, safer, and more convenient than using var-args)
  77 class JavaCallArguments : public StackObj {
  78  private:
  79   enum Constants {
  80    _default_size = 8    // Must be at least # of arguments in JavaCalls methods
  81   };
  82 
  83   intptr_t    _value_buffer      [_default_size + 1];
  84   u_char      _value_state_buffer[_default_size + 1];
  85 
  86   intptr_t*   _value;
  87   u_char*     _value_state;
  88   int         _size;
  89   int         _max_size;
  90   bool        _start_at_zero;      // Support late setting of receiver
  91   JVMCI_ONLY(nmethod*    _alternative_target;) // Nmethod that should be called instead of normal target
  92 
  93   void initialize() {
  94     // Starts at first element to support set_receiver.
  95     _value       = &amp;_value_buffer[1];
  96     _value_state = &amp;_value_state_buffer[1];
  97 
  98     _max_size = _default_size;
  99     _size = 0;
 100     _start_at_zero = false;
 101     JVMCI_ONLY(_alternative_target = NULL;)
 102   }
 103 
 104   // Helper for push_oop and the like.  The value argument is a
 105   // "handle" that refers to an oop.  We record the address of the
 106   // handle rather than the designated oop.  The handle is later
 107   // resolved to the oop by parameters().  This delays the exposure of
 108   // naked oops until it is GC-safe.
 109   template&lt;typename T&gt;
 110   inline int push_oop_impl(T handle, int size) {
 111     // JNITypes::put_obj expects an oop value, so we play fast and
 112     // loose with the type system.  The cast from handle type to oop
 113     // *must* use a C-style cast.  In a product build it performs a
 114     // reinterpret_cast. In a debug build (more accurately, in a
 115     // CHECK_UNHANDLED_OOPS build) it performs a static_cast, invoking
 116     // the debug-only oop class's conversion from void* constructor.
 117     JNITypes::put_obj((oop)handle, _value, size); // Updates size.
 118     return size;                // Return the updated size.
 119   }
 120 
 121  public:
 122   JavaCallArguments() { initialize(); }
 123 
 124   JavaCallArguments(Handle receiver) {
 125     initialize();
 126     push_oop(receiver);
 127   }
 128 
 129   JavaCallArguments(int max_size) {
 130     if (max_size &gt; _default_size) {
 131       _value = NEW_RESOURCE_ARRAY(intptr_t, max_size + 1);
 132       _value_state = NEW_RESOURCE_ARRAY(u_char, max_size + 1);
 133 
 134       // Reserve room for potential receiver in value and state
 135       _value++;
 136       _value_state++;
 137 
 138       _max_size = max_size;
 139       _size = 0;
 140       _start_at_zero = false;
 141       JVMCI_ONLY(_alternative_target = NULL;)
 142     } else {
 143       initialize();
 144     }
 145   }
 146 
 147 #if INCLUDE_JVMCI
 148   void set_alternative_target(nmethod* target) {
 149     _alternative_target = target;
 150   }
 151 
 152   nmethod* alternative_target() {
 153     return _alternative_target;
 154   }
 155 #endif
 156 
 157   // The possible values for _value_state elements.
 158   enum {
 159     value_state_primitive,
 160     value_state_oop,
 161     value_state_handle,
 162     value_state_jobject,
 163     value_state_limit
 164   };
 165 
 166   inline void push_oop(Handle h) {
 167     _value_state[_size] = value_state_handle;
 168     _size = push_oop_impl(h.raw_value(), _size);
 169   }
 170 
 171   inline void push_jobject(jobject h) {
 172     _value_state[_size] = value_state_jobject;
 173     _size = push_oop_impl(h, _size);
 174   }
 175 
 176   inline void push_int(int i) {
 177     _value_state[_size] = value_state_primitive;
 178     JNITypes::put_int(i, _value, _size);
 179   }
 180 
 181   inline void push_double(double d) {
 182     _value_state[_size] = value_state_primitive;
 183     _value_state[_size + 1] = value_state_primitive;
 184     JNITypes::put_double(d, _value, _size);
 185   }
 186 
 187   inline void push_long(jlong l) {
 188     _value_state[_size] = value_state_primitive;
 189     _value_state[_size + 1] = value_state_primitive;
 190     JNITypes::put_long(l, _value, _size);
 191   }
 192 
 193   inline void push_float(float f) {
 194     _value_state[_size] = value_state_primitive;
 195     JNITypes::put_float(f, _value, _size);
 196   }
 197 
 198   // receiver
 199   Handle receiver() {
 200     assert(_size &gt; 0, "must at least be one argument");
 201     assert(_value_state[0] == value_state_handle,
 202            "first argument must be an oop");
 203     assert(_value[0] != 0, "receiver must be not-null");
 204     return Handle((oop*)_value[0], false);
 205   }
 206 
 207   void set_receiver(Handle h) {
 208     assert(_start_at_zero == false, "can only be called once");
 209     _start_at_zero = true;
 210     _value_state--;
 211     _value--;
 212     _size++;
 213     _value_state[0] = value_state_handle;
 214     push_oop_impl(h.raw_value(), 0);
 215   }
 216 
 217   // Converts all Handles to oops, and returns a reference to parameter vector
 218   intptr_t* parameters() ;
 219   int   size_of_parameters() const { return _size; }
 220 
 221   // Verify that pushed arguments fits a given method
 222   void verify(const methodHandle&amp; method, BasicType return_type);
 223 };
 224 
 225 // All calls to Java have to go via JavaCalls. Sets up the stack frame
 226 // and makes sure that the last_Java_frame pointers are chained correctly.
 227 //
 228 
 229 class JavaCalls: AllStatic {
 230   static void call_helper(JavaValue* result, const methodHandle&amp; method, JavaCallArguments* args, TRAPS);
 231  public:
 232   // call_special
 233   // ------------
 234   // The receiver must be first oop in argument list
 235   static void call_special(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS);
 236 
 237   static void call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, TRAPS); // No args
 238   static void call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS);
 239   static void call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS);
 240 
 241   // virtual call
 242   // ------------
 243 
 244   // The receiver must be first oop in argument list
 245   static void call_virtual(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS);
 246 
 247   static void call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, TRAPS); // No args
 248   static void call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS);
 249   static void call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS);
 250 
 251   // Static call
 252   // -----------
 253   static void call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS);
 254 
 255   static void call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, TRAPS);
 256   static void call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS);
 257   static void call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS);
 258   static void call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, Handle arg3, TRAPS);
 259 
 260   // Allocate instance + invoke constructor. This is equivalent to "new Klass(args ...)" expression in Java code.
 261   static Handle construct_new_instance(InstanceKlass* klass, Symbol* constructor_signature, JavaCallArguments* args, TRAPS);
 262 
 263   static Handle construct_new_instance(InstanceKlass* klass, Symbol* constructor_signature, TRAPS);
 264   static Handle construct_new_instance(InstanceKlass* klass, Symbol* constructor_signature, Handle arg1, TRAPS);
 265   static Handle construct_new_instance(InstanceKlass* klass, Symbol* constructor_signature, Handle arg1, Handle arg2, TRAPS);
 266 
 267   // Low-level interface
 268   static void call(JavaValue* result, const methodHandle&amp; method, JavaCallArguments* args, TRAPS);
 269 };
 270 
 271 #endif // SHARE_RUNTIME_JAVACALLS_HPP
</pre></body></html>
