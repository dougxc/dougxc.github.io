<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot </title>
</head><body id="SUNWwebrev">
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfig.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 836             }
 837         }
 838     }
 839 
 840     @HotSpotVMConstant(name = "ASSERT") @Stable public boolean cAssertions;
 841     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
 842     public final boolean linuxOs = System.getProperty("os.name", "").startsWith("Linux");
 843 
 844     @HotSpotVMFlag(name = "CodeEntryAlignment") @Stable public int codeEntryAlignment;
 845     @HotSpotVMFlag(name = "VerifyOops") @Stable public boolean verifyOops;
 846     @HotSpotVMFlag(name = "CITime") @Stable public boolean ciTime;
 847     @HotSpotVMFlag(name = "CITimeEach") @Stable public boolean ciTimeEach;
 848     @HotSpotVMFlag(name = "CompileTheWorldStartAt", optional = true) @Stable public int compileTheWorldStartAt;
 849     @HotSpotVMFlag(name = "CompileTheWorldStopAt", optional = true) @Stable public int compileTheWorldStopAt;
 850     @HotSpotVMFlag(name = "DontCompileHugeMethods") @Stable public boolean dontCompileHugeMethods;
 851     @HotSpotVMFlag(name = "HugeMethodLimit") @Stable public int hugeMethodLimit;
 852     @HotSpotVMFlag(name = "PrintInlining") @Stable public boolean printInlining;
 853     @HotSpotVMFlag(name = "JVMCIUseFastLocking") @Stable public boolean useFastLocking;
 854     @HotSpotVMFlag(name = "ForceUnreachable") @Stable public boolean forceUnreachable;
 855     @HotSpotVMFlag(name = "CodeCacheSegmentSize") @Stable public int codeSegmentSize;

 856 
 857     @HotSpotVMFlag(name = "UseTLAB") @Stable public boolean useTLAB;
 858     @HotSpotVMFlag(name = "UseBiasedLocking") @Stable public boolean useBiasedLocking;
 859     @HotSpotVMFlag(name = "UsePopCountInstruction") @Stable public boolean usePopCountInstruction;
 860     @HotSpotVMFlag(name = "UseCountLeadingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountLeadingZerosInstruction;
 861     @HotSpotVMFlag(name = "UseCountTrailingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountTrailingZerosInstruction;
 862     @HotSpotVMFlag(name = "UseAESIntrinsics") @Stable public boolean useAESIntrinsics;
 863     @HotSpotVMFlag(name = "UseCRC32Intrinsics") @Stable public boolean useCRC32Intrinsics;
 864     @HotSpotVMFlag(name = "UseG1GC") @Stable public boolean useG1GC;
 865     @HotSpotVMFlag(name = "UseConcMarkSweepGC") @Stable public boolean useCMSGC;
 866 
 867     @HotSpotVMFlag(name = "AllocatePrefetchStyle") @Stable public int allocatePrefetchStyle;
 868     @HotSpotVMFlag(name = "AllocatePrefetchInstr") @Stable public int allocatePrefetchInstr;
 869     @HotSpotVMFlag(name = "AllocatePrefetchLines") @Stable public int allocatePrefetchLines;
 870     @HotSpotVMFlag(name = "AllocateInstancePrefetchLines") @Stable public int allocateInstancePrefetchLines;
 871     @HotSpotVMFlag(name = "AllocatePrefetchStepSize") @Stable public int allocatePrefetchStepSize;
 872     @HotSpotVMFlag(name = "AllocatePrefetchDistance") @Stable public int allocatePrefetchDistance;
 873 
 874     @HotSpotVMFlag(name = "FlightRecorder", optional = true) @Stable public boolean flightRecorder;
 875 

</pre><hr></hr><pre>
1666     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_ADDRESS") @Stable public int MARKID_CARD_TABLE_ADDRESS;
1667     @HotSpotVMConstant(name = "CodeInstaller::HEAP_TOP_ADDRESS") @Stable public int MARKID_HEAP_TOP_ADDRESS;
1668     @HotSpotVMConstant(name = "CodeInstaller::HEAP_END_ADDRESS") @Stable public int MARKID_HEAP_END_ADDRESS;
1669     @HotSpotVMConstant(name = "CodeInstaller::NARROW_KLASS_BASE_ADDRESS") @Stable public int MARKID_NARROW_KLASS_BASE_ADDRESS;
1670     @HotSpotVMConstant(name = "CodeInstaller::CRC_TABLE_ADDRESS") @Stable public int MARKID_CRC_TABLE_ADDRESS;
1671     @HotSpotVMConstant(name = "CodeInstaller::INVOKE_INVALID") @Stable public int MARKID_INVOKE_INVALID;
1672 
1673     @HotSpotVMConstant(name = "BitData::exception_seen_flag") @Stable public int bitDataExceptionSeenFlag;
1674     @HotSpotVMConstant(name = "BitData::null_seen_flag") @Stable public int bitDataNullSeenFlag;
1675     @HotSpotVMConstant(name = "CounterData::count_off") @Stable public int methodDataCountOffset;
1676     @HotSpotVMConstant(name = "JumpData::taken_off_set") @Stable public int jumpDataTakenOffset;
1677     @HotSpotVMConstant(name = "JumpData::displacement_off_set") @Stable public int jumpDataDisplacementOffset;
1678     @HotSpotVMConstant(name = "ReceiverTypeData::nonprofiled_count_off_set") @Stable public int receiverTypeDataNonprofiledCountOffset;
1679     @HotSpotVMConstant(name = "ReceiverTypeData::receiver_type_row_cell_count") @Stable public int receiverTypeDataReceiverTypeRowCellCount;
1680     @HotSpotVMConstant(name = "ReceiverTypeData::receiver0_offset") @Stable public int receiverTypeDataReceiver0Offset;
1681     @HotSpotVMConstant(name = "ReceiverTypeData::count0_offset") @Stable public int receiverTypeDataCount0Offset;
1682     @HotSpotVMConstant(name = "BranchData::not_taken_off_set") @Stable public int branchDataNotTakenOffset;
1683     @HotSpotVMConstant(name = "ArrayData::array_len_off_set") @Stable public int arrayDataArrayLenOffset;
1684     @HotSpotVMConstant(name = "ArrayData::array_start_off_set") @Stable public int arrayDataArrayStartOffset;
1685     @HotSpotVMConstant(name = "MultiBranchData::per_case_cell_count") @Stable public int multiBranchDataPerCaseCellCount;

1686     // Checkstyle: resume
1687 
1688     private boolean check() {
1689         for (Field f : getClass().getDeclaredFields()) {
1690             int modifiers = f.getModifiers();
1691             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
1692                 assert Modifier.isFinal(modifiers) || f.getAnnotation(Stable.class) != null : "field should either be final or @Stable: " + f;
1693             }
1694         }
1695 
1696         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
1697         assert (layoutHelperArrayTagObjectValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "object array must have first bit set";
1698         assert (layoutHelperArrayTagTypeValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "type array must have first bit set";
1699 
1700         return true;
1701     }
1702 
1703     /**
1704      * A compact representation of the different encoding strategies for Objects and metadata.
1705      */

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 836             }
 837         }
 838     }
 839 
 840     @HotSpotVMConstant(name = "ASSERT") @Stable public boolean cAssertions;
 841     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
 842     public final boolean linuxOs = System.getProperty("os.name", "").startsWith("Linux");
 843 
 844     @HotSpotVMFlag(name = "CodeEntryAlignment") @Stable public int codeEntryAlignment;
 845     @HotSpotVMFlag(name = "VerifyOops") @Stable public boolean verifyOops;
 846     @HotSpotVMFlag(name = "CITime") @Stable public boolean ciTime;
 847     @HotSpotVMFlag(name = "CITimeEach") @Stable public boolean ciTimeEach;
 848     @HotSpotVMFlag(name = "CompileTheWorldStartAt", optional = true) @Stable public int compileTheWorldStartAt;
 849     @HotSpotVMFlag(name = "CompileTheWorldStopAt", optional = true) @Stable public int compileTheWorldStopAt;
 850     @HotSpotVMFlag(name = "DontCompileHugeMethods") @Stable public boolean dontCompileHugeMethods;
 851     @HotSpotVMFlag(name = "HugeMethodLimit") @Stable public int hugeMethodLimit;
 852     @HotSpotVMFlag(name = "PrintInlining") @Stable public boolean printInlining;
 853     @HotSpotVMFlag(name = "JVMCIUseFastLocking") @Stable public boolean useFastLocking;
 854     @HotSpotVMFlag(name = "ForceUnreachable") @Stable public boolean forceUnreachable;
 855     @HotSpotVMFlag(name = "CodeCacheSegmentSize") @Stable public int codeSegmentSize;
<span class="new"> 856     @HotSpotVMFlag(name = "FoldStableValues") @Stable public boolean foldStableValues;</span>
 857 
 858     @HotSpotVMFlag(name = "UseTLAB") @Stable public boolean useTLAB;
 859     @HotSpotVMFlag(name = "UseBiasedLocking") @Stable public boolean useBiasedLocking;
 860     @HotSpotVMFlag(name = "UsePopCountInstruction") @Stable public boolean usePopCountInstruction;
 861     @HotSpotVMFlag(name = "UseCountLeadingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountLeadingZerosInstruction;
 862     @HotSpotVMFlag(name = "UseCountTrailingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountTrailingZerosInstruction;
 863     @HotSpotVMFlag(name = "UseAESIntrinsics") @Stable public boolean useAESIntrinsics;
 864     @HotSpotVMFlag(name = "UseCRC32Intrinsics") @Stable public boolean useCRC32Intrinsics;
 865     @HotSpotVMFlag(name = "UseG1GC") @Stable public boolean useG1GC;
 866     @HotSpotVMFlag(name = "UseConcMarkSweepGC") @Stable public boolean useCMSGC;
 867 
 868     @HotSpotVMFlag(name = "AllocatePrefetchStyle") @Stable public int allocatePrefetchStyle;
 869     @HotSpotVMFlag(name = "AllocatePrefetchInstr") @Stable public int allocatePrefetchInstr;
 870     @HotSpotVMFlag(name = "AllocatePrefetchLines") @Stable public int allocatePrefetchLines;
 871     @HotSpotVMFlag(name = "AllocateInstancePrefetchLines") @Stable public int allocateInstancePrefetchLines;
 872     @HotSpotVMFlag(name = "AllocatePrefetchStepSize") @Stable public int allocatePrefetchStepSize;
 873     @HotSpotVMFlag(name = "AllocatePrefetchDistance") @Stable public int allocatePrefetchDistance;
 874 
 875     @HotSpotVMFlag(name = "FlightRecorder", optional = true) @Stable public boolean flightRecorder;
 876 

</pre><hr></hr><pre>
1667     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_ADDRESS") @Stable public int MARKID_CARD_TABLE_ADDRESS;
1668     @HotSpotVMConstant(name = "CodeInstaller::HEAP_TOP_ADDRESS") @Stable public int MARKID_HEAP_TOP_ADDRESS;
1669     @HotSpotVMConstant(name = "CodeInstaller::HEAP_END_ADDRESS") @Stable public int MARKID_HEAP_END_ADDRESS;
1670     @HotSpotVMConstant(name = "CodeInstaller::NARROW_KLASS_BASE_ADDRESS") @Stable public int MARKID_NARROW_KLASS_BASE_ADDRESS;
1671     @HotSpotVMConstant(name = "CodeInstaller::CRC_TABLE_ADDRESS") @Stable public int MARKID_CRC_TABLE_ADDRESS;
1672     @HotSpotVMConstant(name = "CodeInstaller::INVOKE_INVALID") @Stable public int MARKID_INVOKE_INVALID;
1673 
1674     @HotSpotVMConstant(name = "BitData::exception_seen_flag") @Stable public int bitDataExceptionSeenFlag;
1675     @HotSpotVMConstant(name = "BitData::null_seen_flag") @Stable public int bitDataNullSeenFlag;
1676     @HotSpotVMConstant(name = "CounterData::count_off") @Stable public int methodDataCountOffset;
1677     @HotSpotVMConstant(name = "JumpData::taken_off_set") @Stable public int jumpDataTakenOffset;
1678     @HotSpotVMConstant(name = "JumpData::displacement_off_set") @Stable public int jumpDataDisplacementOffset;
1679     @HotSpotVMConstant(name = "ReceiverTypeData::nonprofiled_count_off_set") @Stable public int receiverTypeDataNonprofiledCountOffset;
1680     @HotSpotVMConstant(name = "ReceiverTypeData::receiver_type_row_cell_count") @Stable public int receiverTypeDataReceiverTypeRowCellCount;
1681     @HotSpotVMConstant(name = "ReceiverTypeData::receiver0_offset") @Stable public int receiverTypeDataReceiver0Offset;
1682     @HotSpotVMConstant(name = "ReceiverTypeData::count0_offset") @Stable public int receiverTypeDataCount0Offset;
1683     @HotSpotVMConstant(name = "BranchData::not_taken_off_set") @Stable public int branchDataNotTakenOffset;
1684     @HotSpotVMConstant(name = "ArrayData::array_len_off_set") @Stable public int arrayDataArrayLenOffset;
1685     @HotSpotVMConstant(name = "ArrayData::array_start_off_set") @Stable public int arrayDataArrayStartOffset;
1686     @HotSpotVMConstant(name = "MultiBranchData::per_case_cell_count") @Stable public int multiBranchDataPerCaseCellCount;
<span class="new">1687 </span>
1688     // Checkstyle: resume
1689 
1690     private boolean check() {
1691         for (Field f : getClass().getDeclaredFields()) {
1692             int modifiers = f.getModifiers();
1693             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
1694                 assert Modifier.isFinal(modifiers) || f.getAnnotation(Stable.class) != null : "field should either be final or @Stable: " + f;
1695             }
1696         }
1697 
1698         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
1699         assert (layoutHelperArrayTagObjectValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "object array must have first bit set";
1700         assert (layoutHelperArrayTagTypeValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "type array must have first bit set";
1701 
1702         return true;
1703     }
1704 
1705     /**
1706      * A compact representation of the different encoding strategies for Objects and metadata.
1707      */

</pre><hr></hr>
</pre></td>
</tr></table>
</body></html>
