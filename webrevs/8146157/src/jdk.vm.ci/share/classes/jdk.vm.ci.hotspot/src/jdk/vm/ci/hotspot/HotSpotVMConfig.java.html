<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfig.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.UnsafeUtil.readCString;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  27 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  28 
  29 import java.lang.reflect.Field;
  30 import java.lang.reflect.Modifier;
  31 import java.util.HashMap;
  32 import java.util.Iterator;
  33 
  34 import jdk.vm.ci.common.JVMCIError;
  35 import jdk.vm.ci.hotspotvmconfig.HotSpotVMAddress;
  36 import jdk.vm.ci.hotspotvmconfig.HotSpotVMConstant;
  37 import jdk.vm.ci.hotspotvmconfig.HotSpotVMData;
  38 import jdk.vm.ci.hotspotvmconfig.HotSpotVMField;
  39 import jdk.vm.ci.hotspotvmconfig.HotSpotVMFlag;
  40 import jdk.vm.ci.hotspotvmconfig.HotSpotVMType;
  41 import sun.misc.Unsafe;
  42 
  43 //JaCoCo Exclude
  44 
  45 /**
  46  * Used to access native configuration details.
  47  *
  48  * All non-static, public fields in this class are so that they can be compiled as constants.
  49  */
  50 public class HotSpotVMConfig {
  51 
  52     /**
  53      * Gets the configuration associated with the singleton {@link HotSpotJVMCIRuntime}.
  54      */
  55     public static HotSpotVMConfig config() {
  56         return runtime().getConfig();
  57     }
  58 
  59     /**
  60      * Maximum allowed size of allocated area for a frame.
  61      */
  62     public final int maxFrameSize = 16 * 1024;
  63 
  64     public HotSpotVMConfig(CompilerToVM compilerToVm) {
  65         // Get raw pointer to the array that contains all gHotSpotVM values.
  66         final long gHotSpotVMData = compilerToVm.initializeConfiguration(this);
  67         assert gHotSpotVMData != 0;
  68 
  69         // Make FindBugs happy.
  70         jvmciHotSpotVMStructs = 0;
  71         jvmciHotSpotVMTypes = 0;
  72         jvmciHotSpotVMIntConstants = 0;
  73         jvmciHotSpotVMLongConstants = 0;
  74         jvmciHotSpotVMAddresses = 0;
  75 
  76         // Initialize the gHotSpotVM fields.
  77         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
  78             if (f.isAnnotationPresent(HotSpotVMData.class)) {
  79                 HotSpotVMData annotation = f.getAnnotation(HotSpotVMData.class);
  80                 final int index = annotation.index();
  81                 final long value = UNSAFE.getAddress(gHotSpotVMData + Unsafe.ADDRESS_SIZE * index);
  82                 try {
  83                     f.setLong(this, value);
  84                 } catch (IllegalAccessException e) {
  85                     throw new JVMCIError("index " + index, e);
  86                 }
  87             }
  88         }
  89 
  90         // Quick sanity check.
  91         assert jvmciHotSpotVMStructs != 0;
  92         assert jvmciHotSpotVMTypes != 0;
  93         assert jvmciHotSpotVMIntConstants != 0;
  94         assert jvmciHotSpotVMLongConstants != 0;
  95         assert jvmciHotSpotVMAddresses != 0;
  96 
  97         initialize();
  98 
  99         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift, logMinObjAlignment());
 100         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift, logKlassAlignment);
 101 
 102         assert check();
 103         assert HotSpotVMConfigVerifier.check();
 104     }
 105 
 106     @Override
 107     public String toString() {
 108         return getClass().getSimpleName();
 109     }
 110 
 111     /**
 112      * Initialize fields by reading their values from vmStructs.
 113      */
 114     private void initialize() {
 115         // Fill the VM fields hash map.
 116         HashMap&lt;String, VMFields.Field&gt; vmFields = new HashMap&lt;&gt;();
 117         for (VMFields.Field e : new VMFields(jvmciHotSpotVMStructs)) {
 118             vmFields.put(e.getName(), e);
 119         }
 120 
 121         // Fill the VM types hash map.
 122         HashMap&lt;String, VMTypes.Type&gt; vmTypes = new HashMap&lt;&gt;();
 123         for (VMTypes.Type e : new VMTypes(jvmciHotSpotVMTypes)) {
 124             vmTypes.put(e.getTypeName(), e);
 125         }
 126 
 127         // Fill the VM constants hash map.
 128         HashMap&lt;String, AbstractConstant&gt; vmConstants = new HashMap&lt;&gt;();
 129         for (AbstractConstant e : new VMIntConstants(jvmciHotSpotVMIntConstants)) {
 130             vmConstants.put(e.getName(), e);
 131         }
 132         for (AbstractConstant e : new VMLongConstants(jvmciHotSpotVMLongConstants)) {
 133             vmConstants.put(e.getName(), e);
 134         }
 135 
 136         // Fill the VM addresses hash map.
 137         HashMap&lt;String, VMAddresses.Address&gt; vmAddresses = new HashMap&lt;&gt;();
 138         for (VMAddresses.Address e : new VMAddresses(jvmciHotSpotVMAddresses)) {
 139             vmAddresses.put(e.getName(), e);
 140         }
 141 
 142         // Fill the flags hash map.
 143         HashMap&lt;String, Flags.Flag&gt; flags = new HashMap&lt;&gt;();
 144         for (Flags.Flag e : new Flags(vmFields, vmTypes)) {
 145             flags.put(e.getName(), e);
 146         }
 147 
 148         String osName = getHostOSName();
 149         String osArch = getHostArchitectureName();
 150 
 151         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
 152             if (f.isAnnotationPresent(HotSpotVMField.class)) {
 153                 HotSpotVMField annotation = f.getAnnotation(HotSpotVMField.class);
 154                 String name = annotation.name();
 155                 String type = annotation.type();
 156                 VMFields.Field entry = vmFields.get(name);
 157                 if (entry == null) {
 158                     if (!isRequired(osArch, annotation.archs())) {
 159                         continue;
 160                     }
 161                     throw new JVMCIError(f.getName() + ": expected VM field not found: " + name);
 162                 }
 163 
 164                 // Make sure the native type is still the type we expect.
 165                 if (!type.isEmpty()) {
 166                     if (!type.equals(entry.getTypeString())) {
 167                         throw new JVMCIError(f.getName() + ": compiler expects type " + type + " but VM field " + name + " is of type " + entry.getTypeString());
 168                     }
 169                 }
 170 
 171                 switch (annotation.get()) {
 172                     case OFFSET:
 173                         setField(f, entry.getOffset());
 174                         break;
 175                     case ADDRESS:
 176                         setField(f, entry.getAddress());
 177                         break;
 178                     case VALUE:
 179                         setField(f, entry.getValue());
 180                         break;
 181                     default:
 182                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
 183                 }
 184             } else if (f.isAnnotationPresent(HotSpotVMType.class)) {
 185                 HotSpotVMType annotation = f.getAnnotation(HotSpotVMType.class);
 186                 String name = annotation.name();
 187                 VMTypes.Type entry = vmTypes.get(name);
 188                 if (entry == null) {
 189                     throw new JVMCIError(f.getName() + ": expected VM type not found: " + name);
 190                 }
 191 
 192                 switch (annotation.get()) {
 193                     case SIZE:
 194                         setField(f, entry.getSize());
 195                         break;
 196                     default:
 197                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
 198                 }
 199             } else if (f.isAnnotationPresent(HotSpotVMConstant.class)) {
 200                 HotSpotVMConstant annotation = f.getAnnotation(HotSpotVMConstant.class);
 201                 String name = annotation.name();
 202                 AbstractConstant entry = vmConstants.get(name);
 203                 if (entry == null) {
 204                     if (!isRequired(osArch, annotation.archs())) {
 205                         continue;
 206                     }
 207                     throw new JVMCIError(f.getName() + ": expected VM constant not found: " + name);
 208                 }
 209                 setField(f, entry.getValue());
 210             } else if (f.isAnnotationPresent(HotSpotVMAddress.class)) {
 211                 HotSpotVMAddress annotation = f.getAnnotation(HotSpotVMAddress.class);
 212                 String name = annotation.name();
 213                 VMAddresses.Address entry = vmAddresses.get(name);
 214                 if (entry == null) {
 215                     if (!isRequired(osName, annotation.os())) {
 216                         continue;
 217                     }
 218                     throw new JVMCIError(f.getName() + ": expected VM address not found: " + name);
 219                 }
 220                 setField(f, entry.getValue());
 221             } else if (f.isAnnotationPresent(HotSpotVMFlag.class)) {
 222                 HotSpotVMFlag annotation = f.getAnnotation(HotSpotVMFlag.class);
 223                 String name = annotation.name();
 224                 Flags.Flag entry = flags.get(name);
 225                 if (entry == null) {
 226                     if (annotation.optional() || !isRequired(osArch, annotation.archs())) {
 227                         continue;
 228                     }
 229                     throw new JVMCIError(f.getName() + ": expected VM flag not found: " + name);
 230 
 231                 }
 232                 setField(f, entry.getValue());
 233             }
 234         }
 235     }
 236 
 237     private final CompressEncoding oopEncoding;
 238     private final CompressEncoding klassEncoding;
 239 
 240     public CompressEncoding getOopEncoding() {
 241         return oopEncoding;
 242     }
 243 
 244     public CompressEncoding getKlassEncoding() {
 245         return klassEncoding;
 246     }
 247 
 248     private void setField(Field field, Object value) {
 249         try {
 250             Class&lt;?&gt; fieldType = field.getType();
 251             if (fieldType == boolean.class) {
 252                 if (value instanceof String) {
 253                     field.setBoolean(this, Boolean.valueOf((String) value));
 254                 } else if (value instanceof Boolean) {
 255                     field.setBoolean(this, (boolean) value);
 256                 } else if (value instanceof Long) {
 257                     field.setBoolean(this, ((long) value) != 0);
 258                 } else {
 259                     throw new JVMCIError(value.getClass().getSimpleName());
 260                 }
 261             } else if (fieldType == byte.class) {
 262                 if (value instanceof Long) {
 263                     field.setByte(this, (byte) (long) value);
 264                 } else {
 265                     throw new JVMCIError(value.getClass().getSimpleName());
 266                 }
 267             } else if (fieldType == int.class) {
 268                 if (value instanceof Integer) {
 269                     field.setInt(this, (int) value);
 270                 } else if (value instanceof Long) {
 271                     field.setInt(this, (int) (long) value);
 272                 } else {
 273                     throw new JVMCIError(value.getClass().getSimpleName());
 274                 }
 275             } else if (fieldType == long.class) {
 276                 field.setLong(this, (long) value);
 277             } else {
 278                 throw new JVMCIError(field.toString());
 279             }
 280         } catch (IllegalAccessException e) {
 281             throw new JVMCIError("%s: %s", field, e);
 282         }
 283     }
 284 
 285     /**
 286      * Gets the host operating system name.
 287      */
 288     private static String getHostOSName() {
 289         String osName = System.getProperty("os.name");
 290         switch (osName) {
 291             case "Linux":
 292                 osName = "linux";
 293                 break;
 294             case "SunOS":
 295                 osName = "solaris";
 296                 break;
 297             case "Mac OS X":
 298                 osName = "bsd";
 299                 break;
 300             default:
 301                 // Of course Windows is different...
 302                 if (osName.startsWith("Windows")) {
 303                     osName = "windows";
 304                 } else {
 305                     throw new JVMCIError("Unexpected OS name: " + osName);
 306                 }
 307         }
 308         return osName;
 309     }
 310 
 311     /**
 312      * Gets the host architecture name for the purpose of finding the corresponding
 313      * {@linkplain HotSpotJVMCIBackendFactory backend}.
 314      */
 315     public String getHostArchitectureName() {
 316         String arch = System.getProperty("os.arch");
 317         switch (arch) {
 318             case "x86_64":
 319                 arch = "amd64";
 320                 break;
 321             case "sparcv9":
 322                 arch = "sparc";
 323                 break;
 324         }
 325         return arch;
 326     }
 327 
 328     /**
 329      * Determines if the current specification is included in a given set of specifications.
 330      *
 331      * @param current
 332      * @param specification specifies a set of specifications, e.g. architectures or operating
 333      *            systems. A zero length value implies all.
 334      */
 335     private static boolean isRequired(String current, String[] specification) {
 336         if (specification.length == 0) {
 337             return true;
 338         }
 339         for (String arch : specification) {
 340             if (arch.equals(current)) {
 341                 return true;
 342             }
 343         }
 344         return false;
 345     }
 346 
 347     /**
 348      * VMStructEntry (see {@code vmStructs.hpp}).
 349      */
 350     @HotSpotVMData(index = 0) @Stable private long jvmciHotSpotVMStructs;
 351     @HotSpotVMData(index = 1) @Stable private long jvmciHotSpotVMStructEntryTypeNameOffset;
 352     @HotSpotVMData(index = 2) @Stable private long jvmciHotSpotVMStructEntryFieldNameOffset;
 353     @HotSpotVMData(index = 3) @Stable private long jvmciHotSpotVMStructEntryTypeStringOffset;
 354     @HotSpotVMData(index = 4) @Stable private long jvmciHotSpotVMStructEntryIsStaticOffset;
 355     @HotSpotVMData(index = 5) @Stable private long jvmciHotSpotVMStructEntryOffsetOffset;
 356     @HotSpotVMData(index = 6) @Stable private long jvmciHotSpotVMStructEntryAddressOffset;
 357     @HotSpotVMData(index = 7) @Stable private long jvmciHotSpotVMStructEntryArrayStride;
 358 
 359     final class VMFields implements Iterable&lt;VMFields.Field&gt; {
 360 
 361         private final long address;
 362 
 363         public VMFields(long address) {
 364             this.address = address;
 365         }
 366 
 367         public Iterator&lt;VMFields.Field&gt; iterator() {
 368             return new Iterator&lt;VMFields.Field&gt;() {
 369 
 370                 private int index = 0;
 371 
 372                 private Field current() {
 373                     return new Field(address + jvmciHotSpotVMStructEntryArrayStride * index);
 374                 }
 375 
 376                 /**
 377                  * The last entry is identified by a NULL fieldName.
 378                  */
 379                 public boolean hasNext() {
 380                     Field entry = current();
 381                     return entry.getFieldName() != null;
 382                 }
 383 
 384                 public Field next() {
 385                     Field entry = current();
 386                     index++;
 387                     return entry;
 388                 }
 389             };
 390         }
 391 
 392         final class Field {
 393 
 394             private final long entryAddress;
 395 
 396             Field(long address) {
 397                 this.entryAddress = address;
 398             }
 399 
 400             public String getTypeName() {
 401                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeNameOffset);
 402                 return readCString(UNSAFE, typeNameAddress);
 403             }
 404 
 405             public String getFieldName() {
 406                 long fieldNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryFieldNameOffset);
 407                 return readCString(UNSAFE, fieldNameAddress);
 408             }
 409 
 410             public String getTypeString() {
 411                 long typeStringAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeStringOffset);
 412                 return readCString(UNSAFE, typeStringAddress);
 413             }
 414 
 415             public boolean isStatic() {
 416                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMStructEntryIsStaticOffset) != 0;
 417             }
 418 
 419             public long getOffset() {
 420                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMStructEntryOffsetOffset);
 421             }
 422 
 423             public long getAddress() {
 424                 return UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryAddressOffset);
 425             }
 426 
 427             public String getName() {
 428                 String typeName = getTypeName();
 429                 String fieldName = getFieldName();
 430                 return typeName + "::" + fieldName;
 431             }
 432 
 433             public long getValue() {
 434                 String type = getTypeString();
 435                 switch (type) {
 436                     case "bool":
 437                         return UNSAFE.getByte(getAddress());
 438                     case "int":
 439                         return UNSAFE.getInt(getAddress());
 440                     case "uint64_t":
 441                         return UNSAFE.getLong(getAddress());
 442                     case "address":
 443                     case "intptr_t":
 444                     case "uintptr_t":
 445                     case "size_t":
 446                         return UNSAFE.getAddress(getAddress());
 447                     default:
 448                         // All foo* types are addresses.
 449                         if (type.endsWith("*")) {
 450                             return UNSAFE.getAddress(getAddress());
 451                         }
 452                         throw new JVMCIError(type);
 453                 }
 454             }
 455 
 456             @Override
 457             public String toString() {
 458                 return String.format("Field[typeName=%s, fieldName=%s, typeString=%s, isStatic=%b, offset=%d, address=0x%x]", getTypeName(), getFieldName(), getTypeString(), isStatic(), getOffset(),
 459                                 getAddress());
 460             }
 461         }
 462     }
 463 
 464     /**
 465      * VMTypeEntry (see vmStructs.hpp).
 466      */
 467     @HotSpotVMData(index = 8) @Stable private long jvmciHotSpotVMTypes;
 468     @HotSpotVMData(index = 9) @Stable private long jvmciHotSpotVMTypeEntryTypeNameOffset;
 469     @HotSpotVMData(index = 10) @Stable private long jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 470     @HotSpotVMData(index = 11) @Stable private long jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 471     @HotSpotVMData(index = 12) @Stable private long jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 472     @HotSpotVMData(index = 13) @Stable private long jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 473     @HotSpotVMData(index = 14) @Stable private long jvmciHotSpotVMTypeEntrySizeOffset;
 474     @HotSpotVMData(index = 15) @Stable private long jvmciHotSpotVMTypeEntryArrayStride;
 475 
 476     final class VMTypes implements Iterable&lt;VMTypes.Type&gt; {
 477 
 478         private final long address;
 479 
 480         public VMTypes(long address) {
 481             this.address = address;
 482         }
 483 
 484         public Iterator&lt;VMTypes.Type&gt; iterator() {
 485             return new Iterator&lt;VMTypes.Type&gt;() {
 486 
 487                 private int index = 0;
 488 
 489                 private Type current() {
 490                     return new Type(address + jvmciHotSpotVMTypeEntryArrayStride * index);
 491                 }
 492 
 493                 /**
 494                  * The last entry is identified by a NULL type name.
 495                  */
 496                 public boolean hasNext() {
 497                     Type entry = current();
 498                     return entry.getTypeName() != null;
 499                 }
 500 
 501                 public Type next() {
 502                     Type entry = current();
 503                     index++;
 504                     return entry;
 505                 }
 506             };
 507         }
 508 
 509         final class Type {
 510 
 511             private final long entryAddress;
 512 
 513             Type(long address) {
 514                 this.entryAddress = address;
 515             }
 516 
 517             public String getTypeName() {
 518                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntryTypeNameOffset);
 519                 return readCString(UNSAFE, typeNameAddress);
 520             }
 521 
 522             public String getSuperclassName() {
 523                 long superclassNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntrySuperclassNameOffset);
 524                 return readCString(UNSAFE, superclassNameAddress);
 525             }
 526 
 527             public boolean isOopType() {
 528                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsOopTypeOffset) != 0;
 529             }
 530 
 531             public boolean isIntegerType() {
 532                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsIntegerTypeOffset) != 0;
 533             }
 534 
 535             public boolean isUnsigned() {
 536                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsUnsignedOffset) != 0;
 537             }
 538 
 539             public long getSize() {
 540                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMTypeEntrySizeOffset);
 541             }
 542 
 543             @Override
 544             public String toString() {
 545                 return String.format("Type[typeName=%s, superclassName=%s, isOopType=%b, isIntegerType=%b, isUnsigned=%b, size=%d]", getTypeName(), getSuperclassName(), isOopType(), isIntegerType(),
 546                                 isUnsigned(), getSize());
 547             }
 548         }
 549     }
 550 
 551     public abstract class AbstractConstant {
 552 
 553         protected final long address;
 554         protected final long nameOffset;
 555         protected final long valueOffset;
 556 
 557         AbstractConstant(long address, long nameOffset, long valueOffset) {
 558             this.address = address;
 559             this.nameOffset = nameOffset;
 560             this.valueOffset = valueOffset;
 561         }
 562 
 563         public String getName() {
 564             long nameAddress = UNSAFE.getAddress(address + nameOffset);
 565             return readCString(UNSAFE, nameAddress);
 566         }
 567 
 568         public abstract long getValue();
 569     }
 570 
 571     /**
 572      * VMIntConstantEntry (see vmStructs.hpp).
 573      */
 574     @HotSpotVMData(index = 16) @Stable private long jvmciHotSpotVMIntConstants;
 575     @HotSpotVMData(index = 17) @Stable private long jvmciHotSpotVMIntConstantEntryNameOffset;
 576     @HotSpotVMData(index = 18) @Stable private long jvmciHotSpotVMIntConstantEntryValueOffset;
 577     @HotSpotVMData(index = 19) @Stable private long jvmciHotSpotVMIntConstantEntryArrayStride;
 578 
 579     final class VMIntConstants implements Iterable&lt;VMIntConstants.Constant&gt; {
 580 
 581         private final long address;
 582 
 583         public VMIntConstants(long address) {
 584             this.address = address;
 585         }
 586 
 587         public Iterator&lt;VMIntConstants.Constant&gt; iterator() {
 588             return new Iterator&lt;VMIntConstants.Constant&gt;() {
 589 
 590                 private int index = 0;
 591 
 592                 private Constant current() {
 593                     return new Constant(address + jvmciHotSpotVMIntConstantEntryArrayStride * index);
 594                 }
 595 
 596                 /**
 597                  * The last entry is identified by a NULL name.
 598                  */
 599                 public boolean hasNext() {
 600                     Constant entry = current();
 601                     return entry.getName() != null;
 602                 }
 603 
 604                 public Constant next() {
 605                     Constant entry = current();
 606                     index++;
 607                     return entry;
 608                 }
 609             };
 610         }
 611 
 612         final class Constant extends AbstractConstant {
 613 
 614             Constant(long address) {
 615                 super(address, jvmciHotSpotVMIntConstantEntryNameOffset, jvmciHotSpotVMIntConstantEntryValueOffset);
 616             }
 617 
 618             @Override
 619             public long getValue() {
 620                 return UNSAFE.getInt(address + valueOffset);
 621             }
 622 
 623             @Override
 624             public String toString() {
 625                 return String.format("IntConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 626             }
 627         }
 628     }
 629 
 630     /**
 631      * VMLongConstantEntry (see vmStructs.hpp).
 632      */
 633     @HotSpotVMData(index = 20) @Stable private long jvmciHotSpotVMLongConstants;
 634     @HotSpotVMData(index = 21) @Stable private long jvmciHotSpotVMLongConstantEntryNameOffset;
 635     @HotSpotVMData(index = 22) @Stable private long jvmciHotSpotVMLongConstantEntryValueOffset;
 636     @HotSpotVMData(index = 23) @Stable private long jvmciHotSpotVMLongConstantEntryArrayStride;
 637 
 638     final class VMLongConstants implements Iterable&lt;VMLongConstants.Constant&gt; {
 639 
 640         private final long address;
 641 
 642         public VMLongConstants(long address) {
 643             this.address = address;
 644         }
 645 
 646         public Iterator&lt;VMLongConstants.Constant&gt; iterator() {
 647             return new Iterator&lt;VMLongConstants.Constant&gt;() {
 648 
 649                 private int index = 0;
 650 
 651                 private Constant currentEntry() {
 652                     return new Constant(address + jvmciHotSpotVMLongConstantEntryArrayStride * index);
 653                 }
 654 
 655                 /**
 656                  * The last entry is identified by a NULL name.
 657                  */
 658                 public boolean hasNext() {
 659                     Constant entry = currentEntry();
 660                     return entry.getName() != null;
 661                 }
 662 
 663                 public Constant next() {
 664                     Constant entry = currentEntry();
 665                     index++;
 666                     return entry;
 667                 }
 668             };
 669         }
 670 
 671         final class Constant extends AbstractConstant {
 672 
 673             Constant(long address) {
 674                 super(address, jvmciHotSpotVMLongConstantEntryNameOffset, jvmciHotSpotVMLongConstantEntryValueOffset);
 675             }
 676 
 677             @Override
 678             public long getValue() {
 679                 return UNSAFE.getLong(address + valueOffset);
 680             }
 681 
 682             @Override
 683             public String toString() {
 684                 return String.format("LongConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 685             }
 686         }
 687     }
 688 
 689     /**
 690      * VMAddressEntry (see vmStructs.hpp).
 691      */
 692     @HotSpotVMData(index = 24) @Stable private long jvmciHotSpotVMAddresses;
 693     @HotSpotVMData(index = 25) @Stable private long jvmciHotSpotVMAddressEntryNameOffset;
 694     @HotSpotVMData(index = 26) @Stable private long jvmciHotSpotVMAddressEntryValueOffset;
 695     @HotSpotVMData(index = 27) @Stable private long jvmciHotSpotVMAddressEntryArrayStride;
 696 
 697     final class VMAddresses implements Iterable&lt;VMAddresses.Address&gt; {
 698 
 699         private final long address;
 700 
 701         public VMAddresses(long address) {
 702             this.address = address;
 703         }
 704 
 705         public Iterator&lt;VMAddresses.Address&gt; iterator() {
 706             return new Iterator&lt;VMAddresses.Address&gt;() {
 707 
 708                 private int index = 0;
 709 
 710                 private Address currentEntry() {
 711                     return new Address(address + jvmciHotSpotVMAddressEntryArrayStride * index);
 712                 }
 713 
 714                 /**
 715                  * The last entry is identified by a NULL name.
 716                  */
 717                 public boolean hasNext() {
 718                     Address entry = currentEntry();
 719                     return entry.getName() != null;
 720                 }
 721 
 722                 public Address next() {
 723                     Address entry = currentEntry();
 724                     index++;
 725                     return entry;
 726                 }
 727             };
 728         }
 729 
 730         final class Address extends AbstractConstant {
 731 
 732             Address(long address) {
 733                 super(address, jvmciHotSpotVMAddressEntryNameOffset, jvmciHotSpotVMAddressEntryValueOffset);
 734             }
 735 
 736             @Override
 737             public long getValue() {
 738                 return UNSAFE.getLong(address + valueOffset);
 739             }
 740 
 741             @Override
 742             public String toString() {
 743                 return String.format("Address[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 744             }
 745         }
 746     }
 747 
 748     final class Flags implements Iterable&lt;Flags.Flag&gt; {
 749 
 750         private final long address;
 751         private final long entrySize;
 752         private final long typeOffset;
 753         private final long nameOffset;
 754         private final long addrOffset;
 755 
 756         public Flags(HashMap&lt;String, VMFields.Field&gt; vmStructs, HashMap&lt;String, VMTypes.Type&gt; vmTypes) {
 757             address = vmStructs.get("Flag::flags").getValue();
 758             entrySize = vmTypes.get("Flag").getSize();
 759             typeOffset = vmStructs.get("Flag::_type").getOffset();
 760             nameOffset = vmStructs.get("Flag::_name").getOffset();
 761             addrOffset = vmStructs.get("Flag::_addr").getOffset();
 762 
 763             assert vmTypes.get("bool").getSize() == Byte.BYTES;
 764             assert vmTypes.get("intx").getSize() == Long.BYTES;
 765             assert vmTypes.get("uintx").getSize() == Long.BYTES;
 766         }
 767 
 768         public Iterator&lt;Flags.Flag&gt; iterator() {
 769             return new Iterator&lt;Flags.Flag&gt;() {
 770 
 771                 private int index = 0;
 772 
 773                 private Flag current() {
 774                     return new Flag(address + entrySize * index);
 775                 }
 776 
 777                 /**
 778                  * The last entry is identified by a NULL name.
 779                  */
 780                 public boolean hasNext() {
 781                     Flag entry = current();
 782                     return entry.getName() != null;
 783                 }
 784 
 785                 public Flag next() {
 786                     Flag entry = current();
 787                     index++;
 788                     return entry;
 789                 }
 790             };
 791         }
 792 
 793         final class Flag {
 794 
 795             private final long entryAddress;
 796 
 797             Flag(long address) {
 798                 this.entryAddress = address;
 799             }
 800 
 801             public String getType() {
 802                 long typeAddress = UNSAFE.getAddress(entryAddress + typeOffset);
 803                 return readCString(UNSAFE, typeAddress);
 804             }
 805 
 806             public String getName() {
 807                 long nameAddress = UNSAFE.getAddress(entryAddress + nameOffset);
 808                 return readCString(UNSAFE, nameAddress);
 809             }
 810 
 811             public long getAddr() {
 812                 return UNSAFE.getAddress(entryAddress + addrOffset);
 813             }
 814 
 815             public Object getValue() {
 816                 switch (getType()) {
 817                     case "bool":
 818                         return Boolean.valueOf(UNSAFE.getByte(getAddr()) != 0);
 819                     case "intx":
 820                     case "uintx":
 821                     case "uint64_t":
 822                         return Long.valueOf(UNSAFE.getLong(getAddr()));
 823                     case "double":
 824                         return Double.valueOf(UNSAFE.getDouble(getAddr()));
 825                     case "ccstr":
 826                     case "ccstrlist":
 827                         return readCString(UNSAFE, getAddr());
 828                     default:
 829                         throw new JVMCIError(getType());
 830                 }
 831             }
 832 
 833             @Override
 834             public String toString() {
 835                 return String.format("Flag[type=%s, name=%s, value=%s]", getType(), getName(), getValue());
 836             }
 837         }
 838     }
 839 
 840     @HotSpotVMConstant(name = "ASSERT") @Stable public boolean cAssertions;
 841     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
 842     public final boolean linuxOs = System.getProperty("os.name", "").startsWith("Linux");
 843 
 844     @HotSpotVMFlag(name = "CodeEntryAlignment") @Stable public int codeEntryAlignment;
 845     @HotSpotVMFlag(name = "VerifyOops") @Stable public boolean verifyOops;
 846     @HotSpotVMFlag(name = "CITime") @Stable public boolean ciTime;
 847     @HotSpotVMFlag(name = "CITimeEach") @Stable public boolean ciTimeEach;
 848     @HotSpotVMFlag(name = "CompileTheWorldStartAt", optional = true) @Stable public int compileTheWorldStartAt;
 849     @HotSpotVMFlag(name = "CompileTheWorldStopAt", optional = true) @Stable public int compileTheWorldStopAt;
 850     @HotSpotVMFlag(name = "DontCompileHugeMethods") @Stable public boolean dontCompileHugeMethods;
 851     @HotSpotVMFlag(name = "HugeMethodLimit") @Stable public int hugeMethodLimit;
 852     @HotSpotVMFlag(name = "PrintInlining") @Stable public boolean printInlining;
 853     @HotSpotVMFlag(name = "JVMCIUseFastLocking") @Stable public boolean useFastLocking;
 854     @HotSpotVMFlag(name = "ForceUnreachable") @Stable public boolean forceUnreachable;
 855     @HotSpotVMFlag(name = "CodeCacheSegmentSize") @Stable public int codeSegmentSize;
 856     @HotSpotVMFlag(name = "FoldStableValues") @Stable public boolean foldStableValues;
 857 
 858     @HotSpotVMFlag(name = "UseTLAB") @Stable public boolean useTLAB;
 859     @HotSpotVMFlag(name = "UseBiasedLocking") @Stable public boolean useBiasedLocking;
 860     @HotSpotVMFlag(name = "UsePopCountInstruction") @Stable public boolean usePopCountInstruction;
 861     @HotSpotVMFlag(name = "UseCountLeadingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountLeadingZerosInstruction;
 862     @HotSpotVMFlag(name = "UseCountTrailingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountTrailingZerosInstruction;
 863     @HotSpotVMFlag(name = "UseAESIntrinsics") @Stable public boolean useAESIntrinsics;
 864     @HotSpotVMFlag(name = "UseCRC32Intrinsics") @Stable public boolean useCRC32Intrinsics;
 865     @HotSpotVMFlag(name = "UseG1GC") @Stable public boolean useG1GC;
 866     @HotSpotVMFlag(name = "UseConcMarkSweepGC") @Stable public boolean useCMSGC;
 867 
 868     @HotSpotVMFlag(name = "AllocatePrefetchStyle") @Stable public int allocatePrefetchStyle;
 869     @HotSpotVMFlag(name = "AllocatePrefetchInstr") @Stable public int allocatePrefetchInstr;
 870     @HotSpotVMFlag(name = "AllocatePrefetchLines") @Stable public int allocatePrefetchLines;
 871     @HotSpotVMFlag(name = "AllocateInstancePrefetchLines") @Stable public int allocateInstancePrefetchLines;
 872     @HotSpotVMFlag(name = "AllocatePrefetchStepSize") @Stable public int allocatePrefetchStepSize;
 873     @HotSpotVMFlag(name = "AllocatePrefetchDistance") @Stable public int allocatePrefetchDistance;
 874 
 875     @HotSpotVMFlag(name = "FlightRecorder", optional = true) @Stable public boolean flightRecorder;
 876 
 877     @HotSpotVMField(name = "CompilerToVM::Data::Universe_collectedHeap", type = "CollectedHeap*", get = HotSpotVMField.Type.VALUE) @Stable private long universeCollectedHeap;
 878     @HotSpotVMField(name = "CollectedHeap::_total_collections", type = "unsigned int", get = HotSpotVMField.Type.OFFSET) @Stable private int collectedHeapTotalCollectionsOffset;
 879 
 880     public long gcTotalCollectionsAddress() {
 881         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
 882     }
 883 
 884     @HotSpotVMFlag(name = "ReduceInitialCardMarks") @Stable public boolean useDeferredInitBarriers;
 885 
 886     // Compressed Oops related values.
 887     @HotSpotVMFlag(name = "UseCompressedOops") @Stable public boolean useCompressedOops;
 888     @HotSpotVMFlag(name = "UseCompressedClassPointers") @Stable public boolean useCompressedClassPointers;
 889 
 890     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowOopBase;
 891     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowOopShift;
 892     @HotSpotVMFlag(name = "ObjectAlignmentInBytes") @Stable public int objectAlignment;
 893 
 894     public final int minObjAlignment() {
 895         return objectAlignment / heapWordSize;
 896     }
 897 
 898     public final int logMinObjAlignment() {
 899         return (int) (Math.log(objectAlignment) / Math.log(2));
 900     }
 901 
 902     @HotSpotVMType(name = "narrowKlass", get = HotSpotVMType.Type.SIZE) @Stable public int narrowKlassSize;
 903     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowKlassBase;
 904     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowKlassShift;
 905     @HotSpotVMConstant(name = "LogKlassAlignmentInBytes") @Stable public int logKlassAlignment;
 906 
 907     // CPU capabilities
 908     @HotSpotVMFlag(name = "UseSSE") @Stable public int useSSE;
 909     @HotSpotVMFlag(name = "UseAVX", archs = {"amd64"}) @Stable public int useAVX;
 910 
 911     @HotSpotVMField(name = "Abstract_VM_Version::_features", type = "uint64_t", get = HotSpotVMField.Type.VALUE) @Stable public long vmVersionFeatures;
 912 
 913     // AMD64 specific values
 914     @HotSpotVMConstant(name = "VM_Version::CPU_CX8", archs = {"amd64"}) @Stable public long amd64CX8;
 915     @HotSpotVMConstant(name = "VM_Version::CPU_CMOV", archs = {"amd64"}) @Stable public long amd64CMOV;
 916     @HotSpotVMConstant(name = "VM_Version::CPU_FXSR", archs = {"amd64"}) @Stable public long amd64FXSR;
 917     @HotSpotVMConstant(name = "VM_Version::CPU_HT", archs = {"amd64"}) @Stable public long amd64HT;
 918     @HotSpotVMConstant(name = "VM_Version::CPU_MMX", archs = {"amd64"}) @Stable public long amd64MMX;
 919     @HotSpotVMConstant(name = "VM_Version::CPU_3DNOW_PREFETCH", archs = {"amd64"}) @Stable public long amd643DNOWPREFETCH;
 920     @HotSpotVMConstant(name = "VM_Version::CPU_SSE", archs = {"amd64"}) @Stable public long amd64SSE;
 921     @HotSpotVMConstant(name = "VM_Version::CPU_SSE2", archs = {"amd64"}) @Stable public long amd64SSE2;
 922     @HotSpotVMConstant(name = "VM_Version::CPU_SSE3", archs = {"amd64"}) @Stable public long amd64SSE3;
 923     @HotSpotVMConstant(name = "VM_Version::CPU_SSSE3", archs = {"amd64"}) @Stable public long amd64SSSE3;
 924     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4A", archs = {"amd64"}) @Stable public long amd64SSE4A;
 925     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_1", archs = {"amd64"}) @Stable public long amd64SSE41;
 926     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_2", archs = {"amd64"}) @Stable public long amd64SSE42;
 927     @HotSpotVMConstant(name = "VM_Version::CPU_POPCNT", archs = {"amd64"}) @Stable public long amd64POPCNT;
 928     @HotSpotVMConstant(name = "VM_Version::CPU_LZCNT", archs = {"amd64"}) @Stable public long amd64LZCNT;
 929     @HotSpotVMConstant(name = "VM_Version::CPU_TSC", archs = {"amd64"}) @Stable public long amd64TSC;
 930     @HotSpotVMConstant(name = "VM_Version::CPU_TSCINV", archs = {"amd64"}) @Stable public long amd64TSCINV;
 931     @HotSpotVMConstant(name = "VM_Version::CPU_AVX", archs = {"amd64"}) @Stable public long amd64AVX;
 932     @HotSpotVMConstant(name = "VM_Version::CPU_AVX2", archs = {"amd64"}) @Stable public long amd64AVX2;
 933     @HotSpotVMConstant(name = "VM_Version::CPU_AES", archs = {"amd64"}) @Stable public long amd64AES;
 934     @HotSpotVMConstant(name = "VM_Version::CPU_ERMS", archs = {"amd64"}) @Stable public long amd64ERMS;
 935     @HotSpotVMConstant(name = "VM_Version::CPU_CLMUL", archs = {"amd64"}) @Stable public long amd64CLMUL;
 936     @HotSpotVMConstant(name = "VM_Version::CPU_BMI1", archs = {"amd64"}) @Stable public long amd64BMI1;
 937     @HotSpotVMConstant(name = "VM_Version::CPU_BMI2", archs = {"amd64"}) @Stable public long amd64BMI2;
 938     @HotSpotVMConstant(name = "VM_Version::CPU_RTM", archs = {"amd64"}) @Stable public long amd64RTM;
 939     @HotSpotVMConstant(name = "VM_Version::CPU_ADX", archs = {"amd64"}) @Stable public long amd64ADX;
 940     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512F", archs = {"amd64"}) @Stable public long amd64AVX512F;
 941     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512DQ", archs = {"amd64"}) @Stable public long amd64AVX512DQ;
 942     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512PF", archs = {"amd64"}) @Stable public long amd64AVX512PF;
 943     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512ER", archs = {"amd64"}) @Stable public long amd64AVX512ER;
 944     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512CD", archs = {"amd64"}) @Stable public long amd64AVX512CD;
 945     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512BW", archs = {"amd64"}) @Stable public long amd64AVX512BW;
 946     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512VL", archs = {"amd64"}) @Stable public long amd64AVX512VL;
 947 
 948     // SPARC specific values
 949     @HotSpotVMConstant(name = "VM_Version::vis3_instructions_m", archs = {"sparc"}) @Stable public int sparcVis3Instructions;
 950     @HotSpotVMConstant(name = "VM_Version::vis2_instructions_m", archs = {"sparc"}) @Stable public int sparcVis2Instructions;
 951     @HotSpotVMConstant(name = "VM_Version::vis1_instructions_m", archs = {"sparc"}) @Stable public int sparcVis1Instructions;
 952     @HotSpotVMConstant(name = "VM_Version::cbcond_instructions_m", archs = {"sparc"}) @Stable public int sparcCbcondInstructions;
 953     @HotSpotVMConstant(name = "VM_Version::v8_instructions_m", archs = {"sparc"}) @Stable public int sparcV8Instructions;
 954     @HotSpotVMConstant(name = "VM_Version::hardware_mul32_m", archs = {"sparc"}) @Stable public int sparcHardwareMul32;
 955     @HotSpotVMConstant(name = "VM_Version::hardware_div32_m", archs = {"sparc"}) @Stable public int sparcHardwareDiv32;
 956     @HotSpotVMConstant(name = "VM_Version::hardware_fsmuld_m", archs = {"sparc"}) @Stable public int sparcHardwareFsmuld;
 957     @HotSpotVMConstant(name = "VM_Version::hardware_popc_m", archs = {"sparc"}) @Stable public int sparcHardwarePopc;
 958     @HotSpotVMConstant(name = "VM_Version::v9_instructions_m", archs = {"sparc"}) @Stable public int sparcV9Instructions;
 959     @HotSpotVMConstant(name = "VM_Version::sun4v_m", archs = {"sparc"}) @Stable public int sparcSun4v;
 960     @HotSpotVMConstant(name = "VM_Version::blk_init_instructions_m", archs = {"sparc"}) @Stable public int sparcBlkInitInstructions;
 961     @HotSpotVMConstant(name = "VM_Version::fmaf_instructions_m", archs = {"sparc"}) @Stable public int sparcFmafInstructions;
 962     @HotSpotVMConstant(name = "VM_Version::fmau_instructions_m", archs = {"sparc"}) @Stable public int sparcFmauInstructions;
 963     @HotSpotVMConstant(name = "VM_Version::sparc64_family_m", archs = {"sparc"}) @Stable public int sparcSparc64Family;
 964     @HotSpotVMConstant(name = "VM_Version::M_family_m", archs = {"sparc"}) @Stable public int sparcMFamily;
 965     @HotSpotVMConstant(name = "VM_Version::T_family_m", archs = {"sparc"}) @Stable public int sparcTFamily;
 966     @HotSpotVMConstant(name = "VM_Version::T1_model_m", archs = {"sparc"}) @Stable public int sparcT1Model;
 967     @HotSpotVMConstant(name = "VM_Version::sparc5_instructions_m", archs = {"sparc"}) @Stable public int sparcSparc5Instructions;
 968     @HotSpotVMConstant(name = "VM_Version::aes_instructions_m", archs = {"sparc"}) @Stable public int sparcAesInstructions;
 969     @HotSpotVMConstant(name = "VM_Version::sha1_instruction_m", archs = {"sparc"}) @Stable public int sparcSha1Instruction;
 970     @HotSpotVMConstant(name = "VM_Version::sha256_instruction_m", archs = {"sparc"}) @Stable public int sparcSha256Instruction;
 971     @HotSpotVMConstant(name = "VM_Version::sha512_instruction_m", archs = {"sparc"}) @Stable public int sparcSha512Instruction;
 972 
 973     @HotSpotVMFlag(name = "UseBlockZeroing", archs = {"sparc"}) @Stable public boolean useBlockZeroing;
 974     @HotSpotVMFlag(name = "BlockZeroingLowLimit", archs = {"sparc"}) @Stable public int blockZeroingLowLimit;
 975 
 976     // offsets, ...
 977     @HotSpotVMFlag(name = "StackShadowPages") @Stable public int stackShadowPages;
 978     @HotSpotVMFlag(name = "UseStackBanging") @Stable public boolean useStackBanging;
 979     @HotSpotVMConstant(name = "STACK_BIAS") @Stable public int stackBias;
 980 
 981     @HotSpotVMField(name = "oopDesc::_mark", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int markOffset;
 982     @HotSpotVMField(name = "oopDesc::_metadata._klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int hubOffset;
 983 
 984     @HotSpotVMField(name = "Klass::_prototype_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int prototypeMarkWordOffset;
 985     @HotSpotVMField(name = "Klass::_subklass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int subklassOffset;
 986     @HotSpotVMField(name = "Klass::_next_sibling", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int nextSiblingOffset;
 987     @HotSpotVMField(name = "Klass::_super_check_offset", type = "juint", get = HotSpotVMField.Type.OFFSET) @Stable public int superCheckOffsetOffset;
 988     @HotSpotVMField(name = "Klass::_secondary_super_cache", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySuperCacheOffset;
 989     @HotSpotVMField(name = "Klass::_secondary_supers", type = "Array&lt;Klass*&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySupersOffset;
 990 
 991     /**
 992      * The offset of the _java_mirror field (of type {@link Class}) in a Klass.
 993      */
 994     @HotSpotVMField(name = "Klass::_java_mirror", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int classMirrorOffset;
 995 
 996     @HotSpotVMField(name = "Klass::_super", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int klassSuperKlassOffset;
 997     @HotSpotVMField(name = "Klass::_modifier_flags", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassModifierFlagsOffset;
 998     @HotSpotVMField(name = "Klass::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int klassAccessFlagsOffset;
 999     @HotSpotVMField(name = "Klass::_layout_helper", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassLayoutHelperOffset;
1000 
1001     @HotSpotVMConstant(name = "Klass::_lh_neutral_value") @Stable public int klassLayoutHelperNeutralValue;
1002     @HotSpotVMConstant(name = "Klass::_lh_instance_slow_path_bit") @Stable public int klassLayoutHelperInstanceSlowPathBit;
1003     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_shift") @Stable public int layoutHelperLog2ElementSizeShift;
1004     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_mask") @Stable public int layoutHelperLog2ElementSizeMask;
1005     @HotSpotVMConstant(name = "Klass::_lh_element_type_shift") @Stable public int layoutHelperElementTypeShift;
1006     @HotSpotVMConstant(name = "Klass::_lh_element_type_mask") @Stable public int layoutHelperElementTypeMask;
1007     @HotSpotVMConstant(name = "Klass::_lh_header_size_shift") @Stable public int layoutHelperHeaderSizeShift;
1008     @HotSpotVMConstant(name = "Klass::_lh_header_size_mask") @Stable public int layoutHelperHeaderSizeMask;
1009     @HotSpotVMConstant(name = "Klass::_lh_array_tag_shift") @Stable public int layoutHelperArrayTagShift;
1010     @HotSpotVMConstant(name = "Klass::_lh_array_tag_type_value") @Stable public int layoutHelperArrayTagTypeValue;
1011     @HotSpotVMConstant(name = "Klass::_lh_array_tag_obj_value") @Stable public int layoutHelperArrayTagObjectValue;
1012 
1013     /**
1014      * This filters out the bit that differentiates a type array from an object array.
1015      */
1016     public int layoutHelperElementTypePrimitiveInPlace() {
1017         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
1018     }
1019 
1020     /**
1021      * Bit pattern in the klass layout helper that can be used to identify arrays.
1022      */
1023     public final int arrayKlassLayoutHelperIdentifier = 0x80000000;
1024 
1025     @HotSpotVMType(name = "vtableEntry", get = HotSpotVMType.Type.SIZE) @Stable public int vtableEntrySize;
1026     @HotSpotVMField(name = "vtableEntry::_method", type = "Method*", get = HotSpotVMField.Type.OFFSET) @Stable public int vtableEntryMethodOffset;
1027 
1028     @HotSpotVMType(name = "InstanceKlass", get = HotSpotVMType.Type.SIZE) @Stable public int instanceKlassSize;
1029     @HotSpotVMField(name = "InstanceKlass::_source_file_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassSourceFileNameIndexOffset;
1030     @HotSpotVMField(name = "InstanceKlass::_init_state", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassInitStateOffset;
1031     @HotSpotVMField(name = "InstanceKlass::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassConstantsOffset;
1032     @HotSpotVMField(name = "InstanceKlass::_fields", type = "Array&lt;u2&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassFieldsOffset;
1033     @HotSpotVMField(name = "CompilerToVM::Data::InstanceKlass_vtable_start_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int instanceKlassVtableStartOffset;
1034     @HotSpotVMField(name = "CompilerToVM::Data::InstanceKlass_vtable_length_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int instanceKlassVtableLengthOffset;
1035 
1036     @HotSpotVMConstant(name = "InstanceKlass::linked") @Stable public int instanceKlassStateLinked;
1037     @HotSpotVMConstant(name = "InstanceKlass::fully_initialized") @Stable public int instanceKlassStateFullyInitialized;
1038 
1039     /**
1040      * See {@code InstanceKlass::vtable_start_offset()}.
1041      */
1042     public final int instanceKlassVtableStartOffset() {
1043         return instanceKlassVtableStartOffset * heapWordSize;
1044     }
1045 
1046     @HotSpotVMType(name = "arrayOopDesc", get = HotSpotVMType.Type.SIZE) @Stable public int arrayOopDescSize;
1047 
1048     /**
1049      * The offset of the array length word in an array object's header.
1050      *
1051      * See {@code arrayOopDesc::length_offset_in_bytes()}.
1052      */
1053     public final int arrayOopDescLengthOffset() {
1054         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
1055     }
1056 
1057     @HotSpotVMField(name = "Array&lt;int&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1LengthOffset;
1058     @HotSpotVMField(name = "Array&lt;u1&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1DataOffset;
1059     @HotSpotVMField(name = "Array&lt;u2&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU2DataOffset;
1060     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayLengthOffset;
1061     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_data[0]", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayBaseOffset;
1062 
1063     @HotSpotVMField(name = "ObjArrayKlass::_element_klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayClassElementOffset;
1064 
1065     @HotSpotVMConstant(name = "FieldInfo::access_flags_offset") @Stable public int fieldInfoAccessFlagsOffset;
1066     @HotSpotVMConstant(name = "FieldInfo::name_index_offset") @Stable public int fieldInfoNameIndexOffset;
1067     @HotSpotVMConstant(name = "FieldInfo::signature_index_offset") @Stable public int fieldInfoSignatureIndexOffset;
1068     @HotSpotVMConstant(name = "FieldInfo::initval_index_offset") @Stable public int fieldInfoInitvalIndexOffset;
1069     @HotSpotVMConstant(name = "FieldInfo::low_packed_offset") @Stable public int fieldInfoLowPackedOffset;
1070     @HotSpotVMConstant(name = "FieldInfo::high_packed_offset") @Stable public int fieldInfoHighPackedOffset;
1071     @HotSpotVMConstant(name = "FieldInfo::field_slots") @Stable public int fieldInfoFieldSlots;
1072 
1073     @HotSpotVMConstant(name = "FIELDINFO_TAG_SIZE") @Stable public int fieldInfoTagSize;
1074 
1075     @HotSpotVMConstant(name = "JVM_ACC_MONITOR_MATCH") @Stable public int jvmAccMonitorMatch;
1076     @HotSpotVMConstant(name = "JVM_ACC_HAS_MONITOR_BYTECODES") @Stable public int jvmAccHasMonitorBytecodes;
1077     @HotSpotVMConstant(name = "JVM_ACC_HAS_FINALIZER") @Stable public int jvmAccHasFinalizer;
1078     @HotSpotVMConstant(name = "JVM_ACC_FIELD_INTERNAL") @Stable public int jvmAccFieldInternal;
1079     @HotSpotVMConstant(name = "JVM_ACC_FIELD_STABLE") @Stable public int jvmAccFieldStable;
1080     @HotSpotVMConstant(name = "JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE") @Stable public int jvmAccFieldHasGenericSignature;
1081     @HotSpotVMConstant(name = "JVM_ACC_WRITTEN_FLAGS") @Stable public int jvmAccWrittenFlags;
1082 
1083     // Modifier.SYNTHETIC is not public so we get it via vmStructs.
1084     @HotSpotVMConstant(name = "JVM_ACC_SYNTHETIC") @Stable public int jvmAccSynthetic;
1085 
1086     /**
1087      * @see HotSpotResolvedObjectTypeImpl#createField
1088      */
1089     @HotSpotVMConstant(name = "JVM_RECOGNIZED_FIELD_MODIFIERS") @Stable public int recognizedFieldModifiers;
1090 
1091     @HotSpotVMField(name = "Thread::_tlab", type = "ThreadLocalAllocBuffer", get = HotSpotVMField.Type.OFFSET) @Stable public int threadTlabOffset;
1092 
1093     @HotSpotVMField(name = "JavaThread::_anchor", type = "JavaFrameAnchor", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadAnchorOffset;
1094     @HotSpotVMField(name = "JavaThread::_threadObj", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectOffset;
1095     @HotSpotVMField(name = "JavaThread::_osthread", type = "OSThread*", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadOffset;
1096     @HotSpotVMField(name = "JavaThread::_dirty_card_queue", type = "DirtyCardQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadDirtyCardQueueOffset;
1097     @HotSpotVMField(name = "JavaThread::_is_method_handle_return", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int threadIsMethodHandleReturnOffset;
1098     @HotSpotVMField(name = "JavaThread::_satb_mark_queue", type = "SATBMarkQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadSatbMarkQueueOffset;
1099     @HotSpotVMField(name = "JavaThread::_vm_result", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectResultOffset;
1100     @HotSpotVMField(name = "JavaThread::_jvmci_counters", type = "jlong*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciCountersThreadOffset;
1101 
1102     /**
1103      * An invalid value for {@link #rtldDefault}.
1104      */
1105     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
1106 
1107     /**
1108      * Address of the library lookup routine. The C signature of this routine is:
1109      *
1110      * &lt;pre&gt;
1111      *     void* (const char *filename, char *ebuf, int ebuflen)
1112      * &lt;/pre&gt;
1113      */
1114     @HotSpotVMAddress(name = "os::dll_load") @Stable public long dllLoad;
1115 
1116     /**
1117      * Address of the library lookup routine. The C signature of this routine is:
1118      *
1119      * &lt;pre&gt;
1120      *     void* (void* handle, const char* name)
1121      * &lt;/pre&gt;
1122      */
1123     @HotSpotVMAddress(name = "os::dll_lookup") @Stable public long dllLookup;
1124 
1125     /**
1126      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
1127      * return the first occurrence of the desired symbol using the default library search order. If
1128      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
1129      * the current platform.
1130      */
1131     @HotSpotVMAddress(name = "RTLD_DEFAULT", os = {"bsd", "linux"}) @Stable public long rtldDefault = INVALID_RTLD_DEFAULT_HANDLE;
1132 
1133     /**
1134      * This field is used to pass exception objects into and out of the runtime system during
1135      * exception handling for compiled code.
1136      */
1137     @HotSpotVMField(name = "JavaThread::_exception_oop", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionOopOffset;
1138     @HotSpotVMField(name = "JavaThread::_exception_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionPcOffset;
1139     @HotSpotVMField(name = "ThreadShadow::_pending_exception", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingExceptionOffset;
1140 
1141     @HotSpotVMField(name = "JavaThread::_pending_deoptimization", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingDeoptimizationOffset;
1142     @HotSpotVMField(name = "JavaThread::_pending_failed_speculation", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingFailedSpeculationOffset;
1143     @HotSpotVMField(name = "JavaThread::_pending_transfer_to_interpreter", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingTransferToInterpreterOffset;
1144 
1145     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_sp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaSpOffset;
1146     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaPcOffset;
1147     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_fp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET, archs = {"amd64"}) @Stable private int javaFrameAnchorLastJavaFpOffset;
1148     @HotSpotVMField(name = "JavaFrameAnchor::_flags", type = "int", get = HotSpotVMField.Type.OFFSET, archs = {"sparc"}) @Stable private int javaFrameAnchorFlagsOffset;
1149 
1150     public int threadLastJavaSpOffset() {
1151         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
1152     }
1153 
1154     public int threadLastJavaPcOffset() {
1155         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
1156     }
1157 
1158     /**
1159      * This value is only valid on AMD64.
1160      */
1161     public int threadLastJavaFpOffset() {
1162         // TODO add an assert for AMD64
1163         return javaThreadAnchorOffset + javaFrameAnchorLastJavaFpOffset;
1164     }
1165 
1166     /**
1167      * This value is only valid on SPARC.
1168      */
1169     public int threadJavaFrameAnchorFlagsOffset() {
1170         // TODO add an assert for SPARC
1171         return javaThreadAnchorOffset + javaFrameAnchorFlagsOffset;
1172     }
1173 
1174     // These are only valid on AMD64.
1175     @HotSpotVMConstant(name = "frame::arg_reg_save_area_bytes", archs = {"amd64"}) @Stable public int runtimeCallStackSize;
1176     @HotSpotVMConstant(name = "frame::interpreter_frame_sender_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameSenderSpOffset;
1177     @HotSpotVMConstant(name = "frame::interpreter_frame_last_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameLastSpOffset;
1178 
1179     @HotSpotVMConstant(name = "dirtyCardQueueBufferOffset") @Stable private int dirtyCardQueueBufferOffset;
1180     @HotSpotVMConstant(name = "dirtyCardQueueIndexOffset") @Stable private int dirtyCardQueueIndexOffset;
1181 
1182     @HotSpotVMConstant(name = "satbMarkQueueBufferOffset") @Stable private int satbMarkQueueBufferOffset;
1183     @HotSpotVMConstant(name = "satbMarkQueueIndexOffset") @Stable private int satbMarkQueueIndexOffset;
1184     @HotSpotVMConstant(name = "satbMarkQueueActiveOffset") @Stable private int satbMarkQueueActiveOffset;
1185 
1186     @HotSpotVMField(name = "OSThread::_interrupted", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadInterruptedOffset;
1187 
1188     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public long markOopDescHashShift;
1189 
1190     @HotSpotVMConstant(name = "markOopDesc::biased_lock_mask_in_place") @Stable public int biasedLockMaskInPlace;
1191     @HotSpotVMConstant(name = "markOopDesc::age_mask_in_place") @Stable public int ageMaskInPlace;
1192     @HotSpotVMConstant(name = "markOopDesc::epoch_mask_in_place") @Stable public int epochMaskInPlace;
1193     @HotSpotVMConstant(name = "markOopDesc::hash_mask") @Stable public long markOopDescHashMask;
1194     @HotSpotVMConstant(name = "markOopDesc::hash_mask_in_place") @Stable public long markOopDescHashMaskInPlace;
1195 
1196     @HotSpotVMConstant(name = "markOopDesc::unlocked_value") @Stable public int unlockedMask;
1197     @HotSpotVMConstant(name = "markOopDesc::biased_lock_pattern") @Stable public int biasedLockPattern;
1198 
1199     @HotSpotVMConstant(name = "markOopDesc::no_hash_in_place") @Stable public int markWordNoHashInPlace;
1200     @HotSpotVMConstant(name = "markOopDesc::no_lock_in_place") @Stable public int markWordNoLockInPlace;
1201 
1202     /**
1203      * See {@code markOopDesc::prototype()}.
1204      */
1205     public long arrayPrototypeMarkWord() {
1206         return markWordNoHashInPlace | markWordNoLockInPlace;
1207     }
1208 
1209     /**
1210      * See {@code markOopDesc::copy_set_hash()}.
1211      */
1212     public long tlabIntArrayMarkWord() {
1213         long tmp = arrayPrototypeMarkWord() &amp; (~markOopDescHashMaskInPlace);
1214         tmp |= ((0x2 &amp; markOopDescHashMask) &lt;&lt; markOopDescHashShift);
1215         return tmp;
1216     }
1217 
1218     /**
1219      * Mark word right shift to get identity hash code.
1220      */
1221     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public int identityHashCodeShift;
1222 
1223     /**
1224      * Identity hash code value when uninitialized.
1225      */
1226     @HotSpotVMConstant(name = "markOopDesc::no_hash") @Stable public int uninitializedIdentityHashCodeValue;
1227 
1228     @HotSpotVMField(name = "Method::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int methodAccessFlagsOffset;
1229     @HotSpotVMField(name = "Method::_constMethod", type = "ConstMethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodConstMethodOffset;
1230     @HotSpotVMField(name = "Method::_intrinsic_id", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodIntrinsicIdOffset;
1231     @HotSpotVMField(name = "Method::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodFlagsOffset;
1232     @HotSpotVMField(name = "Method::_vtable_index", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodVtableIndexOffset;
1233 
1234     @HotSpotVMField(name = "Method::_method_counters", type = "MethodCounters*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCountersOffset;
1235     @HotSpotVMField(name = "Method::_method_data", type = "MethodData*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOffset;
1236     @HotSpotVMField(name = "Method::_from_compiled_entry", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCompiledEntryOffset;
1237     @HotSpotVMField(name = "Method::_code", type = "nmethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCodeOffset;
1238 
1239     @HotSpotVMConstant(name = "Method::_jfr_towrite") @Stable public int methodFlagsJfrTowrite;
1240     @HotSpotVMConstant(name = "Method::_caller_sensitive") @Stable public int methodFlagsCallerSensitive;
1241     @HotSpotVMConstant(name = "Method::_force_inline") @Stable public int methodFlagsForceInline;
1242     @HotSpotVMConstant(name = "Method::_dont_inline") @Stable public int methodFlagsDontInline;
1243     @HotSpotVMConstant(name = "Method::_hidden") @Stable public int methodFlagsHidden;
1244     @HotSpotVMConstant(name = "Method::nonvirtual_vtable_index") @Stable public int nonvirtualVtableIndex;
1245     @HotSpotVMConstant(name = "Method::invalid_vtable_index") @Stable public int invalidVtableIndex;
1246 
1247     @HotSpotVMField(name = "MethodCounters::_invocation_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int invocationCounterOffset;
1248     @HotSpotVMField(name = "MethodCounters::_backedge_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int backedgeCounterOffset;
1249     @HotSpotVMConstant(name = "InvocationCounter::count_increment") @Stable public int invocationCounterIncrement;
1250     @HotSpotVMConstant(name = "InvocationCounter::count_shift") @Stable public int invocationCounterShift;
1251 
1252     @HotSpotVMField(name = "MethodData::_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataSize;
1253     @HotSpotVMField(name = "MethodData::_data_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataDataSize;
1254     @HotSpotVMField(name = "MethodData::_data[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopDataOffset;
1255     @HotSpotVMField(name = "MethodData::_trap_hist._array[0]", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopTrapHistoryOffset;
1256     @HotSpotVMField(name = "MethodData::_jvmci_ir_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataIRSizeOffset;
1257 
1258     @HotSpotVMField(name = "nmethod::_verified_entry_point", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodEntryOffset;
1259     @HotSpotVMField(name = "nmethod::_comp_level", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodCompLevelOffset;
1260 
1261     @HotSpotVMConstant(name = "CompLevel_full_optimization") @Stable public int compilationLevelFullOptimization;
1262 
1263     @HotSpotVMConstant(name = "InvocationEntryBci") @Stable public int invocationEntryBci;
1264 
1265     @HotSpotVMField(name = "JVMCIEnv::_task", type = "CompileTask*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvTaskOffset;
1266     @HotSpotVMField(name = "JVMCIEnv::_jvmti_can_hotswap_or_post_breakpoint", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvJvmtiCanHotswapOrPostBreakpointOffset;
1267     @HotSpotVMField(name = "CompileTask::_num_inlined_bytecodes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int compileTaskNumInlinedBytecodesOffset;
1268 
1269     @HotSpotVMField(name = "CompilerToVM::Data::Method_extra_stack_entries", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int extraStackEntries;
1270 
1271     @HotSpotVMField(name = "ConstMethod::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodConstantsOffset;
1272     @HotSpotVMField(name = "ConstMethod::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodFlagsOffset;
1273     @HotSpotVMField(name = "ConstMethod::_code_size", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodCodeSizeOffset;
1274     @HotSpotVMField(name = "ConstMethod::_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodNameIndexOffset;
1275     @HotSpotVMField(name = "ConstMethod::_signature_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodSignatureIndexOffset;
1276     @HotSpotVMField(name = "ConstMethod::_max_stack", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodMaxStackOffset;
1277     @HotSpotVMField(name = "ConstMethod::_max_locals", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodMaxLocalsOffset;
1278 
1279     @HotSpotVMConstant(name = "ConstMethod::_has_linenumber_table") @Stable public int constMethodHasLineNumberTable;
1280     @HotSpotVMConstant(name = "ConstMethod::_has_localvariable_table") @Stable public int constMethodHasLocalVariableTable;
1281     @HotSpotVMConstant(name = "ConstMethod::_has_exception_table") @Stable public int constMethodHasExceptionTable;
1282 
1283     @HotSpotVMType(name = "ExceptionTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int exceptionTableElementSize;
1284     @HotSpotVMField(name = "ExceptionTableElement::start_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementStartPcOffset;
1285     @HotSpotVMField(name = "ExceptionTableElement::end_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementEndPcOffset;
1286     @HotSpotVMField(name = "ExceptionTableElement::handler_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementHandlerPcOffset;
1287     @HotSpotVMField(name = "ExceptionTableElement::catch_type_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementCatchTypeIndexOffset;
1288 
1289     @HotSpotVMType(name = "LocalVariableTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int localVariableTableElementSize;
1290     @HotSpotVMField(name = "LocalVariableTableElement::start_bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementStartBciOffset;
1291     @HotSpotVMField(name = "LocalVariableTableElement::length", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementLengthOffset;
1292     @HotSpotVMField(name = "LocalVariableTableElement::name_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementNameCpIndexOffset;
1293     @HotSpotVMField(name = "LocalVariableTableElement::descriptor_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementDescriptorCpIndexOffset;
1294     @HotSpotVMField(name = "LocalVariableTableElement::signature_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSignatureCpIndexOffset;
1295     @HotSpotVMField(name = "LocalVariableTableElement::slot", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSlotOffset;
1296 
1297     @HotSpotVMType(name = "ConstantPool", get = HotSpotVMType.Type.SIZE) @Stable public int constantPoolSize;
1298     @HotSpotVMField(name = "ConstantPool::_tags", type = "Array&lt;u1&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolTagsOffset;
1299     @HotSpotVMField(name = "ConstantPool::_pool_holder", type = "InstanceKlass*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolHolderOffset;
1300     @HotSpotVMField(name = "ConstantPool::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolLengthOffset;
1301 
1302     @HotSpotVMConstant(name = "ConstantPool::CPCACHE_INDEX_TAG") @Stable public int constantPoolCpCacheIndexTag;
1303 
1304     @HotSpotVMConstant(name = "JVM_CONSTANT_Utf8") @Stable public int jvmConstantUtf8;
1305     @HotSpotVMConstant(name = "JVM_CONSTANT_Integer") @Stable public int jvmConstantInteger;
1306     @HotSpotVMConstant(name = "JVM_CONSTANT_Long") @Stable public int jvmConstantLong;
1307     @HotSpotVMConstant(name = "JVM_CONSTANT_Float") @Stable public int jvmConstantFloat;
1308     @HotSpotVMConstant(name = "JVM_CONSTANT_Double") @Stable public int jvmConstantDouble;
1309     @HotSpotVMConstant(name = "JVM_CONSTANT_Class") @Stable public int jvmConstantClass;
1310     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClass") @Stable public int jvmConstantUnresolvedClass;
1311     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClassInError") @Stable public int jvmConstantUnresolvedClassInError;
1312     @HotSpotVMConstant(name = "JVM_CONSTANT_String") @Stable public int jvmConstantString;
1313     @HotSpotVMConstant(name = "JVM_CONSTANT_Fieldref") @Stable public int jvmConstantFieldref;
1314     @HotSpotVMConstant(name = "JVM_CONSTANT_Methodref") @Stable public int jvmConstantMethodref;
1315     @HotSpotVMConstant(name = "JVM_CONSTANT_InterfaceMethodref") @Stable public int jvmConstantInterfaceMethodref;
1316     @HotSpotVMConstant(name = "JVM_CONSTANT_NameAndType") @Stable public int jvmConstantNameAndType;
1317     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandle") @Stable public int jvmConstantMethodHandle;
1318     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandleInError") @Stable public int jvmConstantMethodHandleInError;
1319     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodType") @Stable public int jvmConstantMethodType;
1320     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodTypeInError") @Stable public int jvmConstantMethodTypeInError;
1321     @HotSpotVMConstant(name = "JVM_CONSTANT_InvokeDynamic") @Stable public int jvmConstantInvokeDynamic;
1322 
1323     @HotSpotVMConstant(name = "JVM_CONSTANT_ExternalMax") @Stable public int jvmConstantExternalMax;
1324     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMin") @Stable public int jvmConstantInternalMin;
1325     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMax") @Stable public int jvmConstantInternalMax;
1326 
1327     @HotSpotVMConstant(name = "HeapWordSize") @Stable public int heapWordSize;
1328 
1329     @HotSpotVMType(name = "Symbol*", get = HotSpotVMType.Type.SIZE) @Stable public int symbolPointerSize;
1330 
1331     @HotSpotVMField(name = "vmSymbols::_symbols[0]", type = "Symbol*", get = HotSpotVMField.Type.ADDRESS) @Stable public long vmSymbolsSymbols;
1332     @HotSpotVMConstant(name = "vmSymbols::FIRST_SID") @Stable public int vmSymbolsFirstSID;
1333     @HotSpotVMConstant(name = "vmSymbols::SID_LIMIT") @Stable public int vmSymbolsSIDLimit;
1334 
1335     /**
1336      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
1337      * are allowed to look like (respectively) the high or low bits of a real oop.
1338      */
1339     @HotSpotVMField(name = "CompilerToVM::Data::Universe_non_oop_bits", type = "void*", get = HotSpotVMField.Type.VALUE) @Stable public long nonOopBits;
1340 
1341     @HotSpotVMField(name = "StubRoutines::_verify_oop_count", type = "jint", get = HotSpotVMField.Type.ADDRESS) @Stable public long verifyOopCounterAddress;
1342     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_mask", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopMask;
1343     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_bits", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopBits;
1344     @HotSpotVMField(name = "CompilerToVM::Data::Universe_base_vtable_size", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int universeBaseVtableSize;
1345 
1346     public final int baseVtableLength() {
1347         return universeBaseVtableSize / vtableEntrySize;
1348     }
1349 
1350     @HotSpotVMField(name = "HeapRegion::LogOfHRGrainBytes", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int logOfHRGrainBytes;
1351 
1352     @HotSpotVMConstant(name = "CardTableModRefBS::dirty_card") @Stable public byte dirtyCardValue;
1353     @HotSpotVMConstant(name = "G1SATBCardTableModRefBS::g1_young_gen") @Stable public byte g1YoungCardValue;
1354 
1355     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_start_address", type = "jbyte*", get = HotSpotVMField.Type.VALUE) @Stable private long cardtableStartAddress;
1356     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable private int cardtableShift;
1357 
1358     public long cardtableStartAddress() {
1359         return cardtableStartAddress;
1360     }
1361 
1362     public int cardtableShift() {
1363         return cardtableShift;
1364     }
1365 
1366     @HotSpotVMField(name = "os::_polling_page", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long safepointPollingAddress;
1367 
1368     // G1 Collector Related Values.
1369 
1370     public int g1CardQueueIndexOffset() {
1371         return javaThreadDirtyCardQueueOffset + dirtyCardQueueIndexOffset;
1372     }
1373 
1374     public int g1CardQueueBufferOffset() {
1375         return javaThreadDirtyCardQueueOffset + dirtyCardQueueBufferOffset;
1376     }
1377 
1378     public int g1SATBQueueMarkingOffset() {
1379         return javaThreadSatbMarkQueueOffset + satbMarkQueueActiveOffset;
1380     }
1381 
1382     public int g1SATBQueueIndexOffset() {
1383         return javaThreadSatbMarkQueueOffset + satbMarkQueueIndexOffset;
1384     }
1385 
1386     public int g1SATBQueueBufferOffset() {
1387         return javaThreadSatbMarkQueueOffset + satbMarkQueueBufferOffset;
1388     }
1389 
1390     @HotSpotVMField(name = "java_lang_Class::_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassOffset;
1391     @HotSpotVMField(name = "java_lang_Class::_array_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int arrayKlassOffset;
1392 
1393     @HotSpotVMType(name = "BasicLock", get = HotSpotVMType.Type.SIZE) @Stable public int basicLockSize;
1394     @HotSpotVMField(name = "BasicLock::_displaced_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int basicLockDisplacedHeaderOffset;
1395 
1396     @HotSpotVMField(name = "Thread::_allocated_bytes", type = "jlong", get = HotSpotVMField.Type.OFFSET) @Stable public int threadAllocatedBytesOffset;
1397 
1398     @HotSpotVMFlag(name = "TLABWasteIncrement") @Stable public int tlabRefillWasteIncrement;
1399 
1400     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_start", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferStartOffset;
1401     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_end", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferEndOffset;
1402     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferTopOffset;
1403     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_pf_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferPfTopOffset;
1404     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_slow_allocations", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferSlowAllocationsOffset;
1405     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_fast_refill_waste", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferFastRefillWasteOffset;
1406     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_number_of_refills", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferNumberOfRefillsOffset;
1407     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_refill_waste_limit", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferRefillWasteLimitOffset;
1408     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_desired_size", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferDesiredSizeOffset;
1409 
1410     public int tlabSlowAllocationsOffset() {
1411         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
1412     }
1413 
1414     public int tlabFastRefillWasteOffset() {
1415         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
1416     }
1417 
1418     public int tlabNumberOfRefillsOffset() {
1419         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
1420     }
1421 
1422     public int tlabRefillWasteLimitOffset() {
1423         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
1424     }
1425 
1426     public int threadTlabSizeOffset() {
1427         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
1428     }
1429 
1430     public int threadTlabStartOffset() {
1431         return threadTlabOffset + threadLocalAllocBufferStartOffset;
1432     }
1433 
1434     public int threadTlabEndOffset() {
1435         return threadTlabOffset + threadLocalAllocBufferEndOffset;
1436     }
1437 
1438     public int threadTlabTopOffset() {
1439         return threadTlabOffset + threadLocalAllocBufferTopOffset;
1440     }
1441 
1442     public int threadTlabPfTopOffset() {
1443         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
1444     }
1445 
1446     @HotSpotVMField(name = "CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve", type = "size_t", get = HotSpotVMField.Type.VALUE) @Stable public int tlabAlignmentReserve;
1447 
1448     @HotSpotVMFlag(name = "TLABStats") @Stable public boolean tlabStats;
1449 
1450     // FIXME This is only temporary until the GC code is changed.
1451     @HotSpotVMField(name = "CompilerToVM::Data::_supports_inline_contig_alloc", type = "bool", get = HotSpotVMField.Type.VALUE) @Stable public boolean inlineContiguousAllocationSupported;
1452     @HotSpotVMField(name = "CompilerToVM::Data::_heap_end_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapEndAddress;
1453     @HotSpotVMField(name = "CompilerToVM::Data::_heap_top_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapTopAddress;
1454 
1455     /**
1456      * The DataLayout header size is the same as the cell size.
1457      */
1458     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutHeaderSize;
1459     @HotSpotVMField(name = "DataLayout::_header._struct._tag", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutTagOffset;
1460     @HotSpotVMField(name = "DataLayout::_header._struct._flags", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutFlagsOffset;
1461     @HotSpotVMField(name = "DataLayout::_header._struct._bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutBCIOffset;
1462     @HotSpotVMField(name = "DataLayout::_cells[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutCellsOffset;
1463     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutCellSize;
1464 
1465     @HotSpotVMConstant(name = "DataLayout::no_tag") @Stable public int dataLayoutNoTag;
1466     @HotSpotVMConstant(name = "DataLayout::bit_data_tag") @Stable public int dataLayoutBitDataTag;
1467     @HotSpotVMConstant(name = "DataLayout::counter_data_tag") @Stable public int dataLayoutCounterDataTag;
1468     @HotSpotVMConstant(name = "DataLayout::jump_data_tag") @Stable public int dataLayoutJumpDataTag;
1469     @HotSpotVMConstant(name = "DataLayout::receiver_type_data_tag") @Stable public int dataLayoutReceiverTypeDataTag;
1470     @HotSpotVMConstant(name = "DataLayout::virtual_call_data_tag") @Stable public int dataLayoutVirtualCallDataTag;
1471     @HotSpotVMConstant(name = "DataLayout::ret_data_tag") @Stable public int dataLayoutRetDataTag;
1472     @HotSpotVMConstant(name = "DataLayout::branch_data_tag") @Stable public int dataLayoutBranchDataTag;
1473     @HotSpotVMConstant(name = "DataLayout::multi_branch_data_tag") @Stable public int dataLayoutMultiBranchDataTag;
1474     @HotSpotVMConstant(name = "DataLayout::arg_info_data_tag") @Stable public int dataLayoutArgInfoDataTag;
1475     @HotSpotVMConstant(name = "DataLayout::call_type_data_tag") @Stable public int dataLayoutCallTypeDataTag;
1476     @HotSpotVMConstant(name = "DataLayout::virtual_call_type_data_tag") @Stable public int dataLayoutVirtualCallTypeDataTag;
1477     @HotSpotVMConstant(name = "DataLayout::parameters_type_data_tag") @Stable public int dataLayoutParametersTypeDataTag;
1478     @HotSpotVMConstant(name = "DataLayout::speculative_trap_data_tag") @Stable public int dataLayoutSpeculativeTrapDataTag;
1479 
1480     @HotSpotVMFlag(name = "BciProfileWidth") @Stable public int bciProfileWidth;
1481     @HotSpotVMFlag(name = "TypeProfileWidth") @Stable public int typeProfileWidth;
1482     @HotSpotVMFlag(name = "MethodProfileWidth") @Stable public int methodProfileWidth;
1483 
1484     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_ic_miss_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long inlineCacheMissStub;
1485     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleWrongMethodStub;
1486 
1487     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_unpack", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleDeoptStub;
1488     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long uncommonTrapStub;
1489 
1490     @HotSpotVMField(name = "CodeCache::_low_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheLowBound;
1491     @HotSpotVMField(name = "CodeCache::_high_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheHighBound;
1492 
1493     @HotSpotVMField(name = "StubRoutines::_aescrypt_encryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptEncryptBlockStub;
1494     @HotSpotVMField(name = "StubRoutines::_aescrypt_decryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptDecryptBlockStub;
1495     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_encryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingEncryptAESCryptStub;
1496     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_decryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingDecryptAESCryptStub;
1497     @HotSpotVMField(name = "StubRoutines::_updateBytesCRC32", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long updateBytesCRC32Stub;
1498     @HotSpotVMField(name = "StubRoutines::_crc_table_adr", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long crcTableAddress;
1499 
1500     @HotSpotVMField(name = "StubRoutines::_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteArraycopy;
1501     @HotSpotVMField(name = "StubRoutines::_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortArraycopy;
1502     @HotSpotVMField(name = "StubRoutines::_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintArraycopy;
1503     @HotSpotVMField(name = "StubRoutines::_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongArraycopy;
1504     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopy;
1505     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopyUninit;
1506     @HotSpotVMField(name = "StubRoutines::_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteDisjointArraycopy;
1507     @HotSpotVMField(name = "StubRoutines::_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortDisjointArraycopy;
1508     @HotSpotVMField(name = "StubRoutines::_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintDisjointArraycopy;
1509     @HotSpotVMField(name = "StubRoutines::_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongDisjointArraycopy;
1510     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopy;
1511     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopyUninit;
1512     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedArraycopy;
1513     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedArraycopy;
1514     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedArraycopy;
1515     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedArraycopy;
1516     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopy;
1517     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopyUninit;
1518     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedDisjointArraycopy;
1519     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedDisjointArraycopy;
1520     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedDisjointArraycopy;
1521     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedDisjointArraycopy;
1522     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopy;
1523     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopyUninit;
1524     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopy;
1525     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopyUninit;
1526     @HotSpotVMField(name = "StubRoutines::_unsafe_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long unsafeArraycopy;
1527     @HotSpotVMField(name = "StubRoutines::_generic_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long genericArraycopy;
1528 
1529     @HotSpotVMAddress(name = "JVMCIRuntime::new_instance") @Stable public long newInstanceAddress;
1530     @HotSpotVMAddress(name = "JVMCIRuntime::new_array") @Stable public long newArrayAddress;
1531     @HotSpotVMAddress(name = "JVMCIRuntime::new_multi_array") @Stable public long newMultiArrayAddress;
1532     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_array") @Stable public long dynamicNewArrayAddress;
1533     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_instance") @Stable public long dynamicNewInstanceAddress;
1534 
1535     @HotSpotVMAddress(name = "JVMCIRuntime::thread_is_interrupted") @Stable public long threadIsInterruptedAddress;
1536     @HotSpotVMAddress(name = "JVMCIRuntime::vm_message") @Stable public long vmMessageAddress;
1537     @HotSpotVMAddress(name = "JVMCIRuntime::identity_hash_code") @Stable public long identityHashCodeAddress;
1538     @HotSpotVMAddress(name = "JVMCIRuntime::exception_handler_for_pc") @Stable public long exceptionHandlerForPcAddress;
1539     @HotSpotVMAddress(name = "JVMCIRuntime::monitorenter") @Stable public long monitorenterAddress;
1540     @HotSpotVMAddress(name = "JVMCIRuntime::monitorexit") @Stable public long monitorexitAddress;
1541     @HotSpotVMAddress(name = "JVMCIRuntime::create_null_exception") @Stable public long createNullPointerExceptionAddress;
1542     @HotSpotVMAddress(name = "JVMCIRuntime::create_out_of_bounds_exception") @Stable public long createOutOfBoundsExceptionAddress;
1543     @HotSpotVMAddress(name = "JVMCIRuntime::log_primitive") @Stable public long logPrimitiveAddress;
1544     @HotSpotVMAddress(name = "JVMCIRuntime::log_object") @Stable public long logObjectAddress;
1545     @HotSpotVMAddress(name = "JVMCIRuntime::log_printf") @Stable public long logPrintfAddress;
1546     @HotSpotVMAddress(name = "JVMCIRuntime::vm_error") @Stable public long vmErrorAddress;
1547     @HotSpotVMAddress(name = "JVMCIRuntime::load_and_clear_exception") @Stable public long loadAndClearExceptionAddress;
1548     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_pre") @Stable public long writeBarrierPreAddress;
1549     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_post") @Stable public long writeBarrierPostAddress;
1550     @HotSpotVMAddress(name = "JVMCIRuntime::validate_object") @Stable public long validateObject;
1551 
1552     @HotSpotVMAddress(name = "JVMCIRuntime::test_deoptimize_call_int") @Stable public long testDeoptimizeCallInt;
1553 
1554     @HotSpotVMAddress(name = "SharedRuntime::register_finalizer") @Stable public long registerFinalizerAddress;
1555     @HotSpotVMAddress(name = "SharedRuntime::exception_handler_for_return_address") @Stable public long exceptionHandlerForReturnAddressAddress;
1556     @HotSpotVMAddress(name = "SharedRuntime::OSR_migration_end") @Stable public long osrMigrationEndAddress;
1557 
1558     @HotSpotVMAddress(name = "os::javaTimeMillis") @Stable public long javaTimeMillisAddress;
1559     @HotSpotVMAddress(name = "os::javaTimeNanos") @Stable public long javaTimeNanosAddress;
1560     @HotSpotVMAddress(name = "SharedRuntime::dsin") @Stable public long arithmeticSinAddress;
1561     @HotSpotVMAddress(name = "SharedRuntime::dcos") @Stable public long arithmeticCosAddress;
1562     @HotSpotVMAddress(name = "SharedRuntime::dtan") @Stable public long arithmeticTanAddress;
1563     @HotSpotVMAddress(name = "SharedRuntime::dexp") @Stable public long arithmeticExpAddress;
1564     @HotSpotVMAddress(name = "SharedRuntime::dlog") @Stable public long arithmeticLogAddress;
1565     @HotSpotVMAddress(name = "SharedRuntime::dlog10") @Stable public long arithmeticLog10Address;
1566     @HotSpotVMAddress(name = "SharedRuntime::dpow") @Stable public long arithmeticPowAddress;
1567 
1568     @HotSpotVMFlag(name = "JVMCICounterSize") @Stable public int jvmciCountersSize;
1569 
1570     @HotSpotVMAddress(name = "Deoptimization::fetch_unroll_info") @Stable public long deoptimizationFetchUnrollInfo;
1571     @HotSpotVMAddress(name = "Deoptimization::uncommon_trap") @Stable public long deoptimizationUncommonTrap;
1572     @HotSpotVMAddress(name = "Deoptimization::unpack_frames") @Stable public long deoptimizationUnpackFrames;
1573 
1574     @HotSpotVMConstant(name = "Deoptimization::Reason_none") @Stable public int deoptReasonNone;
1575     @HotSpotVMConstant(name = "Deoptimization::Reason_null_check") @Stable public int deoptReasonNullCheck;
1576     @HotSpotVMConstant(name = "Deoptimization::Reason_range_check") @Stable public int deoptReasonRangeCheck;
1577     @HotSpotVMConstant(name = "Deoptimization::Reason_class_check") @Stable public int deoptReasonClassCheck;
1578     @HotSpotVMConstant(name = "Deoptimization::Reason_array_check") @Stable public int deoptReasonArrayCheck;
1579     @HotSpotVMConstant(name = "Deoptimization::Reason_unreached0") @Stable public int deoptReasonUnreached0;
1580     @HotSpotVMConstant(name = "Deoptimization::Reason_type_checked_inlining") @Stable public int deoptReasonTypeCheckInlining;
1581     @HotSpotVMConstant(name = "Deoptimization::Reason_optimized_type_check") @Stable public int deoptReasonOptimizedTypeCheck;
1582     @HotSpotVMConstant(name = "Deoptimization::Reason_not_compiled_exception_handler") @Stable public int deoptReasonNotCompiledExceptionHandler;
1583     @HotSpotVMConstant(name = "Deoptimization::Reason_unresolved") @Stable public int deoptReasonUnresolved;
1584     @HotSpotVMConstant(name = "Deoptimization::Reason_jsr_mismatch") @Stable public int deoptReasonJsrMismatch;
1585     @HotSpotVMConstant(name = "Deoptimization::Reason_div0_check") @Stable public int deoptReasonDiv0Check;
1586     @HotSpotVMConstant(name = "Deoptimization::Reason_constraint") @Stable public int deoptReasonConstraint;
1587     @HotSpotVMConstant(name = "Deoptimization::Reason_loop_limit_check") @Stable public int deoptReasonLoopLimitCheck;
1588     @HotSpotVMConstant(name = "Deoptimization::Reason_aliasing") @Stable public int deoptReasonAliasing;
1589     @HotSpotVMConstant(name = "Deoptimization::Reason_transfer_to_interpreter") @Stable public int deoptReasonTransferToInterpreter;
1590     @HotSpotVMConstant(name = "Deoptimization::Reason_LIMIT") @Stable public int deoptReasonOSROffset;
1591 
1592     @HotSpotVMConstant(name = "Deoptimization::Action_none") @Stable public int deoptActionNone;
1593     @HotSpotVMConstant(name = "Deoptimization::Action_maybe_recompile") @Stable public int deoptActionMaybeRecompile;
1594     @HotSpotVMConstant(name = "Deoptimization::Action_reinterpret") @Stable public int deoptActionReinterpret;
1595     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_entrant") @Stable public int deoptActionMakeNotEntrant;
1596     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_compilable") @Stable public int deoptActionMakeNotCompilable;
1597 
1598     @HotSpotVMConstant(name = "Deoptimization::_action_bits") @Stable public int deoptimizationActionBits;
1599     @HotSpotVMConstant(name = "Deoptimization::_reason_bits") @Stable public int deoptimizationReasonBits;
1600     @HotSpotVMConstant(name = "Deoptimization::_debug_id_bits") @Stable public int deoptimizationDebugIdBits;
1601     @HotSpotVMConstant(name = "Deoptimization::_action_shift") @Stable public int deoptimizationActionShift;
1602     @HotSpotVMConstant(name = "Deoptimization::_reason_shift") @Stable public int deoptimizationReasonShift;
1603     @HotSpotVMConstant(name = "Deoptimization::_debug_id_shift") @Stable public int deoptimizationDebugIdShift;
1604 
1605     @HotSpotVMConstant(name = "Deoptimization::Unpack_deopt") @Stable public int deoptimizationUnpackDeopt;
1606     @HotSpotVMConstant(name = "Deoptimization::Unpack_exception") @Stable public int deoptimizationUnpackException;
1607     @HotSpotVMConstant(name = "Deoptimization::Unpack_uncommon_trap") @Stable public int deoptimizationUnpackUncommonTrap;
1608     @HotSpotVMConstant(name = "Deoptimization::Unpack_reexecute") @Stable public int deoptimizationUnpackReexecute;
1609 
1610     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_size_of_deoptimized_frame", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockSizeOfDeoptimizedFrameOffset;
1611     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_caller_adjustment", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockCallerAdjustmentOffset;
1612     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_number_of_frames", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockNumberOfFramesOffset;
1613     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_total_frame_sizes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockTotalFrameSizesOffset;
1614     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_unpack_kind", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockUnpackKindOffset;
1615     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_sizes", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFrameSizesOffset;
1616     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_pcs", type = "address*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFramePcsOffset;
1617     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_initial_info", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockInitialInfoOffset;
1618 
1619     @HotSpotVMConstant(name = "vmIntrinsics::_invokeBasic") @Stable public int vmIntrinsicInvokeBasic;
1620     @HotSpotVMConstant(name = "vmIntrinsics::_linkToVirtual") @Stable public int vmIntrinsicLinkToVirtual;
1621     @HotSpotVMConstant(name = "vmIntrinsics::_linkToStatic") @Stable public int vmIntrinsicLinkToStatic;
1622     @HotSpotVMConstant(name = "vmIntrinsics::_linkToSpecial") @Stable public int vmIntrinsicLinkToSpecial;
1623     @HotSpotVMConstant(name = "vmIntrinsics::_linkToInterface") @Stable public int vmIntrinsicLinkToInterface;
1624 
1625     @HotSpotVMConstant(name = "JVMCIEnv::ok") @Stable public int codeInstallResultOk;
1626     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_failed") @Stable public int codeInstallResultDependenciesFailed;
1627     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_invalid") @Stable public int codeInstallResultDependenciesInvalid;
1628     @HotSpotVMConstant(name = "JVMCIEnv::cache_full") @Stable public int codeInstallResultCacheFull;
1629     @HotSpotVMConstant(name = "JVMCIEnv::code_too_large") @Stable public int codeInstallResultCodeTooLarge;
1630 
1631     public String getCodeInstallResultDescription(int codeInstallResult) {
1632         if (codeInstallResult == codeInstallResultOk) {
1633             return "ok";
1634         }
1635         if (codeInstallResult == codeInstallResultDependenciesFailed) {
1636             return "dependencies failed";
1637         }
1638         if (codeInstallResult == codeInstallResultDependenciesInvalid) {
1639             return "dependencies invalid";
1640         }
1641         if (codeInstallResult == codeInstallResultCacheFull) {
1642             return "code cache is full";
1643         }
1644         if (codeInstallResult == codeInstallResultCodeTooLarge) {
1645             return "code is too large";
1646         }
1647         assert false : codeInstallResult;
1648         return "unknown";
1649     }
1650 
1651     // Checkstyle: stop
1652     @HotSpotVMConstant(name = "CodeInstaller::VERIFIED_ENTRY") @Stable public int MARKID_VERIFIED_ENTRY;
1653     @HotSpotVMConstant(name = "CodeInstaller::UNVERIFIED_ENTRY") @Stable public int MARKID_UNVERIFIED_ENTRY;
1654     @HotSpotVMConstant(name = "CodeInstaller::OSR_ENTRY") @Stable public int MARKID_OSR_ENTRY;
1655     @HotSpotVMConstant(name = "CodeInstaller::EXCEPTION_HANDLER_ENTRY") @Stable public int MARKID_EXCEPTION_HANDLER_ENTRY;
1656     @HotSpotVMConstant(name = "CodeInstaller::DEOPT_HANDLER_ENTRY") @Stable public int MARKID_DEOPT_HANDLER_ENTRY;
1657     @HotSpotVMConstant(name = "CodeInstaller::INVOKEINTERFACE") @Stable public int MARKID_INVOKEINTERFACE;
1658     @HotSpotVMConstant(name = "CodeInstaller::INVOKEVIRTUAL") @Stable public int MARKID_INVOKEVIRTUAL;
1659     @HotSpotVMConstant(name = "CodeInstaller::INVOKESTATIC") @Stable public int MARKID_INVOKESTATIC;
1660     @HotSpotVMConstant(name = "CodeInstaller::INVOKESPECIAL") @Stable public int MARKID_INVOKESPECIAL;
1661     @HotSpotVMConstant(name = "CodeInstaller::INLINE_INVOKE") @Stable public int MARKID_INLINE_INVOKE;
1662     @HotSpotVMConstant(name = "CodeInstaller::POLL_NEAR") @Stable public int MARKID_POLL_NEAR;
1663     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_NEAR") @Stable public int MARKID_POLL_RETURN_NEAR;
1664     @HotSpotVMConstant(name = "CodeInstaller::POLL_FAR") @Stable public int MARKID_POLL_FAR;
1665     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_FAR") @Stable public int MARKID_POLL_RETURN_FAR;
1666     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_SHIFT") @Stable public int MARKID_CARD_TABLE_SHIFT;
1667     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_ADDRESS") @Stable public int MARKID_CARD_TABLE_ADDRESS;
1668     @HotSpotVMConstant(name = "CodeInstaller::HEAP_TOP_ADDRESS") @Stable public int MARKID_HEAP_TOP_ADDRESS;
1669     @HotSpotVMConstant(name = "CodeInstaller::HEAP_END_ADDRESS") @Stable public int MARKID_HEAP_END_ADDRESS;
1670     @HotSpotVMConstant(name = "CodeInstaller::NARROW_KLASS_BASE_ADDRESS") @Stable public int MARKID_NARROW_KLASS_BASE_ADDRESS;
1671     @HotSpotVMConstant(name = "CodeInstaller::CRC_TABLE_ADDRESS") @Stable public int MARKID_CRC_TABLE_ADDRESS;
1672     @HotSpotVMConstant(name = "CodeInstaller::INVOKE_INVALID") @Stable public int MARKID_INVOKE_INVALID;
1673 
1674     @HotSpotVMConstant(name = "BitData::exception_seen_flag") @Stable public int bitDataExceptionSeenFlag;
1675     @HotSpotVMConstant(name = "BitData::null_seen_flag") @Stable public int bitDataNullSeenFlag;
1676     @HotSpotVMConstant(name = "CounterData::count_off") @Stable public int methodDataCountOffset;
1677     @HotSpotVMConstant(name = "JumpData::taken_off_set") @Stable public int jumpDataTakenOffset;
1678     @HotSpotVMConstant(name = "JumpData::displacement_off_set") @Stable public int jumpDataDisplacementOffset;
1679     @HotSpotVMConstant(name = "ReceiverTypeData::nonprofiled_count_off_set") @Stable public int receiverTypeDataNonprofiledCountOffset;
1680     @HotSpotVMConstant(name = "ReceiverTypeData::receiver_type_row_cell_count") @Stable public int receiverTypeDataReceiverTypeRowCellCount;
1681     @HotSpotVMConstant(name = "ReceiverTypeData::receiver0_offset") @Stable public int receiverTypeDataReceiver0Offset;
1682     @HotSpotVMConstant(name = "ReceiverTypeData::count0_offset") @Stable public int receiverTypeDataCount0Offset;
1683     @HotSpotVMConstant(name = "BranchData::not_taken_off_set") @Stable public int branchDataNotTakenOffset;
1684     @HotSpotVMConstant(name = "ArrayData::array_len_off_set") @Stable public int arrayDataArrayLenOffset;
1685     @HotSpotVMConstant(name = "ArrayData::array_start_off_set") @Stable public int arrayDataArrayStartOffset;
1686     @HotSpotVMConstant(name = "MultiBranchData::per_case_cell_count") @Stable public int multiBranchDataPerCaseCellCount;
1687 
1688     // Checkstyle: resume
1689 
1690     private boolean check() {
1691         for (Field f : getClass().getDeclaredFields()) {
1692             int modifiers = f.getModifiers();
1693             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
1694                 assert Modifier.isFinal(modifiers) || f.getAnnotation(Stable.class) != null : "field should either be final or @Stable: " + f;
1695             }
1696         }
1697 
1698         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
1699         assert (layoutHelperArrayTagObjectValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "object array must have first bit set";
1700         assert (layoutHelperArrayTagTypeValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "type array must have first bit set";
1701 
1702         return true;
1703     }
1704 
1705     /**
1706      * A compact representation of the different encoding strategies for Objects and metadata.
1707      */
1708     public static class CompressEncoding {
1709         public final long base;
1710         public final int shift;
1711         public final int alignment;
1712 
1713         CompressEncoding(long base, int shift, int alignment) {
1714             this.base = base;
1715             this.shift = shift;
1716             this.alignment = alignment;
1717         }
1718 
1719         public int compress(long ptr) {
1720             if (ptr == 0L) {
1721                 return 0;
1722             } else {
1723                 return (int) ((ptr - base) &gt;&gt;&gt; shift);
1724             }
1725         }
1726 
1727         public long uncompress(int ptr) {
1728             if (ptr == 0) {
1729                 return 0L;
1730             } else {
1731                 return ((ptr &amp; 0xFFFFFFFFL) &lt;&lt; shift) + base;
1732             }
1733         }
1734 
1735         @Override
1736         public String toString() {
1737             return "base: " + base + " shift: " + shift + " alignment: " + alignment;
1738         }
1739 
1740         @Override
1741         public int hashCode() {
1742             final int prime = 31;
1743             int result = 1;
1744             result = prime * result + alignment;
1745             result = prime * result + (int) (base ^ (base &gt;&gt;&gt; 32));
1746             result = prime * result + shift;
1747             return result;
1748         }
1749 
1750         @Override
1751         public boolean equals(Object obj) {
1752             if (obj instanceof CompressEncoding) {
1753                 CompressEncoding other = (CompressEncoding) obj;
1754                 return alignment == other.alignment &amp;&amp; base == other.base &amp;&amp; shift == other.shift;
1755             } else {
1756                 return false;
1757             }
1758         }
1759     }
1760 
1761 }
</pre></body></html>
