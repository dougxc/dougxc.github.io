--- old/graal/com.oracle.graal.hotspot.hsail/src/com/oracle/graal/hotspot/hsail/ForEachToGraal.java	2014-01-30 16:44:17.202201060 +0100
+++ new/graal/com.oracle.graal.hotspot.hsail/src/com/oracle/graal/hotspot/hsail/ForEachToGraal.java	2014-01-30 16:44:17.138201059 +0100
@@ -28,6 +28,7 @@
 import java.lang.reflect.*;
 import java.util.*;
 
+import com.amd.sumatra.*;
 import com.oracle.graal.api.code.*;
 import com.oracle.graal.api.meta.*;
 import com.oracle.graal.compiler.hsail.*;
@@ -46,7 +47,7 @@
  * Implements compile and dispatch of Java code containing lambda constructs. Currently only used by
  * JDK interception code that offloads to the GPU.
  */
-public class ForEachToGraal implements CompileAndDispatch {
+public class ForEachToGraal implements CompileAndDispatch, Sumatra {
 
     private static HSAILHotSpotBackend getHSAILBackend() {
         Backend backend = runtime().getBackend(HSAIL.class);
--- old/mx/projects	2014-01-30 16:44:17.494201054 +0100
+++ new/mx/projects	2014-01-30 16:44:17.430201053 +0100
@@ -90,7 +90,7 @@
 project@com.oracle.graal.api.runtime@subDir=graal
 project@com.oracle.graal.api.runtime@sourceDirs=src
 project@com.oracle.graal.api.runtime@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.api.runtime@javaCompliance=1.7
+project@com.oracle.graal.api.runtime@javaCompliance=1.8
 project@com.oracle.graal.api.runtime@workingSets=API,Graal
 
 # graal.api.test
@@ -98,14 +98,14 @@
 project@com.oracle.graal.api.test@sourceDirs=src
 project@com.oracle.graal.api.test@dependencies=JUNIT,com.oracle.graal.api.runtime
 project@com.oracle.graal.api.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.api.test@javaCompliance=1.7
+project@com.oracle.graal.api.test@javaCompliance=1.8
 project@com.oracle.graal.api.test@workingSets=API,Graal,Test
 
 # graal.api.meta
 project@com.oracle.graal.api.meta@subDir=graal
 project@com.oracle.graal.api.meta@sourceDirs=src
 project@com.oracle.graal.api.meta@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.api.meta@javaCompliance=1.7
+project@com.oracle.graal.api.meta@javaCompliance=1.8
 project@com.oracle.graal.api.meta@workingSets=API,Graal
 
 # graal.api.meta.test
@@ -113,7 +113,7 @@
 project@com.oracle.graal.api.meta.test@sourceDirs=src
 project@com.oracle.graal.api.meta.test@dependencies=JUNIT,com.oracle.graal.runtime,com.oracle.graal.java
 project@com.oracle.graal.api.meta.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.api.meta.test@javaCompliance=1.7
+project@com.oracle.graal.api.meta.test@javaCompliance=1.8
 project@com.oracle.graal.api.meta.test@workingSets=API,Graal,Test
 
 # graal.api.meta.jdk8.test
@@ -129,7 +129,7 @@
 project@com.oracle.graal.api.code@sourceDirs=src
 project@com.oracle.graal.api.code@dependencies=com.oracle.graal.api.meta
 project@com.oracle.graal.api.code@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.api.code@javaCompliance=1.7
+project@com.oracle.graal.api.code@javaCompliance=1.8
 project@com.oracle.graal.api.code@workingSets=API,Graal
 
 # graal.api.replacements
@@ -137,7 +137,7 @@
 project@com.oracle.graal.api.replacements@sourceDirs=src
 project@com.oracle.graal.api.replacements@dependencies=com.oracle.graal.api.meta
 project@com.oracle.graal.api.replacements@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.api.replacements@javaCompliance=1.7
+project@com.oracle.graal.api.replacements@javaCompliance=1.8
 project@com.oracle.graal.api.replacements@workingSets=API,Graal,Replacements
 
 # graal.service.processor
@@ -145,7 +145,7 @@
 project@com.oracle.graal.service.processor@sourceDirs=src
 project@com.oracle.graal.service.processor@dependencies=com.oracle.graal.api.runtime
 project@com.oracle.graal.service.processor@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.service.processor@javaCompliance=1.7
+project@com.oracle.graal.service.processor@javaCompliance=1.8
 project@com.oracle.graal.service.processor@workingSets=Codegen,HotSpot
 
 # graal.amd64
@@ -153,7 +153,7 @@
 project@com.oracle.graal.amd64@sourceDirs=src
 project@com.oracle.graal.amd64@dependencies=com.oracle.graal.api.code
 project@com.oracle.graal.amd64@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.amd64@javaCompliance=1.7
+project@com.oracle.graal.amd64@javaCompliance=1.8
 project@com.oracle.graal.amd64@workingSets=Graal,AMD64
 
 # graal.ptx
@@ -161,7 +161,7 @@
 project@com.oracle.graal.ptx@sourceDirs=src
 project@com.oracle.graal.ptx@dependencies=com.oracle.graal.api.code
 project@com.oracle.graal.ptx@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.ptx@javaCompliance=1.7
+project@com.oracle.graal.ptx@javaCompliance=1.8
 project@com.oracle.graal.ptx@workingSets=Graal,PTX
 
 # graal.sparc
@@ -169,7 +169,7 @@
 project@com.oracle.graal.sparc@sourceDirs=src
 project@com.oracle.graal.sparc@dependencies=com.oracle.graal.api.code
 project@com.oracle.graal.sparc@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.sparc@javaCompliance=1.7
+project@com.oracle.graal.sparc@javaCompliance=1.8
 project@com.oracle.graal.sparc@workingSets=Graal,SPARC
 
 # graal.hotspot
@@ -178,7 +178,7 @@
 project@com.oracle.graal.hotspot@dependencies=com.oracle.graal.replacements,com.oracle.graal.runtime,com.oracle.graal.printer
 project@com.oracle.graal.hotspot@checkstyle=com.oracle.graal.graph
 project@com.oracle.graal.hotspot@annotationProcessors=com.oracle.graal.replacements.verifier,com.oracle.graal.service.processor
-project@com.oracle.graal.hotspot@javaCompliance=1.7
+project@com.oracle.graal.hotspot@javaCompliance=1.8
 project@com.oracle.graal.hotspot@workingSets=Graal,HotSpot
 
 # graal.hotspot.amd64
@@ -187,7 +187,7 @@
 project@com.oracle.graal.hotspot.amd64@dependencies=com.oracle.graal.hotspot,com.oracle.graal.compiler.amd64,com.oracle.graal.replacements.amd64
 project@com.oracle.graal.hotspot.amd64@checkstyle=com.oracle.graal.graph
 project@com.oracle.graal.hotspot.amd64@annotationProcessors=com.oracle.graal.service.processor
-project@com.oracle.graal.hotspot.amd64@javaCompliance=1.7
+project@com.oracle.graal.hotspot.amd64@javaCompliance=1.8
 project@com.oracle.graal.hotspot.amd64@workingSets=Graal,HotSpot,AMD64
 
 # graal.hotspot.sparc
@@ -196,7 +196,7 @@
 project@com.oracle.graal.hotspot.sparc@dependencies=com.oracle.graal.compiler.sparc
 project@com.oracle.graal.hotspot.sparc@checkstyle=com.oracle.graal.graph
 project@com.oracle.graal.hotspot.sparc@annotationProcessors=com.oracle.graal.service.processor
-project@com.oracle.graal.hotspot.sparc@javaCompliance=1.7
+project@com.oracle.graal.hotspot.sparc@javaCompliance=1.8
 project@com.oracle.graal.hotspot.sparc@workingSets=Graal,HotSpot,SPARC
 
 # graal.hotspot.ptx
@@ -205,7 +205,7 @@
 project@com.oracle.graal.hotspot.ptx@dependencies=com.oracle.graal.ptx,com.oracle.graal.compiler.ptx,com.oracle.graal.hotspot
 project@com.oracle.graal.hotspot.ptx@checkstyle=com.oracle.graal.graph
 project@com.oracle.graal.hotspot.ptx@annotationProcessors=com.oracle.graal.service.processor
-project@com.oracle.graal.hotspot.ptx@javaCompliance=1.7
+project@com.oracle.graal.hotspot.ptx@javaCompliance=1.8
 project@com.oracle.graal.hotspot.ptx@workingSets=Graal,HotSpot,PTX
 
 # graal.hotspot.hsail
@@ -214,7 +214,7 @@
 project@com.oracle.graal.hotspot.hsail@dependencies=com.oracle.graal.replacements.hsail,com.oracle.graal.hotspot
 project@com.oracle.graal.hotspot.hsail@checkstyle=com.oracle.graal.graph
 project@com.oracle.graal.hotspot.hsail@annotationProcessors=com.oracle.graal.service.processor
-project@com.oracle.graal.hotspot.hsail@javaCompliance=1.7
+project@com.oracle.graal.hotspot.hsail@javaCompliance=1.8
 project@com.oracle.graal.hotspot.hsail@workingSets=Graal,HotSpot,PTX
 
 # graal.hotspot.server
@@ -222,7 +222,7 @@
 project@com.oracle.graal.hotspot.server@sourceDirs=src
 project@com.oracle.graal.hotspot.server@dependencies=com.oracle.graal.hotspot
 project@com.oracle.graal.hotspot.server@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.hotspot.server@javaCompliance=1.7
+project@com.oracle.graal.hotspot.server@javaCompliance=1.8
 project@com.oracle.graal.hotspot.server@workingSets=Graal,HotSpot
 
 # graal.hotspot.test
@@ -230,7 +230,7 @@
 project@com.oracle.graal.hotspot.test@sourceDirs=src
 project@com.oracle.graal.hotspot.test@dependencies=com.oracle.graal.replacements.test,com.oracle.graal.hotspot
 project@com.oracle.graal.hotspot.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.hotspot.test@javaCompliance=1.7
+project@com.oracle.graal.hotspot.test@javaCompliance=1.8
 project@com.oracle.graal.hotspot.test@workingSets=Graal,HotSpot,Test
 
 # graal.hotspot.jdk8.test
@@ -246,14 +246,14 @@
 project@com.oracle.graal.hotspot.amd64.test@sourceDirs=src
 project@com.oracle.graal.hotspot.amd64.test@dependencies=com.oracle.graal.asm.amd64,com.oracle.graal.compiler.test
 project@com.oracle.graal.hotspot.amd64.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.hotspot.amd64.test@javaCompliance=1.7
+project@com.oracle.graal.hotspot.amd64.test@javaCompliance=1.8
 project@com.oracle.graal.hotspot.amd64.test@workingSets=Graal,HotSpot,AMD64,Test
 
 # graal.options
 project@com.oracle.graal.options@subDir=graal
 project@com.oracle.graal.options@sourceDirs=src
 project@com.oracle.graal.options@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.options@javaCompliance=1.7
+project@com.oracle.graal.options@javaCompliance=1.8
 project@com.oracle.graal.options@annotationProcessorForDependents=true
 project@com.oracle.graal.options@workingSets=Graal,Codegen
 
@@ -262,14 +262,14 @@
 project@com.oracle.graal.options.test@sourceDirs=src
 project@com.oracle.graal.options.test@dependencies=com.oracle.graal.options,JUNIT
 project@com.oracle.graal.options.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.options.test@javaCompliance=1.7
+project@com.oracle.graal.options.test@javaCompliance=1.8
 project@com.oracle.graal.options.test@workingSets=Graal
 
 # graal.graph
 project@com.oracle.graal.graph@subDir=graal
 project@com.oracle.graal.graph@sourceDirs=src
 project@com.oracle.graal.graph@dependencies=com.oracle.graal.debug,com.oracle.graal.api.code
-project@com.oracle.graal.graph@javaCompliance=1.7
+project@com.oracle.graal.graph@javaCompliance=1.8
 project@com.oracle.graal.graph@workingSets=Graal,Graph
 
 # graal.graph.test
@@ -277,14 +277,14 @@
 project@com.oracle.graal.graph.test@sourceDirs=src
 project@com.oracle.graal.graph.test@checkstyle=com.oracle.graal.graph
 project@com.oracle.graal.graph.test@dependencies=JUNIT,com.oracle.graal.graph
-project@com.oracle.graal.graph.test@javaCompliance=1.7
+project@com.oracle.graal.graph.test@javaCompliance=1.8
 project@com.oracle.graal.graph.test@workingSets=Graal,Graph,Test
 
 # graal.debug
 project@com.oracle.graal.debug@subDir=graal
 project@com.oracle.graal.debug@sourceDirs=src
 project@com.oracle.graal.debug@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.debug@javaCompliance=1.7
+project@com.oracle.graal.debug@javaCompliance=1.8
 project@com.oracle.graal.debug@workingSets=Graal,Debug
 
 # graal.debug.test
@@ -292,7 +292,7 @@
 project@com.oracle.graal.debug.test@sourceDirs=src
 project@com.oracle.graal.debug.test@dependencies=JUNIT,com.oracle.graal.debug
 project@com.oracle.graal.debug.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.debug.test@javaCompliance=1.7
+project@com.oracle.graal.debug.test@javaCompliance=1.8
 project@com.oracle.graal.debug.test@workingSets=Graal,Debug,Test
 
 # graal.lir
@@ -300,7 +300,7 @@
 project@com.oracle.graal.lir@sourceDirs=src
 project@com.oracle.graal.lir@dependencies=com.oracle.graal.asm,com.oracle.graal.nodes
 project@com.oracle.graal.lir@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.lir@javaCompliance=1.7
+project@com.oracle.graal.lir@javaCompliance=1.8
 project@com.oracle.graal.lir@workingSets=Graal,LIR
 
 # graal.lir.amd64
@@ -308,7 +308,7 @@
 project@com.oracle.graal.lir.amd64@sourceDirs=src
 project@com.oracle.graal.lir.amd64@dependencies=com.oracle.graal.lir,com.oracle.graal.asm.amd64
 project@com.oracle.graal.lir.amd64@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.lir.amd64@javaCompliance=1.7
+project@com.oracle.graal.lir.amd64@javaCompliance=1.8
 project@com.oracle.graal.lir.amd64@workingSets=Graal,LIR,AMD64
 
 # graal.lir.ptx
@@ -316,7 +316,7 @@
 project@com.oracle.graal.lir.ptx@sourceDirs=src
 project@com.oracle.graal.lir.ptx@dependencies=com.oracle.graal.asm.ptx
 project@com.oracle.graal.lir.ptx@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.lir.ptx@javaCompliance=1.7
+project@com.oracle.graal.lir.ptx@javaCompliance=1.8
 project@com.oracle.graal.lir.ptx@workingSets=Graal,LIR,PTX
 
 # graal.lir.sparc
@@ -324,7 +324,7 @@
 project@com.oracle.graal.lir.sparc@sourceDirs=src
 project@com.oracle.graal.lir.sparc@dependencies=com.oracle.graal.asm.sparc
 project@com.oracle.graal.lir.sparc@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.lir.sparc@javaCompliance=1.7
+project@com.oracle.graal.lir.sparc@javaCompliance=1.8
 project@com.oracle.graal.lir.sparc@workingSets=Graal,LIR,SPARC
 
 # graal.alloc
@@ -332,7 +332,7 @@
 project@com.oracle.graal.alloc@sourceDirs=src
 project@com.oracle.graal.alloc@dependencies=com.oracle.graal.nodes
 project@com.oracle.graal.alloc@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.alloc@javaCompliance=1.7
+project@com.oracle.graal.alloc@javaCompliance=1.8
 project@com.oracle.graal.alloc@workingSets=Graal
 
 # graal.word
@@ -340,7 +340,7 @@
 project@com.oracle.graal.word@sourceDirs=src
 project@com.oracle.graal.word@dependencies=com.oracle.graal.phases
 project@com.oracle.graal.word@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.word@javaCompliance=1.7
+project@com.oracle.graal.word@javaCompliance=1.8
 project@com.oracle.graal.word@workingSets=API,Graal
 
 # graal.replacements
@@ -348,7 +348,7 @@
 project@com.oracle.graal.replacements@sourceDirs=src
 project@com.oracle.graal.replacements@dependencies=com.oracle.graal.compiler,com.oracle.graal.java,com.oracle.graal.word
 project@com.oracle.graal.replacements@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.replacements@javaCompliance=1.7
+project@com.oracle.graal.replacements@javaCompliance=1.8
 project@com.oracle.graal.replacements@annotationProcessors=com.oracle.graal.replacements.verifier,com.oracle.graal.service.processor
 project@com.oracle.graal.replacements@workingSets=Graal,Replacements
 
@@ -357,7 +357,7 @@
 project@com.oracle.graal.replacements.amd64@sourceDirs=src
 project@com.oracle.graal.replacements.amd64@dependencies=com.oracle.graal.replacements
 project@com.oracle.graal.replacements.amd64@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.replacements.amd64@javaCompliance=1.7
+project@com.oracle.graal.replacements.amd64@javaCompliance=1.8
 project@com.oracle.graal.replacements.amd64@annotationProcessors=com.oracle.graal.service.processor
 project@com.oracle.graal.replacements.amd64@workingSets=Graal,Replacements,AMD64
 
@@ -366,7 +366,7 @@
 project@com.oracle.graal.replacements.hsail@sourceDirs=src
 project@com.oracle.graal.replacements.hsail@dependencies=com.oracle.graal.compiler.hsail
 project@com.oracle.graal.replacements.hsail@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.replacements.hsail@javaCompliance=1.7
+project@com.oracle.graal.replacements.hsail@javaCompliance=1.8
 project@com.oracle.graal.replacements.hsail@workingSets=Graal,Replacements,HSAIL
 
 # graal.replacements.test
@@ -374,7 +374,7 @@
 project@com.oracle.graal.replacements.test@sourceDirs=src
 project@com.oracle.graal.replacements.test@dependencies=com.oracle.graal.compiler.test,com.oracle.graal.replacements
 project@com.oracle.graal.replacements.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.replacements.test@javaCompliance=1.7
+project@com.oracle.graal.replacements.test@javaCompliance=1.8
 project@com.oracle.graal.replacements.test@workingSets=Graal,Replacements,Test
 
 # graal.replacements.verifier
@@ -382,7 +382,7 @@
 project@com.oracle.graal.replacements.verifier@sourceDirs=src
 project@com.oracle.graal.replacements.verifier@dependencies=com.oracle.graal.api.replacements
 project@com.oracle.graal.replacements.verifier@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.replacements.verifier@javaCompliance=1.7
+project@com.oracle.graal.replacements.verifier@javaCompliance=1.8
 project@com.oracle.graal.replacements.verifier@workingSets=Graal,Replacements
 
 # graal.nodes
@@ -390,7 +390,7 @@
 project@com.oracle.graal.nodes@sourceDirs=src
 project@com.oracle.graal.nodes@dependencies=com.oracle.graal.graph,com.oracle.graal.api.replacements
 project@com.oracle.graal.nodes@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.nodes@javaCompliance=1.7
+project@com.oracle.graal.nodes@javaCompliance=1.8
 project@com.oracle.graal.nodes@workingSets=Graal,Graph
 
 # graal.nodes.test
@@ -398,7 +398,7 @@
 project@com.oracle.graal.nodes.test@sourceDirs=src
 project@com.oracle.graal.nodes.test@dependencies=com.oracle.graal.compiler.test
 project@com.oracle.graal.nodes.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.nodes.test@javaCompliance=1.7
+project@com.oracle.graal.nodes.test@javaCompliance=1.8
 project@com.oracle.graal.nodes.test@workingSets=Graal,Graph
 
 # graal.phases
@@ -406,7 +406,7 @@
 project@com.oracle.graal.phases@sourceDirs=src
 project@com.oracle.graal.phases@dependencies=com.oracle.graal.nodes,com.oracle.graal.options
 project@com.oracle.graal.phases@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.phases@javaCompliance=1.7
+project@com.oracle.graal.phases@javaCompliance=1.8
 project@com.oracle.graal.phases@workingSets=Graal,Phases
 
 # graal.phases.common
@@ -414,7 +414,7 @@
 project@com.oracle.graal.phases.common@sourceDirs=src
 project@com.oracle.graal.phases.common@dependencies=com.oracle.graal.phases
 project@com.oracle.graal.phases.common@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.phases.common@javaCompliance=1.7
+project@com.oracle.graal.phases.common@javaCompliance=1.8
 project@com.oracle.graal.phases.common@workingSets=Graal,Phases
 
 # graal.virtual
@@ -422,7 +422,7 @@
 project@com.oracle.graal.virtual@sourceDirs=src
 project@com.oracle.graal.virtual@dependencies=com.oracle.graal.phases.common
 project@com.oracle.graal.virtual@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.virtual@javaCompliance=1.7
+project@com.oracle.graal.virtual@javaCompliance=1.8
 project@com.oracle.graal.virtual@workingSets=Graal,Phases
 
 # graal.loop
@@ -430,7 +430,7 @@
 project@com.oracle.graal.loop@sourceDirs=src
 project@com.oracle.graal.loop@dependencies=com.oracle.graal.phases.common
 project@com.oracle.graal.loop@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.loop@javaCompliance=1.7
+project@com.oracle.graal.loop@javaCompliance=1.8
 project@com.oracle.graal.loop@workingSets=Graal,Phases
 
 # graal.compiler
@@ -438,7 +438,7 @@
 project@com.oracle.graal.compiler@sourceDirs=src
 project@com.oracle.graal.compiler@dependencies=com.oracle.graal.api.runtime,com.oracle.graal.virtual,com.oracle.graal.loop,com.oracle.graal.alloc,com.oracle.graal.lir
 project@com.oracle.graal.compiler@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.compiler@javaCompliance=1.7
+project@com.oracle.graal.compiler@javaCompliance=1.8
 project@com.oracle.graal.compiler@annotationProcessors=com.oracle.graal.service.processor
 project@com.oracle.graal.compiler@workingSets=Graal
 
@@ -447,7 +447,7 @@
 project@com.oracle.graal.compiler.amd64@sourceDirs=src
 project@com.oracle.graal.compiler.amd64@dependencies=com.oracle.graal.compiler,com.oracle.graal.lir.amd64
 project@com.oracle.graal.compiler.amd64@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.compiler.amd64@javaCompliance=1.7
+project@com.oracle.graal.compiler.amd64@javaCompliance=1.8
 project@com.oracle.graal.compiler.amd64@workingSets=Graal,AMD64
 
 # graal.compiler.amd64.test
@@ -455,7 +455,7 @@
 project@com.oracle.graal.compiler.amd64.test@sourceDirs=src
 project@com.oracle.graal.compiler.amd64.test@dependencies=com.oracle.graal.compiler.test
 project@com.oracle.graal.compiler.amd64.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.compiler.amd64.test@javaCompliance=1.7
+project@com.oracle.graal.compiler.amd64.test@javaCompliance=1.8
 project@com.oracle.graal.compiler.amd64.test@workingSets=Graal,AMD64,Test
 
 # graal.compiler.ptx
@@ -463,7 +463,7 @@
 project@com.oracle.graal.compiler.ptx@sourceDirs=src
 project@com.oracle.graal.compiler.ptx@dependencies=com.oracle.graal.lir.ptx,com.oracle.graal.compiler
 project@com.oracle.graal.compiler.ptx@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.compiler.ptx@javaCompliance=1.7
+project@com.oracle.graal.compiler.ptx@javaCompliance=1.8
 project@com.oracle.graal.compiler.ptx@workingSets=Graal,PTX
 
 # graal.compiler.ptx.test
@@ -471,7 +471,7 @@
 project@com.oracle.graal.compiler.ptx.test@sourceDirs=src
 project@com.oracle.graal.compiler.ptx.test@dependencies=com.oracle.graal.hotspot.ptx,com.oracle.graal.compiler.test
 project@com.oracle.graal.compiler.ptx.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.compiler.ptx.test@javaCompliance=1.7
+project@com.oracle.graal.compiler.ptx.test@javaCompliance=1.8
 project@com.oracle.graal.compiler.ptx.test@workingSets=Graal,PTX,Test
 
 # graal.compiler.sparc
@@ -479,7 +479,7 @@
 project@com.oracle.graal.compiler.sparc@sourceDirs=src
 project@com.oracle.graal.compiler.sparc@dependencies=com.oracle.graal.lir.sparc
 project@com.oracle.graal.compiler.sparc@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.compiler.sparc@javaCompliance=1.7
+project@com.oracle.graal.compiler.sparc@javaCompliance=1.8
 project@com.oracle.graal.compiler.sparc@workingSets=Graal,SPARC
 
 # graal.compiler.sparc.test
@@ -487,7 +487,7 @@
 project@com.oracle.graal.compiler.sparc.test@sourceDirs=src
 project@com.oracle.graal.compiler.sparc.test@dependencies=com.oracle.graal.compiler.test
 project@com.oracle.graal.compiler.sparc.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.compiler.sparc.test@javaCompliance=1.7
+project@com.oracle.graal.compiler.sparc.test@javaCompliance=1.8
 project@com.oracle.graal.compiler.sparc.test@workingSets=Graal,SPARC,Test
 
 # graal.runtime
@@ -495,14 +495,14 @@
 project@com.oracle.graal.runtime@sourceDirs=src
 project@com.oracle.graal.runtime@dependencies=com.oracle.graal.compiler
 project@com.oracle.graal.runtime@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.runtime@javaCompliance=1.7
+project@com.oracle.graal.runtime@javaCompliance=1.8
 project@com.oracle.graal.runtime@workingSets=Graal
 
 # graal.bytecode
 project@com.oracle.graal.bytecode@subDir=graal
 project@com.oracle.graal.bytecode@sourceDirs=src
 project@com.oracle.graal.bytecode@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.bytecode@javaCompliance=1.7
+project@com.oracle.graal.bytecode@javaCompliance=1.8
 project@com.oracle.graal.bytecode@workingSets=Graal,Java
 
 # graal.java
@@ -510,7 +510,7 @@
 project@com.oracle.graal.java@sourceDirs=src
 project@com.oracle.graal.java@dependencies=com.oracle.graal.phases,com.oracle.graal.bytecode
 project@com.oracle.graal.java@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.java@javaCompliance=1.7
+project@com.oracle.graal.java@javaCompliance=1.8
 project@com.oracle.graal.java@workingSets=Graal,Java
 
 # graal.java.decompiler
@@ -518,7 +518,7 @@
 project@com.oracle.graal.java.decompiler@sourceDirs=src
 project@com.oracle.graal.java.decompiler@dependencies=com.oracle.graal.java
 project@com.oracle.graal.java.decompiler@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.java.decompiler@javaCompliance=1.7
+project@com.oracle.graal.java.decompiler@javaCompliance=1.8
 project@com.oracle.graal.java.decompiler@workingSets=Graal
 
 # graal.java.decompiler.test
@@ -526,7 +526,7 @@
 project@com.oracle.graal.java.decompiler.test@sourceDirs=src
 project@com.oracle.graal.java.decompiler.test@dependencies=com.oracle.graal.printer,com.oracle.graal.runtime
 project@com.oracle.graal.java.decompiler.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.java.decompiler.test@javaCompliance=1.7
+project@com.oracle.graal.java.decompiler.test@javaCompliance=1.8
 project@com.oracle.graal.java.decompiler.test@workingSets=Graal,Test
 
 # graal.printer
@@ -534,7 +534,7 @@
 project@com.oracle.graal.printer@sourceDirs=src
 project@com.oracle.graal.printer@dependencies=com.oracle.graal.java.decompiler,com.oracle.graal.compiler
 project@com.oracle.graal.printer@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.printer@javaCompliance=1.7
+project@com.oracle.graal.printer@javaCompliance=1.8
 project@com.oracle.graal.printer@workingSets=Graal,Graph
 
 # graal.test
@@ -542,7 +542,7 @@
 project@com.oracle.graal.test@sourceDirs=src
 project@com.oracle.graal.test@dependencies=JUNIT
 project@com.oracle.graal.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.test@javaCompliance=1.7
+project@com.oracle.graal.test@javaCompliance=1.8
 project@com.oracle.graal.test@workingSets=Graal,Test
 
 # graal.compiler.test
@@ -550,7 +550,7 @@
 project@com.oracle.graal.compiler.test@sourceDirs=src
 project@com.oracle.graal.compiler.test@dependencies=com.oracle.graal.test,com.oracle.graal.printer,com.oracle.graal.runtime
 project@com.oracle.graal.compiler.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.compiler.test@javaCompliance=1.7
+project@com.oracle.graal.compiler.test@javaCompliance=1.8
 project@com.oracle.graal.compiler.test@workingSets=Graal,Test
 
 # graal.jtt
@@ -558,7 +558,7 @@
 project@com.oracle.graal.jtt@sourceDirs=src
 project@com.oracle.graal.jtt@dependencies=com.oracle.graal.compiler.test
 project@com.oracle.graal.jtt@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.jtt@javaCompliance=1.7
+project@com.oracle.graal.jtt@javaCompliance=1.8
 project@com.oracle.graal.jtt@workingSets=Graal,Test
 
 # graal.asm
@@ -566,7 +566,7 @@
 project@com.oracle.graal.asm@sourceDirs=src
 project@com.oracle.graal.asm@dependencies=com.oracle.graal.api.code
 project@com.oracle.graal.asm@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.asm@javaCompliance=1.7
+project@com.oracle.graal.asm@javaCompliance=1.8
 project@com.oracle.graal.asm@workingSets=Graal,Assembler
 
 # graal.asm.test
@@ -574,7 +574,7 @@
 project@com.oracle.graal.asm.test@sourceDirs=src
 project@com.oracle.graal.asm.test@dependencies=com.oracle.graal.test,com.oracle.graal.runtime
 project@com.oracle.graal.asm.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.asm.test@javaCompliance=1.7
+project@com.oracle.graal.asm.test@javaCompliance=1.8
 project@com.oracle.graal.asm.test@workingSets=Graal,Assembler,Test
 
 # graal.asm.amd64
@@ -582,7 +582,7 @@
 project@com.oracle.graal.asm.amd64@sourceDirs=src
 project@com.oracle.graal.asm.amd64@dependencies=com.oracle.graal.asm,com.oracle.graal.amd64
 project@com.oracle.graal.asm.amd64@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.asm.amd64@javaCompliance=1.7
+project@com.oracle.graal.asm.amd64@javaCompliance=1.8
 project@com.oracle.graal.asm.amd64@workingSets=Graal,Assembler,AMD64
 
 # graal.asm.amd64.test
@@ -590,7 +590,7 @@
 project@com.oracle.graal.asm.amd64.test@sourceDirs=src
 project@com.oracle.graal.asm.amd64.test@dependencies=com.oracle.graal.asm.test,com.oracle.graal.asm.amd64
 project@com.oracle.graal.asm.amd64.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.asm.amd64.test@javaCompliance=1.7
+project@com.oracle.graal.asm.amd64.test@javaCompliance=1.8
 project@com.oracle.graal.asm.amd64.test@workingSets=Graal,Assembler,AMD64,Test
 
 # graal.hsail
@@ -598,49 +598,49 @@
 project@com.oracle.graal.hsail@sourceDirs=src
 project@com.oracle.graal.hsail@dependencies=com.oracle.graal.graph
 project@com.oracle.graal.hsail@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.hsail@javaCompliance=1.7
+project@com.oracle.graal.hsail@javaCompliance=1.8
 
 # graal.lir.hsail
 project@com.oracle.graal.lir.hsail@subDir=graal
 project@com.oracle.graal.lir.hsail@sourceDirs=src
 project@com.oracle.graal.lir.hsail@dependencies=com.oracle.graal.lir,com.oracle.graal.asm.hsail
 project@com.oracle.graal.lir.hsail@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.lir.hsail@javaCompliance=1.7
+project@com.oracle.graal.lir.hsail@javaCompliance=1.8
 
 # graal.compiler.hsail
 project@com.oracle.graal.compiler.hsail@subDir=graal
 project@com.oracle.graal.compiler.hsail@sourceDirs=src
 project@com.oracle.graal.compiler.hsail@dependencies=com.oracle.graal.compiler,com.oracle.graal.lir.hsail
 project@com.oracle.graal.compiler.hsail@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.compiler.hsail@javaCompliance=1.7
+project@com.oracle.graal.compiler.hsail@javaCompliance=1.8
 
 # graal.compiler.hsail.test.infra - HSAIL compiler test infrastructure
 project@com.oracle.graal.compiler.hsail.test.infra@subDir=graal
 project@com.oracle.graal.compiler.hsail.test.infra@sourceDirs=src
 project@com.oracle.graal.compiler.hsail.test.infra@dependencies=com.oracle.graal.hotspot.hsail,JUNIT,OKRA_WITH_SIM
 project@com.oracle.graal.compiler.hsail.test.infra@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.compiler.hsail.test.infra@javaCompliance=1.7
+project@com.oracle.graal.compiler.hsail.test.infra@javaCompliance=1.8
 
 # graal.compiler.hsail.test
 project@com.oracle.graal.compiler.hsail.test@subDir=graal
 project@com.oracle.graal.compiler.hsail.test@sourceDirs=src
 project@com.oracle.graal.compiler.hsail.test@dependencies=com.oracle.graal.compiler.hsail.test.infra,com.oracle.graal.compiler.test
 project@com.oracle.graal.compiler.hsail.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.compiler.hsail.test@javaCompliance=1.7
+project@com.oracle.graal.compiler.hsail.test@javaCompliance=1.8
 
 # graal.asm.hsail
 project@com.oracle.graal.asm.hsail@subDir=graal
 project@com.oracle.graal.asm.hsail@sourceDirs=src
 project@com.oracle.graal.asm.hsail@dependencies=com.oracle.graal.hsail,OKRA,com.oracle.graal.asm
 project@com.oracle.graal.asm.hsail@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.asm.hsail@javaCompliance=1.7
+project@com.oracle.graal.asm.hsail@javaCompliance=1.8
 
 # graal.asm.ptx
 project@com.oracle.graal.asm.ptx@subDir=graal
 project@com.oracle.graal.asm.ptx@sourceDirs=src
 project@com.oracle.graal.asm.ptx@dependencies=com.oracle.graal.lir
 project@com.oracle.graal.asm.ptx@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.asm.ptx@javaCompliance=1.7
+project@com.oracle.graal.asm.ptx@javaCompliance=1.8
 project@com.oracle.graal.asm.ptx@workingSets=Graal,Assembler,PTX
 
 # graal.asm.sparc
@@ -648,14 +648,14 @@
 project@com.oracle.graal.asm.sparc@sourceDirs=src
 project@com.oracle.graal.asm.sparc@dependencies=com.oracle.graal.hotspot,com.oracle.graal.sparc
 project@com.oracle.graal.asm.sparc@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.asm.sparc@javaCompliance=1.7
+project@com.oracle.graal.asm.sparc@javaCompliance=1.8
 project@com.oracle.graal.asm.sparc@workingSets=Graal,Assembler,SPARC
 
 # truffle.api
 project@com.oracle.truffle.api@subDir=graal
 project@com.oracle.truffle.api@sourceDirs=src
 project@com.oracle.truffle.api@dependencies=
-project@com.oracle.truffle.api@javaCompliance=1.7
+project@com.oracle.truffle.api@javaCompliance=1.8
 project@com.oracle.truffle.api@workingSets=API,Truffle
 
 # truffle.api.test
@@ -663,7 +663,7 @@
 project@com.oracle.truffle.api.test@sourceDirs=src
 project@com.oracle.truffle.api.test@dependencies=com.oracle.truffle.api,JUNIT
 project@com.oracle.truffle.api.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.truffle.api.test@javaCompliance=1.7
+project@com.oracle.truffle.api.test@javaCompliance=1.8
 project@com.oracle.truffle.api.test@workingSets=API,Truffle,Test
 
 # truffle.api.dsl
@@ -671,7 +671,7 @@
 project@com.oracle.truffle.api.dsl@sourceDirs=src
 project@com.oracle.truffle.api.dsl@dependencies=com.oracle.truffle.api
 project@com.oracle.truffle.api.dsl@checkstyle=com.oracle.truffle.api
-project@com.oracle.truffle.api.dsl@javaCompliance=1.7
+project@com.oracle.truffle.api.dsl@javaCompliance=1.8
 project@com.oracle.truffle.api.dsl@workingSets=API,Truffle,Codegen
 
 # truffle.api.dsl.test
@@ -679,7 +679,7 @@
 project@com.oracle.truffle.api.dsl.test@sourceDirs=src
 project@com.oracle.truffle.api.dsl.test@dependencies=com.oracle.truffle.api.dsl,JUNIT
 project@com.oracle.truffle.api.dsl.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.truffle.api.dsl.test@javaCompliance=1.7
+project@com.oracle.truffle.api.dsl.test@javaCompliance=1.8
 project@com.oracle.truffle.api.dsl.test@annotationProcessors=com.oracle.truffle.dsl.processor
 project@com.oracle.truffle.api.dsl.test@workingSets=API,Truffle,Codegen,Test
 
@@ -688,7 +688,7 @@
 project@com.oracle.truffle.dsl.processor@sourceDirs=src
 project@com.oracle.truffle.dsl.processor@dependencies=com.oracle.truffle.api.dsl
 project@com.oracle.truffle.dsl.processor@checkstyle=com.oracle.graal.graph
-project@com.oracle.truffle.dsl.processor@javaCompliance=1.7
+project@com.oracle.truffle.dsl.processor@javaCompliance=1.8
 project@com.oracle.truffle.dsl.processor@workingSets=Truffle,Codegen
 
 # truffle.sl
@@ -696,7 +696,7 @@
 project@com.oracle.truffle.sl@sourceDirs=src
 project@com.oracle.truffle.sl@dependencies=com.oracle.truffle.api.dsl
 project@com.oracle.truffle.sl@checkstyle=com.oracle.graal.graph
-project@com.oracle.truffle.sl@javaCompliance=1.7
+project@com.oracle.truffle.sl@javaCompliance=1.8
 project@com.oracle.truffle.sl@annotationProcessors=com.oracle.truffle.dsl.processor
 project@com.oracle.truffle.sl@workingSets=Truffle,SimpleLanguage
 
@@ -705,7 +705,7 @@
 project@com.oracle.truffle.sl.test@sourceDirs=src
 project@com.oracle.truffle.sl.test@dependencies=com.oracle.truffle.sl,JUNIT
 project@com.oracle.truffle.sl.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.truffle.sl.test@javaCompliance=1.7
+project@com.oracle.truffle.sl.test@javaCompliance=1.8
 project@com.oracle.truffle.sl.test@workingSets=Truffle,SimpleLanguage,Test
 
 # graal.truffle
@@ -713,7 +713,7 @@
 project@com.oracle.graal.truffle@sourceDirs=src
 project@com.oracle.graal.truffle@dependencies=com.oracle.truffle.api,com.oracle.graal.replacements,com.oracle.graal.runtime,com.oracle.graal.printer
 project@com.oracle.graal.truffle@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.truffle@javaCompliance=1.7
+project@com.oracle.graal.truffle@javaCompliance=1.8
 project@com.oracle.graal.truffle@workingSets=Graal,Truffle
 
 # graal.truffle.test
@@ -721,7 +721,7 @@
 project@com.oracle.graal.truffle.test@sourceDirs=src
 project@com.oracle.graal.truffle.test@dependencies=com.oracle.graal.truffle,com.oracle.graal.compiler.test
 project@com.oracle.graal.truffle.test@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.truffle.test@javaCompliance=1.7
+project@com.oracle.graal.truffle.test@javaCompliance=1.8
 project@com.oracle.graal.truffle.test@workingSets=Graal,Truffle,Test
 
 # graal.truffle.hotspot
@@ -729,7 +729,7 @@
 project@com.oracle.graal.truffle.hotspot@sourceDirs=src
 project@com.oracle.graal.truffle.hotspot@dependencies=com.oracle.graal.truffle,com.oracle.graal.hotspot
 project@com.oracle.graal.truffle.hotspot@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.truffle.hotspot@javaCompliance=1.7
+project@com.oracle.graal.truffle.hotspot@javaCompliance=1.8
 project@com.oracle.graal.truffle.hotspot@annotationProcessors=com.oracle.graal.service.processor
 project@com.oracle.graal.truffle.hotspot@workingSets=Graal,Truffle
 
@@ -738,7 +738,7 @@
 project@com.oracle.graal.truffle.hotspot.amd64@sourceDirs=src
 project@com.oracle.graal.truffle.hotspot.amd64@dependencies=com.oracle.graal.truffle.hotspot,com.oracle.graal.hotspot.amd64
 project@com.oracle.graal.truffle.hotspot.amd64@checkstyle=com.oracle.graal.graph
-project@com.oracle.graal.truffle.hotspot.amd64@javaCompliance=1.7
+project@com.oracle.graal.truffle.hotspot.amd64@javaCompliance=1.8
 project@com.oracle.graal.truffle.hotspot.amd64@annotationProcessors=com.oracle.graal.service.processor
 project@com.oracle.graal.truffle.hotspot.amd64@workingSets=Graal,Truffle
 
@@ -746,7 +746,7 @@
 project@com.oracle.truffle.ruby.runtime@subDir=graal
 project@com.oracle.truffle.ruby.runtime@sourceDirs=src
 project@com.oracle.truffle.ruby.runtime@dependencies=JRUBYSTDLIB,JNR_POSIX,JNR_CONSTANTS,JNR_FFI,JFFI,JFFI_NATIVE,JNR_X86ASM,ASM,ASM_ANALYSIS,ASM_COMMONS,ASM_TREE,ASM_UTIL,com.oracle.truffle.api
-project@com.oracle.truffle.ruby.runtime@javaCompliance=1.7
+project@com.oracle.truffle.ruby.runtime@javaCompliance=1.8
 project@com.oracle.truffle.ruby.runtime@workingSets=Truffle,Ruby
 
 # truffle.ruby.nodes
@@ -754,7 +754,7 @@
 project@com.oracle.truffle.ruby.nodes@sourceDirs=src
 project@com.oracle.truffle.ruby.nodes@dependencies=com.oracle.truffle.ruby.runtime,com.oracle.truffle.api.dsl
 project@com.oracle.truffle.ruby.nodes@checkstyle=com.oracle.truffle.ruby.runtime
-project@com.oracle.truffle.ruby.nodes@javaCompliance=1.7
+project@com.oracle.truffle.ruby.nodes@javaCompliance=1.8
 project@com.oracle.truffle.ruby.nodes@annotationProcessors=com.oracle.truffle.dsl.processor
 project@com.oracle.truffle.ruby.nodes@workingSets=Truffle,Ruby
 
@@ -763,7 +763,7 @@
 project@com.oracle.truffle.ruby.parser@sourceDirs=src
 project@com.oracle.truffle.ruby.parser@dependencies=JRUBYPARSER,com.oracle.truffle.ruby.nodes
 project@com.oracle.truffle.ruby.parser@checkstyle=com.oracle.truffle.ruby.runtime
-project@com.oracle.truffle.ruby.parser@javaCompliance=1.7
+project@com.oracle.truffle.ruby.parser@javaCompliance=1.8
 project@com.oracle.truffle.ruby.parser@workingSets=Truffle,Ruby
 
 # truffle.ruby.shell
@@ -771,7 +771,7 @@
 project@com.oracle.truffle.ruby.shell@sourceDirs=src
 project@com.oracle.truffle.ruby.shell@dependencies=JLINE,com.oracle.truffle.ruby.parser
 project@com.oracle.truffle.ruby.shell@checkstyle=com.oracle.truffle.ruby.runtime
-project@com.oracle.truffle.ruby.shell@javaCompliance=1.7
+project@com.oracle.truffle.ruby.shell@javaCompliance=1.8
 project@com.oracle.truffle.ruby.shell@workingSets=Truffle,Ruby
 
 # truffle.ruby.test
@@ -779,5 +779,5 @@
 project@com.oracle.truffle.ruby.test@sourceDirs=src
 project@com.oracle.truffle.ruby.test@dependencies=com.oracle.truffle.ruby.parser,JUNIT
 project@com.oracle.truffle.ruby.test@checkstyle=com.oracle.truffle.ruby.runtime
-project@com.oracle.truffle.ruby.test@javaCompliance=1.7
+project@com.oracle.truffle.ruby.test@javaCompliance=1.8
 project@com.oracle.truffle.ruby.test@workingSets=Truffle,Ruby,Test
--- /dev/null	2014-01-29 23:03:08.911280982 +0100
+++ new/graal/com.oracle.graal.compiler.hsail.test/src/com/oracle/graal/compiler/hsail/test/BasicSumatraTest.java	2014-01-30 16:44:17.730201050 +0100
@@ -0,0 +1,18 @@
+package com.oracle.graal.compiler.hsail.test;
+
+import java.util.*;
+import java.util.stream.*;
+
+public class BasicSumatraTest {
+
+    public static void main(String[] args) {
+        // System.out.println(System.getProperties().toString());
+        int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
+        int b[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
+        int c[] = new int[a.length];
+        IntStream.range(0, a.length).parallel().forEach(id -> {
+            c[id] = a[id] + b[id];
+        });
+        System.out.println(Arrays.toString(c));
+    }
+}
--- /dev/null	2014-01-29 23:03:08.911280982 +0100
+++ new/graal/com.oracle.graal.hotspot.hsail/src/com/oracle/graal/hotspot/hsail/BasicSumatraDemo.java	2014-01-30 16:44:17.942201046 +0100
@@ -0,0 +1,18 @@
+package com.oracle.graal.hotspot.hsail;
+
+import java.util.*;
+import java.util.stream.*;
+
+public class BasicSumatraDemo {
+
+    public static void main(String[] args) {
+        // System.out.println(System.getProperties().toString());
+        int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
+        int b[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
+        int c[] = new int[a.length];
+        IntStream.range(0, a.length).parallel().forEach(id -> {
+            c[id] = a[id] + b[id];
+        });
+        System.out.println(Arrays.toString(c));
+    }
+}
--- /dev/null	2014-01-29 23:03:08.911280982 +0100
+++ new/graal/com.oracle.graal.hsail/src/com/amd/sumatra/Sumatra.java	2014-01-30 16:44:18.178201039 +0100
@@ -0,0 +1,50 @@
+// University of Illinois/NCSA
+// Open Source License
+// 
+// Copyright (c) 2013, Advanced Micro Devices, Inc.
+// All rights reserved.
+// 
+// Developed by:
+// 
+//     Runtimes Team
+// 
+//     Advanced Micro Devices, Inc
+// 
+//     www.amd.com
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy of
+// this software and associated documentation files (the "Software"), to deal with
+// the Software without restriction, including without limitation the rights to
+// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+// of the Software, and to permit persons to whom the Software is furnished to do
+// so, subject to the following conditions:
+// 
+//     * Redistributions of source code must retain the above copyright notice,
+//       this list of conditions and the following disclaimers.
+// 
+//     * Redistributions in binary form must reproduce the above copyright notice,
+//       this list of conditions and the following disclaimers in the
+//       documentation and/or other materials provided with the distribution.
+// 
+//     * Neither the names of the LLVM Team, University of Illinois at
+//       Urbana-Champaign, nor the names of its contributors may be used to
+//       endorse or promote products derived from this Software without specific
+//       prior written permission.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
+// SOFTWARE.
+//===----------------------------------------------------------------------===//
+
+package com.amd.sumatra;
+
+public interface Sumatra {
+
+    public Object createKernel(Class<?> consumerClass);
+
+    public boolean dispatchKernel(Object kernel, int jobSize, Object[] args);
+}
\ No newline at end of file
--- /dev/null	2014-01-29 23:03:08.911280982 +0100
+++ new/graal/com.oracle.graal.hsail/src/com/amd/sumatra/SumatraFactory.java	2014-01-30 16:44:18.386201035 +0100
@@ -0,0 +1,78 @@
+// University of Illinois/NCSA
+// Open Source License
+// 
+// Copyright (c) 2013, Advanced Micro Devices, Inc.
+// All rights reserved.
+// 
+// Developed by:
+// 
+//     Runtimes Team
+// 
+//     Advanced Micro Devices, Inc
+// 
+//     www.amd.com
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy of
+// this software and associated documentation files (the "Software"), to deal with
+// the Software without restriction, including without limitation the rights to
+// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+// of the Software, and to permit persons to whom the Software is furnished to do
+// so, subject to the following conditions:
+// 
+//     * Redistributions of source code must retain the above copyright notice,
+//       this list of conditions and the following disclaimers.
+// 
+//     * Redistributions in binary form must reproduce the above copyright notice,
+//       this list of conditions and the following disclaimers in the
+//       documentation and/or other materials provided with the distribution.
+// 
+//     * Neither the names of the LLVM Team, University of Illinois at
+//       Urbana-Champaign, nor the names of its contributors may be used to
+//       endorse or promote products derived from this Software without specific
+//       prior written permission.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
+// SOFTWARE.
+//===----------------------------------------------------------------------===//
+
+package com.amd.sumatra;
+
+import sun.misc.*;
+
+public class SumatraFactory {
+
+    public static Sumatra getSumatra() {
+        try {
+            ClassLoader cl = Launcher.getLauncher().getClassLoader();
+            Class c = Class.forName("com.oracle.graal.hotspot.hsail.ForEachToGraal", true, cl);
+            Sumatra s = (Sumatra) c.newInstance();
+            if (s != null) {
+                return s;
+            } else {
+                System.out.println("### newInstance() is null?!");
+                return null;
+            }
+        } catch (ClassNotFoundException e) {
+            System.out.println("Exception: " + e);
+            e.printStackTrace();
+            return null;
+        } catch (IllegalAccessException e) {
+            System.out.println("Exception: " + e);
+            e.printStackTrace();
+            return null;
+        } catch (ExceptionInInitializerError e) {
+            System.out.println("Exception: " + e);
+            e.printStackTrace();
+            return null;
+        } catch (InstantiationException e) {
+            System.out.println("Exception: " + e);
+            e.printStackTrace();
+            return null;
+        }
+    }
+}
\ No newline at end of file
--- /dev/null	2014-01-29 23:03:08.911280982 +0100
+++ new/graal/com.oracle.graal.hsail/src/com/amd/sumatra/SumatraUtils.java	2014-01-30 16:44:18.614201031 +0100
@@ -0,0 +1,34 @@
+package com.amd.sumatra;
+
+import java.lang.reflect.Field;
+
+public class SumatraUtils {
+    public static Object getFieldFromObject(Field f, Object fromObj) {
+        try {
+            f.setAccessible(true);
+            java.lang.reflect.Type type = f.getType();
+
+            if (type == double.class) {
+                return f.getDouble(fromObj);
+            } else if (type == float.class) {
+                return f.getFloat(fromObj);
+            } else if (type == long.class) {
+                return f.getLong(fromObj);
+            } else if (type == int.class) {
+                return f.getInt(fromObj);
+            } else if (type == byte.class) {
+                return f.getByte(fromObj);
+            } else if (type == boolean.class) {
+                return f.getBoolean(fromObj);
+            } else {
+                // object
+                return f.get(fromObj);
+            }
+        } catch (Exception e) {
+            // fail("unable to get field " + f + " from " + fromObj);
+            return null;
+        }
+
+    }
+
+}
\ No newline at end of file
--- /dev/null	2014-01-29 23:03:08.911280982 +0100
+++ new/graal/com.oracle.graal.hsail/src/java/util/stream/ForEachOps.java	2014-01-30 16:44:18.842201028 +0100
@@ -0,0 +1,428 @@
+/*
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
+ * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ */
+package java.util.stream;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.RuntimeMXBean;
+import java.util.ArrayList;
+import java.util.Spliterators;
+
+import java.util.Objects;
+import java.util.Spliterator;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountedCompleter;
+import java.util.concurrent.ForkJoinTask;
+import java.util.function.Consumer;
+import java.util.function.DoubleConsumer;
+import java.util.function.IntConsumer;
+import java.util.function.LongConsumer;
+
+/**
+ * Factory for creating instances of {@code TerminalOp} that perform an action for every element of
+ * a stream. Supported variants include unordered traversal (elements are provided to the
+ * {@code Consumer} as soon as they are available), and ordered traversal (elements are provided to
+ * the {@code Consumer} in encounter order.)
+ * 
+ * <p>
+ * Elements are provided to the {@code Consumer} on whatever thread and whatever order they become
+ * available. For ordered traversals, it is guaranteed that processing an element
+ * <em>happens-before</em> processing subsequent elements in the encounter order.
+ * 
+ * <p>
+ * Exceptions occurring as a result of sending an element to the {@code Consumer} will be relayed to
+ * the caller and traversal will be prematurely terminated.
+ * 
+ * @since 1.8
+ */
+final class ForEachOps {
+
+    private ForEachOps() {
+    }
+
+    /**
+     * Constructs a {@code TerminalOp} that perform an action for every element of a stream.
+     * 
+     * @param action the {@code Consumer} that receives all elements of a stream
+     * @param ordered whether an ordered traversal is requested
+     * @param <T> the type of the stream elements
+     * @return the {@code TerminalOp} instance
+     */
+    public static <T> TerminalOp<T, Void> makeRef(Consumer<? super T> action, boolean ordered) {
+        Objects.requireNonNull(action);
+        return new ForEachOp.OfRef<>(action, ordered);
+    }
+
+    /**
+     * Constructs a {@code TerminalOp} that perform an action for every element of an
+     * {@code IntStream}.
+     * 
+     * @param action the {@code IntConsumer} that receives all elements of a stream
+     * @param ordered whether an ordered traversal is requested
+     * @return the {@code TerminalOp} instance
+     */
+    public static TerminalOp<Integer, Void> makeInt(IntConsumer action, boolean ordered) {
+        Objects.requireNonNull(action);
+        return new ForEachOp.OfInt(action, ordered);
+    }
+
+    /**
+     * Constructs a {@code TerminalOp} that perform an action for every element of a
+     * {@code LongStream}.
+     * 
+     * @param action the {@code LongConsumer} that receives all elements of a stream
+     * @param ordered whether an ordered traversal is requested
+     * @return the {@code TerminalOp} instance
+     */
+    public static TerminalOp<Long, Void> makeLong(LongConsumer action, boolean ordered) {
+        Objects.requireNonNull(action);
+        return new ForEachOp.OfLong(action, ordered);
+    }
+
+    /**
+     * Constructs a {@code TerminalOp} that perform an action for every element of a
+     * {@code DoubleStream}.
+     * 
+     * @param action the {@code DoubleConsumer} that receives all elements of a stream
+     * @param ordered whether an ordered traversal is requested
+     * @return the {@code TerminalOp} instance
+     */
+    public static TerminalOp<Double, Void> makeDouble(DoubleConsumer action, boolean ordered) {
+        Objects.requireNonNull(action);
+        return new ForEachOp.OfDouble(action, ordered);
+    }
+
+    /**
+     * A {@code TerminalOp} that evaluates a stream pipeline and sends the output to itself as a
+     * {@code TerminalSink}. Elements will be sent in whatever thread they become available. If the
+     * traversal is unordered, they will be sent independent of the stream's encounter order.
+     * 
+     * <p>
+     * This terminal operation is stateless. For parallel evaluation, each leaf instance of a
+     * {@code ForEachTask} will send elements to the same {@code TerminalSink} reference that is an
+     * instance of this class.
+     * 
+     * @param <T> the output type of the stream pipeline
+     */
+    static abstract class ForEachOp<T> implements TerminalOp<T, Void>, TerminalSink<T, Void> {
+        private final boolean ordered;
+
+        protected ForEachOp(boolean ordered) {
+            this.ordered = ordered;
+        }
+
+        // TerminalOp
+
+        @Override
+        public int getOpFlags() {
+            return ordered ? 0 : StreamOpFlag.NOT_ORDERED;
+        }
+
+        @Override
+        public <S> Void evaluateSequential(PipelineHelper<T> helper, Spliterator<S> spliterator) {
+            return helper.wrapAndCopyInto(this, spliterator).get();
+        }
+
+        static boolean defaultExecutionModeOpenCL = Boolean.getBoolean("com.amd.sumatra.offload.immediate");
+        static boolean usesSumatraRedirect = ManagementFactory.getRuntimeMXBean().getInputArguments().contains("-XX:+UseSumatraRedirect");
+
+        static boolean supportsForEachOffload() {
+            return (defaultExecutionModeOpenCL || usesSumatraRedirect);
+        }
+
+        @Override
+        public <S> Void evaluateParallel(PipelineHelper<T> helper, Spliterator<S> spliterator) {
+            if (ordered) {
+                new ForEachOrderedTask<>(helper, spliterator, this).invoke();
+            } else {
+                Spliterator sp;
+                if (supportsForEachOffload() && (sp = PipelineInfo.offloadableSpliterator(spliterator)) != null) {
+                    parallelForEachOffloadable(sp, helper, helper.wrapSink(this));
+                } else {
+                    evaluateParallelForEachJava(helper, spliterator);
+                }
+            }
+            return null;
+        }
+
+        private <S> void parallelForEachOffloadable(Spliterator sp, PipelineHelper<T> helper, Sink<S> sink) {
+            if (defaultExecutionModeOpenCL) {
+                // immediate redirection (without waiting for compiler intrinsic) if flag set
+                // we pass "this" in case we have to call back to java
+                PipelineInfo.offloadPipeline(sp, helper, sink, this);
+            } else {
+                // this code is the original parallelForEach code
+                // may get redirected later by a compiler intrinsic;
+                evaluateParallelForEachJava(helper, sp);
+            }
+        }
+
+        <S> Void evaluateParallelForEachJava(PipelineHelper<T> helper, Spliterator<S> spliterator) {
+            new ForEachTask<>(helper, spliterator, helper.wrapSink(this)).invoke();
+            return null;
+        }
+
+        // TerminalSink
+
+        @Override
+        public Void get() {
+            return null;
+        }
+
+        // Implementations
+
+        /** Implementation class for reference streams */
+        static final class OfRef<T> extends ForEachOp<T> {
+            final Consumer<? super T> consumer;
+
+            OfRef(Consumer<? super T> consumer, boolean ordered) {
+                super(ordered);
+                this.consumer = consumer;
+            }
+
+            @Override
+            public void accept(T t) {
+                consumer.accept(t);
+            }
+        }
+
+        /** Implementation class for {@code IntStream} */
+        static final class OfInt extends ForEachOp<Integer> implements Sink.OfInt {
+            final IntConsumer consumer;
+
+            OfInt(IntConsumer consumer, boolean ordered) {
+                super(ordered);
+                this.consumer = consumer;
+            }
+
+            @Override
+            public StreamShape inputShape() {
+                return StreamShape.INT_VALUE;
+            }
+
+            @Override
+            public void accept(int t) {
+                consumer.accept(t);
+            }
+        }
+
+        /** Implementation class for {@code LongStream} */
+        static final class OfLong extends ForEachOp<Long> implements Sink.OfLong {
+            final LongConsumer consumer;
+
+            OfLong(LongConsumer consumer, boolean ordered) {
+                super(ordered);
+                this.consumer = consumer;
+            }
+
+            @Override
+            public StreamShape inputShape() {
+                return StreamShape.LONG_VALUE;
+            }
+
+            @Override
+            public void accept(long t) {
+                consumer.accept(t);
+            }
+        }
+
+        /** Implementation class for {@code DoubleStream} */
+        static final class OfDouble extends ForEachOp<Double> implements Sink.OfDouble {
+            final DoubleConsumer consumer;
+
+            OfDouble(DoubleConsumer consumer, boolean ordered) {
+                super(ordered);
+                this.consumer = consumer;
+            }
+
+            @Override
+            public StreamShape inputShape() {
+                return StreamShape.DOUBLE_VALUE;
+            }
+
+            @Override
+            public void accept(double t) {
+                consumer.accept(t);
+            }
+        }
+    }
+
+    /** A {@code ForkJoinTask} for performing a parallel for-each operation */
+    @SuppressWarnings("serial")
+    static final class ForEachTask<S, T> extends CountedCompleter<Void> {
+        private Spliterator<S> spliterator;
+        private final Sink<S> sink;
+        private final PipelineHelper<T> helper;
+        private long targetSize;
+
+        ForEachTask(PipelineHelper<T> helper, Spliterator<S> spliterator, Sink<S> sink) {
+            super(null);
+            this.sink = sink;
+            this.helper = helper;
+            this.spliterator = spliterator;
+            this.targetSize = 0L;
+        }
+
+        ForEachTask(ForEachTask<S, T> parent, Spliterator<S> spliterator) {
+            super(parent);
+            this.spliterator = spliterator;
+            this.sink = parent.sink;
+            this.targetSize = parent.targetSize;
+            this.helper = parent.helper;
+        }
+
+        // Similar to AbstractTask but doesn't need to track child tasks
+        public void compute() {
+            Spliterator<S> rightSplit = spliterator, leftSplit;
+            long sizeEstimate = rightSplit.estimateSize(), sizeThreshold;
+            if ((sizeThreshold = targetSize) == 0L)
+                targetSize = sizeThreshold = AbstractTask.suggestTargetSize(sizeEstimate);
+            boolean isShortCircuit = StreamOpFlag.SHORT_CIRCUIT.isKnown(helper.getStreamAndOpFlags());
+            boolean forkRight = false;
+            Sink<S> taskSink = sink;
+            ForEachTask<S, T> task = this;
+            while (!isShortCircuit || !taskSink.cancellationRequested()) {
+                if (sizeEstimate <= sizeThreshold || (leftSplit = rightSplit.trySplit()) == null) {
+                    task.helper.copyInto(taskSink, rightSplit);
+                    break;
+                }
+                ForEachTask<S, T> leftTask = new ForEachTask<>(task, leftSplit);
+                task.addToPendingCount(1);
+                ForEachTask<S, T> taskToFork;
+                if (forkRight) {
+                    forkRight = false;
+                    rightSplit = leftSplit;
+                    taskToFork = task;
+                    task = leftTask;
+                } else {
+                    forkRight = true;
+                    taskToFork = leftTask;
+                }
+                taskToFork.fork();
+                sizeEstimate = rightSplit.estimateSize();
+            }
+            task.spliterator = null;
+            task.propagateCompletion();
+        }
+    }
+
+    /**
+     * A {@code ForkJoinTask} for performing a parallel for-each operation which visits the elements
+     * in encounter order
+     */
+    @SuppressWarnings("serial")
+    static final class ForEachOrderedTask<S, T> extends CountedCompleter<Void> {
+        private final PipelineHelper<T> helper;
+        private Spliterator<S> spliterator;
+        private final long targetSize;
+        private final ConcurrentHashMap<ForEachOrderedTask<S, T>, ForEachOrderedTask<S, T>> completionMap;
+        private final Sink<T> action;
+        private final Object lock;
+        private final ForEachOrderedTask<S, T> leftPredecessor;
+        private Node<T> node;
+
+        protected ForEachOrderedTask(PipelineHelper<T> helper, Spliterator<S> spliterator, Sink<T> action) {
+            super(null);
+            this.helper = helper;
+            this.spliterator = spliterator;
+            this.targetSize = AbstractTask.suggestTargetSize(spliterator.estimateSize());
+            this.completionMap = new ConcurrentHashMap<>();
+            this.action = action;
+            this.lock = new Object();
+            this.leftPredecessor = null;
+        }
+
+        ForEachOrderedTask(ForEachOrderedTask<S, T> parent, Spliterator<S> spliterator, ForEachOrderedTask<S, T> leftPredecessor) {
+            super(parent);
+            this.helper = parent.helper;
+            this.spliterator = spliterator;
+            this.targetSize = parent.targetSize;
+            this.completionMap = parent.completionMap;
+            this.action = parent.action;
+            this.lock = parent.lock;
+            this.leftPredecessor = leftPredecessor;
+        }
+
+        @Override
+        public final void compute() {
+            doCompute(this);
+        }
+
+        private static <S, T> void doCompute(ForEachOrderedTask<S, T> task) {
+            Spliterator<S> rightSplit = task.spliterator, leftSplit;
+            long sizeThreshold = task.targetSize;
+            boolean forkRight = false;
+            while (rightSplit.estimateSize() > sizeThreshold && (leftSplit = rightSplit.trySplit()) != null) {
+                ForEachOrderedTask<S, T> leftChild = new ForEachOrderedTask<>(task, leftSplit, task.leftPredecessor);
+                ForEachOrderedTask<S, T> rightChild = new ForEachOrderedTask<>(task, rightSplit, leftChild);
+                task.completionMap.put(leftChild, rightChild);
+                task.addToPendingCount(1); // forking
+                rightChild.addToPendingCount(1); // right pending on left child
+                if (task.leftPredecessor != null) {
+                    leftChild.addToPendingCount(1); // left pending on previous subtree, except left
+// spine
+                    if (task.completionMap.replace(task.leftPredecessor, task, leftChild))
+                        task.addToPendingCount(-1); // transfer my "right child" count to my left
+// child
+                    else
+                        leftChild.addToPendingCount(-1); // left child is ready to go when ready
+                }
+                ForEachOrderedTask<S, T> taskToFork;
+                if (forkRight) {
+                    forkRight = false;
+                    rightSplit = leftSplit;
+                    task = leftChild;
+                    taskToFork = rightChild;
+                } else {
+                    forkRight = true;
+                    task = rightChild;
+                    taskToFork = leftChild;
+                }
+                taskToFork.fork();
+            }
+            if (task.getPendingCount() == 0) {
+                task.helper.wrapAndCopyInto(task.action, rightSplit);
+            } else {
+                Node.Builder<T> nb = task.helper.makeNodeBuilder(task.helper.exactOutputSizeIfKnown(rightSplit), size -> (T[]) new Object[size]);
+                task.node = task.helper.wrapAndCopyInto(nb, rightSplit).build();
+            }
+            task.tryComplete();
+        }
+
+        @Override
+        public void onCompletion(CountedCompleter<?> caller) {
+            spliterator = null;
+            if (node != null) {
+                // Dump any data from this leaf into the sink
+                synchronized (lock) {
+                    node.forEach(action);
+                }
+                node = null;
+            }
+            ForEachOrderedTask<S, T> victim = completionMap.remove(this);
+            if (victim != null)
+                victim.tryComplete();
+        }
+    }
+}
--- /dev/null	2014-01-29 23:03:08.911280982 +0100
+++ new/graal/com.oracle.graal.hsail/src/java/util/stream/PipelineInfo.java	2014-01-30 16:44:19.070201024 +0100
@@ -0,0 +1,372 @@
+package java.util.stream;
+
+import java.util.Spliterators;
+import java.util.Spliterator;
+import java.util.concurrent.CountedCompleter;
+import java.util.function.Supplier;
+
+import com.amd.sumatra.SumatraUtils;
+import java.util.function.IntConsumer;
+import java.lang.reflect.Method;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.lang.Class;
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.amd.sumatra.Sumatra;
+import com.amd.sumatra.SumatraFactory;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+public class PipelineInfo {
+
+    // implemented by an ArrayList of PipelineInfo.Entry elements
+    private ArrayList<Entry> plist = new ArrayList<>();
+
+    public void add(Entry entry) {
+        plist.add(entry);
+    }
+
+    public Entry get(int n) {
+        return plist.get(n);
+    }
+
+    public int size() {
+        return plist.size();
+    }
+
+    public void show() {
+        int opNum = 0;
+        for (Entry entry : plist) {
+            opNum++;
+            System.out.println("Op #" + opNum + entry);
+        }
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (!(other instanceof PipelineInfo)) {
+            return false;
+        }
+        PipelineInfo otherInfo = (PipelineInfo) other;
+        return (plist.equals(otherInfo.plist));
+    }
+
+    @Override
+    public int hashCode() {
+        return plist.hashCode();
+    }
+
+    static public enum OpType {
+        UNKNOWN, FILTER, PEEK, FOREACH
+    };
+
+    static public enum DataType {
+        UNKNOWN, INT, OBJ
+    };
+
+    public static class Entry {
+        public OpType op;               // what kind of op
+        public DataType dtype;          // what type of data
+        public Class<?> lambdaClass;    // class of lambda to call
+        public Object lambdaObj;      // actual lambda object from this capture
+
+        Entry(String klassName) {
+            // hack alert, there should be a way to do this that is not dependent on the
+            // order of the innerclass declarations
+            if (klassName.endsWith("IntPipeline$9$1")) {
+                setOpData(OpType.FILTER, DataType.INT);
+            } else if (klassName.endsWith("IntPipeline$10$1")) {
+                setOpData(OpType.PEEK, DataType.INT);
+            } else if (klassName.endsWith("ReferencePipeline$2$1")) {
+                setOpData(OpType.FILTER, DataType.OBJ);
+            } else if (klassName.endsWith("ReferencePipeline$11$1")) {
+                setOpData(OpType.PEEK, DataType.OBJ);
+            } else if (klassName.contains("ForEachOps$ForEachOp$")) {
+                setOpData(OpType.FOREACH, DataType.UNKNOWN);
+            } else {
+                System.out.println("WARNING: unmatched class name " + klassName + " in PipelineInfo.Entry constructor");
+                setOpData(OpType.UNKNOWN, DataType.UNKNOWN);
+            }
+        }
+
+        private void setOpData(OpType _op, DataType _dtype) {
+            op = _op;
+            dtype = _dtype;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            // on purpose we say that there are equal ignoring the lambdaObj fields
+            if (!(other instanceof Entry)) {
+                return false;
+            }
+            Entry otherEntry = (Entry) other;
+            return ((op.equals(otherEntry.op)) && (dtype.equals(otherEntry.dtype)) && (lambdaClass.equals(otherEntry.lambdaClass)));
+        }
+
+        @Override
+        public int hashCode() {
+            // on purpose we don't hash in the lambdaObj field
+            int hashOp = op.hashCode();
+            int hashDtype = dtype.hashCode();
+            int hashClass = lambdaClass.hashCode();
+            return (hashOp + hashDtype + hashClass) * hashClass + hashOp;
+        }
+
+        public String toString() {
+            return (", op=" + op + ", dtype=" + dtype + ", lambdaObj=" + lambdaObj);
+        }
+    }
+
+    static Field findFieldStartsWith(Class<?> klass, String startStr) {
+        Field[] fields = klass.getDeclaredFields();
+        for (Field f : fields) {
+            if (f.getName().startsWith(startStr)) {
+                return f;
+            }
+        }
+        // if we got this far, no such field
+        return null;
+    }
+
+    static boolean pipelineDebugPrint = Boolean.getBoolean("pipelineDebugPrint");
+
+    static void debugPrint(String str) {
+        if (pipelineDebugPrint) {
+            System.out.println(str);
+        }
+    }
+
+    public static <P_IN> PipelineInfo deducePipeline(Sink<P_IN> sink) {
+        PipelineInfo info = new PipelineInfo();
+        try {
+            Object curSink = sink;
+            int opNum = 1;
+            while (curSink != null) {
+                Class<?> curSinkKlass = curSink.getClass();
+                String sinkKlassName = curSinkKlass.getName();
+                Entry entry = new Entry(sinkKlassName);
+
+                // val field is in this$1 for peek, filter etc
+                Field thisField = findFieldStartsWith(curSinkKlass, "this$1");
+                Field curSinkLambdaField = null;
+                Object curSinkLambda = null;
+                if (thisField != null) {
+                    // long thisOffset = UnsafeWrapper.objectFieldOffset(thisField);
+                    // Get pipeline object from sink
+                    // Object pipeline = UnsafeWrapper.getObject(curSink, thisOffset);
+                    Object pipeline = SumatraUtils.getFieldFromObject(thisField, curSink);
+// System.out.println("deducePipeline: " + curSinkKlass.getName()
+// + "... thisOffset= " + thisOffset
+// + "... pipeline= " + pipeline);
+                    // lambda is in val$cap$0 or arg$1
+                    curSinkLambdaField = findFieldStartsWith(pipeline.getClass(), "val$");
+                    // long offset = UnsafeWrapper.objectFieldOffset(curSinkLambdaField);
+                    // curSinkLambda = UnsafeWrapper.getObject(pipeline, offset);
+                    curSinkLambda = SumatraUtils.getFieldFromObject(curSinkLambdaField, pipeline);
+                } else {
+                    // It is a java.util.stream.ForEachOps$ForEachOp
+// System.out.println("curSinkKlass = " + curSinkKlass.getName());
+                    curSinkLambdaField = findFieldStartsWith(curSinkKlass, "consumer");
+                    if (curSinkLambdaField != null) {
+                        // long offset = UnsafeWrapper.objectFieldOffset(curSinkLambdaField);
+                        // curSinkLambda = UnsafeWrapper.getObject(curSink, offset);
+                        curSinkLambda = SumatraUtils.getFieldFromObject(curSinkLambdaField, curSink);
+                    } else {
+                        System.out.println("WARNING: Did not find consumer field in " + curSink);
+                    }
+                }
+
+                if (curSinkLambda == null) {
+                    System.out.println("WARNING: cannot determine lambda from " + curSink);
+                } else {
+                    entry.lambdaObj = curSinkLambda;
+                    entry.lambdaClass = curSinkLambda.getClass();
+// System.out.println("entry.lambdaObj: " + entry.lambdaObj
+// + " ... entry.lambdaClass=" + entry.lambdaClass);
+                }
+
+                // to move to the next downstream entry
+                Class<?> curSinkSupKlass = curSinkKlass.getSuperclass();
+                Field downstreamField = findFieldStartsWith(curSinkSupKlass, "downstream");
+                Object downstream;
+                if (downstreamField != null) {
+                    Class<?> downstreamKlass = downstreamField.getType();
+                    downstream = downstreamField.get(curSink);
+                } else {
+                    downstream = null;   // at the terminal op
+                }
+                info.add(entry);
+
+                // for next iteration
+                curSink = downstream;
+                opNum++;
+            }
+
+        } catch (Exception e) {
+            e.printStackTrace();
+            return null;
+        }
+        return info;
+    }
+
+    public static boolean isRangeIntSpliterator(Spliterator sp) {
+        return (sp instanceof Streams.RangeIntSpliterator);
+    }
+
+    static final ConcurrentHashMap<PipelineInfo, Object> pipelineKernels = new ConcurrentHashMap<>();
+    static final ConcurrentHashMap<PipelineInfo, Boolean> haveGoodPipelineKernel = new ConcurrentHashMap<>();
+
+    static boolean neverRevertToJava = Boolean.getBoolean("com.amd.sumatra.neverRevertToJava");
+
+    static Sumatra sumatra = SumatraFactory.getSumatra();
+
+    public static <P_OUT> void revertParallelForEachJava(Spliterator sp, PipelineHelper<P_OUT> helper, Object forEachOpInstance) {
+        ((ForEachOps.ForEachOp) forEachOpInstance).evaluateParallelForEachJava(helper, sp);
+    }
+
+    static final String[] arrayBasedCollectionSpliteratorNames = {"java.util.ArrayList$ArrayListSpliterator", "java.util.Vector$VectorSpliterator"};
+
+    static ArrayList<String> arrayBasedCollectionSpliterators;
+
+    static {
+        arrayBasedCollectionSpliterators = new ArrayList<String>(arrayBasedCollectionSpliteratorNames.length);
+        for (int i = 0; i < arrayBasedCollectionSpliteratorNames.length; i++) {
+            arrayBasedCollectionSpliterators.add(arrayBasedCollectionSpliteratorNames[i]);
+        }
+    }
+
+    static <S> Spliterator offloadableSpliterator(Spliterator sp) {
+        // don't have to check parallel, we got here from parallelForEach
+        // any array spliterator is legal, I guess
+
+        if (isArraySpliterator(sp)) {
+            return sp;
+        } else if (PipelineInfo.isRangeIntSpliterator(sp)) {
+            // certain kinds of intRangeSpliterators are ok
+            Streams.RangeIntSpliterator risp = (Streams.RangeIntSpliterator) sp;
+            if (risp.getFrom() == 0) {
+                return sp;
+            }
+        } else if (arrayBasedCollectionSpliterators.contains(sp.getClass().getName())) {
+            return sp;
+        }
+        // if we got this far, it's not OK
+        return null;
+    }
+
+    static final String NEWLINE = System.getProperty("line.separator");
+    static final String REVERT_MSG = "WARNING: reverting to java, offload kernel could not be created." + NEWLINE + "Check HSAIL tools are on your PATH and LD_LIBRARY_PATH" + NEWLINE +
+                    "and on the sun.boot.library.path";
+
+    static public <P_IN, P_OUT> void offloadPipeline(Spliterator sp, PipelineHelper<P_OUT> helper, Sink<P_IN> sink, Object forEachOpInstance) {
+
+        PipelineInfo pipelineInfo = null;
+        Boolean haveKernel;
+        boolean isObjectLambda = false;
+        boolean success = false;
+        try {
+            pipelineInfo = PipelineInfo.deducePipeline(sink);
+            Object okraKernel = null;
+            isObjectLambda = !PipelineInfo.isRangeIntSpliterator(sp);
+            // for now we only handle pipeline sizes of 1
+            if (pipelineInfo.size() == 1) {
+                Object consumer = pipelineInfo.get(0).lambdaObj;
+                Class consumerClass = consumer.getClass();
+                haveKernel = haveGoodPipelineKernel.get(pipelineInfo);
+                if (haveKernel == null) {
+                    okraKernel = sumatra.createKernel(consumerClass);
+                    if (okraKernel != null) {
+                        // Store result for later call like kernels
+                        pipelineKernels.put(pipelineInfo, okraKernel);
+                        haveGoodPipelineKernel.put(pipelineInfo, true);
+                    } else {
+                        System.out.println(REVERT_MSG);
+                        haveGoodPipelineKernel.put(pipelineInfo, false);
+                    }
+                } else if (haveKernel == true) {
+                    okraKernel = pipelineKernels.get(pipelineInfo);
+                }
+
+                // now if we have a kernel, dispatch to it
+                if (okraKernel != null) {
+                    // try to dispatch
+                    // Extract actual args from Consumer
+                    // Push args using okra api
+
+                    Field[] fields = consumerClass.getDeclaredFields();
+                    ArrayList<Object> args = new ArrayList<Object>();
+                    int argIndex = 0;
+                    for (Field f : fields) {
+                        // logger.info("... " + f);
+                        args.add(SumatraUtils.getFieldFromObject(f, consumer));
+                    }
+
+                    // Secretly pass in the source array reference, each element
+                    // will be retrieved using the workitem id
+                    if (isObjectLambda) {
+                        Field f;
+                        String spName = sp.getClass().getName();
+                        if (arrayBasedCollectionSpliterators.contains(spName) == true) {
+                            Field listField = sp.getClass().getDeclaredField("list");
+                            AbstractList list = (AbstractList) SumatraUtils.getFieldFromObject(listField, sp);
+                            // We want ArrayList.elementData
+                            f = list.getClass().getDeclaredField("elementData");
+                            args.add(SumatraUtils.getFieldFromObject(f, list));
+                        } else {
+                            // We want ArraySpliterator.array
+                            f = sp.getClass().getDeclaredField("array");
+                            args.add(SumatraUtils.getFieldFromObject(f, sp));
+                        }
+                    }
+                    success = sumatra.dispatchKernel(okraKernel, (int) sp.estimateSize(), args.toArray());
+                }
+            }
+        } catch (Exception e) {
+            System.err.println(e);
+            e.printStackTrace();
+
+            if (pipelineInfo != null) {
+                haveGoodPipelineKernel.put(pipelineInfo, false);
+            }
+
+        } catch (UnsatisfiedLinkError e) {
+            System.err.println(e);
+            e.printStackTrace();
+
+            if (pipelineInfo != null) {
+                haveGoodPipelineKernel.put(pipelineInfo, false);
+            }
+        }
+
+        // check success flag, if false revert to java
+        if (!success) {
+            forEachOpenCLPipelineRevertToJava(sp, helper, forEachOpInstance);
+        }
+    }
+
+    static <P_OUT> void forEachOpenCLPipelineRevertToJava(Spliterator sp, PipelineHelper<P_OUT> helper, Object forEachOpInstance) {
+
+        // the following flag would normally be set in testing mode
+        // when we want to consider the need to revert to java a failure
+        if (neverRevertToJava) {
+            // cause an unchecked exception
+            throw new RuntimeException("configured to never revert to Java");
+        }
+
+        // get here if it is OK to revert to Java
+        // call back to the java fork-join version
+        // (call back thru PipelineInfo to avoid having to make the target class public)
+        PipelineInfo.revertParallelForEachJava(sp, helper, forEachOpInstance);
+    }
+
+    // Sumatra Helper
+    public static boolean isArraySpliterator(Spliterator sp) {
+        String spName = sp.getClass().getName();
+        return spName.equals("java.util.Spliterators$ArraySpliterator");
+    }
+
+}
--- /dev/null	2014-01-29 23:03:08.911280982 +0100
+++ new/graal/com.oracle.graal.hsail/src/java/util/stream/Streams.java	2014-01-30 16:44:19.286201020 +0100
@@ -0,0 +1,856 @@
+/*
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
+ * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ */
+package java.util.stream;
+
+import java.util.Comparator;
+import java.util.Objects;
+import java.util.Spliterator;
+import java.util.function.Consumer;
+import java.util.function.DoubleConsumer;
+import java.util.function.IntConsumer;
+import java.util.function.LongConsumer;
+
+/**
+ * Utility methods for operating on and creating streams.
+ * 
+ * <p>
+ * Unless otherwise stated, streams are created as sequential streams. A sequential stream can be
+ * transformed into a parallel stream by calling the {@code parallel()} method on the created
+ * stream.
+ * 
+ * @since 1.8
+ */
+final class Streams {
+
+    private Streams() {
+        throw new Error("no instances");
+    }
+
+    /**
+     * An object instance representing no value, that cannot be an actual data element of a stream.
+     * Used when processing streams that can contain {@code null} elements to distinguish between a
+     * {@code null} value and no value.
+     */
+    static final Object NONE = new Object();
+
+    /**
+     * An {@code int} range spliterator.
+     */
+    static final class RangeIntSpliterator implements Spliterator.OfInt {
+        // Can never be greater that upTo, this avoids overflow if upper bound
+        // is Integer.MAX_VALUE
+        // All elements are traversed if from == upTo & last == 0
+        private int from;
+        private final int upTo;
+        // 1 if the range is closed and the last element has not been traversed
+        // Otherwise, 0 if the range is open, or is a closed range and all
+        // elements have been traversed
+        private int last;
+
+        int getFrom() {
+            return from;
+        }
+
+        int getUpTo() {
+            return upTo;
+        }
+
+        RangeIntSpliterator(int from, int upTo, boolean closed) {
+            this(from, upTo, closed ? 1 : 0);
+        }
+
+        private RangeIntSpliterator(int from, int upTo, int last) {
+            this.from = from;
+            this.upTo = upTo;
+            this.last = last;
+        }
+
+        @Override
+        public boolean tryAdvance(IntConsumer consumer) {
+            Objects.requireNonNull(consumer);
+
+            final int i = from;
+            if (i < upTo) {
+                from++;
+                consumer.accept(i);
+                return true;
+            } else if (last > 0) {
+                last = 0;
+                consumer.accept(i);
+                return true;
+            }
+            return false;
+        }
+
+        @Override
+        public void forEachRemaining(IntConsumer consumer) {
+            Objects.requireNonNull(consumer);
+
+            int i = from;
+            final int hUpTo = upTo;
+            int hLast = last;
+            from = upTo;
+            last = 0;
+            while (i < hUpTo) {
+                consumer.accept(i++);
+            }
+            if (hLast > 0) {
+                // Last element of closed range
+                consumer.accept(i);
+            }
+        }
+
+        @Override
+        public long estimateSize() {
+            // Ensure ranges of size > Integer.MAX_VALUE report the correct size
+            return ((long) upTo) - from + last;
+        }
+
+        @Override
+        public int characteristics() {
+            return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.IMMUTABLE | Spliterator.NONNULL | Spliterator.DISTINCT | Spliterator.SORTED;
+        }
+
+        @Override
+        public Comparator<? super Integer> getComparator() {
+            return null;
+        }
+
+        @Override
+        public Spliterator.OfInt trySplit() {
+            long size = estimateSize();
+            return size <= 1 ? null
+            // Left split always has a half-open range
+                            : new RangeIntSpliterator(from, from = from + splitPoint(size), 0);
+        }
+
+        /**
+         * The spliterator size below which the spliterator will be split at the mid-point to
+         * produce balanced splits. Above this size the spliterator will be split at a ratio of
+         * 1:(RIGHT_BALANCED_SPLIT_RATIO - 1) to produce right-balanced splits.
+         * 
+         * <p>
+         * Such splitting ensures that for very large ranges that the left side of the range will
+         * more likely be processed at a lower-depth than a balanced tree at the expense of a
+         * higher-depth for the right side of the range.
+         * 
+         * <p>
+         * This is optimized for cases such as IntStream.ints() that is implemented as range of 0 to
+         * Integer.MAX_VALUE but is likely to be augmented with a limit operation that limits the
+         * number of elements to a count lower than this threshold.
+         */
+        private static final int BALANCED_SPLIT_THRESHOLD = 1 << 24;
+
+        /**
+         * The split ratio of the left and right split when the spliterator size is above
+         * BALANCED_SPLIT_THRESHOLD.
+         */
+        private static final int RIGHT_BALANCED_SPLIT_RATIO = 1 << 3;
+
+        private int splitPoint(long size) {
+            int d = (size < BALANCED_SPLIT_THRESHOLD) ? 2 : RIGHT_BALANCED_SPLIT_RATIO;
+            // Cast to int is safe since:
+            // 2 <= size < 2^32
+            // 2 <= d <= 8
+            return (int) (size / d);
+        }
+    }
+
+    /**
+     * A {@code long} range spliterator.
+     * 
+     * This implementation cannot be used for ranges whose size is greater than Long.MAX_VALUE
+     */
+    static final class RangeLongSpliterator implements Spliterator.OfLong {
+        // Can never be greater that upTo, this avoids overflow if upper bound
+        // is Long.MAX_VALUE
+        // All elements are traversed if from == upTo & last == 0
+        private long from;
+        private final long upTo;
+        // 1 if the range is closed and the last element has not been traversed
+        // Otherwise, 0 if the range is open, or is a closed range and all
+        // elements have been traversed
+        private int last;
+
+        RangeLongSpliterator(long from, long upTo, boolean closed) {
+            this(from, upTo, closed ? 1 : 0);
+        }
+
+        private RangeLongSpliterator(long from, long upTo, int last) {
+            assert upTo - from + last > 0;
+            this.from = from;
+            this.upTo = upTo;
+            this.last = last;
+        }
+
+        @Override
+        public boolean tryAdvance(LongConsumer consumer) {
+            Objects.requireNonNull(consumer);
+
+            final long i = from;
+            if (i < upTo) {
+                from++;
+                consumer.accept(i);
+                return true;
+            } else if (last > 0) {
+                last = 0;
+                consumer.accept(i);
+                return true;
+            }
+            return false;
+        }
+
+        @Override
+        public void forEachRemaining(LongConsumer consumer) {
+            Objects.requireNonNull(consumer);
+
+            long i = from;
+            final long hUpTo = upTo;
+            int hLast = last;
+            from = upTo;
+            last = 0;
+            while (i < hUpTo) {
+                consumer.accept(i++);
+            }
+            if (hLast > 0) {
+                // Last element of closed range
+                consumer.accept(i);
+            }
+        }
+
+        @Override
+        public long estimateSize() {
+            return upTo - from + last;
+        }
+
+        @Override
+        public int characteristics() {
+            return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.IMMUTABLE | Spliterator.NONNULL | Spliterator.DISTINCT | Spliterator.SORTED;
+        }
+
+        @Override
+        public Comparator<? super Long> getComparator() {
+            return null;
+        }
+
+        @Override
+        public Spliterator.OfLong trySplit() {
+            long size = estimateSize();
+            return size <= 1 ? null
+            // Left split always has a half-open range
+                            : new RangeLongSpliterator(from, from = from + splitPoint(size), 0);
+        }
+
+        /**
+         * The spliterator size below which the spliterator will be split at the mid-point to
+         * produce balanced splits. Above this size the spliterator will be split at a ratio of
+         * 1:(RIGHT_BALANCED_SPLIT_RATIO - 1) to produce right-balanced splits.
+         * 
+         * <p>
+         * Such splitting ensures that for very large ranges that the left side of the range will
+         * more likely be processed at a lower-depth than a balanced tree at the expense of a
+         * higher-depth for the right side of the range.
+         * 
+         * <p>
+         * This is optimized for cases such as LongStream.longs() that is implemented as range of 0
+         * to Long.MAX_VALUE but is likely to be augmented with a limit operation that limits the
+         * number of elements to a count lower than this threshold.
+         */
+        private static final long BALANCED_SPLIT_THRESHOLD = 1 << 24;
+
+        /**
+         * The split ratio of the left and right split when the spliterator size is above
+         * BALANCED_SPLIT_THRESHOLD.
+         */
+        private static final long RIGHT_BALANCED_SPLIT_RATIO = 1 << 3;
+
+        private long splitPoint(long size) {
+            long d = (size < BALANCED_SPLIT_THRESHOLD) ? 2 : RIGHT_BALANCED_SPLIT_RATIO;
+            // 2 <= size <= Long.MAX_VALUE
+            return size / d;
+        }
+    }
+
+    private static abstract class AbstractStreamBuilderImpl<T, S extends Spliterator<T>> implements Spliterator<T> {
+        // >= 0 when building, < 0 when built
+        // -1 == no elements
+        // -2 == one element, held by first
+        // -3 == two or more elements, held by buffer
+        int count;
+
+        // Spliterator implementation for 0 or 1 element
+        // count == -1 for no elements
+        // count == -2 for one element held by first
+
+        @Override
+        public S trySplit() {
+            return null;
+        }
+
+        @Override
+        public long estimateSize() {
+            return -count - 1;
+        }
+
+        @Override
+        public int characteristics() {
+            return Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED | Spliterator.IMMUTABLE;
+        }
+    }
+
+    static final class StreamBuilderImpl<T> extends AbstractStreamBuilderImpl<T, Spliterator<T>> implements Stream.Builder<T> {
+        // The first element in the stream
+        // valid if count == 1
+        T first;
+
+        // The first and subsequent elements in the stream
+        // non-null if count == 2
+        SpinedBuffer<T> buffer;
+
+        /**
+         * Constructor for building a stream of 0 or more elements.
+         */
+        StreamBuilderImpl() {
+        }
+
+        /**
+         * Constructor for a singleton stream.
+         * 
+         * @param t the single element
+         */
+        StreamBuilderImpl(T t) {
+            first = t;
+            count = -2;
+        }
+
+        // StreamBuilder implementation
+
+        @Override
+        public void accept(T t) {
+            if (count == 0) {
+                first = t;
+                count++;
+            } else if (count > 0) {
+                if (buffer == null) {
+                    buffer = new SpinedBuffer<>();
+                    buffer.accept(first);
+                    count++;
+                }
+
+                buffer.accept(t);
+            } else {
+                throw new IllegalStateException();
+            }
+        }
+
+        public Stream.Builder<T> add(T t) {
+            accept(t);
+            return this;
+        }
+
+        @Override
+        public Stream<T> build() {
+            int c = count;
+            if (c >= 0) {
+                // Switch count to negative value signalling the builder is built
+                count = -count - 1;
+                // Use this spliterator if 0 or 1 elements, otherwise use
+                // the spliterator of the spined buffer
+                return (c < 2) ? StreamSupport.stream(this, false) : StreamSupport.stream(buffer.spliterator(), false);
+            }
+
+            throw new IllegalStateException();
+        }
+
+        // Spliterator implementation for 0 or 1 element
+        // count == -1 for no elements
+        // count == -2 for one element held by first
+
+        @Override
+        public boolean tryAdvance(Consumer<? super T> action) {
+            Objects.requireNonNull(action);
+
+            if (count == -2) {
+                action.accept(first);
+                count = -1;
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        @Override
+        public void forEachRemaining(Consumer<? super T> action) {
+            Objects.requireNonNull(action);
+
+            if (count == -2) {
+                action.accept(first);
+                count = -1;
+            }
+        }
+    }
+
+    static final class IntStreamBuilderImpl extends AbstractStreamBuilderImpl<Integer, Spliterator.OfInt> implements IntStream.Builder, Spliterator.OfInt {
+        // The first element in the stream
+        // valid if count == 1
+        int first;
+
+        // The first and subsequent elements in the stream
+        // non-null if count == 2
+        SpinedBuffer.OfInt buffer;
+
+        /**
+         * Constructor for building a stream of 0 or more elements.
+         */
+        IntStreamBuilderImpl() {
+        }
+
+        /**
+         * Constructor for a singleton stream.
+         * 
+         * @param t the single element
+         */
+        IntStreamBuilderImpl(int t) {
+            first = t;
+            count = -2;
+        }
+
+        // StreamBuilder implementation
+
+        @Override
+        public void accept(int t) {
+            if (count == 0) {
+                first = t;
+                count++;
+            } else if (count > 0) {
+                if (buffer == null) {
+                    buffer = new SpinedBuffer.OfInt();
+                    buffer.accept(first);
+                    count++;
+                }
+
+                buffer.accept(t);
+            } else {
+                throw new IllegalStateException();
+            }
+        }
+
+        @Override
+        public IntStream build() {
+            int c = count;
+            if (c >= 0) {
+                // Switch count to negative value signalling the builder is built
+                count = -count - 1;
+                // Use this spliterator if 0 or 1 elements, otherwise use
+                // the spliterator of the spined buffer
+                return (c < 2) ? StreamSupport.intStream(this, false) : StreamSupport.intStream(buffer.spliterator(), false);
+            }
+
+            throw new IllegalStateException();
+        }
+
+        // Spliterator implementation for 0 or 1 element
+        // count == -1 for no elements
+        // count == -2 for one element held by first
+
+        @Override
+        public boolean tryAdvance(IntConsumer action) {
+            Objects.requireNonNull(action);
+
+            if (count == -2) {
+                action.accept(first);
+                count = -1;
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        @Override
+        public void forEachRemaining(IntConsumer action) {
+            Objects.requireNonNull(action);
+
+            if (count == -2) {
+                action.accept(first);
+                count = -1;
+            }
+        }
+    }
+
+    static final class LongStreamBuilderImpl extends AbstractStreamBuilderImpl<Long, Spliterator.OfLong> implements LongStream.Builder, Spliterator.OfLong {
+        // The first element in the stream
+        // valid if count == 1
+        long first;
+
+        // The first and subsequent elements in the stream
+        // non-null if count == 2
+        SpinedBuffer.OfLong buffer;
+
+        /**
+         * Constructor for building a stream of 0 or more elements.
+         */
+        LongStreamBuilderImpl() {
+        }
+
+        /**
+         * Constructor for a singleton stream.
+         * 
+         * @param t the single element
+         */
+        LongStreamBuilderImpl(long t) {
+            first = t;
+            count = -2;
+        }
+
+        // StreamBuilder implementation
+
+        @Override
+        public void accept(long t) {
+            if (count == 0) {
+                first = t;
+                count++;
+            } else if (count > 0) {
+                if (buffer == null) {
+                    buffer = new SpinedBuffer.OfLong();
+                    buffer.accept(first);
+                    count++;
+                }
+
+                buffer.accept(t);
+            } else {
+                throw new IllegalStateException();
+            }
+        }
+
+        @Override
+        public LongStream build() {
+            int c = count;
+            if (c >= 0) {
+                // Switch count to negative value signalling the builder is built
+                count = -count - 1;
+                // Use this spliterator if 0 or 1 elements, otherwise use
+                // the spliterator of the spined buffer
+                return (c < 2) ? StreamSupport.longStream(this, false) : StreamSupport.longStream(buffer.spliterator(), false);
+            }
+
+            throw new IllegalStateException();
+        }
+
+        // Spliterator implementation for 0 or 1 element
+        // count == -1 for no elements
+        // count == -2 for one element held by first
+
+        @Override
+        public boolean tryAdvance(LongConsumer action) {
+            Objects.requireNonNull(action);
+
+            if (count == -2) {
+                action.accept(first);
+                count = -1;
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        @Override
+        public void forEachRemaining(LongConsumer action) {
+            Objects.requireNonNull(action);
+
+            if (count == -2) {
+                action.accept(first);
+                count = -1;
+            }
+        }
+    }
+
+    static final class DoubleStreamBuilderImpl extends AbstractStreamBuilderImpl<Double, Spliterator.OfDouble> implements DoubleStream.Builder, Spliterator.OfDouble {
+        // The first element in the stream
+        // valid if count == 1
+        double first;
+
+        // The first and subsequent elements in the stream
+        // non-null if count == 2
+        SpinedBuffer.OfDouble buffer;
+
+        /**
+         * Constructor for building a stream of 0 or more elements.
+         */
+        DoubleStreamBuilderImpl() {
+        }
+
+        /**
+         * Constructor for a singleton stream.
+         * 
+         * @param t the single element
+         */
+        DoubleStreamBuilderImpl(double t) {
+            first = t;
+            count = -2;
+        }
+
+        // StreamBuilder implementation
+
+        @Override
+        public void accept(double t) {
+            if (count == 0) {
+                first = t;
+                count++;
+            } else if (count > 0) {
+                if (buffer == null) {
+                    buffer = new SpinedBuffer.OfDouble();
+                    buffer.accept(first);
+                    count++;
+                }
+
+                buffer.accept(t);
+            } else {
+                throw new IllegalStateException();
+            }
+        }
+
+        @Override
+        public DoubleStream build() {
+            int c = count;
+            if (c >= 0) {
+                // Switch count to negative value signalling the builder is built
+                count = -count - 1;
+                // Use this spliterator if 0 or 1 elements, otherwise use
+                // the spliterator of the spined buffer
+                return (c < 2) ? StreamSupport.doubleStream(this, false) : StreamSupport.doubleStream(buffer.spliterator(), false);
+            }
+
+            throw new IllegalStateException();
+        }
+
+        // Spliterator implementation for 0 or 1 element
+        // count == -1 for no elements
+        // count == -2 for one element held by first
+
+        @Override
+        public boolean tryAdvance(DoubleConsumer action) {
+            Objects.requireNonNull(action);
+
+            if (count == -2) {
+                action.accept(first);
+                count = -1;
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        @Override
+        public void forEachRemaining(DoubleConsumer action) {
+            Objects.requireNonNull(action);
+
+            if (count == -2) {
+                action.accept(first);
+                count = -1;
+            }
+        }
+    }
+
+    abstract static class ConcatSpliterator<T, T_SPLITR extends Spliterator<T>> implements Spliterator<T> {
+        protected final T_SPLITR aSpliterator;
+        protected final T_SPLITR bSpliterator;
+        // True when no split has occurred, otherwise false
+        boolean beforeSplit;
+        // Never read after splitting
+        final boolean unsized;
+
+        public ConcatSpliterator(T_SPLITR aSpliterator, T_SPLITR bSpliterator) {
+            this.aSpliterator = aSpliterator;
+            this.bSpliterator = bSpliterator;
+            beforeSplit = true;
+            // The spliterator is known to be unsized before splitting if the
+            // sum of the estimates overflows.
+            unsized = aSpliterator.estimateSize() + bSpliterator.estimateSize() < 0;
+        }
+
+        @Override
+        public T_SPLITR trySplit() {
+            T_SPLITR ret = beforeSplit ? aSpliterator : (T_SPLITR) bSpliterator.trySplit();
+            beforeSplit = false;
+            return ret;
+        }
+
+        @Override
+        public boolean tryAdvance(Consumer<? super T> consumer) {
+            boolean hasNext;
+            if (beforeSplit) {
+                hasNext = aSpliterator.tryAdvance(consumer);
+                if (!hasNext) {
+                    beforeSplit = false;
+                    hasNext = bSpliterator.tryAdvance(consumer);
+                }
+            } else
+                hasNext = bSpliterator.tryAdvance(consumer);
+            return hasNext;
+        }
+
+        @Override
+        public void forEachRemaining(Consumer<? super T> consumer) {
+            if (beforeSplit)
+                aSpliterator.forEachRemaining(consumer);
+            bSpliterator.forEachRemaining(consumer);
+        }
+
+        @Override
+        public long estimateSize() {
+            if (beforeSplit) {
+                // If one or both estimates are Long.MAX_VALUE then the sum
+                // will either be Long.MAX_VALUE or overflow to a negative value
+                long size = aSpliterator.estimateSize() + bSpliterator.estimateSize();
+                return (size >= 0) ? size : Long.MAX_VALUE;
+            } else {
+                return bSpliterator.estimateSize();
+            }
+        }
+
+        @Override
+        public int characteristics() {
+            if (beforeSplit) {
+                // Concatenation loses DISTINCT and SORTED characteristics
+                return aSpliterator.characteristics() & bSpliterator.characteristics() & ~(Spliterator.DISTINCT | Spliterator.SORTED | (unsized ? Spliterator.SIZED | Spliterator.SUBSIZED : 0));
+            } else {
+                return bSpliterator.characteristics();
+            }
+        }
+
+        @Override
+        public Comparator<? super T> getComparator() {
+            if (beforeSplit)
+                throw new IllegalStateException();
+            return bSpliterator.getComparator();
+        }
+
+        static class OfRef<T> extends ConcatSpliterator<T, Spliterator<T>> {
+            OfRef(Spliterator<T> aSpliterator, Spliterator<T> bSpliterator) {
+                super(aSpliterator, bSpliterator);
+            }
+        }
+
+        private static abstract class OfPrimitive<T, T_CONS, T_SPLITR extends Spliterator.OfPrimitive<T, T_CONS, T_SPLITR>> extends ConcatSpliterator<T, T_SPLITR> implements
+                        Spliterator.OfPrimitive<T, T_CONS, T_SPLITR> {
+            private OfPrimitive(T_SPLITR aSpliterator, T_SPLITR bSpliterator) {
+                super(aSpliterator, bSpliterator);
+            }
+
+            @Override
+            public boolean tryAdvance(T_CONS action) {
+                boolean hasNext;
+                if (beforeSplit) {
+                    hasNext = aSpliterator.tryAdvance(action);
+                    if (!hasNext) {
+                        beforeSplit = false;
+                        hasNext = bSpliterator.tryAdvance(action);
+                    }
+                } else
+                    hasNext = bSpliterator.tryAdvance(action);
+                return hasNext;
+            }
+
+            @Override
+            public void forEachRemaining(T_CONS action) {
+                if (beforeSplit)
+                    aSpliterator.forEachRemaining(action);
+                bSpliterator.forEachRemaining(action);
+            }
+        }
+
+        static class OfInt extends ConcatSpliterator.OfPrimitive<Integer, IntConsumer, Spliterator.OfInt> implements Spliterator.OfInt {
+            OfInt(Spliterator.OfInt aSpliterator, Spliterator.OfInt bSpliterator) {
+                super(aSpliterator, bSpliterator);
+            }
+        }
+
+        static class OfLong extends ConcatSpliterator.OfPrimitive<Long, LongConsumer, Spliterator.OfLong> implements Spliterator.OfLong {
+            OfLong(Spliterator.OfLong aSpliterator, Spliterator.OfLong bSpliterator) {
+                super(aSpliterator, bSpliterator);
+            }
+        }
+
+        static class OfDouble extends ConcatSpliterator.OfPrimitive<Double, DoubleConsumer, Spliterator.OfDouble> implements Spliterator.OfDouble {
+            OfDouble(Spliterator.OfDouble aSpliterator, Spliterator.OfDouble bSpliterator) {
+                super(aSpliterator, bSpliterator);
+            }
+        }
+    }
+
+    /**
+     * Given two Runnables, return a Runnable that executes both in sequence, even if the first
+     * throws an exception, and if both throw exceptions, add any exceptions thrown by the second as
+     * suppressed exceptions of the first.
+     */
+    static Runnable composeWithExceptions(Runnable a, Runnable b) {
+        return new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    a.run();
+                } catch (Throwable e1) {
+                    try {
+                        b.run();
+                    } catch (Throwable e2) {
+                        try {
+                            e1.addSuppressed(e2);
+                        } catch (Throwable ignore) {
+                        }
+                    }
+                    throw e1;
+                }
+                b.run();
+            }
+        };
+    }
+
+    /**
+     * Given two streams, return a Runnable that executes both of their {@link BaseStream#close}
+     * methods in sequence, even if the first throws an exception, and if both throw exceptions, add
+     * any exceptions thrown by the second as suppressed exceptions of the first.
+     */
+    static Runnable composedClose(BaseStream<?, ?> a, BaseStream<?, ?> b) {
+        return new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    a.close();
+                } catch (Throwable e1) {
+                    try {
+                        b.close();
+                    } catch (Throwable e2) {
+                        try {
+                            e1.addSuppressed(e2);
+                        } catch (Throwable ignore) {
+                        }
+                    }
+                    throw e1;
+                }
+                b.close();
+            }
+        };
+    }
+}
--- /dev/null	2014-01-29 23:03:08.911280982 +0100
+++ new/./sumatra.sh	2014-01-30 16:44:19.498201016 +0100
@@ -0,0 +1,29 @@
+#!/bin/bash
+
+# Run the test which loads the Okra lib from a jar
+echo "--- Running com.oracle.graal.compiler.hsail.test.BasicSumatraTest ---"
+mx vm -Dcom.amd.sumatra.offload.immediate=true \
+      -Xbootclasspath/p:graal.jar \
+      -XX:-BootstrapGraal \
+      -XX:+UseHSAILSimulator \
+      -XX:+TraceGPUInteraction \
+      -cp @com.oracle.graal.compiler.hsail.test \
+      com.oracle.graal.compiler.hsail.test.BasicSumatraTest
+
+# Run the sample which requires PATH and LD_LIBRARY_PATH for loading Okra
+if [ -z "$OKRA_BIN" ]; then
+    OKRA_BIN=$HOME/okra/dist/bin
+fi
+test -x $OKRA_BIN/hsailasm || { echo "$OKRA_BIN is missing hsailasm" ; exit 1; }
+
+export PATH=$PATH:$OKRA_BIN
+export LD_LIBRARY_PATH=$OKRA_BIN
+
+echo "--- Running com.oracle.graal.hotspot.hsail.BasicSumatraDemo ---"
+mx vm -Dcom.amd.sumatra.offload.immediate=true \
+      -Xbootclasspath/p:graal.jar \
+      -XX:-BootstrapGraal \
+      -XX:+UseHSAILSimulator \
+      -XX:+TraceGPUInteraction \
+      -cp @com.oracle.graal.hotspot.hsail \
+      com.oracle.graal.hotspot.hsail.BasicSumatraDemo
