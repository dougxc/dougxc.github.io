<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old graal/com.oracle.graal.compiler.hsail.test.infra/src/com/oracle/graal/compiler/hsail/test/infra/KernelTester.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package com.oracle.graal.compiler.hsail.test.infra;
  24 
  25 import static org.junit.Assert.*;
  26 import static org.junit.Assume.*;
  27 
  28 import java.io.*;
  29 import java.lang.annotation.*;
  30 import java.lang.reflect.*;
  31 import java.nio.file.*;
  32 import java.util.*;
  33 import java.util.concurrent.atomic.*;
  34 import java.util.logging.*;
  35 
  36 import com.amd.okra.*;
  37 
  38 /**
  39  * Abstract class on which the HSAIL unit tests are built. Executes a method or lambda on both the
  40  * Java side and the Okra side and compares the results for fields that are annotated with
  41  * {@link KernelTester.Result}.
  42  */
  43 public abstract class KernelTester {
  44 
  45     /**
  46      * Denotes a field whose value is to be compared as part of computing the result of a test.
  47      */
  48     @Retention(RetentionPolicy.RUNTIME)
  49     @Target(ElementType.FIELD)
  50     public @interface Result {
  51     }
  52 
  53     // Using these in case we want to compile with Java 7.
  54     public interface MyIntConsumer {
  55 
  56         void accept(int value);
  57     }
  58 
  59     public interface MyObjConsumer {
  60 
  61         void accept(Object obj);
  62     }
  63 
  64     public enum DispatchMode {
  65         SEQ,
  66         JTP,
  67         OKRA
  68     }
  69 
  70     public enum HsailMode {
  71         COMPILED,
  72         INJECT_HSAIL,
  73         INJECT_OCL
  74     }
  75 
  76     public DispatchMode dispatchMode;
  77     // Where the hsail comes from.
  78     private HsailMode hsailMode;
  79     protected Method testMethod;
  80     // What type of okra dispatch to use when client calls.
  81     private boolean useLambdaMethod;
  82     private Class&lt;?&gt;[] testMethodParams = null;
  83     private int id = nextId.incrementAndGet();
  84     static AtomicInteger nextId = new AtomicInteger(0);
  85     public static Logger logger;
  86     private OkraContext okraContext;
  87     private OkraKernel okraKernel;
  88     private static final String propPkgName = KernelTester.class.getPackage().getName();
  89     private static Level logLevel;
  90     private static ConsoleHandler consoleHandler;
  91     private boolean runOkraFirst = Boolean.getBoolean("kerneltester.runOkraFirst");
  92 
  93     static {
  94         logger = Logger.getLogger(propPkgName);
  95         logLevel = Level.parse(System.getProperty("kerneltester.logLevel", "OFF"));
  96 
  97         // This block configure the logger with handler and formatter.
  98         consoleHandler = new ConsoleHandler();
  99         logger.addHandler(consoleHandler);
 100         logger.setUseParentHandlers(false);
 101         SimpleFormatter formatter = new SimpleFormatter() {
 102 
 103             @SuppressWarnings("sync-override")
 104             @Override
 105             public String format(LogRecord record) {
 106                 return (record.getMessage() + "\n");
 107             }
 108         };
 109         consoleHandler.setFormatter(formatter);
 110         setLogLevel(logLevel);
 111     }
 112 
 113     private static boolean gaveNoOkraWarning = false;
 114     private boolean onSimulator;
 115     private final boolean okraLibExists;
 116 
 117     public boolean runningOnSimulator() {
 118         return onSimulator;
 119     }
 120 
 121     public KernelTester(boolean okraLibExists) {
 122         dispatchMode = DispatchMode.SEQ;
 123         hsailMode = HsailMode.COMPILED;
 124         useLambdaMethod = false;
 125         // Control which okra instances can run the tests (is Simulator is static).
 126         onSimulator = OkraContext.isSimulator();
 127         this.okraLibExists = okraLibExists;
 128     }
 129 
 130     public abstract void runTest();
 131 
 132     // Default comparison is to compare all things marked @Result.
 133     public boolean compareResults(KernelTester base) {
 134         Class&lt;?&gt; clazz = this.getClass();
 135         while (clazz != null &amp;&amp; clazz != KernelTester.class) {
 136             for (Field f : clazz.getDeclaredFields()) {
 137                 if (!Modifier.isStatic(f.getModifiers())) {
 138                     Result annos = f.getAnnotation(Result.class);
 139                     if (annos != null) {
 140                         logger.fine("@Result field = " + f);
 141                         Object myResult = getFieldFromObject(f, this);
 142                         Object otherResult = getFieldFromObject(f, base);
 143                         boolean same = compareObjects(myResult, otherResult);
 144                         logger.fine("comparing " + myResult + ", " + otherResult + ", match=" + same);
 145                         if (!same) {
 146                             logger.severe("mismatch comparing " + f + ", " + myResult + " vs. " + otherResult);
 147                             logSevere("FAILED!!! " + this.getClass());
 148                             return false;
 149                         }
 150                     }
 151                 }
 152             }
 153             clazz = clazz.getSuperclass();
 154         }
 155         logInfo("PASSED: " + this.getClass());
 156         return true;
 157     }
 158 
 159     private boolean compareObjects(Object first, Object second) {
 160         if (first == null) {
 161             return (second == null);
 162         }
 163         if (second == null) {
 164             return (first == null);
 165         }
 166         Class&lt;?&gt; clazz = first.getClass();
 167         if (clazz != second.getClass()) {
 168             return false;
 169         }
 170         if (!clazz.isArray()) {
 171             // Non arrays.
 172             if (clazz.equals(float.class) || clazz.equals(double.class)) {
 173                 return isEqualsFP((double) first, (double) second);
 174             } else {
 175                 return first.equals(second);
 176             }
 177         } else {
 178             // Handle the case where Objects are arrays.
 179             ArrayComparer comparer;
 180             if (clazz.equals(float[].class) || clazz.equals(double[].class)) {
 181                 comparer = new FPArrayComparer();
 182             } else if (clazz.equals(long[].class) || clazz.equals(int[].class) || clazz.equals(byte[].class)) {
 183                 comparer = new IntArrayComparer();
 184             } else if (clazz.equals(boolean[].class)) {
 185                 comparer = new BooleanArrayComparer();
 186             } else {
 187                 comparer = new ObjArrayComparer();
 188             }
 189             return comparer.compareArrays(first, second);
 190         }
 191     }
 192 
 193     static final int MISMATCHLIMIT = 10;
 194     static final int ELEMENTDISPLAYLIMIT = 20;
 195 
 196     public int getMisMatchLimit() {
 197         return MISMATCHLIMIT;
 198     }
 199 
 200     public int getElementDisplayLimit() {
 201         return ELEMENTDISPLAYLIMIT;
 202     }
 203 
 204     abstract class ArrayComparer {
 205 
 206         abstract Object getElement(Object ary, int index);
 207 
 208         // Equality test, can be overridden
 209         boolean isEquals(Object firstElement, Object secondElement) {
 210             return firstElement.equals(secondElement);
 211         }
 212 
 213         boolean compareArrays(Object first, Object second) {
 214             int len = Array.getLength(first);
 215             if (len != Array.getLength(second)) {
 216                 return false;
 217             }
 218             // If info logLevel, build string of first few elements from first array.
 219             if (logLevel.intValue() &lt;= Level.INFO.intValue()) {
 220                 StringBuilder sb = new StringBuilder();
 221                 for (int i = 0; i &lt; Math.min(len, getElementDisplayLimit()); i++) {
 222                     sb.append(getElement(first, i));
 223                     sb.append(", ");
 224                 }
 225                 logger.info(sb.toString());
 226             }
 227             boolean success = true;
 228             int mismatches = 0;
 229             for (int i = 0; i &lt; len; i++) {
 230                 Object firstElement = getElement(first, i);
 231                 Object secondElement = getElement(second, i);
 232                 if (!isEquals(firstElement, secondElement)) {
 233                     logSevere("mismatch at index " + i + ", expected " + secondElement + ", saw " + firstElement);
 234                     success = false;
 235                     mismatches++;
 236                     if (mismatches &gt;= getMisMatchLimit()) {
 237                         logSevere("...Truncated");
 238                         break;
 239                     }
 240                 }
 241             }
 242             return success;
 243         }
 244     }
 245 
 246     class FPArrayComparer extends ArrayComparer {
 247 
 248         @Override
 249         Object getElement(Object ary, int index) {
 250             return Array.getDouble(ary, index);
 251         }
 252 
 253         @Override
 254         boolean isEquals(Object firstElement, Object secondElement) {
 255             return isEqualsFP((double) firstElement, (double) secondElement);
 256         }
 257     }
 258 
 259     class IntArrayComparer extends ArrayComparer {
 260 
 261         @Override
 262         Object getElement(Object ary, int index) {
 263             return Array.getLong(ary, index);
 264         }
 265     }
 266 
 267     class BooleanArrayComparer extends ArrayComparer {
 268 
 269         @Override
 270         Object getElement(Object ary, int index) {
 271             return Array.getBoolean(ary, index);
 272         }
 273     }
 274 
 275     class ObjArrayComparer extends ArrayComparer {
 276 
 277         @Override
 278         Object getElement(Object ary, int index) {
 279             return Array.get(ary, index);
 280         }
 281 
 282         @Override
 283         boolean isEquals(Object firstElement, Object secondElement) {
 284             return compareObjects(firstElement, secondElement);
 285         }
 286     }
 287 
 288     /**
 289      * Tests two floating point values for equality.
 290      */
 291     public boolean isEqualsFP(double first, double second) {
 292         // Special case for checking whether expected and actual values are both NaNs.
 293         if (Double.isNaN(first) &amp;&amp; Double.isNaN(second)) {
 294             return true;
 295         }
 296         return first == second;
 297     }
 298 
 299     public void setDispatchMode(DispatchMode dispatchMode) {
 300         this.dispatchMode = dispatchMode;
 301     }
 302 
 303     public void setHsailMode(HsailMode hsailMode) {
 304         this.hsailMode = hsailMode;
 305     }
 306 
 307     /**
 308      * Return a clone of this instance unless overridden, we just call the null constructor.
 309      */
 310     public KernelTester newInstance() {
 311         try {
 312             return this.getClass().getConstructor((Class&lt;?&gt;[]) null).newInstance();
 313         } catch (Throwable t) {
 314             fail("Unexpected exception " + t);
 315             return null;
 316         }
 317     }
 318 
 319     public Method getMethodFromMethodName(String methName, Class&lt;?&gt; clazz) {
 320         Class&lt;?&gt; clazz2 = clazz;
 321         while (clazz2 != null) {
 322             for (Method m : clazz2.getDeclaredMethods()) {
 323                 logger.fine(" in " + clazz2 + ", trying to match " + m);
 324                 if (m.getName().equals(methName)) {
 325                     testMethodParams = m.getParameterTypes();
 326                     if (logLevel.intValue() &lt;= Level.FINE.intValue()) {
 327                         logger.fine(" in " + clazz2 + ", matched " + m);
 328                         logger.fine("parameter types are...");
 329                         int paramNum = 0;
 330                         for (Class&lt;?&gt; pclazz : testMethodParams) {
 331                             logger.fine(paramNum++ + ") " + pclazz.toString());
 332                         }
 333                     }
 334                     return m;
 335                 }
 336             }
 337             // Didn't find it in current clazz, try superclass.
 338             clazz2 = clazz2.getSuperclass();
 339         }
 340         // If we got this far, no match.
 341         return null;
 342     }
 343 
 344     private void setTestMethod(String methName, Class&lt;?&gt; inClazz) {
 345         testMethod = getMethodFromMethodName(methName, inClazz);
 346         if (testMethod == null) {
 347             fail("cannot find method " + methName + " in class " + inClazz);
 348         } else {
 349             // Print info but only for first such class.
 350             if (id == 1) {
 351                 logger.fine("testMethod to be compiled is \n   " + testMethod);
 352             }
 353         }
 354     }
 355 
 356     // Default is method name "run", but could be overridden.
 357     private final String defaultMethodName = "run";
 358 
 359     public String getTestMethodName() {
 360         return defaultMethodName;
 361     }
 362 
 363     /**
 364      * The dispatchMethodKernel dispatches a non-lambda method. All the parameters of the compiled
 365      * method are supplied as parameters to this call.
 366      */
 367     public void dispatchMethodKernel(int range, Object... args) {
 368         if (testMethod == null) {
 369             setTestMethod(getTestMethodName(), this.getClass());
 370         }
 371         if (dispatchMode == DispatchMode.SEQ) {
 372             dispatchMethodKernelSeq(range, args);
 373         } else if (dispatchMode == DispatchMode.OKRA) {
 374             dispatchMethodKernelOkra(range, args);
 375         }
 376     }
 377 
 378     /**
 379      * The "array stream" version of {@link #dispatchMethodKernel(int, Object...)}.
 380      */
 381     public void dispatchMethodKernel(Object[] ary, Object... args) {
 382         if (testMethod == null) {
 383             setTestMethod(getTestMethodName(), this.getClass());
 384         }
 385         if (dispatchMode == DispatchMode.SEQ) {
 386             dispatchMethodKernelSeq(ary, args);
 387         } else if (dispatchMode == DispatchMode.OKRA) {
 388             dispatchMethodKernelOkra(ary, args);
 389         }
 390     }
 391 
 392     /**
 393      * This dispatchLambdaMethodKernel dispatches the lambda version of a kernel where the "kernel"
 394      * is for the lambda method itself (like lambda$0).
 395      */
 396     public void dispatchLambdaMethodKernel(int range, MyIntConsumer consumer) {
 397         if (testMethod == null) {
 398             setTestMethod(findLambdaMethodName(), this.getClass());
 399         }
 400         if (dispatchMode == DispatchMode.SEQ) {
 401             dispatchLambdaKernelSeq(range, consumer);
 402         } else if (dispatchMode == DispatchMode.OKRA) {
 403             dispatchLambdaMethodKernelOkra(range, consumer);
 404         }
 405     }
 406 
 407     public void dispatchLambdaMethodKernel(Object[] ary, MyObjConsumer consumer) {
 408         if (testMethod == null) {
 409             setTestMethod(findLambdaMethodName(), this.getClass());
 410         }
 411         if (dispatchMode == DispatchMode.SEQ) {
 412             dispatchLambdaKernelSeq(ary, consumer);
 413         } else if (dispatchMode == DispatchMode.OKRA) {
 414             dispatchLambdaMethodKernelOkra(ary, consumer);
 415         }
 416     }
 417 
 418     /**
 419      * Dispatches the lambda version of a kernel where the "kernel" is for the xxx$$Lambda.accept
 420      * method in the wrapper for the lambda. Note that the useLambdaMethod boolean provides a way of
 421      * actually invoking dispatchLambdaMethodKernel from this API.
 422      */
 423     public void dispatchLambdaKernel(int range, MyIntConsumer consumer) {
 424         if (useLambdaMethod) {
 425             dispatchLambdaMethodKernel(range, consumer);
 426             return;
 427         }
 428         if (testMethod == null) {
 429             setTestMethod("accept", consumer.getClass());
 430         }
 431         if (dispatchMode == DispatchMode.SEQ) {
 432             dispatchLambdaKernelSeq(range, consumer);
 433         } else if (dispatchMode == DispatchMode.OKRA) {
 434             dispatchLambdaKernelOkra(range, consumer);
 435         }
 436     }
 437 
 438     public void dispatchLambdaKernel(Object[] ary, MyObjConsumer consumer) {
 439         if (useLambdaMethod) {
 440             dispatchLambdaMethodKernel(ary, consumer);
 441             return;
 442         }
 443         if (testMethod == null) {
 444             setTestMethod("accept", consumer.getClass());
 445         }
 446         if (dispatchMode == DispatchMode.SEQ) {
 447             dispatchLambdaKernelSeq(ary, consumer);
 448         } else if (dispatchMode == DispatchMode.OKRA) {
 449             dispatchLambdaKernelOkra(ary, consumer);
 450         }
 451     }
 452 
 453     private ArrayList&lt;String&gt; getLambdaMethodNames() {
 454         Class&lt;?&gt; clazz = this.getClass();
 455         ArrayList&lt;String&gt; lambdaNames = new ArrayList&lt;&gt;();
 456         while (clazz != null &amp;&amp; (lambdaNames.size() == 0)) {
 457             for (Method m : clazz.getDeclaredMethods()) {
 458                 logger.fine(" in " + clazz + ", trying to match " + m);
 459                 if (m.getName().startsWith("lambda$")) {
 460                     lambdaNames.add(m.getName());
 461                 }
 462             }
 463             // Didn't find it in current clazz, try superclass.
 464             clazz = clazz.getSuperclass();
 465         }
 466         return lambdaNames;
 467     }
 468 
 469     /**
 470      * findLambdaMethodName finds a name in the class starting with lambda$. If we find more than
 471      * one, throw an error, and tell user to override explicitly
 472      */
 473     private String findLambdaMethodName() {
 474         // If user overrode getTestMethodName, use that name.
 475         if (!getTestMethodName().equals(defaultMethodName)) {
 476             return getTestMethodName();
 477         } else {
 478             ArrayList&lt;String&gt; lambdaNames = getLambdaMethodNames();
 479             switch (lambdaNames.size()) {
 480                 case 1:
 481                     return lambdaNames.get(0);
 482                 case 0:
 483                     fail("No lambda method found in " + this.getClass());
 484                     return null;
 485                 default:
 486                     // More than one lambda.
 487                     String msg = "Multiple lambda methods found in " + this.getClass() + "\nYou should override getTestMethodName with one of the following\n";
 488                     for (String name : lambdaNames) {
 489                         msg = msg + name + "\n";
 490                     }
 491                     fail(msg);
 492                     return null;
 493             }
 494         }
 495     }
 496 
 497     /**
 498      * The getCompiledHSAILSource returns the string of HSAIL code for the compiled method. By
 499      * default, throws an error. In graal for instance, this would be overridden in
 500      * GraalKernelTester.
 501      */
 502     public String getCompiledHSAILSource(Method testMethod1) {
 503         fail("no compiler connected so unable to compile " + testMethod1 + "\nYou could try injecting HSAIL or OpenCL");
 504         return null;
 505     }
 506 
 507     public String getHSAILSource(Method testMethod1) {
 508         switch (hsailMode) {
 509             case COMPILED:
 510                 return getCompiledHSAILSource(testMethod1);
 511             case INJECT_HSAIL:
 512                 return getHsailFromClassnameHsailFile();
 513             case INJECT_OCL:
 514                 return getHsailFromClassnameOclFile();
 515             default:
 516                 fail("unknown hsailMode = " + hsailMode);
 517                 return null;
 518         }
 519     }
 520 
 521     /**
 522      * The getHSAILKernelName returns the name of the hsail kernel. By default we use 'run'. unless
 523      * coming from opencl injection. Could be overridden by the junit test.
 524      */
 525     public String getHSAILKernelName() {
 526         return (hsailMode != HsailMode.INJECT_OCL ? "&amp;run" : "&amp;__OpenCL_run_kernel");
 527     }
 528 
 529     private void createOkraKernel() {
 530         // Call routines in the derived class to get the hsail code and kernel name.
 531         String hsailSource = getHSAILSource(testMethod);
 532         if (!okraLibExists) {
 533             if (!gaveNoOkraWarning) {
 534                 logger.severe("No Okra library detected, skipping all KernelTester tests in " + this.getClass().getPackage().getName());
 535                 gaveNoOkraWarning = true;
 536             }
 537         }
 538         // Ignore any kerneltester test if okra does not exist.
 539         assumeTrue(okraLibExists);
 540         // Control which okra instances can run the tests.
 541         onSimulator = OkraContext.isSimulator();
 542         okraContext = new OkraContext();
 543         if (!okraContext.isValid()) {
 544             fail("...unable to create context");
 545         }
 546         // Control verbosity in okra from our logLevel.
 547         if (logLevel.intValue() &lt;= Level.INFO.intValue()) {
 548             okraContext.setVerbose(true);
 549         }
 550         okraKernel = new OkraKernel(okraContext, hsailSource, getHSAILKernelName());
 551         if (!okraKernel.isValid()) {
 552             fail("...unable to create kernel");
 553         }
 554     }
 555 
 556     /**
 557      * Dispatches an okra kernel over a given range using JNI. Protected so that it can be
 558      * overridden in {@link GraalKernelTester} which will dispatch without JNI.
 559      */
 560     protected void dispatchKernelOkra(int range, Object... args) {
 561         if (okraKernel == null) {
 562             createOkraKernel();
 563         }
 564         if (logLevel.intValue() &lt;= Level.FINE.intValue()) {
 565             logger.fine("Arguments passed to okra...");
 566             for (Object arg : args) {
 567                 logger.fine("  " + arg);
 568             }
 569         }
 570         okraKernel.setLaunchAttributes(range);
 571         okraKernel.dispatchWithArgs(args);
 572     }
 573 
 574     // int stream version
 575     private void dispatchMethodKernelSeq(int range, Object... args) {
 576         Object[] invokeArgs = new Object[args.length + 1];
 577         // Need space on the end for the gid parameter.
 578         System.arraycopy(args, 0, invokeArgs, 0, args.length);
 579         int gidArgIndex = invokeArgs.length - 1;
 580         if (logLevel.intValue() &lt;= Level.FINE.intValue()) {
 581             for (Object arg : args) {
 582                 logger.fine(arg.toString());
 583             }
 584         }
 585         for (int rangeIndex = 0; rangeIndex &lt; range; rangeIndex++) {
 586             invokeArgs[gidArgIndex] = rangeIndex;
 587             invokeMethodKernelSeq(invokeArgs, rangeIndex);
 588         }
 589     }
 590 
 591     // array stream version
 592     private void dispatchMethodKernelSeq(Object[] ary, Object... args) {
 593         Object[] invokeArgs = new Object[args.length + 1];
 594         // Need space on the end for the final obj parameter.
 595         System.arraycopy(args, 0, invokeArgs, 0, args.length);
 596         int objArgIndex = invokeArgs.length - 1;
 597         if (logLevel.intValue() &lt;= Level.FINE.intValue()) {
 598             for (Object arg : args) {
 599                 logger.fine(arg.toString());
 600             }
 601         }
 602         int range = ary.length;
 603         for (int rangeIndex = 0; rangeIndex &lt; range; rangeIndex++) {
 604             invokeArgs[objArgIndex] = ary[rangeIndex];
 605             invokeMethodKernelSeq(invokeArgs, rangeIndex);
 606         }
 607     }
 608 
 609     private void invokeMethodKernelSeq(Object[] invokeArgs, int rangeIndex) {
 610         try {
 611             testMethod.invoke(this, invokeArgs);
 612         } catch (IllegalAccessException e) {
 613             fail("could not invoke " + testMethod + ", make sure it is public");
 614         } catch (IllegalArgumentException e) {
 615             fail("wrong arguments invoking " + testMethod + ", check number and type of args passed to dispatchMethodKernel");
 616         } catch (InvocationTargetException e) {
 617             Throwable cause = e.getCause();
 618             if (cause instanceof RuntimeException) {
 619                 throw ((RuntimeException) cause);
 620             } else {
 621                 String errstr = testMethod + " threw a checked exception on gid=" + rangeIndex + ", exception was " + cause;
 622                 fail(errstr);
 623             }
 624         } catch (Exception e) {
 625             fail("Unknown exception " + e + " invoking " + testMethod);
 626         }
 627     }
 628 
 629     // int stream version
 630     private void dispatchMethodKernelOkra(int range, Object... args) {
 631         Object[] fixedArgs = fixArgTypes(args);
 632         if (Modifier.isStatic(testMethod.getModifiers())) {
 633             dispatchKernelOkra(range, fixedArgs);
 634         } else {
 635             // If it is a non-static method we have to push "this" as the first argument.
 636             Object[] newFixedArgs = new Object[fixedArgs.length + 1];
 637             System.arraycopy(fixedArgs, 0, newFixedArgs, 1, fixedArgs.length);
 638             newFixedArgs[0] = this;
 639             dispatchKernelOkra(range, newFixedArgs);
 640         }
 641     }
 642 
 643     // array stream version
 644     private void dispatchMethodKernelOkra(Object[] ary, Object... args) {
 645         // add the ary itself as the last arg in the passed parameter list
 646         Object[] argsWithAry = new Object[args.length + 1];
 647         System.arraycopy(args, 0, argsWithAry, 0, args.length);
 648         argsWithAry[argsWithAry.length - 1] = ary;
 649 
 650         Object[] fixedArgs = fixArgTypes(argsWithAry);
 651         int range = ary.length;
 652         if (Modifier.isStatic(testMethod.getModifiers())) {
 653             dispatchKernelOkra(range, fixedArgs);
 654         } else {
 655             // If it is a non-static method we have to push "this" as the first argument.
 656             Object[] newFixedArgs = new Object[fixedArgs.length + 1];
 657             System.arraycopy(fixedArgs, 0, newFixedArgs, 1, fixedArgs.length);
 658             newFixedArgs[0] = this;
 659             dispatchKernelOkra(range, newFixedArgs);
 660         }
 661     }
 662 
 663     /**
 664      * For primitive arg parameters, make sure arg types are cast to whatever the testMethod
 665      * signature says they should be.
 666      */
 667     protected Object[] fixArgTypes(Object[] args) {
 668         Object[] fixedArgs = new Object[args.length];
 669         for (int i = 0; i &lt; args.length; i++) {
 670             Class&lt;?&gt; paramClass = testMethodParams[i];
 671             if (paramClass.equals(Float.class) || paramClass.equals(float.class)) {
 672                 fixedArgs[i] = ((Number) args[i]).floatValue();
 673             } else if (paramClass.equals(Integer.class) || paramClass.equals(int.class)) {
 674                 fixedArgs[i] = ((Number) args[i]).intValue();
 675             } else if (paramClass.equals(Long.class) || paramClass.equals(long.class)) {
 676                 fixedArgs[i] = ((Number) args[i]).longValue();
 677             } else if (paramClass.equals(Double.class) || paramClass.equals(double.class)) {
 678                 fixedArgs[i] = ((Number) args[i]).doubleValue();
 679             } else if (paramClass.equals(Byte.class) || paramClass.equals(byte.class)) {
 680                 fixedArgs[i] = ((Number) args[i]).byteValue();
 681             } else if (paramClass.equals(Boolean.class) || paramClass.equals(boolean.class)) {
 682                 fixedArgs[i] = (boolean) args[i];
 683             } else {
 684                 // All others just move unchanged.
 685                 fixedArgs[i] = args[i];
 686             }
 687         }
 688         return fixedArgs;
 689     }
 690 
 691     /**
 692      * Dispatching a lambda on the java side is simple.
 693      */
 694     @SuppressWarnings("static-method")
 695     private void dispatchLambdaKernelSeq(int range, MyIntConsumer consumer) {
 696         for (int i = 0; i &lt; range; i++) {
 697             consumer.accept(i);
 698         }
 699     }
 700 
 701     @SuppressWarnings("static-method")
 702     private void dispatchLambdaKernelSeq(Object[] ary, MyObjConsumer consumer) {
 703         for (Object obj : ary) {
 704             consumer.accept(obj);
 705         }
 706     }
 707 
 708     /**
 709      * The dispatchLambdaMethodKernelOkra dispatches in the case where the hsail kernel implements
 710      * the lambda method itself as opposed to the wrapper that calls the lambda method. From the
 711      * consumer object, we need to find the fields and pass them to the kernel.
 712      */
 713     protected void dispatchLambdaMethodKernelOkra(int range, MyIntConsumer consumer) {
 714         logger.info("To determine parameters to pass to hsail kernel, we will examine   " + consumer.getClass());
 715         Field[] fields = consumer.getClass().getDeclaredFields();
 716         Object[] args = new Object[fields.length];
 717         int argIndex = 0;
 718         for (Field f : fields) {
 719             logger.info("... " + f);
 720             args[argIndex++] = getFieldFromObject(f, consumer);
 721         }
 722         dispatchKernelOkra(range, args);
 723     }
 724 
 725     private void dispatchLambdaMethodKernelOkra(Object[] ary, MyObjConsumer consumer) {
 726         logger.info("To determine parameters to pass to hsail kernel, we will examine   " + consumer.getClass());
 727         Field[] fields = consumer.getClass().getDeclaredFields();
 728         Object[] args = new Object[fields.length + 1];  // + 1 because we also pass the array
 729         int argIndex = 0;
 730         for (Field f : fields) {
 731             logger.info("... " + f);
 732             args[argIndex++] = getFieldFromObject(f, consumer);
 733         }
 734         args[argIndex] = ary;
 735         dispatchKernelOkra(ary.length, args);
 736     }
 737 
 738     /**
 739      * The dispatchLambdaKernelOkra dispatches in the case where the hsail kernel where the hsail
 740      * kernel implements the accept method of the wrapper that calls the lambda method as opposed to
 741      * the actual lambda method itself.
 742      */
 743     private void dispatchLambdaKernelOkra(int range, MyIntConsumer consumer) {
 744         // The "wrapper" method always has only one arg consisting of the consumer.
 745         Object[] args = new Object[1];
 746         args[0] = consumer;
 747         dispatchKernelOkra(range, args);
 748     }
 749 
 750     private void dispatchLambdaKernelOkra(Object[] ary, MyObjConsumer consumer) {
 751         // The "wrapper" method always has only one arg consisting of the consumer.
 752         Object[] args = new Object[2];
 753         args[0] = consumer;
 754         args[1] = ary;
 755         dispatchKernelOkra(ary.length, args);
 756     }
 757 
 758     private void disposeKernelOkra() {
 759         if (okraContext != null) {
 760             okraContext.dispose();
 761         }
 762     }
 763 
 764     private void compareOkraToSeq(HsailMode hsailModeToUse) {
 765         compareOkraToSeq(hsailModeToUse, false);
 766     }
 767 
 768     /**
 769      * Runs this instance on OKRA, and as SEQ and compares the output of the two executions. the
 770      * runOkraFirst flag controls which order they are done in. Note the compiler must use eager
 771      * resolving if Okra is done first.
 772      */
 773     private void compareOkraToSeq(HsailMode hsailModeToUse, boolean useLambda) {
 774         KernelTester testerSeq;
 775         if (runOkraFirst) {
 776             runOkraInstance(hsailModeToUse, useLambda);
 777             testerSeq = runSeqInstance();
 778         } else {
 779             testerSeq = runSeqInstance();
 780             runOkraInstance(hsailModeToUse, useLambda);
 781         }
 782         assertTrue("failed comparison to SEQ", compareResults(testerSeq));
 783     }
 784 
 785     private void runOkraInstance(HsailMode hsailModeToUse, boolean useLambda) {
 786         // run Okra instance in exiting KernelTester object
 787         this.setHsailMode(hsailModeToUse);
 788         this.setDispatchMode(DispatchMode.OKRA);
 789         this.useLambdaMethod = useLambda;
 790         this.runTest();
 791         this.disposeKernelOkra();
 792     }
 793 
 794     private KernelTester runSeqInstance() {
 795         // Create and run sequential instance.
 796         KernelTester testerSeq = newInstance();
 797         testerSeq.setDispatchMode(DispatchMode.SEQ);
 798         testerSeq.runTest();
 799         return testerSeq;
 800     }
 801 
 802     public void testGeneratedHsail() {
 803         compareOkraToSeq(HsailMode.COMPILED);
 804     }
 805 
 806     public void testGeneratedHsailUsingLambdaMethod() {
 807         compareOkraToSeq(HsailMode.COMPILED, true);
 808     }
 809 
 810     public void testInjectedHsail() {
 811         newInstance().compareOkraToSeq(HsailMode.INJECT_HSAIL);
 812     }
 813 
 814     public void testInjectedOpencl() {
 815         newInstance().compareOkraToSeq(HsailMode.INJECT_OCL);
 816     }
 817 
 818     protected static Object getFieldFromObject(Field f, Object fromObj) {
 819         try {
 820             f.setAccessible(true);
 821             Type type = f.getType();
 822             logger.info("type = " + type);
 823             if (type == double.class) {
 824                 return f.getDouble(fromObj);
 825             } else if (type == float.class) {
 826                 return f.getFloat(fromObj);
 827             } else if (type == long.class) {
 828                 return f.getLong(fromObj);
 829             } else if (type == int.class) {
 830                 return f.getInt(fromObj);
 831             } else if (type == byte.class) {
 832                 return f.getByte(fromObj);
 833             } else if (type == boolean.class) {
 834                 return f.getBoolean(fromObj);
 835             } else {
 836                 return f.get(fromObj);
 837             }
 838         } catch (Exception e) {
 839             fail("unable to get field " + f + " from " + fromObj);
 840             return null;
 841         }
 842     }
 843 
 844     public static void checkFileExists(String fileName) {
 845         assertTrue(fileName + " does not exist", fileExists(fileName));
 846     }
 847 
 848     public static boolean fileExists(String fileName) {
 849         return new File(fileName).exists();
 850     }
 851 
 852     public static String getFileAsString(String sourceFileName) {
 853         String source = null;
 854         try {
 855             checkFileExists(sourceFileName);
 856             source = new String(Files.readAllBytes(FileSystems.getDefault().getPath(sourceFileName)));
 857         } catch (IOException e) {
 858             fail("could not open file " + sourceFileName);
 859             return null;
 860         }
 861         return source;
 862     }
 863 
 864     public static String getHsailFromFile(String sourceFileName) {
 865         logger.severe("... getting hsail from file " + sourceFileName);
 866         return getFileAsString(sourceFileName);
 867     }
 868 
 869     private static void executeCmd(String... cmd) {
 870         logger.info("spawning" + Arrays.toString(cmd));
 871         try {
 872             ProcessBuilder pb = new ProcessBuilder(cmd);
 873             Process p = pb.start();
 874             if (logLevel.intValue() &lt;= Level.INFO.intValue()) {
 875                 InputStream in = p.getInputStream();
 876                 BufferedInputStream buf = new BufferedInputStream(in);
 877                 InputStreamReader inread = new InputStreamReader(buf);
 878                 BufferedReader bufferedreader = new BufferedReader(inread);
 879                 String line;
 880                 while ((line = bufferedreader.readLine()) != null) {
 881                     logger.info(line);
 882                 }
 883             }
 884             p.waitFor();
 885         } catch (Exception e) {
 886             fail("could not execute &lt;" + Arrays.toString(cmd) + "&gt;");
 887         }
 888     }
 889 
 890     public static String getHsailFromOpenCLFile(String openclFileName) {
 891         String openclHsailFile = "opencl_out.hsail";
 892         String tmpTahitiFile = "_temp_0_Tahiti.txt";
 893         checkFileExists(openclFileName);
 894         logger.severe("...converting " + openclFileName + " to HSAIL...");
 895         executeCmd("aoc2", "-m64", "-I./", "-march=hsail", openclFileName);
 896         if (fileExists(tmpTahitiFile)) {
 897             return getFileAsString(tmpTahitiFile);
 898         } else {
 899             executeCmd("HSAILasm", "-disassemble", "-o", openclHsailFile, openclFileName.replace(".cl", ".bin"));
 900             checkFileExists(openclHsailFile);
 901             return getFileAsString(openclHsailFile);
 902         }
 903     }
 904 
 905     public String getHsailFromClassnameHsailFile() {
 906         return (getHsailFromFile(this.getClass().getSimpleName() + ".hsail"));
 907     }
 908 
 909     public String getHsailFromClassnameOclFile() {
 910         return (getHsailFromOpenCLFile(this.getClass().getSimpleName() + ".cl"));
 911     }
 912 
 913     public static void logInfo(String msg) {
 914         logger.info(msg);
 915     }
 916 
 917     public static void logSevere(String msg) {
 918         logger.severe(msg);
 919     }
 920 
 921     public static void setLogLevel(Level level) {
 922         logLevel = level;
 923         logger.setLevel(level);
 924         consoleHandler.setLevel(level);
 925     }
 926 }
</pre></body></html>
