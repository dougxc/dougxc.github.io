--- old/src/hotspot/share/code/debugInfo.cpp	2018-11-01 11:13:06.000000000 +0100
+++ new/src/hotspot/share/code/debugInfo.cpp	2018-11-01 11:13:05.000000000 +0100
@@ -127,6 +127,7 @@
 
 void ObjectValue::read_object(DebugInfoReadStream* stream) {
   _klass = read_from(stream);
+  _base_object = read_from(stream);
   assert(_klass->is_constant_oop(), "should be constant java mirror oop");
   int length = stream->read_int();
   for (int i = 0; i < length; i++) {
@@ -144,6 +145,7 @@
     stream->write_int(OBJECT_CODE);
     stream->write_int(_id);
     _klass->write_on(stream);
+    _base_object->write_on(stream);
     int length = _field_values.length();
     stream->write_int(length);
     for (int i = 0; i < length; i++) {
--- old/src/hotspot/share/code/debugInfo.hpp	2018-11-01 11:13:07.000000000 +0100
+++ new/src/hotspot/share/code/debugInfo.hpp	2018-11-01 11:13:06.000000000 +0100
@@ -97,14 +97,16 @@
  private:
   int                        _id;
   ScopeValue*                _klass;
+  ScopeValue*                _base_object;
   GrowableArray<ScopeValue*> _field_values;
   Handle                     _value;
   bool                       _visited;
 
  public:
-  ObjectValue(int id, ScopeValue* klass)
+  ObjectValue(int id, ScopeValue* klass, ScopeValue* base_object)
      : _id(id)
      , _klass(klass)
+     , _base_object(base_object)
      , _field_values()
      , _value()
      , _visited(false) {
@@ -122,6 +124,7 @@
   bool                        is_object() const         { return true; }
   int                         id() const                { return _id; }
   ScopeValue*                 klass() const             { return _klass; }
+  ScopeValue*                 base_object() const       { return _base_object; }
   GrowableArray<ScopeValue*>* field_values()            { return &_field_values; }
   ScopeValue*                 field_at(int i) const     { return _field_values.at(i); }
   int                         field_size()              { return _field_values.length(); }
--- old/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp	2018-11-01 11:13:08.000000000 +0100
+++ new/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp	2018-11-01 11:13:07.000000000 +0100
@@ -471,7 +471,16 @@
     Handle object(THREAD, values->obj_at(i));
     Handle slot_kind (THREAD, slotKinds->obj_at(i));
     BasicType type = JVMCIRuntime::kindToBasicType(slot_kind, CHECK);
-    ScopeValue* value = get_scope_value(object, type, objects, cur_second, CHECK);
+    ScopeValue* value;
+    if (object == Value::ILLEGAL()) {
+      // no value needs to be written
+      value = _illegal_value;
+      if (type == T_DOUBLE || type == T_LONG) {
+        cur_second = _illegal_value;
+      }
+    } else {
+      value = get_scope_value(object, type, objects, cur_second, CHECK);
+    }
 
     if (isLongArray && cur_second == NULL) {
       // we're trying to put ints into a long array... this isn't really valid, but it's used for some optimizations.
@@ -1011,9 +1020,17 @@
     HandleMark hm(THREAD);
     Handle value(THREAD, virtualObjects->obj_at(i));
     int id = VirtualObject::id(value);
+    Handle base_object(THREAD, VirtualObject::baseObject(value));
     Handle type(THREAD, VirtualObject::type(value));
     oop javaMirror = HotSpotResolvedObjectTypeImpl::javaClass(type);
-    ObjectValue* sv = new ObjectValue(id, new ConstantOopWriteValue(JNIHandles::make_local(Thread::current(), javaMirror)));
+    ScopeValue* baseObjectValue;
+    if (base_object.is_null()) {
+      baseObjectValue = _oop_null_scope_value;
+    } else {
+      ScopeValue* second = NULL;
+      baseObjectValue = get_scope_value(base_object, T_OBJECT, objects, second, CHECK_NULL);
+    }
+    ObjectValue* sv = new ObjectValue(id, new ConstantOopWriteValue(JNIHandles::make_local(Thread::current(), javaMirror)), baseObjectValue);
     if (id < 0 || id >= objects->length()) {
       JVMCI_ERROR_NULL("virtual object id %d out of bounds", id);
     }
--- old/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp	2018-11-01 11:13:09.000000000 +0100
+++ new/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp	2018-11-01 11:13:08.000000000 +0100
@@ -1067,7 +1067,7 @@
                   }
                 }
               }
-              bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), objects, CHECK_NULL);
+              bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), NULL, objects, CHECK_NULL);
               Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);
               realloc_called = true;
 
@@ -1325,7 +1325,7 @@
     return;
   }
 
-  bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, CHECK);
+  bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), NULL, objects, CHECK);
   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
 
   for (int frame_index = 0; frame_index < virtualFrames->length(); frame_index++) {
--- old/src/hotspot/share/jvmci/jvmciJavaClasses.hpp	2018-11-01 11:13:10.000000000 +0100
+++ new/src/hotspot/share/jvmci/jvmciJavaClasses.hpp	2018-11-01 11:13:10.000000000 +0100
@@ -278,6 +278,7 @@
   end_class                                                                                                                                                    \
   start_class(VirtualObject)                                                                                                                                   \
     int_field(VirtualObject, id)                                                                                                                               \
+    oop_field(VirtualObject, baseObject, "Ljdk/vm/ci/meta/JavaValue;")                                                                                         \
     oop_field(VirtualObject, type, "Ljdk/vm/ci/meta/ResolvedJavaType;")                                                                                        \
     objArrayOop_field(VirtualObject, values, "[Ljdk/vm/ci/meta/JavaValue;")                                                                                    \
     objArrayOop_field(VirtualObject, slotKinds, "[Ljdk/vm/ci/meta/JavaKind;")                                                                                  \
--- old/src/hotspot/share/opto/output.cpp	2018-11-01 11:13:11.000000000 +0100
+++ new/src/hotspot/share/opto/output.cpp	2018-11-01 11:13:11.000000000 +0100
@@ -544,7 +544,8 @@
       assert(cik->is_instance_klass() ||
              cik->is_array_klass(), "Not supported allocation.");
       sv = new ObjectValue(spobj->_idx,
-                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));
+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()),
+                           new ConstantOopWriteValue(NULL));
       Compile::set_sv_for_object_node(objs, sv);
 
       uint first_ind = spobj->first_index(sfpt->jvms());
@@ -816,7 +817,8 @@
           assert(cik->is_instance_klass() ||
                  cik->is_array_klass(), "Not supported allocation.");
           ObjectValue* sv = new ObjectValue(spobj->_idx,
-                                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));
+                                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()),
+                                            new ConstantOopWriteValue(NULL));
           Compile::set_sv_for_object_node(objs, sv);
 
           uint first_ind = spobj->first_index(youngest_jvms);
--- old/src/hotspot/share/runtime/deoptimization.cpp	2018-11-01 11:13:12.000000000 +0100
+++ new/src/hotspot/share/runtime/deoptimization.cpp	2018-11-01 11:13:12.000000000 +0100
@@ -232,7 +232,7 @@
       }
       if (objects != NULL) {
         JRT_BLOCK
-          realloc_failures = realloc_objects(thread, &deoptee, objects, THREAD);
+          realloc_failures = realloc_objects(thread, &deoptee, &map, objects, THREAD);
         JRT_END
         bool skip_internal = (cm != NULL) && !cm->is_compiled_by_jvmci();
         reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal);
@@ -787,7 +787,7 @@
   = Deoptimization::Action_reinterpret;
 
 #if COMPILER2_OR_JVMCI
-bool Deoptimization::realloc_objects(JavaThread* thread, frame* fr, GrowableArray<ScopeValue*>* objects, TRAPS) {
+bool Deoptimization::realloc_objects(JavaThread* thread, frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, TRAPS) {
   Handle pending_exception(THREAD, thread->pending_exception());
   const char* exception_file = thread->exception_file();
   int exception_line = thread->exception_line();
@@ -800,19 +800,25 @@
     ObjectValue* sv = (ObjectValue*) objects->at(i);
 
     Klass* k = java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()());
-    oop obj = NULL;
+    if (reg_map == NULL && (!sv->base_object()->is_constant_oop() || !sv->base_object()->as_ConstantOopReadValue()->value().is_null())) {
+      // skip element with base object if we don't have a register map
+      continue;
+    }
+    oop obj = StackValue::create_stack_value(fr, reg_map, sv->base_object())->get_obj()();
 
-    if (k->is_instance_klass()) {
-      InstanceKlass* ik = InstanceKlass::cast(k);
-      obj = ik->allocate_instance(THREAD);
-    } else if (k->is_typeArray_klass()) {
-      TypeArrayKlass* ak = TypeArrayKlass::cast(k);
-      assert(sv->field_size() % type2size[ak->element_type()] == 0, "non-integral array length");
-      int len = sv->field_size() / type2size[ak->element_type()];
-      obj = ak->allocate(len, THREAD);
-    } else if (k->is_objArray_klass()) {
-      ObjArrayKlass* ak = ObjArrayKlass::cast(k);
-      obj = ak->allocate(sv->field_size(), THREAD);
+    if (obj == NULL) {
+      if (k->is_instance_klass()) {
+        InstanceKlass* ik = InstanceKlass::cast(k);
+        obj = ik->allocate_instance(THREAD);
+      } else if (k->is_typeArray_klass()) {
+        TypeArrayKlass* ak = TypeArrayKlass::cast(k);
+        assert(sv->field_size() % type2size[ak->element_type()] == 0, "non-integral array length");
+        int len = sv->field_size() / type2size[ak->element_type()];
+        obj = ak->allocate(len, THREAD);
+      } else if (k->is_objArray_klass()) {
+        ObjArrayKlass* ak = ObjArrayKlass::cast(k);
+        obj = ak->allocate(sv->field_size(), THREAD);
+      }
     }
 
     if (obj == NULL) {
@@ -841,6 +847,11 @@
 
   for (int i = 0; i < sv->field_size(); i++) {
     StackValue* value = StackValue::create_stack_value(fr, reg_map, sv->field_at(i));
+    if (value->type() == T_CONFLICT) {
+      // skip fields with no values
+      index += (type == T_LONG || type == T_DOUBLE) ? 2 : 1;
+      continue;
+    }
     switch(type) {
     case T_LONG: case T_DOUBLE: {
       assert(value->type() == T_INT, "Agreement.");
@@ -935,6 +946,10 @@
 void Deoptimization::reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj) {
   for (int i = 0; i < sv->field_size(); i++) {
     StackValue* value = StackValue::create_stack_value(fr, reg_map, sv->field_at(i));
+    if (value->type() == T_CONFLICT) {
+      // skip fields with no values
+      continue;
+    }
     assert(value->type() == T_OBJECT, "object element expected");
     obj->obj_at_put(i, value->get_obj()());
   }
@@ -978,6 +993,11 @@
     StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);
     int offset = fields->at(i)._offset;
     BasicType type = fields->at(i)._type;
+    if (value->type() == T_CONFLICT) {
+      // skip fields with no values
+      svIndex += (type == T_LONG || type == T_DOUBLE) ? 2 : 1;
+      continue;
+    }
     switch (type) {
       case T_OBJECT: case T_ARRAY:
         assert(value->type() == T_OBJECT, "Agreement.");
--- old/src/hotspot/share/runtime/deoptimization.hpp	2018-11-01 11:13:13.000000000 +0100
+++ new/src/hotspot/share/runtime/deoptimization.hpp	2018-11-01 11:13:13.000000000 +0100
@@ -157,7 +157,7 @@
 JVMCI_ONLY(public:)
 
   // Support for restoring non-escaping objects
-  static bool realloc_objects(JavaThread* thread, frame* fr, GrowableArray<ScopeValue*>* objects, TRAPS);
+  static bool realloc_objects(JavaThread* thread, frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, TRAPS);
   static void reassign_type_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, typeArrayOop obj, BasicType type);
   static void reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj);
   static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal);
--- old/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code/VirtualObject.java	2018-11-01 11:13:14.000000000 +0100
+++ new/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code/VirtualObject.java	2018-11-01 11:13:14.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -22,11 +22,11 @@
  */
 package jdk.vm.ci.code;
 
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.IdentityHashMap;
 import java.util.Set;
 
+import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.meta.JavaKind;
 import jdk.vm.ci.meta.JavaValue;
 import jdk.vm.ci.meta.ResolvedJavaField;
@@ -40,15 +40,16 @@
 public final class VirtualObject implements JavaValue {
 
     private final ResolvedJavaType type;
+    private JavaValue baseObject;
     private JavaValue[] values;
     private JavaKind[] slotKinds;
     private final int id;
 
     /**
-     * Creates a new {@link VirtualObject} for the given type, with the given fields. If
-     * {@code type} is an instance class then {@code values} provides the values for the fields
+     * Creates a new {@link VirtualObject} for the given type, with the given contents. If
+     * {@link #type} is an instance class then {@link #values} provides the values for the fields
      * returned by {@link ResolvedJavaType#getInstanceFields(boolean) getInstanceFields(true)}. If
-     * {@code type} is an array then the length of the values array determines the reallocated array
+     * {@link #type} is an array then the length of {@link #values} determines the reallocated array
      * length.
      *
      * @param type the type of the object whose allocation was removed during compilation. This can
@@ -58,11 +59,30 @@
      * @return a new {@link VirtualObject} instance.
      */
     public static VirtualObject get(ResolvedJavaType type, int id) {
-        return new VirtualObject(type, id);
+        return new VirtualObject(type, null, id);
     }
 
-    private VirtualObject(ResolvedJavaType type, int id) {
+    /**
+     * Creates a new {@link VirtualObject} based on the given existing object, with the given
+     * contents. If {@link #type} is an instance class then {@link #values} provides the values for
+     * the fields returned by {@link ResolvedJavaType#getInstanceFields(boolean)
+     * getInstanceFields(true)}. If {@link #type} is an array then the length of {@link #values}
+     * determines the array length.
+     *
+     * @param type the type of the object whose allocation was removed during compilation. This can
+     *            be either an instance of an array type.
+     * @param baseObject the pre-existing object to be used instead of allocating a new object.
+     * @param id a unique id that identifies the object within the debug information for one
+     *            position in the compiled code.
+     * @return a new {@link VirtualObject} instance.
+     */
+    public static VirtualObject get(ResolvedJavaType type, JavaValue baseObject, int id) {
+        return new VirtualObject(type, baseObject, id);
+    }
+
+    private VirtualObject(ResolvedJavaType type, JavaValue baseObject, int id) {
         this.type = type;
+        this.baseObject = baseObject;
         this.id = id;
     }
 
@@ -86,14 +106,32 @@
                         }
                     } else {
                         ResolvedJavaField[] fields = vo.type.getInstanceFields(true);
-                        assert fields.length == vo.values.length : vo.type + ", fields=" + Arrays.toString(fields) + ", values=" + Arrays.toString(vo.values);
-                        for (int i = 0; i < vo.values.length; i++) {
+                        int fieldIndex = 0;
+                        for (int i = 0; i < vo.values.length; i++, fieldIndex++) {
                             if (i != 0) {
                                 buf.append(',');
                             }
-                            buf.append(fields[i].getName()).append('=');
+                            if (fieldIndex >= fields.length) {
+                                buf.append("<missing field>");
+                            } else {
+                                ResolvedJavaField field = fields[fieldIndex];
+                                buf.append(field.getName());
+                                if (vo.slotKinds[i].getSlotCount() == 2 && field.getType().getJavaKind().getSlotCount() == 1) {
+                                    if (fieldIndex + 1 >= fields.length) {
+                                        buf.append("/<missing field>");
+                                    } else {
+                                        ResolvedJavaField field2 = fields[++fieldIndex];
+                                        buf.append('/').append(field2.getName());
+                                    }
+                                }
+                            }
+                            buf.append('=');
                             appendValue(buf, vo.values[i], visited);
                         }
+                        // Extra fields
+                        for (; fieldIndex < fields.length; fieldIndex++) {
+                            buf.append(fields[fieldIndex].getName()).append("=<missing value>");
+                        }
                     }
                 }
                 buf.append('}');
@@ -104,6 +142,55 @@
         return buf;
     }
 
+    public interface LayoutVerifier {
+        int getOffset(ResolvedJavaField field);
+
+        default JavaKind getStorageKind(ResolvedJavaField field) {
+            return field.getType().getJavaKind();
+        }
+    }
+
+    public void verifyLayout(LayoutVerifier verifier) {
+        if (!type.isArray()) {
+            ResolvedJavaField[] fields = type.getInstanceFields(true);
+            int fieldIndex = 0;
+            for (int i = 0; i < values.length; i++, fieldIndex++) {
+                JavaKind slotKind = slotKinds[i];
+                if (fieldIndex >= fields.length) {
+                    throw new JVMCIError("Not enough fields for the values provided for %s", toString());
+                } else {
+                    ResolvedJavaField field = fields[fieldIndex];
+                    JavaKind fieldKind = verifier.getStorageKind(field);
+                    if (slotKind.getSlotCount() == 2 && fieldKind == JavaKind.Int) {
+                        int offset = verifier.getOffset(field);
+                        if (offset % 8 != 0) {
+                            throw new JVMCIError("Double word value stored across two ints must be aligned %s", toString());
+                        }
+
+                        if (fieldIndex + 1 >= fields.length) {
+                            throw new JVMCIError("Missing second field for double word value stored in two ints %s", toString());
+                        }
+                        ResolvedJavaField field2 = fields[fieldIndex + 1];
+                        if (field2.getType().getJavaKind() != JavaKind.Int) {
+                            throw new JVMCIError("Second field for double word value stored in two ints must be int but got %s in %s", field2.getType().getJavaKind(), toString());
+                        }
+                        int offset2 = verifier.getOffset(field2);
+                        if (offset + 4 != offset2) {
+                            throw new JVMCIError("Double word value stored across two ints must be sequential %s", toString());
+                        }
+                        fieldIndex++;
+                    } else if (fieldKind.getStackKind() != slotKind.getStackKind()) {
+                        throw new JVMCIError("Expected value of kind %s but got %s for field %s in %s", fieldKind, slotKind, field, toString());
+                    }
+                }
+            }
+            // Extra fields
+            if (fieldIndex < fields.length) {
+                throw new JVMCIError("Not enough values provided for fields in %s", this);
+            }
+        }
+    }
+
     @Override
     public String toString() {
         Set<VirtualObject> visited = Collections.newSetFromMap(new IdentityHashMap<VirtualObject, Boolean>());
@@ -119,6 +206,17 @@
     }
 
     /**
+     * Returns the pre-existing object, or null if a new object needs to be allocated.
+     */
+    public JavaValue getBaseObject() {
+        return baseObject;
+    }
+
+    public void setBaseObject(JavaValue baseObject) {
+        this.baseObject = baseObject;
+    }
+
+    /**
      * Returns the array containing all the values to be stored into the object when it is
      * recreated. This field is intentional exposed as a mutable array that a compiler may modify
      * (e.g. during register allocation).
--- old/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/DebugInfoBuilder.java	2018-11-01 11:13:15.000000000 +0100
+++ new/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/DebugInfoBuilder.java	2018-11-01 11:13:15.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2018 Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -92,6 +92,10 @@
                         if (!(state instanceof MaterializedObjectState) || ((MaterializedObjectState) state).materializedValue() != state.object()) {
                             objectStates.put(state.object(), state);
                         }
+                        if (state.object().baseObject() != null) {
+                            virtualObjects.put(state.object(), VirtualObject.get(state.object().type(), toJavaValue(state.object().baseObject()), virtualObjects.size()));
+                            pendingVirtualObjects.add(state.object());
+                        }
                     }
                 }
             }
@@ -126,7 +130,7 @@
                         ValueNode value = currentField.values().get(i);
                         if (value == null) {
                             JavaKind entryKind = vobjNode.entryKind(i);
-                            values[pos] = JavaConstant.defaultForKind(entryKind.getStackKind());
+                            values[pos] = vobjNode.baseObject() != null ? Value.ILLEGAL : JavaConstant.defaultForKind(entryKind.getStackKind());
                             slotKinds[pos] = entryKind.getStackKind();
                             pos++;
                         } else if (!value.isConstant() || value.asJavaConstant().getJavaKind() != JavaKind.Illegal) {
--- old/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/LIRFrameState.java	2018-11-01 11:13:17.000000000 +0100
+++ new/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/LIRFrameState.java	2018-11-01 11:13:16.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -88,6 +88,9 @@
         if (virtualObjects != null) {
             for (VirtualObject obj : virtualObjects) {
                 processValues(inst, obj.getValues(), proc);
+                if (obj.getBaseObject() != null) {
+                    obj.setBaseObject(processValue(inst, obj.getBaseObject(), proc));
+                }
             }
         }
         if (liveBasePointers != null) {
@@ -107,6 +110,9 @@
         if (virtualObjects != null) {
             for (VirtualObject obj : virtualObjects) {
                 visitValues(inst, obj.getValues(), proc);
+                if (obj.getBaseObject() != null) {
+                    visitValue(inst, obj.getBaseObject(), proc);
+                }
             }
         }
         if (liveBasePointers != null) {
@@ -122,52 +128,59 @@
 
     protected void processValues(LIRInstruction inst, JavaValue[] values, InstructionValueProcedure proc) {
         for (int i = 0; i < values.length; i++) {
-            JavaValue value = values[i];
-            if (isIllegalJavaValue(value)) {
-                continue;
-            }
-            if (value instanceof AllocatableValue) {
-                AllocatableValue allocatable = (AllocatableValue) value;
-                Value result = proc.doValue(inst, allocatable, OperandMode.ALIVE, STATE_FLAGS);
-                if (!allocatable.identityEquals(result)) {
-                    values[i] = (JavaValue) result;
-                }
-            } else if (value instanceof StackLockValue) {
-                StackLockValue monitor = (StackLockValue) value;
-                JavaValue owner = monitor.getOwner();
-                if (owner instanceof AllocatableValue) {
-                    monitor.setOwner((JavaValue) proc.doValue(inst, (AllocatableValue) owner, OperandMode.ALIVE, STATE_FLAGS));
-                }
-                Value slot = monitor.getSlot();
-                if (isVirtualStackSlot(slot)) {
-                    monitor.setSlot(asAllocatableValue(proc.doValue(inst, slot, OperandMode.ALIVE, STATE_FLAGS)));
-                }
-            } else {
-                assert unprocessed(value);
+            values[i] = processValue(inst, values[i], proc);
+        }
+    }
+
+    private JavaValue processValue(LIRInstruction inst, JavaValue value, InstructionValueProcedure proc) {
+        if (isIllegalJavaValue(value)) {
+            return value;
+        }
+        if (value instanceof AllocatableValue) {
+            AllocatableValue allocatable = (AllocatableValue) value;
+            Value result = proc.doValue(inst, allocatable, OperandMode.ALIVE, STATE_FLAGS);
+            if (!allocatable.identityEquals(result)) {
+                return (JavaValue) result;
+            }
+        } else if (value instanceof StackLockValue) {
+            StackLockValue monitor = (StackLockValue) value;
+            JavaValue owner = monitor.getOwner();
+            if (owner instanceof AllocatableValue) {
+                monitor.setOwner((JavaValue) proc.doValue(inst, (AllocatableValue) owner, OperandMode.ALIVE, STATE_FLAGS));
             }
+            Value slot = monitor.getSlot();
+            if (isVirtualStackSlot(slot)) {
+                monitor.setSlot(asAllocatableValue(proc.doValue(inst, slot, OperandMode.ALIVE, STATE_FLAGS)));
+            }
+        } else {
+            assert unprocessed(value);
         }
+        return value;
     }
 
     protected void visitValues(LIRInstruction inst, JavaValue[] values, InstructionValueConsumer proc) {
         for (int i = 0; i < values.length; i++) {
-            JavaValue value = values[i];
-            if (isIllegalJavaValue(value)) {
-                continue;
-            } else if (value instanceof AllocatableValue) {
-                proc.visitValue(inst, (AllocatableValue) value, OperandMode.ALIVE, STATE_FLAGS);
-            } else if (value instanceof StackLockValue) {
-                StackLockValue monitor = (StackLockValue) value;
-                JavaValue owner = monitor.getOwner();
-                if (owner instanceof AllocatableValue) {
-                    proc.visitValue(inst, (AllocatableValue) owner, OperandMode.ALIVE, STATE_FLAGS);
-                }
-                Value slot = monitor.getSlot();
-                if (isVirtualStackSlot(slot)) {
-                    proc.visitValue(inst, slot, OperandMode.ALIVE, STATE_FLAGS);
-                }
-            } else {
-                assert unprocessed(value);
+            visitValue(inst, values[i], proc);
+        }
+    }
+
+    private void visitValue(LIRInstruction inst, JavaValue value, InstructionValueConsumer proc) {
+        if (isIllegalJavaValue(value)) {
+            return;
+        } else if (value instanceof AllocatableValue) {
+            proc.visitValue(inst, (AllocatableValue) value, OperandMode.ALIVE, STATE_FLAGS);
+        } else if (value instanceof StackLockValue) {
+            StackLockValue monitor = (StackLockValue) value;
+            JavaValue owner = monitor.getOwner();
+            if (owner instanceof AllocatableValue) {
+                proc.visitValue(inst, (AllocatableValue) owner, OperandMode.ALIVE, STATE_FLAGS);
             }
+            Value slot = monitor.getSlot();
+            if (isVirtualStackSlot(slot)) {
+                proc.visitValue(inst, slot, OperandMode.ALIVE, STATE_FLAGS);
+            }
+        } else {
+            assert unprocessed(value);
         }
     }
 
--- old/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/virtual/EscapeObjectState.java	2018-11-01 11:13:18.000000000 +0100
+++ new/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/virtual/EscapeObjectState.java	2018-11-01 11:13:17.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,7 +36,7 @@
 public abstract class EscapeObjectState extends VirtualState implements ValueNumberable {
     public static final NodeClass<EscapeObjectState> TYPE = NodeClass.create(EscapeObjectState.class);
 
-    @Input protected VirtualObjectNode object;
+    @OptionalInput protected VirtualObjectNode object;
 
     public VirtualObjectNode object() {
         return object;
--- old/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/virtual/VirtualInstanceNode.java	2018-11-01 11:13:19.000000000 +0100
+++ new/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/virtual/VirtualInstanceNode.java	2018-11-01 11:13:18.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,22 +42,34 @@
     protected final ResolvedJavaType type;
     protected final ResolvedJavaField[] fields;
 
+    @OptionalInput private ValueNode baseObject;
+
     public VirtualInstanceNode(ResolvedJavaType type, boolean hasIdentity) {
         this(type, type.getInstanceFields(true), hasIdentity);
     }
 
+    public VirtualInstanceNode(ResolvedJavaType type, ValueNode baseObject) {
+        this(TYPE, type, type.getInstanceFields(true), true, baseObject);
+    }
+
     public VirtualInstanceNode(ResolvedJavaType type, ResolvedJavaField[] fields, boolean hasIdentity) {
-        this(TYPE, type, fields, hasIdentity);
+        this(TYPE, type, fields, hasIdentity, null);
     }
 
     protected VirtualInstanceNode(NodeClass<? extends VirtualInstanceNode> c, ResolvedJavaType type, boolean hasIdentity) {
-        this(c, type, type.getInstanceFields(true), hasIdentity);
+        this(c, type, type.getInstanceFields(true), hasIdentity, null);
     }
 
-    protected VirtualInstanceNode(NodeClass<? extends VirtualInstanceNode> c, ResolvedJavaType type, ResolvedJavaField[] fields, boolean hasIdentity) {
+    protected VirtualInstanceNode(NodeClass<? extends VirtualInstanceNode> c, ResolvedJavaType type, ResolvedJavaField[] fields, boolean hasIdentity, ValueNode baseObject) {
         super(c, type, hasIdentity);
         this.type = type;
         this.fields = fields;
+        this.baseObject = baseObject;
+    }
+
+    @Override
+    public ValueNode baseObject() {
+        return baseObject;
     }
 
     @Override
--- old/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/virtual/VirtualObjectNode.java	2018-11-01 11:13:20.000000000 +0100
+++ new/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/virtual/VirtualObjectNode.java	2018-11-01 11:13:19.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -73,6 +73,10 @@
         resetObjectId();
     }
 
+    public ValueNode baseObject() {
+        return null;
+    }
+
     /**
      * The type of object described by this {@link VirtualObjectNode}. In case of arrays, this is
      * the array type (and not the component type).
--- /dev/null	2018-11-01 11:13:21.000000000 +0100
+++ new/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ea/DeferredWriteTest.java	2018-11-01 11:13:20.000000000 +0100
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.graalvm.compiler.core.test.ea;
+
+import org.graalvm.compiler.api.directives.GraalDirectives;
+import org.graalvm.compiler.core.common.CompilationIdentifier;
+import org.graalvm.compiler.core.test.GraalCompilerTest;
+import org.graalvm.compiler.nodes.ConstantNode;
+import org.graalvm.compiler.nodes.FrameState;
+import org.graalvm.compiler.nodes.NodeView;
+import org.graalvm.compiler.nodes.ParameterNode;
+import org.graalvm.compiler.nodes.StructuredGraph;
+import org.graalvm.compiler.nodes.ValueNode;
+import org.graalvm.compiler.nodes.extended.StateSplitProxyNode;
+import org.graalvm.compiler.nodes.type.StampTool;
+import org.graalvm.compiler.nodes.virtual.VirtualInstanceNode;
+import org.graalvm.compiler.options.OptionValues;
+import org.graalvm.compiler.virtual.nodes.VirtualObjectState;
+import org.junit.Test;
+
+import jdk.vm.ci.code.InstalledCode;
+import jdk.vm.ci.meta.JavaKind;
+import jdk.vm.ci.meta.ResolvedJavaMethod;
+
+public class DeferredWriteTest extends GraalCompilerTest {
+
+    public static class TestObject {
+        int a;
+        Object b;
+        double c;
+        long d;
+        boolean e;
+
+        public TestObject(int a, Object b, double c, long d, boolean e) {
+            this.a = a;
+            this.b = b;
+            this.c = c;
+            this.d = d;
+            this.e = e;
+        }
+
+        public boolean compare(Object obj) {
+            TestObject other = (TestObject) obj;
+            return other.a == a && other.b == b && other.c == c && other.d == d && other.e == e;
+        }
+
+        protected TestObject copy() {
+            return new TestObject(a, b, c, d, e);
+        }
+    }
+
+    public static volatile int dummy;
+    public static volatile int dummy2;
+
+    public static void testSnippet(TestObject t) {
+        dummy = t.a;
+        if (dummy2 == 0) {
+            GraalDirectives.deoptimize();
+        }
+    }
+
+    private static int mode;
+
+    @Override
+    protected StructuredGraph parseForCompile(ResolvedJavaMethod method, CompilationIdentifier compilationId, OptionValues options) {
+        StructuredGraph graph = super.parseForCompile(method, compilationId, options);
+        StateSplitProxyNode frameStateHolder = graph.getNodes().filter(StateSplitProxyNode.class).first();
+
+        FrameState state = frameStateHolder.stateAfter();
+        ParameterNode param = graph.getNodes().filter(ParameterNode.class).first();
+        VirtualInstanceNode virtual = graph.add(new VirtualInstanceNode(StampTool.typeOrNull(param.stamp(NodeView.DEFAULT)), param));
+
+        ValueNode[] values = new ValueNode[5];
+        for (int i = 0; i < virtual.getFields().length; i++) {
+            switch (virtual.field(i).getName()) {
+                case "a":
+                    values[i] = mode == 0 ? ConstantNode.forInt(123, graph) : null;
+                    break;
+                case "b":
+                    values[i] = mode == 1 ? ConstantNode.defaultForKind(JavaKind.Object, graph) : null;
+                    break;
+                case "c":
+                    values[i] = mode == 2 ? ConstantNode.forDouble(123, graph) : null;
+                    break;
+                case "d":
+                    values[i] = mode == 3 ? ConstantNode.forLong(123, graph) : null;
+                    break;
+                case "e":
+                    values[i] = mode == 4 ? ConstantNode.forInt(0, graph) : null;
+                    break;
+            }
+        }
+        state.addVirtualObjectMapping(graph.unique(new VirtualObjectState(virtual, values)));
+        return graph;
+    }
+
+    @Override
+    protected InstalledCode getCode(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, boolean forceCompile, boolean installAsDefault, OptionValues options) {
+        return super.getCode(installedCodeOwner, graph, true, installAsDefault, options);
+    }
+
+    @Test
+    public void simple() {
+        for (mode = 0; mode < 5; mode++) {
+            TestObject input = new TestObject(1, TestObject.class, 1, 100000000000L, true);
+            test("testSnippet", input);
+            assert input.a == (mode == 0 ? 123 : 1) : input.a;
+            assert input.b == (mode == 1 ? null : TestObject.class) : input.b;
+            assert input.c == (mode == 2 ? 123D : 1D) : input.c;
+            assert input.d == (mode == 3 ? 123L : 100000000000L) : input.d;
+            assert input.e == (mode == 4 ? false : true) : input.e;
+        }
+    }
+}
