<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/share/vm/jvmci </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/share/vm/jvmci/jvmciRuntime.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/share/vm/jvmci/vmStructs_jvmci.cpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/share/vm/jvmci/jvmciRuntime.hpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  49   void warn_and_abort(const char* message) {
  50     warn(message);
  51     abort();
  52   }
  53   void warn(const char* message) {
  54     warning("Error at line %d while parsing %s: %s", _lineNo, _filename == NULL ? "?" : _filename, message);
  55   }
  56  public:
  57   ParseClosure() : _lineNo(0), _filename(NULL), _abort(false) {}
  58   void parse_line(char* line) {
  59     _lineNo++;
  60     do_line(line);
  61   }
  62   virtual void do_line(char* line) = 0;
  63   int lineNo() { return _lineNo; }
  64   bool is_aborted() { return _abort; }
  65   void set_filename(char* path) {_filename = path; _lineNo = 0;}
  66 };
  67 
  68 class JVMCIRuntime: public AllStatic {










  69  private:
  70   static jobject _HotSpotJVMCIRuntime_instance;
  71   static bool _HotSpotJVMCIRuntime_initialized;
  72   static bool _well_known_classes_initialized;
  73 
  74   static int _trivial_prefixes_count;
  75   static char** _trivial_prefixes;
  76 


  77   static bool _shutdown_called;
  78 
<span class="changed">  79   /**</span>
<span class="changed">  80    * Instantiates a service object, calls its default constructor and returns it.</span>
<span class="changed">  81    *</span>
<span class="changed">  82    * @param name the name of a class implementing jdk.vm.ci.service.Service</span>
<span class="changed">  83    */</span>
<span class="changed">  84   static Handle create_Service(const char* name, TRAPS);</span>
  85 
  86  public:
  87   static bool is_HotSpotJVMCIRuntime_initialized() {
  88     return _HotSpotJVMCIRuntime_initialized;
  89   }
  90 
  91   /**
  92    * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary
  93    */
  94   static Handle get_HotSpotJVMCIRuntime(TRAPS) {
  95     initialize_JVMCI(CHECK_(Handle()));
  96     return Handle(JNIHandles::resolve_non_null(_HotSpotJVMCIRuntime_instance));
  97   }
  98 
  99   static jobject get_HotSpotJVMCIRuntime_jobject(TRAPS) {
 100     initialize_JVMCI(CHECK_NULL);
 101     assert(_HotSpotJVMCIRuntime_initialized, "must be");
 102     return _HotSpotJVMCIRuntime_instance;
 103   }
 104 

</pre><hr></hr><pre>
 109    */
 110   static void initialize_JVMCI(TRAPS);
 111 
 112   /**
 113    * Explicitly initialize HotSpotJVMCIRuntime itself
 114    */
 115   static void initialize_HotSpotJVMCIRuntime(TRAPS);
 116 
 117   static void initialize_well_known_classes(TRAPS);
 118 
 119   static void metadata_do(void f(Metadata*));
 120 
 121   static void shutdown(TRAPS);
 122 
 123   static bool shutdown_called() {
 124     return _shutdown_called;
 125   }
 126 
 127   static bool treat_as_trivial(Method* method);
 128 












 129   static BasicType kindToBasicType(Handle kind, TRAPS);
 130 
 131   // The following routines are all called from compiled JVMCI code
 132 
 133   static void new_instance(JavaThread* thread, Klass* klass);
 134   static void new_array(JavaThread* thread, Klass* klass, jint length);
 135   static void new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims);
 136   static void dynamic_new_array(JavaThread* thread, oopDesc* element_mirror, jint length);
 137   static void dynamic_new_instance(JavaThread* thread, oopDesc* type_mirror);
 138   static jboolean thread_is_interrupted(JavaThread* thread, oopDesc* obj, jboolean clear_interrupted);
 139   static void vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3);
 140   static jint identity_hash_code(JavaThread* thread, oopDesc* obj);
 141   static address exception_handler_for_pc(JavaThread* thread);
 142   static void monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock);
 143   static void monitorexit (JavaThread* thread, oopDesc* obj, BasicLock* lock);
 144   static void vm_error(JavaThread* thread, jlong where, jlong format, jlong value);
 145   static oopDesc* load_and_clear_exception(JavaThread* thread);
 146   static void log_printf(JavaThread* thread, oopDesc* format, jlong v1, jlong v2, jlong v3);
 147   static void log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline);
 148   // Print the passed in object, optionally followed by a newline.  If

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
  49   void warn_and_abort(const char* message) {
  50     warn(message);
  51     abort();
  52   }
  53   void warn(const char* message) {
  54     warning("Error at line %d while parsing %s: %s", _lineNo, _filename == NULL ? "?" : _filename, message);
  55   }
  56  public:
  57   ParseClosure() : _lineNo(0), _filename(NULL), _abort(false) {}
  58   void parse_line(char* line) {
  59     _lineNo++;
  60     do_line(line);
  61   }
  62   virtual void do_line(char* line) = 0;
  63   int lineNo() { return _lineNo; }
  64   bool is_aborted() { return _abort; }
  65   void set_filename(char* path) {_filename = path; _lineNo = 0;}
  66 };
  67 
  68 class JVMCIRuntime: public AllStatic {
<span class="new">  69  public:</span>
<span class="new">  70   // Constants describing whether JVMCI wants to be able to adjust the compilation</span>
<span class="new">  71   // level selected for a method by the VM compilation policy and if so, based on</span>
<span class="new">  72   // what information about the method being schedule for compilation.</span>
<span class="new">  73   enum CompLevelAdjustment {</span>
<span class="new">  74      none = 0,             // no adjustment</span>
<span class="new">  75      by_holder = 1,        // adjust based on declaring class of method</span>
<span class="new">  76      by_full_signature = 2 // adjust based on declaring class, name and signature of method</span>
<span class="new">  77   };</span>
<span class="new">  78 </span>
  79  private:
  80   static jobject _HotSpotJVMCIRuntime_instance;
  81   static bool _HotSpotJVMCIRuntime_initialized;
  82   static bool _well_known_classes_initialized;
  83 
  84   static int _trivial_prefixes_count;
  85   static char** _trivial_prefixes;
  86 
<span class="new">  87   static CompLevelAdjustment _comp_level_adjustment;</span>
<span class="new">  88 </span>
  89   static bool _shutdown_called;
  90 
<span class="changed">  91   static CompLevel adjust_comp_level_inner(methodHandle method, bool is_osr, CompLevel level, JavaThread* thread);</span>





  92 
  93  public:
  94   static bool is_HotSpotJVMCIRuntime_initialized() {
  95     return _HotSpotJVMCIRuntime_initialized;
  96   }
  97 
  98   /**
  99    * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary
 100    */
 101   static Handle get_HotSpotJVMCIRuntime(TRAPS) {
 102     initialize_JVMCI(CHECK_(Handle()));
 103     return Handle(JNIHandles::resolve_non_null(_HotSpotJVMCIRuntime_instance));
 104   }
 105 
 106   static jobject get_HotSpotJVMCIRuntime_jobject(TRAPS) {
 107     initialize_JVMCI(CHECK_NULL);
 108     assert(_HotSpotJVMCIRuntime_initialized, "must be");
 109     return _HotSpotJVMCIRuntime_instance;
 110   }
 111 

</pre><hr></hr><pre>
 116    */
 117   static void initialize_JVMCI(TRAPS);
 118 
 119   /**
 120    * Explicitly initialize HotSpotJVMCIRuntime itself
 121    */
 122   static void initialize_HotSpotJVMCIRuntime(TRAPS);
 123 
 124   static void initialize_well_known_classes(TRAPS);
 125 
 126   static void metadata_do(void f(Metadata*));
 127 
 128   static void shutdown(TRAPS);
 129 
 130   static bool shutdown_called() {
 131     return _shutdown_called;
 132   }
 133 
 134   static bool treat_as_trivial(Method* method);
 135 
<span class="new"> 136   /**</span>
<span class="new"> 137    * Lets JVMCI modify the compilation level currently selected for a method by</span>
<span class="new"> 138    * the VM compilation policy.</span>
<span class="new"> 139    *</span>
<span class="new"> 140    * @param method the method being scheduled for compilation</span>
<span class="new"> 141    * @param is_osr specifies if the compilation is an OSR compilation</span>
<span class="new"> 142    * @param level the compilation level currently selected by the VM compilation policy</span>
<span class="new"> 143    * @param thread the current thread</span>
<span class="new"> 144    * @return the compilation level to use for the compilation</span>
<span class="new"> 145    */</span>
<span class="new"> 146   static CompLevel adjust_comp_level(methodHandle method, bool is_osr, CompLevel level, JavaThread* thread);</span>
<span class="new"> 147 </span>
 148   static BasicType kindToBasicType(Handle kind, TRAPS);
 149 
 150   // The following routines are all called from compiled JVMCI code
 151 
 152   static void new_instance(JavaThread* thread, Klass* klass);
 153   static void new_array(JavaThread* thread, Klass* klass, jint length);
 154   static void new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims);
 155   static void dynamic_new_array(JavaThread* thread, oopDesc* element_mirror, jint length);
 156   static void dynamic_new_instance(JavaThread* thread, oopDesc* type_mirror);
 157   static jboolean thread_is_interrupted(JavaThread* thread, oopDesc* obj, jboolean clear_interrupted);
 158   static void vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3);
 159   static jint identity_hash_code(JavaThread* thread, oopDesc* obj);
 160   static address exception_handler_for_pc(JavaThread* thread);
 161   static void monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock);
 162   static void monitorexit (JavaThread* thread, oopDesc* obj, BasicLock* lock);
 163   static void vm_error(JavaThread* thread, jlong where, jlong format, jlong value);
 164   static oopDesc* load_and_clear_exception(JavaThread* thread);
 165   static void log_printf(JavaThread* thread, oopDesc* format, jlong v1, jlong v2, jlong v3);
 166   static void log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline);
 167   // Print the passed in object, optionally followed by a newline.  If

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/share/vm/jvmci/jvmciRuntime.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/share/vm/jvmci/vmStructs_jvmci.cpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
