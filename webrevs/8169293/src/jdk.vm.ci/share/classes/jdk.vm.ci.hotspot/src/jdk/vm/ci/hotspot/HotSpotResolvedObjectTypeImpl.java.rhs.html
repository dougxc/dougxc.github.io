<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12272">12272</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8169293">8169293</a>: [JVMCI] incorrect assertion in HotSpotResolvedObjectTypeImpl.resolveMethod</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotConstantPool.isSignaturePolymorphicHolder;
  28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  29 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  30 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  31 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  32 
  33 import java.lang.annotation.Annotation;
  34 import java.lang.reflect.Array;
  35 import java.lang.reflect.Constructor;
  36 import java.lang.reflect.Method;
  37 import java.lang.reflect.Modifier;
  38 import java.nio.ByteOrder;
  39 import java.util.ArrayList;
  40 import java.util.Arrays;
  41 import java.util.HashMap;
  42 
  43 import jdk.vm.ci.common.JVMCIError;
  44 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  45 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  46 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  47 import jdk.vm.ci.meta.Assumptions.LeafType;
  48 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  49 import jdk.vm.ci.meta.Constant;
  50 import jdk.vm.ci.meta.JavaConstant;
  51 import jdk.vm.ci.meta.JavaKind;
  52 import jdk.vm.ci.meta.JavaType;
  53 import jdk.vm.ci.meta.ResolvedJavaField;
  54 import jdk.vm.ci.meta.ResolvedJavaMethod;
  55 import jdk.vm.ci.meta.ResolvedJavaType;
  56 
  57 /**
  58  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.
  59  */
  60 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceWrapperObject {
  61 
  62     /**
  63      * The Java class this type represents.
  64      */
  65     private final Class&lt;?&gt; javaClass;
  66     private HashMap&lt;Long, HotSpotResolvedJavaField&gt; fieldCache;
  67     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCache;
  68     private HotSpotResolvedJavaField[] instanceFields;
  69     private HotSpotResolvedObjectTypeImpl[] interfaces;
  70     private HotSpotConstantPool constantPool;
  71     final HotSpotJVMCIMetaAccessContext context;
  72     private HotSpotResolvedObjectType arrayOfType;
  73 
  74     /**
  75      * Gets the JVMCI mirror for a {@link Class} object.
  76      *
  77      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}
  78      */
  79     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {
  80         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);
  81     }
  82 
  83     /**
  84      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the
  85      * underlying Klass*, it is used instead of the raw Klass*.
  86      *
  87      * Called from the VM.
  88      *
  89      * @param javaClass a {@link Class} object
  90      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
  91      */
  92     @SuppressWarnings("unused")
  93     private static HotSpotResolvedObjectTypeImpl fromMetaspace(Class&lt;?&gt; javaClass) {
  94         return fromObjectClass(javaClass);
  95     }
  96 
  97     /**
  98      * Creates the JVMCI mirror for a {@link Class} object.
  99      *
 100      * &lt;p&gt;
 101      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
 102      * {@link Class} type. Use {@link #fromObjectClass(Class)} or {@link #fromMetaspace(Class)}
 103      * instead.
 104      * &lt;/p&gt;
 105      *
 106      * @param javaClass the Class to create the mirror for
 107      * @param context
 108      */
 109     HotSpotResolvedObjectTypeImpl(Class&lt;?&gt; javaClass, HotSpotJVMCIMetaAccessContext context) {
 110         super(getSignatureName(javaClass));
 111         this.javaClass = javaClass;
 112         this.context = context;
 113         assert getName().charAt(0) != '[' || isArray() : getName();
 114     }
 115 
 116     /**
 117      * Returns the name of this type as it would appear in a signature.
 118      */
 119     private static String getSignatureName(Class&lt;?&gt; javaClass) {
 120         if (javaClass.isArray()) {
 121             return javaClass.getName().replace('.', '/');
 122         }
 123         return "L" + javaClass.getName().replace('.', '/') + ";";
 124     }
 125 
 126     /**
 127      * Gets the metaspace Klass for this type.
 128      */
 129     long getMetaspaceKlass() {
 130         if (HotSpotJVMCIRuntime.getHostWordKind() == JavaKind.Long) {
 131             return UNSAFE.getLong(javaClass, config().klassOffset);
 132         }
 133         return UNSAFE.getInt(javaClass, config().klassOffset) &amp; 0xFFFFFFFFL;
 134     }
 135 
 136     @Override
 137     public long getMetaspacePointer() {
 138         return getMetaspaceKlass();
 139     }
 140 
 141     /**
 142      * The Klass* for this object is kept alive by the direct reference to {@link #javaClass} so no
 143      * extra work is required.
 144      */
 145     @Override
 146     public boolean isRegistered() {
 147         return true;
 148     }
 149 
 150     @Override
 151     public int getModifiers() {
 152         if (isArray()) {
 153             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 154         } else {
 155             return getAccessFlags() &amp; jvmClassModifiers();
 156         }
 157     }
 158 
 159     public int getAccessFlags() {
 160         HotSpotVMConfig config = config();
 161         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 162     }
 163 
 164     @Override
 165     public HotSpotResolvedObjectType getArrayClass() {
 166         if (arrayOfType == null) {
 167             arrayOfType = fromObjectClass(Array.newInstance(mirror(), 0).getClass());
 168         }
 169         return arrayOfType;
 170     }
 171 
 172     @Override
 173     public ResolvedJavaType getComponentType() {
 174         Class&lt;?&gt; javaComponentType = mirror().getComponentType();
 175         return javaComponentType == null ? null : runtime().fromClass(javaComponentType);
 176     }
 177 
 178     @Override
 179     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 180         if (isLeaf()) {
 181             // No assumptions are required.
 182             return new AssumptionResult&lt;&gt;(this);
 183         }
 184         HotSpotVMConfig config = config();
 185         if (isArray()) {
 186             ResolvedJavaType elementalType = getElementalType();
 187             AssumptionResult&lt;ResolvedJavaType&gt; elementType = elementalType.findLeafConcreteSubtype();
 188             if (elementType != null &amp;&amp; elementType.getResult().equals(elementalType)) {
 189                 /*
 190                  * If the elementType is leaf then the array is leaf under the same assumptions but
 191                  * only if the element type is exactly the leaf type. The element type can be
 192                  * abstract even if there is only one implementor of the abstract type.
 193                  */
 194                 AssumptionResult&lt;ResolvedJavaType&gt; result = new AssumptionResult&lt;&gt;(this);
 195                 result.add(elementType);
 196                 return result;
 197             }
 198             return null;
 199         } else if (isInterface()) {
 200             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
 201             /*
 202              * If the implementor field contains itself that indicates that the interface has more
 203              * than one implementors (see: InstanceKlass::add_implementor).
 204              */
 205             if (implementor == null || implementor.equals(this)) {
 206                 return null;
 207             }
 208 
 209             assert !implementor.isInterface();
 210             if (implementor.isAbstract() || !implementor.isLeafClass()) {
 211                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
 212                 if (leafConcreteSubtype != null) {
 213                     assert !leafConcreteSubtype.getResult().equals(implementor);
 214                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
 215                     // Accumulate leaf assumptions and return the combined result.
 216                     newResult.add(leafConcreteSubtype);
 217                     return newResult;
 218                 }
 219                 return null;
 220             }
 221             return concreteSubtype(implementor);
 222         } else {
 223             HotSpotResolvedObjectTypeImpl type = this;
 224             while (type.isAbstract()) {
 225                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
 226                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
 227                     return null;
 228                 }
 229                 type = subklass;
 230             }
 231             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
 232                 return null;
 233             }
 234             if (this.isAbstract()) {
 235                 return concreteSubtype(type);
 236             } else {
 237                 assert this.equals(type);
 238                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 239             }
 240         }
 241     }
 242 
 243     private AssumptionResult&lt;ResolvedJavaType&gt; concreteSubtype(HotSpotResolvedObjectTypeImpl type) {
 244         if (type.isLeaf()) {
 245             return new AssumptionResult&lt;&gt;(type, new ConcreteSubtype(this, type));
 246         } else {
 247             return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 248         }
 249     }
 250 
 251     /**
 252      * Returns if type {@code type} is a leaf class. This is the case if the
 253      * {@code Klass::_subklass} field of the underlying class is zero.
 254      *
 255      * @return true if the type is a leaf class
 256      */
 257     private boolean isLeafClass() {
 258         return getSubklass() == null;
 259     }
 260 
 261     /**
 262      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 263      * type {@code type}.
 264      *
 265      * @return value of the subklass field as metaspace klass pointer
 266      */
 267     private HotSpotResolvedObjectTypeImpl getSubklass() {
 268         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 269     }
 270 
 271     @Override
 272     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 273         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();
 274         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);
 275     }
 276 
 277     @Override
 278     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 279         if (interfaces == null) {
 280             Class&lt;?&gt;[] javaInterfaces = mirror().getInterfaces();
 281             HotSpotResolvedObjectTypeImpl[] result = new HotSpotResolvedObjectTypeImpl[javaInterfaces.length];
 282             for (int i = 0; i &lt; javaInterfaces.length; i++) {
 283                 result[i] = fromObjectClass(javaInterfaces[i]);
 284             }
 285             interfaces = result;
 286         }
 287         return interfaces;
 288     }
 289 
 290     @Override
 291     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 292         if (!isInterface()) {
 293             throw new JVMCIError("Cannot call getSingleImplementor() on a non-interface type: %s", this);
 294         }
 295         return compilerToVM().getImplementor(this);
 296     }
 297 
 298     public HotSpotResolvedObjectTypeImpl getSupertype() {
 299         if (isArray()) {
 300             ResolvedJavaType componentType = getComponentType();
 301             if (mirror() == Object[].class || componentType.isPrimitive()) {
 302                 return fromObjectClass(Object.class);
 303             }
 304             return (HotSpotResolvedObjectTypeImpl) ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype().getArrayClass();
 305         }
 306         if (isInterface()) {
 307             return fromObjectClass(Object.class);
 308         }
 309         return getSuperclass();
 310     }
 311 
 312     @Override
 313     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 314         if (otherType.isPrimitive()) {
 315             return null;
 316         } else {
 317             HotSpotResolvedObjectTypeImpl t1 = this;
 318             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 319             while (true) {
 320                 if (t1.isAssignableFrom(t2)) {
 321                     return t1;
 322                 }
 323                 if (t2.isAssignableFrom(t1)) {
 324                     return t2;
 325                 }
 326                 t1 = t1.getSupertype();
 327                 t2 = t2.getSupertype();
 328             }
 329         }
 330     }
 331 
 332     @Override
 333     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 334         assert !isArray();
 335         if (!compilerToVM().hasFinalizableSubclass(this)) {
 336             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 337         }
 338         return new AssumptionResult&lt;&gt;(true);
 339     }
 340 
 341     @Override
 342     public boolean hasFinalizer() {
 343         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 344     }
 345 
 346     @Override
 347     public boolean isPrimitive() {
 348         return false;
 349     }
 350 
 351     @Override
 352     public boolean isArray() {
 353         return mirror().isArray();
 354     }
 355 
 356     @Override
 357     public boolean isInitialized() {
 358         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 359     }
 360 
 361     @Override
 362     public boolean isLinked() {
 363         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 364     }
 365 
 366     /**
 367      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 368      * klass.
 369      *
 370      * @return state field value of this type
 371      */
 372     private int getInitState() {
 373         assert !isArray() : "_init_state only exists in InstanceKlass";
 374         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 375     }
 376 
 377     @Override
 378     public void initialize() {
 379         if (!isInitialized()) {
 380             UNSAFE.ensureClassInitialized(mirror());
 381             assert isInitialized();
 382         }
 383     }
 384 
 385     @Override
 386     public boolean isInstance(JavaConstant obj) {
 387         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
 388             return mirror().isInstance(((HotSpotObjectConstantImpl) obj).object());
 389         }
 390         return false;
 391     }
 392 
 393     @Override
 394     public boolean isInstanceClass() {
 395         return !isArray() &amp;&amp; !isInterface();
 396     }
 397 
 398     @Override
 399     public boolean isInterface() {
 400         return mirror().isInterface();
 401     }
 402 
 403     @Override
 404     public boolean isAssignableFrom(ResolvedJavaType other) {
 405         assert other != null;
 406         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 407             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
 408             return mirror().isAssignableFrom(otherType.mirror());
 409         }
 410         return false;
 411     }
 412 
 413     @Override
 414     public boolean isJavaLangObject() {
 415         return javaClass.equals(Object.class);
 416     }
 417 
 418     @Override
 419     public JavaKind getJavaKind() {
 420         return JavaKind.Object;
 421     }
 422 
 423     @Override
 424     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
<a name="1" id="anc1"></a>
 425         if (isInterface()) {
 426             // Methods can only be resolved against concrete types
 427             return null;
 428         }
 429         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic() &amp;&amp; !isSignaturePolymorphicHolder(method.getDeclaringClass())) {
 430             return method;
 431         }
 432         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 433             return null;
 434         }
 435         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
 436         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
 437         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
 438     }
 439 
 440     public HotSpotConstantPool getConstantPool() {
 441         if (constantPool == null || !isArray() &amp;&amp; UNSAFE.getAddress(getMetaspaceKlass() + config().instanceKlassConstantsOffset) != constantPool.getMetaspaceConstantPool()) {
 442             /*
 443              * If the pointer to the ConstantPool has changed since this was last read refresh the
 444              * HotSpotConstantPool wrapper object. This ensures that uses of the constant pool are
 445              * operating on the latest one and that HotSpotResolvedJavaMethodImpls will be able to
 446              * use the shared copy instead of creating their own instance.
 447              */
 448             constantPool = compilerToVM().getConstantPool(this);
 449         }
 450         return constantPool;
 451     }
 452 
 453     /**
 454      * Gets the instance size of this type. If an instance of this type cannot be fast path
 455      * allocated, then the returned value is negative (its absolute value gives the size). Must not
 456      * be called if this is an array or interface type.
 457      */
 458     public int instanceSize() {
 459         assert !isArray();
 460         assert !isInterface();
 461 
 462         HotSpotVMConfig config = config();
 463         final int layoutHelper = layoutHelper();
 464         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : "must be instance";
 465 
 466         // See: Klass::layout_helper_size_in_bytes
 467         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 468 
 469         // See: Klass::layout_helper_needs_slow_path
 470         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 471 
 472         return needsSlowPath ? -size : size;
 473     }
 474 
 475     public int layoutHelper() {
 476         HotSpotVMConfig config = config();
 477         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 478     }
 479 
 480     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {
 481         HotSpotResolvedJavaMethodImpl method = null;
 482         if (methodCache == null) {
 483             methodCache = new HashMap&lt;&gt;(8);
 484         } else {
 485             method = methodCache.get(metaspaceMethod);
 486         }
 487         if (method == null) {
 488             method = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);
 489             methodCache.put(metaspaceMethod, method);
 490             context.add(method);
 491         }
 492         return method;
 493     }
 494 
 495     public int getVtableLength() {
 496         HotSpotVMConfig config = config();
 497         if (isInterface() || isArray()) {
 498             /* Everything has the core vtable of java.lang.Object */
 499             return config.baseVtableLength();
 500         }
 501         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 502         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + " " + config.vtableEntrySize;
 503         return result;
 504     }
 505 
 506     synchronized HotSpotResolvedJavaField createField(String fieldName, JavaType type, long offset, int rawFlags) {
 507         HotSpotResolvedJavaField result = null;
 508 
 509         final int flags = rawFlags &amp; HotSpotModifiers.jvmFieldModifiers();
 510 
 511         final long id = offset + ((long) flags &lt;&lt; 32);
 512 
 513         // Must cache the fields, because the local load elimination only works if the
 514         // objects from two field lookups are identical.
 515         if (fieldCache == null) {
 516             fieldCache = new HashMap&lt;&gt;(8);
 517         } else {
 518             result = fieldCache.get(id);
 519         }
 520 
 521         if (result == null) {
 522             result = new HotSpotResolvedJavaFieldImpl(this, fieldName, type, offset, rawFlags);
 523             fieldCache.put(id, result);
 524         } else {
 525             assert result.getName().equals(fieldName);
 526             /*
 527              * Comparing the types directly is too strict, because the type in the cache could be
 528              * resolved while the incoming type is unresolved. The name comparison is sufficient
 529              * because the type will always be resolved in the context of the holder.
 530              */
 531             assert result.getType().getName().equals(type.getName());
 532             assert result.offset() == offset;
 533             assert result.getModifiers() == flags;
 534         }
 535 
 536         return result;
 537     }
 538 
 539     @Override
 540     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 541         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 542         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 543         /*
 544          * Sometimes the receiver type in the graph hasn't stabilized to a subtype of declared
 545          * holder, usually because of phis, so make sure that the type is related to the declared
 546          * type before using it for lookup. Unlinked types should also be ignored because we can't
 547          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 548          * a deopt instead since they can't really be used if they aren't linked yet.
 549          */
 550         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 551             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 552             if (result != null) {
 553                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 554             }
 555             return null;
 556         }
 557         /*
 558          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 559          * the correct method for the subtype.
 560          */
 561         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 562         if (resolvedMethod == null) {
 563             // The type isn't known to implement the method.
 564             return null;
 565         }
 566 
 567         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 568         if (result != null) {
 569             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 570         }
 571         return null;
 572     }
 573 
 574     /**
 575      * This class represents the field information for one field contained in the fields array of an
 576      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 577      */
 578     private class FieldInfo {
 579         /**
 580          * Native pointer into the array of Java shorts.
 581          */
 582         private final long metaspaceData;
 583 
 584         /**
 585          * Creates a field info for the field in the fields array at index {@code index}.
 586          *
 587          * @param index index to the fields array
 588          */
 589         FieldInfo(int index) {
 590             HotSpotVMConfig config = config();
 591             // Get Klass::_fields
 592             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 593             assert config.fieldInfoFieldSlots == 6 : "revisit the field parsing code";
 594             int offset = config.fieldInfoFieldSlots * Short.BYTES * index;
 595             metaspaceData = metaspaceFields + config.arrayU2DataOffset + offset;
 596         }
 597 
 598         private int getAccessFlags() {
 599             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
 600         }
 601 
 602         private int getNameIndex() {
 603             return readFieldSlot(config().fieldInfoNameIndexOffset);
 604         }
 605 
 606         private int getSignatureIndex() {
 607             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
 608         }
 609 
 610         public int getOffset() {
 611             HotSpotVMConfig config = config();
 612             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
 613             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
 614             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
 615             return offset;
 616         }
 617 
 618         /**
 619          * Helper method to read an entry (slot) from the field array. Currently field info is laid
 620          * on top an array of Java shorts.
 621          */
 622         private int readFieldSlot(int index) {
 623             int offset = Short.BYTES * index;
 624             return UNSAFE.getChar(metaspaceData + offset);
 625         }
 626 
 627         /**
 628          * Returns the name of this field as a {@link String}. If the field is an internal field the
 629          * name index is pointing into the vmSymbols table.
 630          */
 631         public String getName() {
 632             final int nameIndex = getNameIndex();
 633             return isInternal() ? config().symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
 634         }
 635 
 636         /**
 637          * Returns the signature of this field as {@link String}. If the field is an internal field
 638          * the signature index is pointing into the vmSymbols table.
 639          */
 640         public String getSignature() {
 641             final int signatureIndex = getSignatureIndex();
 642             return isInternal() ? config().symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
 643         }
 644 
 645         public JavaType getType() {
 646             String signature = getSignature();
 647             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 648         }
 649 
 650         private boolean isInternal() {
 651             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 652         }
 653 
 654         public boolean isStatic() {
 655             return Modifier.isStatic(getAccessFlags());
 656         }
 657 
 658         public boolean hasGenericSignature() {
 659             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 660         }
 661     }
 662 
 663     @SuppressFBWarnings(value = "SE_COMPARATOR_SHOULD_BE_SERIALIZABLE", justification = "comparator is only used transiently")
 664     private static class OffsetComparator implements java.util.Comparator&lt;HotSpotResolvedJavaField&gt; {
 665         @Override
 666         public int compare(HotSpotResolvedJavaField o1, HotSpotResolvedJavaField o2) {
 667             return o1.offset() - o2.offset();
 668         }
 669     }
 670 
 671     @Override
 672     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 673         if (instanceFields == null) {
 674             if (isArray() || isInterface()) {
 675                 instanceFields = new HotSpotResolvedJavaField[0];
 676             } else {
 677                 final int fieldCount = getFieldCount();
 678                 ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 679 
 680                 for (int i = 0; i &lt; fieldCount; i++) {
 681                     FieldInfo field = new FieldInfo(i);
 682 
 683                     // We are only interested in instance fields.
 684                     if (!field.isStatic()) {
 685                         HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 686                         fieldsArray.add(resolvedJavaField);
 687                     }
 688                 }
 689 
 690                 fieldsArray.sort(new OffsetComparator());
 691 
 692                 HotSpotResolvedJavaField[] myFields = fieldsArray.toArray(new HotSpotResolvedJavaField[0]);
 693 
 694                 if (mirror() != Object.class) {
 695                     HotSpotResolvedJavaField[] superFields = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 696                     HotSpotResolvedJavaField[] fields = Arrays.copyOf(superFields, superFields.length + myFields.length);
 697                     System.arraycopy(myFields, 0, fields, superFields.length, myFields.length);
 698                     instanceFields = fields;
 699                 } else {
 700                     assert myFields.length == 0 : "java.lang.Object has fields!";
 701                     instanceFields = myFields;
 702                 }
 703 
 704             }
 705         }
 706         if (!includeSuperclasses) {
 707             int myFieldsStart = 0;
 708             while (myFieldsStart &lt; instanceFields.length &amp;&amp; !instanceFields[myFieldsStart].getDeclaringClass().equals(this)) {
 709                 myFieldsStart++;
 710             }
 711             if (myFieldsStart == 0) {
 712                 return instanceFields;
 713             }
 714             if (myFieldsStart == instanceFields.length) {
 715                 return new HotSpotResolvedJavaField[0];
 716             }
 717             return Arrays.copyOfRange(instanceFields, myFieldsStart, instanceFields.length);
 718         }
 719         return instanceFields;
 720     }
 721 
 722     @Override
 723     public ResolvedJavaField[] getStaticFields() {
 724         if (isArray()) {
 725             return new HotSpotResolvedJavaField[0];
 726         } else {
 727             final int fieldCount = getFieldCount();
 728             ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 729 
 730             for (int i = 0; i &lt; fieldCount; i++) {
 731                 FieldInfo field = new FieldInfo(i);
 732 
 733                 // We are only interested in static fields.
 734                 if (field.isStatic()) {
 735                     HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 736                     fieldsArray.add(resolvedJavaField);
 737                 }
 738             }
 739 
 740             fieldsArray.sort(new OffsetComparator());
 741             return fieldsArray.toArray(new HotSpotResolvedJavaField[fieldsArray.size()]);
 742         }
 743     }
 744 
 745     /**
 746      * Returns the actual field count of this class's internal {@code InstanceKlass::_fields} array
 747      * by walking the array and discounting the generic signature slots at the end of the array.
 748      *
 749      * &lt;p&gt;
 750      * See {@code FieldStreamBase::init_generic_signature_start_slot}
 751      */
 752     private int getFieldCount() {
 753         HotSpotVMConfig config = config();
 754         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 755         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
 756         int fieldCount = 0;
 757 
 758         for (int i = 0, index = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
 759             FieldInfo field = new FieldInfo(index);
 760             if (field.hasGenericSignature()) {
 761                 metaspaceFieldsLength--;
 762             }
 763             fieldCount++;
 764         }
 765         return fieldCount;
 766     }
 767 
 768     @Override
 769     public Class&lt;?&gt; mirror() {
 770         return javaClass;
 771     }
 772 
 773     @Override
 774     public String getSourceFileName() {
 775         HotSpotVMConfig config = config();
 776         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
 777         if (sourceFileNameIndex == 0) {
 778             return null;
 779         }
 780         return getConstantPool().lookupUtf8(sourceFileNameIndex);
 781     }
 782 
 783     @Override
 784     public Annotation[] getAnnotations() {
 785         return mirror().getAnnotations();
 786     }
 787 
 788     @Override
 789     public Annotation[] getDeclaredAnnotations() {
 790         return mirror().getDeclaredAnnotations();
 791     }
 792 
 793     @Override
 794     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 795         return mirror().getAnnotation(annotationClass);
 796     }
 797 
 798     /**
 799      * Performs a fast-path check that this type is resolved in the context of a given accessing
 800      * class. A negative result does not mean this type is not resolved with respect to
 801      * {@code accessingClass}. That can only be determined by
 802      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 803      * re-resolving} the type.
 804      */
 805     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 806         assert accessingClass != null;
 807         ResolvedJavaType elementType = getElementalType();
 808         if (elementType.isPrimitive()) {
 809             // Primitive type resolution is context free.
 810             return true;
 811         }
 812         if (elementType.getName().startsWith("Ljava/")) {
 813             // Classes in a java.* package can only be defined by the
 814             // boot class loader. This is enforced by ClassLoader.preDefineClass()
 815             assert mirror().getClassLoader() == null;
 816             return true;
 817         }
 818         ClassLoader thisCl = mirror().getClassLoader();
 819         ClassLoader accessingClassCl = ((HotSpotResolvedObjectTypeImpl) accessingClass).mirror().getClassLoader();
 820         return thisCl == accessingClassCl;
 821     }
 822 
 823     @Override
 824     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 825         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 826             return this;
 827         }
 828         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 829         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 830     }
 831 
 832     /**
 833      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 834      */
 835     public Constant klass() {
 836         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 837     }
 838 
 839     public boolean isPrimaryType() {
 840         return config().secondarySuperCacheOffset != superCheckOffset();
 841     }
 842 
 843     public int superCheckOffset() {
 844         HotSpotVMConfig config = config();
 845         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
 846     }
 847 
 848     public long prototypeMarkWord() {
 849         HotSpotVMConfig config = config();
 850         if (isArray()) {
 851             return config.arrayPrototypeMarkWord();
 852         } else {
 853             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 854         }
 855     }
 856 
 857     @Override
 858     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 859         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 860         for (ResolvedJavaField field : declaredFields) {
 861             HotSpotResolvedJavaField resolvedField = (HotSpotResolvedJavaField) field;
 862             long resolvedFieldOffset = resolvedField.offset();
 863             // @formatter:off
 864             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN  &amp;&amp;
 865                             expectedEntryKind.isPrimitive() &amp;&amp;
 866                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;
 867                             resolvedField.getJavaKind().isPrimitive()) {
 868                 resolvedFieldOffset +=
 869                                 resolvedField.getJavaKind().getByteCount() -
 870                                 Math.min(resolvedField.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());
 871             }
 872             if (resolvedFieldOffset == offset) {
 873                 return field;
 874             }
 875             // @formatter:on
 876         }
 877         return null;
 878     }
 879 
 880     @Override
 881     public boolean isLocal() {
 882         return mirror().isLocalClass();
 883     }
 884 
 885     @Override
 886     public boolean isMember() {
 887         return mirror().isMemberClass();
 888     }
 889 
 890     @Override
 891     public HotSpotResolvedObjectTypeImpl getEnclosingType() {
 892         final Class&lt;?&gt; encl = mirror().getEnclosingClass();
 893         return encl == null ? null : fromObjectClass(encl);
 894     }
 895 
 896     @Override
 897     public ResolvedJavaMethod[] getDeclaredConstructors() {
 898         Constructor&lt;?&gt;[] constructors = mirror().getDeclaredConstructors();
 899         ResolvedJavaMethod[] result = new ResolvedJavaMethod[constructors.length];
 900         for (int i = 0; i &lt; constructors.length; i++) {
 901             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(constructors[i]);
 902             assert result[i].isConstructor();
 903         }
 904         return result;
 905     }
 906 
 907     @Override
 908     public ResolvedJavaMethod[] getDeclaredMethods() {
 909         Method[] methods = mirror().getDeclaredMethods();
 910         ResolvedJavaMethod[] result = new ResolvedJavaMethod[methods.length];
 911         for (int i = 0; i &lt; methods.length; i++) {
 912             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(methods[i]);
 913             assert !result[i].isConstructor();
 914         }
 915         return result;
 916     }
 917 
 918     public ResolvedJavaMethod getClassInitializer() {
 919         return compilerToVM().getClassInitializer(this);
 920     }
 921 
 922     @Override
 923     public String toString() {
 924         return "HotSpotType&lt;" + getName() + ", resolved&gt;";
 925     }
 926 
 927     @Override
 928     public boolean isCloneableWithAllocation() {
 929         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
 930     }
 931 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
