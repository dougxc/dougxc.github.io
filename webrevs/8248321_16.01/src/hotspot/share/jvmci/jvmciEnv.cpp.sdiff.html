<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>open Sdiff src/hotspot/share/jvmci </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/hotspot/share/jvmci/jvmciCompilerToVM.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/jvmci/jvmciEnv.hpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/jvmci/jvmciEnv.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-59942">59942</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8248359">8248359</a>: [JVMCI] miscellaneous code cleanups and improvements</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  60   }
  61   if (!jvmti_can_access_local_variables() &amp;&amp;
  62       JvmtiExport::can_access_local_variables()) {
  63     return true;
  64   }
  65   if (!jvmti_can_hotswap_or_post_breakpoint() &amp;&amp;
  66       JvmtiExport::can_hotswap_or_post_breakpoint()) {
  67     return true;
  68   }
  69   if (!jvmti_can_post_on_exceptions() &amp;&amp;
  70       JvmtiExport::can_post_on_exceptions()) {
  71     return true;
  72   }
  73   if (!jvmti_can_pop_frame() &amp;&amp;
  74       JvmtiExport::can_pop_frame()) {
  75     return true;
  76   }
  77   return false;
  78 }
  79 
<span class="removed">  80 JavaVM* JVMCIEnv::_shared_library_javavm = NULL;</span>
<span class="removed">  81 void* JVMCIEnv::_shared_library_handle = NULL;</span>
<span class="removed">  82 char* JVMCIEnv::_shared_library_path = NULL;</span>
<span class="removed">  83 </span>
  84 void JVMCIEnv::copy_saved_properties() {
  85   assert(!is_hotspot(), "can only copy saved properties from HotSpot to native image");
  86 
  87   JavaThread* THREAD = JavaThread::current();
  88 
  89   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_services_Services(), Handle(), Handle(), true, THREAD);
  90   if (HAS_PENDING_EXCEPTION) {
  91     JVMCIRuntime::exit_on_pending_exception(NULL, "Error initializing jdk.vm.ci.services.Services");
  92   }
  93   InstanceKlass* ik = InstanceKlass::cast(k);
  94   if (ik-&gt;should_be_initialized()) {
  95     ik-&gt;initialize(THREAD);
  96     if (HAS_PENDING_EXCEPTION) {
  97       JVMCIRuntime::exit_on_pending_exception(NULL, "Error initializing jdk.vm.ci.services.Services");
  98     }
  99   }
 100 
 101   // Get the serialized saved properties from HotSpot
 102   TempNewSymbol serializeSavedProperties = SymbolTable::new_symbol("serializeSavedProperties");
 103   JavaValue result(T_OBJECT);

</pre><hr></hr><pre>
 114 
 115   // Copy serialized saved properties from HotSpot object into native buffer
 116   jbyte* serialized_properties = NEW_RESOURCE_ARRAY(jbyte, serialized_properties_len);
 117   memcpy(serialized_properties, ba-&gt;byte_at_addr(0), serialized_properties_len);
 118 
 119   // Copy native buffer into shared library object
 120   JVMCIPrimitiveArray buf = new_byteArray(serialized_properties_len, this);
 121   if (has_pending_exception()) {
 122     describe_pending_exception(true);
 123     fatal("Error in copy_saved_properties");
 124   }
 125   copy_bytes_from(serialized_properties, buf, 0, serialized_properties_len);
 126   if (has_pending_exception()) {
 127     describe_pending_exception(true);
 128     fatal("Error in copy_saved_properties");
 129   }
 130 
 131   // Initialize saved properties in shared library
 132   jclass servicesClass = JNIJVMCI::Services::clazz();
 133   jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();
<span class="changed"> 134   JNIAccessMark jni(this);</span>
 135   jni()-&gt;CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());
 136   if (jni()-&gt;ExceptionCheck()) {
 137     jni()-&gt;ExceptionDescribe();
 138     fatal("Error calling jdk.vm.ci.services.Services.initializeSavedProperties");
 139   }
 140 }
 141 
<span class="removed"> 142 JNIEnv* JVMCIEnv::init_shared_library(JavaThread* thread) {</span>
<span class="removed"> 143   if (_shared_library_javavm == NULL) {</span>
<span class="removed"> 144     MutexLocker locker(JVMCI_lock);</span>
<span class="removed"> 145     if (_shared_library_javavm == NULL) {</span>
<span class="removed"> 146       char path[JVM_MAXPATHLEN];</span>
<span class="removed"> 147       char ebuf[1024];</span>
<span class="removed"> 148       if (JVMCILibPath != NULL) {</span>
<span class="removed"> 149         if (!os::dll_locate_lib(path, sizeof(path), JVMCILibPath, JVMCI_SHARED_LIBRARY_NAME)) {</span>
<span class="removed"> 150           vm_exit_during_initialization("Unable to create JVMCI shared library path from -XX:JVMCILibPath value", JVMCILibPath);</span>
<span class="removed"> 151         }</span>
<span class="removed"> 152       } else {</span>
<span class="removed"> 153         if (!os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {</span>
<span class="removed"> 154           vm_exit_during_initialization("Unable to create path to JVMCI shared library");</span>
<span class="removed"> 155         }</span>
<span class="removed"> 156       }</span>
<span class="removed"> 157 </span>
<span class="removed"> 158       void* handle = os::dll_load(path, ebuf, sizeof ebuf);</span>
<span class="removed"> 159       if (handle == NULL) {</span>
<span class="removed"> 160         vm_exit_during_initialization("Unable to load JVMCI shared library", ebuf);</span>
<span class="removed"> 161       }</span>
<span class="removed"> 162       _shared_library_handle = handle;</span>
<span class="removed"> 163       _shared_library_path = strdup(path);</span>
<span class="removed"> 164       jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);</span>
<span class="removed"> 165       typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);</span>
<span class="removed"> 166 </span>
<span class="removed"> 167       JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(handle, "JNI_CreateJavaVM"));</span>
<span class="removed"> 168       JNIEnv* env;</span>
<span class="removed"> 169       if (JNI_CreateJavaVM == NULL) {</span>
<span class="removed"> 170         vm_exit_during_initialization("Unable to find JNI_CreateJavaVM", path);</span>
<span class="removed"> 171       }</span>
<span class="removed"> 172 </span>
<span class="removed"> 173       ResourceMark rm;</span>
<span class="removed"> 174       JavaVMInitArgs vm_args;</span>
<span class="removed"> 175       vm_args.version = JNI_VERSION_1_2;</span>
<span class="removed"> 176       vm_args.ignoreUnrecognized = JNI_TRUE;</span>
<span class="removed"> 177       vm_args.options = NULL;</span>
<span class="removed"> 178       vm_args.nOptions = 0;</span>
<span class="removed"> 179 </span>
<span class="removed"> 180       JavaVM* the_javavm = NULL;</span>
<span class="removed"> 181       int result = (*JNI_CreateJavaVM)(&amp;the_javavm, (void**) &amp;env, &amp;vm_args);</span>
<span class="removed"> 182       if (result == JNI_OK) {</span>
<span class="removed"> 183         guarantee(env != NULL, "missing env");</span>
<span class="removed"> 184         _shared_library_javavm = the_javavm;</span>
<span class="removed"> 185         return env;</span>
<span class="removed"> 186       } else {</span>
<span class="removed"> 187         vm_exit_during_initialization(err_msg("JNI_CreateJavaVM failed with return value %d", result), path);</span>
<span class="removed"> 188       }</span>
<span class="removed"> 189     }</span>
<span class="removed"> 190   }</span>
<span class="removed"> 191   return NULL;</span>
<span class="removed"> 192 }</span>
<span class="removed"> 193 </span>
 194 void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {
 195   assert(thread != NULL, "npe");
<span class="removed"> 196   // By default there is only one runtime which is the compiler runtime.</span>
<span class="removed"> 197   _runtime = JVMCI::compiler_runtime();</span>
 198   _env = NULL;
 199   _pop_frame_on_close = false;
 200   _detach_on_close = false;
 201   if (!UseJVMCINativeLibrary) {
 202     // In HotSpot mode, JNI isn't used at all.

 203     _is_hotspot = true;
 204     return;
 205   }
 206 
 207   if (parent_env != NULL) {
 208     // If the parent JNI environment is non-null then figure out whether it
 209     // is a HotSpot or shared library JNIEnv and set the state appropriately.
 210     _is_hotspot = thread-&gt;jni_environment() == parent_env;
 211     if (_is_hotspot) {
 212       // Select the Java runtime
 213       _runtime = JVMCI::java_runtime();
 214       return;
 215     }


 216     _env = parent_env;
 217     return;
 218   }
 219 
 220   // Running in JVMCI shared library mode so ensure the shared library
 221   // is loaded and initialized and get a shared library JNIEnv
 222   _is_hotspot = false;
<span class="changed"> 223   _env = init_shared_library(thread);</span>


 224 
 225   if (_env != NULL) {
 226     // Creating the JVMCI shared library VM also attaches the current thread
 227     _detach_on_close = true;
 228   } else {
<span class="changed"> 229     _shared_library_javavm-&gt;GetEnv((void**)&amp;parent_env, JNI_VERSION_1_2);</span>
 230     if (parent_env != NULL) {
 231       // Even though there's a parent JNI env, there's no guarantee
 232       // it was opened by a JVMCIEnv scope and thus may not have
 233       // pushed a local JNI frame. As such, we use a new JNI local
 234       // frame in this scope to ensure local JNI refs are collected
 235       // in a timely manner after leaving this scope.
 236       _env = parent_env;
 237     } else {
 238       ResourceMark rm; // Thread name is resource allocated
 239       JavaVMAttachArgs attach_args;
 240       attach_args.version = JNI_VERSION_1_2;
 241       attach_args.name = thread-&gt;name();
 242       attach_args.group = NULL;
<span class="changed"> 243       if (_shared_library_javavm-&gt;AttachCurrentThread((void**)&amp;_env, &amp;attach_args) != JNI_OK) {</span>
 244         fatal("Error attaching current thread (%s) to JVMCI shared library JNI interface", attach_args.name);
 245       }
 246       _detach_on_close = true;
 247     }
 248   }
 249 
 250   assert(_env != NULL, "missing env");
 251   assert(_throw_to_caller == false, "must be");
 252 
<span class="changed"> 253   JNIAccessMark jni(this);</span>
 254   jint result = _env-&gt;PushLocalFrame(32);
 255   if (result != JNI_OK) {
 256     char message[256];
 257     jio_snprintf(message, 256, "Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d", _file, _line);
 258     JVMCIRuntime::exit_on_pending_exception(this, message);
 259   }
 260   _pop_frame_on_close = true;
 261 }
 262 
 263 JVMCIEnv::JVMCIEnv(JavaThread* thread, JVMCICompileState* compile_state, const char* file, int line):
 264     _throw_to_caller(false), _file(file), _line(line), _compile_state(compile_state) {
 265   init_env_mode_runtime(thread, NULL);
 266 }
 267 
 268 JVMCIEnv::JVMCIEnv(JavaThread* thread, const char* file, int line):
 269     _throw_to_caller(false), _file(file), _line(line), _compile_state(NULL) {
 270   init_env_mode_runtime(thread, NULL);
 271 }
 272 
 273 JVMCIEnv::JVMCIEnv(JavaThread* thread, JNIEnv* parent_env, const char* file, int line):

</pre><hr></hr><pre>
 277 }
 278 
 279 void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, const char* file, int line) {
 280   _compile_state = NULL;
 281   _throw_to_caller = false;
 282   _file = file;
 283   _line = line;
 284   if (is_hotspot) {
 285     _env = NULL;
 286     _pop_frame_on_close = false;
 287     _detach_on_close = false;
 288     _is_hotspot = true;
 289     _runtime = JVMCI::java_runtime();
 290   } else {
 291     init_env_mode_runtime(thread, NULL);
 292   }
 293 }
 294 
 295 // Prints a pending exception (if any) and its stack trace.
 296 void JVMCIEnv::describe_pending_exception(bool clear) {

 297   if (!is_hotspot()) {
 298     JNIAccessMark jni(this);
 299     if (jni()-&gt;ExceptionCheck()) {
 300       jthrowable ex = !clear ? jni()-&gt;ExceptionOccurred() : NULL;
 301       jni()-&gt;ExceptionDescribe();
 302       if (ex != NULL) {
 303         jni()-&gt;Throw(ex);
 304       }
 305     }
 306   } else {
<span class="removed"> 307     Thread* THREAD = Thread::current();</span>
 308     if (HAS_PENDING_EXCEPTION) {
 309       JVMCIRuntime::describe_pending_hotspot_exception((JavaThread*) THREAD, clear);
 310     }
 311   }
 312 }
 313 
 314 void JVMCIEnv::translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle&amp; throwable) {
 315   assert(!is_hotspot(), "must_be");
 316   // Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets
 317   // may not have been called.
 318   Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);
 319   JavaCallArguments jargs;
 320   jargs.push_oop(throwable);
 321   JavaValue result(T_OBJECT);
 322   JavaCalls::call_static(&amp;result,
 323                           runtimeKlass,
 324                           vmSymbols::encodeThrowable_name(),
 325                           vmSymbols::encodeThrowable_signature(), &amp;jargs, THREAD);
 326   if (HAS_PENDING_EXCEPTION) {
 327     JVMCIRuntime::exit_on_pending_exception(this, "HotSpotJVMCIRuntime.encodeThrowable should not throw an exception");
 328   }
 329 
 330   oop encoded_throwable_string = (oop) result.get_jobject();
 331 
 332   ResourceMark rm;
 333   const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);
 334 
<span class="changed"> 335   JNIAccessMark jni(this);</span>
 336   jobject jni_encoded_throwable_string = jni()-&gt;NewStringUTF(encoded_throwable_chars);
 337   jthrowable jni_throwable = (jthrowable) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 338                                 JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),
 339                                 jni_encoded_throwable_string);
 340   jni()-&gt;Throw(jni_throwable);
 341 }
 342 
 343 JVMCIEnv::~JVMCIEnv() {
 344   if (_throw_to_caller) {
 345     if (is_hotspot()) {
 346       // Nothing to do
 347     } else {
 348       if (Thread::current()-&gt;is_Java_thread()) {
 349         JavaThread* THREAD = JavaThread::current();
 350         if (HAS_PENDING_EXCEPTION) {
 351           Handle throwable = Handle(THREAD, PENDING_EXCEPTION);
 352           CLEAR_PENDING_EXCEPTION;
 353           translate_hotspot_exception_to_jni_exception(THREAD, throwable);
 354         }
 355       }
 356     }
 357   } else {
 358     if (_pop_frame_on_close) {
 359       // Pop the JNI local frame that was pushed when entering this JVMCIEnv scope.
 360       JNIAccessMark jni(this);
 361       jni()-&gt;PopLocalFrame(NULL);
 362     }
 363 
 364     if (has_pending_exception()) {
 365       char message[256];
 366       jio_snprintf(message, 256, "Uncaught exception exiting JVMCIEnv scope entered at %s:%d", _file, _line);
 367       JVMCIRuntime::exit_on_pending_exception(this, message);
 368     }
 369 
 370     if (_detach_on_close) {
<span class="changed"> 371       get_shared_library_javavm()-&gt;DetachCurrentThread();</span>
 372     }
 373   }
 374 }
 375 
 376 jboolean JVMCIEnv::has_pending_exception() {
 377   if (is_hotspot()) {
 378     Thread* THREAD = Thread::current();
 379     return HAS_PENDING_EXCEPTION;
 380   } else {
 381     JNIAccessMark jni(this);
 382     return jni()-&gt;ExceptionCheck();
 383   }
 384 }
 385 
 386 void JVMCIEnv::clear_pending_exception() {
 387   if (is_hotspot()) {
 388     Thread* THREAD = Thread::current();
 389     CLEAR_PENDING_EXCEPTION;
 390   } else {
 391     JNIAccessMark jni(this);

</pre><hr></hr><pre>
 586     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_DOUBLE))) return T_DOUBLE;
 587     return T_ILLEGAL;
 588   }
 589 }
 590 
 591 // Create a boxing object of the appropriate primitive type.
 592 JVMCIObject JVMCIEnv::create_box(BasicType type, jvalue* value, JVMCI_TRAPS) {
 593   switch (type) {
 594     case T_BOOLEAN:
 595     case T_BYTE:
 596     case T_CHAR:
 597     case T_SHORT:
 598     case T_INT:
 599     case T_LONG:
 600     case T_FLOAT:
 601     case T_DOUBLE:
 602       break;
 603     default:
 604       JVMCI_THROW_MSG_(IllegalArgumentException, "Only boxes for primitive values can be created", JVMCIObject());
 605   }
<span class="removed"> 606   if (is_hotspot()) {</span>
 607     JavaThread* THREAD = JavaThread::current();

 608     oop box = java_lang_boxing_object::create(type, value, CHECK_(JVMCIObject()));
 609     return HotSpotJVMCI::wrap(box);
 610   } else {
<span class="changed"> 611     JNIAccessMark jni(this);</span>
 612     jobject box = jni()-&gt;NewObjectA(JNIJVMCI::box_class(type), JNIJVMCI::box_constructor(type), value);
 613     assert(box != NULL, "");
 614     return wrap(box);
 615   }
 616 }
 617 
 618 const char* JVMCIEnv::as_utf8_string(JVMCIObject str) {
 619   if (is_hotspot()) {
 620     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str));
 621   } else {
 622     JNIAccessMark jni(this);
 623     int length = jni()-&gt;GetStringLength(str.as_jstring());
 624     char* result = NEW_RESOURCE_ARRAY(char, length + 1);
 625     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, result);
 626     return result;
 627   }
 628 }
 629 
 630 char* JVMCIEnv::as_utf8_string(JVMCIObject str, char* buf, int buflen) {
 631   if (is_hotspot()) {

</pre><hr></hr><pre>
 655 DO_THROW(InternalError)
 656 DO_THROW(ArrayIndexOutOfBoundsException)
 657 DO_THROW(IllegalStateException)
 658 DO_THROW(NullPointerException)
 659 DO_THROW(IllegalArgumentException)
 660 DO_THROW(InvalidInstalledCodeException)
 661 DO_THROW(UnsatisfiedLinkError)
 662 DO_THROW(UnsupportedOperationException)
 663 DO_THROW(ClassNotFoundException)
 664 
 665 #undef DO_THROW
 666 
 667 void JVMCIEnv::fthrow_error(const char* file, int line, const char* format, ...) {
 668   const int max_msg_size = 1024;
 669   va_list ap;
 670   va_start(ap, format);
 671   char msg[max_msg_size];
 672   vsnprintf(msg, max_msg_size, format, ap);
 673   msg[max_msg_size-1] = '\0';
 674   va_end(ap);
<span class="removed"> 675   if (is_hotspot()) {</span>
 676     JavaThread* THREAD = JavaThread::current();

 677     Handle h_loader = Handle();
 678     Handle h_protection_domain = Handle();
 679     Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);
 680   } else {
<span class="changed"> 681     JNIAccessMark jni(this);</span>
 682     jni()-&gt;ThrowNew(JNIJVMCI::JVMCIError::clazz(), msg);
 683   }
 684 }
 685 
 686 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_compileMethod (JVMCIObject runtime, JVMCIObject method, int entry_bci,
 687                                                               jlong compile_state, int id) {
 688   if (is_hotspot()) {
 689     Thread* THREAD = Thread::current();
 690     JavaCallArguments jargs;
 691     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 692     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(method)));
 693     jargs.push_int(entry_bci);
 694     jargs.push_long(compile_state);
 695     jargs.push_int(id);
 696     JavaValue result(T_OBJECT);
 697     JavaCalls::call_special(&amp;result,
 698                             HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 699                             vmSymbols::compileMethod_name(),
 700                             vmSymbols::compileMethod_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 701     return wrap((oop) result.get_jobject());

</pre><hr></hr><pre>
 718     JavaCallArguments jargs;
 719     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 720     JavaValue result(T_VOID);
 721     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::bootstrapFinished_name(), vmSymbols::void_method_signature(), &amp;jargs, CHECK);
 722   } else {
 723     JNIAccessMark jni(this);
 724     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::bootstrapFinished_method());
 725 
 726   }
 727 }
 728 
 729 void JVMCIEnv::call_HotSpotJVMCIRuntime_shutdown (JVMCIObject runtime) {
 730   HandleMark hm;
 731   JavaThread* THREAD = JavaThread::current();
 732   if (is_hotspot()) {
 733     JavaCallArguments jargs;
 734     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 735     JavaValue result(T_VOID);
 736     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &amp;jargs, THREAD);
 737   } else {
<span class="changed"> 738     JNIAccessMark jni(this);</span>
 739     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::shutdown_method());
 740   }
 741   if (has_pending_exception()) {
 742     // This should never happen as HotSpotJVMCIRuntime.shutdown() should
 743     // handle all exceptions.
 744     describe_pending_exception(true);
 745   }
 746 }
 747 
 748 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_runtime (JVMCIEnv* JVMCIENV) {
 749   JavaThread* THREAD = JavaThread::current();
 750   if (is_hotspot()) {
 751     JavaCallArguments jargs;
 752     JavaValue result(T_OBJECT);
 753     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::runtime_name(), vmSymbols::runtime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 754     return wrap((oop) result.get_jobject());
 755   } else {
<span class="changed"> 756     JNIAccessMark jni(this);</span>
 757     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::runtime_method());
 758     if (jni()-&gt;ExceptionCheck()) {
 759       return JVMCIObject();
 760     }
 761     return wrap(result);
 762   }
 763 }
 764 
 765 JVMCIObject JVMCIEnv::call_JVMCI_getRuntime (JVMCIEnv* JVMCIENV) {
 766   JavaThread* THREAD = JavaThread::current();
 767   if (is_hotspot()) {
 768     JavaCallArguments jargs;
 769     JavaValue result(T_OBJECT);
 770     JavaCalls::call_static(&amp;result, HotSpotJVMCI::JVMCI::klass(), vmSymbols::getRuntime_name(), vmSymbols::getRuntime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 771     return wrap((oop) result.get_jobject());
 772   } else {
<span class="changed"> 773     JNIAccessMark jni(this);</span>
 774     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JVMCI::clazz(), JNIJVMCI::JVMCI::getRuntime_method());
 775     if (jni()-&gt;ExceptionCheck()) {
 776       return JVMCIObject();
 777     }
 778     return wrap(result);
 779   }
 780 }
 781 
 782 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_getCompiler (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 783   JavaThread* THREAD = JavaThread::current();
 784   if (is_hotspot()) {
 785     JavaCallArguments jargs;
 786     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 787     JavaValue result(T_OBJECT);
 788     JavaCalls::call_virtual(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::getCompiler_name(), vmSymbols::getCompiler_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 789     return wrap((oop) result.get_jobject());
 790   } else {
<span class="changed"> 791     JNIAccessMark jni(this);</span>
 792     jobject result = jni()-&gt;CallObjectMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::getCompiler_method());
 793     if (jni()-&gt;ExceptionCheck()) {
 794       return JVMCIObject();
 795     }
 796     return wrap(result);
 797   }
 798 }
 799 
 800 
 801 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCIEnv* JVMCIENV) {
 802   JavaThread* THREAD = JavaThread::current();
 803   if (is_hotspot()) {
 804     JavaCallArguments jargs;
 805     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));
 806     JavaValue result(T_OBJECT);
 807     JavaCalls::call_static(&amp;result,
 808                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 809                            vmSymbols::callToString_name(),
 810                            vmSymbols::callToString_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 811     return wrap((oop) result.get_jobject());
 812   } else {
<span class="changed"> 813     JNIAccessMark jni(this);</span>
 814     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 815                                                      JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),
 816                                                      object.as_jobject());
 817     if (jni()-&gt;ExceptionCheck()) {
 818       return JVMCIObject();
 819     }
 820     return wrap(result);
 821   }
 822 }
 823 
 824 
 825 JVMCIObject JVMCIEnv::call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS) {
 826   JavaThread* THREAD = JavaThread::current();
 827   if (is_hotspot()) {
 828     JavaCallArguments jargs;
 829     jargs.push_int(kind);
 830     jargs.push_long(value);
 831     JavaValue result(T_OBJECT);
 832     JavaCalls::call_static(&amp;result,
 833                            HotSpotJVMCI::PrimitiveConstant::klass(),
 834                            vmSymbols::forTypeChar_name(),
 835                            vmSymbols::forTypeChar_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 836     return wrap((oop) result.get_jobject());
 837   } else {
<span class="changed"> 838     JNIAccessMark jni(this);</span>
 839     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),
 840                                                      JNIJVMCI::PrimitiveConstant::forTypeChar_method(),
 841                                                      kind, value);
 842     if (jni()-&gt;ExceptionCheck()) {
 843       return JVMCIObject();
 844     }
 845     return wrap(result);
 846   }
 847 }
 848 
 849 JVMCIObject JVMCIEnv::call_JavaConstant_forFloat(float value, JVMCI_TRAPS) {
 850   JavaThread* THREAD = JavaThread::current();
 851   if (is_hotspot()) {
 852     JavaCallArguments jargs;
 853     jargs.push_float(value);
 854     JavaValue result(T_OBJECT);
 855     JavaCalls::call_static(&amp;result,
 856                            HotSpotJVMCI::JavaConstant::klass(),
 857                            vmSymbols::forFloat_name(),
 858                            vmSymbols::forFloat_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 859     return wrap((oop) result.get_jobject());
 860   } else {
<span class="changed"> 861     JNIAccessMark jni(this);</span>
 862     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 863                                                      JNIJVMCI::JavaConstant::forFloat_method(),
 864                                                      value);
 865     if (jni()-&gt;ExceptionCheck()) {
 866       return JVMCIObject();
 867     }
 868     return wrap(result);
 869   }
 870 }
 871 
 872 JVMCIObject JVMCIEnv::call_JavaConstant_forDouble(double value, JVMCI_TRAPS) {
 873   JavaThread* THREAD = JavaThread::current();
 874   if (is_hotspot()) {
 875     JavaCallArguments jargs;
 876     jargs.push_double(value);
 877     JavaValue result(T_OBJECT);
 878     JavaCalls::call_static(&amp;result,
 879                            HotSpotJVMCI::JavaConstant::klass(),
 880                            vmSymbols::forDouble_name(),
 881                            vmSymbols::forDouble_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 882     return wrap((oop) result.get_jobject());
 883   } else {
<span class="changed"> 884     JNIAccessMark jni(this);</span>
 885     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 886                                                      JNIJVMCI::JavaConstant::forDouble_method(),
 887                                                      value);
 888     if (jni()-&gt;ExceptionCheck()) {
 889       return JVMCIObject();
 890     }
 891     return wrap(result);
 892   }
 893 }
 894 
 895 JVMCIObject JVMCIEnv::get_jvmci_primitive_type(BasicType type) {
 896   JVMCIObjectArray primitives = get_HotSpotResolvedPrimitiveType_primitives();
 897   JVMCIObject result = get_object_at(primitives, type);
 898   return result;
 899 }
 900 
 901 JVMCIObject JVMCIEnv::new_StackTraceElement(const methodHandle&amp; method, int bci, JVMCI_TRAPS) {
 902   JavaThread* THREAD = JavaThread::current();
 903   Symbol* file_name_sym;
 904   int line_number;

</pre><hr></hr><pre>
 909   const char* declaring_class_str = holder-&gt;external_name();
 910 
 911   if (is_hotspot()) {
 912     HotSpotJVMCI::StackTraceElement::klass()-&gt;initialize(CHECK_(JVMCIObject()));
 913     oop objOop = HotSpotJVMCI::StackTraceElement::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
 914     Handle obj = Handle(THREAD, objOop);
 915 
 916     oop declaring_class = StringTable::intern((char*) declaring_class_str, CHECK_(JVMCIObject()));
 917     HotSpotJVMCI::StackTraceElement::set_declaringClass(this, obj(), declaring_class);
 918 
 919     oop method_name = StringTable::intern(method_name_sym, CHECK_(JVMCIObject()));
 920     HotSpotJVMCI::StackTraceElement::set_methodName(this, obj(), method_name);
 921 
 922     if (file_name_sym != NULL) {
 923       oop file_name = StringTable::intern(file_name_sym, CHECK_(JVMCIObject()));
 924       HotSpotJVMCI::StackTraceElement::set_fileName(this, obj(), file_name);
 925     }
 926     HotSpotJVMCI::StackTraceElement::set_lineNumber(this, obj(), line_number);
 927     return wrap(obj());
 928   } else {
<span class="changed"> 929     JNIAccessMark jni(this);</span>
 930     jobject declaring_class = jni()-&gt;NewStringUTF(declaring_class_str);
 931     if (jni()-&gt;ExceptionCheck()) {
 932       return JVMCIObject();
 933     }
 934     jobject method_name = jni()-&gt;NewStringUTF(method_name_sym-&gt;as_C_string());
 935     if (jni()-&gt;ExceptionCheck()) {
 936       return JVMCIObject();
 937     }
 938     jobject file_name = NULL;
 939     if (file_name_sym != NULL) {
 940       file_name = jni()-&gt;NewStringUTF(file_name_sym-&gt;as_C_string());
 941       if (jni()-&gt;ExceptionCheck()) {
 942         return JVMCIObject();
 943       }
 944     }
 945 
 946     jobject result = jni()-&gt;NewObject(JNIJVMCI::StackTraceElement::clazz(),
 947                                       JNIJVMCI::StackTraceElement::constructor(),
 948                                       declaring_class, method_name, file_name, line_number);
 949     return wrap(result);

</pre><hr></hr><pre>
 961       ik-&gt;initialize(CHECK_(JVMCIObject()));
 962     }
 963     oop obj = ik-&gt;allocate_instance(CHECK_(JVMCIObject()));
 964     Handle obj_h(THREAD, obj);
 965     Handle nameStr = java_lang_String::create_from_str(name, CHECK_(JVMCIObject()));
 966 
 967     // Call constructor
 968     JavaCallArguments jargs;
 969     jargs.push_oop(obj_h);
 970     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(methodObject)));
 971     jargs.push_oop(nameStr);
 972     jargs.push_int(isDefault);
 973     jargs.push_long(compileId);
 974     JavaValue result(T_VOID);
 975     JavaCalls::call_special(&amp;result, ik,
 976                             vmSymbols::object_initializer_name(),
 977                             vmSymbols::method_string_bool_long_signature(),
 978                             &amp;jargs, CHECK_(JVMCIObject()));
 979     return wrap(obj_h());
 980   } else {
<span class="changed"> 981     JNIAccessMark jni(this);</span>
 982     jobject nameStr = name == NULL ? NULL : jni()-&gt;NewStringUTF(name);
 983     if (jni()-&gt;ExceptionCheck()) {
 984       return JVMCIObject();
 985     }
 986 
 987     jobject result = jni()-&gt;NewObject(JNIJVMCI::HotSpotNmethod::clazz(),
 988                                       JNIJVMCI::HotSpotNmethod::constructor(),
 989                                       methodObject.as_jobject(), nameStr, isDefault);
 990     return wrap(result);
 991   }
 992 }
 993 
 994 JVMCIObject JVMCIEnv::make_local(JVMCIObject object) {
 995   if (object.is_null()) {
 996     return JVMCIObject();
 997   }
 998   if (is_hotspot()) {
 999     return wrap(JNIHandles::make_local(HotSpotJVMCI::resolve(object)));
1000   } else {
1001     JNIAccessMark jni(this);
1002     return wrap(jni()-&gt;NewLocalRef(object.as_jobject()));
1003   }
1004 }
1005 
1006 JVMCIObject JVMCIEnv::make_global(JVMCIObject object) {
1007   if (object.is_null()) {
1008     return JVMCIObject();
1009   }
1010   if (is_hotspot()) {
1011     return wrap(JNIHandles::make_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));
1012   } else {
1013     JNIAccessMark jni(this);
1014     return wrap(jni()-&gt;NewGlobalRef(object.as_jobject()));
1015   }
1016 }
1017 
<span class="removed">1018 JVMCIObject JVMCIEnv::make_weak(JVMCIObject object) {</span>
<span class="removed">1019   if (object.is_null()) {</span>
<span class="removed">1020     return JVMCIObject();</span>
<span class="removed">1021   }</span>
<span class="removed">1022   if (is_hotspot()) {</span>
<span class="removed">1023     return wrap(JNIHandles::make_weak_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));</span>
<span class="removed">1024   } else {</span>
<span class="removed">1025     JNIAccessMark jni(this);</span>
<span class="removed">1026     return wrap(jni()-&gt;NewWeakGlobalRef(object.as_jobject()));</span>
<span class="removed">1027   }</span>
<span class="removed">1028 }</span>
<span class="removed">1029 </span>
1030 void JVMCIEnv::destroy_local(JVMCIObject object) {
1031   if (is_hotspot()) {
1032     JNIHandles::destroy_local(object.as_jobject());
1033   } else {
1034     JNIAccessMark jni(this);
1035     jni()-&gt;DeleteLocalRef(object.as_jobject());
1036   }
1037 }
1038 
1039 void JVMCIEnv::destroy_global(JVMCIObject object) {
1040   if (is_hotspot()) {
1041     JNIHandles::destroy_global(object.as_jobject());
1042   } else {
1043     JNIAccessMark jni(this);
1044     jni()-&gt;DeleteGlobalRef(object.as_jobject());
1045   }
1046 }
1047 
<span class="removed">1048 void JVMCIEnv::destroy_weak(JVMCIObject object) {</span>
<span class="removed">1049   if (is_hotspot()) {</span>
<span class="removed">1050     JNIHandles::destroy_weak_global(object.as_jweak());</span>
<span class="removed">1051   } else {</span>
<span class="removed">1052     JNIAccessMark jni(this);</span>
<span class="removed">1053     jni()-&gt;DeleteWeakGlobalRef(object.as_jweak());</span>
<span class="removed">1054   }</span>
<span class="removed">1055 }</span>
<span class="removed">1056 </span>
1057 const char* JVMCIEnv::klass_name(JVMCIObject object) {
1058   if (is_hotspot()) {
1059     return HotSpotJVMCI::resolve(object)-&gt;klass()-&gt;signature_name();
1060   } else {
1061     JVMCIObject name;
1062     {
1063       JNIAccessMark jni(this);
1064       jclass jcl = jni()-&gt;GetObjectClass(object.as_jobject());
1065       jobject result = jni()-&gt;CallObjectMethod(jcl, JNIJVMCI::Class_getName_method());
1066       name = JVMCIObject::create(result, is_hotspot());
1067     }
1068     return as_utf8_string(name);
1069   }
1070 }
1071 
1072 JVMCIObject JVMCIEnv::get_jvmci_method(const methodHandle&amp; method, JVMCI_TRAPS) {
1073   JVMCIObject method_object;
1074   if (method() == NULL) {
1075     return method_object;
1076   }
1077 
1078   Thread* THREAD = Thread::current();
<span class="changed">1079   jmetadata handle = JVMCI::allocate_handle(method);</span>
1080   jboolean exception = false;
1081   if (is_hotspot()) {
1082     JavaValue result(T_OBJECT);
1083     JavaCallArguments args;
1084     args.push_long((jlong) handle);
1085     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass(),
1086                            vmSymbols::fromMetaspace_name(),
1087                            vmSymbols::method_fromMetaspace_signature(), &amp;args, THREAD);
1088     if (HAS_PENDING_EXCEPTION) {
1089       exception = true;
1090     } else {
1091       method_object = wrap((oop)result.get_jobject());
1092     }
1093   } else {
1094     JNIAccessMark jni(this);
1095     method_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedJavaMethodImpl::clazz(),
1096                                                                   JNIJVMCI::HotSpotResolvedJavaMethodImpl_fromMetaspace_method(),
1097                                                                   (jlong) handle));
1098     exception = jni()-&gt;ExceptionCheck();
1099   }
1100 
1101   if (exception) {
<span class="changed">1102     JVMCI::release_handle(handle);</span>
1103     return JVMCIObject();
1104   }
1105 
1106   assert(asMethod(method_object) == method(), "must be");
1107   if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {
<span class="changed">1108     JVMCI::release_handle(handle);</span>
1109   }
1110   assert(!method_object.is_null(), "must be");
1111   return method_object;
1112 }
1113 
1114 JVMCIObject JVMCIEnv::get_jvmci_type(const JVMCIKlassHandle&amp; klass, JVMCI_TRAPS) {
1115   JVMCIObject type;
1116   if (klass.is_null()) {
1117     return type;
1118   }
1119 
1120   jlong pointer = (jlong) klass();
1121   JavaThread* THREAD = JavaThread::current();
1122   JVMCIObject signature = create_string(klass-&gt;signature_name(), JVMCI_CHECK_(JVMCIObject()));
1123   jboolean exception = false;
1124   if (is_hotspot()) {
1125     JavaValue result(T_OBJECT);
1126     JavaCallArguments args;
1127     args.push_long(pointer);
1128     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(signature)));
1129     JavaCalls::call_static(&amp;result,
1130                            HotSpotJVMCI::HotSpotResolvedObjectTypeImpl::klass(),
1131                            vmSymbols::fromMetaspace_name(),
1132                            vmSymbols::klass_fromMetaspace_signature(), &amp;args, THREAD);
1133 
1134     if (HAS_PENDING_EXCEPTION) {
1135       exception = true;
1136     } else {
1137       type = wrap((oop)result.get_jobject());
1138     }
1139   } else {
<span class="changed">1140     JNIAccessMark jni(this);</span>
1141 
1142     HandleMark hm(THREAD);
1143     type = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedObjectTypeImpl::clazz(),
1144                                                         JNIJVMCI::HotSpotResolvedObjectTypeImpl_fromMetaspace_method(),
1145                                                         pointer, signature.as_jstring()));
1146     exception = jni()-&gt;ExceptionCheck();
1147   }
1148   if (exception) {
1149     return JVMCIObject();
1150   }
1151 
1152   assert(type.is_non_null(), "must have result");
1153   return type;
1154 }
1155 
1156 JVMCIObject JVMCIEnv::get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS) {
1157   JVMCIObject cp_object;
<span class="changed">1158   jmetadata handle = JVMCI::allocate_handle(cp);</span>
1159   jboolean exception = false;
<span class="removed">1160   if (is_hotspot()) {</span>
1161     JavaThread* THREAD = JavaThread::current();

1162     JavaValue result(T_OBJECT);
1163     JavaCallArguments args;
1164     args.push_long((jlong) handle);
1165     JavaCalls::call_static(&amp;result,
1166                            HotSpotJVMCI::HotSpotConstantPool::klass(),
1167                            vmSymbols::fromMetaspace_name(),
1168                            vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, THREAD);
1169     if (HAS_PENDING_EXCEPTION) {
1170       exception = true;
1171     } else {
1172       cp_object = wrap((oop)result.get_jobject());
1173     }
1174   } else {
<span class="changed">1175     JNIAccessMark jni(this);</span>
1176     cp_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotConstantPool::clazz(),
1177                                                              JNIJVMCI::HotSpotConstantPool_fromMetaspace_method(),
1178                                                              (jlong) handle));
1179     exception = jni()-&gt;ExceptionCheck();
1180   }
1181 
1182   if (exception) {
<span class="changed">1183     JVMCI::release_handle(handle);</span>
1184     return JVMCIObject();
1185   }
1186 
1187   assert(!cp_object.is_null(), "must be");
1188   // Constant pools aren't cached so this is always a newly created object using the handle
1189   assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, "must use same handle");
1190   return cp_object;
1191 }
1192 
1193 JVMCIPrimitiveArray JVMCIEnv::new_booleanArray(int length, JVMCI_TRAPS) {
<span class="removed">1194   if (is_hotspot()) {</span>
1195     JavaThread* THREAD = JavaThread::current();

1196     typeArrayOop result = oopFactory::new_boolArray(length, CHECK_(JVMCIObject()));
1197     return wrap(result);
1198   } else {
<span class="changed">1199     JNIAccessMark jni(this);</span>
1200     jbooleanArray result = jni()-&gt;NewBooleanArray(length);
1201     return wrap(result);
1202   }
1203 }
1204 
1205 JVMCIPrimitiveArray JVMCIEnv::new_byteArray(int length, JVMCI_TRAPS) {
<span class="removed">1206   if (is_hotspot()) {</span>
1207     JavaThread* THREAD = JavaThread::current();

1208     typeArrayOop result = oopFactory::new_byteArray(length, CHECK_(JVMCIObject()));
1209     return wrap(result);
1210   } else {
<span class="changed">1211     JNIAccessMark jni(this);</span>
1212     jbyteArray result = jni()-&gt;NewByteArray(length);
1213     return wrap(result);
1214   }
1215 }
1216 
1217 JVMCIObjectArray JVMCIEnv::new_byte_array_array(int length, JVMCI_TRAPS) {
<span class="removed">1218   if (is_hotspot()) {</span>
1219     JavaThread* THREAD = JavaThread::current();

1220     Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())-&gt;array_klass(CHECK_(JVMCIObject()));
1221     objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) -&gt;allocate(length, CHECK_(JVMCIObject()));
1222     return wrap(result);
1223   } else {
<span class="changed">1224     JNIAccessMark jni(this);</span>
1225     jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::byte_array(), NULL);
1226     return wrap(result);
1227   }
1228 }
1229 
1230 JVMCIPrimitiveArray JVMCIEnv::new_intArray(int length, JVMCI_TRAPS) {
<span class="removed">1231   if (is_hotspot()) {</span>
1232     JavaThread* THREAD = JavaThread::current();

1233     typeArrayOop result = oopFactory::new_intArray(length, CHECK_(JVMCIObject()));
1234     return wrap(result);
1235   } else {
<span class="changed">1236     JNIAccessMark jni(this);</span>
1237     jintArray result = jni()-&gt;NewIntArray(length);
1238     return wrap(result);
1239   }
1240 }
1241 
1242 JVMCIPrimitiveArray JVMCIEnv::new_longArray(int length, JVMCI_TRAPS) {
<span class="removed">1243   if (is_hotspot()) {</span>
1244     JavaThread* THREAD = JavaThread::current();

1245     typeArrayOop result = oopFactory::new_longArray(length, CHECK_(JVMCIObject()));
1246     return wrap(result);
1247   } else {
<span class="changed">1248     JNIAccessMark jni(this);</span>
1249     jlongArray result = jni()-&gt;NewLongArray(length);
1250     return wrap(result);
1251   }
1252 }
1253 
1254 JVMCIObject JVMCIEnv::new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS) {
<span class="removed">1255   if (is_hotspot()) {</span>
1256     JavaThread* THREAD = JavaThread::current();

1257     HotSpotJVMCI::VMField::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1258     oop obj = HotSpotJVMCI::VMField::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1259     HotSpotJVMCI::VMField::set_name(this, obj, HotSpotJVMCI::resolve(name));
1260     HotSpotJVMCI::VMField::set_type(this, obj, HotSpotJVMCI::resolve(type));
1261     HotSpotJVMCI::VMField::set_offset(this, obj, offset);
1262     HotSpotJVMCI::VMField::set_address(this, obj, address);
1263     HotSpotJVMCI::VMField::set_value(this, obj, HotSpotJVMCI::resolve(value));
1264     return wrap(obj);
1265   } else {
<span class="changed">1266     JNIAccessMark jni(this);</span>
1267     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMField::clazz(),
1268                                     JNIJVMCI::VMField::constructor(),
1269                                     get_jobject(name), get_jobject(type), offset, address, get_jobject(value));
1270     return wrap(result);
1271   }
1272 }
1273 
1274 JVMCIObject JVMCIEnv::new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS) {
<span class="removed">1275   if (is_hotspot()) {</span>
1276     JavaThread* THREAD = JavaThread::current();

1277     HotSpotJVMCI::VMFlag::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1278     oop obj = HotSpotJVMCI::VMFlag::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1279     HotSpotJVMCI::VMFlag::set_name(this, obj, HotSpotJVMCI::resolve(name));
1280     HotSpotJVMCI::VMFlag::set_type(this, obj, HotSpotJVMCI::resolve(type));
1281     HotSpotJVMCI::VMFlag::set_value(this, obj, HotSpotJVMCI::resolve(value));
1282     return wrap(obj);
1283   } else {
<span class="changed">1284     JNIAccessMark jni(this);</span>
1285     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMFlag::clazz(),
1286                                     JNIJVMCI::VMFlag::constructor(),
1287                                     get_jobject(name), get_jobject(type), get_jobject(value));
1288     return wrap(result);
1289   }
1290 }
1291 
1292 JVMCIObject JVMCIEnv::new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS) {
<span class="removed">1293   if (is_hotspot()) {</span>
1294     JavaThread* THREAD = JavaThread::current();

1295     HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1296     oop obj = HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1297     HotSpotJVMCI::VMIntrinsicMethod::set_declaringClass(this, obj, HotSpotJVMCI::resolve(declaringClass));
1298     HotSpotJVMCI::VMIntrinsicMethod::set_name(this, obj, HotSpotJVMCI::resolve(name));
1299     HotSpotJVMCI::VMIntrinsicMethod::set_descriptor(this, obj, HotSpotJVMCI::resolve(descriptor));
1300     HotSpotJVMCI::VMIntrinsicMethod::set_id(this, obj, id);
1301     return wrap(obj);
1302   } else {
<span class="changed">1303     JNIAccessMark jni(this);</span>
1304     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMIntrinsicMethod::clazz(),
1305                                     JNIJVMCI::VMIntrinsicMethod::constructor(),
1306                                     get_jobject(declaringClass), get_jobject(name), get_jobject(descriptor), id);
1307     return wrap(result);
1308   }
1309 }
1310 
1311 JVMCIObject JVMCIEnv::new_HotSpotStackFrameReference(JVMCI_TRAPS) {
1312   if (is_hotspot()) {
1313     JavaThread* THREAD = JavaThread::current();
1314     HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1315     oop obj = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1316     return wrap(obj);
1317   } else {
1318     ShouldNotReachHere();
1319     return JVMCIObject();
1320   }
1321 }
1322 JVMCIObject JVMCIEnv::new_JVMCIError(JVMCI_TRAPS) {
1323   if (is_hotspot()) {

</pre><hr></hr><pre>
1329     ShouldNotReachHere();
1330     return JVMCIObject();
1331   }
1332 }
1333 
1334 
1335 JVMCIObject JVMCIEnv::get_object_constant(oop objOop, bool compressed, bool dont_register) {
1336   JavaThread* THREAD = JavaThread::current();
1337   Handle obj = Handle(THREAD, objOop);
1338   if (obj.is_null()) {
1339     return JVMCIObject();
1340   }
1341   if (is_hotspot()) {
1342     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1343     oop constant = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1344     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::set_object(this, constant, obj());
1345     HotSpotJVMCI::HotSpotObjectConstantImpl::set_compressed(this, constant, compressed);
1346     return wrap(constant);
1347   } else {
1348     jlong handle = make_handle(obj);
<span class="changed">1349     JNIAccessMark jni(this);</span>
1350     jobject result = jni()-&gt;NewObject(JNIJVMCI::IndirectHotSpotObjectConstantImpl::clazz(),
1351                                       JNIJVMCI::IndirectHotSpotObjectConstantImpl::constructor(),
1352                                       handle, compressed, dont_register);
1353     return wrap(result);
1354   }
1355 }
1356 
1357 
1358 Handle JVMCIEnv::asConstant(JVMCIObject constant, JVMCI_TRAPS) {
1359   if (constant.is_null()) {
1360     return Handle();
1361   }
1362   JavaThread* THREAD = JavaThread::current();
1363   if (is_hotspot()) {
1364     assert(HotSpotJVMCI::DirectHotSpotObjectConstantImpl::is_instance(this, constant), "wrong type");
1365     oop obj = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::object(this, HotSpotJVMCI::resolve(constant));
1366     return Handle(THREAD, obj);
1367   } else if (isa_IndirectHotSpotObjectConstantImpl(constant)) {
1368     jlong object_handle = get_IndirectHotSpotObjectConstantImpl_objectHandle(constant);
1369     if (object_handle == 0L) {
1370       JVMCI_THROW_MSG_(NullPointerException, "Foreign object reference has been cleared", Handle());
1371     }
1372     oop result = resolve_handle(object_handle);
1373     if (result == NULL) {
1374       JVMCI_THROW_MSG_(InternalError, "Constant was unexpectedly NULL", Handle());
1375     }
1376     return Handle(THREAD, result);
1377   } else {
1378     JVMCI_THROW_MSG_(IllegalArgumentException, "DirectHotSpotObjectConstantImpl shouldn't reach JVMCI in SVM mode", Handle());
1379   }
1380 }
1381 
1382 JVMCIObject JVMCIEnv::wrap(jobject object) {
1383   return JVMCIObject::create(object, is_hotspot());
1384 }
1385 
1386 jlong JVMCIEnv::make_handle(const Handle&amp; obj) {
1387   assert(!obj.is_null(), "should only create handle for non-NULL oops");
<span class="changed">1388   jobject handle = JVMCI::make_global(obj);</span>
1389   return (jlong) handle;
1390 }
1391 
1392 oop JVMCIEnv::resolve_handle(jlong objectHandle) {
1393   assert(objectHandle != 0, "should be a valid handle");
1394   oop obj = *((oopDesc**)objectHandle);
1395   if (obj != NULL) {
1396     oopDesc::verify(obj);
1397   }
1398   return obj;
1399 }
1400 
1401 JVMCIObject JVMCIEnv::create_string(const char* str, JVMCI_TRAPS) {
<span class="removed">1402   if (is_hotspot()) {</span>
1403     JavaThread* THREAD = JavaThread::current();

1404     Handle result = java_lang_String::create_from_str(str, CHECK_(JVMCIObject()));
1405     return HotSpotJVMCI::wrap(result());
1406   } else {
1407     jobject result;
1408     jboolean exception = false;
1409     {
<span class="changed">1410       JNIAccessMark jni(this);</span>
1411       result = jni()-&gt;NewStringUTF(str);
1412       exception = jni()-&gt;ExceptionCheck();
1413     }
1414     return wrap(result);
1415   }
1416 }
1417 
1418 bool JVMCIEnv::equals(JVMCIObject a, JVMCIObject b) {
1419   if (is_hotspot()) {
1420     return HotSpotJVMCI::resolve(a) == HotSpotJVMCI::resolve(b);
1421   } else {
1422     JNIAccessMark jni(this);
1423     return jni()-&gt;IsSameObject(a.as_jobject(), b.as_jobject()) != 0;
1424   }
1425 }
1426 
1427 BasicType JVMCIEnv::kindToBasicType(JVMCIObject kind, JVMCI_TRAPS) {
1428   if (kind.is_null()) {
1429     JVMCI_THROW_(NullPointerException, T_ILLEGAL);
1430   }

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
  60   }
  61   if (!jvmti_can_access_local_variables() &amp;&amp;
  62       JvmtiExport::can_access_local_variables()) {
  63     return true;
  64   }
  65   if (!jvmti_can_hotswap_or_post_breakpoint() &amp;&amp;
  66       JvmtiExport::can_hotswap_or_post_breakpoint()) {
  67     return true;
  68   }
  69   if (!jvmti_can_post_on_exceptions() &amp;&amp;
  70       JvmtiExport::can_post_on_exceptions()) {
  71     return true;
  72   }
  73   if (!jvmti_can_pop_frame() &amp;&amp;
  74       JvmtiExport::can_pop_frame()) {
  75     return true;
  76   }
  77   return false;
  78 }
  79 




  80 void JVMCIEnv::copy_saved_properties() {
  81   assert(!is_hotspot(), "can only copy saved properties from HotSpot to native image");
  82 
  83   JavaThread* THREAD = JavaThread::current();
  84 
  85   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_services_Services(), Handle(), Handle(), true, THREAD);
  86   if (HAS_PENDING_EXCEPTION) {
  87     JVMCIRuntime::exit_on_pending_exception(NULL, "Error initializing jdk.vm.ci.services.Services");
  88   }
  89   InstanceKlass* ik = InstanceKlass::cast(k);
  90   if (ik-&gt;should_be_initialized()) {
  91     ik-&gt;initialize(THREAD);
  92     if (HAS_PENDING_EXCEPTION) {
  93       JVMCIRuntime::exit_on_pending_exception(NULL, "Error initializing jdk.vm.ci.services.Services");
  94     }
  95   }
  96 
  97   // Get the serialized saved properties from HotSpot
  98   TempNewSymbol serializeSavedProperties = SymbolTable::new_symbol("serializeSavedProperties");
  99   JavaValue result(T_OBJECT);

</pre><hr></hr><pre>
 110 
 111   // Copy serialized saved properties from HotSpot object into native buffer
 112   jbyte* serialized_properties = NEW_RESOURCE_ARRAY(jbyte, serialized_properties_len);
 113   memcpy(serialized_properties, ba-&gt;byte_at_addr(0), serialized_properties_len);
 114 
 115   // Copy native buffer into shared library object
 116   JVMCIPrimitiveArray buf = new_byteArray(serialized_properties_len, this);
 117   if (has_pending_exception()) {
 118     describe_pending_exception(true);
 119     fatal("Error in copy_saved_properties");
 120   }
 121   copy_bytes_from(serialized_properties, buf, 0, serialized_properties_len);
 122   if (has_pending_exception()) {
 123     describe_pending_exception(true);
 124     fatal("Error in copy_saved_properties");
 125   }
 126 
 127   // Initialize saved properties in shared library
 128   jclass servicesClass = JNIJVMCI::Services::clazz();
 129   jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();
<span class="changed"> 130   JNIAccessMark jni(this, THREAD);</span>
 131   jni()-&gt;CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());
 132   if (jni()-&gt;ExceptionCheck()) {
 133     jni()-&gt;ExceptionDescribe();
 134     fatal("Error calling jdk.vm.ci.services.Services.initializeSavedProperties");
 135   }
 136 }
 137 




















































 138 void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {
 139   assert(thread != NULL, "npe");


 140   _env = NULL;
 141   _pop_frame_on_close = false;
 142   _detach_on_close = false;
 143   if (!UseJVMCINativeLibrary) {
 144     // In HotSpot mode, JNI isn't used at all.
<span class="new"> 145     _runtime = JVMCI::java_runtime();</span>
 146     _is_hotspot = true;
 147     return;
 148   }
 149 
 150   if (parent_env != NULL) {
 151     // If the parent JNI environment is non-null then figure out whether it
 152     // is a HotSpot or shared library JNIEnv and set the state appropriately.
 153     _is_hotspot = thread-&gt;jni_environment() == parent_env;
 154     if (_is_hotspot) {
 155       // Select the Java runtime
 156       _runtime = JVMCI::java_runtime();
 157       return;
 158     }
<span class="new"> 159     _runtime = JVMCI::compiler_runtime();</span>
<span class="new"> 160     assert(_runtime != NULL, "npe");</span>
 161     _env = parent_env;
 162     return;
 163   }
 164 
 165   // Running in JVMCI shared library mode so ensure the shared library
 166   // is loaded and initialized and get a shared library JNIEnv
 167   _is_hotspot = false;
<span class="changed"> 168 </span>
<span class="changed"> 169   _runtime = JVMCI::compiler_runtime();</span>
<span class="changed"> 170   _env = _runtime-&gt;init_shared_library_javavm();</span>
 171 
 172   if (_env != NULL) {
 173     // Creating the JVMCI shared library VM also attaches the current thread
 174     _detach_on_close = true;
 175   } else {
<span class="changed"> 176     _runtime-&gt;GetEnv(thread, (void**)&amp;parent_env, JNI_VERSION_1_2);</span>
 177     if (parent_env != NULL) {
 178       // Even though there's a parent JNI env, there's no guarantee
 179       // it was opened by a JVMCIEnv scope and thus may not have
 180       // pushed a local JNI frame. As such, we use a new JNI local
 181       // frame in this scope to ensure local JNI refs are collected
 182       // in a timely manner after leaving this scope.
 183       _env = parent_env;
 184     } else {
 185       ResourceMark rm; // Thread name is resource allocated
 186       JavaVMAttachArgs attach_args;
 187       attach_args.version = JNI_VERSION_1_2;
 188       attach_args.name = thread-&gt;name();
 189       attach_args.group = NULL;
<span class="changed"> 190       if (_runtime-&gt;AttachCurrentThread(thread, (void**) &amp;_env, &amp;attach_args) != JNI_OK) {</span>
 191         fatal("Error attaching current thread (%s) to JVMCI shared library JNI interface", attach_args.name);
 192       }
 193       _detach_on_close = true;
 194     }
 195   }
 196 
 197   assert(_env != NULL, "missing env");
 198   assert(_throw_to_caller == false, "must be");
 199 
<span class="changed"> 200   JNIAccessMark jni(this, thread);</span>
 201   jint result = _env-&gt;PushLocalFrame(32);
 202   if (result != JNI_OK) {
 203     char message[256];
 204     jio_snprintf(message, 256, "Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d", _file, _line);
 205     JVMCIRuntime::exit_on_pending_exception(this, message);
 206   }
 207   _pop_frame_on_close = true;
 208 }
 209 
 210 JVMCIEnv::JVMCIEnv(JavaThread* thread, JVMCICompileState* compile_state, const char* file, int line):
 211     _throw_to_caller(false), _file(file), _line(line), _compile_state(compile_state) {
 212   init_env_mode_runtime(thread, NULL);
 213 }
 214 
 215 JVMCIEnv::JVMCIEnv(JavaThread* thread, const char* file, int line):
 216     _throw_to_caller(false), _file(file), _line(line), _compile_state(NULL) {
 217   init_env_mode_runtime(thread, NULL);
 218 }
 219 
 220 JVMCIEnv::JVMCIEnv(JavaThread* thread, JNIEnv* parent_env, const char* file, int line):

</pre><hr></hr><pre>
 224 }
 225 
 226 void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, const char* file, int line) {
 227   _compile_state = NULL;
 228   _throw_to_caller = false;
 229   _file = file;
 230   _line = line;
 231   if (is_hotspot) {
 232     _env = NULL;
 233     _pop_frame_on_close = false;
 234     _detach_on_close = false;
 235     _is_hotspot = true;
 236     _runtime = JVMCI::java_runtime();
 237   } else {
 238     init_env_mode_runtime(thread, NULL);
 239   }
 240 }
 241 
 242 // Prints a pending exception (if any) and its stack trace.
 243 void JVMCIEnv::describe_pending_exception(bool clear) {
<span class="new"> 244   Thread* THREAD = Thread::current();</span>
 245   if (!is_hotspot()) {
 246     JNIAccessMark jni(this);
 247     if (jni()-&gt;ExceptionCheck()) {
 248       jthrowable ex = !clear ? jni()-&gt;ExceptionOccurred() : NULL;
 249       jni()-&gt;ExceptionDescribe();
 250       if (ex != NULL) {
 251         jni()-&gt;Throw(ex);
 252       }
 253     }
 254   } else {

 255     if (HAS_PENDING_EXCEPTION) {
 256       JVMCIRuntime::describe_pending_hotspot_exception((JavaThread*) THREAD, clear);
 257     }
 258   }
 259 }
 260 
 261 void JVMCIEnv::translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle&amp; throwable) {
 262   assert(!is_hotspot(), "must_be");
 263   // Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets
 264   // may not have been called.
 265   Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);
 266   JavaCallArguments jargs;
 267   jargs.push_oop(throwable);
 268   JavaValue result(T_OBJECT);
 269   JavaCalls::call_static(&amp;result,
 270                           runtimeKlass,
 271                           vmSymbols::encodeThrowable_name(),
 272                           vmSymbols::encodeThrowable_signature(), &amp;jargs, THREAD);
 273   if (HAS_PENDING_EXCEPTION) {
 274     JVMCIRuntime::exit_on_pending_exception(this, "HotSpotJVMCIRuntime.encodeThrowable should not throw an exception");
 275   }
 276 
 277   oop encoded_throwable_string = (oop) result.get_jobject();
 278 
 279   ResourceMark rm;
 280   const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);
 281 
<span class="changed"> 282   JNIAccessMark jni(this, THREAD);</span>
 283   jobject jni_encoded_throwable_string = jni()-&gt;NewStringUTF(encoded_throwable_chars);
 284   jthrowable jni_throwable = (jthrowable) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 285                                 JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),
 286                                 jni_encoded_throwable_string);
 287   jni()-&gt;Throw(jni_throwable);
 288 }
 289 
 290 JVMCIEnv::~JVMCIEnv() {
 291   if (_throw_to_caller) {
 292     if (is_hotspot()) {
 293       // Nothing to do
 294     } else {
 295       if (Thread::current()-&gt;is_Java_thread()) {
 296         JavaThread* THREAD = JavaThread::current();
 297         if (HAS_PENDING_EXCEPTION) {
 298           Handle throwable = Handle(THREAD, PENDING_EXCEPTION);
 299           CLEAR_PENDING_EXCEPTION;
 300           translate_hotspot_exception_to_jni_exception(THREAD, throwable);
 301         }
 302       }
 303     }
 304   } else {
 305     if (_pop_frame_on_close) {
 306       // Pop the JNI local frame that was pushed when entering this JVMCIEnv scope.
 307       JNIAccessMark jni(this);
 308       jni()-&gt;PopLocalFrame(NULL);
 309     }
 310 
 311     if (has_pending_exception()) {
 312       char message[256];
 313       jio_snprintf(message, 256, "Uncaught exception exiting JVMCIEnv scope entered at %s:%d", _file, _line);
 314       JVMCIRuntime::exit_on_pending_exception(this, message);
 315     }
 316 
 317     if (_detach_on_close) {
<span class="changed"> 318       _runtime-&gt;DetachCurrentThread(JavaThread::current());</span>
 319     }
 320   }
 321 }
 322 
 323 jboolean JVMCIEnv::has_pending_exception() {
 324   if (is_hotspot()) {
 325     Thread* THREAD = Thread::current();
 326     return HAS_PENDING_EXCEPTION;
 327   } else {
 328     JNIAccessMark jni(this);
 329     return jni()-&gt;ExceptionCheck();
 330   }
 331 }
 332 
 333 void JVMCIEnv::clear_pending_exception() {
 334   if (is_hotspot()) {
 335     Thread* THREAD = Thread::current();
 336     CLEAR_PENDING_EXCEPTION;
 337   } else {
 338     JNIAccessMark jni(this);

</pre><hr></hr><pre>
 533     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_DOUBLE))) return T_DOUBLE;
 534     return T_ILLEGAL;
 535   }
 536 }
 537 
 538 // Create a boxing object of the appropriate primitive type.
 539 JVMCIObject JVMCIEnv::create_box(BasicType type, jvalue* value, JVMCI_TRAPS) {
 540   switch (type) {
 541     case T_BOOLEAN:
 542     case T_BYTE:
 543     case T_CHAR:
 544     case T_SHORT:
 545     case T_INT:
 546     case T_LONG:
 547     case T_FLOAT:
 548     case T_DOUBLE:
 549       break;
 550     default:
 551       JVMCI_THROW_MSG_(IllegalArgumentException, "Only boxes for primitive values can be created", JVMCIObject());
 552   }

 553   JavaThread* THREAD = JavaThread::current();
<span class="new"> 554   if (is_hotspot()) {</span>
 555     oop box = java_lang_boxing_object::create(type, value, CHECK_(JVMCIObject()));
 556     return HotSpotJVMCI::wrap(box);
 557   } else {
<span class="changed"> 558     JNIAccessMark jni(this, THREAD);</span>
 559     jobject box = jni()-&gt;NewObjectA(JNIJVMCI::box_class(type), JNIJVMCI::box_constructor(type), value);
 560     assert(box != NULL, "");
 561     return wrap(box);
 562   }
 563 }
 564 
 565 const char* JVMCIEnv::as_utf8_string(JVMCIObject str) {
 566   if (is_hotspot()) {
 567     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str));
 568   } else {
 569     JNIAccessMark jni(this);
 570     int length = jni()-&gt;GetStringLength(str.as_jstring());
 571     char* result = NEW_RESOURCE_ARRAY(char, length + 1);
 572     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, result);
 573     return result;
 574   }
 575 }
 576 
 577 char* JVMCIEnv::as_utf8_string(JVMCIObject str, char* buf, int buflen) {
 578   if (is_hotspot()) {

</pre><hr></hr><pre>
 602 DO_THROW(InternalError)
 603 DO_THROW(ArrayIndexOutOfBoundsException)
 604 DO_THROW(IllegalStateException)
 605 DO_THROW(NullPointerException)
 606 DO_THROW(IllegalArgumentException)
 607 DO_THROW(InvalidInstalledCodeException)
 608 DO_THROW(UnsatisfiedLinkError)
 609 DO_THROW(UnsupportedOperationException)
 610 DO_THROW(ClassNotFoundException)
 611 
 612 #undef DO_THROW
 613 
 614 void JVMCIEnv::fthrow_error(const char* file, int line, const char* format, ...) {
 615   const int max_msg_size = 1024;
 616   va_list ap;
 617   va_start(ap, format);
 618   char msg[max_msg_size];
 619   vsnprintf(msg, max_msg_size, format, ap);
 620   msg[max_msg_size-1] = '\0';
 621   va_end(ap);

 622   JavaThread* THREAD = JavaThread::current();
<span class="new"> 623   if (is_hotspot()) {</span>
 624     Handle h_loader = Handle();
 625     Handle h_protection_domain = Handle();
 626     Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);
 627   } else {
<span class="changed"> 628     JNIAccessMark jni(this, THREAD);</span>
 629     jni()-&gt;ThrowNew(JNIJVMCI::JVMCIError::clazz(), msg);
 630   }
 631 }
 632 
 633 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_compileMethod (JVMCIObject runtime, JVMCIObject method, int entry_bci,
 634                                                               jlong compile_state, int id) {
 635   if (is_hotspot()) {
 636     Thread* THREAD = Thread::current();
 637     JavaCallArguments jargs;
 638     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 639     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(method)));
 640     jargs.push_int(entry_bci);
 641     jargs.push_long(compile_state);
 642     jargs.push_int(id);
 643     JavaValue result(T_OBJECT);
 644     JavaCalls::call_special(&amp;result,
 645                             HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 646                             vmSymbols::compileMethod_name(),
 647                             vmSymbols::compileMethod_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 648     return wrap((oop) result.get_jobject());

</pre><hr></hr><pre>
 665     JavaCallArguments jargs;
 666     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 667     JavaValue result(T_VOID);
 668     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::bootstrapFinished_name(), vmSymbols::void_method_signature(), &amp;jargs, CHECK);
 669   } else {
 670     JNIAccessMark jni(this);
 671     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::bootstrapFinished_method());
 672 
 673   }
 674 }
 675 
 676 void JVMCIEnv::call_HotSpotJVMCIRuntime_shutdown (JVMCIObject runtime) {
 677   HandleMark hm;
 678   JavaThread* THREAD = JavaThread::current();
 679   if (is_hotspot()) {
 680     JavaCallArguments jargs;
 681     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 682     JavaValue result(T_VOID);
 683     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &amp;jargs, THREAD);
 684   } else {
<span class="changed"> 685     JNIAccessMark jni(this, THREAD);</span>
 686     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::shutdown_method());
 687   }
 688   if (has_pending_exception()) {
 689     // This should never happen as HotSpotJVMCIRuntime.shutdown() should
 690     // handle all exceptions.
 691     describe_pending_exception(true);
 692   }
 693 }
 694 
 695 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_runtime (JVMCIEnv* JVMCIENV) {
 696   JavaThread* THREAD = JavaThread::current();
 697   if (is_hotspot()) {
 698     JavaCallArguments jargs;
 699     JavaValue result(T_OBJECT);
 700     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::runtime_name(), vmSymbols::runtime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 701     return wrap((oop) result.get_jobject());
 702   } else {
<span class="changed"> 703     JNIAccessMark jni(this, THREAD);</span>
 704     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::runtime_method());
 705     if (jni()-&gt;ExceptionCheck()) {
 706       return JVMCIObject();
 707     }
 708     return wrap(result);
 709   }
 710 }
 711 
 712 JVMCIObject JVMCIEnv::call_JVMCI_getRuntime (JVMCIEnv* JVMCIENV) {
 713   JavaThread* THREAD = JavaThread::current();
 714   if (is_hotspot()) {
 715     JavaCallArguments jargs;
 716     JavaValue result(T_OBJECT);
 717     JavaCalls::call_static(&amp;result, HotSpotJVMCI::JVMCI::klass(), vmSymbols::getRuntime_name(), vmSymbols::getRuntime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 718     return wrap((oop) result.get_jobject());
 719   } else {
<span class="changed"> 720     JNIAccessMark jni(this, THREAD);</span>
 721     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JVMCI::clazz(), JNIJVMCI::JVMCI::getRuntime_method());
 722     if (jni()-&gt;ExceptionCheck()) {
 723       return JVMCIObject();
 724     }
 725     return wrap(result);
 726   }
 727 }
 728 
 729 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_getCompiler (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 730   JavaThread* THREAD = JavaThread::current();
 731   if (is_hotspot()) {
 732     JavaCallArguments jargs;
 733     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 734     JavaValue result(T_OBJECT);
 735     JavaCalls::call_virtual(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::getCompiler_name(), vmSymbols::getCompiler_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 736     return wrap((oop) result.get_jobject());
 737   } else {
<span class="changed"> 738     JNIAccessMark jni(this, THREAD);</span>
 739     jobject result = jni()-&gt;CallObjectMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::getCompiler_method());
 740     if (jni()-&gt;ExceptionCheck()) {
 741       return JVMCIObject();
 742     }
 743     return wrap(result);
 744   }
 745 }
 746 
 747 
 748 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCIEnv* JVMCIENV) {
 749   JavaThread* THREAD = JavaThread::current();
 750   if (is_hotspot()) {
 751     JavaCallArguments jargs;
 752     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));
 753     JavaValue result(T_OBJECT);
 754     JavaCalls::call_static(&amp;result,
 755                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 756                            vmSymbols::callToString_name(),
 757                            vmSymbols::callToString_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 758     return wrap((oop) result.get_jobject());
 759   } else {
<span class="changed"> 760     JNIAccessMark jni(this, THREAD);</span>
 761     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 762                                                      JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),
 763                                                      object.as_jobject());
 764     if (jni()-&gt;ExceptionCheck()) {
 765       return JVMCIObject();
 766     }
 767     return wrap(result);
 768   }
 769 }
 770 
 771 
 772 JVMCIObject JVMCIEnv::call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS) {
 773   JavaThread* THREAD = JavaThread::current();
 774   if (is_hotspot()) {
 775     JavaCallArguments jargs;
 776     jargs.push_int(kind);
 777     jargs.push_long(value);
 778     JavaValue result(T_OBJECT);
 779     JavaCalls::call_static(&amp;result,
 780                            HotSpotJVMCI::PrimitiveConstant::klass(),
 781                            vmSymbols::forTypeChar_name(),
 782                            vmSymbols::forTypeChar_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 783     return wrap((oop) result.get_jobject());
 784   } else {
<span class="changed"> 785     JNIAccessMark jni(this, THREAD);</span>
 786     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),
 787                                                      JNIJVMCI::PrimitiveConstant::forTypeChar_method(),
 788                                                      kind, value);
 789     if (jni()-&gt;ExceptionCheck()) {
 790       return JVMCIObject();
 791     }
 792     return wrap(result);
 793   }
 794 }
 795 
 796 JVMCIObject JVMCIEnv::call_JavaConstant_forFloat(float value, JVMCI_TRAPS) {
 797   JavaThread* THREAD = JavaThread::current();
 798   if (is_hotspot()) {
 799     JavaCallArguments jargs;
 800     jargs.push_float(value);
 801     JavaValue result(T_OBJECT);
 802     JavaCalls::call_static(&amp;result,
 803                            HotSpotJVMCI::JavaConstant::klass(),
 804                            vmSymbols::forFloat_name(),
 805                            vmSymbols::forFloat_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 806     return wrap((oop) result.get_jobject());
 807   } else {
<span class="changed"> 808     JNIAccessMark jni(this, THREAD);</span>
 809     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 810                                                      JNIJVMCI::JavaConstant::forFloat_method(),
 811                                                      value);
 812     if (jni()-&gt;ExceptionCheck()) {
 813       return JVMCIObject();
 814     }
 815     return wrap(result);
 816   }
 817 }
 818 
 819 JVMCIObject JVMCIEnv::call_JavaConstant_forDouble(double value, JVMCI_TRAPS) {
 820   JavaThread* THREAD = JavaThread::current();
 821   if (is_hotspot()) {
 822     JavaCallArguments jargs;
 823     jargs.push_double(value);
 824     JavaValue result(T_OBJECT);
 825     JavaCalls::call_static(&amp;result,
 826                            HotSpotJVMCI::JavaConstant::klass(),
 827                            vmSymbols::forDouble_name(),
 828                            vmSymbols::forDouble_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 829     return wrap((oop) result.get_jobject());
 830   } else {
<span class="changed"> 831     JNIAccessMark jni(this, THREAD);</span>
 832     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 833                                                      JNIJVMCI::JavaConstant::forDouble_method(),
 834                                                      value);
 835     if (jni()-&gt;ExceptionCheck()) {
 836       return JVMCIObject();
 837     }
 838     return wrap(result);
 839   }
 840 }
 841 
 842 JVMCIObject JVMCIEnv::get_jvmci_primitive_type(BasicType type) {
 843   JVMCIObjectArray primitives = get_HotSpotResolvedPrimitiveType_primitives();
 844   JVMCIObject result = get_object_at(primitives, type);
 845   return result;
 846 }
 847 
 848 JVMCIObject JVMCIEnv::new_StackTraceElement(const methodHandle&amp; method, int bci, JVMCI_TRAPS) {
 849   JavaThread* THREAD = JavaThread::current();
 850   Symbol* file_name_sym;
 851   int line_number;

</pre><hr></hr><pre>
 856   const char* declaring_class_str = holder-&gt;external_name();
 857 
 858   if (is_hotspot()) {
 859     HotSpotJVMCI::StackTraceElement::klass()-&gt;initialize(CHECK_(JVMCIObject()));
 860     oop objOop = HotSpotJVMCI::StackTraceElement::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
 861     Handle obj = Handle(THREAD, objOop);
 862 
 863     oop declaring_class = StringTable::intern((char*) declaring_class_str, CHECK_(JVMCIObject()));
 864     HotSpotJVMCI::StackTraceElement::set_declaringClass(this, obj(), declaring_class);
 865 
 866     oop method_name = StringTable::intern(method_name_sym, CHECK_(JVMCIObject()));
 867     HotSpotJVMCI::StackTraceElement::set_methodName(this, obj(), method_name);
 868 
 869     if (file_name_sym != NULL) {
 870       oop file_name = StringTable::intern(file_name_sym, CHECK_(JVMCIObject()));
 871       HotSpotJVMCI::StackTraceElement::set_fileName(this, obj(), file_name);
 872     }
 873     HotSpotJVMCI::StackTraceElement::set_lineNumber(this, obj(), line_number);
 874     return wrap(obj());
 875   } else {
<span class="changed"> 876     JNIAccessMark jni(this, THREAD);</span>
 877     jobject declaring_class = jni()-&gt;NewStringUTF(declaring_class_str);
 878     if (jni()-&gt;ExceptionCheck()) {
 879       return JVMCIObject();
 880     }
 881     jobject method_name = jni()-&gt;NewStringUTF(method_name_sym-&gt;as_C_string());
 882     if (jni()-&gt;ExceptionCheck()) {
 883       return JVMCIObject();
 884     }
 885     jobject file_name = NULL;
 886     if (file_name_sym != NULL) {
 887       file_name = jni()-&gt;NewStringUTF(file_name_sym-&gt;as_C_string());
 888       if (jni()-&gt;ExceptionCheck()) {
 889         return JVMCIObject();
 890       }
 891     }
 892 
 893     jobject result = jni()-&gt;NewObject(JNIJVMCI::StackTraceElement::clazz(),
 894                                       JNIJVMCI::StackTraceElement::constructor(),
 895                                       declaring_class, method_name, file_name, line_number);
 896     return wrap(result);

</pre><hr></hr><pre>
 908       ik-&gt;initialize(CHECK_(JVMCIObject()));
 909     }
 910     oop obj = ik-&gt;allocate_instance(CHECK_(JVMCIObject()));
 911     Handle obj_h(THREAD, obj);
 912     Handle nameStr = java_lang_String::create_from_str(name, CHECK_(JVMCIObject()));
 913 
 914     // Call constructor
 915     JavaCallArguments jargs;
 916     jargs.push_oop(obj_h);
 917     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(methodObject)));
 918     jargs.push_oop(nameStr);
 919     jargs.push_int(isDefault);
 920     jargs.push_long(compileId);
 921     JavaValue result(T_VOID);
 922     JavaCalls::call_special(&amp;result, ik,
 923                             vmSymbols::object_initializer_name(),
 924                             vmSymbols::method_string_bool_long_signature(),
 925                             &amp;jargs, CHECK_(JVMCIObject()));
 926     return wrap(obj_h());
 927   } else {
<span class="changed"> 928     JNIAccessMark jni(this, THREAD);</span>
 929     jobject nameStr = name == NULL ? NULL : jni()-&gt;NewStringUTF(name);
 930     if (jni()-&gt;ExceptionCheck()) {
 931       return JVMCIObject();
 932     }
 933 
 934     jobject result = jni()-&gt;NewObject(JNIJVMCI::HotSpotNmethod::clazz(),
 935                                       JNIJVMCI::HotSpotNmethod::constructor(),
 936                                       methodObject.as_jobject(), nameStr, isDefault);
 937     return wrap(result);
 938   }
 939 }
 940 
 941 JVMCIObject JVMCIEnv::make_local(JVMCIObject object) {
 942   if (object.is_null()) {
 943     return JVMCIObject();
 944   }
 945   if (is_hotspot()) {
 946     return wrap(JNIHandles::make_local(HotSpotJVMCI::resolve(object)));
 947   } else {
 948     JNIAccessMark jni(this);
 949     return wrap(jni()-&gt;NewLocalRef(object.as_jobject()));
 950   }
 951 }
 952 
 953 JVMCIObject JVMCIEnv::make_global(JVMCIObject object) {
 954   if (object.is_null()) {
 955     return JVMCIObject();
 956   }
 957   if (is_hotspot()) {
 958     return wrap(JNIHandles::make_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));
 959   } else {
 960     JNIAccessMark jni(this);
 961     return wrap(jni()-&gt;NewGlobalRef(object.as_jobject()));
 962   }
 963 }
 964 












 965 void JVMCIEnv::destroy_local(JVMCIObject object) {
 966   if (is_hotspot()) {
 967     JNIHandles::destroy_local(object.as_jobject());
 968   } else {
 969     JNIAccessMark jni(this);
 970     jni()-&gt;DeleteLocalRef(object.as_jobject());
 971   }
 972 }
 973 
 974 void JVMCIEnv::destroy_global(JVMCIObject object) {
 975   if (is_hotspot()) {
 976     JNIHandles::destroy_global(object.as_jobject());
 977   } else {
 978     JNIAccessMark jni(this);
 979     jni()-&gt;DeleteGlobalRef(object.as_jobject());
 980   }
 981 }
 982 









 983 const char* JVMCIEnv::klass_name(JVMCIObject object) {
 984   if (is_hotspot()) {
 985     return HotSpotJVMCI::resolve(object)-&gt;klass()-&gt;signature_name();
 986   } else {
 987     JVMCIObject name;
 988     {
 989       JNIAccessMark jni(this);
 990       jclass jcl = jni()-&gt;GetObjectClass(object.as_jobject());
 991       jobject result = jni()-&gt;CallObjectMethod(jcl, JNIJVMCI::Class_getName_method());
 992       name = JVMCIObject::create(result, is_hotspot());
 993     }
 994     return as_utf8_string(name);
 995   }
 996 }
 997 
 998 JVMCIObject JVMCIEnv::get_jvmci_method(const methodHandle&amp; method, JVMCI_TRAPS) {
 999   JVMCIObject method_object;
1000   if (method() == NULL) {
1001     return method_object;
1002   }
1003 
1004   Thread* THREAD = Thread::current();
<span class="changed">1005   jmetadata handle = _runtime-&gt;allocate_handle(method);</span>
1006   jboolean exception = false;
1007   if (is_hotspot()) {
1008     JavaValue result(T_OBJECT);
1009     JavaCallArguments args;
1010     args.push_long((jlong) handle);
1011     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass(),
1012                            vmSymbols::fromMetaspace_name(),
1013                            vmSymbols::method_fromMetaspace_signature(), &amp;args, THREAD);
1014     if (HAS_PENDING_EXCEPTION) {
1015       exception = true;
1016     } else {
1017       method_object = wrap((oop)result.get_jobject());
1018     }
1019   } else {
1020     JNIAccessMark jni(this);
1021     method_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedJavaMethodImpl::clazz(),
1022                                                                   JNIJVMCI::HotSpotResolvedJavaMethodImpl_fromMetaspace_method(),
1023                                                                   (jlong) handle));
1024     exception = jni()-&gt;ExceptionCheck();
1025   }
1026 
1027   if (exception) {
<span class="changed">1028     _runtime-&gt;release_handle(handle);</span>
1029     return JVMCIObject();
1030   }
1031 
1032   assert(asMethod(method_object) == method(), "must be");
1033   if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {
<span class="changed">1034     _runtime-&gt;release_handle(handle);</span>
1035   }
1036   assert(!method_object.is_null(), "must be");
1037   return method_object;
1038 }
1039 
1040 JVMCIObject JVMCIEnv::get_jvmci_type(const JVMCIKlassHandle&amp; klass, JVMCI_TRAPS) {
1041   JVMCIObject type;
1042   if (klass.is_null()) {
1043     return type;
1044   }
1045 
1046   jlong pointer = (jlong) klass();
1047   JavaThread* THREAD = JavaThread::current();
1048   JVMCIObject signature = create_string(klass-&gt;signature_name(), JVMCI_CHECK_(JVMCIObject()));
1049   jboolean exception = false;
1050   if (is_hotspot()) {
1051     JavaValue result(T_OBJECT);
1052     JavaCallArguments args;
1053     args.push_long(pointer);
1054     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(signature)));
1055     JavaCalls::call_static(&amp;result,
1056                            HotSpotJVMCI::HotSpotResolvedObjectTypeImpl::klass(),
1057                            vmSymbols::fromMetaspace_name(),
1058                            vmSymbols::klass_fromMetaspace_signature(), &amp;args, THREAD);
1059 
1060     if (HAS_PENDING_EXCEPTION) {
1061       exception = true;
1062     } else {
1063       type = wrap((oop)result.get_jobject());
1064     }
1065   } else {
<span class="changed">1066     JNIAccessMark jni(this, THREAD);</span>
1067 
1068     HandleMark hm(THREAD);
1069     type = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedObjectTypeImpl::clazz(),
1070                                                         JNIJVMCI::HotSpotResolvedObjectTypeImpl_fromMetaspace_method(),
1071                                                         pointer, signature.as_jstring()));
1072     exception = jni()-&gt;ExceptionCheck();
1073   }
1074   if (exception) {
1075     return JVMCIObject();
1076   }
1077 
1078   assert(type.is_non_null(), "must have result");
1079   return type;
1080 }
1081 
1082 JVMCIObject JVMCIEnv::get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS) {
1083   JVMCIObject cp_object;
<span class="changed">1084   jmetadata handle = _runtime-&gt;allocate_handle(cp);</span>
1085   jboolean exception = false;

1086   JavaThread* THREAD = JavaThread::current();
<span class="new">1087   if (is_hotspot()) {</span>
1088     JavaValue result(T_OBJECT);
1089     JavaCallArguments args;
1090     args.push_long((jlong) handle);
1091     JavaCalls::call_static(&amp;result,
1092                            HotSpotJVMCI::HotSpotConstantPool::klass(),
1093                            vmSymbols::fromMetaspace_name(),
1094                            vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, THREAD);
1095     if (HAS_PENDING_EXCEPTION) {
1096       exception = true;
1097     } else {
1098       cp_object = wrap((oop)result.get_jobject());
1099     }
1100   } else {
<span class="changed">1101     JNIAccessMark jni(this, THREAD);</span>
1102     cp_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotConstantPool::clazz(),
1103                                                              JNIJVMCI::HotSpotConstantPool_fromMetaspace_method(),
1104                                                              (jlong) handle));
1105     exception = jni()-&gt;ExceptionCheck();
1106   }
1107 
1108   if (exception) {
<span class="changed">1109     _runtime-&gt;release_handle(handle);</span>
1110     return JVMCIObject();
1111   }
1112 
1113   assert(!cp_object.is_null(), "must be");
1114   // Constant pools aren't cached so this is always a newly created object using the handle
1115   assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, "must use same handle");
1116   return cp_object;
1117 }
1118 
1119 JVMCIPrimitiveArray JVMCIEnv::new_booleanArray(int length, JVMCI_TRAPS) {

1120   JavaThread* THREAD = JavaThread::current();
<span class="new">1121   if (is_hotspot()) {</span>
1122     typeArrayOop result = oopFactory::new_boolArray(length, CHECK_(JVMCIObject()));
1123     return wrap(result);
1124   } else {
<span class="changed">1125     JNIAccessMark jni(this, THREAD);</span>
1126     jbooleanArray result = jni()-&gt;NewBooleanArray(length);
1127     return wrap(result);
1128   }
1129 }
1130 
1131 JVMCIPrimitiveArray JVMCIEnv::new_byteArray(int length, JVMCI_TRAPS) {

1132   JavaThread* THREAD = JavaThread::current();
<span class="new">1133   if (is_hotspot()) {</span>
1134     typeArrayOop result = oopFactory::new_byteArray(length, CHECK_(JVMCIObject()));
1135     return wrap(result);
1136   } else {
<span class="changed">1137     JNIAccessMark jni(this, THREAD);</span>
1138     jbyteArray result = jni()-&gt;NewByteArray(length);
1139     return wrap(result);
1140   }
1141 }
1142 
1143 JVMCIObjectArray JVMCIEnv::new_byte_array_array(int length, JVMCI_TRAPS) {

1144   JavaThread* THREAD = JavaThread::current();
<span class="new">1145   if (is_hotspot()) {</span>
1146     Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())-&gt;array_klass(CHECK_(JVMCIObject()));
1147     objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) -&gt;allocate(length, CHECK_(JVMCIObject()));
1148     return wrap(result);
1149   } else {
<span class="changed">1150     JNIAccessMark jni(this, THREAD);</span>
1151     jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::byte_array(), NULL);
1152     return wrap(result);
1153   }
1154 }
1155 
1156 JVMCIPrimitiveArray JVMCIEnv::new_intArray(int length, JVMCI_TRAPS) {

1157   JavaThread* THREAD = JavaThread::current();
<span class="new">1158   if (is_hotspot()) {</span>
1159     typeArrayOop result = oopFactory::new_intArray(length, CHECK_(JVMCIObject()));
1160     return wrap(result);
1161   } else {
<span class="changed">1162     JNIAccessMark jni(this, THREAD);</span>
1163     jintArray result = jni()-&gt;NewIntArray(length);
1164     return wrap(result);
1165   }
1166 }
1167 
1168 JVMCIPrimitiveArray JVMCIEnv::new_longArray(int length, JVMCI_TRAPS) {

1169   JavaThread* THREAD = JavaThread::current();
<span class="new">1170   if (is_hotspot()) {</span>
1171     typeArrayOop result = oopFactory::new_longArray(length, CHECK_(JVMCIObject()));
1172     return wrap(result);
1173   } else {
<span class="changed">1174     JNIAccessMark jni(this, THREAD);</span>
1175     jlongArray result = jni()-&gt;NewLongArray(length);
1176     return wrap(result);
1177   }
1178 }
1179 
1180 JVMCIObject JVMCIEnv::new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS) {

1181   JavaThread* THREAD = JavaThread::current();
<span class="new">1182   if (is_hotspot()) {</span>
1183     HotSpotJVMCI::VMField::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1184     oop obj = HotSpotJVMCI::VMField::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1185     HotSpotJVMCI::VMField::set_name(this, obj, HotSpotJVMCI::resolve(name));
1186     HotSpotJVMCI::VMField::set_type(this, obj, HotSpotJVMCI::resolve(type));
1187     HotSpotJVMCI::VMField::set_offset(this, obj, offset);
1188     HotSpotJVMCI::VMField::set_address(this, obj, address);
1189     HotSpotJVMCI::VMField::set_value(this, obj, HotSpotJVMCI::resolve(value));
1190     return wrap(obj);
1191   } else {
<span class="changed">1192     JNIAccessMark jni(this, THREAD);</span>
1193     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMField::clazz(),
1194                                     JNIJVMCI::VMField::constructor(),
1195                                     get_jobject(name), get_jobject(type), offset, address, get_jobject(value));
1196     return wrap(result);
1197   }
1198 }
1199 
1200 JVMCIObject JVMCIEnv::new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS) {

1201   JavaThread* THREAD = JavaThread::current();
<span class="new">1202   if (is_hotspot()) {</span>
1203     HotSpotJVMCI::VMFlag::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1204     oop obj = HotSpotJVMCI::VMFlag::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1205     HotSpotJVMCI::VMFlag::set_name(this, obj, HotSpotJVMCI::resolve(name));
1206     HotSpotJVMCI::VMFlag::set_type(this, obj, HotSpotJVMCI::resolve(type));
1207     HotSpotJVMCI::VMFlag::set_value(this, obj, HotSpotJVMCI::resolve(value));
1208     return wrap(obj);
1209   } else {
<span class="changed">1210     JNIAccessMark jni(this, THREAD);</span>
1211     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMFlag::clazz(),
1212                                     JNIJVMCI::VMFlag::constructor(),
1213                                     get_jobject(name), get_jobject(type), get_jobject(value));
1214     return wrap(result);
1215   }
1216 }
1217 
1218 JVMCIObject JVMCIEnv::new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS) {

1219   JavaThread* THREAD = JavaThread::current();
<span class="new">1220   if (is_hotspot()) {</span>
1221     HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1222     oop obj = HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1223     HotSpotJVMCI::VMIntrinsicMethod::set_declaringClass(this, obj, HotSpotJVMCI::resolve(declaringClass));
1224     HotSpotJVMCI::VMIntrinsicMethod::set_name(this, obj, HotSpotJVMCI::resolve(name));
1225     HotSpotJVMCI::VMIntrinsicMethod::set_descriptor(this, obj, HotSpotJVMCI::resolve(descriptor));
1226     HotSpotJVMCI::VMIntrinsicMethod::set_id(this, obj, id);
1227     return wrap(obj);
1228   } else {
<span class="changed">1229     JNIAccessMark jni(this, THREAD);</span>
1230     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMIntrinsicMethod::clazz(),
1231                                     JNIJVMCI::VMIntrinsicMethod::constructor(),
1232                                     get_jobject(declaringClass), get_jobject(name), get_jobject(descriptor), id);
1233     return wrap(result);
1234   }
1235 }
1236 
1237 JVMCIObject JVMCIEnv::new_HotSpotStackFrameReference(JVMCI_TRAPS) {
1238   if (is_hotspot()) {
1239     JavaThread* THREAD = JavaThread::current();
1240     HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1241     oop obj = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1242     return wrap(obj);
1243   } else {
1244     ShouldNotReachHere();
1245     return JVMCIObject();
1246   }
1247 }
1248 JVMCIObject JVMCIEnv::new_JVMCIError(JVMCI_TRAPS) {
1249   if (is_hotspot()) {

</pre><hr></hr><pre>
1255     ShouldNotReachHere();
1256     return JVMCIObject();
1257   }
1258 }
1259 
1260 
1261 JVMCIObject JVMCIEnv::get_object_constant(oop objOop, bool compressed, bool dont_register) {
1262   JavaThread* THREAD = JavaThread::current();
1263   Handle obj = Handle(THREAD, objOop);
1264   if (obj.is_null()) {
1265     return JVMCIObject();
1266   }
1267   if (is_hotspot()) {
1268     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1269     oop constant = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1270     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::set_object(this, constant, obj());
1271     HotSpotJVMCI::HotSpotObjectConstantImpl::set_compressed(this, constant, compressed);
1272     return wrap(constant);
1273   } else {
1274     jlong handle = make_handle(obj);
<span class="changed">1275     JNIAccessMark jni(this, THREAD);</span>
1276     jobject result = jni()-&gt;NewObject(JNIJVMCI::IndirectHotSpotObjectConstantImpl::clazz(),
1277                                       JNIJVMCI::IndirectHotSpotObjectConstantImpl::constructor(),
1278                                       handle, compressed, dont_register);
1279     return wrap(result);
1280   }
1281 }
1282 
1283 
1284 Handle JVMCIEnv::asConstant(JVMCIObject constant, JVMCI_TRAPS) {
1285   if (constant.is_null()) {
1286     return Handle();
1287   }
1288   JavaThread* THREAD = JavaThread::current();
1289   if (is_hotspot()) {
1290     assert(HotSpotJVMCI::DirectHotSpotObjectConstantImpl::is_instance(this, constant), "wrong type");
1291     oop obj = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::object(this, HotSpotJVMCI::resolve(constant));
1292     return Handle(THREAD, obj);
1293   } else if (isa_IndirectHotSpotObjectConstantImpl(constant)) {
1294     jlong object_handle = get_IndirectHotSpotObjectConstantImpl_objectHandle(constant);
1295     if (object_handle == 0L) {
1296       JVMCI_THROW_MSG_(NullPointerException, "Foreign object reference has been cleared", Handle());
1297     }
1298     oop result = resolve_handle(object_handle);
1299     if (result == NULL) {
1300       JVMCI_THROW_MSG_(InternalError, "Constant was unexpectedly NULL", Handle());
1301     }
1302     return Handle(THREAD, result);
1303   } else {
1304     JVMCI_THROW_MSG_(IllegalArgumentException, "DirectHotSpotObjectConstantImpl shouldn't reach JVMCI in SVM mode", Handle());
1305   }
1306 }
1307 
1308 JVMCIObject JVMCIEnv::wrap(jobject object) {
1309   return JVMCIObject::create(object, is_hotspot());
1310 }
1311 
1312 jlong JVMCIEnv::make_handle(const Handle&amp; obj) {
1313   assert(!obj.is_null(), "should only create handle for non-NULL oops");
<span class="changed">1314   jobject handle = _runtime-&gt;make_global(obj);</span>
1315   return (jlong) handle;
1316 }
1317 
1318 oop JVMCIEnv::resolve_handle(jlong objectHandle) {
1319   assert(objectHandle != 0, "should be a valid handle");
1320   oop obj = *((oopDesc**)objectHandle);
1321   if (obj != NULL) {
1322     oopDesc::verify(obj);
1323   }
1324   return obj;
1325 }
1326 
1327 JVMCIObject JVMCIEnv::create_string(const char* str, JVMCI_TRAPS) {

1328   JavaThread* THREAD = JavaThread::current();
<span class="new">1329   if (is_hotspot()) {</span>
1330     Handle result = java_lang_String::create_from_str(str, CHECK_(JVMCIObject()));
1331     return HotSpotJVMCI::wrap(result());
1332   } else {
1333     jobject result;
1334     jboolean exception = false;
1335     {
<span class="changed">1336       JNIAccessMark jni(this, THREAD);</span>
1337       result = jni()-&gt;NewStringUTF(str);
1338       exception = jni()-&gt;ExceptionCheck();
1339     }
1340     return wrap(result);
1341   }
1342 }
1343 
1344 bool JVMCIEnv::equals(JVMCIObject a, JVMCIObject b) {
1345   if (is_hotspot()) {
1346     return HotSpotJVMCI::resolve(a) == HotSpotJVMCI::resolve(b);
1347   } else {
1348     JNIAccessMark jni(this);
1349     return jni()-&gt;IsSameObject(a.as_jobject(), b.as_jobject()) != 0;
1350   }
1351 }
1352 
1353 BasicType JVMCIEnv::kindToBasicType(JVMCIObject kind, JVMCI_TRAPS) {
1354   if (kind.is_null()) {
1355     JVMCI_THROW_(NullPointerException, T_ILLEGAL);
1356   }

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/hotspot/share/jvmci/jvmciCompilerToVM.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/jvmci/jvmciEnv.hpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
