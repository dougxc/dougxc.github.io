<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/jvmci/jvmciJavaClasses.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/symbolTable.hpp"
  26 #include "interpreter/linkResolver.hpp"
  27 #include "jvmci/jniAccessMark.inline.hpp"
  28 #include "jvmci/jvmciJavaClasses.hpp"
  29 #include "jvmci/jvmciRuntime.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "runtime/jniHandles.inline.hpp"
  32 #include "runtime/fieldDescriptor.inline.hpp"
  33 
  34 // ------------------------------------------------------------------
  35 
  36 oop HotSpotJVMCI::resolve(JVMCIObject obj) {
  37   return JNIHandles::resolve(obj.as_jobject());
  38 }
  39 
  40 arrayOop HotSpotJVMCI::resolve(JVMCIArray obj) {
  41   return (arrayOop) JNIHandles::resolve(obj.as_jobject());
  42 }
  43 
  44 objArrayOop HotSpotJVMCI::resolve(JVMCIObjectArray obj) {
  45   return (objArrayOop) JNIHandles::resolve(obj.as_jobject());
  46 }
  47 
  48 typeArrayOop HotSpotJVMCI::resolve(JVMCIPrimitiveArray obj) {
  49   return (typeArrayOop) JNIHandles::resolve(obj.as_jobject());
  50 }
  51 
  52 JVMCIObject HotSpotJVMCI::wrap(oop obj) {
  53   assert(Thread::current()-&gt;is_Java_thread(), "must be");
  54   return JVMCIObject(JNIHandles::make_local(obj), true);
  55 }
  56 
  57 /**
  58  * Computes the field offset of a static or instance field.
  59  * It looks up the name and signature symbols without creating new ones;
  60  * all the symbols of these classes need to be already loaded.
  61  */
  62 void HotSpotJVMCI::compute_offset(int &amp;dest_offset, Klass* klass, const char* name, const char* signature, bool static_field, TRAPS) {
  63   InstanceKlass* ik = InstanceKlass::cast(klass);
  64   Symbol* name_symbol = SymbolTable::probe(name, (int)strlen(name));
  65   Symbol* signature_symbol = SymbolTable::probe(signature, (int)strlen(signature));
  66   if (name_symbol == NULL || signature_symbol == NULL) {
  67 #ifndef PRODUCT
  68     ik-&gt;print_on(tty);
  69 #endif
  70     fatal("symbol with name %s and signature %s was not found in symbol table (klass=%s)", name, signature, klass-&gt;name()-&gt;as_C_string());
  71   }
  72 
  73   fieldDescriptor fd;
  74   if (!ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd)) {
  75     ResourceMark rm;
  76     fatal("Could not find field %s.%s with signature %s", ik-&gt;external_name(), name, signature);
  77   }
  78   guarantee(fd.is_static() == static_field, "static/instance mismatch");
  79   dest_offset = fd.offset();
  80   assert(dest_offset != 0, "must be valid offset");
  81   if (static_field) {
  82         // Must ensure classes for static fields are initialized as the
  83         // accessor itself does not include a class initialization check.
  84         ik-&gt;initialize(CHECK);
  85   }
  86   JVMCI_event_2("   field offset for %s %s.%s = %d", signature, ik-&gt;external_name(), name, dest_offset);
  87 }
  88 
  89 #ifndef PRODUCT
  90 static void check_resolve_method(const char* call_type, Klass* resolved_klass, Symbol* method_name, Symbol* method_signature, TRAPS) {
  91   Method* method;
  92   LinkInfo link_info(resolved_klass, method_name, method_signature, NULL, LinkInfo::skip_access_check);
  93   if (strcmp(call_type, "call_static") == 0) {
  94     method = LinkResolver::resolve_static_call_or_null(link_info);
  95   } else if (strcmp(call_type, "call_virtual") == 0) {
  96     method = LinkResolver::resolve_virtual_call_or_null(resolved_klass, link_info);
  97   } else if (strcmp(call_type, "call_special") == 0) {
  98     method = LinkResolver::resolve_special_call_or_null(link_info);
  99   } else {
 100     fatal("Unknown or unsupported call type: %s", call_type);
 101   }
 102   if (method == NULL) {
 103     fatal("Could not resolve %s.%s%s", resolved_klass-&gt;external_name(), method_name-&gt;as_C_string(), method_signature-&gt;as_C_string());
 104   }
 105 }
 106 #endif
 107 
 108 jclass JNIJVMCI::_box_classes[T_CONFLICT+1];
 109 jclass JNIJVMCI::_byte_array;
 110 jfieldID JNIJVMCI::_box_fields[T_CONFLICT+1];
 111 jmethodID JNIJVMCI::_box_constructors[T_CONFLICT+1];
 112 jmethodID JNIJVMCI::_Class_getName_method;
 113 
 114 jmethodID JNIJVMCI::_HotSpotResolvedJavaMethodImpl_fromMetaspace_method;
 115 jmethodID JNIJVMCI::_HotSpotConstantPool_fromMetaspace_method;
 116 jmethodID JNIJVMCI::_HotSpotResolvedObjectTypeImpl_fromMetaspace_method;
 117 jmethodID JNIJVMCI::_HotSpotResolvedPrimitiveType_fromMetaspace_method;
 118 
 119 #define START_CLASS(className, fullClassName)                          { \
 120   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::fullClassName(), true, CHECK); \
 121   className::_klass = InstanceKlass::cast(k);                                     \
 122   JVMCI_event_2(" klass for %s = " PTR_FORMAT, k-&gt;external_name(), p2i(k));       \
 123   className::_klass-&gt;initialize(CHECK);
 124 
 125 #define END_CLASS }
 126 
 127 #define FIELD(className, name, signature, static_field) compute_offset(className::_##name##_offset, className::_klass, #name, signature, static_field, CHECK);
 128 #define CHAR_FIELD(className, name) FIELD(className, name, "C", false)
 129 #define INT_FIELD(className, name) FIELD(className, name, "I", false)
 130 #define BOOLEAN_FIELD(className, name) FIELD(className, name, "Z", false)
 131 #define LONG_FIELD(className, name) FIELD(className, name, "J", false)
 132 #define FLOAT_FIELD(className, name) FIELD(className, name, "F", false)
 133 #define OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, false)
 134 #define STATIC_OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, true)
 135 #define STATIC_INT_FIELD(className, name) FIELD(className, name, "I", true)
 136 #define STATIC_BOOLEAN_FIELD(className, name) FIELD(className, name, "Z", true)
 137 #ifdef PRODUCT
 138 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
 139 #define CONSTRUCTOR(className, signature)
 140 #else
 141 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \
 142   check_resolve_method(#hsCallType, k, vmSymbols::methodName##_name(), vmSymbols::signatureSymbolName(), CHECK);
 143 #define CONSTRUCTOR(className, signature) { \
 144   TempNewSymbol sig = SymbolTable::new_symbol(signature); \
 145   check_resolve_method("call_special", k, vmSymbols::object_initializer_name(), sig, CHECK); \
 146   }
 147 #endif
 148 /**
 149  * Computes and initializes the offsets used by HotSpotJVMCI.
 150  */
 151 void HotSpotJVMCI::compute_offsets(TRAPS) {
 152   JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, OBJECT_FIELD, OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
 153 }
 154 
 155 #undef START_CLASS
 156 #undef END_CLASS
 157 #undef METHOD
 158 #undef CONSTRUCTOR
 159 #undef FIELD
 160 #undef CHAR_FIELD
 161 #undef INT_FIELD
 162 #undef BOOLEAN_FIELD
 163 #undef LONG_FIELD
 164 #undef FLOAT_FIELD
 165 #undef OBJECT_FIELD
 166 #undef PRIMARRAY_FIELD
 167 #undef OBJECTARRAY_FIELD
 168 #undef STATIC_FIELD
 169 #undef STATIC_OBJECT_FIELD
 170 #undef STATIC_OBJECTARRAY_FIELD
 171 #undef STATIC_INT_FIELD
 172 #undef STATIC_BOOLEAN_FIELD
 173 #undef EMPTY_CAST
 174 
 175 // ------------------------------------------------------------------
 176 
 177 #define START_CLASS(className, fullClassName)                                           \
 178   void HotSpotJVMCI::className::initialize(JVMCI_TRAPS) {                               \
 179     Thread* THREAD = Thread::current();                                                 \
 180     className::klass()-&gt;initialize(CHECK);                                              \
 181   }                                                                                     \
 182   bool HotSpotJVMCI::className::is_instance(JVMCIEnv* env, JVMCIObject object) {        \
 183     return resolve(object)-&gt;is_a(className::klass());                                   \
 184   }                                                                                     \
 185   void HotSpotJVMCI::className::check(oop obj, const char* field_name, int offset) {    \
 186     assert(obj != NULL, "NULL field access of %s.%s", #className, field_name); \
 187     assert(obj-&gt;is_a(className::klass()), "wrong class, " #className " expected, found %s", obj-&gt;klass()-&gt;external_name()); \
 188     assert(offset != 0, "must be valid offset");                                        \
 189   }                                                                                     \
 190   InstanceKlass* HotSpotJVMCI::className::_klass = NULL;
 191 
 192 #define END_CLASS
 193 
 194 #define FIELD(className, name, type, accessor, cast)                     \
 195   type HotSpotJVMCI::className::name(JVMCIEnv* env, oop obj)               { className::check(obj, #name, className::_##name##_offset); return cast obj-&gt;accessor(className::_##name##_offset); } \
 196   void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, oop obj, type x) { className::check(obj, #name, className::_##name##_offset); obj-&gt;accessor##_put(className::_##name##_offset, x); }
 197 
 198 #define EMPTY_CAST
 199 #define CHAR_FIELD(className, name) FIELD(className, name, jchar, char_field, EMPTY_CAST)
 200 #define INT_FIELD(className, name) FIELD(className, name, jint, int_field, EMPTY_CAST)
 201 #define BOOLEAN_FIELD(className, name) FIELD(className, name, jboolean, bool_field, EMPTY_CAST)
 202 #define LONG_FIELD(className, name) FIELD(className, name, jlong, long_field, EMPTY_CAST)
 203 #define FLOAT_FIELD(className, name) FIELD(className, name, jfloat, float_field, EMPTY_CAST)
 204 
 205 #define OBJECT_FIELD(className, name, signature) FIELD(className, name, oop, obj_field, EMPTY_CAST)
 206 #define OBJECTARRAY_FIELD(className, name, signature) FIELD(className, name, objArrayOop, obj_field, (objArrayOop))
 207 #define PRIMARRAY_FIELD(className, name, signature) FIELD(className, name, typeArrayOop, obj_field, (typeArrayOop))
 208 #define STATIC_OBJECT_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, oop)
 209 #define STATIC_OBJECTARRAY_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, objArrayOop)
 210 #define STATIC_OOPISH_FIELD(className, name, type)                                                                        \
 211     type HotSpotJVMCI::className::name(JVMCIEnv* env) {                                                                   \
 212       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), "Class not yet linked: " #className);         \
 213       InstanceKlass* ik = className::klass();                                                                             \
 214       oop base = ik-&gt;static_field_base_raw();                                                                             \
 215       oop result = HeapAccess&lt;&gt;::oop_load_at(base, className::_##name##_offset);                                          \
 216       return type(result);                                                                                                \
 217     }                                                                                                                     \
 218     void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, type x) {                                                     \
 219       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), "Class not yet linked: " #className);         \
 220       assert(className::klass() != NULL, "Class not yet loaded: " #className);                                            \
 221       InstanceKlass* ik = className::klass();                                                                             \
 222       oop base = ik-&gt;static_field_base_raw();                                                                             \
 223       HeapAccess&lt;&gt;::oop_store_at(base, className::_##name##_offset, x);                                                   \
 224     }
 225 #define STATIC_PRIMITIVE_FIELD(className, name, jtypename)                                                                \
 226     jtypename HotSpotJVMCI::className::get_##name(JVMCIEnv* env) {                                                        \
 227       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), "Class not yet linked: " #className);         \
 228       InstanceKlass* ik = className::klass();                                                                             \
 229       oop base = ik-&gt;static_field_base_raw();                                                                             \
 230       return HeapAccess&lt;&gt;::load_at(base, className::_##name##_offset);                                                    \
 231     }                                                                                                                     \
 232     void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, jtypename x) {                                                \
 233       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), "Class not yet linked: " #className);         \
 234       InstanceKlass* ik = className::klass();                                                                             \
 235       oop base = ik-&gt;static_field_base_raw();                                                                             \
 236       HeapAccess&lt;&gt;::store_at(base, _##name##_offset, x);                                                                  \
 237     }
 238 
 239 #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint)
 240 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean)
 241 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
 242 #define CONSTRUCTOR(className, signature)
 243 
 244 /**
 245  * Generates the method and field definitions for the classes in HotSpotJVMCI. For example:
 246  *
 247  * void HotSpotJVMCI::Architecture::initialize(JVMCIEnv* env) { ... }
 248  * bool HotSpotJVMCI::Architecture::is_instance(JVMCIEnv* env, JVMCIObject object) { ... }
 249  * void HotSpotJVMCI::Architecture::check(oop obj, const char* field_name, int offset) { ... }
 250  *  oop HotSpotJVMCI::Architecture::wordKind(JVMCIEnv* env, oop obj) { ... }
 251  * void HotSpotJVMCI::Architecture::set_wordKind(JVMCIEnv* env, oop obj, oop x) { ... }
 252  *
 253  * InstanceKlass *HotSpotJVMCI::Architecture::_klass = NULL;
 254  */
 255 JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
 256 
 257 #undef START_CLASS
 258 #undef END_CLASS
 259 #undef METHOD
 260 #undef CONSTRUCTOR
 261 #undef FIELD
 262 #undef CHAR_FIELD
 263 #undef INT_FIELD
 264 #undef BOOLEAN_FIELD
 265 #undef LONG_FIELD
 266 #undef FLOAT_FIELD
 267 #undef OBJECT_FIELD
 268 #undef PRIMARRAY_FIELD
 269 #undef OBJECTARRAY_FIELD
 270 #undef STATIC_OOPISH_FIELD
 271 #undef STATIC_OBJECT_FIELD
 272 #undef STATIC_OBJECTARRAY_FIELD
 273 #undef STATIC_INT_FIELD
 274 #undef STATIC_BOOLEAN_FIELD
 275 #undef STATIC_PRIMITIVE_FIELD
 276 #undef EMPTY_CAST
 277 
 278 /**
 279  * Initializes the JNI id of a field. As per the JNI specification,
 280  * this ensures the declaring class is initialized.
 281  */
 282 void JNIJVMCI::initialize_field_id(JNIEnv* env, jfieldID &amp;fieldid, jclass clazz, const char* class_name, const char* name, const char* signature, bool static_field) {
 283   if (JVMCILibDumpJNIConfig != NULL) {
 284     fileStream* st = JVMCIGlobals::get_jni_config_file();
 285     st-&gt;print_cr("field %s %s %s", class_name, name, signature);
 286     return;
 287   }
 288   if (env-&gt;ExceptionCheck()) {
 289     return;
 290   }
 291   jfieldID current = fieldid;
 292   if (static_field) {
 293     // Class initialization barrier
 294     fieldid = env-&gt;GetStaticFieldID(clazz, name, signature);
 295   } else {
 296     // Class initialization barrier
 297     fieldid = env-&gt;GetFieldID(clazz, name, signature);
 298   }
 299   JVMCI_event_2("   jfieldID for %s %s.%s = " PTR_FORMAT, signature, class_name, name, p2i(fieldid));
 300 
 301   if (env-&gt;ExceptionCheck()) {
 302     env-&gt;ExceptionDescribe();
 303     env-&gt;ExceptionClear();
 304     ResourceMark rm;
 305     Thread* THREAD = Thread::current();
 306     fatal("Could not find field %s.%s with signature %s", class_name, name, signature);
 307   }
 308 }
 309 
 310 #define START_CLASS(className, fullClassName) {                                             \
 311   current_class_name = vmSymbols::fullClassName()-&gt;as_C_string();                           \
 312   if (JVMCILibDumpJNIConfig != NULL) {                                                      \
 313     fileStream* st = JVMCIGlobals::get_jni_config_file();                                   \
 314     st-&gt;print_cr("class %s", current_class_name);                                           \
 315   } else {                                                                                  \
 316     jclass k = env-&gt;FindClass(current_class_name);                                          \
 317     JVMCI_EXCEPTION_CHECK(env, "FindClass(%s)", current_class_name);                        \
 318     assert(k != NULL, #fullClassName " not initialized");                                   \
 319     k = (jclass) env-&gt;NewGlobalRef(k);                                                      \
 320     JVMCI_event_2(" jclass for %s = " PTR_FORMAT, current_class_name, p2i(k));              \
 321     className::_class = k;                                                                  \
 322   }
 323 
 324 #define END_CLASS current_class_name = NULL; }
 325 
 326 #define FIELD(className, name, signature, static_field) initialize_field_id(env, className::_##name##_field_id, className::_class, current_class_name, #name, signature, static_field);
 327 #define CHAR_FIELD(className, name) FIELD(className, name, "C", false)
 328 #define INT_FIELD(className, name) FIELD(className, name, "I", false)
 329 #define BOOLEAN_FIELD(className, name) FIELD(className, name, "Z", false)
 330 #define LONG_FIELD(className, name) FIELD(className, name, "J", false)
 331 #define FLOAT_FIELD(className, name) FIELD(className, name, "F", false)
 332 #define OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, false)
 333 #define STATIC_OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, true)
 334 #define STATIC_INT_FIELD(className, name) FIELD(className, name, "I", true)
 335 #define STATIC_BOOLEAN_FIELD(className, name) FIELD(className, name, "Z", true)
 336 
 337 #define GET_JNI_METHOD(jniGetMethod, dst, clazz, methodName, signature)                        \
 338     if (JVMCILibDumpJNIConfig != NULL) {                                                       \
 339       fileStream* st = JVMCIGlobals::get_jni_config_file();                                    \
 340       st-&gt;print_cr("method %s %s %s", current_class_name, methodName, signature);              \
 341     } else {                                                                                   \
 342       jmethodID current = dst;                                                                 \
 343       dst = env-&gt;jniGetMethod(clazz, methodName, signature);                                   \
 344       JVMCI_EXCEPTION_CHECK(env, #jniGetMethod "(%s.%s%s)",                                    \
 345                   current_class_name, methodName, signature);                                  \
 346       assert(dst != NULL, "uninitialized");                                                    \
 347       JVMCI_event_2("   jmethodID for %s.%s%s = " PTR_FORMAT,                                  \
 348                   current_class_name, methodName, signature, p2i(dst));                        \
 349     }
 350 
 351 #define GET_JNI_CONSTRUCTOR(clazz, signature) \
 352   GET_JNI_METHOD(GetMethodID, JNIJVMCI::clazz::_constructor, clazz::_class, "&lt;init&gt;", signature) \
 353 
 354 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \
 355      GET_JNI_METHOD(jniGetMethod,                                        \
 356                     className::_##methodName##_method,                   \
 357                     className::clazz(),                                  \
 358                     vmSymbols::methodName##_name()-&gt;as_C_string(),       \
 359                     vmSymbols::signatureSymbolName()-&gt;as_C_string())
 360 
 361 #define CONSTRUCTOR(className, signature) \
 362   GET_JNI_CONSTRUCTOR(className, signature)
 363 
 364 extern "C" {
 365   void     JNICALL JVM_RegisterJVMCINatives(JNIEnv *env, jclass compilerToVMClass);
 366   jobject  JNICALL JVM_GetJVMCIRuntime(JNIEnv *env, jclass c);
 367 }
 368 
 369 // Dumps symbols for public &lt;init&gt;() and &lt;init&gt;(String) methods of
 370 // non-abstract Throwable subtypes known by the VM. This is to
 371 // support the use of reflection in jdk.vm.ci.hotspot.TranslatedException.create().
 372 class ThrowableInitDumper : public SymbolClosure {
 373  private:
 374   fileStream* _st;
 375  public:
 376   ThrowableInitDumper(fileStream* st)     { _st = st; }
 377   void do_symbol(Symbol** p) {
 378     Thread* THREAD = Thread::current();
 379     Symbol* name = *p;
 380     if (name == NULL) {
 381       return;
 382     }
 383     Klass* k = SystemDictionary::resolve_or_null(name, CHECK_EXIT);
 384     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 385       InstanceKlass* iklass = InstanceKlass::cast(k);
 386       if (iklass-&gt;is_subclass_of(SystemDictionary::Throwable_klass()) &amp;&amp; iklass-&gt;is_public() &amp;&amp; !iklass-&gt;is_abstract()) {
 387         const char* class_name = NULL;
 388         Array&lt;Method*&gt;* methods = iklass-&gt;methods();
 389         for (int i = 0; i &lt; methods-&gt;length(); i++) {
 390           Method* m = methods-&gt;at(i);
 391           if (m-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
 392               m-&gt;is_public() &amp;&amp;
 393               (m-&gt;signature() == vmSymbols::void_method_signature() || m-&gt;signature() == vmSymbols::string_void_signature())) {
 394             if (class_name == NULL) {
 395               class_name = name-&gt;as_C_string();
 396               _st-&gt;print_cr("class %s", class_name);
 397             }
 398             _st-&gt;print_cr("method %s %s %s", class_name, m-&gt;name()-&gt;as_C_string(), m-&gt;signature()-&gt;as_C_string());
 399           }
 400         }
 401       }
 402     }
 403   }
 404 };
 405 
 406 #define IN_CLASS(fullClassName) current_class_name = vmSymbols::fullClassName()-&gt;as_C_string()
 407 /**
 408  * Initializes the JNI method and field ids used in JNIJVMCI.
 409  */
 410 void JNIJVMCI::initialize_ids(JNIEnv* env) {
 411   ResourceMark rm;
 412   const char* current_class_name = NULL;
 413   JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, OBJECT_FIELD, OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
 414 
 415   IN_CLASS(java_lang_Class);
 416   GET_JNI_METHOD(GetMethodID, _Class_getName_method, Class::_class, "getName", "()Ljava/lang/String;");
 417 
 418   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedPrimitiveType);
 419   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedPrimitiveType_fromMetaspace_method, HotSpotResolvedPrimitiveType::_class,
 420                                                                                           vmSymbols::fromMetaspace_name()-&gt;as_C_string(),
 421                                                                                           vmSymbols::primitive_fromMetaspace_signature()-&gt;as_C_string());
 422   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedObjectTypeImpl);
 423   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedObjectTypeImpl_fromMetaspace_method, HotSpotResolvedObjectTypeImpl::_class,
 424                                                                                            vmSymbols::fromMetaspace_name()-&gt;as_C_string(),
 425                                                                                            vmSymbols::klass_fromMetaspace_signature()-&gt;as_C_string());
 426   IN_CLASS(jdk_vm_ci_hotspot_HotSpotConstantPool);
 427   GET_JNI_METHOD(GetStaticMethodID, _HotSpotConstantPool_fromMetaspace_method, HotSpotConstantPool::_class,
 428                                                                                   vmSymbols::fromMetaspace_name()-&gt;as_C_string(),
 429                                                                                   vmSymbols::constantPool_fromMetaspace_signature()-&gt;as_C_string());
 430   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedJavaMethodImpl);
 431   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedJavaMethodImpl_fromMetaspace_method, HotSpotResolvedJavaMethodImpl::_class,
 432                                                                                            vmSymbols::fromMetaspace_name()-&gt;as_C_string(),
 433                                                                                            vmSymbols::method_fromMetaspace_signature()-&gt;as_C_string());
 434 
 435 #define BOX_CLASSES(generate)     \
 436   generate(Boolean, T_BOOLEAN, Z) \
 437   generate(Byte, T_BYTE, B)       \
 438   generate(Character, T_CHAR, C)  \
 439   generate(Short, T_SHORT, S)     \
 440   generate(Integer, T_INT, I)     \
 441   generate(Long, T_LONG, J)       \
 442   generate(Float, T_FLOAT, F)     \
 443   generate(Double, T_DOUBLE, D)   \
 444 
 445 #define DO_BOX_CLASS(klass, basicType, type) \
 446   current_class_name = "java/lang/" #klass;                                                                       \
 447   if (JVMCILibDumpJNIConfig == NULL) {                                                                            \
 448     _box_classes[basicType] = env-&gt;FindClass("java/lang/" #klass);                                                \
 449     JVMCI_EXCEPTION_CHECK(env, "FindClass(%s)", #klass);                                                          \
 450     _box_classes[basicType] = (jclass) env-&gt;NewGlobalRef(_box_classes[basicType]);                                \
 451     assert(_box_classes[basicType] != NULL, "uninitialized");                                                     \
 452     _box_fields[basicType] = env-&gt;GetFieldID(_box_classes[basicType], "value", #type);                            \
 453     JVMCI_EXCEPTION_CHECK(env, "GetFieldID(%s, value, %s)", #klass, #type);                                       \
 454     GET_JNI_METHOD(GetMethodID, _box_constructors[basicType], _box_classes[basicType], "&lt;init&gt;", "(" #type ")V"); \
 455   } else {                                                                                                        \
 456     fileStream* st = JVMCIGlobals::get_jni_config_file();                                                         \
 457     st-&gt;print_cr("field %s value %s", current_class_name, #type);                                                 \
 458     st-&gt;print_cr("method %s &lt;init&gt; (%s)V", current_class_name, #type);                                            \
 459   }
 460 
 461   BOX_CLASSES(DO_BOX_CLASS);
 462 
 463   if (JVMCILibDumpJNIConfig == NULL) {
 464     _byte_array = env-&gt;FindClass("[B");
 465     JVMCI_EXCEPTION_CHECK(env, "FindClass([B)");
 466     _byte_array = (jclass) env-&gt;NewGlobalRef(_byte_array);
 467     assert(_byte_array != NULL, "uninitialized");
 468   } else {
 469     fileStream* st = JVMCIGlobals::get_jni_config_file();
 470     st-&gt;print_cr("class [B");
 471   }
 472 
 473 #define DUMP_ALL_NATIVE_METHODS(class_symbol) do {                                                                  \
 474   current_class_name = class_symbol-&gt;as_C_string();                                                                 \
 475   Klass* k = SystemDictionary::resolve_or_fail(class_symbol, true, CHECK_EXIT);                                     \
 476   InstanceKlass* iklass = InstanceKlass::cast(k);                                                                   \
 477   Array&lt;Method*&gt;* methods = iklass-&gt;methods();                                                                      \
 478   for (int i = 0; i &lt; methods-&gt;length(); i++) {                                                                     \
 479     Method* m = methods-&gt;at(i);                                                                                     \
 480     if (m-&gt;is_native()) {                                                                                           \
 481       st-&gt;print_cr("method %s %s %s", current_class_name, m-&gt;name()-&gt;as_C_string(), m-&gt;signature()-&gt;as_C_string()); \
 482     }                                                                                                               \
 483   }                                                                                                                 \
 484 } while(0)
 485 
 486   if (JVMCILibDumpJNIConfig != NULL) {
 487     Thread* THREAD = Thread::current();
 488     fileStream* st = JVMCIGlobals::get_jni_config_file();
 489 
 490     DUMP_ALL_NATIVE_METHODS(vmSymbols::jdk_vm_ci_hotspot_CompilerToVM());
 491     ThrowableInitDumper dumper(st);
 492     vmSymbols::symbols_do(&amp;dumper);
 493 
 494     st-&gt;flush();
 495     tty-&gt;print_cr("Dumped JVMCI shared library JNI configuration to %s", JVMCILibDumpJNIConfig);
 496     vm_exit(0);
 497   }
 498 
 499 #undef DUMP_ALL_NATIVE_METHODS
 500 #undef DO_BOX_CLASS
 501 #undef BOX_CLASSES
 502 #undef IN_CLASS
 503 
 504 #define CC (char*)  /*cast a literal from (const char*)*/
 505 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(f))
 506 }
 507 
 508 static void register_natives_for_class(JNIEnv* env, jclass clazz, const char* name, const JNINativeMethod *methods, jint nMethods) {
 509   if (clazz == NULL) {
 510     clazz = env-&gt;FindClass(name);
 511     if (env-&gt;ExceptionCheck()) {
 512       env-&gt;ExceptionDescribe();
 513       fatal("Could not find class %s", name);
 514     }
 515   }
 516   env-&gt;RegisterNatives(clazz, methods, nMethods);
 517   if (env-&gt;ExceptionCheck()) {
 518     env-&gt;ExceptionDescribe();
 519     fatal("Failure registering natives for %s", name);
 520   }
 521 }
 522 
 523 void JNIJVMCI::register_natives(JNIEnv* env) {
 524   if (env != JavaThread::current()-&gt;jni_environment()) {
 525     JNINativeMethod CompilerToVM_nmethods[] = {{ CC"registerNatives", CC"()V", FN_PTR(JVM_RegisterJVMCINatives) }};
 526     JNINativeMethod JVMCI_nmethods[] = {{ CC"initializeRuntime",   CC"()Ljdk/vm/ci/runtime/JVMCIRuntime;", FN_PTR(JVM_GetJVMCIRuntime) }};
 527 
 528     register_natives_for_class(env, NULL, "jdk/vm/ci/hotspot/CompilerToVM", CompilerToVM_nmethods, 1);
 529     register_natives_for_class(env, JVMCI::clazz(), "jdk/vm/ci/runtime/JVMCI", JVMCI_nmethods, 1);
 530   }
 531 }
 532 
 533 #undef METHOD
 534 #undef CONSTRUCTOR
 535 #undef FIELD2
 536 
 537 #define EMPTY0
 538 #define EMPTY1(x)
 539 #define EMPTY2(x,y)
 540 #define FIELD3(className, name, sig) FIELD2(className, name)
 541 #define FIELD2(className, name) \
 542   jfieldID JNIJVMCI::className::_##name##_field_id = 0; \
 543   int HotSpotJVMCI::className::_##name##_offset = 0;
 544 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
 545 #define CONSTRUCTOR(className, signature)
 546 
 547 // Generates the definitions of static fields used by the accessors. For example:
 548 //  jfieldID JNIJVMCI::Architecture::_wordKind_field_id = 0;
 549 //  jfieldID HotSpotJVMCI::Architecture::_wordKind_offset = 0;
 550 JVMCI_CLASSES_DO(EMPTY2, EMPTY0, FIELD2, FIELD2, FIELD2, FIELD2, FIELD2, FIELD3, FIELD3, FIELD3, FIELD3, FIELD3, FIELD2, FIELD2, METHOD, CONSTRUCTOR)
 551 
 552 #undef START_CLASS
 553 #undef END_CLASS
 554 #undef METHOD
 555 #undef CONSTRUCTOR
 556 #undef FIELD
 557 #undef CHAR_FIELD
 558 #undef INT_FIELD
 559 #undef BOOLEAN_FIELD
 560 #undef LONG_FIELD
 561 #undef FLOAT_FIELD
 562 #undef OBJECT_FIELD
 563 #undef PRIMARRAY_FIELD
 564 #undef OBJECTARRAY_FIELD
 565 #undef STATIC_FIELD
 566 #undef STATIC_OBJECT_FIELD
 567 #undef STATIC_OBJECTARRAY_FIELD
 568 #undef STATIC_INT_FIELD
 569 #undef STATIC_BOOLEAN_FIELD
 570 #undef EMPTY_CAST
 571 
 572 
 573 #define START_CLASS(className, fullClassName)                                                                                     \
 574   void JNIJVMCI::className::initialize(JVMCI_TRAPS) {                                                                             \
 575     /* should already be initialized */                                                                                           \
 576   }                                                                                                                               \
 577   bool JNIJVMCI::className::is_instance(JVMCIEnv* jvmciEnv, JVMCIObject object) {                                                 \
 578     JNIAccessMark jni(jvmciEnv);                                                                                                  \
 579     return jni()-&gt;IsInstanceOf(object.as_jobject(), className::clazz()) != 0;                                                     \
 580   }                                                                                                                               \
 581   void JNIJVMCI::className::check(JVMCIEnv* jvmciEnv, JVMCIObject obj, const char* field_name, jfieldID offset) {                 \
 582     assert(obj.is_non_null(), "NULL field access of %s.%s", #className, field_name);                                     \
 583     assert(jvmciEnv-&gt;isa_##className(obj), "wrong class, " #className " expected, found %s", jvmciEnv-&gt;klass_name(obj)); \
 584     assert(offset != 0, "must be valid offset");                                                                                  \
 585   }                                                                                                                               \
 586   jclass JNIJVMCI::className::_class = NULL;
 587 
 588 #define END_CLASS
 589 
 590 #define FIELD(className, name, type, accessor, cast)                                                                \
 591   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj) {                                       \
 592    className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                                           \
 593    JNIAccessMark jni(jvmciEnv);                               \
 594    return cast jni()-&gt;Get##accessor##Field(resolve_handle(obj), className::_##name##_field_id); \
 595   }                                                                                                                 \
 596   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj, type x) {                               \
 597     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                                          \
 598     JNIAccessMark jni(jvmciEnv); \
 599     jni()-&gt;Set##accessor##Field(resolve_handle(obj), className::_##name##_field_id, x);         \
 600   } \
 601 
 602 #define EMPTY_CAST
 603 #define CHAR_FIELD(className, name)                    FIELD(className, name, jchar, Char, EMPTY_CAST)
 604 #define INT_FIELD(className, name)                     FIELD(className, name, jint, Int, EMPTY_CAST)
 605 #define BOOLEAN_FIELD(className, name)                 FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
 606 #define LONG_FIELD(className, name)                    FIELD(className, name, jlong, Long, EMPTY_CAST)
 607 #define FLOAT_FIELD(className, name)                   FIELD(className, name, jfloat, Float, EMPTY_CAST)
 608 
 609 #define OBJECT_FIELD(className, name, signature)              OOPISH_FIELD(className, name, JVMCIObject, Object, EMPTY_CAST)
 610 #define OBJECTARRAY_FIELD(className, name, signature)         OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
 611 #define PRIMARRAY_FIELD(className, name, signature)           OOPISH_FIELD(className, name, JVMCIPrimitiveArray, Object, (JVMCIPrimitiveArray))
 612 
 613 #define STATIC_OBJECT_FIELD(className, name, signature)       STATIC_OOPISH_FIELD(className, name, JVMCIObject, Object, (JVMCIObject))
 614 #define STATIC_OBJECTARRAY_FIELD(className, name, signature)  STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
 615 
 616 #define OOPISH_FIELD(className, name, type, accessor, cast)                                             \
 617   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj) {                           \
 618     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                              \
 619     JNIAccessMark jni(jvmciEnv);                                                                        \
 620     return cast wrap(jni()-&gt;Get##accessor##Field(resolve_handle(obj), className::_##name##_field_id));  \
 621   }                                                                                                     \
 622   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj, type x) {                   \
 623     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                              \
 624     JNIAccessMark jni(jvmciEnv);                                                                        \
 625     jni()-&gt;Set##accessor##Field(resolve_handle(obj), className::_##name##_field_id, resolve_handle(x)); \
 626   }
 627 
 628 #define STATIC_OOPISH_FIELD(className, name, type, accessor, cast)                                      \
 629   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv) {                                            \
 630     JNIAccessMark jni(jvmciEnv);                                                                        \
 631     return cast wrap(jni()-&gt;GetStatic##accessor##Field(className::clazz(), className::_##name##_field_id));  \
 632   }                                                                                                     \
 633   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, type x) {                                    \
 634     JNIAccessMark jni(jvmciEnv);                                                                        \
 635     jni()-&gt;SetStatic##accessor##Field(className::clazz(), className::_##name##_field_id, resolve_handle(x)); \
 636   }
 637 
 638 #define STATIC_PRIMITIVE_FIELD(className, name, type, accessor, cast)                                   \
 639   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv) {                                            \
 640     JNIAccessMark jni(jvmciEnv);                                                                        \
 641     return cast jni()-&gt;GetStatic##accessor##Field(className::clazz(), className::_##name##_field_id);   \
 642   }                                                                                                     \
 643   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, type x) {                                    \
 644     JNIAccessMark jni(jvmciEnv);                                                                        \
 645     jni()-&gt;SetStatic##accessor##Field(className::clazz(), className::_##name##_field_id, x);            \
 646   }
 647 
 648 #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint, Int, EMPTY_CAST)
 649 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
 650 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \
 651   jmethodID JNIJVMCI::className::_##methodName##_method;
 652 
 653 #define CONSTRUCTOR(className, signature) \
 654   jmethodID JNIJVMCI::className::_constructor;
 655 
 656 /**
 657  * Generates the method definitions for the classes in HotSpotJVMCI.
 658  */
 659 JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
 660 
 661 #undef METHOD
 662 #undef CONSTRUCTOR
 663 #undef START_CLASS
 664 #undef END_CLASS
 665 #undef FIELD
 666 #undef CHAR_FIELD
 667 #undef INT_FIELD
 668 #undef BOOLEAN_FIELD
 669 #undef LONG_FIELD
 670 #undef FLOAT_FIELD
 671 #undef OBJECT_FIELD
 672 #undef PRIMARRAY_FIELD
 673 #undef OBJECTARRAY_FIELD
 674 #undef STATIC_OOPISH_FIELD
 675 #undef STATIC_OBJECT_FIELD
 676 #undef STATIC_OBJECTARRAY_FIELD
 677 #undef STATIC_INT_FIELD
 678 #undef STATIC_BOOLEAN_FIELD
 679 #undef STATIC_PRIMITIVE_FIELD
 680 #undef OOPISH_FIELD
 681 #undef EMPTY_CAST
</pre></body></html>
