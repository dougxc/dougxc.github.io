<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-59942">59942</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8248359">8248359</a>: [JVMCI] miscellaneous code cleanups and improvements
rev <a href="https://bugs.openjdk.java.net/browse/JDK-59943">59943</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8248321">8248321</a>: [JVMCI] improve libgraal logging and fatal error handling</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "classfile/symbolTable.hpp"
  27 #include "compiler/compileBroker.hpp"
<a name="1" id="anc1"></a><span class="new">  28 #include "gc/shared/oopStorage.inline.hpp"</span>
<span class="new">  29 #include "gc/shared/oopStorageSet.hpp"</span>
  30 #include "jvmci/jniAccessMark.inline.hpp"
  31 #include "jvmci/jvmciCompilerToVM.hpp"
  32 #include "jvmci/jvmciRuntime.hpp"
<a name="2" id="anc2"></a><span class="new">  33 #include "jvmci/metadataHandles.hpp"</span>
  34 #include "logging/log.hpp"
  35 #include "memory/oopFactory.hpp"
  36 #include "memory/universe.hpp"
  37 #include "oops/constantPool.inline.hpp"
  38 #include "oops/method.inline.hpp"
  39 #include "oops/objArrayKlass.hpp"
  40 #include "oops/oop.inline.hpp"
<a name="3" id="anc3"></a><span class="new">  41 #include "oops/typeArrayOop.inline.hpp"</span>
  42 #include "runtime/atomic.hpp"
  43 #include "runtime/biasedLocking.hpp"
  44 #include "runtime/deoptimization.hpp"
  45 #include "runtime/fieldDescriptor.inline.hpp"
  46 #include "runtime/frame.inline.hpp"
<a name="4" id="anc4"></a><span class="new">  47 #include "runtime/jniHandles.inline.hpp"</span>
  48 #include "runtime/sharedRuntime.hpp"
  49 #if INCLUDE_G1GC
  50 #include "gc/g1/g1ThreadLocalData.hpp"
  51 #endif // INCLUDE_G1GC
  52 
  53 // Simple helper to see if the caller of a runtime stub which
  54 // entered the VM has been deoptimized
  55 
  56 static bool caller_is_deopted() {
  57   JavaThread* thread = JavaThread::current();
  58   RegisterMap reg_map(thread, false);
  59   frame runtime_frame = thread-&gt;last_frame();
  60   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  61   assert(caller_frame.is_compiled_frame(), "must be compiled");
  62   return caller_frame.is_deoptimized_frame();
  63 }
  64 
  65 // Stress deoptimization
  66 static void deopt_caller() {
  67   if ( !caller_is_deopted()) {
  68     JavaThread* thread = JavaThread::current();
  69     RegisterMap reg_map(thread, false);
  70     frame runtime_frame = thread-&gt;last_frame();
  71     frame caller_frame = runtime_frame.sender(&amp;reg_map);
  72     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
  73     assert(caller_is_deopted(), "Must be deoptimized");
  74   }
  75 }
  76 
  77 // Manages a scope for a JVMCI runtime call that attempts a heap allocation.
  78 // If there is a pending exception upon closing the scope and the runtime
  79 // call is of the variety where allocation failure returns NULL without an
  80 // exception, the following action is taken:
  81 //   1. The pending exception is cleared
  82 //   2. NULL is written to JavaThread::_vm_result
  83 //   3. Checks that an OutOfMemoryError is Universe::out_of_memory_error_retry().
  84 class RetryableAllocationMark: public StackObj {
  85  private:
  86   JavaThread* _thread;
  87  public:
  88   RetryableAllocationMark(JavaThread* thread, bool activate) {
  89     if (activate) {
  90       assert(!thread-&gt;in_retryable_allocation(), "retryable allocation scope is non-reentrant");
  91       _thread = thread;
  92       _thread-&gt;set_in_retryable_allocation(true);
  93     } else {
  94       _thread = NULL;
  95     }
  96   }
  97   ~RetryableAllocationMark() {
  98     if (_thread != NULL) {
  99       _thread-&gt;set_in_retryable_allocation(false);
 100       JavaThread* THREAD = _thread;
 101       if (HAS_PENDING_EXCEPTION) {
 102         oop ex = PENDING_EXCEPTION;
 103         CLEAR_PENDING_EXCEPTION;
 104         oop retry_oome = Universe::out_of_memory_error_retry();
 105         if (ex-&gt;is_a(retry_oome-&gt;klass()) &amp;&amp; retry_oome != ex) {
 106           ResourceMark rm;
 107           fatal("Unexpected exception in scope of retryable allocation: " INTPTR_FORMAT " of type %s", p2i(ex), ex-&gt;klass()-&gt;external_name());
 108         }
 109         _thread-&gt;set_vm_result(NULL);
 110       }
 111     }
 112   }
 113 };
 114 
 115 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail))
 116   JRT_BLOCK;
 117   assert(klass-&gt;is_klass(), "not a class");
 118   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 119   InstanceKlass* h = InstanceKlass::cast(klass);
 120   {
 121     RetryableAllocationMark ram(thread, null_on_fail);
 122     h-&gt;check_valid_for_instantiation(true, CHECK);
 123     oop obj;
 124     if (null_on_fail) {
 125       if (!h-&gt;is_initialized()) {
 126         // Cannot re-execute class initialization without side effects
 127         // so return without attempting the initialization
 128         return;
 129       }
 130     } else {
 131       // make sure klass is initialized
 132       h-&gt;initialize(CHECK);
 133     }
 134     // allocate instance and return via TLS
 135     obj = h-&gt;allocate_instance(CHECK);
 136     thread-&gt;set_vm_result(obj);
 137   }
 138   JRT_BLOCK_END;
 139   SharedRuntime::on_slowpath_allocation_exit(thread);
 140 JRT_END
 141 
 142 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* thread, Klass* array_klass, jint length, bool null_on_fail))
 143   JRT_BLOCK;
 144   // Note: no handle for klass needed since they are not used
 145   //       anymore after new_objArray() and no GC can happen before.
 146   //       (This may have to change if this code changes!)
 147   assert(array_klass-&gt;is_klass(), "not a class");
 148   oop obj;
 149   if (array_klass-&gt;is_typeArray_klass()) {
 150     BasicType elt_type = TypeArrayKlass::cast(array_klass)-&gt;element_type();
 151     RetryableAllocationMark ram(thread, null_on_fail);
 152     obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 153   } else {
 154     Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
 155     Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();
 156     RetryableAllocationMark ram(thread, null_on_fail);
 157     obj = oopFactory::new_objArray(elem_klass, length, CHECK);
 158   }
 159   thread-&gt;set_vm_result(obj);
 160   // This is pretty rare but this runtime patch is stressful to deoptimization
 161   // if we deoptimize here so force a deopt to stress the path.
 162   if (DeoptimizeALot) {
 163     static int deopts = 0;
 164     // Alternate between deoptimizing and raising an error (which will also cause a deopt)
 165     if (deopts++ % 2 == 0) {
 166       if (null_on_fail) {
 167         return;
 168       } else {
 169         ResourceMark rm(THREAD);
 170         THROW(vmSymbols::java_lang_OutOfMemoryError());
 171       }
 172     } else {
 173       deopt_caller();
 174     }
 175   }
 176   JRT_BLOCK_END;
 177   SharedRuntime::on_slowpath_allocation_exit(thread);
 178 JRT_END
 179 
 180 JRT_ENTRY(void, JVMCIRuntime::new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail))
 181   assert(klass-&gt;is_klass(), "not a class");
 182   assert(rank &gt;= 1, "rank must be nonzero");
 183   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 184   RetryableAllocationMark ram(thread, null_on_fail);
 185   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
 186   thread-&gt;set_vm_result(obj);
 187 JRT_END
 188 
 189 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail))
 190   RetryableAllocationMark ram(thread, null_on_fail);
 191   oop obj = Reflection::reflect_new_array(element_mirror, length, CHECK);
 192   thread-&gt;set_vm_result(obj);
 193 JRT_END
 194 
 195 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail))
 196   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(type_mirror));
 197 
 198   if (klass == NULL) {
 199     ResourceMark rm(THREAD);
 200     THROW(vmSymbols::java_lang_InstantiationException());
 201   }
 202   RetryableAllocationMark ram(thread, null_on_fail);
 203 
 204   // Create new instance (the receiver)
 205   klass-&gt;check_valid_for_instantiation(false, CHECK);
 206 
 207   if (null_on_fail) {
 208     if (!klass-&gt;is_initialized()) {
 209       // Cannot re-execute class initialization without side effects
 210       // so return without attempting the initialization
 211       return;
 212     }
 213   } else {
 214     // Make sure klass gets initialized
 215     klass-&gt;initialize(CHECK);
 216   }
 217 
 218   oop obj = klass-&gt;allocate_instance(CHECK);
 219   thread-&gt;set_vm_result(obj);
 220 JRT_END
 221 
 222 extern void vm_exit(int code);
 223 
 224 // Enter this method from compiled code handler below. This is where we transition
 225 // to VM mode. This is done as a helper routine so that the method called directly
 226 // from compiled code does not have to transition to VM. This allows the entry
 227 // method to see if the nmethod that we have just looked up a handler for has
 228 // been deoptimized while we were in the vm. This simplifies the assembly code
 229 // cpu directories.
 230 //
 231 // We are entering here from exception stub (via the entry method below)
 232 // If there is a compiled exception handler in this method, we will continue there;
 233 // otherwise we will unwind the stack and continue at the caller of top frame method
 234 // Note: we enter in Java using a special JRT wrapper. This wrapper allows us to
 235 // control the area where we can allow a safepoint. After we exit the safepoint area we can
 236 // check to see if the handler we are going to return is now in a nmethod that has
 237 // been deoptimized. If that is the case we return the deopt blob
 238 // unpack_with_exception entry instead. This makes life for the exception blob easier
 239 // because making that same check and diverting is painful from assembly language.
 240 JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, CompiledMethod*&amp; cm))
 241   // Reset method handle flag.
 242   thread-&gt;set_is_method_handle_return(false);
 243 
 244   Handle exception(thread, ex);
 245   cm = CodeCache::find_compiled(pc);
 246   assert(cm != NULL, "this is not a compiled method");
 247   // Adjust the pc as needed/
 248   if (cm-&gt;is_deopt_pc(pc)) {
 249     RegisterMap map(thread, false);
 250     frame exception_frame = thread-&gt;last_frame().sender(&amp;map);
 251     // if the frame isn't deopted then pc must not correspond to the caller of last_frame
 252     assert(exception_frame.is_deoptimized_frame(), "must be deopted");
 253     pc = exception_frame.pc();
 254   }
 255 #ifdef ASSERT
 256   assert(exception.not_null(), "NULL exceptions should be handled by throw_exception");
 257   assert(oopDesc::is_oop(exception()), "just checking");
 258   // Check that exception is a subclass of Throwable, otherwise we have a VerifyError
 259   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
 260     if (ExitVMOnVerifyError) vm_exit(-1);
 261     ShouldNotReachHere();
 262   }
 263 #endif
 264 
 265   // Check the stack guard pages and reenable them if necessary and there is
 266   // enough space on the stack to do so.  Use fast exceptions only if the guard
 267   // pages are enabled.
 268   bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
 269   if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
 270 
 271   if (JvmtiExport::can_post_on_exceptions()) {
 272     // To ensure correct notification of exception catches and throws
 273     // we have to deoptimize here.  If we attempted to notify the
 274     // catches and throws during this exception lookup it's possible
 275     // we could deoptimize on the way out of the VM and end back in
 276     // the interpreter at the throw site.  This would result in double
 277     // notifications since the interpreter would also notify about
 278     // these same catches and throws as it unwound the frame.
 279 
 280     RegisterMap reg_map(thread);
 281     frame stub_frame = thread-&gt;last_frame();
 282     frame caller_frame = stub_frame.sender(&amp;reg_map);
 283 
 284     // We don't really want to deoptimize the nmethod itself since we
 285     // can actually continue in the exception handler ourselves but I
 286     // don't see an easy way to have the desired effect.
 287     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
 288     assert(caller_is_deopted(), "Must be deoptimized");
 289 
 290     return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 291   }
 292 
 293   // ExceptionCache is used only for exceptions at call sites and not for implicit exceptions
 294   if (guard_pages_enabled) {
 295     address fast_continuation = cm-&gt;handler_for_exception_and_pc(exception, pc);
 296     if (fast_continuation != NULL) {
 297       // Set flag if return address is a method handle call site.
 298       thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 299       return fast_continuation;
 300     }
 301   }
 302 
 303   // If the stack guard pages are enabled, check whether there is a handler in
 304   // the current method.  Otherwise (guard pages disabled), force an unwind and
 305   // skip the exception cache update (i.e., just leave continuation==NULL).
 306   address continuation = NULL;
 307   if (guard_pages_enabled) {
 308 
 309     // New exception handling mechanism can support inlined methods
 310     // with exception handlers since the mappings are from PC to PC
 311 
 312     // debugging support
 313     // tracing
 314     if (log_is_enabled(Info, exceptions)) {
 315       ResourceMark rm;
 316       stringStream tempst;
 317       assert(cm-&gt;method() != NULL, "Unexpected null method()");
 318       tempst.print("compiled method &lt;%s&gt;\n"
 319                    " at PC" INTPTR_FORMAT " for thread " INTPTR_FORMAT,
 320                    cm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
 321       Exceptions::log_exception(exception, tempst.as_string());
 322     }
 323     // for AbortVMOnException flag
 324     NOT_PRODUCT(Exceptions::debug_check_abort(exception));
 325 
 326     // Clear out the exception oop and pc since looking up an
 327     // exception handler can cause class loading, which might throw an
 328     // exception and those fields are expected to be clear during
 329     // normal bytecode execution.
 330     thread-&gt;clear_exception_oop_and_pc();
 331 
 332     bool recursive_exception = false;
 333     continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);
 334     // If an exception was thrown during exception dispatch, the exception oop may have changed
 335     thread-&gt;set_exception_oop(exception());
 336     thread-&gt;set_exception_pc(pc);
 337 
 338     // The exception cache is used only for non-implicit exceptions
 339     // Update the exception cache only when another exception did
 340     // occur during the computation of the compiled exception handler
 341     // (e.g., when loading the class of the catch type).
 342     // Checking for exception oop equality is not
 343     // sufficient because some exceptions are pre-allocated and reused.
 344     if (continuation != NULL &amp;&amp; !recursive_exception &amp;&amp; !SharedRuntime::deopt_blob()-&gt;contains(continuation)) {
 345       cm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
 346     }
 347   }
 348 
 349   // Set flag if return address is a method handle call site.
 350   thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 351 
 352   if (log_is_enabled(Info, exceptions)) {
 353     ResourceMark rm;
 354     log_info(exceptions)("Thread " PTR_FORMAT " continuing at PC " PTR_FORMAT
 355                          " for exception thrown at PC " PTR_FORMAT,
 356                          p2i(thread), p2i(continuation), p2i(pc));
 357   }
 358 
 359   return continuation;
 360 JRT_END
 361 
 362 // Enter this method from compiled code only if there is a Java exception handler
 363 // in the method handling the exception.
 364 // We are entering here from exception stub. We don't do a normal VM transition here.
 365 // We do it in a helper. This is so we can check to see if the nmethod we have just
 366 // searched for an exception handler has been deoptimized in the meantime.
 367 address JVMCIRuntime::exception_handler_for_pc(JavaThread* thread) {
 368   oop exception = thread-&gt;exception_oop();
 369   address pc = thread-&gt;exception_pc();
 370   // Still in Java mode
 371   DEBUG_ONLY(ResetNoHandleMark rnhm);
 372   CompiledMethod* cm = NULL;
 373   address continuation = NULL;
 374   {
 375     // Enter VM mode by calling the helper
 376     ResetNoHandleMark rnhm;
 377     continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);
 378   }
 379   // Back in JAVA, use no oops DON'T safepoint
 380 
 381   // Now check to see if the compiled method we were called from is now deoptimized.
 382   // If so we must return to the deopt blob and deoptimize the nmethod
 383   if (cm != NULL &amp;&amp; caller_is_deopted()) {
 384     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 385   }
 386 
 387   assert(continuation != NULL, "no handler found");
 388   return continuation;
 389 }
 390 
 391 JRT_BLOCK_ENTRY(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 392   SharedRuntime::monitor_enter_helper(obj, lock, thread);
 393 JRT_END
 394 
 395 JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 396   assert(thread-&gt;last_Java_sp(), "last_Java_sp must be set");
 397   assert(oopDesc::is_oop(obj), "invalid lock object pointer dected");
 398   SharedRuntime::monitor_exit_helper(obj, lock, thread);
 399 JRT_END
 400 
 401 // Object.notify() fast path, caller does slow path
 402 JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *thread, oopDesc* obj))
 403 
 404   // Very few notify/notifyAll operations find any threads on the waitset, so
 405   // the dominant fast-path is to simply return.
 406   // Relatedly, it's critical that notify/notifyAll be fast in order to
 407   // reduce lock hold times.
 408   if (!SafepointSynchronize::is_synchronizing()) {
 409     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 410       return true;
 411     }
 412   }
 413   return false; // caller must perform slow path
 414 
 415 JRT_END
 416 
 417 // Object.notifyAll() fast path, caller does slow path
 418 JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *thread, oopDesc* obj))
 419 
 420   if (!SafepointSynchronize::is_synchronizing() ) {
 421     if (ObjectSynchronizer::quick_notify(obj, thread, true)) {
 422       return true;
 423     }
 424   }
 425   return false; // caller must perform slow path
 426 
 427 JRT_END
 428 
 429 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))
 430   JRT_BLOCK;
 431   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 432   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 433   JRT_BLOCK_END;
 434   return caller_is_deopted();
 435 JRT_END
 436 
 437 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))
 438   JRT_BLOCK;
 439   ResourceMark rm(thread);
 440   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 441   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass-&gt;external_name());
 442   JRT_BLOCK_END;
 443   return caller_is_deopted();
 444 JRT_END
 445 
 446 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))
 447   JRT_BLOCK;
 448   ResourceMark rm(thread);
 449   const char* message = SharedRuntime::generate_class_cast_message(caster_klass, target_klass);
 450   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 451   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 452   JRT_BLOCK_END;
 453   return caller_is_deopted();
 454 JRT_END
 455 
 456 JRT_LEAF(void, JVMCIRuntime::log_object(JavaThread* thread, oopDesc* obj, bool as_string, bool newline))
 457   ttyLocker ttyl;
 458 
 459   if (obj == NULL) {
 460     tty-&gt;print("NULL");
 461   } else if (oopDesc::is_oop_or_null(obj, true) &amp;&amp; (!as_string || !java_lang_String::is_instance(obj))) {
 462     if (oopDesc::is_oop_or_null(obj, true)) {
 463       char buf[O_BUFLEN];
 464       tty-&gt;print("%s@" INTPTR_FORMAT, obj-&gt;klass()-&gt;name()-&gt;as_C_string(buf, O_BUFLEN), p2i(obj));
 465     } else {
 466       tty-&gt;print(INTPTR_FORMAT, p2i(obj));
 467     }
 468   } else {
 469     ResourceMark rm;
 470     assert(obj != NULL &amp;&amp; java_lang_String::is_instance(obj), "must be");
 471     char *buf = java_lang_String::as_utf8_string(obj);
 472     tty-&gt;print_raw(buf);
 473   }
 474   if (newline) {
 475     tty-&gt;cr();
 476   }
 477 JRT_END
 478 
 479 #if INCLUDE_G1GC
 480 
 481 JRT_LEAF(void, JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj))
 482   G1ThreadLocalData::satb_mark_queue(thread).enqueue(obj);
 483 JRT_END
 484 
 485 JRT_LEAF(void, JVMCIRuntime::write_barrier_post(JavaThread* thread, void* card_addr))
 486   G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);
 487 JRT_END
 488 
 489 #endif // INCLUDE_G1GC
 490 
 491 JRT_LEAF(jboolean, JVMCIRuntime::validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child))
 492   bool ret = true;
 493   if(!Universe::heap()-&gt;is_in(parent)) {
 494     tty-&gt;print_cr("Parent Object " INTPTR_FORMAT " not in heap", p2i(parent));
 495     parent-&gt;print();
 496     ret=false;
 497   }
 498   if(!Universe::heap()-&gt;is_in(child)) {
 499     tty-&gt;print_cr("Child Object " INTPTR_FORMAT " not in heap", p2i(child));
 500     child-&gt;print();
 501     ret=false;
 502   }
 503   return (jint)ret;
 504 JRT_END
 505 
 506 JRT_ENTRY(void, JVMCIRuntime::vm_error(JavaThread* thread, jlong where, jlong format, jlong value))
 507   ResourceMark rm;
 508   const char *error_msg = where == 0L ? "&lt;internal JVMCI error&gt;" : (char*) (address) where;
 509   char *detail_msg = NULL;
 510   if (format != 0L) {
 511     const char* buf = (char*) (address) format;
 512     size_t detail_msg_length = strlen(buf) * 2;
 513     detail_msg = (char *) NEW_RESOURCE_ARRAY(u_char, detail_msg_length);
 514     jio_snprintf(detail_msg, detail_msg_length, buf, value);
 515   }
 516   report_vm_error(__FILE__, __LINE__, error_msg, "%s", detail_msg);
 517 JRT_END
 518 
 519 JRT_LEAF(oopDesc*, JVMCIRuntime::load_and_clear_exception(JavaThread* thread))
 520   oop exception = thread-&gt;exception_oop();
 521   assert(exception != NULL, "npe");
 522   thread-&gt;set_exception_oop(NULL);
 523   thread-&gt;set_exception_pc(0);
 524   return exception;
 525 JRT_END
 526 
 527 PRAGMA_DIAG_PUSH
 528 PRAGMA_FORMAT_NONLITERAL_IGNORED
 529 JRT_LEAF(void, JVMCIRuntime::log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3))
 530   ResourceMark rm;
 531   tty-&gt;print(format, v1, v2, v3);
 532 JRT_END
 533 PRAGMA_DIAG_POP
 534 
 535 static void decipher(jlong v, bool ignoreZero) {
 536   if (v != 0 || !ignoreZero) {
 537     void* p = (void *)(address) v;
 538     CodeBlob* cb = CodeCache::find_blob(p);
 539     if (cb) {
 540       if (cb-&gt;is_nmethod()) {
 541         char buf[O_BUFLEN];
 542         tty-&gt;print("%s [" INTPTR_FORMAT "+" JLONG_FORMAT "]", cb-&gt;as_nmethod_or_null()-&gt;method()-&gt;name_and_sig_as_C_string(buf, O_BUFLEN), p2i(cb-&gt;code_begin()), (jlong)((address)v - cb-&gt;code_begin()));
 543         return;
 544       }
 545       cb-&gt;print_value_on(tty);
 546       return;
 547     }
 548     if (Universe::heap()-&gt;is_in(p)) {
 549       oop obj = oop(p);
 550       obj-&gt;print_value_on(tty);
 551       return;
 552     }
 553     tty-&gt;print(INTPTR_FORMAT " [long: " JLONG_FORMAT ", double %lf, char %c]",p2i((void *)v), (jlong)v, (jdouble)v, (char)v);
 554   }
 555 }
 556 
 557 PRAGMA_DIAG_PUSH
 558 PRAGMA_FORMAT_NONLITERAL_IGNORED
 559 JRT_LEAF(void, JVMCIRuntime::vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3))
 560   ResourceMark rm;
 561   const char *buf = (const char*) (address) format;
 562   if (vmError) {
 563     if (buf != NULL) {
 564       fatal(buf, v1, v2, v3);
 565     } else {
 566       fatal("&lt;anonymous error&gt;");
 567     }
 568   } else if (buf != NULL) {
 569     tty-&gt;print(buf, v1, v2, v3);
 570   } else {
 571     assert(v2 == 0, "v2 != 0");
 572     assert(v3 == 0, "v3 != 0");
 573     decipher(v1, false);
 574   }
 575 JRT_END
 576 PRAGMA_DIAG_POP
 577 
 578 JRT_LEAF(void, JVMCIRuntime::log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline))
 579   union {
 580       jlong l;
 581       jdouble d;
 582       jfloat f;
 583   } uu;
 584   uu.l = value;
 585   switch (typeChar) {
 586     case 'Z': tty-&gt;print(value == 0 ? "false" : "true"); break;
 587     case 'B': tty-&gt;print("%d", (jbyte) value); break;
 588     case 'C': tty-&gt;print("%c", (jchar) value); break;
 589     case 'S': tty-&gt;print("%d", (jshort) value); break;
 590     case 'I': tty-&gt;print("%d", (jint) value); break;
 591     case 'F': tty-&gt;print("%f", uu.f); break;
 592     case 'J': tty-&gt;print(JLONG_FORMAT, value); break;
 593     case 'D': tty-&gt;print("%lf", uu.d); break;
 594     default: assert(false, "unknown typeChar"); break;
 595   }
 596   if (newline) {
 597     tty-&gt;cr();
 598   }
 599 JRT_END
 600 
 601 JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))
 602   return (jint) obj-&gt;identity_hash();
 603 JRT_END
 604 
 605 JRT_ENTRY(jint, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))
 606   deopt_caller();
 607   return (jint) value;
 608 JRT_END
 609 
 610 
 611 // private static JVMCIRuntime JVMCI.initializeRuntime()
 612 JVM_ENTRY_NO_ENV(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))
 613   JNI_JVMCIENV(thread, env);
 614   if (!EnableJVMCI) {
 615     JVMCI_THROW_MSG_NULL(InternalError, "JVMCI is not enabled");
 616   }
 617   JVMCIENV-&gt;runtime()-&gt;initialize_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);
 618   JVMCIObject runtime = JVMCIENV-&gt;runtime()-&gt;get_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);
 619   return JVMCIENV-&gt;get_jobject(runtime);
 620 JVM_END
 621 
 622 void JVMCIRuntime::call_getCompiler(TRAPS) {
 623   THREAD_JVMCIENV(JavaThread::current());
 624   JVMCIObject jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_CHECK);
 625   initialize(JVMCIENV);
 626   JVMCIENV-&gt;call_HotSpotJVMCIRuntime_getCompiler(jvmciRuntime, JVMCI_CHECK);
 627 }
 628 
 629 void JVMCINMethodData::initialize(
 630   int nmethod_mirror_index,
 631   const char* name,
 632   FailedSpeculation** failed_speculations)
 633 {
 634   _failed_speculations = failed_speculations;
 635   _nmethod_mirror_index = nmethod_mirror_index;
 636   if (name != NULL) {
 637     _has_name = true;
 638     char* dest = (char*) this-&gt;name();
 639     strcpy(dest, name);
 640   } else {
 641     _has_name = false;
 642   }
 643 }
 644 
 645 void JVMCINMethodData::add_failed_speculation(nmethod* nm, jlong speculation) {
 646   uint index = (speculation &gt;&gt; 32) &amp; 0xFFFFFFFF;
 647   int length = (int) speculation;
 648   if (index + length &gt; (uint) nm-&gt;speculations_size()) {
 649     fatal(INTPTR_FORMAT "[index: %d, length: %d] out of bounds wrt encoded speculations of length %u", speculation, index, length, nm-&gt;speculations_size());
 650   }
 651   address data = nm-&gt;speculations_begin() + index;
 652   FailedSpeculation::add_failed_speculation(nm, _failed_speculations, data, length);
 653 }
 654 
 655 oop JVMCINMethodData::get_nmethod_mirror(nmethod* nm, bool phantom_ref) {
 656   if (_nmethod_mirror_index == -1) {
 657     return NULL;
 658   }
 659   if (phantom_ref) {
 660     return nm-&gt;oop_at_phantom(_nmethod_mirror_index);
 661   } else {
 662     return nm-&gt;oop_at(_nmethod_mirror_index);
 663   }
 664 }
 665 
 666 void JVMCINMethodData::set_nmethod_mirror(nmethod* nm, oop new_mirror) {
 667   assert(_nmethod_mirror_index != -1, "cannot set JVMCI mirror for nmethod");
 668   oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);
 669   assert(new_mirror != NULL, "use clear_nmethod_mirror to clear the mirror");
 670   assert(*addr == NULL, "cannot overwrite non-null mirror");
 671 
 672   *addr = new_mirror;
 673 
 674   // Since we've patched some oops in the nmethod,
 675   // (re)register it with the heap.
 676   Universe::heap()-&gt;register_nmethod(nm);
 677 }
 678 
 679 void JVMCINMethodData::clear_nmethod_mirror(nmethod* nm) {
 680   if (_nmethod_mirror_index != -1) {
 681     oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);
 682     *addr = NULL;
 683   }
 684 }
 685 
 686 void JVMCINMethodData::invalidate_nmethod_mirror(nmethod* nm) {
 687   oop nmethod_mirror = get_nmethod_mirror(nm, /* phantom_ref */ false);
 688   if (nmethod_mirror == NULL) {
 689     return;
 690   }
 691 
 692   // Update the values in the mirror if it still refers to nm.
 693   // We cannot use JVMCIObject to wrap the mirror as this is called
 694   // during GC, forbidding the creation of JNIHandles.
 695   JVMCIEnv* jvmciEnv = NULL;
 696   nmethod* current = (nmethod*) HotSpotJVMCI::InstalledCode::address(jvmciEnv, nmethod_mirror);
 697   if (nm == current) {
 698     if (!nm-&gt;is_alive()) {
 699       // Break the link from the mirror to nm such that
 700       // future invocations via the mirror will result in
 701       // an InvalidInstalledCodeException.
 702       HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, 0);
 703       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 704     } else if (nm-&gt;is_not_entrant()) {
 705       // Zero the entry point so any new invocation will fail but keep
 706       // the address link around that so that existing activations can
 707       // be deoptimized via the mirror (i.e. JVMCIEnv::invalidate_installed_code).
 708       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 709     }
 710   }
 711 }
 712 
<a name="5" id="anc5"></a><span class="new"> 713 JVMCIRuntime::JVMCIRuntime(int id) {</span>
<span class="new"> 714   _init_state = uninitialized;</span>
<span class="new"> 715   _shared_library_javavm = NULL;</span>
<span class="new"> 716   _id = id;</span>
<span class="new"> 717   _metadata_handles = new MetadataHandles();</span>
<span class="new"> 718   JVMCI_event_1("created new JVMCI runtime %d (" PTR_FORMAT ")", id, p2i(this));</span>
<span class="new"> 719 }</span>
<span class="new"> 720 </span>
<span class="new"> 721 // Handles to objects in the Hotspot heap.</span>
<span class="new"> 722 static OopStorage* object_handles() {</span>
<span class="new"> 723   return OopStorageSet::vm_global();</span>
<span class="new"> 724 }</span>
<span class="new"> 725 </span>
<span class="new"> 726 jobject JVMCIRuntime::make_global(const Handle&amp; obj) {</span>
<span class="new"> 727   assert(!Universe::heap()-&gt;is_gc_active(), "can't extend the root set during GC");</span>
<span class="new"> 728   assert(oopDesc::is_oop(obj()), "not an oop");</span>
<span class="new"> 729   oop* ptr = object_handles()-&gt;allocate();</span>
<span class="new"> 730   jobject res = NULL;</span>
<span class="new"> 731   if (ptr != NULL) {</span>
<span class="new"> 732     assert(*ptr == NULL, "invariant");</span>
<span class="new"> 733     NativeAccess&lt;&gt;::oop_store(ptr, obj());</span>
<span class="new"> 734     res = reinterpret_cast&lt;jobject&gt;(ptr);</span>
<span class="new"> 735   } else {</span>
<span class="new"> 736     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,</span>
<span class="new"> 737                           "Cannot create JVMCI oop handle");</span>
<span class="new"> 738   }</span>
<span class="new"> 739   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 740   return res;</span>
<span class="new"> 741 }</span>
<span class="new"> 742 </span>
<span class="new"> 743 void JVMCIRuntime::destroy_global(jobject handle) {</span>
<span class="new"> 744   // Assert before nulling out, for better debugging.</span>
<span class="new"> 745   assert(is_global_handle(handle), "precondition");</span>
<span class="new"> 746   oop* oop_ptr = reinterpret_cast&lt;oop*&gt;(handle);</span>
<span class="new"> 747   NativeAccess&lt;&gt;::oop_store(oop_ptr, (oop)NULL);</span>
<span class="new"> 748   object_handles()-&gt;release(oop_ptr);</span>
<span class="new"> 749   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 750 }</span>
<span class="new"> 751 </span>
<span class="new"> 752 bool JVMCIRuntime::is_global_handle(jobject handle) {</span>
<span class="new"> 753   const oop* ptr = reinterpret_cast&lt;oop*&gt;(handle);</span>
<span class="new"> 754   return object_handles()-&gt;allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;</span>
<span class="new"> 755 }</span>
<span class="new"> 756 </span>
<span class="new"> 757 jmetadata JVMCIRuntime::allocate_handle(const methodHandle&amp; handle) {</span>
<span class="new"> 758   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 759   return _metadata_handles-&gt;allocate_handle(handle);</span>
<span class="new"> 760 }</span>
<span class="new"> 761 </span>
<span class="new"> 762 jmetadata JVMCIRuntime::allocate_handle(const constantPoolHandle&amp; handle) {</span>
<span class="new"> 763   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 764   return _metadata_handles-&gt;allocate_handle(handle);</span>
<span class="new"> 765 }</span>
<span class="new"> 766 </span>
<span class="new"> 767 void JVMCIRuntime::release_handle(jmetadata handle) {</span>
<span class="new"> 768   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 769   _metadata_handles-&gt;chain_free_list(handle);</span>
<span class="new"> 770 }</span>
<span class="new"> 771 </span>
<span class="new"> 772 // Function for redirecting shared library JavaVM output to tty</span>
<span class="new"> 773 static void _log(const char* buf, size_t count) {</span>
<span class="new"> 774   tty-&gt;write((char*) buf, count);</span>
<span class="new"> 775 }</span>
<span class="new"> 776 </span>
<span class="new"> 777 // Function for shared library JavaVM to flush tty</span>
<span class="new"> 778 static void _flush_log() {</span>
<span class="new"> 779   tty-&gt;flush();</span>
<span class="new"> 780 }</span>
<span class="new"> 781 </span>
<span class="new"> 782 // Function for shared library JavaVM to exit HotSpot on a fatal error</span>
<span class="new"> 783 static void _fatal() {</span>
<span class="new"> 784   fatal("Fatal error in JVMCI shared library");</span>
<span class="new"> 785 }</span>
<span class="new"> 786 </span>
<span class="new"> 787 JNIEnv* JVMCIRuntime::init_shared_library_javavm() {</span>
<span class="new"> 788   JavaVM* javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 789   if (javaVM == NULL) {</span>
<span class="new"> 790     MutexLocker locker(JVMCI_lock);</span>
<span class="new"> 791     // Check again under JVMCI_lock</span>
<span class="new"> 792     javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 793     if (javaVM != NULL) {</span>
<span class="new"> 794       return NULL;</span>
<span class="new"> 795     }</span>
<span class="new"> 796     char* sl_path;</span>
<span class="new"> 797     void* sl_handle = JVMCI::get_shared_library(sl_path, true);</span>
<span class="new"> 798 </span>
<span class="new"> 799     jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);</span>
<span class="new"> 800     typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);</span>
<span class="new"> 801 </span>
<span class="new"> 802     JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(sl_handle, "JNI_CreateJavaVM"));</span>
<span class="new"> 803     if (JNI_CreateJavaVM == NULL) {</span>
<span class="new"> 804       vm_exit_during_initialization("Unable to find JNI_CreateJavaVM", sl_path);</span>
<span class="new"> 805     }</span>
<span class="new"> 806 </span>
<span class="new"> 807     ResourceMark rm;</span>
<span class="new"> 808     JavaVMInitArgs vm_args;</span>
<span class="new"> 809     vm_args.version = JNI_VERSION_1_2;</span>
<span class="new"> 810     vm_args.ignoreUnrecognized = JNI_TRUE;</span>
<span class="new"> 811     JavaVMOption options[4];</span>
<span class="new"> 812     jlong javaVM_id = 0;</span>
<span class="new"> 813 </span>
<span class="new"> 814     // Protocol: JVMCI shared library JavaVM should support a non-standard "_javavm_id"</span>
<span class="new"> 815     // option whose extraInfo info field is a pointer to which a unique id for the</span>
<span class="new"> 816     // JavaVM should be written.</span>
<span class="new"> 817     options[0].optionString = (char*) "_javavm_id";</span>
<span class="new"> 818     options[0].extraInfo = &amp;javaVM_id;</span>
<span class="new"> 819 </span>
<span class="new"> 820     options[1].optionString = (char*) "_log";</span>
<span class="new"> 821     options[1].extraInfo = (void*) _log;</span>
<span class="new"> 822     options[2].optionString = (char*) "_flush_log";</span>
<span class="new"> 823     options[2].extraInfo = (void*) _flush_log;</span>
<span class="new"> 824     options[3].optionString = (char*) "_fatal";</span>
<span class="new"> 825     options[3].extraInfo = (void*) _fatal;</span>
<span class="new"> 826 </span>
<span class="new"> 827     vm_args.version = JNI_VERSION_1_2;</span>
<span class="new"> 828     vm_args.options = options;</span>
<span class="new"> 829     vm_args.nOptions = sizeof(options) / sizeof(JavaVMOption);</span>
<span class="new"> 830 </span>
<span class="new"> 831     JNIEnv* env = NULL;</span>
<span class="new"> 832     int result = (*JNI_CreateJavaVM)(&amp;javaVM, (void**) &amp;env, &amp;vm_args);</span>
<span class="new"> 833     if (result == JNI_OK) {</span>
<span class="new"> 834       guarantee(env != NULL, "missing env");</span>
<span class="new"> 835       _shared_library_javavm = javaVM;</span>
<span class="new"> 836       JVMCI_event_1("created JavaVM[%ld]@" PTR_FORMAT " for JVMCI runtime %d", javaVM_id, p2i(javaVM), _id);</span>
<span class="new"> 837       return env;</span>
<span class="new"> 838     } else {</span>
<span class="new"> 839       vm_exit_during_initialization(err_msg("JNI_CreateJavaVM failed with return value %d", result), sl_path);</span>
<span class="new"> 840     }</span>
<span class="new"> 841   }</span>
<span class="new"> 842   return NULL;</span>
<span class="new"> 843 }</span>
<span class="new"> 844 </span>
<span class="new"> 845 void JVMCIRuntime::init_JavaVM_info(jlongArray info, JVMCI_TRAPS) {</span>
<span class="new"> 846   if (info != NULL) {</span>
<span class="new"> 847     typeArrayOop info_oop = (typeArrayOop) JNIHandles::resolve(info);</span>
<span class="new"> 848     if (info_oop-&gt;length() &lt; 4) {</span>
<span class="new"> 849       JVMCI_THROW_MSG(ArrayIndexOutOfBoundsException, err_msg("%d &lt; 4", info_oop-&gt;length()));</span>
<span class="new"> 850     }</span>
<span class="new"> 851     JavaVM* javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 852     info_oop-&gt;long_at_put(0, (jlong) (address) javaVM);</span>
<span class="new"> 853     info_oop-&gt;long_at_put(1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);</span>
<span class="new"> 854     info_oop-&gt;long_at_put(2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);</span>
<span class="new"> 855     info_oop-&gt;long_at_put(3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);</span>
<span class="new"> 856   }</span>
<span class="new"> 857 }</span>
<span class="new"> 858 </span>
<span class="new"> 859 #define JAVAVM_CALL_BLOCK                                             \</span>
<span class="new"> 860   guarantee(thread != NULL &amp;&amp; _shared_library_javavm != NULL, "npe"); \</span>
<span class="new"> 861   ThreadToNativeFromVM ttnfv(thread);                                 \</span>
<span class="new"> 862   JavaVM* javavm = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 863 </span>
<span class="new"> 864 jint JVMCIRuntime::AttachCurrentThread(JavaThread* thread, void **penv, void *args) {</span>
<span class="new"> 865   JAVAVM_CALL_BLOCK</span>
<span class="new"> 866   return javavm-&gt;AttachCurrentThread(penv, args);</span>
<span class="new"> 867 }</span>
<span class="new"> 868 </span>
<span class="new"> 869 jint JVMCIRuntime::AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args) {</span>
<span class="new"> 870   JAVAVM_CALL_BLOCK</span>
<span class="new"> 871   return javavm-&gt;AttachCurrentThreadAsDaemon(penv, args);</span>
<span class="new"> 872 }</span>
<span class="new"> 873 </span>
<span class="new"> 874 jint JVMCIRuntime::DetachCurrentThread(JavaThread* thread) {</span>
<span class="new"> 875   JAVAVM_CALL_BLOCK</span>
<span class="new"> 876   return javavm-&gt;DetachCurrentThread();</span>
<span class="new"> 877 }</span>
<span class="new"> 878 </span>
<span class="new"> 879 jint JVMCIRuntime::GetEnv(JavaThread* thread, void **penv, jint version) {</span>
<span class="new"> 880   JAVAVM_CALL_BLOCK</span>
<span class="new"> 881   return javavm-&gt;GetEnv(penv, version);</span>
<span class="new"> 882 }</span>
<span class="new"> 883 #undef JAVAVM_CALL_BLOCK                                             \</span>
<span class="new"> 884 </span>
 885 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 886   if (is_HotSpotJVMCIRuntime_initialized()) {
 887     if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {
 888       JVMCI_THROW_MSG(InternalError, "JVMCI has already been enabled in the JVMCI shared library");
 889     }
 890   }
 891 
 892   initialize(JVMCIENV);
 893 
 894   // This should only be called in the context of the JVMCI class being initialized
 895   JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
 896 
 897   _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);
<a name="6" id="anc6"></a><span class="new"> 898   JVMCI::_is_initialized = true;</span>
 899 }
 900 
 901 void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {
<a name="7" id="anc7"></a>
 902   // Check first without JVMCI_lock
<a name="8" id="anc8"></a><span class="changed"> 903   if (_init_state == fully_initialized) {</span>
 904     return;
 905   }
 906 
 907   MutexLocker locker(JVMCI_lock);
 908   // Check again under JVMCI_lock
<a name="9" id="anc9"></a><span class="changed"> 909   if (_init_state == fully_initialized) {</span>
 910     return;
 911   }
 912 
<a name="10" id="anc10"></a><span class="changed"> 913   while (_init_state == being_initialized) {</span>
<span class="changed"> 914     JVMCI_event_1("waiting for initialization of JVMCI runtime %d", _id);</span>
 915     JVMCI_lock-&gt;wait();
<a name="11" id="anc11"></a><span class="changed"> 916     if (_init_state == fully_initialized) {</span>
<span class="changed"> 917       JVMCI_event_1("done waiting for initialization of JVMCI runtime %d", _id);</span>
 918       return;
 919     }
 920   }
 921 
<a name="12" id="anc12"></a><span class="changed"> 922   JVMCI_event_1("initializing JVMCI runtime %d", _id);</span>
<span class="changed"> 923   _init_state = being_initialized;</span>
 924 
 925   {
 926     MutexUnlocker unlock(JVMCI_lock);
 927 
 928     HandleMark hm;
 929     ResourceMark rm;
 930     JavaThread* THREAD = JavaThread::current();
 931     if (JVMCIENV-&gt;is_hotspot()) {
 932       HotSpotJVMCI::compute_offsets(CHECK_EXIT);
 933     } else {
 934       JNIAccessMark jni(JVMCIENV);
 935 
 936       JNIJVMCI::initialize_ids(jni.env());
 937       if (jni()-&gt;ExceptionCheck()) {
 938         jni()-&gt;ExceptionDescribe();
 939         fatal("JNI exception during init");
 940       }
 941     }
<a name="13" id="anc13"></a><span class="new"> 942 </span>
<span class="new"> 943     if (!JVMCIENV-&gt;is_hotspot()) {</span>
<span class="new"> 944       JNIAccessMark jni(JVMCIENV, THREAD);</span>
<span class="new"> 945       JNIJVMCI::register_natives(jni.env());</span>
<span class="new"> 946     }</span>
 947     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));
 948     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));
 949     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));
 950     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));
 951     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));
 952     create_jvmci_primitive_type(T_LONG, JVMCI_CHECK_EXIT_((void)0));
 953     create_jvmci_primitive_type(T_FLOAT, JVMCI_CHECK_EXIT_((void)0));
 954     create_jvmci_primitive_type(T_DOUBLE, JVMCI_CHECK_EXIT_((void)0));
 955     create_jvmci_primitive_type(T_VOID, JVMCI_CHECK_EXIT_((void)0));
 956 
 957     if (!JVMCIENV-&gt;is_hotspot()) {
 958       JVMCIENV-&gt;copy_saved_properties();
 959     }
 960   }
 961 
<a name="14" id="anc14"></a><span class="changed"> 962   _init_state = fully_initialized;</span>
<span class="changed"> 963   JVMCI_event_1("initialized JVMCI runtime %d", _id);</span>
 964   JVMCI_lock-&gt;notify_all();
 965 }
 966 
 967 JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
 968   Thread* THREAD = Thread::current();
 969   // These primitive types are long lived and are created before the runtime is fully set up
 970   // so skip registering them for scanning.
 971   JVMCIObject mirror = JVMCIENV-&gt;get_object_constant(java_lang_Class::primitive_mirror(type), false, true);
 972   if (JVMCIENV-&gt;is_hotspot()) {
 973     JavaValue result(T_OBJECT);
 974     JavaCallArguments args;
 975     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(mirror)));
 976     args.push_int(type2char(type));
 977     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedPrimitiveType::klass(), vmSymbols::fromMetaspace_name(), vmSymbols::primitive_fromMetaspace_signature(), &amp;args, CHECK_(JVMCIObject()));
 978 
 979     return JVMCIENV-&gt;wrap(JNIHandles::make_local((oop)result.get_jobject()));
 980   } else {
 981     JNIAccessMark jni(JVMCIENV);
 982     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedPrimitiveType::clazz(),
 983                                            JNIJVMCI::HotSpotResolvedPrimitiveType_fromMetaspace_method(),
 984                                            mirror.as_jobject(), type2char(type));
 985     if (jni()-&gt;ExceptionCheck()) {
 986       return JVMCIObject();
 987     }
 988     return JVMCIENV-&gt;wrap(result);
 989   }
 990 }
 991 
 992 void JVMCIRuntime::initialize_JVMCI(JVMCI_TRAPS) {
 993   if (!is_HotSpotJVMCIRuntime_initialized()) {
 994     initialize(JVMCI_CHECK);
 995     JVMCIENV-&gt;call_JVMCI_getRuntime(JVMCI_CHECK);
 996   }
 997 }
 998 
 999 JVMCIObject JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
1000   initialize(JVMCIENV);
1001   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
1002   return _HotSpotJVMCIRuntime_instance;
1003 }
1004 
<a name="15" id="anc15"></a><span class="changed">1005 // private static void CompilerToVM.registerNatives()</span>

1006 JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
1007   JNI_JVMCIENV(thread, env);
1008 
1009   if (!EnableJVMCI) {
1010     JVMCI_THROW_MSG(InternalError, "JVMCI is not enabled");
1011   }
1012 
1013   JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
1014 
1015   {
1016     ResourceMark rm;
1017     HandleMark hm(thread);
1018     ThreadToNativeFromVM trans(thread);
1019 
1020     // Ensure _non_oop_bits is initialized
1021     Universe::non_oop_word();
1022 
1023     if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count())) {
1024       if (!env-&gt;ExceptionCheck()) {
1025         for (int i = 0; i &lt; CompilerToVM::methods_count(); i++) {
1026           if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods + i, 1)) {
1027             guarantee(false, "Error registering JNI method %s%s", CompilerToVM::methods[i].name, CompilerToVM::methods[i].signature);
1028             break;
1029           }
1030         }
1031       } else {
1032         env-&gt;ExceptionDescribe();
1033       }
1034       guarantee(false, "Failed registering CompilerToVM native methods");
1035     }
1036   }
1037 JVM_END
1038 
1039 
1040 void JVMCIRuntime::shutdown() {
<a name="16" id="anc16"></a><span class="changed">1041   JVMCIObject instance = _HotSpotJVMCIRuntime_instance;</span>
<span class="changed">1042   if (instance.is_non_null()) {</span>
<span class="changed">1043     JVMCI_event_1("shutting down JVMCI runtime %d", _id);</span>
<span class="changed">1044     _HotSpotJVMCIRuntime_instance = JVMCIObject();</span>
<span class="changed">1045     JVMCIEnv __stack_jvmci_env__(JavaThread::current(), instance.is_hotspot(), __FILE__, __LINE__);</span>
<span class="changed">1046     JVMCIEnv* JVMCIENV = &amp;__stack_jvmci_env__;</span>
<span class="changed">1047     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(instance);</span>
<span class="changed">1048     JVMCI_event_1("shut down JVMCI runtime %d", _id);</span>
1049   }
1050 }
1051 
1052 void JVMCIRuntime::bootstrap_finished(TRAPS) {
<a name="17" id="anc17"></a><span class="changed">1053   if (_HotSpotJVMCIRuntime_instance.is_non_null()) {</span>
1054     THREAD_JVMCIENV(JavaThread::current());
1055     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
1056   }
1057 }
1058 
1059 void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {
1060   if (HAS_PENDING_EXCEPTION) {
1061     Handle exception(THREAD, PENDING_EXCEPTION);
1062     const char* exception_file = THREAD-&gt;exception_file();
1063     int exception_line = THREAD-&gt;exception_line();
1064     CLEAR_PENDING_EXCEPTION;
1065     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
1066       // Don't print anything if we are being killed.
1067     } else {
1068       java_lang_Throwable::print_stack_trace(exception, tty);
1069 
1070       // Clear and ignore any exceptions raised during printing
1071       CLEAR_PENDING_EXCEPTION;
1072     }
1073     if (!clear) {
1074       THREAD-&gt;set_pending_exception(exception(), exception_file, exception_line);
1075     }
1076   }
1077 }
1078 
1079 
1080 void JVMCIRuntime::exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message) {
1081   JavaThread* THREAD = JavaThread::current();
1082 
1083   static volatile int report_error = 0;
1084   if (!report_error &amp;&amp; Atomic::cmpxchg(&amp;report_error, 0, 1) == 0) {
1085     // Only report an error once
1086     tty-&gt;print_raw_cr(message);
1087     if (JVMCIENV != NULL) {
1088       JVMCIENV-&gt;describe_pending_exception(true);
1089     } else {
1090       describe_pending_hotspot_exception(THREAD, true);
1091     }
1092   } else {
1093     // Allow error reporting thread to print the stack trace.
1094     THREAD-&gt;sleep(200);
1095   }
1096 
1097   before_exit(THREAD);
1098   vm_exit(-1);
1099 }
1100 
1101 // ------------------------------------------------------------------
1102 // Note: the logic of this method should mirror the logic of
1103 // constantPoolOopDesc::verify_constant_pool_resolve.
1104 bool JVMCIRuntime::check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass) {
1105   if (accessing_klass-&gt;is_objArray_klass()) {
1106     accessing_klass = ObjArrayKlass::cast(accessing_klass)-&gt;bottom_klass();
1107   }
1108   if (!accessing_klass-&gt;is_instance_klass()) {
1109     return true;
1110   }
1111 
1112   if (resolved_klass-&gt;is_objArray_klass()) {
1113     // Find the element klass, if this is an array.
1114     resolved_klass = ObjArrayKlass::cast(resolved_klass)-&gt;bottom_klass();
1115   }
1116   if (resolved_klass-&gt;is_instance_klass()) {
1117     Reflection::VerifyClassAccessResults result =
1118       Reflection::verify_class_access(accessing_klass, InstanceKlass::cast(resolved_klass), true);
1119     return result == Reflection::ACCESS_OK;
1120   }
1121   return true;
1122 }
1123 
1124 // ------------------------------------------------------------------
1125 Klass* JVMCIRuntime::get_klass_by_name_impl(Klass*&amp; accessing_klass,
1126                                           const constantPoolHandle&amp; cpool,
1127                                           Symbol* sym,
1128                                           bool require_local) {
1129   JVMCI_EXCEPTION_CONTEXT;
1130 
1131   // Now we need to check the SystemDictionary
1132   if (sym-&gt;char_at(0) == JVM_SIGNATURE_CLASS &amp;&amp;
1133       sym-&gt;char_at(sym-&gt;utf8_length()-1) == JVM_SIGNATURE_ENDCLASS) {
1134     // This is a name from a signature.  Strip off the trimmings.
1135     // Call recursive to keep scope of strippedsym.
1136     TempNewSymbol strippedsym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
1137                                                         sym-&gt;utf8_length()-2);
1138     return get_klass_by_name_impl(accessing_klass, cpool, strippedsym, require_local);
1139   }
1140 
1141   Handle loader(THREAD, (oop)NULL);
1142   Handle domain(THREAD, (oop)NULL);
1143   if (accessing_klass != NULL) {
1144     loader = Handle(THREAD, accessing_klass-&gt;class_loader());
1145     domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
1146   }
1147 
1148   Klass* found_klass;
1149   {
1150     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems
1151     MutexLocker ml(Compile_lock);
1152     if (!require_local) {
1153       found_klass = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, CHECK_NULL);
1154     } else {
1155       found_klass = SystemDictionary::find_instance_or_array_klass(sym, loader, domain, CHECK_NULL);
1156     }
1157   }
1158 
1159   // If we fail to find an array klass, look again for its element type.
1160   // The element type may be available either locally or via constraints.
1161   // In either case, if we can find the element type in the system dictionary,
1162   // we must build an array type around it.  The CI requires array klasses
1163   // to be loaded if their element klasses are loaded, except when memory
1164   // is exhausted.
1165   if (sym-&gt;char_at(0) == JVM_SIGNATURE_ARRAY &amp;&amp;
1166       (sym-&gt;char_at(1) == JVM_SIGNATURE_ARRAY || sym-&gt;char_at(1) == JVM_SIGNATURE_CLASS)) {
1167     // We have an unloaded array.
1168     // Build it on the fly if the element class exists.
1169     TempNewSymbol elem_sym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
1170                                                      sym-&gt;utf8_length()-1);
1171 
1172     // Get element Klass recursively.
1173     Klass* elem_klass =
1174       get_klass_by_name_impl(accessing_klass,
1175                              cpool,
1176                              elem_sym,
1177                              require_local);
1178     if (elem_klass != NULL) {
1179       // Now make an array for it
1180       return elem_klass-&gt;array_klass(THREAD);
1181     }
1182   }
1183 
1184   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {
1185     // Look inside the constant pool for pre-resolved class entries.
1186     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {
1187       if (cpool-&gt;tag_at(i).is_klass()) {
1188         Klass*  kls = cpool-&gt;resolved_klass_at(i);
1189         if (kls-&gt;name() == sym) {
1190           return kls;
1191         }
1192       }
1193     }
1194   }
1195 
1196   return found_klass;
1197 }
1198 
1199 // ------------------------------------------------------------------
1200 Klass* JVMCIRuntime::get_klass_by_name(Klass* accessing_klass,
1201                                   Symbol* klass_name,
1202                                   bool require_local) {
1203   ResourceMark rm;
1204   constantPoolHandle cpool;
1205   return get_klass_by_name_impl(accessing_klass,
1206                                                  cpool,
1207                                                  klass_name,
1208                                                  require_local);
1209 }
1210 
1211 // ------------------------------------------------------------------
1212 // Implementation of get_klass_by_index.
1213 Klass* JVMCIRuntime::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
1214                                         int index,
1215                                         bool&amp; is_accessible,
1216                                         Klass* accessor) {
1217   JVMCI_EXCEPTION_CONTEXT;
1218   Klass* klass = ConstantPool::klass_at_if_loaded(cpool, index);
1219   Symbol* klass_name = NULL;
1220   if (klass == NULL) {
1221     klass_name = cpool-&gt;klass_name_at(index);
1222   }
1223 
1224   if (klass == NULL) {
1225     // Not found in constant pool.  Use the name to do the lookup.
1226     Klass* k = get_klass_by_name_impl(accessor,
1227                                         cpool,
1228                                         klass_name,
1229                                         false);
1230     // Calculate accessibility the hard way.
1231     if (k == NULL) {
1232       is_accessible = false;
1233     } else if (k-&gt;class_loader() != accessor-&gt;class_loader() &amp;&amp;
1234                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {
1235       // Loaded only remotely.  Not linked yet.
1236       is_accessible = false;
1237     } else {
1238       // Linked locally, and we must also check public/private, etc.
1239       is_accessible = check_klass_accessibility(accessor, k);
1240     }
1241     if (!is_accessible) {
1242       return NULL;
1243     }
1244     return k;
1245   }
1246 
1247   // It is known to be accessible, since it was found in the constant pool.
1248   is_accessible = true;
1249   return klass;
1250 }
1251 
1252 // ------------------------------------------------------------------
1253 // Get a klass from the constant pool.
1254 Klass* JVMCIRuntime::get_klass_by_index(const constantPoolHandle&amp; cpool,
1255                                    int index,
1256                                    bool&amp; is_accessible,
1257                                    Klass* accessor) {
1258   ResourceMark rm;
1259   Klass* result = get_klass_by_index_impl(cpool, index, is_accessible, accessor);
1260   return result;
1261 }
1262 
1263 // ------------------------------------------------------------------
1264 // Implementation of get_field_by_index.
1265 //
1266 // Implementation note: the results of field lookups are cached
1267 // in the accessor klass.
1268 void JVMCIRuntime::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor&amp; field_desc,
1269                                         int index) {
1270   JVMCI_EXCEPTION_CONTEXT;
1271 
1272   assert(klass-&gt;is_linked(), "must be linked before using its constant-pool");
1273 
1274   constantPoolHandle cpool(thread, klass-&gt;constants());
1275 
1276   // Get the field's name, signature, and type.
1277   Symbol* name  = cpool-&gt;name_ref_at(index);
1278 
1279   int nt_index = cpool-&gt;name_and_type_ref_index_at(index);
1280   int sig_index = cpool-&gt;signature_ref_index_at(nt_index);
1281   Symbol* signature = cpool-&gt;symbol_at(sig_index);
1282 
1283   // Get the field's declared holder.
1284   int holder_index = cpool-&gt;klass_ref_index_at(index);
1285   bool holder_is_accessible;
1286   Klass* declared_holder = get_klass_by_index(cpool, holder_index,
1287                                                holder_is_accessible,
1288                                                klass);
1289 
1290   // The declared holder of this field may not have been loaded.
1291   // Bail out with partial field information.
1292   if (!holder_is_accessible) {
1293     return;
1294   }
1295 
1296 
1297   // Perform the field lookup.
1298   Klass*  canonical_holder =
1299     InstanceKlass::cast(declared_holder)-&gt;find_field(name, signature, &amp;field_desc);
1300   if (canonical_holder == NULL) {
1301     return;
1302   }
1303 
1304   assert(canonical_holder == field_desc.field_holder(), "just checking");
1305 }
1306 
1307 // ------------------------------------------------------------------
1308 // Get a field by index from a klass's constant pool.
1309 void JVMCIRuntime::get_field_by_index(InstanceKlass* accessor, fieldDescriptor&amp; fd, int index) {
1310   ResourceMark rm;
1311   return get_field_by_index_impl(accessor, fd, index);
1312 }
1313 
1314 // ------------------------------------------------------------------
1315 // Perform an appropriate method lookup based on accessor, holder,
1316 // name, signature, and bytecode.
1317 Method* JVMCIRuntime::lookup_method(InstanceKlass* accessor,
1318                                     Klass*        holder,
1319                                     Symbol*       name,
1320                                     Symbol*       sig,
1321                                     Bytecodes::Code bc,
1322                                     constantTag   tag) {
1323   // Accessibility checks are performed in JVMCIEnv::get_method_by_index_impl().
1324   assert(check_klass_accessibility(accessor, holder), "holder not accessible");
1325 
1326   Method* dest_method;
1327   LinkInfo link_info(holder, name, sig, accessor, LinkInfo::needs_access_check, tag);
1328   switch (bc) {
1329   case Bytecodes::_invokestatic:
1330     dest_method =
1331       LinkResolver::resolve_static_call_or_null(link_info);
1332     break;
1333   case Bytecodes::_invokespecial:
1334     dest_method =
1335       LinkResolver::resolve_special_call_or_null(link_info);
1336     break;
1337   case Bytecodes::_invokeinterface:
1338     dest_method =
1339       LinkResolver::linktime_resolve_interface_method_or_null(link_info);
1340     break;
1341   case Bytecodes::_invokevirtual:
1342     dest_method =
1343       LinkResolver::linktime_resolve_virtual_method_or_null(link_info);
1344     break;
1345   default: ShouldNotReachHere();
1346   }
1347 
1348   return dest_method;
1349 }
1350 
1351 
1352 // ------------------------------------------------------------------
1353 Method* JVMCIRuntime::get_method_by_index_impl(const constantPoolHandle&amp; cpool,
1354                                                int index, Bytecodes::Code bc,
1355                                                InstanceKlass* accessor) {
1356   if (bc == Bytecodes::_invokedynamic) {
1357     ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);
1358     bool is_resolved = !cpce-&gt;is_f1_null();
1359     if (is_resolved) {
1360       // Get the invoker Method* from the constant pool.
1361       // (The appendix argument, if any, will be noted in the method's signature.)
1362       Method* adapter = cpce-&gt;f1_as_method();
1363       return adapter;
1364     }
1365 
1366     return NULL;
1367   }
1368 
1369   int holder_index = cpool-&gt;klass_ref_index_at(index);
1370   bool holder_is_accessible;
1371   Klass* holder = get_klass_by_index_impl(cpool, holder_index, holder_is_accessible, accessor);
1372 
1373   // Get the method's name and signature.
1374   Symbol* name_sym = cpool-&gt;name_ref_at(index);
1375   Symbol* sig_sym  = cpool-&gt;signature_ref_at(index);
1376 
1377   if (cpool-&gt;has_preresolution()
1378       || ((holder == SystemDictionary::MethodHandle_klass() || holder == SystemDictionary::VarHandle_klass()) &amp;&amp;
1379           MethodHandles::is_signature_polymorphic_name(holder, name_sym))) {
1380     // Short-circuit lookups for JSR 292-related call sites.
1381     // That is, do not rely only on name-based lookups, because they may fail
1382     // if the names are not resolvable in the boot class loader (7056328).
1383     switch (bc) {
1384     case Bytecodes::_invokevirtual:
1385     case Bytecodes::_invokeinterface:
1386     case Bytecodes::_invokespecial:
1387     case Bytecodes::_invokestatic:
1388       {
1389         Method* m = ConstantPool::method_at_if_loaded(cpool, index);
1390         if (m != NULL) {
1391           return m;
1392         }
1393       }
1394       break;
1395     default:
1396       break;
1397     }
1398   }
1399 
1400   if (holder_is_accessible) { // Our declared holder is loaded.
1401     constantTag tag = cpool-&gt;tag_ref_at(index);
1402     Method* m = lookup_method(accessor, holder, name_sym, sig_sym, bc, tag);
1403     if (m != NULL) {
1404       // We found the method.
1405       return m;
1406     }
1407   }
1408 
1409   // Either the declared holder was not loaded, or the method could
1410   // not be found.
1411 
1412   return NULL;
1413 }
1414 
1415 // ------------------------------------------------------------------
1416 InstanceKlass* JVMCIRuntime::get_instance_klass_for_declared_method_holder(Klass* method_holder) {
1417   // For the case of &lt;array&gt;.clone(), the method holder can be an ArrayKlass*
1418   // instead of an InstanceKlass*.  For that case simply pretend that the
1419   // declared holder is Object.clone since that's where the call will bottom out.
1420   if (method_holder-&gt;is_instance_klass()) {
1421     return InstanceKlass::cast(method_holder);
1422   } else if (method_holder-&gt;is_array_klass()) {
1423     return SystemDictionary::Object_klass();
1424   } else {
1425     ShouldNotReachHere();
1426   }
1427   return NULL;
1428 }
1429 
1430 
1431 // ------------------------------------------------------------------
1432 Method* JVMCIRuntime::get_method_by_index(const constantPoolHandle&amp; cpool,
1433                                      int index, Bytecodes::Code bc,
1434                                      InstanceKlass* accessor) {
1435   ResourceMark rm;
1436   return get_method_by_index_impl(cpool, index, bc, accessor);
1437 }
1438 
1439 // ------------------------------------------------------------------
1440 // Check for changes to the system dictionary during compilation
1441 // class loads, evolution, breakpoints
1442 JVMCI::CodeInstallResult JVMCIRuntime::validate_compile_task_dependencies(Dependencies* dependencies, JVMCICompileState* compile_state, char** failure_detail) {
1443   // If JVMTI capabilities were enabled during compile, the compilation is invalidated.
1444   if (compile_state != NULL &amp;&amp; compile_state-&gt;jvmti_state_changed()) {
1445     *failure_detail = (char*) "Jvmti state change during compilation invalidated dependencies";
1446     return JVMCI::dependencies_failed;
1447   }
1448 
1449   CompileTask* task = compile_state == NULL ? NULL : compile_state-&gt;task();
1450   Dependencies::DepType result = dependencies-&gt;validate_dependencies(task, failure_detail);
1451   if (result == Dependencies::end_marker) {
1452     return JVMCI::ok;
1453   }
1454 
1455   return JVMCI::dependencies_failed;
1456 }
1457 
1458 // Reports a pending exception and exits the VM.
1459 static void fatal_exception_in_compile(JVMCIEnv* JVMCIENV, JavaThread* thread, const char* msg) {
1460   // Only report a fatal JVMCI compilation exception once
1461   static volatile int report_init_failure = 0;
1462   if (!report_init_failure &amp;&amp; Atomic::cmpxchg(&amp;report_init_failure, 0, 1) == 0) {
1463       tty-&gt;print_cr("%s:", msg);
1464       JVMCIENV-&gt;describe_pending_exception(true);
1465   }
1466   JVMCIENV-&gt;clear_pending_exception();
1467   before_exit(thread);
1468   vm_exit(-1);
1469 }
1470 
1471 void JVMCIRuntime::compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; method, int entry_bci) {
1472   JVMCI_EXCEPTION_CONTEXT
1473 
1474   JVMCICompileState* compile_state = JVMCIENV-&gt;compile_state();
1475 
1476   bool is_osr = entry_bci != InvocationEntryBci;
1477   if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {
1478     // no OSR compilations during bootstrap - the compiler is just too slow at this point,
1479     // and we know that there are no endless loops
<a name="18" id="anc18"></a><span class="changed">1480     compile_state-&gt;set_failure(true, "No OSR during bootstrap");</span>
1481     return;
1482   }
<a name="19" id="anc19"></a><span class="changed">1483   if (JVMCI::in_shutdown()) {</span>
1484     compile_state-&gt;set_failure(false, "Avoiding compilation during shutdown");
1485     return;
1486   }
1487 
1488   HandleMark hm;
1489   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);
1490   if (JVMCIENV-&gt;has_pending_exception()) {
1491     fatal_exception_in_compile(JVMCIENV, thread, "Exception during HotSpotJVMCIRuntime initialization");
1492   }
1493   JVMCIObject jvmci_method = JVMCIENV-&gt;get_jvmci_method(method, JVMCIENV);
1494   if (JVMCIENV-&gt;has_pending_exception()) {
1495     JVMCIENV-&gt;describe_pending_exception(true);
1496     compile_state-&gt;set_failure(false, "exception getting JVMCI wrapper method");
1497     return;
1498   }
1499 
1500   JVMCIObject result_object = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_compileMethod(receiver, jvmci_method, entry_bci,
1501                                                                      (jlong) compile_state, compile_state-&gt;task()-&gt;compile_id());
1502   if (!JVMCIENV-&gt;has_pending_exception()) {
1503     if (result_object.is_non_null()) {
1504       JVMCIObject failure_message = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_failureMessage(result_object);
1505       if (failure_message.is_non_null()) {
1506         // Copy failure reason into resource memory first ...
1507         const char* failure_reason = JVMCIENV-&gt;as_utf8_string(failure_message);
1508         // ... and then into the C heap.
1509         failure_reason = os::strdup(failure_reason, mtJVMCI);
1510         bool retryable = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_retry(result_object) != 0;
1511         compile_state-&gt;set_failure(retryable, failure_reason, true);
1512       } else {
1513         if (compile_state-&gt;task()-&gt;code() == NULL) {
1514           compile_state-&gt;set_failure(true, "no nmethod produced");
1515         } else {
1516           compile_state-&gt;task()-&gt;set_num_inlined_bytecodes(JVMCIENV-&gt;get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));
1517           compiler-&gt;inc_methods_compiled();
1518         }
1519       }
1520     } else {
1521       assert(false, "JVMCICompiler.compileMethod should always return non-null");
1522     }
1523   } else {
1524     // An uncaught exception here implies failure during compiler initialization.
1525     // The only sensible thing to do here is to exit the VM.
1526     fatal_exception_in_compile(JVMCIENV, thread, "Exception during JVMCI compiler initialization");
1527   }
1528   if (compiler-&gt;is_bootstrapping()) {
1529     compiler-&gt;set_bootstrap_compilation_request_handled();
1530   }
1531 }
1532 
1533 
1534 // ------------------------------------------------------------------
1535 JVMCI::CodeInstallResult JVMCIRuntime::register_method(JVMCIEnv* JVMCIENV,
1536                                 const methodHandle&amp; method,
1537                                 nmethod*&amp; nm,
1538                                 int entry_bci,
1539                                 CodeOffsets* offsets,
1540                                 int orig_pc_offset,
1541                                 CodeBuffer* code_buffer,
1542                                 int frame_words,
1543                                 OopMapSet* oop_map_set,
1544                                 ExceptionHandlerTable* handler_table,
1545                                 ImplicitExceptionTable* implicit_exception_table,
1546                                 AbstractCompiler* compiler,
1547                                 DebugInformationRecorder* debug_info,
1548                                 Dependencies* dependencies,
1549                                 int compile_id,
1550                                 bool has_unsafe_access,
1551                                 bool has_wide_vector,
1552                                 JVMCIObject compiled_code,
1553                                 JVMCIObject nmethod_mirror,
1554                                 FailedSpeculation** failed_speculations,
1555                                 char* speculations,
1556                                 int speculations_len) {
1557   JVMCI_EXCEPTION_CONTEXT;
1558   nm = NULL;
1559   int comp_level = CompLevel_full_optimization;
1560   char* failure_detail = NULL;
1561 
1562   bool install_default = JVMCIENV-&gt;get_HotSpotNmethod_isDefault(nmethod_mirror) != 0;
1563   assert(JVMCIENV-&gt;isa_HotSpotNmethod(nmethod_mirror), "must be");
1564   JVMCIObject name = JVMCIENV-&gt;get_InstalledCode_name(nmethod_mirror);
1565   const char* nmethod_mirror_name = name.is_null() ? NULL : JVMCIENV-&gt;as_utf8_string(name);
1566   int nmethod_mirror_index;
1567   if (!install_default) {
1568     // Reserve or initialize mirror slot in the oops table.
1569     OopRecorder* oop_recorder = debug_info-&gt;oop_recorder();
1570     nmethod_mirror_index = oop_recorder-&gt;allocate_oop_index(nmethod_mirror.is_hotspot() ? nmethod_mirror.as_jobject() : NULL);
1571   } else {
1572     // A default HotSpotNmethod mirror is never tracked by the nmethod
1573     nmethod_mirror_index = -1;
1574   }
1575 
1576   JVMCI::CodeInstallResult result;
1577   {
1578     // To prevent compile queue updates.
1579     MutexLocker locker(THREAD, MethodCompileQueue_lock);
1580 
1581     // Prevent SystemDictionary::add_to_hierarchy from running
1582     // and invalidating our dependencies until we install this method.
1583     MutexLocker ml(Compile_lock);
1584 
1585     // Encode the dependencies now, so we can check them right away.
1586     dependencies-&gt;encode_content_bytes();
1587 
1588     // Record the dependencies for the current compile in the log
1589     if (LogCompilation) {
1590       for (Dependencies::DepStream deps(dependencies); deps.next(); ) {
1591         deps.log_dependency();
1592       }
1593     }
1594 
1595     // Check for {class loads, evolution, breakpoints} during compilation
1596     result = validate_compile_task_dependencies(dependencies, JVMCIENV-&gt;compile_state(), &amp;failure_detail);
1597     if (result != JVMCI::ok) {
1598       // While not a true deoptimization, it is a preemptive decompile.
1599       MethodData* mdp = method()-&gt;method_data();
1600       if (mdp != NULL) {
1601         mdp-&gt;inc_decompile_count();
1602 #ifdef ASSERT
1603         if (mdp-&gt;decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
1604           ResourceMark m;
1605           tty-&gt;print_cr("WARN: endless recompilation of %s. Method was set to not compilable.", method()-&gt;name_and_sig_as_C_string());
1606         }
1607 #endif
1608       }
1609 
1610       // All buffers in the CodeBuffer are allocated in the CodeCache.
1611       // If the code buffer is created on each compile attempt
1612       // as in C2, then it must be freed.
1613       //code_buffer-&gt;free_blob();
1614     } else {
1615       nm =  nmethod::new_nmethod(method,
1616                                  compile_id,
1617                                  entry_bci,
1618                                  offsets,
1619                                  orig_pc_offset,
1620                                  debug_info, dependencies, code_buffer,
1621                                  frame_words, oop_map_set,
1622                                  handler_table, implicit_exception_table,
1623                                  compiler, comp_level,
1624                                  speculations, speculations_len,
1625                                  nmethod_mirror_index, nmethod_mirror_name, failed_speculations);
1626 
1627 
1628       // Free codeBlobs
1629       if (nm == NULL) {
1630         // The CodeCache is full.  Print out warning and disable compilation.
1631         {
1632           MutexUnlocker ml(Compile_lock);
1633           MutexUnlocker locker(MethodCompileQueue_lock);
1634           CompileBroker::handle_full_code_cache(CodeCache::get_code_blob_type(comp_level));
1635         }
1636       } else {
1637         nm-&gt;set_has_unsafe_access(has_unsafe_access);
1638         nm-&gt;set_has_wide_vectors(has_wide_vector);
1639 
1640         // Record successful registration.
1641         // (Put nm into the task handle *before* publishing to the Java heap.)
1642         if (JVMCIENV-&gt;compile_state() != NULL) {
1643           JVMCIENV-&gt;compile_state()-&gt;task()-&gt;set_code(nm);
1644         }
1645 
1646         JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
1647         assert(data != NULL, "must be");
1648         if (install_default) {
1649           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == NULL, "must be");
1650           if (entry_bci == InvocationEntryBci) {
1651             if (TieredCompilation) {
1652               // If there is an old version we're done with it
1653               CompiledMethod* old = method-&gt;code();
1654               if (TraceMethodReplacement &amp;&amp; old != NULL) {
1655                 ResourceMark rm;
1656                 char *method_name = method-&gt;name_and_sig_as_C_string();
1657                 tty-&gt;print_cr("Replacing method %s", method_name);
1658               }
1659               if (old != NULL ) {
1660                 old-&gt;make_not_entrant();
1661               }
1662             }
1663 
1664             LogTarget(Info, nmethod, install) lt;
1665             if (lt.is_enabled()) {
1666               ResourceMark rm;
1667               char *method_name = method-&gt;name_and_sig_as_C_string();
1668               lt.print("Installing method (%d) %s [entry point: %p]",
1669                         comp_level, method_name, nm-&gt;entry_point());
1670             }
1671             // Allow the code to be executed
1672             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1673             if (nm-&gt;make_in_use()) {
1674               method-&gt;set_code(method, nm);
1675             }
1676           } else {
1677             LogTarget(Info, nmethod, install) lt;
1678             if (lt.is_enabled()) {
1679               ResourceMark rm;
1680               char *method_name = method-&gt;name_and_sig_as_C_string();
1681               lt.print("Installing osr method (%d) %s @ %d",
1682                         comp_level, method_name, entry_bci);
1683             }
1684             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1685             if (nm-&gt;make_in_use()) {
1686               InstanceKlass::cast(method-&gt;method_holder())-&gt;add_osr_nmethod(nm);
1687             }
1688           }
1689         } else {
1690           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == HotSpotJVMCI::resolve(nmethod_mirror), "must be");
1691         }
1692       }
1693       result = nm != NULL ? JVMCI::ok :JVMCI::cache_full;
1694     }
1695   }
1696 
1697   // String creation must be done outside lock
1698   if (failure_detail != NULL) {
1699     // A failure to allocate the string is silently ignored.
1700     JVMCIObject message = JVMCIENV-&gt;create_string(failure_detail, JVMCIENV);
1701     JVMCIENV-&gt;set_HotSpotCompiledNmethod_installationFailureMessage(compiled_code, message);
1702   }
1703 
1704   // JVMTI -- compiled method notification (must be done outside lock)
1705   if (nm != NULL) {
1706     nm-&gt;post_compiled_method_load_event();
1707   }
1708 
1709   return result;
1710 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="20" type="hidden" /></form></body></html>
