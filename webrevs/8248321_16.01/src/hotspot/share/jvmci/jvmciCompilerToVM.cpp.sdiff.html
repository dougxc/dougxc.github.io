<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>open Sdiff src/hotspot/share/jvmci </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/hotspot/share/jvmci/jvmciCompiler.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/jvmci/jvmciEnv.cpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-59942">59942</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8248359">8248359</a>: [JVMCI] miscellaneous code cleanups and improvements
rev <a href="https://bugs.openjdk.java.net/browse/JDK-59943">59943</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8248321">8248321</a>: [JVMCI] improve libgraal logging and fatal error handling</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  86     thread-&gt;set_active_handles(compile_handles);
  87   }
  88 }
  89 
  90 void JNIHandleMark::pop_jni_handle_block(JavaThread* thread) {
  91   if (thread != NULL) {
  92     // Release our JNI handle block
  93     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  94     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  95     thread-&gt;set_active_handles(java_handles);
  96     compile_handles-&gt;set_pop_frame_link(NULL);
  97     JNIHandleBlock::release_block(compile_handles, thread); // may block
  98   }
  99 }
 100 
 101 class JVMCITraceMark : public StackObj {
 102   const char* _msg;
 103  public:
 104   JVMCITraceMark(const char* msg) {
 105     _msg = msg;
<span class="changed"> 106     if (JVMCITraceLevel &gt;= 1) {</span>
<span class="changed"> 107       tty-&gt;print_cr(PTR_FORMAT " JVMCITrace-1: Enter %s", p2i(JavaThread::current()), _msg);</span>
<span class="changed"> 108     }</span>
 109   }
 110   ~JVMCITraceMark() {
<span class="changed"> 111     if (JVMCITraceLevel &gt;= 1) {</span>
<span class="changed"> 112       tty-&gt;print_cr(PTR_FORMAT " JVMCITrace-1: Exit %s", p2i(JavaThread::current()), _msg);</span>
<span class="changed"> 113     }</span>
 114   }
 115 };
 116 
 117 
 118 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 119   assert(_index &lt; _args-&gt;length(), "out of bounds");
 120   oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
 121   assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), "arg type mismatch");
 122   return Handle(Thread::current(), arg);
 123 }
 124 
 125 // Bring the JVMCI compiler thread into the VM state.
 126 #define JVMCI_VM_ENTRY_MARK                   \
 127   ThreadInVMfromNative __tiv(thread);         \
 128   ResetNoHandleMark rnhm;                     \
 129   HandleMarkCleaner __hm(thread);             \
 130   Thread* THREAD = thread;                    \
 131   debug_only(VMNativeEntryWrapper __vew;)
 132 
 133 // Native method block that transitions current thread to '_thread_in_vm'.
 134 #define C2V_BLOCK(result_type, name, signature)      \
 135   TRACE_CALL(result_type, jvmci_ ## name signature)  \
 136   JVMCI_VM_ENTRY_MARK;                               \
 137   ResourceMark rm;                                   \
 138   JNI_JVMCIENV(thread, env);
 139 
<span class="changed"> 140 static Thread* get_current_thread() {</span>
<span class="changed"> 141   return Thread::current_or_null_safe();</span>






 142 }
 143 
 144 // Entry to native method implementation that transitions
 145 // current thread to '_thread_in_vm'.
 146 #define C2V_VMENTRY(result_type, name, signature)        \
 147   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="changed"> 148   Thread* base_thread = get_current_thread();            \</span>
<span class="changed"> 149   if (base_thread == NULL) {                             \</span>
 150     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 151         err_msg("Cannot call into HotSpot from JVMCI shared library without attaching current thread")); \
 152     return;                                              \
 153   }                                                      \
<span class="removed"> 154   assert(base_thread-&gt;is_Java_thread(), "just checking");\</span>
<span class="removed"> 155   JavaThread* thread = (JavaThread*) base_thread;        \</span>
 156   JVMCITraceMark jtm("CompilerToVM::" #name);            \
 157   C2V_BLOCK(result_type, name, signature)
 158 
 159 #define C2V_VMENTRY_(result_type, name, signature, result) \
 160   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="changed"> 161   Thread* base_thread = get_current_thread();            \</span>
<span class="changed"> 162   if (base_thread == NULL) {                             \</span>
 163     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 164         err_msg("Cannot call into HotSpot from JVMCI shared library without attaching current thread")); \
 165     return result;                                       \
 166   }                                                      \
<span class="removed"> 167   assert(base_thread-&gt;is_Java_thread(), "just checking");\</span>
<span class="removed"> 168   JavaThread* thread = (JavaThread*) base_thread;        \</span>
 169   JVMCITraceMark jtm("CompilerToVM::" #name);            \
 170   C2V_BLOCK(result_type, name, signature)
 171 
 172 #define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)
 173 #define C2V_VMENTRY_0(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, 0)
 174 
 175 // Entry to native method implementation that does not transition
 176 // current thread to '_thread_in_vm'.
 177 #define C2V_VMENTRY_PREFIX(result_type, name, signature) \
 178   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="changed"> 179   Thread* base_thread = get_current_thread();</span>
 180 
 181 #define C2V_END }
 182 
 183 #define JNI_THROW(caller, name, msg) do {                                         \
 184     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 185     if (__throw_res != JNI_OK) {                                                  \
 186       tty-&gt;print_cr("Throwing " #name " in " caller " returned %d", __throw_res); \
 187     }                                                                             \
 188     return;                                                                       \
 189   } while (0);
 190 
 191 #define JNI_THROW_(caller, name, msg, result) do {                                \
 192     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 193     if (__throw_res != JNI_OK) {                                                  \
 194       tty-&gt;print_cr("Throwing " #name " in " caller " returned %d", __throw_res); \
 195     }                                                                             \
 196     return result;                                                                \
 197   } while (0)
 198 
 199 jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS);

</pre><hr></hr><pre>
1562   // all locals are materialized by now
1563   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);
1564   // update the locals array
1565   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);
1566   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1567   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1568     StackValue* var = locals-&gt;at(i);
1569     if (var-&gt;type() == T_OBJECT) {
1570       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));
1571     }
1572   }
1573   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);
1574 C2V_END
1575 
1576 // Creates a scope where the current thread is attached and detached
1577 // from HotSpot if it wasn't already attached when entering the scope.
1578 extern "C" void jio_printf(const char *fmt, ...);
1579 class AttachDetach : public StackObj {
1580  public:
1581   bool _attached;
<span class="changed">1582   AttachDetach(JNIEnv* env, Thread* current_thread) {</span>
1583     if (current_thread == NULL) {
1584       extern struct JavaVM_ main_vm;
1585       JNIEnv* hotspotEnv;
1586       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
1587       _attached = res == JNI_OK;
1588       static volatile int report_attach_error = 0;
1589       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_attach_error, 0, 1) == 0) {
1590         // Only report an attach error once
1591         jio_printf("Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n", res);
1592       }
1593     } else {
1594       _attached = false;
1595     }
1596   }
1597   ~AttachDetach() {
1598     if (_attached &amp;&amp; get_current_thread() != NULL) {
1599       extern struct JavaVM_ main_vm;
1600       jint res = main_vm.DetachCurrentThread();
1601       static volatile int report_detach_error = 0;
1602       if (res != JNI_OK &amp;&amp; report_detach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_detach_error, 0, 1) == 0) {
1603         // Only report an attach error once
1604         jio_printf("Warning: detaching current thread from VM failed with %d (future attach errors are suppressed)\n", res);
1605       }
1606     }
1607   }
1608 };
1609 
1610 C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))
<span class="changed">1611   AttachDetach ad(env, base_thread);</span>
1612   bool use_tty = true;
<span class="changed">1613   if (base_thread == NULL) {</span>
1614     if (!ad._attached) {
1615       // Can only use tty if the current thread is attached

1616       return 0;
1617     }
<span class="changed">1618     base_thread = get_current_thread();</span>
1619   }
1620   JVMCITraceMark jtm("writeDebugOutput");
<span class="removed">1621   assert(base_thread-&gt;is_Java_thread(), "just checking");</span>
<span class="removed">1622   JavaThread* thread = (JavaThread*) base_thread;</span>
1623   C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))
1624   if (bytes == NULL) {
1625     if (can_throw) {
1626       JVMCI_THROW_0(NullPointerException);
1627     }
1628     return -1;
1629   }
1630   JVMCIPrimitiveArray array = JVMCIENV-&gt;wrap(bytes);
1631 
1632   // Check if offset and length are non negative.
1633   if (offset &lt; 0 || length &lt; 0) {
1634     if (can_throw) {
1635       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1636     }
1637     return -2;
1638   }
1639   // Check if the range is valid.
1640   int array_length = JVMCIENV-&gt;get_length(array);
1641   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array_length)) {
1642     if (can_throw) {

</pre><hr></hr><pre>
2212   if (x == NULL) {
2213     JVMCI_THROW_0(NullPointerException);
2214   }
2215   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2216   return xobj-&gt;long_field(displacement);
2217 }
2218 
2219 C2V_VMENTRY_NULL(jobject, getObject, (JNIEnv* env, jobject, jobject x, long displacement))
2220   if (x == NULL) {
2221     JVMCI_THROW_0(NullPointerException);
2222   }
2223   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2224   oop res = xobj-&gt;obj_field(displacement);
2225   JVMCIObject result = JVMCIENV-&gt;get_object_constant(res);
2226   return JVMCIENV-&gt;get_jobject(result);
2227 }
2228 
2229 C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))
2230   jobject handle = (jobject)(address)h;
2231   if (handle != NULL) {
<span class="changed">2232     JVMCI::destroy_global(handle);</span>
2233   }
2234 }
2235 
2236 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {
2237   if (!UseJVMCINativeLibrary) {
2238     JVMCI_THROW_MSG(UnsupportedOperationException, "JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)");
2239   }
2240 }
2241 
<span class="removed">2242 static JavaVM* requireNativeLibraryJavaVM(const char* caller, JVMCI_TRAPS) {</span>
<span class="removed">2243   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();</span>
<span class="removed">2244   if (javaVM == NULL) {</span>
<span class="removed">2245     JVMCI_THROW_MSG_NULL(IllegalStateException, err_msg("Require JVMCI shared library to be initialized in %s", caller));</span>
<span class="removed">2246   }</span>
<span class="removed">2247   return javaVM;</span>
<span class="removed">2248 }</span>
<span class="removed">2249 </span>
2250 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))
2251   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2252   requireInHotSpot("registerNativeMethods", JVMCI_CHECK_NULL);
<span class="changed">2253   void* shared_library = JVMCIEnv::get_shared_library_handle();</span>
<span class="changed">2254   if (shared_library == NULL) {</span>


2255     // Ensure the JVMCI shared library runtime is initialized.
2256     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
2257     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2258     HandleMark hm;
<span class="removed">2259     JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
2260     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);
2261     if (peerEnv-&gt;has_pending_exception()) {
2262       peerEnv-&gt;describe_pending_exception(true);
2263     }
<span class="changed">2264     shared_library = JVMCIEnv::get_shared_library_handle();</span>
<span class="changed">2265     if (shared_library == NULL) {</span>
<span class="changed">2266       JVMCI_THROW_MSG_0(InternalError, "Error initializing JVMCI runtime");</span>
2267     }
2268   }
2269 
2270   if (mirror == NULL) {
2271     JVMCI_THROW_0(NullPointerException);
2272   }
2273   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2274   if (klass == NULL || !klass-&gt;is_instance_klass()) {
2275     JVMCI_THROW_MSG_0(IllegalArgumentException, "clazz is for primitive type");
2276   }
2277 
2278   InstanceKlass* iklass = InstanceKlass::cast(klass);
2279   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
2280     methodHandle method(THREAD, iklass-&gt;methods()-&gt;at(i));
2281     if (method-&gt;is_native()) {
2282 
2283       // Compute argument size
2284       int args_size = 1                             // JNIEnv
2285                     + (method-&gt;is_static() ? 1 : 0) // class for static methods
2286                     + method-&gt;size_of_parameters(); // actual parameters
2287 
2288       // 1) Try JNI short style
2289       stringStream st;
2290       char* pure_name = NativeLookup::pure_jni_name(method);
2291       os::print_jni_name_prefix_on(&amp;st, args_size);
2292       st.print_raw(pure_name);
2293       os::print_jni_name_suffix_on(&amp;st, args_size);
2294       char* jni_name = st.as_string();
2295 
<span class="changed">2296       address entry = (address) os::dll_lookup(shared_library, jni_name);</span>
2297       if (entry == NULL) {
2298         // 2) Try JNI long style
2299         st.reset();
2300         char* long_name = NativeLookup::long_jni_name(method);
2301         os::print_jni_name_prefix_on(&amp;st, args_size);
2302         st.print_raw(pure_name);
2303         st.print_raw(long_name);
2304         os::print_jni_name_suffix_on(&amp;st, args_size);
2305         char* jni_long_name = st.as_string();
<span class="changed">2306         entry = (address) os::dll_lookup(shared_library, jni_long_name);</span>
2307         if (entry == NULL) {
2308           JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg("%s [neither %s nor %s exist in %s]",
2309               method-&gt;name_and_sig_as_C_string(),
<span class="changed">2310               jni_name, jni_long_name, JVMCIEnv::get_shared_library_path()));</span>
2311         }
2312       }
2313 
2314       if (method-&gt;has_native_function() &amp;&amp; entry != method-&gt;native_function()) {
2315         JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg("%s [cannot re-link from " PTR_FORMAT " to " PTR_FORMAT "]",
2316             method-&gt;name_and_sig_as_C_string(), p2i(method-&gt;native_function()), p2i(entry)));
2317       }
2318       method-&gt;set_native_function(entry, Method::native_bind_event_is_interesting);
<span class="changed">2319       log_debug(jni, resolve)("[Dynamic-linking native method %s.%s ... JNI]",</span>
2320                               method-&gt;method_holder()-&gt;external_name(),
<span class="changed">2321                               method-&gt;name()-&gt;as_C_string());</span>

2322     }
2323   }
2324 
<span class="changed">2325   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();</span>
<span class="changed">2326   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(4, JVMCI_CHECK_NULL);</span>
<span class="changed">2327   JVMCIENV-&gt;put_long_at(result, 0, (jlong) (address) javaVM);</span>
<span class="changed">2328   JVMCIENV-&gt;put_long_at(result, 1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);</span>
<span class="changed">2329   JVMCIENV-&gt;put_long_at(result, 2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);</span>
<span class="changed">2330   JVMCIENV-&gt;put_long_at(result, 3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);</span>
<span class="changed">2331   return (jlongArray) JVMCIENV-&gt;get_jobject(result);</span>
2332 }
2333 
2334 C2V_VMENTRY_PREFIX(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject c2vm))
<span class="changed">2335   if (base_thread == NULL) {</span>
2336     // Called from unattached JVMCI shared library thread
2337     return false;
2338   }
2339   JVMCITraceMark jtm("isCurrentThreadAttached");
<span class="removed">2340   assert(base_thread-&gt;is_Java_thread(), "just checking");</span>
<span class="removed">2341   JavaThread* thread = (JavaThread*) base_thread;</span>
2342   if (thread-&gt;jni_environment() == env) {
2343     C2V_BLOCK(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject))
2344     requireJVMCINativeLibrary(JVMCI_CHECK_0);
<span class="changed">2345     JavaVM* javaVM = requireNativeLibraryJavaVM("isCurrentThreadAttached", JVMCI_CHECK_0);</span>



2346     JNIEnv* peerEnv;
<span class="changed">2347     return javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK;</span>
2348   }
2349   return true;
2350 C2V_END
2351 
2352 C2V_VMENTRY_PREFIX(jlong, getCurrentJavaThread, (JNIEnv* env, jobject c2vm))
<span class="changed">2353   if (base_thread == NULL) {</span>
2354     // Called from unattached JVMCI shared library thread
2355     return 0L;
2356   }
2357   JVMCITraceMark jtm("getCurrentJavaThread");
<span class="changed">2358   assert(base_thread-&gt;is_Java_thread(), "just checking");</span>
<span class="changed">2359   return (jlong) p2i(base_thread);</span>
2360 C2V_END
2361 
2362 C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean as_daemon))
<span class="changed">2363   if (base_thread == NULL) {</span>
2364     // Called from unattached JVMCI shared library thread
2365     extern struct JavaVM_ main_vm;
2366     JNIEnv* hotspotEnv;
<span class="changed">2367     jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**)&amp;hotspotEnv, NULL) :</span>
<span class="changed">2368                            main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);</span>
2369     if (res != JNI_OK) {
2370       JNI_THROW_("attachCurrentThread", InternalError, err_msg("Trying to attach thread returned %d", res), false);
2371     }
2372     return true;
2373   }
2374   JVMCITraceMark jtm("attachCurrentThread");
<span class="removed">2375   assert(base_thread-&gt;is_Java_thread(), "just checking");\</span>
<span class="removed">2376   JavaThread* thread = (JavaThread*) base_thread;</span>
2377   if (thread-&gt;jni_environment() == env) {
2378     // Called from HotSpot
2379     C2V_BLOCK(jboolean, attachCurrentThread, (JNIEnv* env, jobject, jboolean))
2380     requireJVMCINativeLibrary(JVMCI_CHECK_0);
<span class="changed">2381     JavaVM* javaVM = requireNativeLibraryJavaVM("attachCurrentThread", JVMCI_CHECK_0);</span>




2382     JavaVMAttachArgs attach_args;
2383     attach_args.version = JNI_VERSION_1_2;
2384     attach_args.name = thread-&gt;name();
2385     attach_args.group = NULL;
<span class="changed">2386     JNIEnv* peerEnv;</span>
<span class="changed">2387     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK) {</span>
2388       return false;
2389     }
<span class="changed">2390     jint res = as_daemon ? javaVM-&gt;AttachCurrentThreadAsDaemon((void**)&amp;peerEnv, &amp;attach_args) :</span>
<span class="changed">2391                            javaVM-&gt;AttachCurrentThread((void**)&amp;peerEnv, &amp;attach_args);</span>

2392     if (res == JNI_OK) {
<span class="changed">2393       guarantee(peerEnv != NULL, "must be");</span>

2394       return true;
2395     }
2396     JVMCI_THROW_MSG_0(InternalError, err_msg("Error %d while attaching %s", res, attach_args.name));
2397   }
2398   // Called from JVMCI shared library
2399   return false;
2400 C2V_END
2401 
2402 C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))
<span class="changed">2403   if (base_thread == NULL) {</span>
2404     // Called from unattached JVMCI shared library thread
<span class="changed">2405     JNI_THROW("detachCurrentThread", IllegalStateException, err_msg("Cannot detach non-attached thread"));</span>
2406   }
2407   JVMCITraceMark jtm("detachCurrentThread");
<span class="removed">2408   assert(base_thread-&gt;is_Java_thread(), "just checking");\</span>
<span class="removed">2409   JavaThread* thread = (JavaThread*) base_thread;</span>
2410   if (thread-&gt;jni_environment() == env) {
2411     // Called from HotSpot
2412     C2V_BLOCK(void, detachCurrentThread, (JNIEnv* env, jobject))
2413     requireJVMCINativeLibrary(JVMCI_CHECK);
2414     requireInHotSpot("detachCurrentThread", JVMCI_CHECK);
<span class="changed">2415     JavaVM* javaVM = requireNativeLibraryJavaVM("detachCurrentThread", JVMCI_CHECK);</span>
<span class="changed">2416     JNIEnv* peerEnv;</span>
<span class="changed">2417     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) != JNI_OK) {</span>



2418       JVMCI_THROW_MSG(IllegalStateException, err_msg("Cannot detach non-attached thread: %s", thread-&gt;name()));
2419     }
<span class="changed">2420     jint res = javaVM-&gt;DetachCurrentThread();</span>
2421     if (res != JNI_OK) {
2422       JVMCI_THROW_MSG(InternalError, err_msg("Error %d while attaching %s", res, thread-&gt;name()));
2423     }
2424   } else {
2425     // Called from attached JVMCI shared library thread
2426     extern struct JavaVM_ main_vm;
2427     jint res = main_vm.DetachCurrentThread();
2428     if (res != JNI_OK) {
<span class="changed">2429       JNI_THROW("detachCurrentThread", InternalError, err_msg("Cannot detach non-attached thread"));</span>
2430     }
2431   }
2432 C2V_END
2433 
2434 C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))
2435   requireJVMCINativeLibrary(JVMCI_CHECK_0);
2436   if (obj_handle == NULL) {
2437     return 0L;
2438   }
2439   JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV-&gt;is_hotspot(), __FILE__, __LINE__);
2440   JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2441   JVMCIEnv* thisEnv = JVMCIENV;
2442 
2443   JVMCIObject obj = thisEnv-&gt;wrap(obj_handle);
2444   JVMCIObject result;
2445   if (thisEnv-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {
2446     methodHandle method(THREAD, thisEnv-&gt;asMethod(obj));
2447     result = peerEnv-&gt;get_jvmci_method(method, JVMCI_CHECK_0);
2448   } else if (thisEnv-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {
2449     Klass* klass = thisEnv-&gt;asKlass(obj);

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
  86     thread-&gt;set_active_handles(compile_handles);
  87   }
  88 }
  89 
  90 void JNIHandleMark::pop_jni_handle_block(JavaThread* thread) {
  91   if (thread != NULL) {
  92     // Release our JNI handle block
  93     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  94     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  95     thread-&gt;set_active_handles(java_handles);
  96     compile_handles-&gt;set_pop_frame_link(NULL);
  97     JNIHandleBlock::release_block(compile_handles, thread); // may block
  98   }
  99 }
 100 
 101 class JVMCITraceMark : public StackObj {
 102   const char* _msg;
 103  public:
 104   JVMCITraceMark(const char* msg) {
 105     _msg = msg;
<span class="changed"> 106     JVMCI_event_2("Enter %s", _msg);</span>


 107   }
 108   ~JVMCITraceMark() {
<span class="changed"> 109     JVMCI_event_2(" Exit %s", _msg);</span>


 110   }
 111 };
 112 
 113 
 114 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 115   assert(_index &lt; _args-&gt;length(), "out of bounds");
 116   oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
 117   assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), "arg type mismatch");
 118   return Handle(Thread::current(), arg);
 119 }
 120 
 121 // Bring the JVMCI compiler thread into the VM state.
 122 #define JVMCI_VM_ENTRY_MARK                   \
 123   ThreadInVMfromNative __tiv(thread);         \
 124   ResetNoHandleMark rnhm;                     \
 125   HandleMarkCleaner __hm(thread);             \
 126   Thread* THREAD = thread;                    \
 127   debug_only(VMNativeEntryWrapper __vew;)
 128 
 129 // Native method block that transitions current thread to '_thread_in_vm'.
 130 #define C2V_BLOCK(result_type, name, signature)      \
 131   TRACE_CALL(result_type, jvmci_ ## name signature)  \
 132   JVMCI_VM_ENTRY_MARK;                               \
 133   ResourceMark rm;                                   \
 134   JNI_JVMCIENV(thread, env);
 135 
<span class="changed"> 136 static JavaThread* get_current_thread(bool allow_null=true) {</span>
<span class="changed"> 137   Thread* thread = Thread::current_or_null_safe();</span>
<span class="changed"> 138   if (thread == NULL) {</span>
<span class="changed"> 139     assert(allow_null, "npe");</span>
<span class="changed"> 140     return NULL;</span>
<span class="changed"> 141   }</span>
<span class="changed"> 142   assert(thread-&gt;is_Java_thread(), "must be");</span>
<span class="changed"> 143   return (JavaThread*) thread;</span>
 144 }
 145 
 146 // Entry to native method implementation that transitions
 147 // current thread to '_thread_in_vm'.
 148 #define C2V_VMENTRY(result_type, name, signature)        \
 149   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="changed"> 150   JavaThread* thread = get_current_thread();             \</span>
<span class="changed"> 151   if (thread == NULL) {                                  \</span>
 152     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 153         err_msg("Cannot call into HotSpot from JVMCI shared library without attaching current thread")); \
 154     return;                                              \
 155   }                                                      \


 156   JVMCITraceMark jtm("CompilerToVM::" #name);            \
 157   C2V_BLOCK(result_type, name, signature)
 158 
 159 #define C2V_VMENTRY_(result_type, name, signature, result) \
 160   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="changed"> 161   JavaThread* thread = get_current_thread();             \</span>
<span class="changed"> 162   if (thread == NULL) {                                  \</span>
 163     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 164         err_msg("Cannot call into HotSpot from JVMCI shared library without attaching current thread")); \
 165     return result;                                       \
 166   }                                                      \


 167   JVMCITraceMark jtm("CompilerToVM::" #name);            \
 168   C2V_BLOCK(result_type, name, signature)
 169 
 170 #define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)
 171 #define C2V_VMENTRY_0(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, 0)
 172 
 173 // Entry to native method implementation that does not transition
 174 // current thread to '_thread_in_vm'.
 175 #define C2V_VMENTRY_PREFIX(result_type, name, signature) \
 176   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="changed"> 177   JavaThread* thread = get_current_thread();</span>
 178 
 179 #define C2V_END }
 180 
 181 #define JNI_THROW(caller, name, msg) do {                                         \
 182     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 183     if (__throw_res != JNI_OK) {                                                  \
 184       tty-&gt;print_cr("Throwing " #name " in " caller " returned %d", __throw_res); \
 185     }                                                                             \
 186     return;                                                                       \
 187   } while (0);
 188 
 189 #define JNI_THROW_(caller, name, msg, result) do {                                \
 190     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 191     if (__throw_res != JNI_OK) {                                                  \
 192       tty-&gt;print_cr("Throwing " #name " in " caller " returned %d", __throw_res); \
 193     }                                                                             \
 194     return result;                                                                \
 195   } while (0)
 196 
 197 jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS);

</pre><hr></hr><pre>
1560   // all locals are materialized by now
1561   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);
1562   // update the locals array
1563   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);
1564   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1565   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1566     StackValue* var = locals-&gt;at(i);
1567     if (var-&gt;type() == T_OBJECT) {
1568       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));
1569     }
1570   }
1571   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);
1572 C2V_END
1573 
1574 // Creates a scope where the current thread is attached and detached
1575 // from HotSpot if it wasn't already attached when entering the scope.
1576 extern "C" void jio_printf(const char *fmt, ...);
1577 class AttachDetach : public StackObj {
1578  public:
1579   bool _attached;
<span class="changed">1580   AttachDetach(JNIEnv* env, JavaThread* current_thread) {</span>
1581     if (current_thread == NULL) {
1582       extern struct JavaVM_ main_vm;
1583       JNIEnv* hotspotEnv;
1584       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
1585       _attached = res == JNI_OK;
1586       static volatile int report_attach_error = 0;
1587       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_attach_error, 0, 1) == 0) {
1588         // Only report an attach error once
1589         jio_printf("Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n", res);
1590       }
1591     } else {
1592       _attached = false;
1593     }
1594   }
1595   ~AttachDetach() {
1596     if (_attached &amp;&amp; get_current_thread() != NULL) {
1597       extern struct JavaVM_ main_vm;
1598       jint res = main_vm.DetachCurrentThread();
1599       static volatile int report_detach_error = 0;
1600       if (res != JNI_OK &amp;&amp; report_detach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_detach_error, 0, 1) == 0) {
1601         // Only report an attach error once
1602         jio_printf("Warning: detaching current thread from VM failed with %d (future attach errors are suppressed)\n", res);
1603       }
1604     }
1605   }
1606 };
1607 
1608 C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))
<span class="changed">1609   AttachDetach ad(env, thread);</span>
1610   bool use_tty = true;
<span class="changed">1611   if (thread == NULL) {</span>
1612     if (!ad._attached) {
1613       // Can only use tty if the current thread is attached
<span class="new">1614       JVMCI_event_1("Cannot write to tty on unattached thread");</span>
1615       return 0;
1616     }
<span class="changed">1617     thread = get_current_thread();</span>
1618   }
1619   JVMCITraceMark jtm("writeDebugOutput");


1620   C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))
1621   if (bytes == NULL) {
1622     if (can_throw) {
1623       JVMCI_THROW_0(NullPointerException);
1624     }
1625     return -1;
1626   }
1627   JVMCIPrimitiveArray array = JVMCIENV-&gt;wrap(bytes);
1628 
1629   // Check if offset and length are non negative.
1630   if (offset &lt; 0 || length &lt; 0) {
1631     if (can_throw) {
1632       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1633     }
1634     return -2;
1635   }
1636   // Check if the range is valid.
1637   int array_length = JVMCIENV-&gt;get_length(array);
1638   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array_length)) {
1639     if (can_throw) {

</pre><hr></hr><pre>
2209   if (x == NULL) {
2210     JVMCI_THROW_0(NullPointerException);
2211   }
2212   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2213   return xobj-&gt;long_field(displacement);
2214 }
2215 
2216 C2V_VMENTRY_NULL(jobject, getObject, (JNIEnv* env, jobject, jobject x, long displacement))
2217   if (x == NULL) {
2218     JVMCI_THROW_0(NullPointerException);
2219   }
2220   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2221   oop res = xobj-&gt;obj_field(displacement);
2222   JVMCIObject result = JVMCIENV-&gt;get_object_constant(res);
2223   return JVMCIENV-&gt;get_jobject(result);
2224 }
2225 
2226 C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))
2227   jobject handle = (jobject)(address)h;
2228   if (handle != NULL) {
<span class="changed">2229     JVMCIENV-&gt;runtime()-&gt;destroy_global(handle);</span>
2230   }
2231 }
2232 
2233 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {
2234   if (!UseJVMCINativeLibrary) {
2235     JVMCI_THROW_MSG(UnsupportedOperationException, "JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)");
2236   }
2237 }
2238 








2239 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))
2240   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2241   requireInHotSpot("registerNativeMethods", JVMCI_CHECK_NULL);
<span class="changed">2242   char* sl_path;</span>
<span class="changed">2243   void* sl_handle;</span>
<span class="changed">2244   JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
<span class="changed">2245   {</span>
2246     // Ensure the JVMCI shared library runtime is initialized.
2247     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
2248     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2249     HandleMark hm;

2250     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);
2251     if (peerEnv-&gt;has_pending_exception()) {
2252       peerEnv-&gt;describe_pending_exception(true);
2253     }
<span class="changed">2254     sl_handle = JVMCI::get_shared_library(sl_path, false);</span>
<span class="changed">2255     if (sl_handle == NULL) {</span>
<span class="changed">2256       JVMCI_THROW_MSG_0(InternalError, err_msg("Error initializing JVMCI runtime %d", runtime-&gt;id()));</span>
2257     }
2258   }
2259 
2260   if (mirror == NULL) {
2261     JVMCI_THROW_0(NullPointerException);
2262   }
2263   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2264   if (klass == NULL || !klass-&gt;is_instance_klass()) {
2265     JVMCI_THROW_MSG_0(IllegalArgumentException, "clazz is for primitive type");
2266   }
2267 
2268   InstanceKlass* iklass = InstanceKlass::cast(klass);
2269   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
2270     methodHandle method(THREAD, iklass-&gt;methods()-&gt;at(i));
2271     if (method-&gt;is_native()) {
2272 
2273       // Compute argument size
2274       int args_size = 1                             // JNIEnv
2275                     + (method-&gt;is_static() ? 1 : 0) // class for static methods
2276                     + method-&gt;size_of_parameters(); // actual parameters
2277 
2278       // 1) Try JNI short style
2279       stringStream st;
2280       char* pure_name = NativeLookup::pure_jni_name(method);
2281       os::print_jni_name_prefix_on(&amp;st, args_size);
2282       st.print_raw(pure_name);
2283       os::print_jni_name_suffix_on(&amp;st, args_size);
2284       char* jni_name = st.as_string();
2285 
<span class="changed">2286       address entry = (address) os::dll_lookup(sl_handle, jni_name);</span>
2287       if (entry == NULL) {
2288         // 2) Try JNI long style
2289         st.reset();
2290         char* long_name = NativeLookup::long_jni_name(method);
2291         os::print_jni_name_prefix_on(&amp;st, args_size);
2292         st.print_raw(pure_name);
2293         st.print_raw(long_name);
2294         os::print_jni_name_suffix_on(&amp;st, args_size);
2295         char* jni_long_name = st.as_string();
<span class="changed">2296         entry = (address) os::dll_lookup(sl_handle, jni_long_name);</span>
2297         if (entry == NULL) {
2298           JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg("%s [neither %s nor %s exist in %s]",
2299               method-&gt;name_and_sig_as_C_string(),
<span class="changed">2300               jni_name, jni_long_name, sl_path));</span>
2301         }
2302       }
2303 
2304       if (method-&gt;has_native_function() &amp;&amp; entry != method-&gt;native_function()) {
2305         JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg("%s [cannot re-link from " PTR_FORMAT " to " PTR_FORMAT "]",
2306             method-&gt;name_and_sig_as_C_string(), p2i(method-&gt;native_function()), p2i(entry)));
2307       }
2308       method-&gt;set_native_function(entry, Method::native_bind_event_is_interesting);
<span class="changed">2309       log_debug(jni, resolve)("[Dynamic-linking native method %s.%s ... JNI] @ " PTR_FORMAT,</span>
2310                               method-&gt;method_holder()-&gt;external_name(),
<span class="changed">2311                               method-&gt;name()-&gt;as_C_string(),</span>
<span class="changed">2312                                                           p2i((void*) entry));</span>
2313     }
2314   }
2315 
<span class="changed">2316   typeArrayOop info_oop = oopFactory::new_longArray(4, CHECK_0);</span>
<span class="changed">2317   jlongArray info = (jlongArray) JNIHandles::make_local(info_oop);</span>
<span class="changed">2318   runtime-&gt;init_JavaVM_info(info, JVMCI_CHECK_0);</span>
<span class="changed">2319   return info;</span>



2320 }
2321 
2322 C2V_VMENTRY_PREFIX(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject c2vm))
<span class="changed">2323   if (thread == NULL) {</span>
2324     // Called from unattached JVMCI shared library thread
2325     return false;
2326   }
2327   JVMCITraceMark jtm("isCurrentThreadAttached");


2328   if (thread-&gt;jni_environment() == env) {
2329     C2V_BLOCK(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject))
2330     requireJVMCINativeLibrary(JVMCI_CHECK_0);
<span class="changed">2331     JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
<span class="changed">2332     if (runtime == NULL || !runtime-&gt;has_shared_library_javavm()) {</span>
<span class="changed">2333       JVMCI_THROW_MSG_0(IllegalStateException, "Require JVMCI shared library JavaVM to be initialized in isCurrentThreadAttached");</span>
<span class="changed">2334     }</span>
2335     JNIEnv* peerEnv;
<span class="changed">2336     return runtime-&gt;GetEnv(thread, (void**) &amp;peerEnv, JNI_VERSION_1_2) == JNI_OK;</span>
2337   }
2338   return true;
2339 C2V_END
2340 
2341 C2V_VMENTRY_PREFIX(jlong, getCurrentJavaThread, (JNIEnv* env, jobject c2vm))
<span class="changed">2342   if (thread == NULL) {</span>
2343     // Called from unattached JVMCI shared library thread
2344     return 0L;
2345   }
2346   JVMCITraceMark jtm("getCurrentJavaThread");
<span class="changed">2347   return (jlong) p2i(thread);</span>

2348 C2V_END
2349 
2350 C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean as_daemon))
<span class="changed">2351   if (thread == NULL) {</span>
2352     // Called from unattached JVMCI shared library thread
2353     extern struct JavaVM_ main_vm;
2354     JNIEnv* hotspotEnv;
<span class="changed">2355     jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**) &amp;hotspotEnv, NULL) :</span>
<span class="changed">2356                            main_vm.AttachCurrentThread((void**) &amp;hotspotEnv, NULL);</span>
2357     if (res != JNI_OK) {
2358       JNI_THROW_("attachCurrentThread", InternalError, err_msg("Trying to attach thread returned %d", res), false);
2359     }
2360     return true;
2361   }
2362   JVMCITraceMark jtm("attachCurrentThread");


2363   if (thread-&gt;jni_environment() == env) {
2364     // Called from HotSpot
2365     C2V_BLOCK(jboolean, attachCurrentThread, (JNIEnv* env, jobject, jboolean))
2366     requireJVMCINativeLibrary(JVMCI_CHECK_0);
<span class="changed">2367     JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
<span class="changed">2368     if (runtime == NULL || !runtime-&gt;has_shared_library_javavm()) {</span>
<span class="changed">2369         JVMCI_THROW_MSG_0(IllegalStateException, "Require JVMCI shared library JavaVM to be initialized in attachCurrentThread");</span>
<span class="changed">2370     }</span>
<span class="changed">2371 </span>
2372     JavaVMAttachArgs attach_args;
2373     attach_args.version = JNI_VERSION_1_2;
2374     attach_args.name = thread-&gt;name();
2375     attach_args.group = NULL;
<span class="changed">2376     JNIEnv* peerJNIEnv;</span>
<span class="changed">2377     if (runtime-&gt;GetEnv(thread, (void**) &amp;peerJNIEnv, JNI_VERSION_1_2) == JNI_OK) {</span>
2378       return false;
2379     }
<span class="changed">2380     jint res = as_daemon ? runtime-&gt;AttachCurrentThreadAsDaemon(thread, (void**) &amp;peerJNIEnv, &amp;attach_args) :</span>
<span class="changed">2381                            runtime-&gt;AttachCurrentThread(thread, (void**) &amp;peerJNIEnv, &amp;attach_args);</span>
<span class="changed">2382 </span>
2383     if (res == JNI_OK) {
<span class="changed">2384       guarantee(peerJNIEnv != NULL, "must be");</span>
<span class="changed">2385       JVMCI_event_1("attached to JavaVM for JVMCI runtime %d", runtime-&gt;id());</span>
2386       return true;
2387     }
2388     JVMCI_THROW_MSG_0(InternalError, err_msg("Error %d while attaching %s", res, attach_args.name));
2389   }
2390   // Called from JVMCI shared library
2391   return false;
2392 C2V_END
2393 
2394 C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))
<span class="changed">2395   if (thread == NULL) {</span>
2396     // Called from unattached JVMCI shared library thread
<span class="changed">2397     JNI_THROW("detachCurrentThread", IllegalStateException, "Cannot detach non-attached thread");</span>
2398   }
2399   JVMCITraceMark jtm("detachCurrentThread");


2400   if (thread-&gt;jni_environment() == env) {
2401     // Called from HotSpot
2402     C2V_BLOCK(void, detachCurrentThread, (JNIEnv* env, jobject))
2403     requireJVMCINativeLibrary(JVMCI_CHECK);
2404     requireInHotSpot("detachCurrentThread", JVMCI_CHECK);
<span class="changed">2405     JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
<span class="changed">2406     if (runtime == NULL || !runtime-&gt;has_shared_library_javavm()) {</span>
<span class="changed">2407       JVMCI_THROW_MSG(IllegalStateException, "Require JVMCI shared library JavaVM to be initialized in detachCurrentThread");</span>
<span class="changed">2408     }</span>
<span class="changed">2409     JNIEnv* peerJNIEnv;</span>
<span class="changed">2410     if (runtime-&gt;GetEnv(thread, (void**) &amp;peerJNIEnv, JNI_VERSION_1_2) != JNI_OK) {</span>
2411       JVMCI_THROW_MSG(IllegalStateException, err_msg("Cannot detach non-attached thread: %s", thread-&gt;name()));
2412     }
<span class="changed">2413     jint res = runtime-&gt;DetachCurrentThread(thread);</span>
2414     if (res != JNI_OK) {
2415       JVMCI_THROW_MSG(InternalError, err_msg("Error %d while attaching %s", res, thread-&gt;name()));
2416     }
2417   } else {
2418     // Called from attached JVMCI shared library thread
2419     extern struct JavaVM_ main_vm;
2420     jint res = main_vm.DetachCurrentThread();
2421     if (res != JNI_OK) {
<span class="changed">2422       JNI_THROW("detachCurrentThread", InternalError, "Cannot detach non-attached thread");</span>
2423     }
2424   }
2425 C2V_END
2426 
2427 C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))
2428   requireJVMCINativeLibrary(JVMCI_CHECK_0);
2429   if (obj_handle == NULL) {
2430     return 0L;
2431   }
2432   JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV-&gt;is_hotspot(), __FILE__, __LINE__);
2433   JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2434   JVMCIEnv* thisEnv = JVMCIENV;
2435 
2436   JVMCIObject obj = thisEnv-&gt;wrap(obj_handle);
2437   JVMCIObject result;
2438   if (thisEnv-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {
2439     methodHandle method(THREAD, thisEnv-&gt;asMethod(obj));
2440     result = peerEnv-&gt;get_jvmci_method(method, JVMCI_CHECK_0);
2441   } else if (thisEnv-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {
2442     Klass* klass = thisEnv-&gt;asKlass(obj);

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/hotspot/share/jvmci/jvmciCompiler.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/jvmci/jvmciEnv.cpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
