<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #ifndef SHARE_VM_JVMCI_JVMCI_RUNTIME_HPP
  25 #define SHARE_VM_JVMCI_JVMCI_RUNTIME_HPP
  26 
  27 #include "interpreter/interpreter.hpp"
  28 #include "memory/allocation.hpp"
  29 #include "runtime/arguments.hpp"
  30 #include "runtime/deoptimization.hpp"
  31 
  32 #define JVMCI_ERROR(...)       \
  33   { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return; }
  34 
  35 #define JVMCI_ERROR_(ret, ...) \
  36   { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return ret; }
  37 
  38 #define JVMCI_ERROR_0(...)    JVMCI_ERROR_(0, __VA_ARGS__)
  39 #define JVMCI_ERROR_NULL(...) JVMCI_ERROR_(NULL, __VA_ARGS__)
  40 #define JVMCI_ERROR_OK(...)   JVMCI_ERROR_(JVMCIEnv::ok, __VA_ARGS__)
  41 #define CHECK_OK              CHECK_(JVMCIEnv::ok)
  42 
  43 class JVMCIRuntime: public AllStatic {
  44  public:
  45   // Constants describing whether JVMCI wants to be able to adjust the compilation
  46   // level selected for a method by the VM compilation policy and if so, based on
  47   // what information about the method being schedule for compilation.
  48   enum CompLevelAdjustment {
  49      none = 0,             // no adjustment
  50      by_holder = 1,        // adjust based on declaring class of method
  51      by_full_signature = 2 // adjust based on declaring class, name and signature of method
  52   };
  53 
  54  private:
  55   static jobject _HotSpotJVMCIRuntime_instance;
  56   static bool _HotSpotJVMCIRuntime_initialized;
  57   static bool _well_known_classes_initialized;
  58 
  59   static CompLevelAdjustment _comp_level_adjustment;
  60 
  61   static bool _shutdown_called;
  62 
  63   static CompLevel adjust_comp_level_inner(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread);
  64 
  65  public:
  66   static bool is_HotSpotJVMCIRuntime_initialized() {
  67     return _HotSpotJVMCIRuntime_initialized;
  68   }
  69 
  70   /**
  71    * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary
  72    */
  73   static Handle get_HotSpotJVMCIRuntime(TRAPS);
  74 
  75   static jobject get_HotSpotJVMCIRuntime_jobject(TRAPS) {
  76     initialize_JVMCI(CHECK_NULL);
  77     assert(_HotSpotJVMCIRuntime_initialized, "must be");
  78     return _HotSpotJVMCIRuntime_instance;
  79   }
  80 
  81   static Handle callStatic(const char* className, const char* methodName, const char* returnType, JavaCallArguments* args, TRAPS);
  82 
  83   /**
  84    * Determines if the VM is sufficiently booted to initialize JVMCI.
  85    */
  86   static bool can_initialize_JVMCI();
  87 
  88   /**
  89    * Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()
  90    */
  91   static void initialize_JVMCI(TRAPS);
  92 
  93   /**
  94    * Explicitly initialize HotSpotJVMCIRuntime itself
  95    */
  96   static void initialize_HotSpotJVMCIRuntime(TRAPS);
  97 
  98   static void initialize_well_known_classes(TRAPS);
  99 
 100   static void metadata_do(void f(Metadata*));
 101 
 102   static void shutdown(TRAPS);
 103 
 104   static void bootstrap_finished(TRAPS);
 105 
 106   static bool shutdown_called() {
 107     return _shutdown_called;
 108   }
 109 
 110   /**
 111    * Lets JVMCI modify the compilation level currently selected for a method by
 112    * the VM compilation policy.
 113    *
 114    * @param method the method being scheduled for compilation
 115    * @param is_osr specifies if the compilation is an OSR compilation
 116    * @param level the compilation level currently selected by the VM compilation policy
 117    * @param thread the current thread
 118    * @return the compilation level to use for the compilation
 119    */
 120   static CompLevel adjust_comp_level(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread);
 121 
 122   static BasicType kindToBasicType(Handle kind, TRAPS);
 123 
<a name="1" id="anc1"></a><span class="changed"> 124   static void new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail);</span>
<span class="changed"> 125   static void new_array_common(JavaThread* thread, Klass* klass, jint length, bool null_on_fail);</span>
<span class="changed"> 126   static void new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail);</span>
<span class="changed"> 127   static void dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail);</span>
<span class="changed"> 128   static void dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail);</span>
<span class="changed"> 129 </span>
<span class="changed"> 130   // The following routines are called from compiled JVMCI code</span>
<span class="changed"> 131 </span>
<span class="changed"> 132   // When allocation fails, these stubs:</span>
<span class="changed"> 133   // 1. Exercise -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError handling and also</span>
<span class="changed"> 134   //    post a JVMTI_EVENT_RESOURCE_EXHAUSTED event if the failure is an OutOfMemroyError</span>
<span class="changed"> 135   // 2. Return NULL with a pending exception.</span>
<span class="changed"> 136   // Compiled code must ensure these stubs are not called twice for the same allocation</span>
<span class="changed"> 137   // site due to the non-repeatable side effects in the case of OOME.</span>
<span class="changed"> 138   static void new_instance(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, false); }</span>
<span class="changed"> 139   static void new_array(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, false); }</span>
<span class="changed"> 140   static void new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, false); }</span>
<span class="changed"> 141   static void dynamic_new_array(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, false); }</span>
<span class="changed"> 142   static void dynamic_new_instance(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, false); }</span>
<span class="changed"> 143 </span>
<span class="changed"> 144   // When allocation fails, these stubs return NULL and have no pending exception. Compiled code</span>
<span class="changed"> 145   // can use these stubs if a failed allocation will be retried (e.g., by deoptimizing and</span>
<span class="changed"> 146   // re-executing in the interpreter).</span>
<span class="changed"> 147   static void new_instance_or_null(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, true); }</span>
<span class="changed"> 148   static void new_array_or_null(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, true); }</span>
<span class="changed"> 149   static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, true); }</span>
<span class="changed"> 150   static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, true); }</span>
<span class="changed"> 151   static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, true); }</span>
 152 
<a name="2" id="anc2"></a>




 153   static jboolean thread_is_interrupted(JavaThread* thread, oopDesc* obj, jboolean clear_interrupted);
 154   static void vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3);
 155   static jint identity_hash_code(JavaThread* thread, oopDesc* obj);
 156   static address exception_handler_for_pc(JavaThread* thread);
 157   static void monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock);
 158   static void monitorexit (JavaThread* thread, oopDesc* obj, BasicLock* lock);
 159   static jboolean object_notify(JavaThread* thread, oopDesc* obj);
 160   static jboolean object_notifyAll(JavaThread* thread, oopDesc* obj);
 161   static void vm_error(JavaThread* thread, jlong where, jlong format, jlong value);
 162   static oopDesc* load_and_clear_exception(JavaThread* thread);
 163   static void log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3);
 164   static void log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline);
 165   // Print the passed in object, optionally followed by a newline.  If
 166   // as_string is true and the object is a java.lang.String then it
 167   // printed as a string, otherwise the type of the object is printed
 168   // followed by its address.
 169   static void log_object(JavaThread* thread, oopDesc* object, bool as_string, bool newline);
 170 #if INCLUDE_G1GC
 171   static void write_barrier_pre(JavaThread* thread, oopDesc* obj);
 172   static void write_barrier_post(JavaThread* thread, void* card);
 173 #endif
 174   static jboolean validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child);
 175 
 176   // used to throw exceptions from compiled JVMCI code
 177   static void throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message);
 178   // helper methods to throw exception with complex messages
 179   static void throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass);
 180   static void throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);
 181 
 182   // Forces initialization of the JVMCI runtime.
 183   static void force_initialization(TRAPS);
 184 
 185   // Test only function
 186   static int test_deoptimize_call_int(JavaThread* thread, int value);
 187 };
 188 
 189 // Tracing macros.
 190 
 191 #define IF_TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1)) ; else
 192 #define IF_TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2)) ; else
 193 #define IF_TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3)) ; else
 194 #define IF_TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4)) ; else
 195 #define IF_TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5)) ; else
 196 
 197 #define TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1 &amp;&amp; (tty-&gt;print("JVMCITrace-1: "), true))) ; else tty-&gt;print_cr
 198 #define TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2 &amp;&amp; (tty-&gt;print("   JVMCITrace-2: "), true))) ; else tty-&gt;print_cr
 199 #define TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3 &amp;&amp; (tty-&gt;print("      JVMCITrace-3: "), true))) ; else tty-&gt;print_cr
 200 #define TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4 &amp;&amp; (tty-&gt;print("         JVMCITrace-4: "), true))) ; else tty-&gt;print_cr
 201 #define TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5 &amp;&amp; (tty-&gt;print("            JVMCITrace-5: "), true))) ; else tty-&gt;print_cr
 202 
 203 #endif // SHARE_VM_JVMCI_JVMCI_RUNTIME_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="3" type="hidden" /></form></body></html>
