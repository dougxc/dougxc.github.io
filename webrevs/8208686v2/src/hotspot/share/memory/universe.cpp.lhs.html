<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "aot/aotLoader.hpp"
  27 #include "classfile/classLoader.hpp"
  28 #include "classfile/classLoaderDataGraph.hpp"
  29 #include "classfile/javaClasses.hpp"
  30 #include "classfile/stringTable.hpp"
  31 #include "classfile/systemDictionary.hpp"
  32 #include "classfile/vmSymbols.hpp"
  33 #include "code/codeCache.hpp"
  34 #include "code/dependencies.hpp"
  35 #include "gc/shared/collectedHeap.inline.hpp"
  36 #include "gc/shared/gcArguments.hpp"
  37 #include "gc/shared/gcConfig.hpp"
  38 #include "gc/shared/gcTraceTime.inline.hpp"
  39 #include "interpreter/interpreter.hpp"
  40 #include "logging/log.hpp"
  41 #include "logging/logStream.hpp"
  42 #include "memory/filemap.hpp"
  43 #include "memory/metadataFactory.hpp"
  44 #include "memory/metaspaceClosure.hpp"
  45 #include "memory/metaspaceCounters.hpp"
  46 #include "memory/metaspaceShared.hpp"
  47 #include "memory/oopFactory.hpp"
  48 #include "memory/resourceArea.hpp"
  49 #include "memory/universe.hpp"
  50 #include "memory/universe.hpp"
  51 #include "oops/constantPool.hpp"
  52 #include "oops/instanceClassLoaderKlass.hpp"
  53 #include "oops/instanceKlass.hpp"
  54 #include "oops/instanceMirrorKlass.hpp"
  55 #include "oops/instanceRefKlass.hpp"
  56 #include "oops/objArrayOop.inline.hpp"
  57 #include "oops/oop.inline.hpp"
  58 #include "oops/typeArrayKlass.hpp"
  59 #include "prims/resolvedMethodTable.hpp"
  60 #include "runtime/arguments.hpp"
  61 #include "runtime/atomic.hpp"
  62 #include "runtime/flags/flagSetting.hpp"
  63 #include "runtime/flags/jvmFlagConstraintList.hpp"
  64 #include "runtime/deoptimization.hpp"
  65 #include "runtime/handles.inline.hpp"
  66 #include "runtime/init.hpp"
  67 #include "runtime/java.hpp"
  68 #include "runtime/javaCalls.hpp"
  69 #include "runtime/sharedRuntime.hpp"
  70 #include "runtime/synchronizer.hpp"
  71 #include "runtime/thread.inline.hpp"
  72 #include "runtime/timerTrace.hpp"
  73 #include "runtime/vm_operations.hpp"
  74 #include "services/memoryService.hpp"
  75 #include "utilities/align.hpp"
  76 #include "utilities/copy.hpp"
  77 #include "utilities/debug.hpp"
  78 #include "utilities/events.hpp"
  79 #include "utilities/formatBuffer.hpp"
  80 #include "utilities/hashtable.inline.hpp"
  81 #include "utilities/macros.hpp"
  82 #include "utilities/ostream.hpp"
  83 #include "utilities/preserveException.hpp"
  84 
  85 // Known objects
  86 Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL /*, NULL...*/ };
  87 Klass* Universe::_objectArrayKlassObj                 = NULL;
  88 oop Universe::_int_mirror                             = NULL;
  89 oop Universe::_float_mirror                           = NULL;
  90 oop Universe::_double_mirror                          = NULL;
  91 oop Universe::_byte_mirror                            = NULL;
  92 oop Universe::_bool_mirror                            = NULL;
  93 oop Universe::_char_mirror                            = NULL;
  94 oop Universe::_long_mirror                            = NULL;
  95 oop Universe::_short_mirror                           = NULL;
  96 oop Universe::_void_mirror                            = NULL;
  97 oop Universe::_mirrors[T_VOID+1]                      = { NULL /*, NULL...*/ };
  98 oop Universe::_main_thread_group                      = NULL;
  99 oop Universe::_system_thread_group                    = NULL;
 100 objArrayOop Universe::_the_empty_class_klass_array    = NULL;
 101 Array&lt;Klass*&gt;* Universe::_the_array_interfaces_array = NULL;
 102 oop Universe::_the_null_sentinel                      = NULL;
 103 oop Universe::_the_null_string                        = NULL;
 104 oop Universe::_the_min_jint_string                   = NULL;
 105 LatestMethodCache* Universe::_finalizer_register_cache = NULL;
 106 LatestMethodCache* Universe::_loader_addClass_cache    = NULL;
 107 LatestMethodCache* Universe::_pd_implies_cache         = NULL;
 108 LatestMethodCache* Universe::_throw_illegal_access_error_cache = NULL;
 109 LatestMethodCache* Universe::_do_stack_walk_cache     = NULL;
 110 oop Universe::_out_of_memory_error_java_heap          = NULL;
 111 oop Universe::_out_of_memory_error_metaspace          = NULL;
 112 oop Universe::_out_of_memory_error_class_metaspace    = NULL;
 113 oop Universe::_out_of_memory_error_array_size         = NULL;
 114 oop Universe::_out_of_memory_error_gc_overhead_limit  = NULL;
 115 oop Universe::_out_of_memory_error_realloc_objects    = NULL;
<a name="1" id="anc1"></a>
 116 oop Universe::_delayed_stack_overflow_error_message   = NULL;
 117 objArrayOop Universe::_preallocated_out_of_memory_error_array = NULL;
 118 volatile jint Universe::_preallocated_out_of_memory_error_avail_count = 0;
 119 bool Universe::_verify_in_progress                    = false;
 120 long Universe::verify_flags                           = Universe::Verify_All;
 121 oop Universe::_null_ptr_exception_instance            = NULL;
 122 oop Universe::_arithmetic_exception_instance          = NULL;
 123 oop Universe::_virtual_machine_error_instance         = NULL;
 124 oop Universe::_vm_exception                           = NULL;
 125 oop Universe::_reference_pending_list                 = NULL;
 126 
 127 Array&lt;int&gt;* Universe::_the_empty_int_array            = NULL;
 128 Array&lt;u2&gt;* Universe::_the_empty_short_array           = NULL;
 129 Array&lt;Klass*&gt;* Universe::_the_empty_klass_array     = NULL;
 130 Array&lt;InstanceKlass*&gt;* Universe::_the_empty_instance_klass_array  = NULL;
 131 Array&lt;Method*&gt;* Universe::_the_empty_method_array   = NULL;
 132 
 133 // These variables are guarded by FullGCALot_lock.
 134 debug_only(objArrayOop Universe::_fullgc_alot_dummy_array = NULL;)
 135 debug_only(int Universe::_fullgc_alot_dummy_next      = 0;)
 136 
 137 // Heap
 138 int             Universe::_verify_count = 0;
 139 
 140 // Oop verification (see MacroAssembler::verify_oop)
 141 uintptr_t       Universe::_verify_oop_mask = 0;
 142 uintptr_t       Universe::_verify_oop_bits = (uintptr_t) -1;
 143 
 144 int             Universe::_base_vtable_size = 0;
 145 bool            Universe::_bootstrapping = false;
 146 bool            Universe::_module_initialized = false;
 147 bool            Universe::_fully_initialized = false;
 148 
 149 size_t          Universe::_heap_capacity_at_last_gc;
 150 size_t          Universe::_heap_used_at_last_gc = 0;
 151 
 152 CollectedHeap*  Universe::_collectedHeap = NULL;
 153 
 154 NarrowPtrStruct Universe::_narrow_oop = { NULL, 0, true };
 155 NarrowPtrStruct Universe::_narrow_klass = { NULL, 0, true };
 156 address Universe::_narrow_ptrs_base;
 157 uint64_t Universe::_narrow_klass_range = (uint64_t(max_juint)+1);
 158 
 159 void Universe::basic_type_classes_do(void f(Klass*)) {
 160   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 161     f(_typeArrayKlassObjs[i]);
 162   }
 163 }
 164 
 165 void Universe::basic_type_classes_do(KlassClosure *closure) {
 166   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 167     closure-&gt;do_klass(_typeArrayKlassObjs[i]);
 168   }
 169 }
 170 
 171 void Universe::oops_do(OopClosure* f) {
 172 
 173   f-&gt;do_oop((oop*) &amp;_int_mirror);
 174   f-&gt;do_oop((oop*) &amp;_float_mirror);
 175   f-&gt;do_oop((oop*) &amp;_double_mirror);
 176   f-&gt;do_oop((oop*) &amp;_byte_mirror);
 177   f-&gt;do_oop((oop*) &amp;_bool_mirror);
 178   f-&gt;do_oop((oop*) &amp;_char_mirror);
 179   f-&gt;do_oop((oop*) &amp;_long_mirror);
 180   f-&gt;do_oop((oop*) &amp;_short_mirror);
 181   f-&gt;do_oop((oop*) &amp;_void_mirror);
 182 
 183   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
 184     f-&gt;do_oop((oop*) &amp;_mirrors[i]);
 185   }
 186   assert(_mirrors[0] == NULL &amp;&amp; _mirrors[T_BOOLEAN - 1] == NULL, "checking");
 187 
 188   f-&gt;do_oop((oop*)&amp;_the_empty_class_klass_array);
 189   f-&gt;do_oop((oop*)&amp;_the_null_sentinel);
 190   f-&gt;do_oop((oop*)&amp;_the_null_string);
 191   f-&gt;do_oop((oop*)&amp;_the_min_jint_string);
 192   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_java_heap);
 193   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_metaspace);
 194   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_class_metaspace);
 195   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_array_size);
 196   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_gc_overhead_limit);
 197   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_realloc_objects);
<a name="2" id="anc2"></a>
 198   f-&gt;do_oop((oop*)&amp;_delayed_stack_overflow_error_message);
 199   f-&gt;do_oop((oop*)&amp;_preallocated_out_of_memory_error_array);
 200   f-&gt;do_oop((oop*)&amp;_null_ptr_exception_instance);
 201   f-&gt;do_oop((oop*)&amp;_arithmetic_exception_instance);
 202   f-&gt;do_oop((oop*)&amp;_virtual_machine_error_instance);
 203   f-&gt;do_oop((oop*)&amp;_main_thread_group);
 204   f-&gt;do_oop((oop*)&amp;_system_thread_group);
 205   f-&gt;do_oop((oop*)&amp;_vm_exception);
 206   f-&gt;do_oop((oop*)&amp;_reference_pending_list);
 207   debug_only(f-&gt;do_oop((oop*)&amp;_fullgc_alot_dummy_array);)
 208 }
 209 
 210 void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {
 211   it-&gt;push(&amp;_klass);
 212 }
 213 
 214 void Universe::metaspace_pointers_do(MetaspaceClosure* it) {
 215   for (int i = 0; i &lt; T_LONG+1; i++) {
 216     it-&gt;push(&amp;_typeArrayKlassObjs[i]);
 217   }
 218   it-&gt;push(&amp;_objectArrayKlassObj);
 219 
 220   it-&gt;push(&amp;_the_empty_int_array);
 221   it-&gt;push(&amp;_the_empty_short_array);
 222   it-&gt;push(&amp;_the_empty_klass_array);
 223   it-&gt;push(&amp;_the_empty_instance_klass_array);
 224   it-&gt;push(&amp;_the_empty_method_array);
 225   it-&gt;push(&amp;_the_array_interfaces_array);
 226 
 227   _finalizer_register_cache-&gt;metaspace_pointers_do(it);
 228   _loader_addClass_cache-&gt;metaspace_pointers_do(it);
 229   _pd_implies_cache-&gt;metaspace_pointers_do(it);
 230   _throw_illegal_access_error_cache-&gt;metaspace_pointers_do(it);
 231   _do_stack_walk_cache-&gt;metaspace_pointers_do(it);
 232 }
 233 
 234 // Serialize metadata and pointers to primitive type mirrors in and out of CDS archive
 235 void Universe::serialize(SerializeClosure* f) {
 236 
 237   for (int i = 0; i &lt; T_LONG+1; i++) {
 238     f-&gt;do_ptr((void**)&amp;_typeArrayKlassObjs[i]);
 239   }
 240 
 241   f-&gt;do_ptr((void**)&amp;_objectArrayKlassObj);
 242 #if INCLUDE_CDS_JAVA_HEAP
 243   // The mirrors are NULL if MetaspaceShared::is_heap_object_archiving_allowed
 244   // is false.
 245   f-&gt;do_oop(&amp;_int_mirror);
 246   f-&gt;do_oop(&amp;_float_mirror);
 247   f-&gt;do_oop(&amp;_double_mirror);
 248   f-&gt;do_oop(&amp;_byte_mirror);
 249   f-&gt;do_oop(&amp;_bool_mirror);
 250   f-&gt;do_oop(&amp;_char_mirror);
 251   f-&gt;do_oop(&amp;_long_mirror);
 252   f-&gt;do_oop(&amp;_short_mirror);
 253   f-&gt;do_oop(&amp;_void_mirror);
 254 #endif
 255 
 256   f-&gt;do_ptr((void**)&amp;_the_array_interfaces_array);
 257   f-&gt;do_ptr((void**)&amp;_the_empty_int_array);
 258   f-&gt;do_ptr((void**)&amp;_the_empty_short_array);
 259   f-&gt;do_ptr((void**)&amp;_the_empty_method_array);
 260   f-&gt;do_ptr((void**)&amp;_the_empty_klass_array);
 261   f-&gt;do_ptr((void**)&amp;_the_empty_instance_klass_array);
 262   _finalizer_register_cache-&gt;serialize(f);
 263   _loader_addClass_cache-&gt;serialize(f);
 264   _pd_implies_cache-&gt;serialize(f);
 265   _throw_illegal_access_error_cache-&gt;serialize(f);
 266   _do_stack_walk_cache-&gt;serialize(f);
 267 }
 268 
 269 void Universe::check_alignment(uintx size, uintx alignment, const char* name) {
 270   if (size &lt; alignment || size % alignment != 0) {
 271     vm_exit_during_initialization(
 272       err_msg("Size of %s (" UINTX_FORMAT " bytes) must be aligned to " UINTX_FORMAT " bytes", name, size, alignment));
 273   }
 274 }
 275 
 276 void initialize_basic_type_klass(Klass* k, TRAPS) {
 277   Klass* ok = SystemDictionary::Object_klass();
 278 #if INCLUDE_CDS
 279   if (UseSharedSpaces) {
 280     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 281     assert(k-&gt;super() == ok, "u3");
 282     k-&gt;restore_unshareable_info(loader_data, Handle(), CHECK);
 283   } else
 284 #endif
 285   {
 286     k-&gt;initialize_supers(ok, NULL, CHECK);
 287   }
 288   k-&gt;append_to_sibling_list();
 289 }
 290 
 291 void Universe::genesis(TRAPS) {
 292   ResourceMark rm;
 293 
 294   { FlagSetting fs(_bootstrapping, true);
 295 
 296     { MutexLocker mc(Compile_lock);
 297 
 298       java_lang_Class::allocate_fixup_lists();
 299 
 300       // determine base vtable size; without that we cannot create the array klasses
 301       compute_base_vtable_size();
 302 
 303       if (!UseSharedSpaces) {
 304         for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 305           _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);
 306         }
 307 
 308         ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
 309 
 310         _the_array_interfaces_array     = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 2, NULL, CHECK);
 311         _the_empty_int_array            = MetadataFactory::new_array&lt;int&gt;(null_cld, 0, CHECK);
 312         _the_empty_short_array          = MetadataFactory::new_array&lt;u2&gt;(null_cld, 0, CHECK);
 313         _the_empty_method_array         = MetadataFactory::new_array&lt;Method*&gt;(null_cld, 0, CHECK);
 314         _the_empty_klass_array          = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 0, CHECK);
 315         _the_empty_instance_klass_array = MetadataFactory::new_array&lt;InstanceKlass*&gt;(null_cld, 0, CHECK);
 316       }
 317     }
 318 
 319     vmSymbols::initialize(CHECK);
 320 
 321     SystemDictionary::initialize(CHECK);
 322 
 323     Klass* ok = SystemDictionary::Object_klass();
 324 
 325     _the_null_string            = StringTable::intern("null", CHECK);
 326     _the_min_jint_string       = StringTable::intern("-2147483648", CHECK);
 327 
 328 #if INCLUDE_CDS
 329     if (UseSharedSpaces) {
 330       // Verify shared interfaces array.
 331       assert(_the_array_interfaces_array-&gt;at(0) ==
 332              SystemDictionary::Cloneable_klass(), "u3");
 333       assert(_the_array_interfaces_array-&gt;at(1) ==
 334              SystemDictionary::Serializable_klass(), "u3");
 335     } else
 336 #endif
 337     {
 338       // Set up shared interfaces array.  (Do this before supers are set up.)
 339       _the_array_interfaces_array-&gt;at_put(0, SystemDictionary::Cloneable_klass());
 340       _the_array_interfaces_array-&gt;at_put(1, SystemDictionary::Serializable_klass());
 341     }
 342 
 343     initialize_basic_type_klass(boolArrayKlassObj(), CHECK);
 344     initialize_basic_type_klass(charArrayKlassObj(), CHECK);
 345     initialize_basic_type_klass(floatArrayKlassObj(), CHECK);
 346     initialize_basic_type_klass(doubleArrayKlassObj(), CHECK);
 347     initialize_basic_type_klass(byteArrayKlassObj(), CHECK);
 348     initialize_basic_type_klass(shortArrayKlassObj(), CHECK);
 349     initialize_basic_type_klass(intArrayKlassObj(), CHECK);
 350     initialize_basic_type_klass(longArrayKlassObj(), CHECK);
 351   } // end of core bootstrapping
 352 
 353   {
 354     Handle tns = java_lang_String::create_from_str("&lt;null_sentinel&gt;", CHECK);
 355     _the_null_sentinel = tns();
 356   }
 357 
 358   // Maybe this could be lifted up now that object array can be initialized
 359   // during the bootstrapping.
 360 
 361   // OLD
 362   // Initialize _objectArrayKlass after core bootstraping to make
 363   // sure the super class is set up properly for _objectArrayKlass.
 364   // ---
 365   // NEW
 366   // Since some of the old system object arrays have been converted to
 367   // ordinary object arrays, _objectArrayKlass will be loaded when
 368   // SystemDictionary::initialize(CHECK); is run. See the extra check
 369   // for Object_klass_loaded in objArrayKlassKlass::allocate_objArray_klass_impl.
 370   _objectArrayKlassObj = InstanceKlass::
 371     cast(SystemDictionary::Object_klass())-&gt;array_klass(1, CHECK);
 372   // OLD
 373   // Add the class to the class hierarchy manually to make sure that
 374   // its vtable is initialized after core bootstrapping is completed.
 375   // ---
 376   // New
 377   // Have already been initialized.
 378   _objectArrayKlassObj-&gt;append_to_sibling_list();
 379 
 380   #ifdef ASSERT
 381   if (FullGCALot) {
 382     // Allocate an array of dummy objects.
 383     // We'd like these to be at the bottom of the old generation,
 384     // so that when we free one and then collect,
 385     // (almost) the whole heap moves
 386     // and we find out if we actually update all the oops correctly.
 387     // But we can't allocate directly in the old generation,
 388     // so we allocate wherever, and hope that the first collection
 389     // moves these objects to the bottom of the old generation.
 390     // We can allocate directly in the permanent generation, so we do.
 391     int size;
 392     if (UseConcMarkSweepGC) {
 393       log_warning(gc)("Using +FullGCALot with concurrent mark sweep gc will not force all objects to relocate");
 394       size = FullGCALotDummies;
 395     } else {
 396       size = FullGCALotDummies * 2;
 397     }
 398     objArrayOop    naked_array = oopFactory::new_objArray(SystemDictionary::Object_klass(), size, CHECK);
 399     objArrayHandle dummy_array(THREAD, naked_array);
 400     int i = 0;
 401     while (i &lt; size) {
 402         // Allocate dummy in old generation
 403       oop dummy = SystemDictionary::Object_klass()-&gt;allocate_instance(CHECK);
 404       dummy_array-&gt;obj_at_put(i++, dummy);
 405     }
 406     {
 407       // Only modify the global variable inside the mutex.
 408       // If we had a race to here, the other dummy_array instances
 409       // and their elements just get dropped on the floor, which is fine.
 410       MutexLocker ml(FullGCALot_lock);
 411       if (_fullgc_alot_dummy_array == NULL) {
 412         _fullgc_alot_dummy_array = dummy_array();
 413       }
 414     }
 415     assert(i == _fullgc_alot_dummy_array-&gt;length(), "just checking");
 416   }
 417   #endif
 418 }
 419 
 420 void Universe::initialize_basic_type_mirrors(TRAPS) {
 421 #if INCLUDE_CDS_JAVA_HEAP
 422     if (UseSharedSpaces &amp;&amp;
 423         MetaspaceShared::open_archive_heap_region_mapped() &amp;&amp;
 424         _int_mirror != NULL) {
 425       assert(MetaspaceShared::is_heap_object_archiving_allowed(), "Sanity");
 426       assert(_float_mirror != NULL &amp;&amp; _double_mirror != NULL &amp;&amp;
 427              _byte_mirror  != NULL &amp;&amp; _byte_mirror   != NULL &amp;&amp;
 428              _bool_mirror  != NULL &amp;&amp; _char_mirror   != NULL &amp;&amp;
 429              _long_mirror  != NULL &amp;&amp; _short_mirror  != NULL &amp;&amp;
 430              _void_mirror  != NULL, "Sanity");
 431     } else
 432 #endif
 433     {
 434       _int_mirror     =
 435         java_lang_Class::create_basic_type_mirror("int",    T_INT, CHECK);
 436       _float_mirror   =
 437         java_lang_Class::create_basic_type_mirror("float",  T_FLOAT,   CHECK);
 438       _double_mirror  =
 439         java_lang_Class::create_basic_type_mirror("double", T_DOUBLE,  CHECK);
 440       _byte_mirror    =
 441         java_lang_Class::create_basic_type_mirror("byte",   T_BYTE, CHECK);
 442       _bool_mirror    =
 443         java_lang_Class::create_basic_type_mirror("boolean",T_BOOLEAN, CHECK);
 444       _char_mirror    =
 445         java_lang_Class::create_basic_type_mirror("char",   T_CHAR, CHECK);
 446       _long_mirror    =
 447         java_lang_Class::create_basic_type_mirror("long",   T_LONG, CHECK);
 448       _short_mirror   =
 449         java_lang_Class::create_basic_type_mirror("short",  T_SHORT,   CHECK);
 450       _void_mirror    =
 451         java_lang_Class::create_basic_type_mirror("void",   T_VOID, CHECK);
 452     }
 453 
 454     _mirrors[T_INT]     = _int_mirror;
 455     _mirrors[T_FLOAT]   = _float_mirror;
 456     _mirrors[T_DOUBLE]  = _double_mirror;
 457     _mirrors[T_BYTE]    = _byte_mirror;
 458     _mirrors[T_BOOLEAN] = _bool_mirror;
 459     _mirrors[T_CHAR]    = _char_mirror;
 460     _mirrors[T_LONG]    = _long_mirror;
 461     _mirrors[T_SHORT]   = _short_mirror;
 462     _mirrors[T_VOID]    = _void_mirror;
 463   //_mirrors[T_OBJECT]  = _object_klass-&gt;java_mirror();
 464   //_mirrors[T_ARRAY]   = _object_klass-&gt;java_mirror();
 465 }
 466 
 467 void Universe::fixup_mirrors(TRAPS) {
 468   // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,
 469   // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply
 470   // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note
 471   // that the number of objects allocated at this point is very small.
 472   assert(SystemDictionary::Class_klass_loaded(), "java.lang.Class should be loaded");
 473   HandleMark hm(THREAD);
 474 
 475   if (!UseSharedSpaces) {
 476     // Cache the start of the static fields
 477     InstanceMirrorKlass::init_offset_of_static_fields();
 478   }
 479 
 480   GrowableArray &lt;Klass*&gt;* list = java_lang_Class::fixup_mirror_list();
 481   int list_length = list-&gt;length();
 482   for (int i = 0; i &lt; list_length; i++) {
 483     Klass* k = list-&gt;at(i);
 484     assert(k-&gt;is_klass(), "List should only hold classes");
 485     EXCEPTION_MARK;
 486     java_lang_Class::fixup_mirror(k, CATCH);
 487   }
 488   delete java_lang_Class::fixup_mirror_list();
 489   java_lang_Class::set_fixup_mirror_list(NULL);
 490 }
 491 
 492 #define assert_pll_locked(test) \
 493   assert(Heap_lock-&gt;test(), "Reference pending list access requires lock")
 494 
 495 #define assert_pll_ownership() assert_pll_locked(owned_by_self)
 496 
 497 oop Universe::reference_pending_list() {
 498   if (Thread::current()-&gt;is_VM_thread()) {
 499     assert_pll_locked(is_locked);
 500   } else {
 501     assert_pll_ownership();
 502   }
 503   return _reference_pending_list;
 504 }
 505 
 506 void Universe::set_reference_pending_list(oop list) {
 507   assert_pll_ownership();
 508   _reference_pending_list = list;
 509 }
 510 
 511 bool Universe::has_reference_pending_list() {
 512   assert_pll_ownership();
 513   return _reference_pending_list != NULL;
 514 }
 515 
 516 oop Universe::swap_reference_pending_list(oop list) {
 517   assert_pll_locked(is_locked);
 518   return Atomic::xchg(list, &amp;_reference_pending_list);
 519 }
 520 
 521 #undef assert_pll_locked
 522 #undef assert_pll_ownership
 523 
 524 // initialize_vtable could cause gc if
 525 // 1) we specified true to initialize_vtable and
 526 // 2) this ran after gc was enabled
 527 // In case those ever change we use handles for oops
 528 void Universe::reinitialize_vtable_of(Klass* ko, TRAPS) {
 529   // init vtable of k and all subclasses
 530   ko-&gt;vtable().initialize_vtable(false, CHECK);
 531   if (ko-&gt;is_instance_klass()) {
 532     for (Klass* sk = ko-&gt;subklass();
 533          sk != NULL;
 534          sk = sk-&gt;next_sibling()) {
 535       reinitialize_vtable_of(sk, CHECK);
 536     }
 537   }
 538 }
 539 
 540 
 541 void initialize_itable_for_klass(InstanceKlass* k, TRAPS) {
 542   k-&gt;itable().initialize_itable(false, CHECK);
 543 }
 544 
 545 
 546 void Universe::reinitialize_itables(TRAPS) {
 547   MutexLocker mcld(ClassLoaderDataGraph_lock);
 548   ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass, CHECK);
 549 }
 550 
 551 
 552 bool Universe::on_page_boundary(void* addr) {
 553   return is_aligned(addr, os::vm_page_size());
 554 }
 555 
 556 
 557 bool Universe::should_fill_in_stack_trace(Handle throwable) {
 558   // never attempt to fill in the stack trace of preallocated errors that do not have
 559   // backtrace. These errors are kept alive forever and may be "re-used" when all
 560   // preallocated errors with backtrace have been consumed. Also need to avoid
 561   // a potential loop which could happen if an out of memory occurs when attempting
 562   // to allocate the backtrace.
 563   return ((!oopDesc::equals(throwable(), Universe::_out_of_memory_error_java_heap)) &amp;&amp;
 564           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_metaspace))  &amp;&amp;
 565           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_class_metaspace))  &amp;&amp;
 566           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_array_size)) &amp;&amp;
 567           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_gc_overhead_limit)) &amp;&amp;
<a name="3" id="anc3"></a><span class="changed"> 568           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_realloc_objects)));</span>

 569 }
 570 
 571 
 572 oop Universe::gen_out_of_memory_error(oop default_err) {
 573   // generate an out of memory error:
 574   // - if there is a preallocated error and stack traces are available
 575   //   (j.l.Throwable is initialized), then return the preallocated
 576   //   error with a filled in stack trace, and with the message
 577   //   provided by the default error.
 578   // - otherwise, return the default error, without a stack trace.
 579   int next;
 580   if ((_preallocated_out_of_memory_error_avail_count &gt; 0) &amp;&amp;
 581       SystemDictionary::Throwable_klass()-&gt;is_initialized()) {
 582     next = (int)Atomic::add(-1, &amp;_preallocated_out_of_memory_error_avail_count);
 583     assert(next &lt; (int)PreallocatedOutOfMemoryErrorCount, "avail count is corrupt");
 584   } else {
 585     next = -1;
 586   }
 587   if (next &lt; 0) {
 588     // all preallocated errors have been used.
 589     // return default
 590     return default_err;
 591   } else {
 592     Thread* THREAD = Thread::current();
 593     Handle default_err_h(THREAD, default_err);
 594     // get the error object at the slot and set set it to NULL so that the
 595     // array isn't keeping it alive anymore.
 596     Handle exc(THREAD, preallocated_out_of_memory_errors()-&gt;obj_at(next));
 597     assert(exc() != NULL, "slot has been used already");
 598     preallocated_out_of_memory_errors()-&gt;obj_at_put(next, NULL);
 599 
 600     // use the message from the default error
 601     oop msg = java_lang_Throwable::message(default_err_h());
 602     assert(msg != NULL, "no message");
 603     java_lang_Throwable::set_message(exc(), msg);
 604 
 605     // populate the stack trace and return it.
 606     java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(exc);
 607     return exc();
 608   }
 609 }
 610 
 611 intptr_t Universe::_non_oop_bits = 0;
 612 
 613 void* Universe::non_oop_word() {
 614   // Neither the high bits nor the low bits of this value is allowed
 615   // to look like (respectively) the high or low bits of a real oop.
 616   //
 617   // High and low are CPU-specific notions, but low always includes
 618   // the low-order bit.  Since oops are always aligned at least mod 4,
 619   // setting the low-order bit will ensure that the low half of the
 620   // word will never look like that of a real oop.
 621   //
 622   // Using the OS-supplied non-memory-address word (usually 0 or -1)
 623   // will take care of the high bits, however many there are.
 624 
 625   if (_non_oop_bits == 0) {
 626     _non_oop_bits = (intptr_t)os::non_memory_address_word() | 1;
 627   }
 628 
 629   return (void*)_non_oop_bits;
 630 }
 631 
 632 jint universe_init() {
 633   assert(!Universe::_fully_initialized, "called after initialize_vtables");
 634   guarantee(1 &lt;&lt; LogHeapWordSize == sizeof(HeapWord),
 635          "LogHeapWordSize is incorrect.");
 636   guarantee(sizeof(oop) &gt;= sizeof(HeapWord), "HeapWord larger than oop?");
 637   guarantee(sizeof(oop) % sizeof(HeapWord) == 0,
 638             "oop size is not not a multiple of HeapWord size");
 639 
 640   TraceTime timer("Genesis", TRACETIME_LOG(Info, startuptime));
 641 
 642   JavaClasses::compute_hard_coded_offsets();
 643 
 644   jint status = Universe::initialize_heap();
 645   if (status != JNI_OK) {
 646     return status;
 647   }
 648 
 649   SystemDictionary::initialize_oop_storage();
 650 
 651   Metaspace::global_initialize();
 652 
 653   // Initialize performance counters for metaspaces
 654   MetaspaceCounters::initialize_performance_counters();
 655   CompressedClassSpaceCounters::initialize_performance_counters();
 656 
 657   AOTLoader::universe_init();
 658 
 659   // Checks 'AfterMemoryInit' constraints.
 660   if (!JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterMemoryInit)) {
 661     return JNI_EINVAL;
 662   }
 663 
 664   // Create memory for metadata.  Must be after initializing heap for
 665   // DumpSharedSpaces.
 666   ClassLoaderData::init_null_class_loader_data();
 667 
 668   // We have a heap so create the Method* caches before
 669   // Metaspace::initialize_shared_spaces() tries to populate them.
 670   Universe::_finalizer_register_cache = new LatestMethodCache();
 671   Universe::_loader_addClass_cache    = new LatestMethodCache();
 672   Universe::_pd_implies_cache         = new LatestMethodCache();
 673   Universe::_throw_illegal_access_error_cache = new LatestMethodCache();
 674   Universe::_do_stack_walk_cache = new LatestMethodCache();
 675 
 676 #if INCLUDE_CDS
 677   if (UseSharedSpaces) {
 678     // Read the data structures supporting the shared spaces (shared
 679     // system dictionary, symbol table, etc.).  After that, access to
 680     // the file (other than the mapped regions) is no longer needed, and
 681     // the file is closed. Closing the file does not affect the
 682     // currently mapped regions.
 683     MetaspaceShared::initialize_shared_spaces();
 684     StringTable::create_table();
 685   } else
 686 #endif
 687   {
 688     SymbolTable::create_table();
 689     StringTable::create_table();
 690 
 691 #if INCLUDE_CDS
 692     if (DumpSharedSpaces) {
 693       MetaspaceShared::prepare_for_dumping();
 694     }
 695 #endif
 696   }
 697   if (strlen(VerifySubSet) &gt; 0) {
 698     Universe::initialize_verify_flags();
 699   }
 700 
 701   ResolvedMethodTable::create_table();
 702 
 703   return JNI_OK;
 704 }
 705 
 706 CollectedHeap* Universe::create_heap() {
 707   assert(_collectedHeap == NULL, "Heap already created");
 708   return GCConfig::arguments()-&gt;create_heap();
 709 }
 710 
 711 // Choose the heap base address and oop encoding mode
 712 // when compressed oops are used:
 713 // Unscaled  - Use 32-bits oops without encoding when
 714 //     NarrowOopHeapBaseMin + heap_size &lt; 4Gb
 715 // ZeroBased - Use zero based compressed oops with encoding when
 716 //     NarrowOopHeapBaseMin + heap_size &lt; 32Gb
 717 // HeapBased - Use compressed oops with heap base + encoding.
 718 
 719 jint Universe::initialize_heap() {
 720   _collectedHeap = create_heap();
 721   jint status = _collectedHeap-&gt;initialize();
 722   if (status != JNI_OK) {
 723     return status;
 724   }
 725   log_info(gc)("Using %s", _collectedHeap-&gt;name());
 726 
 727   ThreadLocalAllocBuffer::set_max_size(Universe::heap()-&gt;max_tlab_size());
 728 
 729 #ifdef _LP64
 730   if (UseCompressedOops) {
 731     // Subtract a page because something can get allocated at heap base.
 732     // This also makes implicit null checking work, because the
 733     // memory+1 page below heap_base needs to cause a signal.
 734     // See needs_explicit_null_check.
 735     // Only set the heap base for compressed oops because it indicates
 736     // compressed oops for pstack code.
 737     if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &gt; UnscaledOopHeapMax) {
 738       // Didn't reserve heap below 4Gb.  Must shift.
 739       Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes);
 740     }
 741     if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &lt;= OopEncodingHeapMax) {
 742       // Did reserve heap below 32Gb. Can use base == 0;
 743       Universe::set_narrow_oop_base(0);
 744     }
 745     AOTLoader::set_narrow_oop_shift();
 746 
 747     Universe::set_narrow_ptrs_base(Universe::narrow_oop_base());
 748 
 749     LogTarget(Info, gc, heap, coops) lt;
 750     if (lt.is_enabled()) {
 751       ResourceMark rm;
 752       LogStream ls(lt);
 753       Universe::print_compressed_oops_mode(&amp;ls);
 754     }
 755 
 756     // Tell tests in which mode we run.
 757     Arguments::PropertyList_add(new SystemProperty("java.vm.compressedOopsMode",
 758                                                    narrow_oop_mode_to_string(narrow_oop_mode()),
 759                                                    false));
 760   }
 761   // Universe::narrow_oop_base() is one page below the heap.
 762   assert((intptr_t)Universe::narrow_oop_base() &lt;= (intptr_t)(Universe::heap()-&gt;base() -
 763          os::vm_page_size()) ||
 764          Universe::narrow_oop_base() == NULL, "invalid value");
 765   assert(Universe::narrow_oop_shift() == LogMinObjAlignmentInBytes ||
 766          Universe::narrow_oop_shift() == 0, "invalid value");
 767 #endif
 768 
 769   // We will never reach the CATCH below since Exceptions::_throw will cause
 770   // the VM to exit if an exception is thrown during initialization
 771 
 772   if (UseTLAB) {
 773     assert(Universe::heap()-&gt;supports_tlab_allocation(),
 774            "Should support thread-local allocation buffers");
 775     ThreadLocalAllocBuffer::startup_initialization();
 776   }
 777   return JNI_OK;
 778 }
 779 
 780 void Universe::print_compressed_oops_mode(outputStream* st) {
 781   st-&gt;print("Heap address: " PTR_FORMAT ", size: " SIZE_FORMAT " MB",
 782             p2i(Universe::heap()-&gt;base()), Universe::heap()-&gt;reserved_region().byte_size()/M);
 783 
 784   st-&gt;print(", Compressed Oops mode: %s", narrow_oop_mode_to_string(narrow_oop_mode()));
 785 
 786   if (Universe::narrow_oop_base() != 0) {
 787     st-&gt;print(": " PTR_FORMAT, p2i(Universe::narrow_oop_base()));
 788   }
 789 
 790   if (Universe::narrow_oop_shift() != 0) {
 791     st-&gt;print(", Oop shift amount: %d", Universe::narrow_oop_shift());
 792   }
 793 
 794   if (!Universe::narrow_oop_use_implicit_null_checks()) {
 795     st-&gt;print(", no protected page in front of the heap");
 796   }
 797   st-&gt;cr();
 798 }
 799 
 800 ReservedSpace Universe::reserve_heap(size_t heap_size, size_t alignment) {
 801 
 802   assert(alignment &lt;= Arguments::conservative_max_heap_alignment(),
 803          "actual alignment " SIZE_FORMAT " must be within maximum heap alignment " SIZE_FORMAT,
 804          alignment, Arguments::conservative_max_heap_alignment());
 805 
 806   size_t total_reserved = align_up(heap_size, alignment);
 807   assert(!UseCompressedOops || (total_reserved &lt;= (OopEncodingHeapMax - os::vm_page_size())),
 808       "heap size is too big for compressed oops");
 809 
 810   bool use_large_pages = UseLargePages &amp;&amp; is_aligned(alignment, os::large_page_size());
 811   assert(!UseLargePages
 812       || UseParallelGC
 813       || use_large_pages, "Wrong alignment to use large pages");
 814 
 815   // Now create the space.
 816   ReservedHeapSpace total_rs(total_reserved, alignment, use_large_pages, AllocateHeapAt);
 817 
 818   if (total_rs.is_reserved()) {
 819     assert((total_reserved == total_rs.size()) &amp;&amp; ((uintptr_t)total_rs.base() % alignment == 0),
 820            "must be exactly of required size and alignment");
 821     // We are good.
 822 
 823     if (UseCompressedOops) {
 824       // Universe::initialize_heap() will reset this to NULL if unscaled
 825       // or zero-based narrow oops are actually used.
 826       // Else heap start and base MUST differ, so that NULL can be encoded nonambigous.
 827       Universe::set_narrow_oop_base((address)total_rs.compressed_oop_base());
 828     }
 829 
 830     if (AllocateHeapAt != NULL) {
 831       log_info(gc,heap)("Successfully allocated Java heap at location %s", AllocateHeapAt);
 832     }
 833     return total_rs;
 834   }
 835 
 836   vm_exit_during_initialization(
 837     err_msg("Could not reserve enough space for " SIZE_FORMAT "KB object heap",
 838             total_reserved/K));
 839 
 840   // satisfy compiler
 841   ShouldNotReachHere();
 842   return ReservedHeapSpace(0, 0, false);
 843 }
 844 
 845 
 846 // It's the caller's responsibility to ensure glitch-freedom
 847 // (if required).
 848 void Universe::update_heap_info_at_gc() {
 849   _heap_capacity_at_last_gc = heap()-&gt;capacity();
 850   _heap_used_at_last_gc     = heap()-&gt;used();
 851 }
 852 
 853 
 854 const char* Universe::narrow_oop_mode_to_string(Universe::NARROW_OOP_MODE mode) {
 855   switch (mode) {
 856     case UnscaledNarrowOop:
 857       return "32-bit";
 858     case ZeroBasedNarrowOop:
 859       return "Zero based";
 860     case DisjointBaseNarrowOop:
 861       return "Non-zero disjoint base";
 862     case HeapBasedNarrowOop:
 863       return "Non-zero based";
 864     default:
 865       ShouldNotReachHere();
 866       return "";
 867   }
 868 }
 869 
 870 
 871 Universe::NARROW_OOP_MODE Universe::narrow_oop_mode() {
 872   if (narrow_oop_base_disjoint()) {
 873     return DisjointBaseNarrowOop;
 874   }
 875 
 876   if (narrow_oop_base() != 0) {
 877     return HeapBasedNarrowOop;
 878   }
 879 
 880   if (narrow_oop_shift() != 0) {
 881     return ZeroBasedNarrowOop;
 882   }
 883 
 884   return UnscaledNarrowOop;
 885 }
 886 
 887 void initialize_known_method(LatestMethodCache* method_cache,
 888                              InstanceKlass* ik,
 889                              const char* method,
 890                              Symbol* signature,
 891                              bool is_static, TRAPS)
 892 {
 893   TempNewSymbol name = SymbolTable::new_symbol(method, CHECK);
 894   Method* m = NULL;
 895   // The klass must be linked before looking up the method.
 896   if (!ik-&gt;link_class_or_fail(THREAD) ||
 897       ((m = ik-&gt;find_method(name, signature)) == NULL) ||
 898       is_static != m-&gt;is_static()) {
 899     ResourceMark rm(THREAD);
 900     // NoSuchMethodException doesn't actually work because it tries to run the
 901     // &lt;init&gt; function before java_lang_Class is linked. Print error and exit.
 902     vm_exit_during_initialization(err_msg("Unable to link/verify %s.%s method",
 903                                  ik-&gt;name()-&gt;as_C_string(), method));
 904   }
 905   method_cache-&gt;init(ik, m);
 906 }
 907 
 908 void Universe::initialize_known_methods(TRAPS) {
 909   // Set up static method for registering finalizers
 910   initialize_known_method(_finalizer_register_cache,
 911                           SystemDictionary::Finalizer_klass(),
 912                           "register",
 913                           vmSymbols::object_void_signature(), true, CHECK);
 914 
 915   initialize_known_method(_throw_illegal_access_error_cache,
 916                           SystemDictionary::internal_Unsafe_klass(),
 917                           "throwIllegalAccessError",
 918                           vmSymbols::void_method_signature(), true, CHECK);
 919 
 920   // Set up method for registering loaded classes in class loader vector
 921   initialize_known_method(_loader_addClass_cache,
 922                           SystemDictionary::ClassLoader_klass(),
 923                           "addClass",
 924                           vmSymbols::class_void_signature(), false, CHECK);
 925 
 926   // Set up method for checking protection domain
 927   initialize_known_method(_pd_implies_cache,
 928                           SystemDictionary::ProtectionDomain_klass(),
 929                           "impliesCreateAccessControlContext",
 930                           vmSymbols::void_boolean_signature(), false, CHECK);
 931 
 932   // Set up method for stack walking
 933   initialize_known_method(_do_stack_walk_cache,
 934                           SystemDictionary::AbstractStackWalker_klass(),
 935                           "doStackWalk",
 936                           vmSymbols::doStackWalk_signature(), false, CHECK);
 937 }
 938 
 939 void universe2_init() {
 940   EXCEPTION_MARK;
 941   Universe::genesis(CATCH);
 942 }
 943 
 944 // Set after initialization of the module runtime, call_initModuleRuntime
 945 void universe_post_module_init() {
 946   Universe::_module_initialized = true;
 947 }
 948 
 949 bool universe_post_init() {
 950   assert(!is_init_completed(), "Error: initialization not yet completed!");
 951   Universe::_fully_initialized = true;
 952   EXCEPTION_MARK;
 953   { ResourceMark rm;
 954     Interpreter::initialize();      // needed for interpreter entry points
 955     if (!UseSharedSpaces) {
 956       HandleMark hm(THREAD);
 957       Klass* ok = SystemDictionary::Object_klass();
 958       Universe::reinitialize_vtable_of(ok, CHECK_false);
 959       Universe::reinitialize_itables(CHECK_false);
 960     }
 961   }
 962 
 963   HandleMark hm(THREAD);
 964   // Setup preallocated empty java.lang.Class array
 965   Universe::_the_empty_class_klass_array = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_false);
 966 
 967   // Setup preallocated OutOfMemoryError errors
 968   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_OutOfMemoryError(), true, CHECK_false);
 969   InstanceKlass* ik = InstanceKlass::cast(k);
 970   Universe::_out_of_memory_error_java_heap = ik-&gt;allocate_instance(CHECK_false);
 971   Universe::_out_of_memory_error_metaspace = ik-&gt;allocate_instance(CHECK_false);
 972   Universe::_out_of_memory_error_class_metaspace = ik-&gt;allocate_instance(CHECK_false);
 973   Universe::_out_of_memory_error_array_size = ik-&gt;allocate_instance(CHECK_false);
 974   Universe::_out_of_memory_error_gc_overhead_limit =
 975     ik-&gt;allocate_instance(CHECK_false);
 976   Universe::_out_of_memory_error_realloc_objects = ik-&gt;allocate_instance(CHECK_false);
<a name="4" id="anc4"></a>
 977 
 978   // Setup preallocated cause message for delayed StackOverflowError
 979   if (StackReservedPages &gt; 0) {
 980     Universe::_delayed_stack_overflow_error_message =
 981       java_lang_String::create_oop_from_str("Delayed StackOverflowError due to ReservedStackAccess annotated method", CHECK_false);
 982   }
 983 
 984   // Setup preallocated NullPointerException
 985   // (this is currently used for a cheap &amp; dirty solution in compiler exception handling)
 986   k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_NullPointerException(), true, CHECK_false);
 987   Universe::_null_ptr_exception_instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
 988   // Setup preallocated ArithmeticException
 989   // (this is currently used for a cheap &amp; dirty solution in compiler exception handling)
 990   k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ArithmeticException(), true, CHECK_false);
 991   Universe::_arithmetic_exception_instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
 992   // Virtual Machine Error for when we get into a situation we can't resolve
 993   k = SystemDictionary::resolve_or_fail(
 994     vmSymbols::java_lang_VirtualMachineError(), true, CHECK_false);
 995   bool linked = InstanceKlass::cast(k)-&gt;link_class_or_fail(CHECK_false);
 996   if (!linked) {
 997      tty-&gt;print_cr("Unable to link/verify VirtualMachineError class");
 998      return false; // initialization failed
 999   }
1000   Universe::_virtual_machine_error_instance =
1001     InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
1002 
1003   Universe::_vm_exception = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
1004 
1005   Handle msg = java_lang_String::create_from_str("Java heap space", CHECK_false);
1006   java_lang_Throwable::set_message(Universe::_out_of_memory_error_java_heap, msg());
1007 
1008   msg = java_lang_String::create_from_str("Metaspace", CHECK_false);
1009   java_lang_Throwable::set_message(Universe::_out_of_memory_error_metaspace, msg());
1010   msg = java_lang_String::create_from_str("Compressed class space", CHECK_false);
1011   java_lang_Throwable::set_message(Universe::_out_of_memory_error_class_metaspace, msg());
1012 
1013   msg = java_lang_String::create_from_str("Requested array size exceeds VM limit", CHECK_false);
1014   java_lang_Throwable::set_message(Universe::_out_of_memory_error_array_size, msg());
1015 
1016   msg = java_lang_String::create_from_str("GC overhead limit exceeded", CHECK_false);
1017   java_lang_Throwable::set_message(Universe::_out_of_memory_error_gc_overhead_limit, msg());
1018 
1019   msg = java_lang_String::create_from_str("Java heap space: failed reallocation of scalar replaced objects", CHECK_false);
1020   java_lang_Throwable::set_message(Universe::_out_of_memory_error_realloc_objects, msg());
1021 
<a name="5" id="anc5"></a>


1022   msg = java_lang_String::create_from_str("/ by zero", CHECK_false);
1023   java_lang_Throwable::set_message(Universe::_arithmetic_exception_instance, msg());
1024 
1025   // Setup the array of errors that have preallocated backtrace
1026   k = Universe::_out_of_memory_error_java_heap-&gt;klass();
1027   assert(k-&gt;name() == vmSymbols::java_lang_OutOfMemoryError(), "should be out of memory error");
1028   ik = InstanceKlass::cast(k);
1029 
1030   int len = (StackTraceInThrowable) ? (int)PreallocatedOutOfMemoryErrorCount : 0;
1031   Universe::_preallocated_out_of_memory_error_array = oopFactory::new_objArray(ik, len, CHECK_false);
1032   for (int i=0; i&lt;len; i++) {
1033     oop err = ik-&gt;allocate_instance(CHECK_false);
1034     Handle err_h = Handle(THREAD, err);
1035     java_lang_Throwable::allocate_backtrace(err_h, CHECK_false);
1036     Universe::preallocated_out_of_memory_errors()-&gt;obj_at_put(i, err_h());
1037   }
1038   Universe::_preallocated_out_of_memory_error_avail_count = (jint)len;
1039 
1040   Universe::initialize_known_methods(CHECK_false);
1041 
1042   // This needs to be done before the first scavenge/gc, since
1043   // it's an input to soft ref clearing policy.
1044   {
1045     MutexLocker x(Heap_lock);
1046     Universe::update_heap_info_at_gc();
1047   }
1048 
1049   // ("weak") refs processing infrastructure initialization
1050   Universe::heap()-&gt;post_initialize();
1051 
1052   MemoryService::add_metaspace_memory_pools();
1053 
1054   MemoryService::set_universe_heap(Universe::heap());
1055 #if INCLUDE_CDS
1056   MetaspaceShared::post_initialize(CHECK_false);
1057 #endif
1058   return true;
1059 }
1060 
1061 
1062 void Universe::compute_base_vtable_size() {
1063   _base_vtable_size = ClassLoader::compute_Object_vtable();
1064 }
1065 
1066 void Universe::print_on(outputStream* st) {
1067   GCMutexLocker hl(Heap_lock); // Heap_lock might be locked by caller thread.
1068   st-&gt;print_cr("Heap");
1069   heap()-&gt;print_on(st);
1070 }
1071 
1072 void Universe::print_heap_at_SIGBREAK() {
1073   if (PrintHeapAtSIGBREAK) {
1074     print_on(tty);
1075     tty-&gt;cr();
1076     tty-&gt;flush();
1077   }
1078 }
1079 
1080 void Universe::print_heap_before_gc() {
1081   LogTarget(Debug, gc, heap) lt;
1082   if (lt.is_enabled()) {
1083     LogStream ls(lt);
1084     ls.print("Heap before GC invocations=%u (full %u):", heap()-&gt;total_collections(), heap()-&gt;total_full_collections());
1085     ResourceMark rm;
1086     heap()-&gt;print_on(&amp;ls);
1087   }
1088 }
1089 
1090 void Universe::print_heap_after_gc() {
1091   LogTarget(Debug, gc, heap) lt;
1092   if (lt.is_enabled()) {
1093     LogStream ls(lt);
1094     ls.print("Heap after GC invocations=%u (full %u):", heap()-&gt;total_collections(), heap()-&gt;total_full_collections());
1095     ResourceMark rm;
1096     heap()-&gt;print_on(&amp;ls);
1097   }
1098 }
1099 
1100 void Universe::initialize_verify_flags() {
1101   verify_flags = 0;
1102   const char delimiter[] = " ,";
1103 
1104   size_t length = strlen(VerifySubSet);
1105   char* subset_list = NEW_C_HEAP_ARRAY(char, length + 1, mtInternal);
1106   strncpy(subset_list, VerifySubSet, length + 1);
1107 
1108   char* token = strtok(subset_list, delimiter);
1109   while (token != NULL) {
1110     if (strcmp(token, "threads") == 0) {
1111       verify_flags |= Verify_Threads;
1112     } else if (strcmp(token, "heap") == 0) {
1113       verify_flags |= Verify_Heap;
1114     } else if (strcmp(token, "symbol_table") == 0) {
1115       verify_flags |= Verify_SymbolTable;
1116     } else if (strcmp(token, "string_table") == 0) {
1117       verify_flags |= Verify_StringTable;
1118     } else if (strcmp(token, "codecache") == 0) {
1119       verify_flags |= Verify_CodeCache;
1120     } else if (strcmp(token, "dictionary") == 0) {
1121       verify_flags |= Verify_SystemDictionary;
1122     } else if (strcmp(token, "classloader_data_graph") == 0) {
1123       verify_flags |= Verify_ClassLoaderDataGraph;
1124     } else if (strcmp(token, "metaspace") == 0) {
1125       verify_flags |= Verify_MetaspaceUtils;
1126     } else if (strcmp(token, "jni_handles") == 0) {
1127       verify_flags |= Verify_JNIHandles;
1128     } else if (strcmp(token, "codecache_oops") == 0) {
1129       verify_flags |= Verify_CodeCacheOops;
1130     } else {
1131       vm_exit_during_initialization(err_msg("VerifySubSet: \'%s\' memory sub-system is unknown, please correct it", token));
1132     }
1133     token = strtok(NULL, delimiter);
1134   }
1135   FREE_C_HEAP_ARRAY(char, subset_list);
1136 }
1137 
1138 bool Universe::should_verify_subset(uint subset) {
1139   if (verify_flags &amp; subset) {
1140     return true;
1141   }
1142   return false;
1143 }
1144 
1145 void Universe::verify(VerifyOption option, const char* prefix) {
1146   // The use of _verify_in_progress is a temporary work around for
1147   // 6320749.  Don't bother with a creating a class to set and clear
1148   // it since it is only used in this method and the control flow is
1149   // straight forward.
1150   _verify_in_progress = true;
1151 
1152   COMPILER2_PRESENT(
1153     assert(!DerivedPointerTable::is_active(),
1154          "DPT should not be active during verification "
1155          "(of thread stacks below)");
1156   )
1157 
1158   ResourceMark rm;
1159   HandleMark hm;  // Handles created during verification can be zapped
1160   _verify_count++;
1161 
1162   FormatBuffer&lt;&gt; title("Verifying %s", prefix);
1163   GCTraceTime(Info, gc, verify) tm(title.buffer());
1164   if (should_verify_subset(Verify_Threads)) {
1165     log_debug(gc, verify)("Threads");
1166     Threads::verify();
1167   }
1168   if (should_verify_subset(Verify_Heap)) {
1169     log_debug(gc, verify)("Heap");
1170     heap()-&gt;verify(option);
1171   }
1172   if (should_verify_subset(Verify_SymbolTable)) {
1173     log_debug(gc, verify)("SymbolTable");
1174     SymbolTable::verify();
1175   }
1176   if (should_verify_subset(Verify_StringTable)) {
1177     log_debug(gc, verify)("StringTable");
1178     StringTable::verify();
1179   }
1180   if (should_verify_subset(Verify_CodeCache)) {
1181   {
1182     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1183     log_debug(gc, verify)("CodeCache");
1184     CodeCache::verify();
1185   }
1186   }
1187   if (should_verify_subset(Verify_SystemDictionary)) {
1188     log_debug(gc, verify)("SystemDictionary");
1189     SystemDictionary::verify();
1190   }
1191 #ifndef PRODUCT
1192   if (should_verify_subset(Verify_ClassLoaderDataGraph)) {
1193     log_debug(gc, verify)("ClassLoaderDataGraph");
1194     ClassLoaderDataGraph::verify();
1195   }
1196 #endif
1197   if (should_verify_subset(Verify_MetaspaceUtils)) {
1198     log_debug(gc, verify)("MetaspaceUtils");
1199     MetaspaceUtils::verify_free_chunks();
1200   }
1201   if (should_verify_subset(Verify_JNIHandles)) {
1202     log_debug(gc, verify)("JNIHandles");
1203     JNIHandles::verify();
1204   }
1205   if (should_verify_subset(Verify_CodeCacheOops)) {
1206     log_debug(gc, verify)("CodeCache Oops");
1207     CodeCache::verify_oops();
1208   }
1209 
1210   _verify_in_progress = false;
1211 }
1212 
1213 
1214 #ifndef PRODUCT
1215 void Universe::calculate_verify_data(HeapWord* low_boundary, HeapWord* high_boundary) {
1216   assert(low_boundary &lt; high_boundary, "bad interval");
1217 
1218   // decide which low-order bits we require to be clear:
1219   size_t alignSize = MinObjAlignmentInBytes;
1220   size_t min_object_size = CollectedHeap::min_fill_size();
1221 
1222   // make an inclusive limit:
1223   uintptr_t max = (uintptr_t)high_boundary - min_object_size*wordSize;
1224   uintptr_t min = (uintptr_t)low_boundary;
1225   assert(min &lt; max, "bad interval");
1226   uintptr_t diff = max ^ min;
1227 
1228   // throw away enough low-order bits to make the diff vanish
1229   uintptr_t mask = (uintptr_t)(-1);
1230   while ((mask &amp; diff) != 0)
1231     mask &lt;&lt;= 1;
1232   uintptr_t bits = (min &amp; mask);
1233   assert(bits == (max &amp; mask), "correct mask");
1234   // check an intermediate value between min and max, just to make sure:
1235   assert(bits == ((min + (max-min)/2) &amp; mask), "correct mask");
1236 
1237   // require address alignment, too:
1238   mask |= (alignSize - 1);
1239 
1240   if (!(_verify_oop_mask == 0 &amp;&amp; _verify_oop_bits == (uintptr_t)-1)) {
1241     assert(_verify_oop_mask == mask &amp;&amp; _verify_oop_bits == bits, "mask stability");
1242   }
1243   _verify_oop_mask = mask;
1244   _verify_oop_bits = bits;
1245 }
1246 
1247 // Oop verification (see MacroAssembler::verify_oop)
1248 
1249 uintptr_t Universe::verify_oop_mask() {
1250   MemRegion m = heap()-&gt;reserved_region();
1251   calculate_verify_data(m.start(), m.end());
1252   return _verify_oop_mask;
1253 }
1254 
1255 uintptr_t Universe::verify_oop_bits() {
1256   MemRegion m = heap()-&gt;reserved_region();
1257   calculate_verify_data(m.start(), m.end());
1258   return _verify_oop_bits;
1259 }
1260 
1261 uintptr_t Universe::verify_mark_mask() {
1262   return markOopDesc::lock_mask_in_place;
1263 }
1264 
1265 uintptr_t Universe::verify_mark_bits() {
1266   intptr_t mask = verify_mark_mask();
1267   intptr_t bits = (intptr_t)markOopDesc::prototype();
1268   assert((bits &amp; ~mask) == 0, "no stray header bits");
1269   return bits;
1270 }
1271 #endif // PRODUCT
1272 
1273 
1274 void Universe::compute_verify_oop_data() {
1275   verify_oop_mask();
1276   verify_oop_bits();
1277   verify_mark_mask();
1278   verify_mark_bits();
1279 }
1280 
1281 
1282 void LatestMethodCache::init(Klass* k, Method* m) {
1283   if (!UseSharedSpaces) {
1284     _klass = k;
1285   }
1286 #ifndef PRODUCT
1287   else {
1288     // sharing initilization should have already set up _klass
1289     assert(_klass != NULL, "just checking");
1290   }
1291 #endif
1292 
1293   _method_idnum = m-&gt;method_idnum();
1294   assert(_method_idnum &gt;= 0, "sanity check");
1295 }
1296 
1297 
1298 Method* LatestMethodCache::get_method() {
1299   if (klass() == NULL) return NULL;
1300   InstanceKlass* ik = InstanceKlass::cast(klass());
1301   Method* m = ik-&gt;method_with_idnum(method_idnum());
1302   assert(m != NULL, "sanity check");
1303   return m;
1304 }
1305 
1306 
1307 #ifdef ASSERT
1308 // Release dummy object(s) at bottom of heap
1309 bool Universe::release_fullgc_alot_dummy() {
1310   MutexLocker ml(FullGCALot_lock);
1311   if (_fullgc_alot_dummy_array != NULL) {
1312     if (_fullgc_alot_dummy_next &gt;= _fullgc_alot_dummy_array-&gt;length()) {
1313       // No more dummies to release, release entire array instead
1314       _fullgc_alot_dummy_array = NULL;
1315       return false;
1316     }
1317     if (!UseConcMarkSweepGC) {
1318       // Release dummy at bottom of old generation
1319       _fullgc_alot_dummy_array-&gt;obj_at_put(_fullgc_alot_dummy_next++, NULL);
1320     }
1321     // Release dummy at bottom of permanent generation
1322     _fullgc_alot_dummy_array-&gt;obj_at_put(_fullgc_alot_dummy_next++, NULL);
1323   }
1324   return true;
1325 }
1326 
1327 #endif // ASSERT
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="6" type="hidden" /></form></body></html>
