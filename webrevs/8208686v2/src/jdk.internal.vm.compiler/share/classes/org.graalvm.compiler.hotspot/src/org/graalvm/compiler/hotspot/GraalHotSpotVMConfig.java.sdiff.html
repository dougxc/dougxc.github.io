<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>open Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../src/jdk.aot/share/classes/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/BinaryContainer.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotBackend.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 631     public final long jlongDisjointArraycopy = getFieldValue("StubRoutines::_jlong_disjoint_arraycopy", Long.class, "address");
 632     public final long oopDisjointArraycopy = getFieldValue("StubRoutines::_oop_disjoint_arraycopy", Long.class, "address");
 633     public final long oopDisjointArraycopyUninit = getFieldValue("StubRoutines::_oop_disjoint_arraycopy_uninit", Long.class, "address");
 634     public final long jbyteAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jbyte_arraycopy", Long.class, "address");
 635     public final long jshortAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jshort_arraycopy", Long.class, "address");
 636     public final long jintAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jint_arraycopy", Long.class, "address");
 637     public final long jlongAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jlong_arraycopy", Long.class, "address");
 638     public final long oopAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_oop_arraycopy", Long.class, "address");
 639     public final long oopAlignedArraycopyUninit = getFieldValue("StubRoutines::_arrayof_oop_arraycopy_uninit", Long.class, "address");
 640     public final long jbyteAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jbyte_disjoint_arraycopy", Long.class, "address");
 641     public final long jshortAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jshort_disjoint_arraycopy", Long.class, "address");
 642     public final long jintAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jint_disjoint_arraycopy", Long.class, "address");
 643     public final long jlongAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jlong_disjoint_arraycopy", Long.class, "address");
 644     public final long oopAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_oop_disjoint_arraycopy", Long.class, "address");
 645     public final long oopAlignedDisjointArraycopyUninit = getFieldValue("StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit", Long.class, "address");
 646     public final long checkcastArraycopy = getFieldValue("StubRoutines::_checkcast_arraycopy", Long.class, "address");
 647     public final long checkcastArraycopyUninit = getFieldValue("StubRoutines::_checkcast_arraycopy_uninit", Long.class, "address");
 648     public final long unsafeArraycopy = getFieldValue("StubRoutines::_unsafe_arraycopy", Long.class, "address");
 649     public final long genericArraycopy = getFieldValue("StubRoutines::_generic_arraycopy", Long.class, "address");
 650 

 651     public final long newInstanceAddress = getAddress("JVMCIRuntime::new_instance");
 652     public final long newArrayAddress = getAddress("JVMCIRuntime::new_array");
 653     public final long newMultiArrayAddress = getAddress("JVMCIRuntime::new_multi_array");
<span class="changed"> 654     public final long dynamicNewArrayAddress = getAddress("JVMCIRuntime::dynamic_new_array");</span>
<span class="changed"> 655     public final long dynamicNewInstanceAddress = getAddress("JVMCIRuntime::dynamic_new_instance");</span>





















 656 
 657     public final long threadIsInterruptedAddress = getAddress("JVMCIRuntime::thread_is_interrupted");
 658     public final long vmMessageAddress = getAddress("JVMCIRuntime::vm_message");
 659     public final long identityHashCodeAddress = getAddress("JVMCIRuntime::identity_hash_code");
 660     public final long exceptionHandlerForPcAddress = getAddress("JVMCIRuntime::exception_handler_for_pc");
 661     public final long monitorenterAddress = getAddress("JVMCIRuntime::monitorenter");
 662     public final long monitorexitAddress = getAddress("JVMCIRuntime::monitorexit");
 663     public final long notifyAddress = getAddress("JVMCIRuntime::object_notify", 0L);
 664     public final long notifyAllAddress = getAddress("JVMCIRuntime::object_notifyAll", 0L);
 665     public final long throwAndPostJvmtiExceptionAddress = getAddress("JVMCIRuntime::throw_and_post_jvmti_exception");
 666     public final long throwKlassExternalNameExceptionAddress = getAddress("JVMCIRuntime::throw_klass_external_name_exception");
 667     public final long throwClassCastExceptionAddress = getAddress("JVMCIRuntime::throw_class_cast_exception");
 668     public final long logPrimitiveAddress = getAddress("JVMCIRuntime::log_primitive");
 669     public final long logObjectAddress = getAddress("JVMCIRuntime::log_object");
 670     public final long logPrintfAddress = getAddress("JVMCIRuntime::log_printf");
 671     public final long vmErrorAddress = getAddress("JVMCIRuntime::vm_error");
 672     public final long loadAndClearExceptionAddress = getAddress("JVMCIRuntime::load_and_clear_exception");
 673     public final long writeBarrierPreAddress = getAddress("JVMCIRuntime::write_barrier_pre");
 674     public final long writeBarrierPostAddress = getAddress("JVMCIRuntime::write_barrier_post");
 675     public final long validateObject = getAddress("JVMCIRuntime::validate_object");

</pre><hr></hr><pre>
 740      */
 741     public final int MARKID_HEAP_TOP_ADDRESS = getConstant("CodeInstaller::HEAP_TOP_ADDRESS", Integer.class, 17);
 742     public final int MARKID_HEAP_END_ADDRESS = getConstant("CodeInstaller::HEAP_END_ADDRESS", Integer.class, 18);
 743     public final int MARKID_NARROW_KLASS_BASE_ADDRESS = getConstant("CodeInstaller::NARROW_KLASS_BASE_ADDRESS", Integer.class, 19);
 744     public final int MARKID_NARROW_OOP_BASE_ADDRESS = getConstant("CodeInstaller::NARROW_OOP_BASE_ADDRESS", Integer.class, 20);
 745     public final int MARKID_CRC_TABLE_ADDRESS = getConstant("CodeInstaller::CRC_TABLE_ADDRESS", Integer.class, 21);
 746     public final int MARKID_LOG_OF_HEAP_REGION_GRAIN_BYTES = getConstant("CodeInstaller::LOG_OF_HEAP_REGION_GRAIN_BYTES", Integer.class, 22);
 747     public final int MARKID_INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED = getConstant("CodeInstaller::INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED", Integer.class, 23);
 748 
 749     // Checkstyle: resume
 750 
 751     protected boolean check() {
 752         for (Field f : getClass().getDeclaredFields()) {
 753             int modifiers = f.getModifiers();
 754             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
 755                 assert Modifier.isFinal(modifiers) : "field should be final: " + f;
 756             }
 757         }
 758 
 759         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;

 760         return true;
 761     }
 762 }
</pre></td><td><pre>

</pre><hr></hr><pre>
 631     public final long jlongDisjointArraycopy = getFieldValue("StubRoutines::_jlong_disjoint_arraycopy", Long.class, "address");
 632     public final long oopDisjointArraycopy = getFieldValue("StubRoutines::_oop_disjoint_arraycopy", Long.class, "address");
 633     public final long oopDisjointArraycopyUninit = getFieldValue("StubRoutines::_oop_disjoint_arraycopy_uninit", Long.class, "address");
 634     public final long jbyteAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jbyte_arraycopy", Long.class, "address");
 635     public final long jshortAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jshort_arraycopy", Long.class, "address");
 636     public final long jintAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jint_arraycopy", Long.class, "address");
 637     public final long jlongAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jlong_arraycopy", Long.class, "address");
 638     public final long oopAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_oop_arraycopy", Long.class, "address");
 639     public final long oopAlignedArraycopyUninit = getFieldValue("StubRoutines::_arrayof_oop_arraycopy_uninit", Long.class, "address");
 640     public final long jbyteAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jbyte_disjoint_arraycopy", Long.class, "address");
 641     public final long jshortAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jshort_disjoint_arraycopy", Long.class, "address");
 642     public final long jintAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jint_disjoint_arraycopy", Long.class, "address");
 643     public final long jlongAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jlong_disjoint_arraycopy", Long.class, "address");
 644     public final long oopAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_oop_disjoint_arraycopy", Long.class, "address");
 645     public final long oopAlignedDisjointArraycopyUninit = getFieldValue("StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit", Long.class, "address");
 646     public final long checkcastArraycopy = getFieldValue("StubRoutines::_checkcast_arraycopy", Long.class, "address");
 647     public final long checkcastArraycopyUninit = getFieldValue("StubRoutines::_checkcast_arraycopy_uninit", Long.class, "address");
 648     public final long unsafeArraycopy = getFieldValue("StubRoutines::_unsafe_arraycopy", Long.class, "address");
 649     public final long genericArraycopy = getFieldValue("StubRoutines::_generic_arraycopy", Long.class, "address");
 650 
<span class="new"> 651     // Allocation stubs that throw an exception when allocation fails</span>
 652     public final long newInstanceAddress = getAddress("JVMCIRuntime::new_instance");
 653     public final long newArrayAddress = getAddress("JVMCIRuntime::new_array");
 654     public final long newMultiArrayAddress = getAddress("JVMCIRuntime::new_multi_array");
<span class="changed"> 655 </span>
<span class="changed"> 656     // Allocation stubs that return null when allocation fails</span>
<span class="changed"> 657     public final long newInstanceOrNullAddress = getAddress("JVMCIRuntime::new_instance_or_null", 0L);</span>
<span class="changed"> 658     public final long newArrayOrNullAddress = getAddress("JVMCIRuntime::new_array_or_null", 0L);</span>
<span class="changed"> 659     public final long newMultiArrayOrNullAddress = getAddress("JVMCIRuntime::new_multi_array_or_null", 0L);</span>
<span class="changed"> 660 </span>
<span class="changed"> 661     public boolean areNullAllocationStubsAvailable() {</span>
<span class="changed"> 662         return newInstanceOrNullAddress != 0L;</span>
<span class="changed"> 663     }</span>
<span class="changed"> 664 </span>
<span class="changed"> 665     /**</span>
<span class="changed"> 666      * Checks that HotSpot implements all or none of the allocate-or-null stubs.</span>
<span class="changed"> 667      */</span>
<span class="changed"> 668     private boolean checkNullAllocationStubs() {</span>
<span class="changed"> 669         if (newInstanceOrNullAddress == 0L) {</span>
<span class="changed"> 670             assert newArrayOrNullAddress == 0L;</span>
<span class="changed"> 671             assert newMultiArrayOrNullAddress == 0L;</span>
<span class="changed"> 672         } else {</span>
<span class="changed"> 673             assert newArrayOrNullAddress != 0L;</span>
<span class="changed"> 674             assert newMultiArrayOrNullAddress != 0L;</span>
<span class="changed"> 675         }</span>
<span class="changed"> 676         return true;</span>
<span class="changed"> 677     }</span>
 678 
 679     public final long threadIsInterruptedAddress = getAddress("JVMCIRuntime::thread_is_interrupted");
 680     public final long vmMessageAddress = getAddress("JVMCIRuntime::vm_message");
 681     public final long identityHashCodeAddress = getAddress("JVMCIRuntime::identity_hash_code");
 682     public final long exceptionHandlerForPcAddress = getAddress("JVMCIRuntime::exception_handler_for_pc");
 683     public final long monitorenterAddress = getAddress("JVMCIRuntime::monitorenter");
 684     public final long monitorexitAddress = getAddress("JVMCIRuntime::monitorexit");
 685     public final long notifyAddress = getAddress("JVMCIRuntime::object_notify", 0L);
 686     public final long notifyAllAddress = getAddress("JVMCIRuntime::object_notifyAll", 0L);
 687     public final long throwAndPostJvmtiExceptionAddress = getAddress("JVMCIRuntime::throw_and_post_jvmti_exception");
 688     public final long throwKlassExternalNameExceptionAddress = getAddress("JVMCIRuntime::throw_klass_external_name_exception");
 689     public final long throwClassCastExceptionAddress = getAddress("JVMCIRuntime::throw_class_cast_exception");
 690     public final long logPrimitiveAddress = getAddress("JVMCIRuntime::log_primitive");
 691     public final long logObjectAddress = getAddress("JVMCIRuntime::log_object");
 692     public final long logPrintfAddress = getAddress("JVMCIRuntime::log_printf");
 693     public final long vmErrorAddress = getAddress("JVMCIRuntime::vm_error");
 694     public final long loadAndClearExceptionAddress = getAddress("JVMCIRuntime::load_and_clear_exception");
 695     public final long writeBarrierPreAddress = getAddress("JVMCIRuntime::write_barrier_pre");
 696     public final long writeBarrierPostAddress = getAddress("JVMCIRuntime::write_barrier_post");
 697     public final long validateObject = getAddress("JVMCIRuntime::validate_object");

</pre><hr></hr><pre>
 762      */
 763     public final int MARKID_HEAP_TOP_ADDRESS = getConstant("CodeInstaller::HEAP_TOP_ADDRESS", Integer.class, 17);
 764     public final int MARKID_HEAP_END_ADDRESS = getConstant("CodeInstaller::HEAP_END_ADDRESS", Integer.class, 18);
 765     public final int MARKID_NARROW_KLASS_BASE_ADDRESS = getConstant("CodeInstaller::NARROW_KLASS_BASE_ADDRESS", Integer.class, 19);
 766     public final int MARKID_NARROW_OOP_BASE_ADDRESS = getConstant("CodeInstaller::NARROW_OOP_BASE_ADDRESS", Integer.class, 20);
 767     public final int MARKID_CRC_TABLE_ADDRESS = getConstant("CodeInstaller::CRC_TABLE_ADDRESS", Integer.class, 21);
 768     public final int MARKID_LOG_OF_HEAP_REGION_GRAIN_BYTES = getConstant("CodeInstaller::LOG_OF_HEAP_REGION_GRAIN_BYTES", Integer.class, 22);
 769     public final int MARKID_INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED = getConstant("CodeInstaller::INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED", Integer.class, 23);
 770 
 771     // Checkstyle: resume
 772 
 773     protected boolean check() {
 774         for (Field f : getClass().getDeclaredFields()) {
 775             int modifiers = f.getModifiers();
 776             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
 777                 assert Modifier.isFinal(modifiers) : "field should be final: " + f;
 778             }
 779         }
 780 
 781         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
<span class="new"> 782         assert checkNullAllocationStubs();</span>
 783         return true;
 784     }
 785 }
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../src/jdk.aot/share/classes/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/BinaryContainer.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotBackend.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
