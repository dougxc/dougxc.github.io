<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot;
  26 
  27 import java.lang.reflect.Field;
  28 import java.lang.reflect.Modifier;
  29 import java.util.List;
  30 
  31 import org.graalvm.compiler.core.common.CompressEncoding;
  32 import org.graalvm.compiler.hotspot.nodes.GraalHotSpotVMConfigNode;
  33 
  34 import jdk.vm.ci.common.JVMCIError;
  35 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
  36 import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
  37 import jdk.vm.ci.meta.ResolvedJavaMethod;
  38 
  39 /**
  40  * Used to access native configuration details.
  41  */
  42 public class GraalHotSpotVMConfig extends GraalHotSpotVMConfigBase {
  43 
  44     GraalHotSpotVMConfig(HotSpotVMConfigStore store) {
  45         super(store);
  46 
  47         assert narrowKlassShift &lt;= logKlassAlignment;
  48         assert narrowOopShift &lt;= logMinObjAlignment();
  49         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift);
  50         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift);
  51 
  52         assert check();
  53     }
  54 
  55     private final CompressEncoding oopEncoding;
  56     private final CompressEncoding klassEncoding;
  57 
  58     public CompressEncoding getOopEncoding() {
  59         return oopEncoding;
  60     }
  61 
  62     public CompressEncoding getKlassEncoding() {
  63         return klassEncoding;
  64     }
  65 
  66     public final boolean cAssertions = getConstant("ASSERT", Boolean.class);
  67 
  68     public final int codeEntryAlignment = getFlag("CodeEntryAlignment", Integer.class);
  69     public final boolean enableContended = getFlag("EnableContended", Boolean.class);
  70     public final boolean restrictContended = getFlag("RestrictContended", Boolean.class);
  71     public final int contendedPaddingWidth = getFlag("ContendedPaddingWidth", Integer.class);
  72     public final int fieldsAllocationStyle = getFlag("FieldsAllocationStyle", Integer.class);
  73     public final boolean compactFields = getFlag("CompactFields", Boolean.class);
  74     public final boolean verifyOops = getFlag("VerifyOops", Boolean.class);
  75     public final boolean ciTime = getFlag("CITime", Boolean.class);
  76     public final boolean ciTimeEach = getFlag("CITimeEach", Boolean.class);
  77     public final boolean dontCompileHugeMethods = getFlag("DontCompileHugeMethods", Boolean.class);
  78     public final int hugeMethodLimit = getFlag("HugeMethodLimit", Integer.class);
  79     public final boolean printInlining = getFlag("PrintInlining", Boolean.class);
  80     public final boolean inline = getFlag("Inline", Boolean.class);
  81     public final boolean inlineNotify = versioned.inlineNotify;
  82     public final boolean useFastLocking = getFlag("JVMCIUseFastLocking", Boolean.class);
  83     public final boolean forceUnreachable = getFlag("ForceUnreachable", Boolean.class);
  84     public final int codeSegmentSize = getFlag("CodeCacheSegmentSize", Integer.class);
  85     public final boolean foldStableValues = getFlag("FoldStableValues", Boolean.class);
  86     public final int maxVectorSize = getFlag("MaxVectorSize", Integer.class);
  87 
  88     public final boolean verifyBeforeGC = getFlag("VerifyBeforeGC", Boolean.class);
  89     public final boolean verifyAfterGC = getFlag("VerifyAfterGC", Boolean.class);
  90 
  91     public final boolean useTLAB = getFlag("UseTLAB", Boolean.class);
  92     public final boolean useBiasedLocking = getFlag("UseBiasedLocking", Boolean.class);
  93     public final boolean usePopCountInstruction = getFlag("UsePopCountInstruction", Boolean.class);
  94     public final boolean useAESIntrinsics = getFlag("UseAESIntrinsics", Boolean.class);
  95     public final boolean useCRC32Intrinsics = getFlag("UseCRC32Intrinsics", Boolean.class);
  96     public final boolean useCRC32CIntrinsics = versioned.useCRC32CIntrinsics;
  97     public final boolean threadLocalHandshakes = getFlag("ThreadLocalHandshakes", Boolean.class, false);
  98 
  99     private final boolean useMultiplyToLenIntrinsic = getFlag("UseMultiplyToLenIntrinsic", Boolean.class);
 100     private final boolean useSHA1Intrinsics = getFlag("UseSHA1Intrinsics", Boolean.class);
 101     private final boolean useSHA256Intrinsics = getFlag("UseSHA256Intrinsics", Boolean.class);
 102     private final boolean useSHA512Intrinsics = getFlag("UseSHA512Intrinsics", Boolean.class);
 103     private final boolean useMontgomeryMultiplyIntrinsic = getFlag("UseMontgomeryMultiplyIntrinsic", Boolean.class, false);
 104     private final boolean useMontgomerySquareIntrinsic = getFlag("UseMontgomerySquareIntrinsic", Boolean.class, false);
 105     private final boolean useMulAddIntrinsic = getFlag("UseMulAddIntrinsic", Boolean.class, false);
 106     private final boolean useSquareToLenIntrinsic = getFlag("UseSquareToLenIntrinsic", Boolean.class, false);
 107 
 108     /*
 109      * These are methods because in some JDKs the flags are visible but the stubs themselves haven't
 110      * been exported so we have to check both if the flag is on and if we have the stub.
 111      */
 112     public boolean useMultiplyToLenIntrinsic() {
 113         return useMultiplyToLenIntrinsic &amp;&amp; multiplyToLen != 0;
 114     }
 115 
 116     public boolean useSHA1Intrinsics() {
 117         return useSHA1Intrinsics &amp;&amp; sha1ImplCompress != 0;
 118     }
 119 
 120     public boolean useSHA256Intrinsics() {
 121         return useSHA256Intrinsics &amp;&amp; sha256ImplCompress != 0;
 122     }
 123 
 124     public boolean useSHA512Intrinsics() {
 125         return useSHA512Intrinsics &amp;&amp; sha512ImplCompress != 0;
 126     }
 127 
 128     public boolean useMontgomeryMultiplyIntrinsic() {
 129         return useMontgomeryMultiplyIntrinsic &amp;&amp; montgomeryMultiply != 0;
 130     }
 131 
 132     public boolean useMontgomerySquareIntrinsic() {
 133         return useMontgomerySquareIntrinsic &amp;&amp; montgomerySquare != 0;
 134     }
 135 
 136     public boolean useMulAddIntrinsic() {
 137         return useMulAddIntrinsic &amp;&amp; mulAdd != 0;
 138     }
 139 
 140     public boolean useSquareToLenIntrinsic() {
 141         return useSquareToLenIntrinsic &amp;&amp; squareToLen != 0;
 142     }
 143 
 144     public boolean inlineNotify() {
 145         return inlineNotify &amp;&amp; notifyAddress != 0;
 146     }
 147 
 148     public boolean inlineNotifyAll() {
 149         return inlineNotify &amp;&amp; notifyAllAddress != 0;
 150     }
 151 
 152     public final boolean useG1GC = getFlag("UseG1GC", Boolean.class);
 153     public final boolean useCMSGC = getFlag("UseConcMarkSweepGC", Boolean.class);
 154 
 155     public final int allocatePrefetchStyle = getFlag("AllocatePrefetchStyle", Integer.class);
 156     public final int allocatePrefetchInstr = getFlag("AllocatePrefetchInstr", Integer.class);
 157     public final int allocatePrefetchLines = getFlag("AllocatePrefetchLines", Integer.class);
 158     public final int allocateInstancePrefetchLines = getFlag("AllocateInstancePrefetchLines", Integer.class);
 159     public final int allocatePrefetchStepSize = getFlag("AllocatePrefetchStepSize", Integer.class);
 160     public final int allocatePrefetchDistance = getFlag("AllocatePrefetchDistance", Integer.class);
 161 
 162     private final long universeCollectedHeap = getFieldValue("CompilerToVM::Data::Universe_collectedHeap", Long.class, "CollectedHeap*");
 163     private final int collectedHeapTotalCollectionsOffset = getFieldOffset("CollectedHeap::_total_collections", Integer.class, "unsigned int");
 164 
 165     public long gcTotalCollectionsAddress() {
 166         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
 167     }
 168 
 169     public final boolean useDeferredInitBarriers = getFlag("ReduceInitialCardMarks", Boolean.class);
 170 
 171     // Compressed Oops related values.
 172     public final boolean useCompressedOops = getFlag("UseCompressedOops", Boolean.class);
 173     public final boolean useCompressedClassPointers = getFlag("UseCompressedClassPointers", Boolean.class);
 174 
 175     public final long narrowOopBase = getFieldValue("CompilerToVM::Data::Universe_narrow_oop_base", Long.class, "address");
 176     public final int narrowOopShift = getFieldValue("CompilerToVM::Data::Universe_narrow_oop_shift", Integer.class, "int");
 177     public final int objectAlignment = getFlag("ObjectAlignmentInBytes", Integer.class);
 178 
 179     public final int minObjAlignment() {
 180         return objectAlignment / heapWordSize;
 181     }
 182 
 183     public final int logMinObjAlignment() {
 184         return (int) (Math.log(objectAlignment) / Math.log(2));
 185     }
 186 
 187     public final int narrowKlassSize = getFieldValue("CompilerToVM::Data::sizeof_narrowKlass", Integer.class, "int");
 188     public final long narrowKlassBase = getFieldValue("CompilerToVM::Data::Universe_narrow_klass_base", Long.class, "address");
 189     public final int narrowKlassShift = getFieldValue("CompilerToVM::Data::Universe_narrow_klass_shift", Integer.class, "int");
 190     public final int logKlassAlignment = getConstant("LogKlassAlignmentInBytes", Integer.class);
 191 
 192     public final int stackShadowPages = getFlag("StackShadowPages", Integer.class);
 193     public final int stackReservedPages = getFlag("StackReservedPages", Integer.class, 0);
 194     public final boolean useStackBanging = getFlag("UseStackBanging", Boolean.class);
 195     public final int stackBias = getConstant("STACK_BIAS", Integer.class);
 196     public final int vmPageSize = getFieldValue("CompilerToVM::Data::vm_page_size", Integer.class, "int");
 197 
 198     public final int markOffset = getFieldOffset("oopDesc::_mark", Integer.class, "markOop");
 199     public final int hubOffset = getFieldOffset("oopDesc::_metadata._klass", Integer.class, "Klass*");
 200 
 201     public final int prototypeMarkWordOffset = getFieldOffset("Klass::_prototype_header", Integer.class, "markOop");
 202     public final int subklassOffset = getFieldOffset("Klass::_subklass", Integer.class, "Klass*");
 203     public final int nextSiblingOffset = getFieldOffset("Klass::_next_sibling", Integer.class, "Klass*");
 204     public final int superCheckOffsetOffset = getFieldOffset("Klass::_super_check_offset", Integer.class, "juint");
 205     public final int secondarySuperCacheOffset = getFieldOffset("Klass::_secondary_super_cache", Integer.class, "Klass*");
 206     public final int secondarySupersOffset = getFieldOffset("Klass::_secondary_supers", Integer.class, "Array&lt;Klass*&gt;*");
 207 
 208     public final boolean classMirrorIsHandle;
 209     public final int classMirrorOffset;
 210     {
 211         String name = "Klass::_java_mirror";
 212         int offset = -1;
 213         boolean isHandle = false;
 214         try {
 215             offset = getFieldOffset(name, Integer.class, "oop");
 216         } catch (JVMCIError e) {
 217 
 218         }
 219         if (offset == -1) {
 220             try {
 221                 offset = getFieldOffset(name, Integer.class, "jobject");
 222                 isHandle = true;
 223             } catch (JVMCIError e) {
 224                 try {
 225                     // JDK-8186777
 226                     offset = getFieldOffset(name, Integer.class, "OopHandle");
 227                     isHandle = true;
 228                 } catch (JVMCIError e2) {
 229                 }
 230             }
 231         }
 232         if (offset == -1) {
 233             throw new JVMCIError("cannot get offset of field " + name + " with type oop, jobject or OopHandle");
 234         }
 235         classMirrorOffset = offset;
 236         classMirrorIsHandle = isHandle;
 237     }
 238 
 239     public final int klassSuperKlassOffset = getFieldOffset("Klass::_super", Integer.class, "Klass*");
 240     public final int klassModifierFlagsOffset = getFieldOffset("Klass::_modifier_flags", Integer.class, "jint");
 241     public final int klassAccessFlagsOffset = getFieldOffset("Klass::_access_flags", Integer.class, "AccessFlags");
 242     public final int klassLayoutHelperOffset = getFieldOffset("Klass::_layout_helper", Integer.class, "jint");
 243 
 244     public final int klassLayoutHelperNeutralValue = getConstant("Klass::_lh_neutral_value", Integer.class);
 245     public final int layoutHelperLog2ElementSizeShift = getConstant("Klass::_lh_log2_element_size_shift", Integer.class);
 246     public final int layoutHelperLog2ElementSizeMask = getConstant("Klass::_lh_log2_element_size_mask", Integer.class);
 247     public final int layoutHelperElementTypeShift = getConstant("Klass::_lh_element_type_shift", Integer.class);
 248     public final int layoutHelperElementTypeMask = getConstant("Klass::_lh_element_type_mask", Integer.class);
 249     public final int layoutHelperHeaderSizeShift = getConstant("Klass::_lh_header_size_shift", Integer.class);
 250     public final int layoutHelperHeaderSizeMask = getConstant("Klass::_lh_header_size_mask", Integer.class);
 251     public final int layoutHelperArrayTagShift = getConstant("Klass::_lh_array_tag_shift", Integer.class);
 252     public final int layoutHelperArrayTagTypeValue = getConstant("Klass::_lh_array_tag_type_value", Integer.class);
 253     public final int layoutHelperArrayTagObjectValue = getConstant("Klass::_lh_array_tag_obj_value", Integer.class);
 254 
 255     /**
 256      * This filters out the bit that differentiates a type array from an object array.
 257      */
 258     public int layoutHelperElementTypePrimitiveInPlace() {
 259         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
 260     }
 261 
 262     public final int vtableEntrySize = getFieldValue("CompilerToVM::Data::sizeof_vtableEntry", Integer.class, "int");
 263     public final int vtableEntryMethodOffset = getFieldOffset("vtableEntry::_method", Integer.class, "Method*");
 264 
 265     public final int instanceKlassInitStateOffset = getFieldOffset("InstanceKlass::_init_state", Integer.class, "u1");
 266     public final int instanceKlassConstantsOffset = getFieldOffset("InstanceKlass::_constants", Integer.class, "ConstantPool*");
 267     public final int instanceKlassFieldsOffset = getFieldOffset("InstanceKlass::_fields", Integer.class, "Array&lt;u2&gt;*");
 268     public final int klassVtableStartOffset = getFieldValue("CompilerToVM::Data::Klass_vtable_start_offset", Integer.class, "int");
 269     public final int klassVtableLengthOffset = getFieldValue("CompilerToVM::Data::Klass_vtable_length_offset", Integer.class, "int");
 270 
 271     public final int instanceKlassStateLinked = getConstant("InstanceKlass::linked", Integer.class);
 272     public final int instanceKlassStateFullyInitialized = getConstant("InstanceKlass::fully_initialized", Integer.class);
 273 
 274     public final int arrayOopDescSize = getFieldValue("CompilerToVM::Data::sizeof_arrayOopDesc", Integer.class, "int");
 275 
 276     /**
 277      * The offset of the array length word in an array object's header.
 278      *
 279      * See {@code arrayOopDesc::length_offset_in_bytes()}.
 280      */
 281     public final int arrayOopDescLengthOffset() {
 282         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
 283     }
 284 
 285     public final int arrayU1LengthOffset = getFieldOffset("Array&lt;int&gt;::_length", Integer.class, "int");
 286     public final int arrayU1DataOffset = getFieldOffset("Array&lt;u1&gt;::_data", Integer.class);
 287     public final int arrayU2DataOffset = getFieldOffset("Array&lt;u2&gt;::_data", Integer.class);
 288     public final int metaspaceArrayLengthOffset = getFieldOffset("Array&lt;Klass*&gt;::_length", Integer.class, "int");
 289     public final int metaspaceArrayBaseOffset = getFieldOffset("Array&lt;Klass*&gt;::_data[0]", Integer.class, "Klass*");
 290 
 291     public final int arrayClassElementOffset = getFieldOffset("ObjArrayKlass::_element_klass", Integer.class, "Klass*");
 292 
 293     public final int fieldInfoAccessFlagsOffset = getConstant("FieldInfo::access_flags_offset", Integer.class);
 294     public final int fieldInfoNameIndexOffset = getConstant("FieldInfo::name_index_offset", Integer.class);
 295     public final int fieldInfoSignatureIndexOffset = getConstant("FieldInfo::signature_index_offset", Integer.class);
 296     public final int fieldInfoInitvalIndexOffset = getConstant("FieldInfo::initval_index_offset", Integer.class);
 297     public final int fieldInfoLowPackedOffset = getConstant("FieldInfo::low_packed_offset", Integer.class);
 298     public final int fieldInfoHighPackedOffset = getConstant("FieldInfo::high_packed_offset", Integer.class);
 299     public final int fieldInfoFieldSlots = getConstant("FieldInfo::field_slots", Integer.class);
 300 
 301     public final int fieldInfoTagSize = getConstant("FIELDINFO_TAG_SIZE", Integer.class);
 302 
 303     public final int jvmAccMonitorMatch = getConstant("JVM_ACC_MONITOR_MATCH", Integer.class);
 304     public final int jvmAccHasMonitorBytecodes = getConstant("JVM_ACC_HAS_MONITOR_BYTECODES", Integer.class);
 305     public final int jvmAccHasFinalizer = getConstant("JVM_ACC_HAS_FINALIZER", Integer.class);
 306     public final int jvmAccFieldInternal = getConstant("JVM_ACC_FIELD_INTERNAL", Integer.class);
 307     public final int jvmAccFieldStable = getConstant("JVM_ACC_FIELD_STABLE", Integer.class);
 308     public final int jvmAccFieldHasGenericSignature = getConstant("JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE", Integer.class);
 309     public final int jvmAccWrittenFlags = getConstant("JVM_ACC_WRITTEN_FLAGS", Integer.class);
 310     public final int jvmAccSynthetic = getConstant("JVM_ACC_SYNTHETIC", Integer.class);
 311 
 312     public final int threadTlabOffset = getFieldOffset("Thread::_tlab", Integer.class, "ThreadLocalAllocBuffer");
 313     public final int javaThreadAnchorOffset = getFieldOffset("JavaThread::_anchor", Integer.class, "JavaFrameAnchor");
 314     public final int threadObjectOffset = getFieldOffset("JavaThread::_threadObj", Integer.class, "oop");
 315     public final int osThreadOffset = getFieldOffset("JavaThread::_osthread", Integer.class, "OSThread*");
 316     public final int threadIsMethodHandleReturnOffset = getFieldOffset("JavaThread::_is_method_handle_return", Integer.class, "int");
 317     public final int threadObjectResultOffset = getFieldOffset("JavaThread::_vm_result", Integer.class, "oop");
 318     public final int jvmciCountersThreadOffset = getFieldOffset("JavaThread::_jvmci_counters", Integer.class, "jlong*");
 319     public final int javaThreadReservedStackActivationOffset = versioned.javaThreadReservedStackActivationOffset;
 320 
 321     public boolean requiresReservedStackCheck(List&lt;ResolvedJavaMethod&gt; methods) {
 322         if (enableStackReservedZoneAddress != 0 &amp;&amp; methods != null) {
 323             for (ResolvedJavaMethod method : methods) {
 324                 if (((HotSpotResolvedJavaMethod) method).hasReservedStackAccess()) {
 325                     return true;
 326                 }
 327             }
 328         }
 329         return false;
 330     }
 331 
 332     /**
 333      * An invalid value for {@link #rtldDefault}.
 334      */
 335     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
 336 
 337     /**
 338      * Address of the library lookup routine. The C signature of this routine is:
 339      *
 340      * &lt;pre&gt;
 341      *     void* (const char *filename, char *ebuf, int ebuflen)
 342      * &lt;/pre&gt;
 343      */
 344     public final long dllLoad = getAddress("os::dll_load");
 345 
 346     /**
 347      * Address of the library lookup routine. The C signature of this routine is:
 348      *
 349      * &lt;pre&gt;
 350      *     void* (void* handle, const char* name)
 351      * &lt;/pre&gt;
 352      */
 353     public final long dllLookup = getAddress("os::dll_lookup");
 354 
 355     /**
 356      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
 357      * return the first occurrence of the desired symbol using the default library search order. If
 358      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
 359      * the current platform.
 360      */
 361     public final long rtldDefault = getAddress("RTLD_DEFAULT", osName.equals("bsd") || osName.equals("linux") ? null : INVALID_RTLD_DEFAULT_HANDLE);
 362 
 363     /**
 364      * This field is used to pass exception objects into and out of the runtime system during
 365      * exception handling for compiled code.
 366      */
 367     public final int threadExceptionOopOffset = getFieldOffset("JavaThread::_exception_oop", Integer.class, "oop");
 368     public final int threadExceptionPcOffset = getFieldOffset("JavaThread::_exception_pc", Integer.class, "address");
 369     public final int pendingExceptionOffset = getFieldOffset("ThreadShadow::_pending_exception", Integer.class, "oop");
 370 
 371     public final int pendingDeoptimizationOffset = getFieldOffset("JavaThread::_pending_deoptimization", Integer.class, "int");
 372     public final int pendingFailedSpeculationOffset = getFieldOffset("JavaThread::_pending_failed_speculation", Integer.class, "long");
 373     public final int pendingTransferToInterpreterOffset = getFieldOffset("JavaThread::_pending_transfer_to_interpreter", Integer.class, "bool");
 374 
 375     private final int javaFrameAnchorLastJavaSpOffset = getFieldOffset("JavaFrameAnchor::_last_Java_sp", Integer.class, "intptr_t*");
 376     private final int javaFrameAnchorLastJavaPcOffset = getFieldOffset("JavaFrameAnchor::_last_Java_pc", Integer.class, "address");
 377 
 378     public int threadLastJavaSpOffset() {
 379         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
 380     }
 381 
 382     public int threadLastJavaPcOffset() {
 383         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
 384     }
 385 
 386     public int threadLastJavaFpOffset() {
 387         assert osArch.equals("aarch64") || osArch.equals("amd64");
 388         return javaThreadAnchorOffset + getFieldOffset("JavaFrameAnchor::_last_Java_fp", Integer.class, "intptr_t*");
 389     }
 390 
 391     public int threadJavaFrameAnchorFlagsOffset() {
 392         assert osArch.equals("sparc");
 393         return javaThreadAnchorOffset + getFieldOffset("JavaFrameAnchor::_flags", Integer.class, "int");
 394     }
 395 
 396     public final int runtimeCallStackSize = getConstant("frame::arg_reg_save_area_bytes", Integer.class, intRequiredOnAMD64);
 397     public final int frameInterpreterFrameSenderSpOffset = getConstant("frame::interpreter_frame_sender_sp_offset", Integer.class, intRequiredOnAMD64);
 398     public final int frameInterpreterFrameLastSpOffset = getConstant("frame::interpreter_frame_last_sp_offset", Integer.class, intRequiredOnAMD64);
 399 
 400     public final int osThreadInterruptedOffset = getFieldOffset("OSThread::_interrupted", Integer.class, "jint");
 401 
 402     public final long markOopDescHashShift = getConstant("markOopDesc::hash_shift", Long.class);
 403 
 404     public final int biasedLockMaskInPlace = getConstant("markOopDesc::biased_lock_mask_in_place", Integer.class);
 405     public final int ageMaskInPlace = getConstant("markOopDesc::age_mask_in_place", Integer.class);
 406     public final int epochMaskInPlace = getConstant("markOopDesc::epoch_mask_in_place", Integer.class);
 407     public final long markOopDescHashMask = getConstant("markOopDesc::hash_mask", Long.class);
 408     public final long markOopDescHashMaskInPlace = getConstant("markOopDesc::hash_mask_in_place", Long.class);
 409 
 410     public final int unlockedMask = getConstant("markOopDesc::unlocked_value", Integer.class);
 411     public final int monitorMask = getConstant("markOopDesc::monitor_value", Integer.class, -1);
 412     public final int biasedLockPattern = getConstant("markOopDesc::biased_lock_pattern", Integer.class);
 413 
 414     // This field has no type in vmStructs.cpp
 415     public final int objectMonitorOwner = getFieldOffset("ObjectMonitor::_owner", Integer.class, null, -1);
 416     public final int objectMonitorRecursions = getFieldOffset("ObjectMonitor::_recursions", Integer.class, "intptr_t", -1);
 417     public final int objectMonitorCxq = getFieldOffset("ObjectMonitor::_cxq", Integer.class, "ObjectWaiter*", -1);
 418     public final int objectMonitorEntryList = getFieldOffset("ObjectMonitor::_EntryList", Integer.class, "ObjectWaiter*", -1);
 419 
 420     public final int markWordNoHashInPlace = getConstant("markOopDesc::no_hash_in_place", Integer.class);
 421     public final int markWordNoLockInPlace = getConstant("markOopDesc::no_lock_in_place", Integer.class);
 422 
 423     /**
 424      * See {@code markOopDesc::prototype()}.
 425      */
 426     public long arrayPrototypeMarkWord() {
 427         return markWordNoHashInPlace | markWordNoLockInPlace;
 428     }
 429 
 430     /**
 431      * See {@code markOopDesc::copy_set_hash()}.
 432      */
 433     public long tlabIntArrayMarkWord() {
 434         long tmp = arrayPrototypeMarkWord() &amp; (~markOopDescHashMaskInPlace);
 435         tmp |= ((0x2 &amp; markOopDescHashMask) &lt;&lt; markOopDescHashShift);
 436         return tmp;
 437     }
 438 
 439     /**
 440      * Mark word right shift to get identity hash code.
 441      */
 442     public final int identityHashCodeShift = getConstant("markOopDesc::hash_shift", Integer.class);
 443 
 444     /**
 445      * Identity hash code value when uninitialized.
 446      */
 447     public final int uninitializedIdentityHashCodeValue = getConstant("markOopDesc::no_hash", Integer.class);
 448 
 449     public final int methodAccessFlagsOffset = getFieldOffset("Method::_access_flags", Integer.class, "AccessFlags");
 450     public final int methodConstMethodOffset = getFieldOffset("Method::_constMethod", Integer.class, "ConstMethod*");
 451     public final int methodIntrinsicIdOffset = versioned.methodIntrinsicIdOffset;
 452     public final int methodFlagsOffset = versioned.methodFlagsOffset;
 453     public final int methodVtableIndexOffset = getFieldOffset("Method::_vtable_index", Integer.class, "int");
 454 
 455     public final int methodCountersOffset = getFieldOffset("Method::_method_counters", Integer.class, "MethodCounters*");
 456     public final int methodDataOffset = getFieldOffset("Method::_method_data", Integer.class, "MethodData*");
 457     public final int methodCompiledEntryOffset = getFieldOffset("Method::_from_compiled_entry", Integer.class, "address");
 458     public final int methodCodeOffset = versioned.methodCodeOffset;
 459 
 460     public final int methodFlagsCallerSensitive = getConstant("Method::_caller_sensitive", Integer.class);
 461     public final int methodFlagsForceInline = getConstant("Method::_force_inline", Integer.class);
 462     public final int methodFlagsDontInline = getConstant("Method::_dont_inline", Integer.class);
 463     public final int methodFlagsHidden = getConstant("Method::_hidden", Integer.class);
 464     public final int nonvirtualVtableIndex = getConstant("Method::nonvirtual_vtable_index", Integer.class);
 465     public final int invalidVtableIndex = getConstant("Method::invalid_vtable_index", Integer.class);
 466 
 467     public final int invocationCounterOffset = getFieldOffset("MethodCounters::_invocation_counter", Integer.class, "InvocationCounter");
 468     public final int backedgeCounterOffset = getFieldOffset("MethodCounters::_backedge_counter", Integer.class, "InvocationCounter");
 469     public final int invocationCounterIncrement = versioned.invocationCounterIncrement;
 470     public final int invocationCounterShift = versioned.invocationCounterShift;
 471 
 472     public final int nmethodEntryOffset = getFieldOffset("nmethod::_verified_entry_point",
 473                     Integer.class, "address");
 474     public final int compilationLevelFullOptimization = getConstant("CompLevel_full_optimization",
 475                     Integer.class);
 476 
 477     public final int constantPoolSize = getFieldValue("CompilerToVM::Data::sizeof_ConstantPool", Integer.class, "int");
 478     public final int constantPoolLengthOffset = getFieldOffset("ConstantPool::_length",
 479                     Integer.class, "int");
 480 
 481     public final int heapWordSize = getConstant("HeapWordSize", Integer.class);
 482 
 483     /**
 484      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
 485      * are allowed to look like (respectively) the high or low bits of a real oop.
 486      */
 487     public final long nonOopBits = getFieldValue("CompilerToVM::Data::Universe_non_oop_bits", Long.class, "void*");
 488 
 489     public final long verifyOopCounterAddress = getFieldAddress("StubRoutines::_verify_oop_count", "jint");
 490     public final long verifyOopMask = getFieldValue("CompilerToVM::Data::Universe_verify_oop_mask", Long.class, "uintptr_t");
 491     public final long verifyOopBits = getFieldValue("CompilerToVM::Data::Universe_verify_oop_bits", Long.class, "uintptr_t");
 492 
 493     public final int logOfHRGrainBytes = getFieldValue("HeapRegion::LogOfHRGrainBytes", Integer.class, "int");
 494 
 495     public final long cardtableStartAddress = getFieldValue("CompilerToVM::Data::cardtable_start_address", Long.class, "jbyte*");
 496     public final int cardtableShift = getFieldValue("CompilerToVM::Data::cardtable_shift", Integer.class, "int");
 497 
 498     /**
 499      * This is the largest stack offset encodeable in an OopMapValue. Offsets larger than this will
 500      * throw an exception during code installation.
 501      */
 502     public final int maxOopMapStackOffset = getFieldValue("CompilerToVM::Data::_max_oop_map_stack_offset", Integer.class, "int");
 503 
 504     public final long safepointPollingAddress = getFieldValue("os::_polling_page", Long.class, "address");
 505 
 506     // G1 Collector Related Values.
 507 
 508     public final byte dirtyCardValue = versioned.dirtyCardValue;
 509     public final byte g1YoungCardValue = versioned.g1YoungCardValue;
 510 
 511     public final int g1SATBQueueMarkingOffset = versioned.g1SATBQueueMarkingOffset;
 512     public final int g1SATBQueueIndexOffset = versioned.g1SATBQueueIndexOffset;
 513     public final int g1SATBQueueBufferOffset = versioned.g1SATBQueueBufferOffset;
 514     public final int g1CardQueueIndexOffset = versioned.g1CardQueueIndexOffset;
 515     public final int g1CardQueueBufferOffset = versioned.g1CardQueueBufferOffset;
 516 
 517     public final int klassOffset = getFieldValue("java_lang_Class::_klass_offset", Integer.class, "int");
 518     public final int arrayKlassOffset = getFieldValue("java_lang_Class::_array_klass_offset", Integer.class, "int");
 519 
 520     public final int basicLockSize = getFieldValue("CompilerToVM::Data::sizeof_BasicLock", Integer.class, "int");
 521     public final int basicLockDisplacedHeaderOffset = getFieldOffset("BasicLock::_displaced_header", Integer.class, "markOop");
 522 
 523     public final int threadPollingPageOffset = getFieldOffset("Thread::_polling_page", Integer.class, "address", -1);
 524     public final int threadAllocatedBytesOffset = getFieldOffset("Thread::_allocated_bytes", Integer.class, "jlong");
 525 
 526     public final int tlabRefillWasteIncrement = getFlag("TLABWasteIncrement", Integer.class);
 527 
 528     private final int threadLocalAllocBufferStartOffset = getFieldOffset("ThreadLocalAllocBuffer::_start", Integer.class, "HeapWord*");
 529     private final int threadLocalAllocBufferEndOffset = getFieldOffset("ThreadLocalAllocBuffer::_end", Integer.class, "HeapWord*");
 530     private final int threadLocalAllocBufferTopOffset = getFieldOffset("ThreadLocalAllocBuffer::_top", Integer.class, "HeapWord*");
 531     private final int threadLocalAllocBufferPfTopOffset = getFieldOffset("ThreadLocalAllocBuffer::_pf_top", Integer.class, "HeapWord*");
 532     private final int threadLocalAllocBufferSlowAllocationsOffset = getFieldOffset("ThreadLocalAllocBuffer::_slow_allocations", Integer.class, "unsigned");
 533     private final int threadLocalAllocBufferFastRefillWasteOffset = getFieldOffset("ThreadLocalAllocBuffer::_fast_refill_waste", Integer.class, "unsigned");
 534     private final int threadLocalAllocBufferNumberOfRefillsOffset = getFieldOffset("ThreadLocalAllocBuffer::_number_of_refills", Integer.class, "unsigned");
 535     private final int threadLocalAllocBufferRefillWasteLimitOffset = getFieldOffset("ThreadLocalAllocBuffer::_refill_waste_limit", Integer.class, "size_t");
 536     private final int threadLocalAllocBufferDesiredSizeOffset = getFieldOffset("ThreadLocalAllocBuffer::_desired_size", Integer.class, "size_t");
 537 
 538     public int tlabSlowAllocationsOffset() {
 539         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
 540     }
 541 
 542     public int tlabFastRefillWasteOffset() {
 543         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
 544     }
 545 
 546     public int tlabNumberOfRefillsOffset() {
 547         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
 548     }
 549 
 550     public int tlabRefillWasteLimitOffset() {
 551         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
 552     }
 553 
 554     public int threadTlabSizeOffset() {
 555         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
 556     }
 557 
 558     public int threadTlabStartOffset() {
 559         return threadTlabOffset + threadLocalAllocBufferStartOffset;
 560     }
 561 
 562     public int threadTlabEndOffset() {
 563         return threadTlabOffset + threadLocalAllocBufferEndOffset;
 564     }
 565 
 566     public int threadTlabTopOffset() {
 567         return threadTlabOffset + threadLocalAllocBufferTopOffset;
 568     }
 569 
 570     public int threadTlabPfTopOffset() {
 571         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
 572     }
 573 
 574     public final int tlabAlignmentReserve = getFieldValue("CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve", Integer.class, "size_t");
 575 
 576     public final boolean tlabStats = getFlag("TLABStats", Boolean.class);
 577 
 578     // FIXME This is only temporary until the GC code is changed.
 579     public final boolean inlineContiguousAllocationSupported = getFieldValue("CompilerToVM::Data::_supports_inline_contig_alloc", Boolean.class);
 580     public final long heapEndAddress = getFieldValue("CompilerToVM::Data::_heap_end_addr", Long.class, "HeapWord**");
 581     public final long heapTopAddress = versioned.heapTopAddress;
 582 
 583     public final boolean cmsIncrementalMode = getFlag("CMSIncrementalMode", Boolean.class, false);
 584 
 585     public final long inlineCacheMissStub = getFieldValue("CompilerToVM::Data::SharedRuntime_ic_miss_stub", Long.class, "address");
 586     public final long handleWrongMethodStub = getFieldValue("CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub", Long.class, "address");
 587 
 588     public final long handleDeoptStub = getFieldValue("CompilerToVM::Data::SharedRuntime_deopt_blob_unpack", Long.class, "address");
 589     public final long uncommonTrapStub = getFieldValue("CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap", Long.class, "address");
 590 
 591     public final long codeCacheLowBound = versioned.codeCacheLowBound;
 592     public final long codeCacheHighBound = versioned.codeCacheHighBound;
 593 
 594     public final long aescryptEncryptBlockStub = getFieldValue("StubRoutines::_aescrypt_encryptBlock", Long.class, "address");
 595     public final long aescryptDecryptBlockStub = getFieldValue("StubRoutines::_aescrypt_decryptBlock", Long.class, "address");
 596     public final long cipherBlockChainingEncryptAESCryptStub = getFieldValue("StubRoutines::_cipherBlockChaining_encryptAESCrypt", Long.class, "address");
 597     public final long cipherBlockChainingDecryptAESCryptStub = getFieldValue("StubRoutines::_cipherBlockChaining_decryptAESCrypt", Long.class, "address");
 598     public final long updateBytesCRC32Stub = getFieldValue("StubRoutines::_updateBytesCRC32", Long.class, "address");
 599     public final long crcTableAddress = getFieldValue("StubRoutines::_crc_table_adr", Long.class, "address");
 600 
 601     public final long sha1ImplCompress = getFieldValue("StubRoutines::_sha1_implCompress", Long.class, "address", 0L);
 602     public final long sha1ImplCompressMB = getFieldValue("StubRoutines::_sha1_implCompressMB", Long.class, "address", 0L);
 603     public final long sha256ImplCompress = getFieldValue("StubRoutines::_sha256_implCompress", Long.class, "address", 0L);
 604     public final long sha256ImplCompressMB = getFieldValue("StubRoutines::_sha256_implCompressMB", Long.class, "address", 0L);
 605     public final long sha512ImplCompress = getFieldValue("StubRoutines::_sha512_implCompress", Long.class, "address", 0L);
 606     public final long sha512ImplCompressMB = getFieldValue("StubRoutines::_sha512_implCompressMB", Long.class, "address", 0L);
 607     public final long multiplyToLen = getFieldValue("StubRoutines::_multiplyToLen", Long.class, "address", longRequiredOnAMD64);
 608 
 609     public final long counterModeAESCrypt = getFieldValue("StubRoutines::_counterMode_AESCrypt", Long.class, "address", 0L);
 610     public final long ghashProcessBlocks = getFieldValue("StubRoutines::_ghash_processBlocks", Long.class, "address", 0L);
 611     public final long crc32cTableTddr = getFieldValue("StubRoutines::_crc32c_table_addr", Long.class, "address", 0L);
 612     public final long updateBytesCRC32C = getFieldValue("StubRoutines::_updateBytesCRC32C", Long.class, "address", 0L);
 613     public final long updateBytesAdler32 = getFieldValue("StubRoutines::_updateBytesAdler32", Long.class, "address", 0L);
 614     public final long squareToLen = getFieldValue("StubRoutines::_squareToLen", Long.class, "address", longRequiredOnAMD64);
 615     public final long mulAdd = getFieldValue("StubRoutines::_mulAdd", Long.class, "address", longRequiredOnAMD64);
 616     public final long montgomeryMultiply = getFieldValue("StubRoutines::_montgomeryMultiply", Long.class, "address", longRequiredOnAMD64);
 617     public final long montgomerySquare = getFieldValue("StubRoutines::_montgomerySquare", Long.class, "address", longRequiredOnAMD64);
 618     public final long vectorizedMismatch = getFieldValue("StubRoutines::_vectorizedMismatch", Long.class, "address", 0L);
 619 
 620     public final long throwDelayedStackOverflowErrorEntry = versioned.throwDelayedStackOverflowErrorEntry;
 621 
 622     public final long jbyteArraycopy = getFieldValue("StubRoutines::_jbyte_arraycopy", Long.class, "address");
 623     public final long jshortArraycopy = getFieldValue("StubRoutines::_jshort_arraycopy", Long.class, "address");
 624     public final long jintArraycopy = getFieldValue("StubRoutines::_jint_arraycopy", Long.class, "address");
 625     public final long jlongArraycopy = getFieldValue("StubRoutines::_jlong_arraycopy", Long.class, "address");
 626     public final long oopArraycopy = getFieldValue("StubRoutines::_oop_arraycopy", Long.class, "address");
 627     public final long oopArraycopyUninit = getFieldValue("StubRoutines::_oop_arraycopy_uninit", Long.class, "address");
 628     public final long jbyteDisjointArraycopy = getFieldValue("StubRoutines::_jbyte_disjoint_arraycopy", Long.class, "address");
 629     public final long jshortDisjointArraycopy = getFieldValue("StubRoutines::_jshort_disjoint_arraycopy", Long.class, "address");
 630     public final long jintDisjointArraycopy = getFieldValue("StubRoutines::_jint_disjoint_arraycopy", Long.class, "address");
 631     public final long jlongDisjointArraycopy = getFieldValue("StubRoutines::_jlong_disjoint_arraycopy", Long.class, "address");
 632     public final long oopDisjointArraycopy = getFieldValue("StubRoutines::_oop_disjoint_arraycopy", Long.class, "address");
 633     public final long oopDisjointArraycopyUninit = getFieldValue("StubRoutines::_oop_disjoint_arraycopy_uninit", Long.class, "address");
 634     public final long jbyteAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jbyte_arraycopy", Long.class, "address");
 635     public final long jshortAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jshort_arraycopy", Long.class, "address");
 636     public final long jintAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jint_arraycopy", Long.class, "address");
 637     public final long jlongAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jlong_arraycopy", Long.class, "address");
 638     public final long oopAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_oop_arraycopy", Long.class, "address");
 639     public final long oopAlignedArraycopyUninit = getFieldValue("StubRoutines::_arrayof_oop_arraycopy_uninit", Long.class, "address");
 640     public final long jbyteAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jbyte_disjoint_arraycopy", Long.class, "address");
 641     public final long jshortAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jshort_disjoint_arraycopy", Long.class, "address");
 642     public final long jintAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jint_disjoint_arraycopy", Long.class, "address");
 643     public final long jlongAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jlong_disjoint_arraycopy", Long.class, "address");
 644     public final long oopAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_oop_disjoint_arraycopy", Long.class, "address");
 645     public final long oopAlignedDisjointArraycopyUninit = getFieldValue("StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit", Long.class, "address");
 646     public final long checkcastArraycopy = getFieldValue("StubRoutines::_checkcast_arraycopy", Long.class, "address");
 647     public final long checkcastArraycopyUninit = getFieldValue("StubRoutines::_checkcast_arraycopy_uninit", Long.class, "address");
 648     public final long unsafeArraycopy = getFieldValue("StubRoutines::_unsafe_arraycopy", Long.class, "address");
 649     public final long genericArraycopy = getFieldValue("StubRoutines::_generic_arraycopy", Long.class, "address");
 650 
 651     public final long newInstanceAddress = getAddress("JVMCIRuntime::new_instance");
 652     public final long newArrayAddress = getAddress("JVMCIRuntime::new_array");
 653     public final long newMultiArrayAddress = getAddress("JVMCIRuntime::new_multi_array");
 654     public final long dynamicNewArrayAddress = getAddress("JVMCIRuntime::dynamic_new_array");
 655     public final long dynamicNewInstanceAddress = getAddress("JVMCIRuntime::dynamic_new_instance");
 656 
 657     public final long threadIsInterruptedAddress = getAddress("JVMCIRuntime::thread_is_interrupted");
 658     public final long vmMessageAddress = getAddress("JVMCIRuntime::vm_message");
 659     public final long identityHashCodeAddress = getAddress("JVMCIRuntime::identity_hash_code");
 660     public final long exceptionHandlerForPcAddress = getAddress("JVMCIRuntime::exception_handler_for_pc");
 661     public final long monitorenterAddress = getAddress("JVMCIRuntime::monitorenter");
 662     public final long monitorexitAddress = getAddress("JVMCIRuntime::monitorexit");
 663     public final long notifyAddress = getAddress("JVMCIRuntime::object_notify", 0L);
 664     public final long notifyAllAddress = getAddress("JVMCIRuntime::object_notifyAll", 0L);
 665     public final long throwAndPostJvmtiExceptionAddress = getAddress("JVMCIRuntime::throw_and_post_jvmti_exception");
 666     public final long throwKlassExternalNameExceptionAddress = getAddress("JVMCIRuntime::throw_klass_external_name_exception");
 667     public final long throwClassCastExceptionAddress = getAddress("JVMCIRuntime::throw_class_cast_exception");
 668     public final long logPrimitiveAddress = getAddress("JVMCIRuntime::log_primitive");
 669     public final long logObjectAddress = getAddress("JVMCIRuntime::log_object");
 670     public final long logPrintfAddress = getAddress("JVMCIRuntime::log_printf");
 671     public final long vmErrorAddress = getAddress("JVMCIRuntime::vm_error");
 672     public final long loadAndClearExceptionAddress = getAddress("JVMCIRuntime::load_and_clear_exception");
 673     public final long writeBarrierPreAddress = getAddress("JVMCIRuntime::write_barrier_pre");
 674     public final long writeBarrierPostAddress = getAddress("JVMCIRuntime::write_barrier_post");
 675     public final long validateObject = getAddress("JVMCIRuntime::validate_object");
 676 
 677     public final long testDeoptimizeCallInt = getAddress("JVMCIRuntime::test_deoptimize_call_int");
 678 
 679     public final long registerFinalizerAddress = getAddress("SharedRuntime::register_finalizer");
 680     public final long exceptionHandlerForReturnAddressAddress = getAddress("SharedRuntime::exception_handler_for_return_address");
 681     public final long osrMigrationEndAddress = getAddress("SharedRuntime::OSR_migration_end");
 682     public final long enableStackReservedZoneAddress = versioned.enableStackReservedZoneAddress;
 683 
 684     public final long javaTimeMillisAddress = getAddress("os::javaTimeMillis");
 685     public final long javaTimeNanosAddress = getAddress("os::javaTimeNanos");
 686     public final long arithmeticSinAddress = getFieldValue("CompilerToVM::Data::dsin", Long.class, "address");
 687     public final long arithmeticCosAddress = getFieldValue("CompilerToVM::Data::dcos", Long.class, "address");
 688     public final long arithmeticTanAddress = getFieldValue("CompilerToVM::Data::dtan", Long.class, "address");
 689     public final long arithmeticExpAddress = getFieldValue("CompilerToVM::Data::dexp", Long.class, "address");
 690     public final long arithmeticLogAddress = getFieldValue("CompilerToVM::Data::dlog", Long.class, "address");
 691     public final long arithmeticLog10Address = getFieldValue("CompilerToVM::Data::dlog10", Long.class, "address");
 692     public final long arithmeticPowAddress = getFieldValue("CompilerToVM::Data::dpow", Long.class, "address");
 693 
 694     public final long fremAddress = getAddress("SharedRuntime::frem");
 695     public final long dremAddress = getAddress("SharedRuntime::drem");
 696 
 697     public final int jvmciCountersSize = getFlag("JVMCICounterSize", Integer.class);
 698 
 699     public final long deoptimizationFetchUnrollInfo = getAddress("Deoptimization::fetch_unroll_info");
 700     public final long deoptimizationUncommonTrap = getAddress("Deoptimization::uncommon_trap");
 701     public final long deoptimizationUnpackFrames = getAddress("Deoptimization::unpack_frames");
 702 
 703     public final int deoptimizationUnpackDeopt = getConstant("Deoptimization::Unpack_deopt", Integer.class);
 704     public final int deoptimizationUnpackException = getConstant("Deoptimization::Unpack_exception", Integer.class);
 705     public final int deoptimizationUnpackUncommonTrap = getConstant("Deoptimization::Unpack_uncommon_trap", Integer.class);
 706     public final int deoptimizationUnpackReexecute = getConstant("Deoptimization::Unpack_reexecute", Integer.class);
 707 
 708     public final int deoptimizationUnrollBlockSizeOfDeoptimizedFrameOffset = getFieldOffset("Deoptimization::UnrollBlock::_size_of_deoptimized_frame", Integer.class, "int");
 709     public final int deoptimizationUnrollBlockCallerAdjustmentOffset = getFieldOffset("Deoptimization::UnrollBlock::_caller_adjustment", Integer.class, "int");
 710     public final int deoptimizationUnrollBlockNumberOfFramesOffset = getFieldOffset("Deoptimization::UnrollBlock::_number_of_frames", Integer.class, "int");
 711     public final int deoptimizationUnrollBlockTotalFrameSizesOffset = getFieldOffset("Deoptimization::UnrollBlock::_total_frame_sizes", Integer.class, "int");
 712     public final int deoptimizationUnrollBlockUnpackKindOffset = getFieldOffset("Deoptimization::UnrollBlock::_unpack_kind", Integer.class, "int");
 713     public final int deoptimizationUnrollBlockFrameSizesOffset = getFieldOffset("Deoptimization::UnrollBlock::_frame_sizes", Integer.class, "intptr_t*");
 714     public final int deoptimizationUnrollBlockFramePcsOffset = getFieldOffset("Deoptimization::UnrollBlock::_frame_pcs", Integer.class, "address*");
 715     public final int deoptimizationUnrollBlockInitialInfoOffset = getFieldOffset("Deoptimization::UnrollBlock::_initial_info", Integer.class, "intptr_t");
 716 
 717     // Checkstyle: stop
 718     public final int MARKID_VERIFIED_ENTRY = getConstant("CodeInstaller::VERIFIED_ENTRY", Integer.class);
 719     public final int MARKID_UNVERIFIED_ENTRY = getConstant("CodeInstaller::UNVERIFIED_ENTRY", Integer.class);
 720     public final int MARKID_OSR_ENTRY = getConstant("CodeInstaller::OSR_ENTRY", Integer.class);
 721     public final int MARKID_EXCEPTION_HANDLER_ENTRY = getConstant("CodeInstaller::EXCEPTION_HANDLER_ENTRY", Integer.class);
 722     public final int MARKID_DEOPT_HANDLER_ENTRY = getConstant("CodeInstaller::DEOPT_HANDLER_ENTRY", Integer.class);
 723     public final int MARKID_INVOKEINTERFACE = getConstant("CodeInstaller::INVOKEINTERFACE", Integer.class);
 724     public final int MARKID_INVOKEVIRTUAL = getConstant("CodeInstaller::INVOKEVIRTUAL", Integer.class);
 725     public final int MARKID_INVOKESTATIC = getConstant("CodeInstaller::INVOKESTATIC", Integer.class);
 726     public final int MARKID_INVOKESPECIAL = getConstant("CodeInstaller::INVOKESPECIAL", Integer.class);
 727     public final int MARKID_INLINE_INVOKE = getConstant("CodeInstaller::INLINE_INVOKE", Integer.class);
 728     public final int MARKID_POLL_NEAR = getConstant("CodeInstaller::POLL_NEAR", Integer.class);
 729     public final int MARKID_POLL_RETURN_NEAR = getConstant("CodeInstaller::POLL_RETURN_NEAR", Integer.class);
 730     public final int MARKID_POLL_FAR = getConstant("CodeInstaller::POLL_FAR", Integer.class);
 731     public final int MARKID_POLL_RETURN_FAR = getConstant("CodeInstaller::POLL_RETURN_FAR", Integer.class);
 732     public final int MARKID_CARD_TABLE_SHIFT = getConstant("CodeInstaller::CARD_TABLE_SHIFT", Integer.class);
 733     public final int MARKID_CARD_TABLE_ADDRESS = getConstant("CodeInstaller::CARD_TABLE_ADDRESS", Integer.class);
 734     public final int MARKID_INVOKE_INVALID = getConstant("CodeInstaller::INVOKE_INVALID", Integer.class);
 735 
 736     /**
 737      * The following constants are given default values here since they are missing in the native
 738      * JVMCI-8 code but are still required for {@link GraalHotSpotVMConfigNode#canonical} to work in
 739      * a JDK8 environment.
 740      */
 741     public final int MARKID_HEAP_TOP_ADDRESS = getConstant("CodeInstaller::HEAP_TOP_ADDRESS", Integer.class, 17);
 742     public final int MARKID_HEAP_END_ADDRESS = getConstant("CodeInstaller::HEAP_END_ADDRESS", Integer.class, 18);
 743     public final int MARKID_NARROW_KLASS_BASE_ADDRESS = getConstant("CodeInstaller::NARROW_KLASS_BASE_ADDRESS", Integer.class, 19);
 744     public final int MARKID_NARROW_OOP_BASE_ADDRESS = getConstant("CodeInstaller::NARROW_OOP_BASE_ADDRESS", Integer.class, 20);
 745     public final int MARKID_CRC_TABLE_ADDRESS = getConstant("CodeInstaller::CRC_TABLE_ADDRESS", Integer.class, 21);
 746     public final int MARKID_LOG_OF_HEAP_REGION_GRAIN_BYTES = getConstant("CodeInstaller::LOG_OF_HEAP_REGION_GRAIN_BYTES", Integer.class, 22);
 747     public final int MARKID_INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED = getConstant("CodeInstaller::INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED", Integer.class, 23);
 748 
 749     // Checkstyle: resume
 750 
 751     protected boolean check() {
 752         for (Field f : getClass().getDeclaredFields()) {
 753             int modifiers = f.getModifiers();
 754             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
 755                 assert Modifier.isFinal(modifiers) : "field should be final: " + f;
 756             }
 757         }
 758 
 759         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
 760         return true;
 761     }
 762 }
</pre></body></html>
