<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "code/compiledIC.hpp"
  26 #include "compiler/compileBroker.hpp"
  27 #include "compiler/disassembler.hpp"
  28 #include "oops/oop.inline.hpp"
  29 #include "oops/objArrayOop.inline.hpp"
  30 #include "runtime/javaCalls.hpp"
  31 #include "jvmci/jvmciEnv.hpp"
  32 #include "jvmci/jvmciCompiler.hpp"
  33 #include "jvmci/jvmciCodeInstaller.hpp"
  34 #include "jvmci/jvmciJavaClasses.hpp"
  35 #include "jvmci/jvmciCompilerToVM.hpp"
  36 #include "jvmci/jvmciRuntime.hpp"
  37 #include "asm/register.hpp"
  38 #include "classfile/vmSymbols.hpp"
  39 #include "code/vmreg.hpp"
  40 
  41 #ifdef TARGET_ARCH_x86
  42 # include "vmreg_x86.inline.hpp"
  43 #endif
  44 #ifdef TARGET_ARCH_sparc
  45 # include "vmreg_sparc.inline.hpp"
  46 #endif
  47 #ifdef TARGET_ARCH_zero
  48 # include "vmreg_zero.inline.hpp"
  49 #endif
  50 #ifdef TARGET_ARCH_arm
  51 # include "vmreg_arm.inline.hpp"
  52 #endif
  53 #ifdef TARGET_ARCH_ppc
  54 # include "vmreg_ppc.inline.hpp"
  55 #endif
  56 
  57 
  58 // frequently used constants
  59 // Allocate them with new so they are never destroyed (otherwise, a
  60 // forced exit could destroy these objects while they are still in
  61 // use).
  62 ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantOopWriteValue(NULL);
  63 ConstantIntValue*      CodeInstaller::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(-1);
  64 ConstantIntValue*      CodeInstaller::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(0);
  65 ConstantIntValue*      CodeInstaller::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(1);
  66 ConstantIntValue*      CodeInstaller::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(2);
  67 LocationValue*         CodeInstaller::_illegal_value = new (ResourceObj::C_HEAP, mtCompiler) LocationValue(Location());
  68 
  69 Method* getMethodFromHotSpotMethod(oop hotspot_method) {
  70   assert(hotspot_method != NULL &amp;&amp; hotspot_method-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()), "sanity");
  71   return CompilerToVM::asMethod(hotspot_method);
  72 }
  73 
  74 VMReg getVMRegFromLocation(Handle location, int total_frame_size, TRAPS) {
  75   if (location.is_null()) {
  76     THROW_NULL(vmSymbols::java_lang_NullPointerException());
  77   }
  78 
  79   Handle reg = code_Location::reg(location);
  80   jint offset = code_Location::offset(location);
  81 
  82   if (reg.not_null()) {
  83     // register
  84     jint number = code_Register::number(reg);
  85     VMReg vmReg = CodeInstaller::get_hotspot_reg(number, CHECK_NULL);
  86     if (offset % 4 == 0) {
  87       return vmReg-&gt;next(offset / 4);
  88     } else {
  89       JVMCI_ERROR_NULL("unaligned subregister offset %d in oop map", offset);
  90     }
  91   } else {
  92     // stack slot
  93     if (offset % 4 == 0) {
  94       return VMRegImpl::stack2reg(offset / 4);
  95     } else {
  96       JVMCI_ERROR_NULL("unaligned stack offset %d in oop map", offset);
  97     }
  98   }
  99 }
 100 
 101 // creates a HotSpot oop map out of the byte arrays provided by DebugInfo
 102 OopMap* CodeInstaller::create_oop_map(Handle debug_info, TRAPS) {
 103   Handle reference_map = DebugInfo::referenceMap(debug_info);
 104   if (reference_map.is_null()) {
 105     THROW_NULL(vmSymbols::java_lang_NullPointerException());
 106   }
 107   if (!reference_map-&gt;is_a(HotSpotReferenceMap::klass())) {
 108     JVMCI_ERROR_NULL("unknown reference map: %s", reference_map-&gt;klass()-&gt;signature_name());
 109   }
 110   if (HotSpotReferenceMap::maxRegisterSize(reference_map) &gt; 16) {
 111     _has_wide_vector = true;
 112   }
 113   OopMap* map = new OopMap(_total_frame_size, _parameter_count);
 114   objArrayHandle objects = HotSpotReferenceMap::objects(reference_map);
 115   objArrayHandle derivedBase = HotSpotReferenceMap::derivedBase(reference_map);
 116   typeArrayHandle sizeInBytes = HotSpotReferenceMap::sizeInBytes(reference_map);
 117   if (objects.is_null() || derivedBase.is_null() || sizeInBytes.is_null()) {
 118     THROW_NULL(vmSymbols::java_lang_NullPointerException());
 119   }
 120   if (objects-&gt;length() != derivedBase-&gt;length() || objects-&gt;length() != sizeInBytes-&gt;length()) {
 121     JVMCI_ERROR_NULL("arrays in reference map have different sizes: %d %d %d", objects-&gt;length(), derivedBase-&gt;length(), sizeInBytes-&gt;length());
 122   }
 123   for (int i = 0; i &lt; objects-&gt;length(); i++) {
 124     Handle location = objects-&gt;obj_at(i);
 125     Handle baseLocation = derivedBase-&gt;obj_at(i);
 126     int bytes = sizeInBytes-&gt;int_at(i);
 127 
 128     VMReg vmReg = getVMRegFromLocation(location, _total_frame_size, CHECK_NULL);
 129     if (baseLocation.not_null()) {
 130       // derived oop
 131 #ifdef _LP64
 132       if (bytes == 8) {
 133 #else
 134       if (bytes == 4) {
 135 #endif
 136         VMReg baseReg = getVMRegFromLocation(baseLocation, _total_frame_size, CHECK_NULL);
 137         map-&gt;set_derived_oop(vmReg, baseReg);
 138       } else {
 139         JVMCI_ERROR_NULL("invalid derived oop size in ReferenceMap: %d", bytes);
 140       }
 141 #ifdef _LP64
 142     } else if (bytes == 8) {
 143       // wide oop
 144       map-&gt;set_oop(vmReg);
 145     } else if (bytes == 4) {
 146       // narrow oop
 147       map-&gt;set_narrowoop(vmReg);
 148 #else
 149     } else if (bytes == 4) {
 150       map-&gt;set_oop(vmReg);
 151 #endif
 152     } else {
 153       JVMCI_ERROR_NULL("invalid oop size in ReferenceMap: %d", bytes);
 154     }
 155   }
 156 
 157   Handle callee_save_info = (oop) DebugInfo::calleeSaveInfo(debug_info);
 158   if (callee_save_info.not_null()) {
 159     objArrayHandle registers = RegisterSaveLayout::registers(callee_save_info);
 160     typeArrayHandle slots = RegisterSaveLayout::slots(callee_save_info);
 161     for (jint i = 0; i &lt; slots-&gt;length(); i++) {
 162       Handle jvmci_reg = registers-&gt;obj_at(i);
 163       jint jvmci_reg_number = code_Register::number(jvmci_reg);
 164       VMReg hotspot_reg = CodeInstaller::get_hotspot_reg(jvmci_reg_number, CHECK_NULL);
 165       // HotSpot stack slots are 4 bytes
 166       jint jvmci_slot = slots-&gt;int_at(i);
 167       jint hotspot_slot = jvmci_slot * VMRegImpl::slots_per_word;
 168       VMReg hotspot_slot_as_reg = VMRegImpl::stack2reg(hotspot_slot);
 169       map-&gt;set_callee_saved(hotspot_slot_as_reg, hotspot_reg);
 170 #ifdef _LP64
 171       // (copied from generate_oop_map() in c1_Runtime1_x86.cpp)
 172       VMReg hotspot_slot_hi_as_reg = VMRegImpl::stack2reg(hotspot_slot + 1);
 173       map-&gt;set_callee_saved(hotspot_slot_hi_as_reg, hotspot_reg-&gt;next());
 174 #endif
 175     }
 176   }
 177   return map;
 178 }
 179 
 180 Metadata* CodeInstaller::record_metadata_reference(Handle constant, TRAPS) {
 181   oop obj = HotSpotMetaspaceConstantImpl::metaspaceObject(constant);
 182   if (obj-&gt;is_a(HotSpotResolvedObjectTypeImpl::klass())) {
 183     Klass* klass = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(obj));
 184     assert(!HotSpotMetaspaceConstantImpl::compressed(constant), "unexpected compressed klass pointer %s @ " INTPTR_FORMAT, klass-&gt;name()-&gt;as_C_string(), p2i(klass));
 185     int index = _oop_recorder-&gt;find_index(klass);
 186     TRACE_jvmci_3("metadata[%d of %d] = %s", index, _oop_recorder-&gt;metadata_count(), klass-&gt;name()-&gt;as_C_string());
 187     return klass;
 188   } else if (obj-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass())) {
 189     Method* method = (Method*) (address) HotSpotResolvedJavaMethodImpl::metaspaceMethod(obj);
 190     assert(!HotSpotMetaspaceConstantImpl::compressed(constant), "unexpected compressed method pointer %s @ " INTPTR_FORMAT, method-&gt;name()-&gt;as_C_string(), p2i(method));
 191     int index = _oop_recorder-&gt;find_index(method);
 192     TRACE_jvmci_3("metadata[%d of %d] = %s", index, _oop_recorder-&gt;metadata_count(), method-&gt;name()-&gt;as_C_string());
 193     return method;
 194   } else {
 195     JVMCI_ERROR_NULL("unexpected metadata reference for constant of type %s", obj-&gt;klass()-&gt;signature_name());
 196   }
 197 }
 198 
 199 #ifdef _LP64
 200 narrowKlass CodeInstaller::record_narrow_metadata_reference(Handle constant, TRAPS) {
 201   oop obj = HotSpotMetaspaceConstantImpl::metaspaceObject(constant);
 202   assert(HotSpotMetaspaceConstantImpl::compressed(constant), "unexpected uncompressed pointer");
 203 
 204   if (!obj-&gt;is_a(HotSpotResolvedObjectTypeImpl::klass())) {
 205     JVMCI_ERROR_0("unexpected compressed pointer of type %s", obj-&gt;klass()-&gt;signature_name());
 206   }
 207 
 208   Klass* klass = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(obj));
 209   int index = _oop_recorder-&gt;find_index(klass);
 210   TRACE_jvmci_3("narrowKlass[%d of %d] = %s", index, _oop_recorder-&gt;metadata_count(), klass-&gt;name()-&gt;as_C_string());
 211   return Klass::encode_klass(klass);
 212 }
 213 #endif
 214 
 215 Location::Type CodeInstaller::get_oop_type(Handle value) {
 216   Handle lirKind = Value::lirKind(value);
 217   Handle platformKind = LIRKind::platformKind(lirKind);
 218   assert(LIRKind::referenceMask(lirKind) == 1, "unexpected referenceMask");
 219 
 220   if (platformKind == word_kind()) {
 221     return Location::oop;
 222   } else {
 223     return Location::narrowoop;
 224   }
 225 }
 226 
 227 ScopeValue* CodeInstaller::get_scope_value(Handle value, BasicType type, GrowableArray&lt;ScopeValue*&gt;* objects, ScopeValue* &amp;second, TRAPS) {
 228   second = NULL;
 229   if (value.is_null()) {
 230     THROW_NULL(vmSymbols::java_lang_NullPointerException());
 231   } else if (value == Value::ILLEGAL()) {
 232     if (type != T_ILLEGAL) {
 233       JVMCI_ERROR_NULL("unexpected illegal value, expected %s", basictype_to_str(type));
 234     }
 235     return _illegal_value;
 236   } else if (value-&gt;is_a(RegisterValue::klass())) {
 237     Handle reg = RegisterValue::reg(value);
 238     jint number = code_Register::number(reg);
 239     VMReg hotspotRegister = get_hotspot_reg(number, CHECK_NULL);
 240     if (is_general_purpose_reg(hotspotRegister)) {
 241       Location::Type locationType;
 242       if (type == T_OBJECT) {
 243         locationType = get_oop_type(value);
 244       } else if (type == T_LONG) {
 245         locationType = Location::lng;
 246       } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {
 247         locationType = Location::int_in_long;
 248       } else {
 249         JVMCI_ERROR_NULL("unexpected type %s in cpu register", basictype_to_str(type));
 250       }
 251       ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));
 252       if (type == T_LONG) {
 253         second = value;
 254       }
 255       return value;
 256     } else {
 257       Location::Type locationType;
 258       if (type == T_FLOAT) {
 259         // this seems weird, but the same value is used in c1_LinearScan
 260         locationType = Location::normal;
 261       } else if (type == T_DOUBLE) {
 262         locationType = Location::dbl;
 263       } else {
 264         JVMCI_ERROR_NULL("unexpected type %s in floating point register", basictype_to_str(type));
 265       }
 266       ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));
 267       if (type == T_DOUBLE) {
 268         second = value;
 269       }
 270       return value;
 271     }
 272   } else if (value-&gt;is_a(StackSlot::klass())) {
 273     jint offset = StackSlot::offset(value);
 274     if (StackSlot::addFrameSize(value)) {
 275       offset += _total_frame_size;
 276     }
 277 
 278     Location::Type locationType;
 279     if (type == T_OBJECT) {
 280       locationType = get_oop_type(value);
 281     } else if (type == T_LONG) {
 282       locationType = Location::lng;
 283     } else if (type == T_DOUBLE) {
 284       locationType = Location::dbl;
 285     } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {
 286       locationType = Location::normal;
 287     } else {
 288       JVMCI_ERROR_NULL("unexpected type %s in stack slot", basictype_to_str(type));
 289     }
 290     ScopeValue* value = new LocationValue(Location::new_stk_loc(locationType, offset));
 291     if (type == T_DOUBLE || type == T_LONG) {
 292       second = value;
 293     }
 294     return value;
 295   } else if (value-&gt;is_a(JavaConstant::klass())) {
 296     if (value-&gt;is_a(PrimitiveConstant::klass())) {
 297       if (value-&gt;is_a(RawConstant::klass())) {
 298         jlong prim = PrimitiveConstant::primitive(value);
 299         return new ConstantLongValue(prim);
 300       } else {
 301         BasicType constantType = JVMCIRuntime::kindToBasicType(PrimitiveConstant::kind(value), CHECK_NULL);
 302         if (type != constantType) {
 303           JVMCI_ERROR_NULL("primitive constant type doesn't match, expected %s but got %s", basictype_to_str(type), basictype_to_str(constantType));
 304         }
 305         if (type == T_INT || type == T_FLOAT) {
 306           jint prim = (jint)PrimitiveConstant::primitive(value);
 307           switch (prim) {
 308             case -1: return _int_m1_scope_value;
 309             case  0: return _int_0_scope_value;
 310             case  1: return _int_1_scope_value;
 311             case  2: return _int_2_scope_value;
 312             default: return new ConstantIntValue(prim);
 313           }
 314         } else if (type == T_LONG || type == T_DOUBLE) {
 315           jlong prim = PrimitiveConstant::primitive(value);
 316           second = _int_1_scope_value;
 317           return new ConstantLongValue(prim);
 318         } else {
 319           JVMCI_ERROR_NULL("unexpected primitive constant type %s", basictype_to_str(type));
 320         }
 321       }
 322     } else if (value-&gt;is_a(NullConstant::klass()) || value-&gt;is_a(HotSpotCompressedNullConstant::klass())) {
 323       if (type == T_OBJECT) {
 324         return _oop_null_scope_value;
 325       } else {
 326         JVMCI_ERROR_NULL("unexpected null constant, expected %s", basictype_to_str(type));
 327       }
 328     } else if (value-&gt;is_a(HotSpotObjectConstantImpl::klass())) {
 329       if (type == T_OBJECT) {
 330         oop obj = HotSpotObjectConstantImpl::object(value);
 331         if (obj == NULL) {
 332           JVMCI_ERROR_NULL("null value must be in NullConstant");
 333         }
 334         return new ConstantOopWriteValue(JNIHandles::make_local(obj));
 335       } else {
 336         JVMCI_ERROR_NULL("unexpected object constant, expected %s", basictype_to_str(type));
 337       }
 338     }
 339   } else if (value-&gt;is_a(VirtualObject::klass())) {
 340     if (type == T_OBJECT) {
 341       int id = VirtualObject::id(value);
 342       if (0 &lt;= id &amp;&amp; id &lt; objects-&gt;length()) {
 343         ScopeValue* object = objects-&gt;at(id);
 344         if (object != NULL) {
 345           return object;
 346         }
 347       }
 348       JVMCI_ERROR_NULL("unknown virtual object id %d", id);
 349     } else {
 350       JVMCI_ERROR_NULL("unexpected virtual object, expected %s", basictype_to_str(type));
 351     }
 352   }
 353 
 354   JVMCI_ERROR_NULL("unexpected value in scope: %s", value-&gt;klass()-&gt;signature_name())
 355 }
 356 
 357 void CodeInstaller::record_object_value(ObjectValue* sv, Handle value, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {
 358   Handle type = VirtualObject::type(value);
 359   int id = VirtualObject::id(value);
 360   oop javaMirror = HotSpotResolvedObjectTypeImpl::javaClass(type);
 361   Klass* klass = java_lang_Class::as_Klass(javaMirror);
 362   bool isLongArray = klass == Universe::longArrayKlassObj();
 363 
 364   objArrayHandle values = VirtualObject::values(value);
 365   objArrayHandle slotKinds = VirtualObject::slotKinds(value);
 366   for (jint i = 0; i &lt; values-&gt;length(); i++) {
 367     ScopeValue* cur_second = NULL;
 368     Handle object = values-&gt;obj_at(i);
 369     BasicType type = JVMCIRuntime::kindToBasicType(slotKinds-&gt;obj_at(i), CHECK);
 370     ScopeValue* value = get_scope_value(object, type, objects, cur_second, CHECK);
 371 
 372     if (isLongArray &amp;&amp; cur_second == NULL) {
 373       // we're trying to put ints into a long array... this isn't really valid, but it's used for some optimizations.
 374       // add an int 0 constant
 375       cur_second = _int_0_scope_value;
 376     }
 377 
 378     if (cur_second != NULL) {
 379       sv-&gt;field_values()-&gt;append(cur_second);
 380     }
 381     assert(value != NULL, "missing value");
 382     sv-&gt;field_values()-&gt;append(value);
 383   }
 384 }
 385 
 386 MonitorValue* CodeInstaller::get_monitor_value(Handle value, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {
 387   if (value.is_null()) {
 388     THROW_NULL(vmSymbols::java_lang_NullPointerException());
 389   }
 390   if (!value-&gt;is_a(StackLockValue::klass())) {
 391     JVMCI_ERROR_NULL("Monitors must be of type StackLockValue, got %s", value-&gt;klass()-&gt;signature_name());
 392   }
 393 
 394   ScopeValue* second = NULL;
 395   ScopeValue* owner_value = get_scope_value(StackLockValue::owner(value), T_OBJECT, objects, second, CHECK_NULL);
 396   assert(second == NULL, "monitor cannot occupy two stack slots");
 397 
 398   ScopeValue* lock_data_value = get_scope_value(StackLockValue::slot(value), T_LONG, objects, second, CHECK_NULL);
 399   assert(second == lock_data_value, "monitor is LONG value that occupies two stack slots");
 400   assert(lock_data_value-&gt;is_location(), "invalid monitor location");
 401   Location lock_data_loc = ((LocationValue*)lock_data_value)-&gt;location();
 402 
 403   bool eliminated = false;
 404   if (StackLockValue::eliminated(value)) {
 405     eliminated = true;
 406   }
 407 
 408   return new MonitorValue(owner_value, lock_data_loc, eliminated);
 409 }
 410 
 411 void CodeInstaller::initialize_dependencies(oop compiled_code, OopRecorder* recorder, TRAPS) {
 412   JavaThread* thread = JavaThread::current();
 413   CompilerThread* compilerThread = thread-&gt;is_Compiler_thread() ? thread-&gt;as_CompilerThread() : NULL;
 414   _oop_recorder = recorder;
 415   _dependencies = new Dependencies(&amp;_arena, _oop_recorder, compilerThread != NULL ? compilerThread-&gt;log() : NULL);
 416   objArrayHandle assumptions = HotSpotCompiledCode::assumptions(compiled_code);
 417   if (!assumptions.is_null()) {
 418     int length = assumptions-&gt;length();
 419     for (int i = 0; i &lt; length; ++i) {
 420       Handle assumption = assumptions-&gt;obj_at(i);
 421       if (!assumption.is_null()) {
 422         if (assumption-&gt;klass() == Assumptions_NoFinalizableSubclass::klass()) {
 423           assumption_NoFinalizableSubclass(assumption);
 424         } else if (assumption-&gt;klass() == Assumptions_ConcreteSubtype::klass()) {
 425           assumption_ConcreteSubtype(assumption);
 426         } else if (assumption-&gt;klass() == Assumptions_LeafType::klass()) {
 427           assumption_LeafType(assumption);
 428         } else if (assumption-&gt;klass() == Assumptions_ConcreteMethod::klass()) {
 429           assumption_ConcreteMethod(assumption);
 430         } else if (assumption-&gt;klass() == Assumptions_CallSiteTargetValue::klass()) {
 431           assumption_CallSiteTargetValue(assumption);
 432         } else {
 433           JVMCI_ERROR("unexpected Assumption subclass %s", assumption-&gt;klass()-&gt;signature_name());
 434         }
 435       }
 436     }
 437   }
 438   if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
 439     objArrayHandle methods = HotSpotCompiledCode::methods(compiled_code);
 440     if (!methods.is_null()) {
 441       int length = methods-&gt;length();
 442       for (int i = 0; i &lt; length; ++i) {
 443         Handle method_handle = methods-&gt;obj_at(i);
 444         methodHandle method = getMethodFromHotSpotMethod(method_handle());
 445         _dependencies-&gt;assert_evol_method(method());
 446       }
 447     }
 448   }
 449 }
 450 
 451 RelocBuffer::~RelocBuffer() {
 452   if (_buffer != NULL) {
 453     FREE_C_HEAP_ARRAY(char, _buffer);
 454   }
 455 }
 456 
 457 address RelocBuffer::begin() const {
 458   if (_buffer != NULL) {
 459     return (address) _buffer;
 460   }
 461   return (address) _static_buffer;
 462 }
 463 
 464 void RelocBuffer::set_size(size_t bytes) {
 465   assert(bytes &lt;= _size, "can't grow in size!");
 466   _size = bytes;
 467 }
 468 
 469 void RelocBuffer::ensure_size(size_t bytes) {
 470   assert(_buffer == NULL, "can only be used once");
 471   assert(_size == 0, "can only be used once");
 472   if (bytes &gt;= RelocBuffer::stack_size) {
 473     _buffer = NEW_C_HEAP_ARRAY(char, bytes, mtInternal);
 474   }
 475   _size = bytes;
 476 }
 477 
 478 JVMCIEnv::CodeInstallResult CodeInstaller::gather_metadata(Handle target, Handle compiled_code, CodeMetadata&amp; metadata, TRAPS) {
 479   CodeBuffer buffer("JVMCI Compiler CodeBuffer for Metadata");
 480   jobject compiled_code_obj = JNIHandles::make_local(compiled_code());
 481   initialize_dependencies(JNIHandles::resolve(compiled_code_obj), NULL, CHECK_OK);
 482 
 483   // Get instructions and constants CodeSections early because we need it.
 484   _instructions = buffer.insts();
 485   _constants = buffer.consts();
 486 
 487   initialize_fields(target(), JNIHandles::resolve(compiled_code_obj), CHECK_OK);
 488   JVMCIEnv::CodeInstallResult result = initialize_buffer(buffer, CHECK_OK);
 489   if (result != JVMCIEnv::ok) {
 490     return result;
 491   }
 492   process_exception_handlers();
 493 
 494   _debug_recorder-&gt;pcs_size(); // ehm, create the sentinel record
 495 
 496   assert(_debug_recorder-&gt;pcs_length() &gt;= 2, "must be at least 2");
 497 
 498   metadata.set_pc_desc(_debug_recorder-&gt;pcs(), _debug_recorder-&gt;pcs_length());
 499   metadata.set_scopes(_debug_recorder-&gt;stream()-&gt;buffer(), _debug_recorder-&gt;data_size());
 500   metadata.set_exception_table(&amp;_exception_handler_table);
 501 
 502   RelocBuffer* reloc_buffer = metadata.get_reloc_buffer();
 503 
 504   reloc_buffer-&gt;ensure_size(buffer.total_relocation_size());
 505   size_t size = (size_t) buffer.copy_relocations_to(reloc_buffer-&gt;begin(), (CodeBuffer::csize_t) reloc_buffer-&gt;size(), true);
 506   reloc_buffer-&gt;set_size(size);
 507   return JVMCIEnv::ok;
 508 }
 509 
 510 // constructor used to create a method
 511 JVMCIEnv::CodeInstallResult CodeInstaller::install(JVMCICompiler* compiler, Handle target, Handle compiled_code, CodeBlob*&amp; cb, Handle installed_code, Handle speculation_log, TRAPS) {
 512   CodeBuffer buffer("JVMCI Compiler CodeBuffer");
 513   jobject compiled_code_obj = JNIHandles::make_local(compiled_code());
 514   OopRecorder* recorder = new OopRecorder(&amp;_arena, true);
 515   initialize_dependencies(JNIHandles::resolve(compiled_code_obj), recorder, CHECK_OK);
 516 
 517   // Get instructions and constants CodeSections early because we need it.
 518   _instructions = buffer.insts();
 519   _constants = buffer.consts();
 520 
 521   initialize_fields(target(), JNIHandles::resolve(compiled_code_obj), CHECK_OK);
 522   JVMCIEnv::CodeInstallResult result = initialize_buffer(buffer, CHECK_OK);
 523   if (result != JVMCIEnv::ok) {
 524     return result;
 525   }
 526   process_exception_handlers();
 527 
 528   int stack_slots = _total_frame_size / HeapWordSize; // conversion to words
 529 
 530   if (!compiled_code-&gt;is_a(HotSpotCompiledNmethod::klass())) {
 531     oop stubName = HotSpotCompiledCode::name(compiled_code_obj);
 532     char* name = strdup(java_lang_String::as_utf8_string(stubName));
 533     cb = RuntimeStub::new_runtime_stub(name,
 534                                        &amp;buffer,
 535                                        CodeOffsets::frame_never_safe,
 536                                        stack_slots,
 537                                        _debug_recorder-&gt;_oopmaps,
 538                                        false);
 539     result = JVMCIEnv::ok;
 540   } else {
 541     nmethod* nm = NULL;
 542     methodHandle method = getMethodFromHotSpotMethod(HotSpotCompiledNmethod::method(compiled_code));
 543     jint entry_bci = HotSpotCompiledNmethod::entryBCI(compiled_code);
 544     jint id = HotSpotCompiledNmethod::id(compiled_code);
 545     bool has_unsafe_access = HotSpotCompiledNmethod::hasUnsafeAccess(compiled_code) == JNI_TRUE;
 546     JVMCIEnv* env = (JVMCIEnv*) (address) HotSpotCompiledNmethod::jvmciEnv(compiled_code);
 547     if (id == -1) {
 548       // Make sure a valid compile_id is associated with every compile
 549       id = CompileBroker::assign_compile_id_unlocked(Thread::current(), method, entry_bci);
 550     }
 551     result = JVMCIEnv::register_method(method, nm, entry_bci, &amp;_offsets, _custom_stack_area_offset, &amp;buffer,
 552                                        stack_slots, _debug_recorder-&gt;_oopmaps, &amp;_exception_handler_table,
 553                                        compiler, _debug_recorder, _dependencies, env, id,
 554                                        has_unsafe_access, _has_wide_vector, installed_code, compiled_code, speculation_log);
 555     cb = nm;
 556   }
 557 
 558   if (cb != NULL) {
 559     // Make sure the pre-calculated constants section size was correct.
 560     guarantee((cb-&gt;code_begin() - cb-&gt;content_begin()) &gt;= _constants_size, "%d &lt; %d", (int)(cb-&gt;code_begin() - cb-&gt;content_begin()), _constants_size);
 561   }
 562   return result;
 563 }
 564 
 565 void CodeInstaller::initialize_fields(oop target, oop compiled_code, TRAPS) {
 566   if (compiled_code-&gt;is_a(HotSpotCompiledNmethod::klass())) {
 567     Handle hotspotJavaMethod = HotSpotCompiledNmethod::method(compiled_code);
 568     methodHandle method = getMethodFromHotSpotMethod(hotspotJavaMethod());
 569     _parameter_count = method-&gt;size_of_parameters();
 570     TRACE_jvmci_2("installing code for %s", method-&gt;name_and_sig_as_C_string());
 571   } else {
 572     // Must be a HotSpotCompiledRuntimeStub.
 573     // Only used in OopMap constructor for non-product builds
 574     _parameter_count = 0;
 575   }
 576   _sites_handle = JNIHandles::make_local(HotSpotCompiledCode::sites(compiled_code));
 577   _exception_handlers_handle = JNIHandles::make_local(HotSpotCompiledCode::exceptionHandlers(compiled_code));
 578 
 579   _code_handle = JNIHandles::make_local(HotSpotCompiledCode::targetCode(compiled_code));
 580   _code_size = HotSpotCompiledCode::targetCodeSize(compiled_code);
 581   _total_frame_size = HotSpotCompiledCode::totalFrameSize(compiled_code);
 582   _custom_stack_area_offset = HotSpotCompiledCode::customStackAreaOffset(compiled_code);
 583 
 584   // Pre-calculate the constants section size.  This is required for PC-relative addressing.
 585   _data_section_handle = JNIHandles::make_local(HotSpotCompiledCode::dataSection(compiled_code));
 586   if ((_constants-&gt;alignment() % HotSpotCompiledCode::dataSectionAlignment(compiled_code)) != 0) {
 587     JVMCI_ERROR("invalid data section alignment: %d", HotSpotCompiledCode::dataSectionAlignment(compiled_code));
 588   }
 589   _constants_size = data_section()-&gt;length();
 590 
 591   _data_section_patches_handle = JNIHandles::make_local(HotSpotCompiledCode::dataSectionPatches(compiled_code));
 592 
 593 #ifndef PRODUCT
 594   _comments_handle = JNIHandles::make_local(HotSpotCompiledCode::comments(compiled_code));
 595 #endif
 596 
 597   _next_call_type = INVOKE_INVALID;
 598 
 599   _has_wide_vector = false;
 600 
 601   oop arch = TargetDescription::arch(target);
 602   _word_kind_handle = JNIHandles::make_local(Architecture::wordKind(arch));
 603 }
 604 
 605 int CodeInstaller::estimate_stubs_size(TRAPS) {
 606   // Estimate the number of static call stubs that might be emitted.
 607   int static_call_stubs = 0;
 608   objArrayOop sites = this-&gt;sites();
 609   for (int i = 0; i &lt; sites-&gt;length(); i++) {
 610     oop site = sites-&gt;obj_at(i);
 611     if (site != NULL &amp;&amp; site-&gt;is_a(CompilationResult_Mark::klass())) {
 612       oop id_obj = CompilationResult_Mark::id(site);
 613       if (id_obj != NULL) {
 614         if (!java_lang_boxing_object::is_instance(id_obj, T_INT)) {
 615           JVMCI_ERROR_0("expected Integer id, got %s", id_obj-&gt;klass()-&gt;signature_name());
 616         }
 617         jint id = id_obj-&gt;int_field(java_lang_boxing_object::value_offset_in_bytes(T_INT));
 618         if (id == INVOKESTATIC || id == INVOKESPECIAL) {
 619           static_call_stubs++;
 620         }
 621       }
 622     }
 623   }
 624   return static_call_stubs * CompiledStaticCall::to_interp_stub_size();
 625 }
 626 
 627 // perform data and call relocation on the CodeBuffer
 628 JVMCIEnv::CodeInstallResult CodeInstaller::initialize_buffer(CodeBuffer&amp; buffer, TRAPS) {
 629   HandleMark hm;
 630   objArrayHandle sites = this-&gt;sites();
 631   int locs_buffer_size = sites-&gt;length() * (relocInfo::length_limit + sizeof(relocInfo));
 632 
 633   // Allocate enough space in the stub section for the static call
 634   // stubs.  Stubs have extra relocs but they are managed by the stub
 635   // section itself so they don't need to be accounted for in the
 636   // locs_buffer above.
 637   int stubs_size = estimate_stubs_size(CHECK_OK);
 638   int total_size = round_to(_code_size, buffer.insts()-&gt;alignment()) + round_to(_constants_size, buffer.consts()-&gt;alignment()) + round_to(stubs_size, buffer.stubs()-&gt;alignment());
 639 
 640   if (total_size &gt; JVMCINMethodSizeLimit) {
 641     return JVMCIEnv::code_too_large;
 642   }
 643 
 644   buffer.initialize(total_size, locs_buffer_size);
 645   if (buffer.blob() == NULL) {
 646     return JVMCIEnv::cache_full;
 647   }
 648   buffer.initialize_stubs_size(stubs_size);
 649   buffer.initialize_consts_size(_constants_size);
 650 
 651   _debug_recorder = new DebugInformationRecorder(_oop_recorder);
 652   _debug_recorder-&gt;set_oopmaps(new OopMapSet());
 653 
 654   buffer.initialize_oop_recorder(_oop_recorder);
 655 
 656   // copy the constant data into the newly created CodeBuffer
 657   address end_data = _constants-&gt;start() + _constants_size;
 658   memcpy(_constants-&gt;start(), data_section()-&gt;base(T_BYTE), _constants_size);
 659   _constants-&gt;set_end(end_data);
 660 
 661   // copy the code into the newly created CodeBuffer
 662   address end_pc = _instructions-&gt;start() + _code_size;
 663   guarantee(_instructions-&gt;allocates2(end_pc), "initialize should have reserved enough space for all the code");
 664   memcpy(_instructions-&gt;start(), code()-&gt;base(T_BYTE), _code_size);
 665   _instructions-&gt;set_end(end_pc);
 666 
 667   for (int i = 0; i &lt; data_section_patches()-&gt;length(); i++) {
 668     Handle patch = data_section_patches()-&gt;obj_at(i);
 669     if (patch.is_null()) {
 670       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);
 671     }
 672     Handle reference = CompilationResult_DataPatch::reference(patch);
 673     if (reference.is_null()) {
 674       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);
 675     }
 676     if (!reference-&gt;is_a(CompilationResult_ConstantReference::klass())) {
 677       JVMCI_ERROR_OK("invalid patch in data section: %s", reference-&gt;klass()-&gt;signature_name());
 678     }
 679     Handle constant = CompilationResult_ConstantReference::constant(reference);
 680     if (constant.is_null()) {
 681       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);
 682     }
 683     address dest = _constants-&gt;start() + CompilationResult_Site::pcOffset(patch);
 684     if (constant-&gt;is_a(HotSpotMetaspaceConstantImpl::klass())) {
 685       if (HotSpotMetaspaceConstantImpl::compressed(constant)) {
 686 #ifdef _LP64
 687         *((narrowKlass*) dest) = record_narrow_metadata_reference(constant, CHECK_OK);
 688 #else
 689         JVMCI_ERROR_OK("unexpected compressed Klass* in 32-bit mode");
 690 #endif
 691       } else {
 692         *((Metadata**) dest) = record_metadata_reference(constant, CHECK_OK);
 693       }
 694     } else if (constant-&gt;is_a(HotSpotObjectConstantImpl::klass())) {
 695       Handle obj = HotSpotObjectConstantImpl::object(constant);
 696       jobject value = JNIHandles::make_local(obj());
 697       int oop_index = _oop_recorder-&gt;find_index(value);
 698 
 699       if (HotSpotObjectConstantImpl::compressed(constant)) {
 700 #ifdef _LP64
 701         _constants-&gt;relocate(dest, oop_Relocation::spec(oop_index), relocInfo::narrow_oop_in_const);
 702 #else
 703         JVMCI_ERROR_OK("unexpected compressed oop in 32-bit mode");
 704 #endif
 705       } else {
 706         _constants-&gt;relocate(dest, oop_Relocation::spec(oop_index));
 707       }
 708     } else {
 709       JVMCI_ERROR_OK("invalid constant in data section: %s", constant-&gt;klass()-&gt;signature_name());
 710     }
 711   }
 712   jint last_pc_offset = -1;
 713   for (int i = 0; i &lt; sites-&gt;length(); i++) {
 714     Handle site = sites-&gt;obj_at(i);
 715     if (site.is_null()) {
 716       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);
 717     }
 718 
 719     jint pc_offset = CompilationResult_Site::pcOffset(site);
 720 
 721     if (site-&gt;is_a(CompilationResult_Call::klass())) {
 722       TRACE_jvmci_4("call at %i", pc_offset);
 723       site_Call(buffer, pc_offset, site, CHECK_OK);
 724     } else if (site-&gt;is_a(CompilationResult_Infopoint::klass())) {
 725       // three reasons for infopoints denote actual safepoints
 726       oop reason = CompilationResult_Infopoint::reason(site);
 727       if (InfopointReason::SAFEPOINT() == reason || InfopointReason::CALL() == reason || InfopointReason::IMPLICIT_EXCEPTION() == reason) {
 728         TRACE_jvmci_4("safepoint at %i", pc_offset);
 729         site_Safepoint(buffer, pc_offset, site, CHECK_OK);
<a name="1" id="anc1"></a><span class="removed"> 730       } else if (InfopointReason::METHOD_START() == reason || InfopointReason::METHOD_END() == reason || InfopointReason::LINE_NUMBER() == reason) {</span>
<span class="removed"> 731         site_Infopoint(buffer, pc_offset, site, CHECK_OK);</span>
 732       } else {
<a name="2" id="anc2"></a><span class="changed"> 733         JVMCI_ERROR_OK("unknown infopoint reason at %i", pc_offset);</span>

 734       }
 735     } else if (site-&gt;is_a(CompilationResult_DataPatch::klass())) {
 736       TRACE_jvmci_4("datapatch at %i", pc_offset);
 737       site_DataPatch(buffer, pc_offset, site, CHECK_OK);
 738     } else if (site-&gt;is_a(CompilationResult_Mark::klass())) {
 739       TRACE_jvmci_4("mark at %i", pc_offset);
 740       site_Mark(buffer, pc_offset, site, CHECK_OK);
 741     } else {
 742       JVMCI_ERROR_OK("unexpected site subclass: %s", site-&gt;klass()-&gt;signature_name());
 743     }
 744     last_pc_offset = pc_offset;
 745 
 746     if (CodeInstallSafepointChecks &amp;&amp; SafepointSynchronize::do_call_back()) {
 747       // this is a hacky way to force a safepoint check but nothing else was jumping out at me.
 748       ThreadToNativeFromVM ttnfv(JavaThread::current());
 749     }
 750   }
 751 
 752 #ifndef PRODUCT
 753   if (comments() != NULL) {
 754     for (int i = 0; i &lt; comments()-&gt;length(); i++) {
 755       oop comment = comments()-&gt;obj_at(i);
 756       assert(comment-&gt;is_a(HotSpotCompiledCode_Comment::klass()), "cce");
 757       jint offset = HotSpotCompiledCode_Comment::pcOffset(comment);
 758       char* text = java_lang_String::as_utf8_string(HotSpotCompiledCode_Comment::text(comment));
 759       buffer.block_comment(offset, text);
 760     }
 761   }
 762 #endif
 763   return JVMCIEnv::ok;
 764 }
 765 
 766 void CodeInstaller::assumption_NoFinalizableSubclass(Handle assumption) {
 767   Handle receiverType_handle = Assumptions_NoFinalizableSubclass::receiverType(assumption());
 768   Klass* receiverType = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(receiverType_handle));
 769   _dependencies-&gt;assert_has_no_finalizable_subclasses(receiverType);
 770 }
 771 
 772 void CodeInstaller::assumption_ConcreteSubtype(Handle assumption) {
 773   Handle context_handle = Assumptions_ConcreteSubtype::context(assumption());
 774   Handle subtype_handle = Assumptions_ConcreteSubtype::subtype(assumption());
 775   Klass* context = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(context_handle));
 776   Klass* subtype = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(subtype_handle));
 777 
 778   assert(context-&gt;is_abstract(), "");
 779   _dependencies-&gt;assert_abstract_with_unique_concrete_subtype(context, subtype);
 780 }
 781 
 782 void CodeInstaller::assumption_LeafType(Handle assumption) {
 783   Handle context_handle = Assumptions_LeafType::context(assumption());
 784   Klass* context = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(context_handle));
 785 
 786   _dependencies-&gt;assert_leaf_type(context);
 787 }
 788 
 789 void CodeInstaller::assumption_ConcreteMethod(Handle assumption) {
 790   Handle impl_handle = Assumptions_ConcreteMethod::impl(assumption());
 791   Handle context_handle = Assumptions_ConcreteMethod::context(assumption());
 792 
 793   methodHandle impl = getMethodFromHotSpotMethod(impl_handle());
 794   Klass* context = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(context_handle));
 795 
 796   _dependencies-&gt;assert_unique_concrete_method(context, impl());
 797 }
 798 
 799 void CodeInstaller::assumption_CallSiteTargetValue(Handle assumption) {
 800   Handle callSite = Assumptions_CallSiteTargetValue::callSite(assumption());
 801   Handle methodHandle = Assumptions_CallSiteTargetValue::methodHandle(assumption());
 802 
 803   _dependencies-&gt;assert_call_site_target_value(callSite(), methodHandle());
 804 }
 805 
 806 void CodeInstaller::process_exception_handlers() {
 807   if (exception_handlers() != NULL) {
 808     objArrayOop handlers = exception_handlers();
 809     for (int i = 0; i &lt; handlers-&gt;length(); i++) {
 810       oop exc = handlers-&gt;obj_at(i);
 811       jint pc_offset = CompilationResult_Site::pcOffset(exc);
 812       jint handler_offset = CompilationResult_ExceptionHandler::handlerPos(exc);
 813 
 814       // Subtable header
 815       _exception_handler_table.add_entry(HandlerTableEntry(1, pc_offset, 0));
 816 
 817       // Subtable entry
 818       _exception_handler_table.add_entry(HandlerTableEntry(-1, handler_offset, 0));
 819     }
 820   }
 821 }
 822 
 823 // If deoptimization happens, the interpreter should reexecute these bytecodes.
 824 // This function mainly helps the compilers to set up the reexecute bit.
 825 static bool bytecode_should_reexecute(Bytecodes::Code code) {
 826   switch (code) {
 827     case Bytecodes::_invokedynamic:
 828     case Bytecodes::_invokevirtual:
 829     case Bytecodes::_invokeinterface:
 830     case Bytecodes::_invokespecial:
 831     case Bytecodes::_invokestatic:
 832       return false;
 833     default:
 834       return true;
 835     }
 836   return true;
 837 }
 838 
 839 GrowableArray&lt;ScopeValue*&gt;* CodeInstaller::record_virtual_objects(Handle debug_info, TRAPS) {
 840   objArrayHandle virtualObjects = DebugInfo::virtualObjectMapping(debug_info);
 841   if (virtualObjects.is_null()) {
 842     return NULL;
 843   }
 844   GrowableArray&lt;ScopeValue*&gt;* objects = new GrowableArray&lt;ScopeValue*&gt;(virtualObjects-&gt;length(), virtualObjects-&gt;length(), NULL);
 845   // Create the unique ObjectValues
 846   for (int i = 0; i &lt; virtualObjects-&gt;length(); i++) {
 847     Handle value = virtualObjects-&gt;obj_at(i);
 848     int id = VirtualObject::id(value);
 849     Handle type = VirtualObject::type(value);
 850     oop javaMirror = HotSpotResolvedObjectTypeImpl::javaClass(type);
 851     ObjectValue* sv = new ObjectValue(id, new ConstantOopWriteValue(JNIHandles::make_local(Thread::current(), javaMirror)));
 852     if (id &lt; 0 || id &gt;= objects-&gt;length()) {
 853       JVMCI_ERROR_NULL("virtual object id %d out of bounds", id);
 854     }
 855     if (objects-&gt;at(id) != NULL) {
 856       JVMCI_ERROR_NULL("duplicate virtual object id %d", id);
 857     }
 858     objects-&gt;at_put(id, sv);
 859   }
 860   // All the values which could be referenced by the VirtualObjects
 861   // exist, so now describe all the VirtualObjects themselves.
 862   for (int i = 0; i &lt; virtualObjects-&gt;length(); i++) {
 863     Handle value = virtualObjects-&gt;obj_at(i);
 864     int id = VirtualObject::id(value);
 865     record_object_value(objects-&gt;at(id)-&gt;as_ObjectValue(), value, objects, CHECK_NULL);
 866   }
 867   _debug_recorder-&gt;dump_object_pool(objects);
 868   return objects;
 869 }
 870 
<a name="3" id="anc3"></a><span class="changed"> 871 void CodeInstaller::record_scope(jint pc_offset, Handle debug_info, TRAPS) {</span>
 872   Handle position = DebugInfo::bytecodePosition(debug_info);
 873   if (position.is_null()) {
 874     // Stubs do not record scope info, just oop maps
 875     return;
 876   }
 877 
<a name="4" id="anc4"></a><span class="changed"> 878   GrowableArray&lt;ScopeValue*&gt;* objectMapping = record_virtual_objects(debug_info, CHECK);</span>
<span class="changed"> 879   record_scope(pc_offset, position, objectMapping, CHECK);</span>





 880 }
 881 
<a name="5" id="anc5"></a><span class="changed"> 882 void CodeInstaller::record_scope(jint pc_offset, Handle position, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {</span>
 883   Handle frame;
<a name="6" id="anc6"></a><span class="changed"> 884   if (position-&gt;is_a(BytecodeFrame::klass())) {</span>



 885     frame = position;
 886   }
 887   Handle caller_frame = BytecodePosition::caller(position);
 888   if (caller_frame.not_null()) {
<a name="7" id="anc7"></a><span class="changed"> 889     record_scope(pc_offset, caller_frame, objects, CHECK);</span>
 890   }
 891 
 892   Handle hotspot_method = BytecodePosition::method(position);
 893   Method* method = getMethodFromHotSpotMethod(hotspot_method());
 894   jint bci = BytecodePosition::bci(position);
 895   if (bci == BytecodeFrame::BEFORE_BCI()) {
 896     bci = SynchronizationEntryBCI;
 897   }
 898 
 899   TRACE_jvmci_2("Recording scope pc_offset=%d bci=%d method=%s", pc_offset, bci, method-&gt;name_and_sig_as_C_string());
 900 
 901   bool reexecute = false;
 902   if (frame.not_null()) {
 903     if (bci == SynchronizationEntryBCI){
 904        reexecute = false;
 905     } else {
 906       Bytecodes::Code code = Bytecodes::java_code_at(method, method-&gt;bcp_from(bci));
 907       reexecute = bytecode_should_reexecute(code);
 908       if (frame.not_null()) {
 909         reexecute = (BytecodeFrame::duringCall(frame) == JNI_FALSE);
 910       }
 911     }
 912   }
 913 
 914   DebugToken* locals_token = NULL;
 915   DebugToken* expressions_token = NULL;
 916   DebugToken* monitors_token = NULL;
 917   bool throw_exception = false;
 918 
 919   if (frame.not_null()) {
 920     jint local_count = BytecodeFrame::numLocals(frame);
 921     jint expression_count = BytecodeFrame::numStack(frame);
 922     jint monitor_count = BytecodeFrame::numLocks(frame);
 923     objArrayHandle values = BytecodeFrame::values(frame);
 924     objArrayHandle slotKinds = BytecodeFrame::slotKinds(frame);
 925 
 926     if (values.is_null() || slotKinds.is_null()) {
 927       THROW(vmSymbols::java_lang_NullPointerException());
 928     }
 929     if (local_count + expression_count + monitor_count != values-&gt;length()) {
 930       JVMCI_ERROR("unexpected values length %d in scope (%d locals, %d expressions, %d monitors)", values-&gt;length(), local_count, expression_count, monitor_count);
 931     }
 932     if (local_count + expression_count != slotKinds-&gt;length()) {
 933       JVMCI_ERROR("unexpected slotKinds length %d in scope (%d locals, %d expressions)", slotKinds-&gt;length(), local_count, expression_count);
 934     }
 935 
 936     GrowableArray&lt;ScopeValue*&gt;* locals = local_count &gt; 0 ? new GrowableArray&lt;ScopeValue*&gt; (local_count) : NULL;
 937     GrowableArray&lt;ScopeValue*&gt;* expressions = expression_count &gt; 0 ? new GrowableArray&lt;ScopeValue*&gt; (expression_count) : NULL;
 938     GrowableArray&lt;MonitorValue*&gt;* monitors = monitor_count &gt; 0 ? new GrowableArray&lt;MonitorValue*&gt; (monitor_count) : NULL;
 939 
 940     TRACE_jvmci_2("Scope at bci %d with %d values", bci, values-&gt;length());
 941     TRACE_jvmci_2("%d locals %d expressions, %d monitors", local_count, expression_count, monitor_count);
 942 
 943     for (jint i = 0; i &lt; values-&gt;length(); i++) {
 944       ScopeValue* second = NULL;
 945       Handle value = values-&gt;obj_at(i);
 946       if (i &lt; local_count) {
 947         BasicType type = JVMCIRuntime::kindToBasicType(slotKinds-&gt;obj_at(i), CHECK);
 948         ScopeValue* first = get_scope_value(value, type, objects, second, CHECK);
 949         if (second != NULL) {
 950           locals-&gt;append(second);
 951         }
 952         locals-&gt;append(first);
 953       } else if (i &lt; local_count + expression_count) {
 954         BasicType type = JVMCIRuntime::kindToBasicType(slotKinds-&gt;obj_at(i), CHECK);
 955         ScopeValue* first = get_scope_value(value, type, objects, second, CHECK);
 956         if (second != NULL) {
 957           expressions-&gt;append(second);
 958         }
 959         expressions-&gt;append(first);
 960       } else {
 961         MonitorValue *monitor = get_monitor_value(value, objects, CHECK);
 962         monitors-&gt;append(monitor);
 963       }
 964       if (second != NULL) {
 965         i++;
 966         if (i &gt;= values-&gt;length() || values-&gt;obj_at(i) != Value::ILLEGAL()) {
 967           JVMCI_ERROR("double-slot value not followed by Value.ILLEGAL");
 968         }
 969       }
 970     }
 971 
 972     locals_token = _debug_recorder-&gt;create_scope_values(locals);
 973     expressions_token = _debug_recorder-&gt;create_scope_values(expressions);
 974     monitors_token = _debug_recorder-&gt;create_monitor_values(monitors);
 975 
 976     throw_exception = BytecodeFrame::rethrowException(frame) == JNI_TRUE;
 977   }
 978 
 979   _debug_recorder-&gt;describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, false, false,
 980                                   locals_token, expressions_token, monitors_token);
 981 }
 982 
 983 void CodeInstaller::site_Safepoint(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {
 984   Handle debug_info = CompilationResult_Infopoint::debugInfo(site);
 985   if (debug_info.is_null()) {
 986     JVMCI_ERROR("debug info expected at safepoint at %i", pc_offset);
 987   }
 988 
 989   // address instruction = _instructions-&gt;start() + pc_offset;
 990   // jint next_pc_offset = Assembler::locate_next_instruction(instruction) - _instructions-&gt;start();
 991   OopMap *map = create_oop_map(debug_info, CHECK);
 992   _debug_recorder-&gt;add_safepoint(pc_offset, map);
<a name="8" id="anc8"></a><span class="changed"> 993   record_scope(pc_offset, debug_info, CHECK);</span>
 994   _debug_recorder-&gt;end_safepoint(pc_offset);
 995 }
 996 
 997 void CodeInstaller::site_Infopoint(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {
 998   Handle debug_info = CompilationResult_Infopoint::debugInfo(site);
 999   if (debug_info.is_null()) {
1000     JVMCI_ERROR("debug info expected at infopoint at %i", pc_offset);
1001   }
1002 
1003   _debug_recorder-&gt;add_non_safepoint(pc_offset);
<a name="9" id="anc9"></a><span class="changed">1004   record_scope(pc_offset, debug_info, CHECK);</span>
1005   _debug_recorder-&gt;end_non_safepoint(pc_offset);
1006 }
1007 
1008 void CodeInstaller::site_Call(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {
1009   Handle target = CompilationResult_Call::target(site);
1010   InstanceKlass* target_klass = InstanceKlass::cast(target-&gt;klass());
1011 
1012   Handle hotspot_method; // JavaMethod
1013   Handle foreign_call;
1014 
1015   if (target_klass-&gt;is_subclass_of(SystemDictionary::HotSpotForeignCallTarget_klass())) {
1016     foreign_call = target;
1017   } else {
1018     hotspot_method = target;
1019   }
1020 
1021   Handle debug_info = CompilationResult_Call::debugInfo(site);
1022 
1023   assert(hotspot_method.not_null() ^ foreign_call.not_null(), "Call site needs exactly one type");
1024 
1025   NativeInstruction* inst = nativeInstruction_at(_instructions-&gt;start() + pc_offset);
1026   jint next_pc_offset = CodeInstaller::pd_next_offset(inst, pc_offset, hotspot_method, CHECK);
1027 
1028   if (debug_info.not_null()) {
1029     OopMap *map = create_oop_map(debug_info, CHECK);
1030     _debug_recorder-&gt;add_safepoint(next_pc_offset, map);
<a name="10" id="anc10"></a><span class="changed">1031     record_scope(next_pc_offset, debug_info, CHECK);</span>
1032   }
1033 
1034   if (foreign_call.not_null()) {
1035     jlong foreign_call_destination = HotSpotForeignCallTarget::address(foreign_call);
1036     CodeInstaller::pd_relocate_ForeignCall(inst, foreign_call_destination, CHECK);
1037   } else { // method != NULL
1038     if (debug_info.is_null()) {
1039       JVMCI_ERROR("debug info expected at call at %i", pc_offset);
1040     }
1041 
1042     TRACE_jvmci_3("method call");
1043     CodeInstaller::pd_relocate_JavaMethod(hotspot_method, pc_offset, CHECK);
1044     if (_next_call_type == INVOKESTATIC || _next_call_type == INVOKESPECIAL) {
1045       // Need a static call stub for transitions from compiled to interpreted.
1046       CompiledStaticCall::emit_to_interp_stub(buffer, _instructions-&gt;start() + pc_offset);
1047     }
1048   }
1049 
1050   _next_call_type = INVOKE_INVALID;
1051 
1052   if (debug_info.not_null()) {
1053     _debug_recorder-&gt;end_safepoint(next_pc_offset);
1054   }
1055 }
1056 
1057 void CodeInstaller::site_DataPatch(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {
1058   Handle reference = CompilationResult_DataPatch::reference(site);
1059   if (reference.is_null()) {
1060     THROW(vmSymbols::java_lang_NullPointerException());
1061   } else if (reference-&gt;is_a(CompilationResult_ConstantReference::klass())) {
1062     Handle constant = CompilationResult_ConstantReference::constant(reference);
1063     if (constant.is_null()) {
1064       THROW(vmSymbols::java_lang_NullPointerException());
1065     } else if (constant-&gt;is_a(HotSpotObjectConstantImpl::klass())) {
1066       pd_patch_OopConstant(pc_offset, constant, CHECK);
1067     } else if (constant-&gt;is_a(HotSpotMetaspaceConstantImpl::klass())) {
1068       pd_patch_MetaspaceConstant(pc_offset, constant, CHECK);
1069     } else {
1070       JVMCI_ERROR("unknown constant type in data patch: %s", constant-&gt;klass()-&gt;signature_name());
1071     }
1072   } else if (reference-&gt;is_a(CompilationResult_DataSectionReference::klass())) {
1073     int data_offset = CompilationResult_DataSectionReference::offset(reference);
1074     if (0 &lt;= data_offset &amp;&amp; data_offset &lt; _constants_size) {
1075       pd_patch_DataSectionReference(pc_offset, data_offset);
1076     } else {
1077       JVMCI_ERROR("data offset 0x%X points outside data section (size 0x%X)", data_offset, _constants_size);
1078     }
1079   } else {
1080     JVMCI_ERROR("unknown data patch type: %s", reference-&gt;klass()-&gt;signature_name());
1081   }
1082 }
1083 
1084 void CodeInstaller::site_Mark(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {
1085   Handle id_obj = CompilationResult_Mark::id(site);
1086 
1087   if (id_obj.not_null()) {
1088     if (!java_lang_boxing_object::is_instance(id_obj(), T_INT)) {
1089       JVMCI_ERROR("expected Integer id, got %s", id_obj-&gt;klass()-&gt;signature_name());
1090     }
1091     jint id = id_obj-&gt;int_field(java_lang_boxing_object::value_offset_in_bytes(T_INT));
1092 
1093     address pc = _instructions-&gt;start() + pc_offset;
1094 
1095     switch (id) {
1096       case UNVERIFIED_ENTRY:
1097         _offsets.set_value(CodeOffsets::Entry, pc_offset);
1098         break;
1099       case VERIFIED_ENTRY:
1100         _offsets.set_value(CodeOffsets::Verified_Entry, pc_offset);
1101         break;
1102       case OSR_ENTRY:
1103         _offsets.set_value(CodeOffsets::OSR_Entry, pc_offset);
1104         break;
1105       case EXCEPTION_HANDLER_ENTRY:
1106         _offsets.set_value(CodeOffsets::Exceptions, pc_offset);
1107         break;
1108       case DEOPT_HANDLER_ENTRY:
1109         _offsets.set_value(CodeOffsets::Deopt, pc_offset);
1110         break;
1111       case INVOKEVIRTUAL:
1112       case INVOKEINTERFACE:
1113       case INLINE_INVOKE:
1114       case INVOKESTATIC:
1115       case INVOKESPECIAL:
1116         _next_call_type = (MarkId) id;
1117         _invoke_mark_pc = pc;
1118         break;
1119       case POLL_NEAR:
1120       case POLL_FAR:
1121       case POLL_RETURN_NEAR:
1122       case POLL_RETURN_FAR:
1123         pd_relocate_poll(pc, id, CHECK);
1124         break;
1125       case CARD_TABLE_SHIFT:
1126       case CARD_TABLE_ADDRESS:
1127       case HEAP_TOP_ADDRESS:
1128       case HEAP_END_ADDRESS:
1129       case NARROW_KLASS_BASE_ADDRESS:
1130       case CRC_TABLE_ADDRESS:
1131         break;
1132       default:
1133         JVMCI_ERROR("invalid mark id: %d", id);
1134         break;
1135     }
1136   }
1137 }
1138 
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="11" type="hidden" /></form></body></html>
