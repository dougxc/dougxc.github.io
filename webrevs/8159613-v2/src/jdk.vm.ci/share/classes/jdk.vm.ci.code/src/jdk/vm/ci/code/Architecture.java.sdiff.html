<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.amd64/src/jdk/vm/ci/amd64/AMD64.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code/BytecodeFrame.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code/Architecture.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.code;
  24 
  25 import java.nio.ByteOrder;
<span class="removed">  26 import java.util.Arrays;</span>
  27 
  28 import jdk.vm.ci.code.Register.RegisterCategory;
  29 import jdk.vm.ci.meta.JavaKind;
  30 import jdk.vm.ci.meta.PlatformKind;
  31 
  32 /**
  33  * Represents a CPU architecture, including information such as its endianness, CPU registers, word
  34  * width, etc.
  35  */
  36 public abstract class Architecture {
  37 
  38     /**
  39      * The architecture specific type of a native word.
  40      */
  41     private final PlatformKind wordKind;
  42 
  43     /**
  44      * The name of this architecture (e.g. "AMD64", "SPARCv9").
  45      */
  46     private final String name;
  47 
  48     /**
<span class="changed">  49      * Array of all available registers on this architecture. The index of each register in this</span>
<span class="changed">  50      * array is equal to its {@linkplain Register#number number}.</span>
  51      */
<span class="changed">  52     private final Register[] registers;</span>
  53 
  54     /**
  55      * The byte ordering can be either little or big endian.
  56      */
  57     private final ByteOrder byteOrder;
  58 
  59     /**
  60      * Whether the architecture supports unaligned memory accesses.
  61      */
  62     private final boolean unalignedMemoryAccess;
  63 
  64     /**
  65      * Mask of the barrier constants denoting the barriers that are not required to be explicitly
  66      * inserted under this architecture.
  67      */
  68     private final int implicitMemoryBarriers;
  69 
  70     /**
  71      * Offset in bytes from the beginning of a call instruction to the displacement.
  72      */
  73     private final int machineCodeCallDisplacementOffset;
  74 
  75     /**
  76      * The size of the return address pushed to the stack by a call instruction. A value of 0
  77      * denotes that call linkage uses registers instead (e.g. SPARC).
  78      */
  79     private final int returnAddressSize;
  80 
<span class="changed">  81     protected Architecture(String name, PlatformKind wordKind, ByteOrder byteOrder, boolean unalignedMemoryAccess, Register[] registers, int implicitMemoryBarriers, int nativeCallDisplacementOffset,</span>

  82                     int returnAddressSize) {
  83         this.name = name;
  84         this.registers = registers;
  85         this.wordKind = wordKind;
  86         this.byteOrder = byteOrder;
  87         this.unalignedMemoryAccess = unalignedMemoryAccess;
  88         this.implicitMemoryBarriers = implicitMemoryBarriers;
  89         this.machineCodeCallDisplacementOffset = nativeCallDisplacementOffset;
  90         this.returnAddressSize = returnAddressSize;
  91     }
  92 
  93     /**
  94      * Converts this architecture to a string.
  95      *
  96      * @return the string representation of this architecture
  97      */
  98     @Override
  99     public final String toString() {
 100         return getName().toLowerCase();
 101     }

</pre><hr></hr><pre>
 103     /**
 104      * Gets the natural size of words (typically registers and pointers) of this architecture, in
 105      * bytes.
 106      */
 107     public int getWordSize() {
 108         return wordKind.getSizeInBytes();
 109     }
 110 
 111     public PlatformKind getWordKind() {
 112         return wordKind;
 113     }
 114 
 115     /**
 116      * Gets the name of this architecture.
 117      */
 118     public String getName() {
 119         return name;
 120     }
 121 
 122     /**
<span class="changed"> 123      * Gets an array of all registers that exist on this architecture. This contains all registers</span>
 124      * that exist in the specification of this architecture. Not all of them may be available on
<span class="changed"> 125      * this particular architecture instance. The index of each register in this array is equal to</span>
 126      * its {@linkplain Register#number number}.
 127      */
<span class="changed"> 128     public Register[] getRegisters() {</span>
<span class="changed"> 129         return registers.clone();</span>
 130     }
 131 
 132     /**
<span class="changed"> 133      * Gets an array of all registers available for storing values on this architecture. This may be</span>
<span class="changed"> 134      * a subset of {@link #getRegisters()}, depending on the capabilities of this particular CPU.</span>
 135      */
<span class="changed"> 136     public Register[] getAvailableValueRegisters() {</span>
 137         return getRegisters();
 138     }
 139 
 140     public ByteOrder getByteOrder() {
 141         return byteOrder;
 142     }
 143 
 144     /**
 145      * @return true if the architecture supports unaligned memory accesses.
 146      */
 147     public boolean supportsUnalignedMemoryAccess() {
 148         return unalignedMemoryAccess;
 149     }
 150 
 151     /**
 152      * Gets the size of the return address pushed to the stack by a call instruction. A value of 0
 153      * denotes that call linkage uses registers instead.
 154      */
 155     public int getReturnAddressSize() {
 156         return returnAddressSize;

</pre><hr></hr><pre>
 189      * @return the largest kind that can be stored in a register {@code category}
 190      */
 191     public abstract PlatformKind getLargestStorableKind(RegisterCategory category);
 192 
 193     /**
 194      * Return the {@link PlatformKind} that is used to store values of a given {@link JavaKind}.
 195      */
 196     public abstract PlatformKind getPlatformKind(JavaKind javaKind);
 197 
 198     @Override
 199     public final boolean equals(Object obj) {
 200         if (obj == this) {
 201             return true;
 202         }
 203         if (obj instanceof Architecture) {
 204             Architecture that = (Architecture) obj;
 205             if (this.name.equals(that.name)) {
 206                 assert this.byteOrder.equals(that.byteOrder);
 207                 assert this.implicitMemoryBarriers == that.implicitMemoryBarriers;
 208                 assert this.machineCodeCallDisplacementOffset == that.machineCodeCallDisplacementOffset;
<span class="changed"> 209                 assert Arrays.equals(this.registers, that.registers);</span>
 210                 assert this.returnAddressSize == that.returnAddressSize;
 211                 assert this.unalignedMemoryAccess == that.unalignedMemoryAccess;
 212                 assert this.wordKind == that.wordKind;
 213                 return true;
 214             }
 215         }
 216         return false;
 217     }
 218 
 219     @Override
 220     public final int hashCode() {
 221         return name.hashCode();
 222     }
 223 }
</pre></td><td><pre>

</pre><hr></hr><pre>
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.code;
  24 
  25 import java.nio.ByteOrder;

  26 
  27 import jdk.vm.ci.code.Register.RegisterCategory;
  28 import jdk.vm.ci.meta.JavaKind;
  29 import jdk.vm.ci.meta.PlatformKind;
  30 
  31 /**
  32  * Represents a CPU architecture, including information such as its endianness, CPU registers, word
  33  * width, etc.
  34  */
  35 public abstract class Architecture {
  36 
  37     /**
  38      * The architecture specific type of a native word.
  39      */
  40     private final PlatformKind wordKind;
  41 
  42     /**
  43      * The name of this architecture (e.g. "AMD64", "SPARCv9").
  44      */
  45     private final String name;
  46 
  47     /**
<span class="changed">  48      * List of all available registers on this architecture. The index of each register in this list</span>
<span class="changed">  49      * is equal to its {@linkplain Register#number number}.</span>
  50      */
<span class="changed">  51     private final RegisterArray registers;</span>
  52 
  53     /**
  54      * The byte ordering can be either little or big endian.
  55      */
  56     private final ByteOrder byteOrder;
  57 
  58     /**
  59      * Whether the architecture supports unaligned memory accesses.
  60      */
  61     private final boolean unalignedMemoryAccess;
  62 
  63     /**
  64      * Mask of the barrier constants denoting the barriers that are not required to be explicitly
  65      * inserted under this architecture.
  66      */
  67     private final int implicitMemoryBarriers;
  68 
  69     /**
  70      * Offset in bytes from the beginning of a call instruction to the displacement.
  71      */
  72     private final int machineCodeCallDisplacementOffset;
  73 
  74     /**
  75      * The size of the return address pushed to the stack by a call instruction. A value of 0
  76      * denotes that call linkage uses registers instead (e.g. SPARC).
  77      */
  78     private final int returnAddressSize;
  79 
<span class="changed">  80     protected Architecture(String name, PlatformKind wordKind, ByteOrder byteOrder, boolean unalignedMemoryAccess, RegisterArray registers, int implicitMemoryBarriers,</span>
<span class="changed">  81                     int nativeCallDisplacementOffset,</span>
  82                     int returnAddressSize) {
  83         this.name = name;
  84         this.registers = registers;
  85         this.wordKind = wordKind;
  86         this.byteOrder = byteOrder;
  87         this.unalignedMemoryAccess = unalignedMemoryAccess;
  88         this.implicitMemoryBarriers = implicitMemoryBarriers;
  89         this.machineCodeCallDisplacementOffset = nativeCallDisplacementOffset;
  90         this.returnAddressSize = returnAddressSize;
  91     }
  92 
  93     /**
  94      * Converts this architecture to a string.
  95      *
  96      * @return the string representation of this architecture
  97      */
  98     @Override
  99     public final String toString() {
 100         return getName().toLowerCase();
 101     }

</pre><hr></hr><pre>
 103     /**
 104      * Gets the natural size of words (typically registers and pointers) of this architecture, in
 105      * bytes.
 106      */
 107     public int getWordSize() {
 108         return wordKind.getSizeInBytes();
 109     }
 110 
 111     public PlatformKind getWordKind() {
 112         return wordKind;
 113     }
 114 
 115     /**
 116      * Gets the name of this architecture.
 117      */
 118     public String getName() {
 119         return name;
 120     }
 121 
 122     /**
<span class="changed"> 123      * Gets the list of all registers that exist on this architecture. This contains all registers</span>
 124      * that exist in the specification of this architecture. Not all of them may be available on
<span class="changed"> 125      * this particular architecture instance. The index of each register in this list is equal to</span>
 126      * its {@linkplain Register#number number}.
 127      */
<span class="changed"> 128     public RegisterArray getRegisters() {</span>
<span class="changed"> 129         return registers;</span>
 130     }
 131 
 132     /**
<span class="changed"> 133      * Gets a list of all registers available for storing values on this architecture. This may be a</span>
<span class="changed"> 134      * subset of {@link #getRegisters()}, depending on the capabilities of this particular CPU.</span>
 135      */
<span class="changed"> 136     public RegisterArray getAvailableValueRegisters() {</span>
 137         return getRegisters();
 138     }
 139 
 140     public ByteOrder getByteOrder() {
 141         return byteOrder;
 142     }
 143 
 144     /**
 145      * @return true if the architecture supports unaligned memory accesses.
 146      */
 147     public boolean supportsUnalignedMemoryAccess() {
 148         return unalignedMemoryAccess;
 149     }
 150 
 151     /**
 152      * Gets the size of the return address pushed to the stack by a call instruction. A value of 0
 153      * denotes that call linkage uses registers instead.
 154      */
 155     public int getReturnAddressSize() {
 156         return returnAddressSize;

</pre><hr></hr><pre>
 189      * @return the largest kind that can be stored in a register {@code category}
 190      */
 191     public abstract PlatformKind getLargestStorableKind(RegisterCategory category);
 192 
 193     /**
 194      * Return the {@link PlatformKind} that is used to store values of a given {@link JavaKind}.
 195      */
 196     public abstract PlatformKind getPlatformKind(JavaKind javaKind);
 197 
 198     @Override
 199     public final boolean equals(Object obj) {
 200         if (obj == this) {
 201             return true;
 202         }
 203         if (obj instanceof Architecture) {
 204             Architecture that = (Architecture) obj;
 205             if (this.name.equals(that.name)) {
 206                 assert this.byteOrder.equals(that.byteOrder);
 207                 assert this.implicitMemoryBarriers == that.implicitMemoryBarriers;
 208                 assert this.machineCodeCallDisplacementOffset == that.machineCodeCallDisplacementOffset;
<span class="changed"> 209                 assert this.registers.equals(that.registers);</span>
 210                 assert this.returnAddressSize == that.returnAddressSize;
 211                 assert this.unalignedMemoryAccess == that.unalignedMemoryAccess;
 212                 assert this.wordKind == that.wordKind;
 213                 return true;
 214             }
 215         }
 216         return false;
 217     }
 218 
 219     @Override
 220     public final int hashCode() {
 221         return name.hashCode();
 222     }
 223 }
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.amd64/src/jdk/vm/ci/amd64/AMD64.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code/BytecodeFrame.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
