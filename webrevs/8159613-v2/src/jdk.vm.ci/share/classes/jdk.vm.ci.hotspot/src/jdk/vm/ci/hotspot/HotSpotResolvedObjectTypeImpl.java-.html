<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  30 
  31 import java.lang.annotation.Annotation;
  32 import java.lang.reflect.Array;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.Method;
  35 import java.lang.reflect.Modifier;
  36 import java.nio.ByteOrder;
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.HashMap;
  40 
  41 import jdk.vm.ci.common.JVMCIError;
  42 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  43 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  45 import jdk.vm.ci.meta.Assumptions.LeafType;
  46 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  47 import jdk.vm.ci.meta.Constant;
  48 import jdk.vm.ci.meta.JavaConstant;
  49 import jdk.vm.ci.meta.JavaKind;
  50 import jdk.vm.ci.meta.JavaType;
  51 import jdk.vm.ci.meta.ModifiersProvider;
  52 import jdk.vm.ci.meta.ResolvedJavaField;
  53 import jdk.vm.ci.meta.ResolvedJavaMethod;
  54 import jdk.vm.ci.meta.ResolvedJavaType;
  55 
  56 /**
  57  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.
  58  */
  59 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceWrapperObject {
  60 
  61     /**
  62      * The Java class this type represents.
  63      */
  64     private final Class&lt;?&gt; javaClass;
  65     private HashMap&lt;Long, HotSpotResolvedJavaField&gt; fieldCache;
  66     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCache;
  67     private HotSpotResolvedJavaField[] instanceFields;
  68     private HotSpotResolvedObjectTypeImpl[] interfaces;
  69     private HotSpotConstantPool constantPool;
  70     final HotSpotJVMCIMetaAccessContext context;
  71     private HotSpotResolvedObjectType arrayOfType;
  72 
  73     /**
  74      * Gets the JVMCI mirror for a {@link Class} object.
  75      *
  76      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}
  77      */
  78     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {
  79         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);
  80     }
  81 
  82     /**
  83      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the
  84      * underlying Klass*, it is used instead of the raw Klass*.
  85      *
  86      * Called from the VM.
  87      *
  88      * @param javaClass a {@link Class} object
  89      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
  90      */
  91     @SuppressWarnings("unused")
  92     private static HotSpotResolvedObjectTypeImpl fromMetaspace(Class&lt;?&gt; javaClass) {
  93         return fromObjectClass(javaClass);
  94     }
  95 
  96     /**
  97      * Creates the JVMCI mirror for a {@link Class} object.
  98      *
  99      * &lt;p&gt;
 100      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
 101      * {@link Class} type. Use {@link #fromObjectClass(Class)} or {@link #fromMetaspace(Class)}
 102      * instead.
 103      * &lt;/p&gt;
 104      *
 105      * @param javaClass the Class to create the mirror for
 106      * @param context
 107      */
 108     HotSpotResolvedObjectTypeImpl(Class&lt;?&gt; javaClass, HotSpotJVMCIMetaAccessContext context) {
 109         super(getSignatureName(javaClass));
 110         this.javaClass = javaClass;
 111         this.context = context;
 112         assert getName().charAt(0) != '[' || isArray() : getName();
 113     }
 114 
 115     /**
 116      * Returns the name of this type as it would appear in a signature.
 117      */
 118     private static String getSignatureName(Class&lt;?&gt; javaClass) {
 119         if (javaClass.isArray()) {
 120             return javaClass.getName().replace('.', '/');
 121         }
 122         return "L" + javaClass.getName().replace('.', '/') + ";";
 123     }
 124 
 125     /**
 126      * Gets the metaspace Klass for this type.
 127      */
 128     long getMetaspaceKlass() {
 129         if (HotSpotJVMCIRuntime.getHostWordKind() == JavaKind.Long) {
 130             return UNSAFE.getLong(javaClass, config().klassOffset);
 131         }
 132         return UNSAFE.getInt(javaClass, config().klassOffset) &amp; 0xFFFFFFFFL;
 133     }
 134 
 135     @Override
 136     public long getMetaspacePointer() {
 137         return getMetaspaceKlass();
 138     }
 139 
 140     /**
 141      * The Klass* for this object is kept alive by the direct reference to {@link #javaClass} so no
 142      * extra work is required.
 143      */
 144     @Override
 145     public boolean isRegistered() {
 146         return true;
 147     }
 148 
 149     @Override
 150     public int getModifiers() {
 151         if (isArray()) {
 152             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 153         } else {
 154             return getAccessFlags() &amp; ModifiersProvider.jvmClassModifiers();
 155         }
 156     }
 157 
 158     public int getAccessFlags() {
 159         HotSpotVMConfig config = config();
 160         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 161     }
 162 
 163     @Override
 164     public HotSpotResolvedObjectType getArrayClass() {
 165         if (arrayOfType == null) {
 166             arrayOfType = fromObjectClass(Array.newInstance(mirror(), 0).getClass());
 167         }
 168         return arrayOfType;
 169     }
 170 
 171     @Override
 172     public ResolvedJavaType getComponentType() {
 173         Class&lt;?&gt; javaComponentType = mirror().getComponentType();
 174         return javaComponentType == null ? null : runtime().fromClass(javaComponentType);
 175     }
 176 
 177     @Override
 178     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 179         if (isLeaf()) {
 180             // No assumptions are required.
 181             return new AssumptionResult&lt;&gt;(this);
 182         }
 183         HotSpotVMConfig config = config();
 184         if (isArray()) {
 185             ResolvedJavaType elementalType = getElementalType();
 186             AssumptionResult&lt;ResolvedJavaType&gt; elementType = elementalType.findLeafConcreteSubtype();
 187             if (elementType != null &amp;&amp; elementType.getResult().equals(elementalType)) {
 188                 /*
 189                  * If the elementType is leaf then the array is leaf under the same assumptions but
 190                  * only if the element type is exactly the leaf type. The element type can be
 191                  * abstract even if there is only one implementor of the abstract type.
 192                  */
 193                 AssumptionResult&lt;ResolvedJavaType&gt; result = new AssumptionResult&lt;&gt;(this);
 194                 result.add(elementType);
 195                 return result;
 196             }
 197             return null;
 198         } else if (isInterface()) {
 199             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
 200             /*
 201              * If the implementor field contains itself that indicates that the interface has more
 202              * than one implementors (see: InstanceKlass::add_implementor).
 203              */
 204             if (implementor == null || implementor.equals(this)) {
 205                 return null;
 206             }
 207 
 208             assert !implementor.isInterface();
 209             if (implementor.isAbstract() || !implementor.isLeafClass()) {
 210                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
 211                 if (leafConcreteSubtype != null) {
 212                     assert !leafConcreteSubtype.getResult().equals(implementor);
 213                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
 214                     // Accumulate leaf assumptions and return the combined result.
 215                     newResult.add(leafConcreteSubtype);
 216                     return newResult;
 217                 }
 218                 return null;
 219             }
 220             return concreteSubtype(implementor);
 221         } else {
 222             HotSpotResolvedObjectTypeImpl type = this;
 223             while (type.isAbstract()) {
 224                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
 225                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
 226                     return null;
 227                 }
 228                 type = subklass;
 229             }
 230             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
 231                 return null;
 232             }
 233             if (this.isAbstract()) {
 234                 return concreteSubtype(type);
 235             } else {
 236                 assert this.equals(type);
 237                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 238             }
 239         }
 240     }
 241 
 242     private AssumptionResult&lt;ResolvedJavaType&gt; concreteSubtype(HotSpotResolvedObjectTypeImpl type) {
 243         if (type.isLeaf()) {
 244             return new AssumptionResult&lt;&gt;(type, new ConcreteSubtype(this, type));
 245         } else {
 246             return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 247         }
 248     }
 249 
 250     /**
 251      * Returns if type {@code type} is a leaf class. This is the case if the
 252      * {@code Klass::_subklass} field of the underlying class is zero.
 253      *
 254      * @return true if the type is a leaf class
 255      */
 256     private boolean isLeafClass() {
 257         return getSubklass() == null;
 258     }
 259 
 260     /**
 261      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 262      * type {@code type}.
 263      *
 264      * @return value of the subklass field as metaspace klass pointer
 265      */
 266     private HotSpotResolvedObjectTypeImpl getSubklass() {
 267         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 268     }
 269 
 270     @Override
 271     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 272         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();
 273         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);
 274     }
 275 
 276     @Override
 277     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 278         if (interfaces == null) {
 279             Class&lt;?&gt;[] javaInterfaces = mirror().getInterfaces();
 280             HotSpotResolvedObjectTypeImpl[] result = new HotSpotResolvedObjectTypeImpl[javaInterfaces.length];
 281             for (int i = 0; i &lt; javaInterfaces.length; i++) {
 282                 result[i] = fromObjectClass(javaInterfaces[i]);
 283             }
 284             interfaces = result;
 285         }
 286         return interfaces;
 287     }
 288 
 289     @Override
 290     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 291         if (!isInterface()) {
 292             throw new JVMCIError("Cannot call getSingleImplementor() on a non-interface type: %s", this);
 293         }
 294         return compilerToVM().getImplementor(this);
 295     }
 296 
 297     public HotSpotResolvedObjectTypeImpl getSupertype() {
 298         if (isArray()) {
 299             ResolvedJavaType componentType = getComponentType();
 300             if (mirror() == Object[].class || componentType.isPrimitive()) {
 301                 return fromObjectClass(Object.class);
 302             }
 303             return (HotSpotResolvedObjectTypeImpl) ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype().getArrayClass();
 304         }
 305         if (isInterface()) {
 306             return fromObjectClass(Object.class);
 307         }
 308         return getSuperclass();
 309     }
 310 
 311     @Override
 312     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 313         if (otherType.isPrimitive()) {
 314             return null;
 315         } else {
 316             HotSpotResolvedObjectTypeImpl t1 = this;
 317             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 318             while (true) {
 319                 if (t1.isAssignableFrom(t2)) {
 320                     return t1;
 321                 }
 322                 if (t2.isAssignableFrom(t1)) {
 323                     return t2;
 324                 }
 325                 t1 = t1.getSupertype();
 326                 t2 = t2.getSupertype();
 327             }
 328         }
 329     }
 330 
 331     @Override
 332     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 333         assert !isArray();
 334         if (!compilerToVM().hasFinalizableSubclass(this)) {
 335             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 336         }
 337         return new AssumptionResult&lt;&gt;(true);
 338     }
 339 
 340     @Override
 341     public boolean hasFinalizer() {
 342         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 343     }
 344 
 345     @Override
 346     public boolean isPrimitive() {
 347         return false;
 348     }
 349 
 350     @Override
 351     public boolean isArray() {
 352         return mirror().isArray();
 353     }
 354 
 355     @Override
 356     public boolean isInitialized() {
 357         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 358     }
 359 
 360     @Override
 361     public boolean isLinked() {
 362         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 363     }
 364 
 365     /**
 366      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 367      * klass.
 368      *
 369      * @return state field value of this type
 370      */
 371     private int getInitState() {
 372         assert !isArray() : "_init_state only exists in InstanceKlass";
 373         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 374     }
 375 
 376     @Override
 377     public void initialize() {
 378         if (!isInitialized()) {
 379             UNSAFE.ensureClassInitialized(mirror());
 380             assert isInitialized();
 381         }
 382     }
 383 
 384     @Override
 385     public boolean isInstance(JavaConstant obj) {
 386         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
 387             return mirror().isInstance(((HotSpotObjectConstantImpl) obj).object());
 388         }
 389         return false;
 390     }
 391 
 392     @Override
 393     public boolean isInstanceClass() {
 394         return !isArray() &amp;&amp; !isInterface();
 395     }
 396 
 397     @Override
 398     public boolean isInterface() {
 399         return mirror().isInterface();
 400     }
 401 
 402     @Override
 403     public boolean isAssignableFrom(ResolvedJavaType other) {
 404         assert other != null;
 405         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 406             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
 407             return mirror().isAssignableFrom(otherType.mirror());
 408         }
 409         return false;
 410     }
 411 
 412     @Override
 413     public boolean isJavaLangObject() {
 414         return javaClass.equals(Object.class);
 415     }
 416 
 417     @Override
 418     public JavaKind getJavaKind() {
 419         return JavaKind.Object;
 420     }
 421 
 422     @Override
 423     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 424         assert !callerType.isArray();
 425         if (isInterface()) {
 426             // Methods can only be resolved against concrete types
 427             return null;
 428         }
 429         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic()) {
 430             return method;
 431         }
 432         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 433             return null;
 434         }
 435         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
 436         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
 437         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
 438     }
 439 
 440     public HotSpotConstantPool getConstantPool() {
 441         if (constantPool == null || !isArray() &amp;&amp; UNSAFE.getAddress(getMetaspaceKlass() + config().instanceKlassConstantsOffset) != constantPool.getMetaspaceConstantPool()) {
 442             /*
 443              * If the pointer to the ConstantPool has changed since this was last read refresh the
 444              * HotSpotConstantPool wrapper object. This ensures that uses of the constant pool are
 445              * operating on the latest one and that HotSpotResolvedJavaMethodImpls will be able to
 446              * use the shared copy instead of creating their own instance.
 447              */
 448             constantPool = compilerToVM().getConstantPool(this, config().instanceKlassConstantsOffset);
 449         }
 450         return constantPool;
 451     }
 452 
 453     /**
 454      * Gets the instance size of this type. If an instance of this type cannot be fast path
 455      * allocated, then the returned value is negative (its absolute value gives the size). Must not
 456      * be called if this is an array or interface type.
 457      */
 458     public int instanceSize() {
 459         assert !isArray();
 460         assert !isInterface();
 461 
 462         HotSpotVMConfig config = config();
 463         final int layoutHelper = layoutHelper();
 464         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : "must be instance";
 465 
 466         // See: Klass::layout_helper_size_in_bytes
 467         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 468 
 469         // See: Klass::layout_helper_needs_slow_path
 470         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 471 
 472         return needsSlowPath ? -size : size;
 473     }
 474 
 475     public int layoutHelper() {
 476         HotSpotVMConfig config = config();
 477         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 478     }
 479 
 480     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {
 481         HotSpotResolvedJavaMethodImpl method = null;
 482         if (methodCache == null) {
 483             methodCache = new HashMap&lt;&gt;(8);
 484         } else {
 485             method = methodCache.get(metaspaceMethod);
 486         }
 487         if (method == null) {
 488             method = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);
 489             methodCache.put(metaspaceMethod, method);
 490             context.add(method);
 491         }
 492         return method;
 493     }
 494 
 495     public int getVtableLength() {
 496         HotSpotVMConfig config = config();
 497         if (isInterface() || isArray()) {
 498             /* Everything has the core vtable of java.lang.Object */
 499             return config.baseVtableLength();
 500         }
 501         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 502         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + " " + config.vtableEntrySize;
 503         return result;
 504     }
 505 
 506     synchronized HotSpotResolvedJavaField createField(String fieldName, JavaType type, long offset, int rawFlags) {
 507         HotSpotResolvedJavaField result = null;
 508 
 509         final int flags = rawFlags &amp; ModifiersProvider.jvmFieldModifiers();
 510 
 511         final long id = offset + ((long) flags &lt;&lt; 32);
 512 
 513         // Must cache the fields, because the local load elimination only works if the
 514         // objects from two field lookups are identical.
 515         if (fieldCache == null) {
 516             fieldCache = new HashMap&lt;&gt;(8);
 517         } else {
 518             result = fieldCache.get(id);
 519         }
 520 
 521         if (result == null) {
 522             result = new HotSpotResolvedJavaFieldImpl(this, fieldName, type, offset, rawFlags);
 523             fieldCache.put(id, result);
 524         } else {
 525             assert result.getName().equals(fieldName);
 526             /*
 527              * Comparing the types directly is too strict, because the type in the cache could be
 528              * resolved while the incoming type is unresolved. The name comparison is sufficient
 529              * because the type will always be resolved in the context of the holder.
 530              */
 531             assert result.getType().getName().equals(type.getName());
 532             assert result.offset() == offset;
 533             assert result.getModifiers() == flags;
 534         }
 535 
 536         return result;
 537     }
 538 
 539     @Override
 540     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 541         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 542         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 543         /*
 544          * Sometimes the receiver type in the graph hasn't stabilized to a subtype of declared
 545          * holder, usually because of phis, so make sure that the type is related to the declared
 546          * type before using it for lookup. Unlinked types should also be ignored because we can't
 547          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 548          * a deopt instead since they can't really be used if they aren't linked yet.
 549          */
 550         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 551             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 552             if (result != null) {
 553                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 554             }
 555             return null;
 556         }
 557         /*
 558          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 559          * the correct method for the subtype.
 560          */
 561         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 562         if (resolvedMethod == null) {
 563             // The type isn't known to implement the method.
 564             return null;
 565         }
 566 
 567         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 568         if (result != null) {
 569             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 570         }
 571         return null;
 572     }
 573 
 574     /**
 575      * This class represents the field information for one field contained in the fields array of an
 576      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 577      */
 578     private class FieldInfo {
 579         /**
 580          * Native pointer into the array of Java shorts.
 581          */
 582         private final long metaspaceData;
 583 
 584         /**
 585          * Creates a field info for the field in the fields array at index {@code index}.
 586          *
 587          * @param index index to the fields array
 588          */
 589         FieldInfo(int index) {
 590             HotSpotVMConfig config = config();
 591             // Get Klass::_fields
 592             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 593             assert config.fieldInfoFieldSlots == 6 : "revisit the field parsing code";
 594             metaspaceData = metaspaceFields + config.arrayU2DataOffset + config.fieldInfoFieldSlots * Short.BYTES * index;
 595         }
 596 
 597         private int getAccessFlags() {
 598             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
 599         }
 600 
 601         private int getNameIndex() {
 602             return readFieldSlot(config().fieldInfoNameIndexOffset);
 603         }
 604 
 605         private int getSignatureIndex() {
 606             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
 607         }
 608 
 609         public int getOffset() {
 610             HotSpotVMConfig config = config();
 611             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
 612             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
 613             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
 614             return offset;
 615         }
 616 
 617         /**
 618          * Helper method to read an entry (slot) from the field array. Currently field info is laid
 619          * on top an array of Java shorts.
 620          */
 621         private int readFieldSlot(int index) {
 622             return UNSAFE.getChar(metaspaceData + Short.BYTES * index);
 623         }
 624 
 625         /**
 626          * Returns the name of this field as a {@link String}. If the field is an internal field the
 627          * name index is pointing into the vmSymbols table.
 628          */
 629         public String getName() {
 630             final int nameIndex = getNameIndex();
 631             return isInternal() ? HotSpotVmSymbols.symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
 632         }
 633 
 634         /**
 635          * Returns the signature of this field as {@link String}. If the field is an internal field
 636          * the signature index is pointing into the vmSymbols table.
 637          */
 638         public String getSignature() {
 639             final int signatureIndex = getSignatureIndex();
 640             return isInternal() ? HotSpotVmSymbols.symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
 641         }
 642 
 643         public JavaType getType() {
 644             String signature = getSignature();
 645             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 646         }
 647 
 648         private boolean isInternal() {
 649             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 650         }
 651 
 652         public boolean isStatic() {
 653             return Modifier.isStatic(getAccessFlags());
 654         }
 655 
 656         public boolean hasGenericSignature() {
 657             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 658         }
 659     }
 660 
 661     private static class OffsetComparator implements java.util.Comparator&lt;HotSpotResolvedJavaField&gt; {
 662         @Override
 663         public int compare(HotSpotResolvedJavaField o1, HotSpotResolvedJavaField o2) {
 664             return o1.offset() - o2.offset();
 665         }
 666     }
 667 
 668     @Override
 669     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 670         if (instanceFields == null) {
 671             if (isArray() || isInterface()) {
 672                 instanceFields = new HotSpotResolvedJavaField[0];
 673             } else {
 674                 final int fieldCount = getFieldCount();
 675                 ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 676 
 677                 for (int i = 0; i &lt; fieldCount; i++) {
 678                     FieldInfo field = new FieldInfo(i);
 679 
 680                     // We are only interested in instance fields.
 681                     if (!field.isStatic()) {
 682                         HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 683                         fieldsArray.add(resolvedJavaField);
 684                     }
 685                 }
 686 
 687                 fieldsArray.sort(new OffsetComparator());
 688 
 689                 HotSpotResolvedJavaField[] myFields = fieldsArray.toArray(new HotSpotResolvedJavaField[0]);
 690 
 691                 if (mirror() != Object.class) {
 692                     HotSpotResolvedJavaField[] superFields = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 693                     HotSpotResolvedJavaField[] fields = Arrays.copyOf(superFields, superFields.length + myFields.length);
 694                     System.arraycopy(myFields, 0, fields, superFields.length, myFields.length);
 695                     instanceFields = fields;
 696                 } else {
 697                     assert myFields.length == 0 : "java.lang.Object has fields!";
 698                     instanceFields = myFields;
 699                 }
 700 
 701             }
 702         }
 703         if (!includeSuperclasses) {
 704             int myFieldsStart = 0;
 705             while (myFieldsStart &lt; instanceFields.length &amp;&amp; !instanceFields[myFieldsStart].getDeclaringClass().equals(this)) {
 706                 myFieldsStart++;
 707             }
 708             if (myFieldsStart == 0) {
 709                 return instanceFields;
 710             }
 711             if (myFieldsStart == instanceFields.length) {
 712                 return new HotSpotResolvedJavaField[0];
 713             }
 714             return Arrays.copyOfRange(instanceFields, myFieldsStart, instanceFields.length);
 715         }
 716         return instanceFields;
 717     }
 718 
 719     @Override
 720     public ResolvedJavaField[] getStaticFields() {
 721         if (isArray()) {
 722             return new HotSpotResolvedJavaField[0];
 723         } else {
 724             final int fieldCount = getFieldCount();
 725             ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 726 
 727             for (int i = 0; i &lt; fieldCount; i++) {
 728                 FieldInfo field = new FieldInfo(i);
 729 
 730                 // We are only interested in static fields.
 731                 if (field.isStatic()) {
 732                     HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 733                     fieldsArray.add(resolvedJavaField);
 734                 }
 735             }
 736 
 737             fieldsArray.sort(new OffsetComparator());
 738             return fieldsArray.toArray(new HotSpotResolvedJavaField[fieldsArray.size()]);
 739         }
 740     }
 741 
 742     /**
 743      * Returns the actual field count of this class's internal {@code InstanceKlass::_fields} array
 744      * by walking the array and discounting the generic signature slots at the end of the array.
 745      *
 746      * &lt;p&gt;
 747      * See {@code FieldStreamBase::init_generic_signature_start_slot}
 748      */
 749     private int getFieldCount() {
 750         HotSpotVMConfig config = config();
 751         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 752         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
 753         int fieldCount = 0;
 754 
 755         for (int i = 0, index = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
 756             FieldInfo field = new FieldInfo(index);
 757             if (field.hasGenericSignature()) {
 758                 metaspaceFieldsLength--;
 759             }
 760             fieldCount++;
 761         }
 762         return fieldCount;
 763     }
 764 
 765     @Override
 766     public Class&lt;?&gt; mirror() {
 767         return javaClass;
 768     }
 769 
 770     @Override
 771     public String getSourceFileName() {
 772         HotSpotVMConfig config = config();
 773         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
 774         if (sourceFileNameIndex == 0) {
 775             return null;
 776         }
 777         return getConstantPool().lookupUtf8(sourceFileNameIndex);
 778     }
 779 
 780     @Override
 781     public Annotation[] getAnnotations() {
 782         return mirror().getAnnotations();
 783     }
 784 
 785     @Override
 786     public Annotation[] getDeclaredAnnotations() {
 787         return mirror().getDeclaredAnnotations();
 788     }
 789 
 790     @Override
 791     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 792         return mirror().getAnnotation(annotationClass);
 793     }
 794 
 795     /**
 796      * Performs a fast-path check that this type is resolved in the context of a given accessing
 797      * class. A negative result does not mean this type is not resolved with respect to
 798      * {@code accessingClass}. That can only be determined by
 799      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 800      * re-resolving} the type.
 801      */
 802     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 803         assert accessingClass != null;
 804         ResolvedJavaType elementType = getElementalType();
 805         if (elementType.isPrimitive()) {
 806             // Primitive type resolution is context free.
 807             return true;
 808         }
 809         if (elementType.getName().startsWith("Ljava/")) {
 810             // Classes in a java.* package can only be defined by the
 811             // boot class loader. This is enforced by ClassLoader.preDefineClass()
 812             assert mirror().getClassLoader() == null;
 813             return true;
 814         }
 815         ClassLoader thisCl = mirror().getClassLoader();
 816         ClassLoader accessingClassCl = ((HotSpotResolvedObjectTypeImpl) accessingClass).mirror().getClassLoader();
 817         return thisCl == accessingClassCl;
 818     }
 819 
 820     @Override
 821     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 822         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 823             return this;
 824         }
 825         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 826         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 827     }
 828 
 829     /**
 830      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 831      */
 832     public Constant klass() {
 833         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 834     }
 835 
 836     public boolean isPrimaryType() {
 837         return config().secondarySuperCacheOffset != superCheckOffset();
 838     }
 839 
 840     public int superCheckOffset() {
 841         HotSpotVMConfig config = config();
 842         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
 843     }
 844 
 845     public long prototypeMarkWord() {
 846         HotSpotVMConfig config = config();
 847         if (isArray()) {
 848             return config.arrayPrototypeMarkWord();
 849         } else {
 850             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 851         }
 852     }
 853 
 854     @Override
 855     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 856         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 857         for (ResolvedJavaField field : declaredFields) {
 858             HotSpotResolvedJavaField resolvedField = (HotSpotResolvedJavaField) field;
 859             long resolvedFieldOffset = resolvedField.offset();
 860             // @formatter:off
 861             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN  &amp;&amp;
 862                             expectedEntryKind.isPrimitive() &amp;&amp;
 863                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;
 864                             resolvedField.getJavaKind().isPrimitive()) {
 865                 resolvedFieldOffset +=
 866                                 resolvedField.getJavaKind().getByteCount() -
 867                                 Math.min(resolvedField.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());
 868             }
 869             if (resolvedFieldOffset == offset) {
 870                 return field;
 871             }
 872             // @formatter:on
 873         }
 874         return null;
 875     }
 876 
 877     @Override
 878     public boolean isLocal() {
 879         return mirror().isLocalClass();
 880     }
 881 
 882     @Override
 883     public boolean isMember() {
 884         return mirror().isMemberClass();
 885     }
 886 
 887     @Override
 888     public HotSpotResolvedObjectTypeImpl getEnclosingType() {
 889         final Class&lt;?&gt; encl = mirror().getEnclosingClass();
 890         return encl == null ? null : fromObjectClass(encl);
 891     }
 892 
 893     @Override
 894     public ResolvedJavaMethod[] getDeclaredConstructors() {
 895         Constructor&lt;?&gt;[] constructors = mirror().getDeclaredConstructors();
 896         ResolvedJavaMethod[] result = new ResolvedJavaMethod[constructors.length];
 897         for (int i = 0; i &lt; constructors.length; i++) {
 898             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(constructors[i]);
 899             assert result[i].isConstructor();
 900         }
 901         return result;
 902     }
 903 
 904     @Override
 905     public ResolvedJavaMethod[] getDeclaredMethods() {
 906         Method[] methods = mirror().getDeclaredMethods();
 907         ResolvedJavaMethod[] result = new ResolvedJavaMethod[methods.length];
 908         for (int i = 0; i &lt; methods.length; i++) {
 909             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(methods[i]);
 910             assert !result[i].isConstructor();
 911         }
 912         return result;
 913     }
 914 
 915     public ResolvedJavaMethod getClassInitializer() {
 916         return compilerToVM().getClassInitializer(this);
 917     }
 918 
 919     @Override
 920     public String toString() {
 921         return "HotSpotType&lt;" + getName() + ", resolved&gt;";
 922     }
 923 
 924     @Override
 925     public boolean isCloneableWithAllocation() {
 926         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
 927     }
 928 }
</pre></body></html>
