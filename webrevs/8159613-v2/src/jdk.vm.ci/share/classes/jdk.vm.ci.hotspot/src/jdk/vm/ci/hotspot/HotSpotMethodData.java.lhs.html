<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.lang.String.format;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  30 
  31 import java.util.Arrays;
  32 
<a name="1" id="anc1"></a><span class="changed">  33 import jdk.vm.ci.hotspot.HotSpotMethodDataAccessor.Tag;</span>
  34 import jdk.vm.ci.meta.DeoptimizationReason;
  35 import jdk.vm.ci.meta.JavaMethodProfile;
  36 import jdk.vm.ci.meta.JavaMethodProfile.ProfiledMethod;
  37 import jdk.vm.ci.meta.JavaTypeProfile;
  38 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;
  39 import jdk.vm.ci.meta.ResolvedJavaMethod;
  40 import jdk.vm.ci.meta.ResolvedJavaType;
  41 import jdk.vm.ci.meta.TriState;
<a name="2" id="anc2"></a><span class="removed">  42 import jdk.internal.misc.Unsafe;</span>
  43 
  44 /**
<a name="3" id="anc3"></a><span class="changed">  45  * Access to a HotSpot MethodData structure (defined in methodData.hpp).</span>
  46  */
<a name="4" id="anc4"></a><span class="changed">  47 public final class HotSpotMethodData {</span>
  48 
<a name="5" id="anc5"></a><span class="changed">  49     private static final HotSpotVMConfig config = config();</span>
<span class="changed">  50     private static final HotSpotMethodDataAccessor NO_DATA_NO_EXCEPTION_ACCESSOR = new NoMethodData(TriState.FALSE);</span>
<span class="changed">  51     private static final HotSpotMethodDataAccessor NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR = new NoMethodData(TriState.UNKNOWN);</span>
<span class="changed">  52 </span>
<span class="changed">  53     // sorted by tag</span>
<span class="changed">  54     // @formatter:off</span>
<span class="changed">  55     private static final HotSpotMethodDataAccessor[] PROFILE_DATA_ACCESSORS = {</span>
<span class="changed">  56         null,</span>
<span class="changed">  57         new BitData(),</span>
<span class="changed">  58         new CounterData(),</span>
<span class="changed">  59         new JumpData(),</span>
<span class="changed">  60         new ReceiverTypeData(),</span>
<span class="changed">  61         new VirtualCallData(),</span>
<span class="changed">  62         new RetData(),</span>
<span class="changed">  63         new BranchData(),</span>
<span class="changed">  64         new MultiBranchData(),</span>
<span class="changed">  65         new ArgInfoData(),</span>
<span class="changed">  66         new UnknownProfileData(Tag.CallTypeData),</span>
<span class="changed">  67         new VirtualCallTypeData(),</span>
<span class="changed">  68         new UnknownProfileData(Tag.ParametersTypeData),</span>
<span class="changed">  69         new UnknownProfileData(Tag.SpeculativeTrapData),</span>
<span class="changed">  70     };</span>
<span class="changed">  71     // @formatter:on</span>
  72 
  73     /**
  74      * Reference to the C++ MethodData object.
  75      */
<a name="6" id="anc6"></a><span class="changed">  76     private final long metaspaceMethodData;</span>
  77     @SuppressWarnings("unused") private final HotSpotResolvedJavaMethodImpl method;
  78 
  79     public HotSpotMethodData(long metaspaceMethodData, HotSpotResolvedJavaMethodImpl method) {
  80         this.metaspaceMethodData = metaspaceMethodData;
  81         this.method = method;
  82     }
  83 
  84     /**
  85      * @return value of the MethodData::_data_size field
  86      */
  87     private int normalDataSize() {
  88         return UNSAFE.getInt(metaspaceMethodData + config.methodDataDataSize);
  89     }
  90 
  91     /**
  92      * Returns the size of the extra data records. This method does the same calculation as
  93      * MethodData::extra_data_size().
  94      *
  95      * @return size of extra data records
  96      */
  97     private int extraDataSize() {
  98         final int extraDataBase = config.methodDataOopDataOffset + normalDataSize();
  99         final int extraDataLimit = UNSAFE.getInt(metaspaceMethodData + config.methodDataSize);
 100         return extraDataLimit - extraDataBase;
 101     }
 102 
 103     public boolean hasNormalData() {
 104         return normalDataSize() &gt; 0;
 105     }
 106 
 107     public boolean hasExtraData() {
 108         return extraDataSize() &gt; 0;
 109     }
 110 
 111     public int getExtraDataBeginOffset() {
 112         return normalDataSize();
 113     }
 114 
 115     public boolean isWithin(int position) {
 116         return position &gt;= 0 &amp;&amp; position &lt; normalDataSize() + extraDataSize();
 117     }
 118 
 119     public int getDeoptimizationCount(DeoptimizationReason reason) {
 120         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
 121         int reasonIndex = metaAccess.convertDeoptReason(reason);
 122         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + reasonIndex) &amp; 0xFF;
 123     }
 124 
 125     public int getOSRDeoptimizationCount(DeoptimizationReason reason) {
 126         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
 127         int reasonIndex = metaAccess.convertDeoptReason(reason);
 128         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + config.deoptReasonOSROffset + reasonIndex) &amp; 0xFF;
 129     }
 130 
 131     public HotSpotMethodDataAccessor getNormalData(int position) {
 132         if (position &gt;= normalDataSize()) {
 133             return null;
 134         }
 135 
<a name="7" id="anc7"></a><span class="changed"> 136         HotSpotMethodDataAccessor result = getData(position);</span>
<span class="changed"> 137         final Tag tag = AbstractMethodData.readTag(this, position);</span>
<span class="changed"> 138         assert result != null : "NO_DATA tag is not allowed " + tag;</span>
<span class="changed"> 139         return result;</span>
 140     }
 141 
 142     public HotSpotMethodDataAccessor getExtraData(int position) {
 143         if (position &gt;= normalDataSize() + extraDataSize()) {
 144             return null;
 145         }
 146         HotSpotMethodDataAccessor data = getData(position);
 147         if (data != null) {
 148             return data;
 149         }
 150         return data;
 151     }
 152 
 153     public static HotSpotMethodDataAccessor getNoDataAccessor(boolean exceptionPossiblyNotRecorded) {
 154         if (exceptionPossiblyNotRecorded) {
 155             return NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR;
 156         } else {
 157             return NO_DATA_NO_EXCEPTION_ACCESSOR;
 158         }
 159     }
 160 
 161     private HotSpotMethodDataAccessor getData(int position) {
 162         assert position &gt;= 0 : "out of bounds";
<a name="8" id="anc8"></a><span class="changed"> 163         final Tag tag = AbstractMethodData.readTag(this, position);</span>
<span class="changed"> 164         HotSpotMethodDataAccessor accessor = PROFILE_DATA_ACCESSORS[tag.getValue()];</span>
 165         assert accessor == null || accessor.getTag() == tag : "wrong data accessor " + accessor + " for tag " + tag;
 166         return accessor;
 167     }
 168 
<a name="9" id="anc9"></a><span class="changed"> 169     private int readUnsignedByte(int position, int offsetInBytes) {</span>
 170         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 171         return UNSAFE.getByte(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFF;
 172     }
 173 
<a name="10" id="anc10"></a><span class="changed"> 174     private int readUnsignedShort(int position, int offsetInBytes) {</span>
 175         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 176         return UNSAFE.getShort(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFF;
 177     }
 178 
 179     /**
 180      * Since the values are stored in cells (platform words) this method uses
 181      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
 182      */
 183     private long readUnsignedInt(int position, int offsetInBytes) {
 184         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 185         return UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFFFFFFL;
 186     }
 187 
 188     private int readUnsignedIntAsSignedInt(int position, int offsetInBytes) {
 189         long value = readUnsignedInt(position, offsetInBytes);
 190         return truncateLongToInt(value);
 191     }
 192 
 193     /**
 194      * Since the values are stored in cells (platform words) this method uses
 195      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
 196      */
 197     private int readInt(int position, int offsetInBytes) {
 198         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 199         return (int) UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes);
 200     }
 201 
 202     private HotSpotResolvedJavaMethod readMethod(int position, int offsetInBytes) {
 203         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 204         return compilerToVM().getResolvedJavaMethod(null, metaspaceMethodData + fullOffsetInBytes);
 205     }
 206 
 207     private HotSpotResolvedObjectTypeImpl readKlass(int position, int offsetInBytes) {
 208         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 209         return compilerToVM().getResolvedJavaType(null, metaspaceMethodData + fullOffsetInBytes, false);
 210     }
 211 
 212     private static int truncateLongToInt(long value) {
 213         return value &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) value;
 214     }
 215 
 216     private static int computeFullOffset(int position, int offsetInBytes) {
 217         return config.methodDataOopDataOffset + position + offsetInBytes;
 218     }
 219 
 220     private static int cellIndexToOffset(int cells) {
 221         return config.dataLayoutHeaderSize + cellsToBytes(cells);
 222     }
 223 
 224     private static int cellsToBytes(int cells) {
 225         return cells * config.dataLayoutCellSize;
 226     }
 227 
 228     /**
 229      * Returns whether profiling ran long enough that the profile information is mature. Other
 230      * informational data will still be valid even if the profile isn't mature.
 231      */
 232     public boolean isProfileMature() {
 233         return runtime().getCompilerToVM().isMature(metaspaceMethodData);
 234     }
 235 
 236     @Override
 237     public String toString() {
 238         StringBuilder sb = new StringBuilder();
 239         String nl = String.format("%n");
 240         String nlIndent = String.format("%n%38s", "");
 241         if (hasNormalData()) {
 242             int pos = 0;
 243             HotSpotMethodDataAccessor data;
 244             while ((data = getNormalData(pos)) != null) {
 245                 if (pos != 0) {
 246                     sb.append(nl);
 247                 }
 248                 int bci = data.getBCI(this, pos);
 249                 sb.append(String.format("%-6d bci: %-6d%-20s", pos, bci, data.getClass().getSimpleName()));
 250                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
 251                 pos = pos + data.getSize(this, pos);
 252             }
 253         }
 254 
 255         if (hasExtraData()) {
 256             int pos = getExtraDataBeginOffset();
 257             HotSpotMethodDataAccessor data;
 258             while ((data = getExtraData(pos)) != null) {
 259                 if (pos == getExtraDataBeginOffset()) {
 260                     sb.append(nl).append("--- Extra data:");
 261                 }
 262                 int bci = data.getBCI(this, pos);
 263                 sb.append(String.format("%n%-6d bci: %-6d%-20s", pos, bci, data.getClass().getSimpleName()));
 264                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
 265                 pos = pos + data.getSize(this, pos);
 266             }
 267 
 268         }
 269         return sb.toString();
 270     }
 271 
<a name="11" id="anc11"></a><span class="changed"> 272     private abstract static class AbstractMethodData implements HotSpotMethodDataAccessor {</span>
<span class="changed"> 273 </span>
<span class="changed"> 274         /**</span>
<span class="changed"> 275          * Corresponds to {@code exception_seen_flag}.</span>
<span class="changed"> 276          */</span>
<span class="changed"> 277         private static final int EXCEPTIONS_MASK = 1 &lt;&lt; config.bitDataExceptionSeenFlag;</span>
<span class="changed"> 278 </span>
<span class="changed"> 279         private final Tag tag;</span>
<span class="changed"> 280         protected final int staticSize;</span>
<span class="changed"> 281 </span>
<span class="changed"> 282         protected AbstractMethodData(Tag tag, int staticSize) {</span>
<span class="changed"> 283             this.tag = tag;</span>
<span class="changed"> 284             this.staticSize = staticSize;</span>
<span class="changed"> 285         }</span>
<span class="changed"> 286 </span>
<span class="changed"> 287         public Tag getTag() {</span>
<span class="changed"> 288             return tag;</span>
<span class="changed"> 289         }</span>
<span class="changed"> 290 </span>
<span class="changed"> 291         public static Tag readTag(HotSpotMethodData data, int position) {</span>
<span class="changed"> 292             final int tag = data.readUnsignedByte(position, config.dataLayoutTagOffset);</span>
<span class="changed"> 293             return Tag.getEnum(tag);</span>
<span class="changed"> 294         }</span>
<span class="changed"> 295 </span>
<span class="changed"> 296         @Override</span>
<span class="changed"> 297         public int getBCI(HotSpotMethodData data, int position) {</span>
<span class="changed"> 298             return data.readUnsignedShort(position, config.dataLayoutBCIOffset);</span>
<span class="changed"> 299         }</span>
<span class="changed"> 300 </span>
<span class="changed"> 301         @Override</span>
<span class="changed"> 302         public final int getSize(HotSpotMethodData data, int position) {</span>
<span class="changed"> 303             int size = staticSize + getDynamicSize(data, position);</span>
<span class="changed"> 304             // Sanity check against VM</span>
<span class="changed"> 305             int vmSize = HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);</span>
<span class="changed"> 306             assert size == vmSize : size + " != " + vmSize;</span>
<span class="changed"> 307             return size;</span>
<span class="changed"> 308         }</span>
<span class="changed"> 309 </span>
<span class="changed"> 310         @Override</span>
<span class="changed"> 311         public TriState getExceptionSeen(HotSpotMethodData data, int position) {</span>
<span class="changed"> 312             return TriState.get((getFlags(data, position) &amp; EXCEPTIONS_MASK) != 0);</span>
<span class="changed"> 313         }</span>
<span class="changed"> 314 </span>
<span class="changed"> 315         @Override</span>
<span class="changed"> 316         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {</span>
<span class="changed"> 317             return null;</span>
<span class="changed"> 318         }</span>
<span class="changed"> 319 </span>
<span class="changed"> 320         @Override</span>
<span class="changed"> 321         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {</span>
<span class="changed"> 322             return null;</span>
<span class="changed"> 323         }</span>
<span class="changed"> 324 </span>
<span class="changed"> 325         @Override</span>
<span class="changed"> 326         public double getBranchTakenProbability(HotSpotMethodData data, int position) {</span>
<span class="changed"> 327             return -1;</span>
<span class="changed"> 328         }</span>
 329 
<a name="12" id="anc12"></a><span class="changed"> 330         @Override</span>
<span class="changed"> 331         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {</span>
<span class="changed"> 332             return null;</span>
<span class="changed"> 333         }</span>
<span class="changed"> 334 </span>
<span class="changed"> 335         @Override</span>
<span class="changed"> 336         public int getExecutionCount(HotSpotMethodData data, int position) {</span>
<span class="changed"> 337             return -1;</span>
<span class="changed"> 338         }</span>
<span class="changed"> 339 </span>
<span class="changed"> 340         @Override</span>
<span class="changed"> 341         public TriState getNullSeen(HotSpotMethodData data, int position) {</span>
<span class="changed"> 342             return TriState.UNKNOWN;</span>
<span class="changed"> 343         }</span>
<span class="changed"> 344 </span>
<span class="changed"> 345         protected int getFlags(HotSpotMethodData data, int position) {</span>
<span class="changed"> 346             return data.readUnsignedByte(position, config.dataLayoutFlagsOffset);</span>
<span class="changed"> 347         }</span>
<span class="changed"> 348 </span>
<span class="changed"> 349         /**</span>
<span class="changed"> 350          * @param data</span>
<span class="changed"> 351          * @param position</span>
<span class="changed"> 352          */</span>
<span class="changed"> 353         protected int getDynamicSize(HotSpotMethodData data, int position) {</span>
<span class="changed"> 354             return 0;</span>
<span class="changed"> 355         }</span>
<span class="changed"> 356 </span>
<span class="changed"> 357         public abstract StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos);</span>
<span class="changed"> 358     }</span>
<span class="changed"> 359 </span>
<span class="changed"> 360     private static class NoMethodData extends AbstractMethodData {</span>
<span class="changed"> 361 </span>
<span class="changed"> 362         private static final int NO_DATA_SIZE = cellIndexToOffset(0);</span>
 363 
 364         private final TriState exceptionSeen;
 365 
<a name="13" id="anc13"></a><span class="changed"> 366         protected NoMethodData(TriState exceptionSeen) {</span>
<span class="changed"> 367             super(Tag.No, NO_DATA_SIZE);</span>
 368             this.exceptionSeen = exceptionSeen;
 369         }
 370 
 371         @Override
 372         public int getBCI(HotSpotMethodData data, int position) {
 373             return -1;
 374         }
 375 
 376         @Override
 377         public TriState getExceptionSeen(HotSpotMethodData data, int position) {
 378             return exceptionSeen;
 379         }
 380 
 381         @Override
 382         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 383             return sb;
 384         }
 385     }
 386 
<a name="14" id="anc14"></a><span class="changed"> 387     private static class BitData extends AbstractMethodData {</span>

 388 
<a name="15" id="anc15"></a><span class="changed"> 389         private static final int BIT_DATA_SIZE = cellIndexToOffset(0);</span>
<span class="changed"> 390         private static final int BIT_DATA_NULL_SEEN_FLAG = 1 &lt;&lt; config.bitDataNullSeenFlag;</span>
 391 
<a name="16" id="anc16"></a><span class="changed"> 392         private BitData() {</span>
<span class="changed"> 393             super(Tag.BitData, BIT_DATA_SIZE);</span>
 394         }
 395 
<a name="17" id="anc17"></a><span class="changed"> 396         protected BitData(Tag tag, int staticSize) {</span>
<span class="changed"> 397             super(tag, staticSize);</span>
 398         }
 399 
 400         @Override
 401         public TriState getNullSeen(HotSpotMethodData data, int position) {
 402             return TriState.get((getFlags(data, position) &amp; BIT_DATA_NULL_SEEN_FLAG) != 0);
 403         }
 404 
 405         @Override
 406         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 407             return sb.append(format("exception_seen(%s)", getExceptionSeen(data, pos)));
 408         }
 409     }
 410 
<a name="18" id="anc18"></a><span class="changed"> 411     private static class CounterData extends BitData {</span>

 412 
<a name="19" id="anc19"></a><span class="changed"> 413         private static final int COUNTER_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="changed"> 414         private static final int COUNTER_DATA_COUNT_OFFSET = cellIndexToOffset(config.methodDataCountOffset);</span>
 415 
<a name="20" id="anc20"></a><span class="changed"> 416         CounterData() {</span>
<span class="changed"> 417             super(Tag.CounterData, COUNTER_DATA_SIZE);</span>
 418         }
 419 
<a name="21" id="anc21"></a><span class="changed"> 420         protected CounterData(Tag tag, int staticSize) {</span>
<span class="changed"> 421             super(tag, staticSize);</span>
 422         }
 423 
 424         @Override
 425         public int getExecutionCount(HotSpotMethodData data, int position) {
 426             return getCounterValue(data, position);
 427         }
 428 
 429         protected int getCounterValue(HotSpotMethodData data, int position) {
 430             return data.readUnsignedIntAsSignedInt(position, COUNTER_DATA_COUNT_OFFSET);
 431         }
 432 
 433         @Override
 434         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 435             return sb.append(format("count(%d) null_seen(%s) exception_seen(%s)", getCounterValue(data, pos), getNullSeen(data, pos), getExceptionSeen(data, pos)));
 436         }
 437     }
 438 
<a name="22" id="anc22"></a><span class="changed"> 439     private static class JumpData extends AbstractMethodData {</span>


 440 
<a name="23" id="anc23"></a><span class="changed"> 441         private static final int JUMP_DATA_SIZE = cellIndexToOffset(2);</span>
<span class="changed"> 442         protected static final int TAKEN_COUNT_OFFSET = cellIndexToOffset(config.jumpDataTakenOffset);</span>
<span class="changed"> 443         protected static final int TAKEN_DISPLACEMENT_OFFSET = cellIndexToOffset(config.jumpDataDisplacementOffset);</span>
 444 
<a name="24" id="anc24"></a><span class="changed"> 445         JumpData() {</span>
<span class="changed"> 446             super(Tag.JumpData, JUMP_DATA_SIZE);</span>
 447         }
 448 
<a name="25" id="anc25"></a><span class="changed"> 449         protected JumpData(Tag tag, int staticSize) {</span>
<span class="changed"> 450             super(tag, staticSize);</span>
 451         }
 452 
 453         @Override
 454         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
 455             return getExecutionCount(data, position) != 0 ? 1 : 0;
 456         }
 457 
 458         @Override
 459         public int getExecutionCount(HotSpotMethodData data, int position) {
 460             return data.readUnsignedIntAsSignedInt(position, TAKEN_COUNT_OFFSET);
 461         }
 462 
 463         public int getTakenDisplacement(HotSpotMethodData data, int position) {
 464             return data.readInt(position, TAKEN_DISPLACEMENT_OFFSET);
 465         }
 466 
 467         @Override
 468         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 469             return sb.append(format("taken(%d) displacement(%d)", getExecutionCount(data, pos), getTakenDisplacement(data, pos)));
 470         }
 471     }
 472 
 473     static class RawItemProfile&lt;T&gt; {
 474         final int entries;
 475         final T[] items;
 476         final long[] counts;
 477         final long totalCount;
 478 
 479         RawItemProfile(int entries, T[] items, long[] counts, long totalCount) {
 480             this.entries = entries;
 481             this.items = items;
 482             this.counts = counts;
 483             this.totalCount = totalCount;
 484         }
 485     }
 486 
<a name="26" id="anc26"></a><span class="changed"> 487     private abstract static class AbstractTypeData extends CounterData {</span>
 488 
<a name="27" id="anc27"></a><span class="changed"> 489         protected static final int TYPE_DATA_ROW_SIZE = cellsToBytes(config.receiverTypeDataReceiverTypeRowCellCount);</span>


 490 
<a name="28" id="anc28"></a><span class="changed"> 491         protected static final int NONPROFILED_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);</span>
<span class="changed"> 492         protected static final int TYPE_DATA_FIRST_TYPE_OFFSET = cellIndexToOffset(config.receiverTypeDataReceiver0Offset);</span>
<span class="changed"> 493         protected static final int TYPE_DATA_FIRST_TYPE_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataCount0Offset);</span>
 494 
<a name="29" id="anc29"></a><span class="changed"> 495         protected AbstractTypeData(Tag tag, int staticSize) {</span>
<span class="changed"> 496             super(tag, staticSize);</span>
 497         }
 498 
 499         @Override
 500         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {
 501             return createTypeProfile(getNullSeen(data, position), getRawTypeProfile(data, position));
 502         }
 503 
 504         private RawItemProfile&lt;ResolvedJavaType&gt; getRawTypeProfile(HotSpotMethodData data, int position) {
 505             int typeProfileWidth = config.typeProfileWidth;
 506 
 507             ResolvedJavaType[] types = new ResolvedJavaType[typeProfileWidth];
 508             long[] counts = new long[typeProfileWidth];
 509             long totalCount = 0;
 510             int entries = 0;
 511 
 512             outer: for (int i = 0; i &lt; typeProfileWidth; i++) {
 513                 HotSpotResolvedObjectTypeImpl receiverKlass = data.readKlass(position, getTypeOffset(i));
 514                 if (receiverKlass != null) {
 515                     HotSpotResolvedObjectTypeImpl klass = receiverKlass;
 516                     long count = data.readUnsignedInt(position, getTypeCountOffset(i));
 517                     /*
 518                      * Because of races in the profile collection machinery it's possible for a
 519                      * class to appear multiple times so merge them to make the profile look
 520                      * rational.
 521                      */
 522                     for (int j = 0; j &lt; entries; j++) {
 523                         if (types[j].equals(klass)) {
 524                             totalCount += count;
 525                             counts[j] += count;
 526                             continue outer;
 527                         }
 528                     }
 529                     types[entries] = klass;
 530                     totalCount += count;
 531                     counts[entries] = count;
 532                     entries++;
 533                 }
 534             }
 535 
 536             totalCount += getTypesNotRecordedExecutionCount(data, position);
 537             return new RawItemProfile&lt;&gt;(entries, types, counts, totalCount);
 538         }
 539 
 540         protected abstract long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position);
 541 
<a name="30" id="anc30"></a><span class="changed"> 542         private static JavaTypeProfile createTypeProfile(TriState nullSeen, RawItemProfile&lt;ResolvedJavaType&gt; profile) {</span>
 543             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
 544                 return null;
 545             }
 546 
 547             ProfiledType[] ptypes = new ProfiledType[profile.entries];
 548             double totalProbability = 0.0;
 549             for (int i = 0; i &lt; profile.entries; i++) {
 550                 double p = profile.counts[i];
 551                 p = p / profile.totalCount;
 552                 totalProbability += p;
 553                 ptypes[i] = new ProfiledType(profile.items[i], p);
 554             }
 555 
 556             Arrays.sort(ptypes);
 557 
 558             double notRecordedTypeProbability = profile.entries &lt; config.typeProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
 559             assert notRecordedTypeProbability == 0 || profile.entries == config.typeProfileWidth;
 560             return new JavaTypeProfile(nullSeen, notRecordedTypeProbability, ptypes);
 561         }
 562 
 563         private static int getTypeOffset(int row) {
 564             return TYPE_DATA_FIRST_TYPE_OFFSET + row * TYPE_DATA_ROW_SIZE;
 565         }
 566 
 567         protected static int getTypeCountOffset(int row) {
 568             return TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;
 569         }
 570 
 571         @Override
 572         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 573             RawItemProfile&lt;ResolvedJavaType&gt; profile = getRawTypeProfile(data, pos);
 574             TriState nullSeen = getNullSeen(data, pos);
 575             TriState exceptionSeen = getExceptionSeen(data, pos);
 576             sb.append(format("count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)", getCounterValue(data, pos), nullSeen, exceptionSeen,
 577                             getTypesNotRecordedExecutionCount(data, pos), profile.entries));
 578             for (int i = 0; i &lt; profile.entries; i++) {
 579                 long count = profile.counts[i];
 580                 sb.append(format("%n  %s (%d, %4.2f)", profile.items[i].toJavaName(), count, (double) count / profile.totalCount));
 581             }
 582             return sb;
 583         }
 584     }
 585 
<a name="31" id="anc31"></a><span class="changed"> 586     private static class ReceiverTypeData extends AbstractTypeData {</span>
 587 
<a name="32" id="anc32"></a><span class="changed"> 588         private static final int TYPE_CHECK_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
 589 
<a name="33" id="anc33"></a><span class="changed"> 590         ReceiverTypeData() {</span>
<span class="changed"> 591             super(Tag.ReceiverTypeData, TYPE_CHECK_DATA_SIZE);</span>
 592         }
 593 
<a name="34" id="anc34"></a><span class="changed"> 594         protected ReceiverTypeData(Tag tag, int staticSize) {</span>
<span class="changed"> 595             super(tag, staticSize);</span>
 596         }
 597 
 598         @Override
 599         public int getExecutionCount(HotSpotMethodData data, int position) {
 600             return -1;
 601         }
 602 
 603         @Override
 604         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 605             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);
 606         }
 607     }
 608 
<a name="35" id="anc35"></a><span class="changed"> 609     private static class VirtualCallData extends ReceiverTypeData {</span>


 610 
<a name="36" id="anc36"></a><span class="changed"> 611         private static final int VIRTUAL_CALL_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * (config.typeProfileWidth + config.methodProfileWidth);</span>
<span class="changed"> 612         private static final int VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET = TYPE_DATA_FIRST_TYPE_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
<span class="changed"> 613         private static final int VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET = TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
 614 
<a name="37" id="anc37"></a><span class="changed"> 615         VirtualCallData() {</span>
<span class="changed"> 616             super(Tag.VirtualCallData, VIRTUAL_CALL_DATA_SIZE);</span>
 617         }
 618 
<a name="38" id="anc38"></a><span class="changed"> 619         protected VirtualCallData(Tag tag, int staticSize) {</span>
<span class="changed"> 620             super(tag, staticSize);</span>
 621         }
 622 
 623         @Override
 624         public int getExecutionCount(HotSpotMethodData data, int position) {
 625             final int typeProfileWidth = config.typeProfileWidth;
 626 
 627             long total = 0;
 628             for (int i = 0; i &lt; typeProfileWidth; i++) {
 629                 total += data.readUnsignedInt(position, getTypeCountOffset(i));
 630             }
 631 
 632             total += getCounterValue(data, position);
 633             return truncateLongToInt(total);
 634         }
 635 
 636         @Override
 637         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 638             return getCounterValue(data, position);
 639         }
 640 
 641         private static long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 642             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);
 643         }
 644 
 645         @Override
 646         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {
 647             return createMethodProfile(getRawMethodProfile(data, position));
 648         }
 649 
<a name="39" id="anc39"></a><span class="changed"> 650         private static RawItemProfile&lt;ResolvedJavaMethod&gt; getRawMethodProfile(HotSpotMethodData data, int position) {</span>
 651             int profileWidth = config.methodProfileWidth;
 652 
 653             ResolvedJavaMethod[] methods = new ResolvedJavaMethod[profileWidth];
 654             long[] counts = new long[profileWidth];
 655             long totalCount = 0;
 656             int entries = 0;
 657 
 658             for (int i = 0; i &lt; profileWidth; i++) {
 659                 HotSpotResolvedJavaMethod method = data.readMethod(position, getMethodOffset(i));
 660                 if (method != null) {
 661                     methods[entries] = method;
 662                     long count = data.readUnsignedInt(position, getMethodCountOffset(i));
 663                     totalCount += count;
 664                     counts[entries] = count;
 665 
 666                     entries++;
 667                 }
 668             }
 669 
 670             totalCount += getMethodsNotRecordedExecutionCount(data, position);
 671             return new RawItemProfile&lt;&gt;(entries, methods, counts, totalCount);
 672         }
 673 
<a name="40" id="anc40"></a><span class="changed"> 674         private static JavaMethodProfile createMethodProfile(RawItemProfile&lt;ResolvedJavaMethod&gt; profile) {</span>
 675             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
 676                 return null;
 677             }
 678 
 679             ProfiledMethod[] pmethods = new ProfiledMethod[profile.entries];
 680             double totalProbability = 0.0;
 681             for (int i = 0; i &lt; profile.entries; i++) {
 682                 double p = profile.counts[i];
 683                 p = p / profile.totalCount;
 684                 totalProbability += p;
 685                 pmethods[i] = new ProfiledMethod(profile.items[i], p);
 686             }
 687 
 688             Arrays.sort(pmethods);
 689 
 690             double notRecordedMethodProbability = profile.entries &lt; config.methodProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
 691             assert notRecordedMethodProbability == 0 || profile.entries == config.methodProfileWidth;
 692             return new JavaMethodProfile(notRecordedMethodProbability, pmethods);
 693         }
 694 
 695         private static int getMethodOffset(int row) {
 696             return VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET + row * TYPE_DATA_ROW_SIZE;
 697         }
 698 
 699         private static int getMethodCountOffset(int row) {
 700             return VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;
 701         }
 702 
 703         @Override
 704         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 705             RawItemProfile&lt;ResolvedJavaMethod&gt; profile = getRawMethodProfile(data, pos);
 706             super.appendTo(sb.append(format("exception_seen(%s) ", getExceptionSeen(data, pos))), data, pos).append(format("%nmethod_entries(%d)", profile.entries));
 707             for (int i = 0; i &lt; profile.entries; i++) {
 708                 long count = profile.counts[i];
 709                 sb.append(format("%n  %s (%d, %4.2f)", profile.items[i].format("%H.%n(%p)"), count, (double) count / profile.totalCount));
 710             }
 711             return sb;
 712         }
 713     }
 714 
<a name="41" id="anc41"></a><span class="changed"> 715     private static class VirtualCallTypeData extends VirtualCallData {</span>
 716 
<a name="42" id="anc42"></a><span class="changed"> 717         VirtualCallTypeData() {</span>
<span class="changed"> 718             super(Tag.VirtualCallTypeData, 0);</span>
 719         }
 720 
 721         @Override
 722         protected int getDynamicSize(HotSpotMethodData data, int position) {
 723             assert staticSize == 0;
 724             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
 725         }
 726     }
 727 
<a name="43" id="anc43"></a><span class="changed"> 728     private static class RetData extends CounterData {</span>

 729 
<a name="44" id="anc44"></a><span class="changed"> 730         private static final int RET_DATA_ROW_SIZE = cellsToBytes(3);</span>
<span class="changed"> 731         private static final int RET_DATA_SIZE = cellIndexToOffset(1) + RET_DATA_ROW_SIZE * config.bciProfileWidth;</span>
 732 
<a name="45" id="anc45"></a><span class="changed"> 733         RetData() {</span>
<span class="changed"> 734             super(Tag.RetData, RET_DATA_SIZE);</span>
 735         }
 736     }
 737 
<a name="46" id="anc46"></a><span class="changed"> 738     private static class BranchData extends JumpData {</span>

 739 
<a name="47" id="anc47"></a><span class="changed"> 740         private static final int BRANCH_DATA_SIZE = cellIndexToOffset(3);</span>
<span class="changed"> 741         private static final int NOT_TAKEN_COUNT_OFFSET = cellIndexToOffset(config.branchDataNotTakenOffset);</span>
 742 
<a name="48" id="anc48"></a><span class="changed"> 743         BranchData() {</span>
<span class="changed"> 744             super(Tag.BranchData, BRANCH_DATA_SIZE);</span>
 745         }
 746 
 747         @Override
 748         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
 749             long takenCount = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET);
 750             long notTakenCount = data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);
 751             long total = takenCount + notTakenCount;
 752 
 753             return total &lt;= 0 ? -1 : takenCount / (double) total;
 754         }
 755 
 756         @Override
 757         public int getExecutionCount(HotSpotMethodData data, int position) {
 758             long count = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET) + data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);
 759             return truncateLongToInt(count);
 760         }
 761 
 762         @Override
 763         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 764             long taken = data.readUnsignedInt(pos, TAKEN_COUNT_OFFSET);
 765             long notTaken = data.readUnsignedInt(pos, NOT_TAKEN_COUNT_OFFSET);
 766             double takenProbability = getBranchTakenProbability(data, pos);
 767             return sb.append(format("taken(%d, %4.2f) not_taken(%d, %4.2f) displacement(%d)", taken, takenProbability, notTaken, 1.0D - takenProbability, getTakenDisplacement(data, pos)));
 768         }
 769     }
 770 
<a name="49" id="anc49"></a><span class="changed"> 771     private static class ArrayData extends AbstractMethodData {</span>

 772 
<a name="50" id="anc50"></a><span class="changed"> 773         private static final int ARRAY_DATA_LENGTH_OFFSET = cellIndexToOffset(config.arrayDataArrayLenOffset);</span>
<span class="changed"> 774         protected static final int ARRAY_DATA_START_OFFSET = cellIndexToOffset(config.arrayDataArrayStartOffset);</span>
 775 
<a name="51" id="anc51"></a><span class="changed"> 776         ArrayData(Tag tag, int staticSize) {</span>
<span class="changed"> 777             super(tag, staticSize);</span>
 778         }
 779 
 780         @Override
 781         protected int getDynamicSize(HotSpotMethodData data, int position) {
 782             return cellsToBytes(getLength(data, position));
 783         }
 784 
 785         protected static int getLength(HotSpotMethodData data, int position) {
 786             return data.readInt(position, ARRAY_DATA_LENGTH_OFFSET);
 787         }
 788 
 789         @Override
 790         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 791             return sb.append(format("length(%d)", getLength(data, pos)));
 792         }
 793     }
 794 
<a name="52" id="anc52"></a><span class="changed"> 795     private static class MultiBranchData extends ArrayData {</span>




 796 
<a name="53" id="anc53"></a><span class="changed"> 797         private static final int MULTI_BRANCH_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="changed"> 798         private static final int MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS = config.multiBranchDataPerCaseCellCount;</span>
<span class="changed"> 799         private static final int MULTI_BRANCH_DATA_ROW_SIZE = cellsToBytes(MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS);</span>
<span class="changed"> 800         private static final int MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(0);</span>
<span class="changed"> 801         private static final int MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(1);</span>
 802 
<a name="54" id="anc54"></a><span class="changed"> 803         MultiBranchData() {</span>
<span class="changed"> 804             super(Tag.MultiBranchData, MULTI_BRANCH_DATA_SIZE);</span>
 805         }
 806 
 807         @Override
 808         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {
 809             int arrayLength = getLength(data, position);
 810             assert arrayLength &gt; 0 : "switch must have at least the default case";
 811             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : "array must have full rows";
 812 
 813             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 814             long totalCount = 0;
 815             double[] result = new double[length];
 816 
 817             // default case is first in HotSpot but last for the compiler
 818             long count = readCount(data, position, 0);
 819             totalCount += count;
 820             result[length - 1] = count;
 821 
 822             for (int i = 1; i &lt; length; i++) {
 823                 count = readCount(data, position, i);
 824                 totalCount += count;
 825                 result[i - 1] = count;
 826             }
 827 
 828             if (totalCount &lt;= 0) {
 829                 return null;
 830             } else {
 831                 for (int i = 0; i &lt; length; i++) {
 832                     result[i] = result[i] / totalCount;
 833                 }
 834                 return result;
 835             }
 836         }
 837 
 838         private static long readCount(HotSpotMethodData data, int position, int i) {
 839             int offset;
 840             long count;
 841             offset = getCountOffset(i);
 842             count = data.readUnsignedInt(position, offset);
 843             return count;
 844         }
 845 
 846         @Override
 847         public int getExecutionCount(HotSpotMethodData data, int position) {
 848             int arrayLength = getLength(data, position);
 849             assert arrayLength &gt; 0 : "switch must have at least the default case";
 850             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : "array must have full rows";
 851 
 852             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 853             long totalCount = 0;
 854             for (int i = 0; i &lt; length; i++) {
 855                 int offset = getCountOffset(i);
 856                 totalCount += data.readUnsignedInt(position, offset);
 857             }
 858 
 859             return truncateLongToInt(totalCount);
 860         }
 861 
 862         private static int getCountOffset(int index) {
 863             return MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;
 864         }
 865 
 866         private static int getDisplacementOffset(int index) {
 867             return MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;
 868         }
 869 
 870         @Override
 871         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 872             int entries = getLength(data, pos) / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 873             sb.append(format("entries(%d)", entries));
 874             for (int i = 0; i &lt; entries; i++) {
 875                 sb.append(format("%n  %d: count(%d) displacement(%d)", i, data.readUnsignedInt(pos, getCountOffset(i)), data.readUnsignedInt(pos, getDisplacementOffset(i))));
 876             }
 877             return sb;
 878         }
 879     }
 880 
<a name="55" id="anc55"></a><span class="changed"> 881     private static class ArgInfoData extends ArrayData {</span>
 882 
<a name="56" id="anc56"></a><span class="changed"> 883         private static final int ARG_INFO_DATA_SIZE = cellIndexToOffset(1);</span>
 884 
<a name="57" id="anc57"></a><span class="changed"> 885         ArgInfoData() {</span>
<span class="changed"> 886             super(Tag.ArgInfoData, ARG_INFO_DATA_SIZE);</span>
 887         }
 888     }
 889 
<a name="58" id="anc58"></a><span class="changed"> 890     private static class UnknownProfileData extends AbstractMethodData {</span>
<span class="changed"> 891         UnknownProfileData(Tag tag) {</span>
<span class="changed"> 892             super(tag, 0);</span>
 893         }
 894 
 895         @Override
 896         protected int getDynamicSize(HotSpotMethodData data, int position) {
 897             assert staticSize == 0;
 898             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
 899         }
 900 
 901         @Override
 902         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
<a name="59" id="anc59"></a><span class="removed"> 903             // TODO Auto-generated method stub</span>
 904             return null;
 905         }
 906     }
 907 
 908     public void setCompiledIRSize(int size) {
 909         UNSAFE.putInt(metaspaceMethodData + config.methodDataIRSizeOffset, size);
 910     }
 911 
 912     public int getCompiledIRSize() {
 913         return UNSAFE.getInt(metaspaceMethodData + config.methodDataIRSizeOffset);
 914     }
<a name="60" id="anc60"></a>




































 915 }
<a name="61" id="anc61"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="61" type="hidden" /></form></body></html>
