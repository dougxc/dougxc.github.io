<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodData.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.lang.String.format;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  30 
  31 import java.util.Arrays;
  32 
  33 import jdk.internal.misc.Unsafe;
  34 import jdk.vm.ci.meta.DeoptimizationReason;
  35 import jdk.vm.ci.meta.JavaMethodProfile;
  36 import jdk.vm.ci.meta.JavaMethodProfile.ProfiledMethod;
  37 import jdk.vm.ci.meta.JavaTypeProfile;
  38 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;
  39 import jdk.vm.ci.meta.ResolvedJavaMethod;
  40 import jdk.vm.ci.meta.ResolvedJavaType;
  41 import jdk.vm.ci.meta.TriState;
  42 
  43 /**
  44  * Access to a HotSpot {@code MethodData} structure (defined in methodData.hpp).
  45  */
  46 final class HotSpotMethodData {
  47 
  48     static final HotSpotVMConfig config = config();
  49     static final HotSpotMethodDataAccessor NO_DATA_NO_EXCEPTION_ACCESSOR = new NoMethodData(config, config.dataLayoutNoTag, TriState.FALSE);
  50     static final HotSpotMethodDataAccessor NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR = new NoMethodData(config, config.dataLayoutNoTag, TriState.UNKNOWN);
  51 
  52     /**
  53      * Reference to the C++ MethodData object.
  54      */
  55     final long metaspaceMethodData;
  56     @SuppressWarnings("unused") private final HotSpotResolvedJavaMethodImpl method;
  57 
  58     public HotSpotMethodData(long metaspaceMethodData, HotSpotResolvedJavaMethodImpl method) {
  59         this.metaspaceMethodData = metaspaceMethodData;
  60         this.method = method;
  61     }
  62 
  63     /**
  64      * @return value of the MethodData::_data_size field
  65      */
  66     private int normalDataSize() {
  67         return UNSAFE.getInt(metaspaceMethodData + config.methodDataDataSize);
  68     }
  69 
  70     /**
  71      * Returns the size of the extra data records. This method does the same calculation as
  72      * MethodData::extra_data_size().
  73      *
  74      * @return size of extra data records
  75      */
  76     private int extraDataSize() {
  77         final int extraDataBase = config.methodDataOopDataOffset + normalDataSize();
  78         final int extraDataLimit = UNSAFE.getInt(metaspaceMethodData + config.methodDataSize);
  79         return extraDataLimit - extraDataBase;
  80     }
  81 
  82     public boolean hasNormalData() {
  83         return normalDataSize() &gt; 0;
  84     }
  85 
  86     public boolean hasExtraData() {
  87         return extraDataSize() &gt; 0;
  88     }
  89 
  90     public int getExtraDataBeginOffset() {
  91         return normalDataSize();
  92     }
  93 
  94     public boolean isWithin(int position) {
  95         return position &gt;= 0 &amp;&amp; position &lt; normalDataSize() + extraDataSize();
  96     }
  97 
  98     public int getDeoptimizationCount(DeoptimizationReason reason) {
  99         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
 100         int reasonIndex = metaAccess.convertDeoptReason(reason);
 101         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + reasonIndex) &amp; 0xFF;
 102     }
 103 
 104     public int getOSRDeoptimizationCount(DeoptimizationReason reason) {
 105         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
 106         int reasonIndex = metaAccess.convertDeoptReason(reason);
 107         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + config.deoptReasonOSROffset + reasonIndex) &amp; 0xFF;
 108     }
 109 
 110     public HotSpotMethodDataAccessor getNormalData(int position) {
 111         if (position &gt;= normalDataSize()) {
 112             return null;
 113         }
 114 
 115         return getData(position);
 116     }
 117 
 118     public HotSpotMethodDataAccessor getExtraData(int position) {
 119         if (position &gt;= normalDataSize() + extraDataSize()) {
 120             return null;
 121         }
 122         HotSpotMethodDataAccessor data = getData(position);
 123         if (data != null) {
 124             return data;
 125         }
 126         return data;
 127     }
 128 
 129     public static HotSpotMethodDataAccessor getNoDataAccessor(boolean exceptionPossiblyNotRecorded) {
 130         if (exceptionPossiblyNotRecorded) {
 131             return NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR;
 132         } else {
 133             return NO_DATA_NO_EXCEPTION_ACCESSOR;
 134         }
 135     }
 136 
 137     private HotSpotMethodDataAccessor getData(int position) {
 138         assert position &gt;= 0 : "out of bounds";
 139         final int tag = HotSpotMethodDataAccessor.readTag(config, this, position);
 140         HotSpotMethodDataAccessor accessor = PROFILE_DATA_ACCESSORS[tag];
 141         assert accessor == null || accessor.getTag() == tag : "wrong data accessor " + accessor + " for tag " + tag;
 142         return accessor;
 143     }
 144 
 145     int readUnsignedByte(int position, int offsetInBytes) {
 146         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 147         return UNSAFE.getByte(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFF;
 148     }
 149 
 150     int readUnsignedShort(int position, int offsetInBytes) {
 151         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 152         return UNSAFE.getShort(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFF;
 153     }
 154 
 155     /**
 156      * Since the values are stored in cells (platform words) this method uses
 157      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
 158      */
 159     private long readUnsignedInt(int position, int offsetInBytes) {
 160         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 161         return UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFFFFFFL;
 162     }
 163 
 164     private int readUnsignedIntAsSignedInt(int position, int offsetInBytes) {
 165         long value = readUnsignedInt(position, offsetInBytes);
 166         return truncateLongToInt(value);
 167     }
 168 
 169     /**
 170      * Since the values are stored in cells (platform words) this method uses
 171      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
 172      */
 173     private int readInt(int position, int offsetInBytes) {
 174         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 175         return (int) UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes);
 176     }
 177 
 178     private HotSpotResolvedJavaMethod readMethod(int position, int offsetInBytes) {
 179         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 180         return compilerToVM().getResolvedJavaMethod(null, metaspaceMethodData + fullOffsetInBytes);
 181     }
 182 
 183     private HotSpotResolvedObjectTypeImpl readKlass(int position, int offsetInBytes) {
 184         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 185         return compilerToVM().getResolvedJavaType(null, metaspaceMethodData + fullOffsetInBytes, false);
 186     }
 187 
 188     private static int truncateLongToInt(long value) {
 189         return value &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) value;
 190     }
 191 
 192     private static int computeFullOffset(int position, int offsetInBytes) {
 193         return config.methodDataOopDataOffset + position + offsetInBytes;
 194     }
 195 
 196     private static int cellIndexToOffset(int cells) {
 197         return config.dataLayoutHeaderSize + cellsToBytes(cells);
 198     }
 199 
 200     private static int cellsToBytes(int cells) {
 201         return cells * config.dataLayoutCellSize;
 202     }
 203 
 204     /**
 205      * Returns whether profiling ran long enough that the profile information is mature. Other
 206      * informational data will still be valid even if the profile isn't mature.
 207      */
 208     public boolean isProfileMature() {
 209         return runtime().getCompilerToVM().isMature(metaspaceMethodData);
 210     }
 211 
 212     @Override
 213     public String toString() {
 214         StringBuilder sb = new StringBuilder();
 215         String nl = String.format("%n");
 216         String nlIndent = String.format("%n%38s", "");
 217         if (hasNormalData()) {
 218             int pos = 0;
 219             HotSpotMethodDataAccessor data;
 220             while ((data = getNormalData(pos)) != null) {
 221                 if (pos != 0) {
 222                     sb.append(nl);
 223                 }
 224                 int bci = data.getBCI(this, pos);
 225                 sb.append(String.format("%-6d bci: %-6d%-20s", pos, bci, data.getClass().getSimpleName()));
 226                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
 227                 pos = pos + data.getSize(this, pos);
 228             }
 229         }
 230 
 231         if (hasExtraData()) {
 232             int pos = getExtraDataBeginOffset();
 233             HotSpotMethodDataAccessor data;
 234             while ((data = getExtraData(pos)) != null) {
 235                 if (pos == getExtraDataBeginOffset()) {
 236                     sb.append(nl).append("--- Extra data:");
 237                 }
 238                 int bci = data.getBCI(this, pos);
 239                 sb.append(String.format("%n%-6d bci: %-6d%-20s", pos, bci, data.getClass().getSimpleName()));
 240                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
 241                 pos = pos + data.getSize(this, pos);
 242             }
 243 
 244         }
 245         return sb.toString();
 246     }
 247 
 248     static final int NO_DATA_SIZE = cellIndexToOffset(0);
 249 
 250     static class NoMethodData extends HotSpotMethodDataAccessor {
 251 
 252         private final TriState exceptionSeen;
 253 
 254         protected NoMethodData(HotSpotVMConfig config, int tag, TriState exceptionSeen) {
 255             super(config, tag, NO_DATA_SIZE);
 256             this.exceptionSeen = exceptionSeen;
 257         }
 258 
 259         @Override
 260         public int getBCI(HotSpotMethodData data, int position) {
 261             return -1;
 262         }
 263 
 264         @Override
 265         public TriState getExceptionSeen(HotSpotMethodData data, int position) {
 266             return exceptionSeen;
 267         }
 268 
 269         @Override
 270         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 271             return sb;
 272         }
 273     }
 274 
 275     static final int BIT_DATA_SIZE = cellIndexToOffset(0);
 276     static final int BIT_DATA_NULL_SEEN_FLAG = 1 &lt;&lt; config.bitDataNullSeenFlag;
 277 
 278     static class BitData extends HotSpotMethodDataAccessor {
 279 
 280         private BitData(HotSpotVMConfig config, int tag) {
 281             super(config, tag, BIT_DATA_SIZE);
 282         }
 283 
 284         protected BitData(HotSpotVMConfig config, int tag, int staticSize) {
 285             super(config, tag, staticSize);
 286         }
 287 
 288         @Override
 289         public TriState getNullSeen(HotSpotMethodData data, int position) {
 290             return TriState.get((getFlags(data, position) &amp; BIT_DATA_NULL_SEEN_FLAG) != 0);
 291         }
 292 
 293         @Override
 294         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 295             return sb.append(format("exception_seen(%s)", getExceptionSeen(data, pos)));
 296         }
 297     }
 298 
 299     static final int COUNTER_DATA_SIZE = cellIndexToOffset(1);
 300     static final int COUNTER_DATA_COUNT_OFFSET = cellIndexToOffset(config.methodDataCountOffset);
 301 
 302     static class CounterData extends BitData {
 303 
 304         CounterData(HotSpotVMConfig config, int tag) {
 305             super(config, tag, COUNTER_DATA_SIZE);
 306         }
 307 
 308         protected CounterData(HotSpotVMConfig config, int tag, int staticSize) {
 309             super(config, tag, staticSize);
 310         }
 311 
 312         @Override
 313         public int getExecutionCount(HotSpotMethodData data, int position) {
 314             return getCounterValue(data, position);
 315         }
 316 
 317         protected int getCounterValue(HotSpotMethodData data, int position) {
 318             return data.readUnsignedIntAsSignedInt(position, COUNTER_DATA_COUNT_OFFSET);
 319         }
 320 
 321         @Override
 322         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 323             return sb.append(format("count(%d) null_seen(%s) exception_seen(%s)", getCounterValue(data, pos), getNullSeen(data, pos), getExceptionSeen(data, pos)));
 324         }
 325     }
 326 
 327     static final int JUMP_DATA_SIZE = cellIndexToOffset(2);
 328     static final int TAKEN_COUNT_OFFSET = cellIndexToOffset(config.jumpDataTakenOffset);
 329     static final int TAKEN_DISPLACEMENT_OFFSET = cellIndexToOffset(config.jumpDataDisplacementOffset);
 330 
 331     static class JumpData extends HotSpotMethodDataAccessor {
 332 
 333         JumpData(HotSpotVMConfig config, int tag) {
 334             super(config, tag, JUMP_DATA_SIZE);
 335         }
 336 
 337         protected JumpData(HotSpotVMConfig config, int tag, int staticSize) {
 338             super(config, tag, staticSize);
 339         }
 340 
 341         @Override
 342         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
 343             return getExecutionCount(data, position) != 0 ? 1 : 0;
 344         }
 345 
 346         @Override
 347         public int getExecutionCount(HotSpotMethodData data, int position) {
 348             return data.readUnsignedIntAsSignedInt(position, TAKEN_COUNT_OFFSET);
 349         }
 350 
 351         public int getTakenDisplacement(HotSpotMethodData data, int position) {
 352             return data.readInt(position, TAKEN_DISPLACEMENT_OFFSET);
 353         }
 354 
 355         @Override
 356         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 357             return sb.append(format("taken(%d) displacement(%d)", getExecutionCount(data, pos), getTakenDisplacement(data, pos)));
 358         }
 359     }
 360 
 361     static class RawItemProfile&lt;T&gt; {
 362         final int entries;
 363         final T[] items;
 364         final long[] counts;
 365         final long totalCount;
 366 
 367         RawItemProfile(int entries, T[] items, long[] counts, long totalCount) {
 368             this.entries = entries;
 369             this.items = items;
 370             this.counts = counts;
 371             this.totalCount = totalCount;
 372         }
 373     }
 374 
 375     static final int TYPE_DATA_ROW_SIZE = cellsToBytes(config.receiverTypeDataReceiverTypeRowCellCount);
 376 
 377     static final int NONPROFILED_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);
 378     static final int TYPE_DATA_FIRST_TYPE_OFFSET = cellIndexToOffset(config.receiverTypeDataReceiver0Offset);
 379     static final int TYPE_DATA_FIRST_TYPE_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataCount0Offset);
 380 
 381     abstract static class AbstractTypeData extends CounterData {
 382 
 383         protected AbstractTypeData(HotSpotVMConfig config, int tag, int staticSize) {
 384             super(config, tag, staticSize);
 385         }
 386 
 387         @Override
 388         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {
 389             return createTypeProfile(getNullSeen(data, position), getRawTypeProfile(data, position));
 390         }
 391 
 392         private RawItemProfile&lt;ResolvedJavaType&gt; getRawTypeProfile(HotSpotMethodData data, int position) {
 393             int typeProfileWidth = config.typeProfileWidth;
 394 
 395             ResolvedJavaType[] types = new ResolvedJavaType[typeProfileWidth];
 396             long[] counts = new long[typeProfileWidth];
 397             long totalCount = 0;
 398             int entries = 0;
 399 
 400             outer: for (int i = 0; i &lt; typeProfileWidth; i++) {
 401                 HotSpotResolvedObjectTypeImpl receiverKlass = data.readKlass(position, getTypeOffset(i));
 402                 if (receiverKlass != null) {
 403                     HotSpotResolvedObjectTypeImpl klass = receiverKlass;
 404                     long count = data.readUnsignedInt(position, getTypeCountOffset(i));
 405                     /*
 406                      * Because of races in the profile collection machinery it's possible for a
 407                      * class to appear multiple times so merge them to make the profile look
 408                      * rational.
 409                      */
 410                     for (int j = 0; j &lt; entries; j++) {
 411                         if (types[j].equals(klass)) {
 412                             totalCount += count;
 413                             counts[j] += count;
 414                             continue outer;
 415                         }
 416                     }
 417                     types[entries] = klass;
 418                     totalCount += count;
 419                     counts[entries] = count;
 420                     entries++;
 421                 }
 422             }
 423 
 424             totalCount += getTypesNotRecordedExecutionCount(data, position);
 425             return new RawItemProfile&lt;&gt;(entries, types, counts, totalCount);
 426         }
 427 
 428         protected abstract long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position);
 429 
 430         private JavaTypeProfile createTypeProfile(TriState nullSeen, RawItemProfile&lt;ResolvedJavaType&gt; profile) {
 431             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
 432                 return null;
 433             }
 434 
 435             ProfiledType[] ptypes = new ProfiledType[profile.entries];
 436             double totalProbability = 0.0;
 437             for (int i = 0; i &lt; profile.entries; i++) {
 438                 double p = profile.counts[i];
 439                 p = p / profile.totalCount;
 440                 totalProbability += p;
 441                 ptypes[i] = new ProfiledType(profile.items[i], p);
 442             }
 443 
 444             Arrays.sort(ptypes);
 445 
 446             double notRecordedTypeProbability = profile.entries &lt; config.typeProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
 447             assert notRecordedTypeProbability == 0 || profile.entries == config.typeProfileWidth;
 448             return new JavaTypeProfile(nullSeen, notRecordedTypeProbability, ptypes);
 449         }
 450 
 451         private static int getTypeOffset(int row) {
 452             return TYPE_DATA_FIRST_TYPE_OFFSET + row * TYPE_DATA_ROW_SIZE;
 453         }
 454 
 455         protected static int getTypeCountOffset(int row) {
 456             return TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;
 457         }
 458 
 459         @Override
 460         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 461             RawItemProfile&lt;ResolvedJavaType&gt; profile = getRawTypeProfile(data, pos);
 462             TriState nullSeen = getNullSeen(data, pos);
 463             TriState exceptionSeen = getExceptionSeen(data, pos);
 464             sb.append(format("count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)", getCounterValue(data, pos), nullSeen, exceptionSeen,
 465                             getTypesNotRecordedExecutionCount(data, pos), profile.entries));
 466             for (int i = 0; i &lt; profile.entries; i++) {
 467                 long count = profile.counts[i];
 468                 sb.append(format("%n  %s (%d, %4.2f)", profile.items[i].toJavaName(), count, (double) count / profile.totalCount));
 469             }
 470             return sb;
 471         }
 472     }
 473 
 474     static final int TYPE_CHECK_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;
 475 
 476     static class ReceiverTypeData extends AbstractTypeData {
 477 
 478         ReceiverTypeData(HotSpotVMConfig config, int tag) {
 479             super(config, tag, TYPE_CHECK_DATA_SIZE);
 480         }
 481 
 482         protected ReceiverTypeData(HotSpotVMConfig config, int tag, int staticSize) {
 483             super(config, tag, staticSize);
 484         }
 485 
 486         @Override
 487         public int getExecutionCount(HotSpotMethodData data, int position) {
 488             return -1;
 489         }
 490 
 491         @Override
 492         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 493             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);
 494         }
 495     }
 496 
 497     static final int VIRTUAL_CALL_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * (config.typeProfileWidth + config.methodProfileWidth);
 498     static final int VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET = TYPE_DATA_FIRST_TYPE_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;
 499     static final int VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET = TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;
 500 
 501     static class VirtualCallData extends ReceiverTypeData {
 502 
 503         VirtualCallData(HotSpotVMConfig config, int tag) {
 504             super(config, tag, VIRTUAL_CALL_DATA_SIZE);
 505         }
 506 
 507         protected VirtualCallData(HotSpotVMConfig config, int tag, int staticSize) {
 508             super(config, tag, staticSize);
 509         }
 510 
 511         @Override
 512         public int getExecutionCount(HotSpotMethodData data, int position) {
 513             final int typeProfileWidth = config.typeProfileWidth;
 514 
 515             long total = 0;
 516             for (int i = 0; i &lt; typeProfileWidth; i++) {
 517                 total += data.readUnsignedInt(position, getTypeCountOffset(i));
 518             }
 519 
 520             total += getCounterValue(data, position);
 521             return truncateLongToInt(total);
 522         }
 523 
 524         @Override
 525         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 526             return getCounterValue(data, position);
 527         }
 528 
 529         private static long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 530             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);
 531         }
 532 
 533         @Override
 534         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {
 535             return createMethodProfile(getRawMethodProfile(data, position));
 536         }
 537 
 538         private RawItemProfile&lt;ResolvedJavaMethod&gt; getRawMethodProfile(HotSpotMethodData data, int position) {
 539             int profileWidth = config.methodProfileWidth;
 540 
 541             ResolvedJavaMethod[] methods = new ResolvedJavaMethod[profileWidth];
 542             long[] counts = new long[profileWidth];
 543             long totalCount = 0;
 544             int entries = 0;
 545 
 546             for (int i = 0; i &lt; profileWidth; i++) {
 547                 HotSpotResolvedJavaMethod method = data.readMethod(position, getMethodOffset(i));
 548                 if (method != null) {
 549                     methods[entries] = method;
 550                     long count = data.readUnsignedInt(position, getMethodCountOffset(i));
 551                     totalCount += count;
 552                     counts[entries] = count;
 553 
 554                     entries++;
 555                 }
 556             }
 557 
 558             totalCount += getMethodsNotRecordedExecutionCount(data, position);
 559             return new RawItemProfile&lt;&gt;(entries, methods, counts, totalCount);
 560         }
 561 
 562         private JavaMethodProfile createMethodProfile(RawItemProfile&lt;ResolvedJavaMethod&gt; profile) {
 563             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
 564                 return null;
 565             }
 566 
 567             ProfiledMethod[] pmethods = new ProfiledMethod[profile.entries];
 568             double totalProbability = 0.0;
 569             for (int i = 0; i &lt; profile.entries; i++) {
 570                 double p = profile.counts[i];
 571                 p = p / profile.totalCount;
 572                 totalProbability += p;
 573                 pmethods[i] = new ProfiledMethod(profile.items[i], p);
 574             }
 575 
 576             Arrays.sort(pmethods);
 577 
 578             double notRecordedMethodProbability = profile.entries &lt; config.methodProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
 579             assert notRecordedMethodProbability == 0 || profile.entries == config.methodProfileWidth;
 580             return new JavaMethodProfile(notRecordedMethodProbability, pmethods);
 581         }
 582 
 583         private static int getMethodOffset(int row) {
 584             return VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET + row * TYPE_DATA_ROW_SIZE;
 585         }
 586 
 587         private static int getMethodCountOffset(int row) {
 588             return VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;
 589         }
 590 
 591         @Override
 592         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 593             RawItemProfile&lt;ResolvedJavaMethod&gt; profile = getRawMethodProfile(data, pos);
 594             super.appendTo(sb.append(format("exception_seen(%s) ", getExceptionSeen(data, pos))), data, pos).append(format("%nmethod_entries(%d)", profile.entries));
 595             for (int i = 0; i &lt; profile.entries; i++) {
 596                 long count = profile.counts[i];
 597                 sb.append(format("%n  %s (%d, %4.2f)", profile.items[i].format("%H.%n(%p)"), count, (double) count / profile.totalCount));
 598             }
 599             return sb;
 600         }
 601     }
 602 
 603     static class VirtualCallTypeData extends VirtualCallData {
 604 
 605         VirtualCallTypeData(HotSpotVMConfig config, int tag) {
 606             super(config, tag, 0);
 607         }
 608 
 609         @Override
 610         protected int getDynamicSize(HotSpotMethodData data, int position) {
 611             assert staticSize == 0;
 612             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
 613         }
 614     }
 615 
 616     static final int RET_DATA_ROW_SIZE = cellsToBytes(3);
 617     static final int RET_DATA_SIZE = cellIndexToOffset(1) + RET_DATA_ROW_SIZE * config.bciProfileWidth;
 618 
 619     static class RetData extends CounterData {
 620 
 621         RetData(HotSpotVMConfig config, int tag) {
 622             super(config, tag, RET_DATA_SIZE);
 623         }
 624     }
 625 
 626     static final int BRANCH_DATA_SIZE = cellIndexToOffset(3);
 627     static final int NOT_TAKEN_COUNT_OFFSET = cellIndexToOffset(config.branchDataNotTakenOffset);
 628 
 629     static class BranchData extends JumpData {
 630 
 631         BranchData(HotSpotVMConfig config, int tag) {
 632             super(config, tag, BRANCH_DATA_SIZE);
 633         }
 634 
 635         @Override
 636         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
 637             long takenCount = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET);
 638             long notTakenCount = data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);
 639             long total = takenCount + notTakenCount;
 640 
 641             return total &lt;= 0 ? -1 : takenCount / (double) total;
 642         }
 643 
 644         @Override
 645         public int getExecutionCount(HotSpotMethodData data, int position) {
 646             long count = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET) + data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);
 647             return truncateLongToInt(count);
 648         }
 649 
 650         @Override
 651         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 652             long taken = data.readUnsignedInt(pos, TAKEN_COUNT_OFFSET);
 653             long notTaken = data.readUnsignedInt(pos, NOT_TAKEN_COUNT_OFFSET);
 654             double takenProbability = getBranchTakenProbability(data, pos);
 655             return sb.append(format("taken(%d, %4.2f) not_taken(%d, %4.2f) displacement(%d)", taken, takenProbability, notTaken, 1.0D - takenProbability, getTakenDisplacement(data, pos)));
 656         }
 657     }
 658 
 659     static final int ARRAY_DATA_LENGTH_OFFSET = cellIndexToOffset(config.arrayDataArrayLenOffset);
 660     static final int ARRAY_DATA_START_OFFSET = cellIndexToOffset(config.arrayDataArrayStartOffset);
 661 
 662     static class ArrayData extends HotSpotMethodDataAccessor {
 663 
 664         ArrayData(HotSpotVMConfig config, int tag, int staticSize) {
 665             super(config, tag, staticSize);
 666         }
 667 
 668         @Override
 669         protected int getDynamicSize(HotSpotMethodData data, int position) {
 670             return cellsToBytes(getLength(data, position));
 671         }
 672 
 673         protected static int getLength(HotSpotMethodData data, int position) {
 674             return data.readInt(position, ARRAY_DATA_LENGTH_OFFSET);
 675         }
 676 
 677         @Override
 678         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 679             return sb.append(format("length(%d)", getLength(data, pos)));
 680         }
 681     }
 682 
 683     static final int MULTI_BRANCH_DATA_SIZE = cellIndexToOffset(1);
 684     static final int MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS = config.multiBranchDataPerCaseCellCount;
 685     static final int MULTI_BRANCH_DATA_ROW_SIZE = cellsToBytes(MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS);
 686     static final int MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(0);
 687     static final int MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(1);
 688 
 689     static class MultiBranchData extends ArrayData {
 690 
 691         MultiBranchData(HotSpotVMConfig config, int tag) {
 692             super(config, tag, MULTI_BRANCH_DATA_SIZE);
 693         }
 694 
 695         @Override
 696         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {
 697             int arrayLength = getLength(data, position);
 698             assert arrayLength &gt; 0 : "switch must have at least the default case";
 699             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : "array must have full rows";
 700 
 701             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 702             long totalCount = 0;
 703             double[] result = new double[length];
 704 
 705             // default case is first in HotSpot but last for the compiler
 706             long count = readCount(data, position, 0);
 707             totalCount += count;
 708             result[length - 1] = count;
 709 
 710             for (int i = 1; i &lt; length; i++) {
 711                 count = readCount(data, position, i);
 712                 totalCount += count;
 713                 result[i - 1] = count;
 714             }
 715 
 716             if (totalCount &lt;= 0) {
 717                 return null;
 718             } else {
 719                 for (int i = 0; i &lt; length; i++) {
 720                     result[i] = result[i] / totalCount;
 721                 }
 722                 return result;
 723             }
 724         }
 725 
 726         private static long readCount(HotSpotMethodData data, int position, int i) {
 727             int offset;
 728             long count;
 729             offset = getCountOffset(i);
 730             count = data.readUnsignedInt(position, offset);
 731             return count;
 732         }
 733 
 734         @Override
 735         public int getExecutionCount(HotSpotMethodData data, int position) {
 736             int arrayLength = getLength(data, position);
 737             assert arrayLength &gt; 0 : "switch must have at least the default case";
 738             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : "array must have full rows";
 739 
 740             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 741             long totalCount = 0;
 742             for (int i = 0; i &lt; length; i++) {
 743                 int offset = getCountOffset(i);
 744                 totalCount += data.readUnsignedInt(position, offset);
 745             }
 746 
 747             return truncateLongToInt(totalCount);
 748         }
 749 
 750         private static int getCountOffset(int index) {
 751             return MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;
 752         }
 753 
 754         private static int getDisplacementOffset(int index) {
 755             return MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;
 756         }
 757 
 758         @Override
 759         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 760             int entries = getLength(data, pos) / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 761             sb.append(format("entries(%d)", entries));
 762             for (int i = 0; i &lt; entries; i++) {
 763                 sb.append(format("%n  %d: count(%d) displacement(%d)", i, data.readUnsignedInt(pos, getCountOffset(i)), data.readUnsignedInt(pos, getDisplacementOffset(i))));
 764             }
 765             return sb;
 766         }
 767     }
 768 
 769     static final int ARG_INFO_DATA_SIZE = cellIndexToOffset(1);
 770 
 771     static class ArgInfoData extends ArrayData {
 772 
 773         ArgInfoData(HotSpotVMConfig config, int tag) {
 774             super(config, tag, ARG_INFO_DATA_SIZE);
 775         }
 776     }
 777 
 778     static class UnknownProfileData extends HotSpotMethodDataAccessor {
 779         UnknownProfileData(HotSpotVMConfig config, int tag) {
 780             super(config, tag, 0);
 781         }
 782 
 783         @Override
 784         protected int getDynamicSize(HotSpotMethodData data, int position) {
 785             assert staticSize == 0;
 786             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
 787         }
 788 
 789         @Override
 790         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 791             return null;
 792         }
 793     }
 794 
 795     public void setCompiledIRSize(int size) {
 796         UNSAFE.putInt(metaspaceMethodData + config.methodDataIRSizeOffset, size);
 797     }
 798 
 799     public int getCompiledIRSize() {
 800         return UNSAFE.getInt(metaspaceMethodData + config.methodDataIRSizeOffset);
 801     }
 802 
 803     // sorted by tag
 804     // @formatter:off
 805     static final HotSpotMethodDataAccessor[] PROFILE_DATA_ACCESSORS = {
 806         null,
 807         new BitData(config, config.dataLayoutBitDataTag),
 808         new CounterData(config, config.dataLayoutCounterDataTag),
 809         new JumpData(config, config.dataLayoutJumpDataTag),
 810         new ReceiverTypeData(config, config.dataLayoutReceiverTypeDataTag),
 811         new VirtualCallData(config, config.dataLayoutVirtualCallDataTag),
 812         new RetData(config, config.dataLayoutRetDataTag),
 813         new BranchData(config, config.dataLayoutBranchDataTag),
 814         new MultiBranchData(config, config.dataLayoutMultiBranchDataTag),
 815         new ArgInfoData(config, config.dataLayoutArgInfoDataTag),
 816         new UnknownProfileData(config, config.dataLayoutCallTypeDataTag),
 817         new VirtualCallTypeData(config, config.dataLayoutVirtualCallTypeDataTag),
 818         new UnknownProfileData(config, config.dataLayoutParametersTypeDataTag),
 819         new UnknownProfileData(config, config.dataLayoutSpeculativeTrapDataTag),
 820     };
 821 
 822     private static boolean checkAccessorTags() {
 823         int expectedTag = 0;
 824         for (HotSpotMethodDataAccessor accessor : PROFILE_DATA_ACCESSORS) {
 825             if (expectedTag ==0 ) {
 826                 assert accessor == null;
 827             } else {
 828                 assert accessor.tag == expectedTag: expectedTag + " != " + accessor.tag + " " + accessor;
 829             }
 830             expectedTag++;
 831         }
 832         return true;
 833     }
 834 
 835     static {
 836         assert checkAccessorTags();
 837     }
 838     // @formatter:on
 839 }
</pre></body></html>
