<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotReferenceMap.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodData.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.lang.String.format;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  30 
  31 import java.util.Arrays;
  32 
<span class="changed">  33 import jdk.vm.ci.hotspot.HotSpotMethodDataAccessor.Tag;</span>
  34 import jdk.vm.ci.meta.DeoptimizationReason;
  35 import jdk.vm.ci.meta.JavaMethodProfile;
  36 import jdk.vm.ci.meta.JavaMethodProfile.ProfiledMethod;
  37 import jdk.vm.ci.meta.JavaTypeProfile;
  38 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;
  39 import jdk.vm.ci.meta.ResolvedJavaMethod;
  40 import jdk.vm.ci.meta.ResolvedJavaType;
  41 import jdk.vm.ci.meta.TriState;
<span class="removed">  42 import jdk.internal.misc.Unsafe;</span>
  43 
  44 /**
<span class="changed">  45  * Access to a HotSpot MethodData structure (defined in methodData.hpp).</span>
  46  */
<span class="changed">  47 public final class HotSpotMethodData {</span>
  48 
<span class="changed">  49     private static final HotSpotVMConfig config = config();</span>
<span class="changed">  50     private static final HotSpotMethodDataAccessor NO_DATA_NO_EXCEPTION_ACCESSOR = new NoMethodData(TriState.FALSE);</span>
<span class="changed">  51     private static final HotSpotMethodDataAccessor NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR = new NoMethodData(TriState.UNKNOWN);</span>
<span class="changed">  52 </span>
<span class="changed">  53     // sorted by tag</span>
<span class="changed">  54     // @formatter:off</span>
<span class="changed">  55     private static final HotSpotMethodDataAccessor[] PROFILE_DATA_ACCESSORS = {</span>
<span class="changed">  56         null,</span>
<span class="changed">  57         new BitData(),</span>
<span class="changed">  58         new CounterData(),</span>
<span class="changed">  59         new JumpData(),</span>
<span class="changed">  60         new ReceiverTypeData(),</span>
<span class="changed">  61         new VirtualCallData(),</span>
<span class="changed">  62         new RetData(),</span>
<span class="changed">  63         new BranchData(),</span>
<span class="changed">  64         new MultiBranchData(),</span>
<span class="changed">  65         new ArgInfoData(),</span>
<span class="changed">  66         new UnknownProfileData(Tag.CallTypeData),</span>
<span class="changed">  67         new VirtualCallTypeData(),</span>
<span class="changed">  68         new UnknownProfileData(Tag.ParametersTypeData),</span>
<span class="changed">  69         new UnknownProfileData(Tag.SpeculativeTrapData),</span>
<span class="changed">  70     };</span>
<span class="changed">  71     // @formatter:on</span>
  72 
  73     /**
  74      * Reference to the C++ MethodData object.
  75      */
<span class="changed">  76     private final long metaspaceMethodData;</span>
  77     @SuppressWarnings("unused") private final HotSpotResolvedJavaMethodImpl method;
  78 
  79     public HotSpotMethodData(long metaspaceMethodData, HotSpotResolvedJavaMethodImpl method) {
  80         this.metaspaceMethodData = metaspaceMethodData;
  81         this.method = method;
  82     }
  83 
  84     /**
  85      * @return value of the MethodData::_data_size field
  86      */
  87     private int normalDataSize() {
  88         return UNSAFE.getInt(metaspaceMethodData + config.methodDataDataSize);
  89     }
  90 
  91     /**
  92      * Returns the size of the extra data records. This method does the same calculation as
  93      * MethodData::extra_data_size().
  94      *
  95      * @return size of extra data records
  96      */

</pre><hr></hr><pre>
 116         return position &gt;= 0 &amp;&amp; position &lt; normalDataSize() + extraDataSize();
 117     }
 118 
 119     public int getDeoptimizationCount(DeoptimizationReason reason) {
 120         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
 121         int reasonIndex = metaAccess.convertDeoptReason(reason);
 122         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + reasonIndex) &amp; 0xFF;
 123     }
 124 
 125     public int getOSRDeoptimizationCount(DeoptimizationReason reason) {
 126         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
 127         int reasonIndex = metaAccess.convertDeoptReason(reason);
 128         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + config.deoptReasonOSROffset + reasonIndex) &amp; 0xFF;
 129     }
 130 
 131     public HotSpotMethodDataAccessor getNormalData(int position) {
 132         if (position &gt;= normalDataSize()) {
 133             return null;
 134         }
 135 
<span class="changed"> 136         HotSpotMethodDataAccessor result = getData(position);</span>
<span class="changed"> 137         final Tag tag = AbstractMethodData.readTag(this, position);</span>
<span class="changed"> 138         assert result != null : "NO_DATA tag is not allowed " + tag;</span>
<span class="changed"> 139         return result;</span>
 140     }
 141 
 142     public HotSpotMethodDataAccessor getExtraData(int position) {
 143         if (position &gt;= normalDataSize() + extraDataSize()) {
 144             return null;
 145         }
 146         HotSpotMethodDataAccessor data = getData(position);
 147         if (data != null) {
 148             return data;
 149         }
 150         return data;
 151     }
 152 
 153     public static HotSpotMethodDataAccessor getNoDataAccessor(boolean exceptionPossiblyNotRecorded) {
 154         if (exceptionPossiblyNotRecorded) {
 155             return NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR;
 156         } else {
 157             return NO_DATA_NO_EXCEPTION_ACCESSOR;
 158         }
 159     }
 160 
 161     private HotSpotMethodDataAccessor getData(int position) {
 162         assert position &gt;= 0 : "out of bounds";
<span class="changed"> 163         final Tag tag = AbstractMethodData.readTag(this, position);</span>
<span class="changed"> 164         HotSpotMethodDataAccessor accessor = PROFILE_DATA_ACCESSORS[tag.getValue()];</span>
 165         assert accessor == null || accessor.getTag() == tag : "wrong data accessor " + accessor + " for tag " + tag;
 166         return accessor;
 167     }
 168 
<span class="changed"> 169     private int readUnsignedByte(int position, int offsetInBytes) {</span>
 170         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 171         return UNSAFE.getByte(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFF;
 172     }
 173 
<span class="changed"> 174     private int readUnsignedShort(int position, int offsetInBytes) {</span>
 175         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 176         return UNSAFE.getShort(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFF;
 177     }
 178 
 179     /**
 180      * Since the values are stored in cells (platform words) this method uses
 181      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
 182      */
 183     private long readUnsignedInt(int position, int offsetInBytes) {
 184         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 185         return UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFFFFFFL;
 186     }
 187 
 188     private int readUnsignedIntAsSignedInt(int position, int offsetInBytes) {
 189         long value = readUnsignedInt(position, offsetInBytes);
 190         return truncateLongToInt(value);
 191     }
 192 
 193     /**
 194      * Since the values are stored in cells (platform words) this method uses

</pre><hr></hr><pre>
 252             }
 253         }
 254 
 255         if (hasExtraData()) {
 256             int pos = getExtraDataBeginOffset();
 257             HotSpotMethodDataAccessor data;
 258             while ((data = getExtraData(pos)) != null) {
 259                 if (pos == getExtraDataBeginOffset()) {
 260                     sb.append(nl).append("--- Extra data:");
 261                 }
 262                 int bci = data.getBCI(this, pos);
 263                 sb.append(String.format("%n%-6d bci: %-6d%-20s", pos, bci, data.getClass().getSimpleName()));
 264                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
 265                 pos = pos + data.getSize(this, pos);
 266             }
 267 
 268         }
 269         return sb.toString();
 270     }
 271 
<span class="changed"> 272     private abstract static class AbstractMethodData implements HotSpotMethodDataAccessor {</span>
<span class="changed"> 273 </span>
<span class="changed"> 274         /**</span>
<span class="changed"> 275          * Corresponds to {@code exception_seen_flag}.</span>
<span class="changed"> 276          */</span>
<span class="changed"> 277         private static final int EXCEPTIONS_MASK = 1 &lt;&lt; config.bitDataExceptionSeenFlag;</span>
<span class="changed"> 278 </span>
<span class="changed"> 279         private final Tag tag;</span>
<span class="changed"> 280         protected final int staticSize;</span>
<span class="changed"> 281 </span>
<span class="changed"> 282         protected AbstractMethodData(Tag tag, int staticSize) {</span>
<span class="changed"> 283             this.tag = tag;</span>
<span class="changed"> 284             this.staticSize = staticSize;</span>
<span class="changed"> 285         }</span>
<span class="changed"> 286 </span>
<span class="changed"> 287         public Tag getTag() {</span>
<span class="changed"> 288             return tag;</span>
<span class="changed"> 289         }</span>
<span class="changed"> 290 </span>
<span class="changed"> 291         public static Tag readTag(HotSpotMethodData data, int position) {</span>
<span class="changed"> 292             final int tag = data.readUnsignedByte(position, config.dataLayoutTagOffset);</span>
<span class="changed"> 293             return Tag.getEnum(tag);</span>
<span class="changed"> 294         }</span>
<span class="changed"> 295 </span>
<span class="changed"> 296         @Override</span>
<span class="changed"> 297         public int getBCI(HotSpotMethodData data, int position) {</span>
<span class="changed"> 298             return data.readUnsignedShort(position, config.dataLayoutBCIOffset);</span>
<span class="changed"> 299         }</span>
<span class="changed"> 300 </span>
<span class="changed"> 301         @Override</span>
<span class="changed"> 302         public final int getSize(HotSpotMethodData data, int position) {</span>
<span class="changed"> 303             int size = staticSize + getDynamicSize(data, position);</span>
<span class="changed"> 304             // Sanity check against VM</span>
<span class="changed"> 305             int vmSize = HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);</span>
<span class="changed"> 306             assert size == vmSize : size + " != " + vmSize;</span>
<span class="changed"> 307             return size;</span>
<span class="changed"> 308         }</span>
<span class="changed"> 309 </span>
<span class="changed"> 310         @Override</span>
<span class="changed"> 311         public TriState getExceptionSeen(HotSpotMethodData data, int position) {</span>
<span class="changed"> 312             return TriState.get((getFlags(data, position) &amp; EXCEPTIONS_MASK) != 0);</span>
<span class="changed"> 313         }</span>
<span class="changed"> 314 </span>
<span class="changed"> 315         @Override</span>
<span class="changed"> 316         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {</span>
<span class="changed"> 317             return null;</span>
<span class="changed"> 318         }</span>
<span class="changed"> 319 </span>
<span class="changed"> 320         @Override</span>
<span class="changed"> 321         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {</span>
<span class="changed"> 322             return null;</span>
<span class="changed"> 323         }</span>
<span class="changed"> 324 </span>
<span class="changed"> 325         @Override</span>
<span class="changed"> 326         public double getBranchTakenProbability(HotSpotMethodData data, int position) {</span>
<span class="changed"> 327             return -1;</span>
<span class="changed"> 328         }</span>
 329 
<span class="changed"> 330         @Override</span>
<span class="changed"> 331         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {</span>
<span class="changed"> 332             return null;</span>
<span class="changed"> 333         }</span>
<span class="changed"> 334 </span>
<span class="changed"> 335         @Override</span>
<span class="changed"> 336         public int getExecutionCount(HotSpotMethodData data, int position) {</span>
<span class="changed"> 337             return -1;</span>
<span class="changed"> 338         }</span>
<span class="changed"> 339 </span>
<span class="changed"> 340         @Override</span>
<span class="changed"> 341         public TriState getNullSeen(HotSpotMethodData data, int position) {</span>
<span class="changed"> 342             return TriState.UNKNOWN;</span>
<span class="changed"> 343         }</span>
<span class="changed"> 344 </span>
<span class="changed"> 345         protected int getFlags(HotSpotMethodData data, int position) {</span>
<span class="changed"> 346             return data.readUnsignedByte(position, config.dataLayoutFlagsOffset);</span>
<span class="changed"> 347         }</span>
<span class="changed"> 348 </span>
<span class="changed"> 349         /**</span>
<span class="changed"> 350          * @param data</span>
<span class="changed"> 351          * @param position</span>
<span class="changed"> 352          */</span>
<span class="changed"> 353         protected int getDynamicSize(HotSpotMethodData data, int position) {</span>
<span class="changed"> 354             return 0;</span>
<span class="changed"> 355         }</span>
<span class="changed"> 356 </span>
<span class="changed"> 357         public abstract StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos);</span>
<span class="changed"> 358     }</span>
<span class="changed"> 359 </span>
<span class="changed"> 360     private static class NoMethodData extends AbstractMethodData {</span>
<span class="changed"> 361 </span>
<span class="changed"> 362         private static final int NO_DATA_SIZE = cellIndexToOffset(0);</span>
 363 
 364         private final TriState exceptionSeen;
 365 
<span class="changed"> 366         protected NoMethodData(TriState exceptionSeen) {</span>
<span class="changed"> 367             super(Tag.No, NO_DATA_SIZE);</span>
 368             this.exceptionSeen = exceptionSeen;
 369         }
 370 
 371         @Override
 372         public int getBCI(HotSpotMethodData data, int position) {
 373             return -1;
 374         }
 375 
 376         @Override
 377         public TriState getExceptionSeen(HotSpotMethodData data, int position) {
 378             return exceptionSeen;
 379         }
 380 
 381         @Override
 382         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 383             return sb;
 384         }
 385     }
 386 
<span class="changed"> 387     private static class BitData extends AbstractMethodData {</span>

 388 
<span class="changed"> 389         private static final int BIT_DATA_SIZE = cellIndexToOffset(0);</span>
<span class="changed"> 390         private static final int BIT_DATA_NULL_SEEN_FLAG = 1 &lt;&lt; config.bitDataNullSeenFlag;</span>
 391 
<span class="changed"> 392         private BitData() {</span>
<span class="changed"> 393             super(Tag.BitData, BIT_DATA_SIZE);</span>
 394         }
 395 
<span class="changed"> 396         protected BitData(Tag tag, int staticSize) {</span>
<span class="changed"> 397             super(tag, staticSize);</span>
 398         }
 399 
 400         @Override
 401         public TriState getNullSeen(HotSpotMethodData data, int position) {
 402             return TriState.get((getFlags(data, position) &amp; BIT_DATA_NULL_SEEN_FLAG) != 0);
 403         }
 404 
 405         @Override
 406         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 407             return sb.append(format("exception_seen(%s)", getExceptionSeen(data, pos)));
 408         }
 409     }
 410 
<span class="changed"> 411     private static class CounterData extends BitData {</span>

 412 
<span class="changed"> 413         private static final int COUNTER_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="changed"> 414         private static final int COUNTER_DATA_COUNT_OFFSET = cellIndexToOffset(config.methodDataCountOffset);</span>
 415 
<span class="changed"> 416         CounterData() {</span>
<span class="changed"> 417             super(Tag.CounterData, COUNTER_DATA_SIZE);</span>
 418         }
 419 
<span class="changed"> 420         protected CounterData(Tag tag, int staticSize) {</span>
<span class="changed"> 421             super(tag, staticSize);</span>
 422         }
 423 
 424         @Override
 425         public int getExecutionCount(HotSpotMethodData data, int position) {
 426             return getCounterValue(data, position);
 427         }
 428 
 429         protected int getCounterValue(HotSpotMethodData data, int position) {
 430             return data.readUnsignedIntAsSignedInt(position, COUNTER_DATA_COUNT_OFFSET);
 431         }
 432 
 433         @Override
 434         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 435             return sb.append(format("count(%d) null_seen(%s) exception_seen(%s)", getCounterValue(data, pos), getNullSeen(data, pos), getExceptionSeen(data, pos)));
 436         }
 437     }
 438 
<span class="changed"> 439     private static class JumpData extends AbstractMethodData {</span>


 440 
<span class="changed"> 441         private static final int JUMP_DATA_SIZE = cellIndexToOffset(2);</span>
<span class="changed"> 442         protected static final int TAKEN_COUNT_OFFSET = cellIndexToOffset(config.jumpDataTakenOffset);</span>
<span class="changed"> 443         protected static final int TAKEN_DISPLACEMENT_OFFSET = cellIndexToOffset(config.jumpDataDisplacementOffset);</span>
 444 
<span class="changed"> 445         JumpData() {</span>
<span class="changed"> 446             super(Tag.JumpData, JUMP_DATA_SIZE);</span>
 447         }
 448 
<span class="changed"> 449         protected JumpData(Tag tag, int staticSize) {</span>
<span class="changed"> 450             super(tag, staticSize);</span>
 451         }
 452 
 453         @Override
 454         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
 455             return getExecutionCount(data, position) != 0 ? 1 : 0;
 456         }
 457 
 458         @Override
 459         public int getExecutionCount(HotSpotMethodData data, int position) {
 460             return data.readUnsignedIntAsSignedInt(position, TAKEN_COUNT_OFFSET);
 461         }
 462 
 463         public int getTakenDisplacement(HotSpotMethodData data, int position) {
 464             return data.readInt(position, TAKEN_DISPLACEMENT_OFFSET);
 465         }
 466 
 467         @Override
 468         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 469             return sb.append(format("taken(%d) displacement(%d)", getExecutionCount(data, pos), getTakenDisplacement(data, pos)));
 470         }
 471     }
 472 
 473     static class RawItemProfile&lt;T&gt; {
 474         final int entries;
 475         final T[] items;
 476         final long[] counts;
 477         final long totalCount;
 478 
 479         RawItemProfile(int entries, T[] items, long[] counts, long totalCount) {
 480             this.entries = entries;
 481             this.items = items;
 482             this.counts = counts;
 483             this.totalCount = totalCount;
 484         }
 485     }
 486 
<span class="changed"> 487     private abstract static class AbstractTypeData extends CounterData {</span>
 488 
<span class="changed"> 489         protected static final int TYPE_DATA_ROW_SIZE = cellsToBytes(config.receiverTypeDataReceiverTypeRowCellCount);</span>


 490 
<span class="changed"> 491         protected static final int NONPROFILED_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);</span>
<span class="changed"> 492         protected static final int TYPE_DATA_FIRST_TYPE_OFFSET = cellIndexToOffset(config.receiverTypeDataReceiver0Offset);</span>
<span class="changed"> 493         protected static final int TYPE_DATA_FIRST_TYPE_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataCount0Offset);</span>
 494 
<span class="changed"> 495         protected AbstractTypeData(Tag tag, int staticSize) {</span>
<span class="changed"> 496             super(tag, staticSize);</span>
 497         }
 498 
 499         @Override
 500         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {
 501             return createTypeProfile(getNullSeen(data, position), getRawTypeProfile(data, position));
 502         }
 503 
 504         private RawItemProfile&lt;ResolvedJavaType&gt; getRawTypeProfile(HotSpotMethodData data, int position) {
 505             int typeProfileWidth = config.typeProfileWidth;
 506 
 507             ResolvedJavaType[] types = new ResolvedJavaType[typeProfileWidth];
 508             long[] counts = new long[typeProfileWidth];
 509             long totalCount = 0;
 510             int entries = 0;
 511 
 512             outer: for (int i = 0; i &lt; typeProfileWidth; i++) {
 513                 HotSpotResolvedObjectTypeImpl receiverKlass = data.readKlass(position, getTypeOffset(i));
 514                 if (receiverKlass != null) {
 515                     HotSpotResolvedObjectTypeImpl klass = receiverKlass;
 516                     long count = data.readUnsignedInt(position, getTypeCountOffset(i));

</pre><hr></hr><pre>
 522                     for (int j = 0; j &lt; entries; j++) {
 523                         if (types[j].equals(klass)) {
 524                             totalCount += count;
 525                             counts[j] += count;
 526                             continue outer;
 527                         }
 528                     }
 529                     types[entries] = klass;
 530                     totalCount += count;
 531                     counts[entries] = count;
 532                     entries++;
 533                 }
 534             }
 535 
 536             totalCount += getTypesNotRecordedExecutionCount(data, position);
 537             return new RawItemProfile&lt;&gt;(entries, types, counts, totalCount);
 538         }
 539 
 540         protected abstract long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position);
 541 
<span class="changed"> 542         private static JavaTypeProfile createTypeProfile(TriState nullSeen, RawItemProfile&lt;ResolvedJavaType&gt; profile) {</span>
 543             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
 544                 return null;
 545             }
 546 
 547             ProfiledType[] ptypes = new ProfiledType[profile.entries];
 548             double totalProbability = 0.0;
 549             for (int i = 0; i &lt; profile.entries; i++) {
 550                 double p = profile.counts[i];
 551                 p = p / profile.totalCount;
 552                 totalProbability += p;
 553                 ptypes[i] = new ProfiledType(profile.items[i], p);
 554             }
 555 
 556             Arrays.sort(ptypes);
 557 
 558             double notRecordedTypeProbability = profile.entries &lt; config.typeProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
 559             assert notRecordedTypeProbability == 0 || profile.entries == config.typeProfileWidth;
 560             return new JavaTypeProfile(nullSeen, notRecordedTypeProbability, ptypes);
 561         }
 562 

</pre><hr></hr><pre>
 566 
 567         protected static int getTypeCountOffset(int row) {
 568             return TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;
 569         }
 570 
 571         @Override
 572         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 573             RawItemProfile&lt;ResolvedJavaType&gt; profile = getRawTypeProfile(data, pos);
 574             TriState nullSeen = getNullSeen(data, pos);
 575             TriState exceptionSeen = getExceptionSeen(data, pos);
 576             sb.append(format("count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)", getCounterValue(data, pos), nullSeen, exceptionSeen,
 577                             getTypesNotRecordedExecutionCount(data, pos), profile.entries));
 578             for (int i = 0; i &lt; profile.entries; i++) {
 579                 long count = profile.counts[i];
 580                 sb.append(format("%n  %s (%d, %4.2f)", profile.items[i].toJavaName(), count, (double) count / profile.totalCount));
 581             }
 582             return sb;
 583         }
 584     }
 585 
<span class="changed"> 586     private static class ReceiverTypeData extends AbstractTypeData {</span>
 587 
<span class="changed"> 588         private static final int TYPE_CHECK_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
 589 
<span class="changed"> 590         ReceiverTypeData() {</span>
<span class="changed"> 591             super(Tag.ReceiverTypeData, TYPE_CHECK_DATA_SIZE);</span>
 592         }
 593 
<span class="changed"> 594         protected ReceiverTypeData(Tag tag, int staticSize) {</span>
<span class="changed"> 595             super(tag, staticSize);</span>
 596         }
 597 
 598         @Override
 599         public int getExecutionCount(HotSpotMethodData data, int position) {
 600             return -1;
 601         }
 602 
 603         @Override
 604         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 605             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);
 606         }
 607     }
 608 
<span class="changed"> 609     private static class VirtualCallData extends ReceiverTypeData {</span>


 610 
<span class="changed"> 611         private static final int VIRTUAL_CALL_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * (config.typeProfileWidth + config.methodProfileWidth);</span>
<span class="changed"> 612         private static final int VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET = TYPE_DATA_FIRST_TYPE_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
<span class="changed"> 613         private static final int VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET = TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
 614 
<span class="changed"> 615         VirtualCallData() {</span>
<span class="changed"> 616             super(Tag.VirtualCallData, VIRTUAL_CALL_DATA_SIZE);</span>
 617         }
 618 
<span class="changed"> 619         protected VirtualCallData(Tag tag, int staticSize) {</span>
<span class="changed"> 620             super(tag, staticSize);</span>
 621         }
 622 
 623         @Override
 624         public int getExecutionCount(HotSpotMethodData data, int position) {
 625             final int typeProfileWidth = config.typeProfileWidth;
 626 
 627             long total = 0;
 628             for (int i = 0; i &lt; typeProfileWidth; i++) {
 629                 total += data.readUnsignedInt(position, getTypeCountOffset(i));
 630             }
 631 
 632             total += getCounterValue(data, position);
 633             return truncateLongToInt(total);
 634         }
 635 
 636         @Override
 637         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 638             return getCounterValue(data, position);
 639         }
 640 
 641         private static long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 642             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);
 643         }
 644 
 645         @Override
 646         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {
 647             return createMethodProfile(getRawMethodProfile(data, position));
 648         }
 649 
<span class="changed"> 650         private static RawItemProfile&lt;ResolvedJavaMethod&gt; getRawMethodProfile(HotSpotMethodData data, int position) {</span>
 651             int profileWidth = config.methodProfileWidth;
 652 
 653             ResolvedJavaMethod[] methods = new ResolvedJavaMethod[profileWidth];
 654             long[] counts = new long[profileWidth];
 655             long totalCount = 0;
 656             int entries = 0;
 657 
 658             for (int i = 0; i &lt; profileWidth; i++) {
 659                 HotSpotResolvedJavaMethod method = data.readMethod(position, getMethodOffset(i));
 660                 if (method != null) {
 661                     methods[entries] = method;
 662                     long count = data.readUnsignedInt(position, getMethodCountOffset(i));
 663                     totalCount += count;
 664                     counts[entries] = count;
 665 
 666                     entries++;
 667                 }
 668             }
 669 
 670             totalCount += getMethodsNotRecordedExecutionCount(data, position);
 671             return new RawItemProfile&lt;&gt;(entries, methods, counts, totalCount);
 672         }
 673 
<span class="changed"> 674         private static JavaMethodProfile createMethodProfile(RawItemProfile&lt;ResolvedJavaMethod&gt; profile) {</span>
 675             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
 676                 return null;
 677             }
 678 
 679             ProfiledMethod[] pmethods = new ProfiledMethod[profile.entries];
 680             double totalProbability = 0.0;
 681             for (int i = 0; i &lt; profile.entries; i++) {
 682                 double p = profile.counts[i];
 683                 p = p / profile.totalCount;
 684                 totalProbability += p;
 685                 pmethods[i] = new ProfiledMethod(profile.items[i], p);
 686             }
 687 
 688             Arrays.sort(pmethods);
 689 
 690             double notRecordedMethodProbability = profile.entries &lt; config.methodProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
 691             assert notRecordedMethodProbability == 0 || profile.entries == config.methodProfileWidth;
 692             return new JavaMethodProfile(notRecordedMethodProbability, pmethods);
 693         }
 694 
 695         private static int getMethodOffset(int row) {
 696             return VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET + row * TYPE_DATA_ROW_SIZE;
 697         }
 698 
 699         private static int getMethodCountOffset(int row) {
 700             return VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;
 701         }
 702 
 703         @Override
 704         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 705             RawItemProfile&lt;ResolvedJavaMethod&gt; profile = getRawMethodProfile(data, pos);
 706             super.appendTo(sb.append(format("exception_seen(%s) ", getExceptionSeen(data, pos))), data, pos).append(format("%nmethod_entries(%d)", profile.entries));
 707             for (int i = 0; i &lt; profile.entries; i++) {
 708                 long count = profile.counts[i];
 709                 sb.append(format("%n  %s (%d, %4.2f)", profile.items[i].format("%H.%n(%p)"), count, (double) count / profile.totalCount));
 710             }
 711             return sb;
 712         }
 713     }
 714 
<span class="changed"> 715     private static class VirtualCallTypeData extends VirtualCallData {</span>
 716 
<span class="changed"> 717         VirtualCallTypeData() {</span>
<span class="changed"> 718             super(Tag.VirtualCallTypeData, 0);</span>
 719         }
 720 
 721         @Override
 722         protected int getDynamicSize(HotSpotMethodData data, int position) {
 723             assert staticSize == 0;
 724             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
 725         }
 726     }
 727 
<span class="changed"> 728     private static class RetData extends CounterData {</span>

 729 
<span class="changed"> 730         private static final int RET_DATA_ROW_SIZE = cellsToBytes(3);</span>
<span class="changed"> 731         private static final int RET_DATA_SIZE = cellIndexToOffset(1) + RET_DATA_ROW_SIZE * config.bciProfileWidth;</span>
 732 
<span class="changed"> 733         RetData() {</span>
<span class="changed"> 734             super(Tag.RetData, RET_DATA_SIZE);</span>
 735         }
 736     }
 737 
<span class="changed"> 738     private static class BranchData extends JumpData {</span>

 739 
<span class="changed"> 740         private static final int BRANCH_DATA_SIZE = cellIndexToOffset(3);</span>
<span class="changed"> 741         private static final int NOT_TAKEN_COUNT_OFFSET = cellIndexToOffset(config.branchDataNotTakenOffset);</span>
 742 
<span class="changed"> 743         BranchData() {</span>
<span class="changed"> 744             super(Tag.BranchData, BRANCH_DATA_SIZE);</span>
 745         }
 746 
 747         @Override
 748         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
 749             long takenCount = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET);
 750             long notTakenCount = data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);
 751             long total = takenCount + notTakenCount;
 752 
 753             return total &lt;= 0 ? -1 : takenCount / (double) total;
 754         }
 755 
 756         @Override
 757         public int getExecutionCount(HotSpotMethodData data, int position) {
 758             long count = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET) + data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);
 759             return truncateLongToInt(count);
 760         }
 761 
 762         @Override
 763         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 764             long taken = data.readUnsignedInt(pos, TAKEN_COUNT_OFFSET);
 765             long notTaken = data.readUnsignedInt(pos, NOT_TAKEN_COUNT_OFFSET);
 766             double takenProbability = getBranchTakenProbability(data, pos);
 767             return sb.append(format("taken(%d, %4.2f) not_taken(%d, %4.2f) displacement(%d)", taken, takenProbability, notTaken, 1.0D - takenProbability, getTakenDisplacement(data, pos)));
 768         }
 769     }
 770 
<span class="changed"> 771     private static class ArrayData extends AbstractMethodData {</span>

 772 
<span class="changed"> 773         private static final int ARRAY_DATA_LENGTH_OFFSET = cellIndexToOffset(config.arrayDataArrayLenOffset);</span>
<span class="changed"> 774         protected static final int ARRAY_DATA_START_OFFSET = cellIndexToOffset(config.arrayDataArrayStartOffset);</span>
 775 
<span class="changed"> 776         ArrayData(Tag tag, int staticSize) {</span>
<span class="changed"> 777             super(tag, staticSize);</span>
 778         }
 779 
 780         @Override
 781         protected int getDynamicSize(HotSpotMethodData data, int position) {
 782             return cellsToBytes(getLength(data, position));
 783         }
 784 
 785         protected static int getLength(HotSpotMethodData data, int position) {
 786             return data.readInt(position, ARRAY_DATA_LENGTH_OFFSET);
 787         }
 788 
 789         @Override
 790         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 791             return sb.append(format("length(%d)", getLength(data, pos)));
 792         }
 793     }
 794 
<span class="changed"> 795     private static class MultiBranchData extends ArrayData {</span>




 796 
<span class="changed"> 797         private static final int MULTI_BRANCH_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="changed"> 798         private static final int MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS = config.multiBranchDataPerCaseCellCount;</span>
<span class="changed"> 799         private static final int MULTI_BRANCH_DATA_ROW_SIZE = cellsToBytes(MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS);</span>
<span class="changed"> 800         private static final int MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(0);</span>
<span class="changed"> 801         private static final int MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(1);</span>
 802 
<span class="changed"> 803         MultiBranchData() {</span>
<span class="changed"> 804             super(Tag.MultiBranchData, MULTI_BRANCH_DATA_SIZE);</span>
 805         }
 806 
 807         @Override
 808         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {
 809             int arrayLength = getLength(data, position);
 810             assert arrayLength &gt; 0 : "switch must have at least the default case";
 811             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : "array must have full rows";
 812 
 813             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 814             long totalCount = 0;
 815             double[] result = new double[length];
 816 
 817             // default case is first in HotSpot but last for the compiler
 818             long count = readCount(data, position, 0);
 819             totalCount += count;
 820             result[length - 1] = count;
 821 
 822             for (int i = 1; i &lt; length; i++) {
 823                 count = readCount(data, position, i);
 824                 totalCount += count;

</pre><hr></hr><pre>
 861 
 862         private static int getCountOffset(int index) {
 863             return MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;
 864         }
 865 
 866         private static int getDisplacementOffset(int index) {
 867             return MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;
 868         }
 869 
 870         @Override
 871         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 872             int entries = getLength(data, pos) / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 873             sb.append(format("entries(%d)", entries));
 874             for (int i = 0; i &lt; entries; i++) {
 875                 sb.append(format("%n  %d: count(%d) displacement(%d)", i, data.readUnsignedInt(pos, getCountOffset(i)), data.readUnsignedInt(pos, getDisplacementOffset(i))));
 876             }
 877             return sb;
 878         }
 879     }
 880 
<span class="changed"> 881     private static class ArgInfoData extends ArrayData {</span>
 882 
<span class="changed"> 883         private static final int ARG_INFO_DATA_SIZE = cellIndexToOffset(1);</span>
 884 
<span class="changed"> 885         ArgInfoData() {</span>
<span class="changed"> 886             super(Tag.ArgInfoData, ARG_INFO_DATA_SIZE);</span>
 887         }
 888     }
 889 
<span class="changed"> 890     private static class UnknownProfileData extends AbstractMethodData {</span>
<span class="changed"> 891         UnknownProfileData(Tag tag) {</span>
<span class="changed"> 892             super(tag, 0);</span>
 893         }
 894 
 895         @Override
 896         protected int getDynamicSize(HotSpotMethodData data, int position) {
 897             assert staticSize == 0;
 898             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
 899         }
 900 
 901         @Override
 902         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
<span class="removed"> 903             // TODO Auto-generated method stub</span>
 904             return null;
 905         }
 906     }
 907 
 908     public void setCompiledIRSize(int size) {
 909         UNSAFE.putInt(metaspaceMethodData + config.methodDataIRSizeOffset, size);
 910     }
 911 
 912     public int getCompiledIRSize() {
 913         return UNSAFE.getInt(metaspaceMethodData + config.methodDataIRSizeOffset);
 914     }





































 915 }
</pre></td><td><pre>

</pre><hr></hr><pre>
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.lang.String.format;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  30 
  31 import java.util.Arrays;
  32 
<span class="changed">  33 import jdk.internal.misc.Unsafe;</span>
  34 import jdk.vm.ci.meta.DeoptimizationReason;
  35 import jdk.vm.ci.meta.JavaMethodProfile;
  36 import jdk.vm.ci.meta.JavaMethodProfile.ProfiledMethod;
  37 import jdk.vm.ci.meta.JavaTypeProfile;
  38 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;
  39 import jdk.vm.ci.meta.ResolvedJavaMethod;
  40 import jdk.vm.ci.meta.ResolvedJavaType;
  41 import jdk.vm.ci.meta.TriState;

  42 
  43 /**
<span class="changed">  44  * Access to a HotSpot {@code MethodData} structure (defined in methodData.hpp).</span>
  45  */
<span class="changed">  46 final class HotSpotMethodData {</span>
  47 
<span class="changed">  48     static final HotSpotVMConfig config = config();</span>
<span class="changed">  49     static final HotSpotMethodDataAccessor NO_DATA_NO_EXCEPTION_ACCESSOR = new NoMethodData(config, config.dataLayoutNoTag, TriState.FALSE);</span>
<span class="changed">  50     static final HotSpotMethodDataAccessor NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR = new NoMethodData(config, config.dataLayoutNoTag, TriState.UNKNOWN);</span>




















  51 
  52     /**
  53      * Reference to the C++ MethodData object.
  54      */
<span class="changed">  55     final long metaspaceMethodData;</span>
  56     @SuppressWarnings("unused") private final HotSpotResolvedJavaMethodImpl method;
  57 
  58     public HotSpotMethodData(long metaspaceMethodData, HotSpotResolvedJavaMethodImpl method) {
  59         this.metaspaceMethodData = metaspaceMethodData;
  60         this.method = method;
  61     }
  62 
  63     /**
  64      * @return value of the MethodData::_data_size field
  65      */
  66     private int normalDataSize() {
  67         return UNSAFE.getInt(metaspaceMethodData + config.methodDataDataSize);
  68     }
  69 
  70     /**
  71      * Returns the size of the extra data records. This method does the same calculation as
  72      * MethodData::extra_data_size().
  73      *
  74      * @return size of extra data records
  75      */

</pre><hr></hr><pre>
  95         return position &gt;= 0 &amp;&amp; position &lt; normalDataSize() + extraDataSize();
  96     }
  97 
  98     public int getDeoptimizationCount(DeoptimizationReason reason) {
  99         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
 100         int reasonIndex = metaAccess.convertDeoptReason(reason);
 101         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + reasonIndex) &amp; 0xFF;
 102     }
 103 
 104     public int getOSRDeoptimizationCount(DeoptimizationReason reason) {
 105         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
 106         int reasonIndex = metaAccess.convertDeoptReason(reason);
 107         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + config.deoptReasonOSROffset + reasonIndex) &amp; 0xFF;
 108     }
 109 
 110     public HotSpotMethodDataAccessor getNormalData(int position) {
 111         if (position &gt;= normalDataSize()) {
 112             return null;
 113         }
 114 
<span class="changed"> 115         return getData(position);</span>



 116     }
 117 
 118     public HotSpotMethodDataAccessor getExtraData(int position) {
 119         if (position &gt;= normalDataSize() + extraDataSize()) {
 120             return null;
 121         }
 122         HotSpotMethodDataAccessor data = getData(position);
 123         if (data != null) {
 124             return data;
 125         }
 126         return data;
 127     }
 128 
 129     public static HotSpotMethodDataAccessor getNoDataAccessor(boolean exceptionPossiblyNotRecorded) {
 130         if (exceptionPossiblyNotRecorded) {
 131             return NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR;
 132         } else {
 133             return NO_DATA_NO_EXCEPTION_ACCESSOR;
 134         }
 135     }
 136 
 137     private HotSpotMethodDataAccessor getData(int position) {
 138         assert position &gt;= 0 : "out of bounds";
<span class="changed"> 139         final int tag = HotSpotMethodDataAccessor.readTag(config, this, position);</span>
<span class="changed"> 140         HotSpotMethodDataAccessor accessor = PROFILE_DATA_ACCESSORS[tag];</span>
 141         assert accessor == null || accessor.getTag() == tag : "wrong data accessor " + accessor + " for tag " + tag;
 142         return accessor;
 143     }
 144 
<span class="changed"> 145     int readUnsignedByte(int position, int offsetInBytes) {</span>
 146         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 147         return UNSAFE.getByte(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFF;
 148     }
 149 
<span class="changed"> 150     int readUnsignedShort(int position, int offsetInBytes) {</span>
 151         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 152         return UNSAFE.getShort(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFF;
 153     }
 154 
 155     /**
 156      * Since the values are stored in cells (platform words) this method uses
 157      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
 158      */
 159     private long readUnsignedInt(int position, int offsetInBytes) {
 160         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 161         return UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFFFFFFL;
 162     }
 163 
 164     private int readUnsignedIntAsSignedInt(int position, int offsetInBytes) {
 165         long value = readUnsignedInt(position, offsetInBytes);
 166         return truncateLongToInt(value);
 167     }
 168 
 169     /**
 170      * Since the values are stored in cells (platform words) this method uses

</pre><hr></hr><pre>
 228             }
 229         }
 230 
 231         if (hasExtraData()) {
 232             int pos = getExtraDataBeginOffset();
 233             HotSpotMethodDataAccessor data;
 234             while ((data = getExtraData(pos)) != null) {
 235                 if (pos == getExtraDataBeginOffset()) {
 236                     sb.append(nl).append("--- Extra data:");
 237                 }
 238                 int bci = data.getBCI(this, pos);
 239                 sb.append(String.format("%n%-6d bci: %-6d%-20s", pos, bci, data.getClass().getSimpleName()));
 240                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
 241                 pos = pos + data.getSize(this, pos);
 242             }
 243 
 244         }
 245         return sb.toString();
 246     }
 247 
<span class="changed"> 248     static final int NO_DATA_SIZE = cellIndexToOffset(0);</span>
























































 249 
<span class="changed"> 250     static class NoMethodData extends HotSpotMethodDataAccessor {</span>
































 251 
 252         private final TriState exceptionSeen;
 253 
<span class="changed"> 254         protected NoMethodData(HotSpotVMConfig config, int tag, TriState exceptionSeen) {</span>
<span class="changed"> 255             super(config, tag, NO_DATA_SIZE);</span>
 256             this.exceptionSeen = exceptionSeen;
 257         }
 258 
 259         @Override
 260         public int getBCI(HotSpotMethodData data, int position) {
 261             return -1;
 262         }
 263 
 264         @Override
 265         public TriState getExceptionSeen(HotSpotMethodData data, int position) {
 266             return exceptionSeen;
 267         }
 268 
 269         @Override
 270         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 271             return sb;
 272         }
 273     }
 274 
<span class="changed"> 275     static final int BIT_DATA_SIZE = cellIndexToOffset(0);</span>
<span class="changed"> 276     static final int BIT_DATA_NULL_SEEN_FLAG = 1 &lt;&lt; config.bitDataNullSeenFlag;</span>
 277 
<span class="changed"> 278     static class BitData extends HotSpotMethodDataAccessor {</span>

 279 
<span class="changed"> 280         private BitData(HotSpotVMConfig config, int tag) {</span>
<span class="changed"> 281             super(config, tag, BIT_DATA_SIZE);</span>
 282         }
 283 
<span class="changed"> 284         protected BitData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="changed"> 285             super(config, tag, staticSize);</span>
 286         }
 287 
 288         @Override
 289         public TriState getNullSeen(HotSpotMethodData data, int position) {
 290             return TriState.get((getFlags(data, position) &amp; BIT_DATA_NULL_SEEN_FLAG) != 0);
 291         }
 292 
 293         @Override
 294         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 295             return sb.append(format("exception_seen(%s)", getExceptionSeen(data, pos)));
 296         }
 297     }
 298 
<span class="changed"> 299     static final int COUNTER_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="changed"> 300     static final int COUNTER_DATA_COUNT_OFFSET = cellIndexToOffset(config.methodDataCountOffset);</span>
 301 
<span class="changed"> 302     static class CounterData extends BitData {</span>

 303 
<span class="changed"> 304         CounterData(HotSpotVMConfig config, int tag) {</span>
<span class="changed"> 305             super(config, tag, COUNTER_DATA_SIZE);</span>
 306         }
 307 
<span class="changed"> 308         protected CounterData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="changed"> 309             super(config, tag, staticSize);</span>
 310         }
 311 
 312         @Override
 313         public int getExecutionCount(HotSpotMethodData data, int position) {
 314             return getCounterValue(data, position);
 315         }
 316 
 317         protected int getCounterValue(HotSpotMethodData data, int position) {
 318             return data.readUnsignedIntAsSignedInt(position, COUNTER_DATA_COUNT_OFFSET);
 319         }
 320 
 321         @Override
 322         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 323             return sb.append(format("count(%d) null_seen(%s) exception_seen(%s)", getCounterValue(data, pos), getNullSeen(data, pos), getExceptionSeen(data, pos)));
 324         }
 325     }
 326 
<span class="changed"> 327     static final int JUMP_DATA_SIZE = cellIndexToOffset(2);</span>
<span class="changed"> 328     static final int TAKEN_COUNT_OFFSET = cellIndexToOffset(config.jumpDataTakenOffset);</span>
<span class="changed"> 329     static final int TAKEN_DISPLACEMENT_OFFSET = cellIndexToOffset(config.jumpDataDisplacementOffset);</span>
 330 
<span class="changed"> 331     static class JumpData extends HotSpotMethodDataAccessor {</span>


 332 
<span class="changed"> 333         JumpData(HotSpotVMConfig config, int tag) {</span>
<span class="changed"> 334             super(config, tag, JUMP_DATA_SIZE);</span>
 335         }
 336 
<span class="changed"> 337         protected JumpData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="changed"> 338             super(config, tag, staticSize);</span>
 339         }
 340 
 341         @Override
 342         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
 343             return getExecutionCount(data, position) != 0 ? 1 : 0;
 344         }
 345 
 346         @Override
 347         public int getExecutionCount(HotSpotMethodData data, int position) {
 348             return data.readUnsignedIntAsSignedInt(position, TAKEN_COUNT_OFFSET);
 349         }
 350 
 351         public int getTakenDisplacement(HotSpotMethodData data, int position) {
 352             return data.readInt(position, TAKEN_DISPLACEMENT_OFFSET);
 353         }
 354 
 355         @Override
 356         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 357             return sb.append(format("taken(%d) displacement(%d)", getExecutionCount(data, pos), getTakenDisplacement(data, pos)));
 358         }
 359     }
 360 
 361     static class RawItemProfile&lt;T&gt; {
 362         final int entries;
 363         final T[] items;
 364         final long[] counts;
 365         final long totalCount;
 366 
 367         RawItemProfile(int entries, T[] items, long[] counts, long totalCount) {
 368             this.entries = entries;
 369             this.items = items;
 370             this.counts = counts;
 371             this.totalCount = totalCount;
 372         }
 373     }
 374 
<span class="changed"> 375     static final int TYPE_DATA_ROW_SIZE = cellsToBytes(config.receiverTypeDataReceiverTypeRowCellCount);</span>
 376 
<span class="changed"> 377     static final int NONPROFILED_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);</span>
<span class="changed"> 378     static final int TYPE_DATA_FIRST_TYPE_OFFSET = cellIndexToOffset(config.receiverTypeDataReceiver0Offset);</span>
<span class="changed"> 379     static final int TYPE_DATA_FIRST_TYPE_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataCount0Offset);</span>
 380 
<span class="changed"> 381     abstract static class AbstractTypeData extends CounterData {</span>


 382 
<span class="changed"> 383         protected AbstractTypeData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="changed"> 384             super(config, tag, staticSize);</span>
 385         }
 386 
 387         @Override
 388         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {
 389             return createTypeProfile(getNullSeen(data, position), getRawTypeProfile(data, position));
 390         }
 391 
 392         private RawItemProfile&lt;ResolvedJavaType&gt; getRawTypeProfile(HotSpotMethodData data, int position) {
 393             int typeProfileWidth = config.typeProfileWidth;
 394 
 395             ResolvedJavaType[] types = new ResolvedJavaType[typeProfileWidth];
 396             long[] counts = new long[typeProfileWidth];
 397             long totalCount = 0;
 398             int entries = 0;
 399 
 400             outer: for (int i = 0; i &lt; typeProfileWidth; i++) {
 401                 HotSpotResolvedObjectTypeImpl receiverKlass = data.readKlass(position, getTypeOffset(i));
 402                 if (receiverKlass != null) {
 403                     HotSpotResolvedObjectTypeImpl klass = receiverKlass;
 404                     long count = data.readUnsignedInt(position, getTypeCountOffset(i));

</pre><hr></hr><pre>
 410                     for (int j = 0; j &lt; entries; j++) {
 411                         if (types[j].equals(klass)) {
 412                             totalCount += count;
 413                             counts[j] += count;
 414                             continue outer;
 415                         }
 416                     }
 417                     types[entries] = klass;
 418                     totalCount += count;
 419                     counts[entries] = count;
 420                     entries++;
 421                 }
 422             }
 423 
 424             totalCount += getTypesNotRecordedExecutionCount(data, position);
 425             return new RawItemProfile&lt;&gt;(entries, types, counts, totalCount);
 426         }
 427 
 428         protected abstract long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position);
 429 
<span class="changed"> 430         private JavaTypeProfile createTypeProfile(TriState nullSeen, RawItemProfile&lt;ResolvedJavaType&gt; profile) {</span>
 431             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
 432                 return null;
 433             }
 434 
 435             ProfiledType[] ptypes = new ProfiledType[profile.entries];
 436             double totalProbability = 0.0;
 437             for (int i = 0; i &lt; profile.entries; i++) {
 438                 double p = profile.counts[i];
 439                 p = p / profile.totalCount;
 440                 totalProbability += p;
 441                 ptypes[i] = new ProfiledType(profile.items[i], p);
 442             }
 443 
 444             Arrays.sort(ptypes);
 445 
 446             double notRecordedTypeProbability = profile.entries &lt; config.typeProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
 447             assert notRecordedTypeProbability == 0 || profile.entries == config.typeProfileWidth;
 448             return new JavaTypeProfile(nullSeen, notRecordedTypeProbability, ptypes);
 449         }
 450 

</pre><hr></hr><pre>
 454 
 455         protected static int getTypeCountOffset(int row) {
 456             return TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;
 457         }
 458 
 459         @Override
 460         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 461             RawItemProfile&lt;ResolvedJavaType&gt; profile = getRawTypeProfile(data, pos);
 462             TriState nullSeen = getNullSeen(data, pos);
 463             TriState exceptionSeen = getExceptionSeen(data, pos);
 464             sb.append(format("count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)", getCounterValue(data, pos), nullSeen, exceptionSeen,
 465                             getTypesNotRecordedExecutionCount(data, pos), profile.entries));
 466             for (int i = 0; i &lt; profile.entries; i++) {
 467                 long count = profile.counts[i];
 468                 sb.append(format("%n  %s (%d, %4.2f)", profile.items[i].toJavaName(), count, (double) count / profile.totalCount));
 469             }
 470             return sb;
 471         }
 472     }
 473 
<span class="changed"> 474     static final int TYPE_CHECK_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
 475 
<span class="changed"> 476     static class ReceiverTypeData extends AbstractTypeData {</span>
 477 
<span class="changed"> 478         ReceiverTypeData(HotSpotVMConfig config, int tag) {</span>
<span class="changed"> 479             super(config, tag, TYPE_CHECK_DATA_SIZE);</span>
 480         }
 481 
<span class="changed"> 482         protected ReceiverTypeData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="changed"> 483             super(config, tag, staticSize);</span>
 484         }
 485 
 486         @Override
 487         public int getExecutionCount(HotSpotMethodData data, int position) {
 488             return -1;
 489         }
 490 
 491         @Override
 492         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 493             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);
 494         }
 495     }
 496 
<span class="changed"> 497     static final int VIRTUAL_CALL_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * (config.typeProfileWidth + config.methodProfileWidth);</span>
<span class="changed"> 498     static final int VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET = TYPE_DATA_FIRST_TYPE_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
<span class="changed"> 499     static final int VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET = TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
 500 
<span class="changed"> 501     static class VirtualCallData extends ReceiverTypeData {</span>


 502 
<span class="changed"> 503         VirtualCallData(HotSpotVMConfig config, int tag) {</span>
<span class="changed"> 504             super(config, tag, VIRTUAL_CALL_DATA_SIZE);</span>
 505         }
 506 
<span class="changed"> 507         protected VirtualCallData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="changed"> 508             super(config, tag, staticSize);</span>
 509         }
 510 
 511         @Override
 512         public int getExecutionCount(HotSpotMethodData data, int position) {
 513             final int typeProfileWidth = config.typeProfileWidth;
 514 
 515             long total = 0;
 516             for (int i = 0; i &lt; typeProfileWidth; i++) {
 517                 total += data.readUnsignedInt(position, getTypeCountOffset(i));
 518             }
 519 
 520             total += getCounterValue(data, position);
 521             return truncateLongToInt(total);
 522         }
 523 
 524         @Override
 525         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 526             return getCounterValue(data, position);
 527         }
 528 
 529         private static long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 530             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);
 531         }
 532 
 533         @Override
 534         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {
 535             return createMethodProfile(getRawMethodProfile(data, position));
 536         }
 537 
<span class="changed"> 538         private RawItemProfile&lt;ResolvedJavaMethod&gt; getRawMethodProfile(HotSpotMethodData data, int position) {</span>
 539             int profileWidth = config.methodProfileWidth;
 540 
 541             ResolvedJavaMethod[] methods = new ResolvedJavaMethod[profileWidth];
 542             long[] counts = new long[profileWidth];
 543             long totalCount = 0;
 544             int entries = 0;
 545 
 546             for (int i = 0; i &lt; profileWidth; i++) {
 547                 HotSpotResolvedJavaMethod method = data.readMethod(position, getMethodOffset(i));
 548                 if (method != null) {
 549                     methods[entries] = method;
 550                     long count = data.readUnsignedInt(position, getMethodCountOffset(i));
 551                     totalCount += count;
 552                     counts[entries] = count;
 553 
 554                     entries++;
 555                 }
 556             }
 557 
 558             totalCount += getMethodsNotRecordedExecutionCount(data, position);
 559             return new RawItemProfile&lt;&gt;(entries, methods, counts, totalCount);
 560         }
 561 
<span class="changed"> 562         private JavaMethodProfile createMethodProfile(RawItemProfile&lt;ResolvedJavaMethod&gt; profile) {</span>
 563             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
 564                 return null;
 565             }
 566 
 567             ProfiledMethod[] pmethods = new ProfiledMethod[profile.entries];
 568             double totalProbability = 0.0;
 569             for (int i = 0; i &lt; profile.entries; i++) {
 570                 double p = profile.counts[i];
 571                 p = p / profile.totalCount;
 572                 totalProbability += p;
 573                 pmethods[i] = new ProfiledMethod(profile.items[i], p);
 574             }
 575 
 576             Arrays.sort(pmethods);
 577 
 578             double notRecordedMethodProbability = profile.entries &lt; config.methodProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
 579             assert notRecordedMethodProbability == 0 || profile.entries == config.methodProfileWidth;
 580             return new JavaMethodProfile(notRecordedMethodProbability, pmethods);
 581         }
 582 
 583         private static int getMethodOffset(int row) {
 584             return VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET + row * TYPE_DATA_ROW_SIZE;
 585         }
 586 
 587         private static int getMethodCountOffset(int row) {
 588             return VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;
 589         }
 590 
 591         @Override
 592         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 593             RawItemProfile&lt;ResolvedJavaMethod&gt; profile = getRawMethodProfile(data, pos);
 594             super.appendTo(sb.append(format("exception_seen(%s) ", getExceptionSeen(data, pos))), data, pos).append(format("%nmethod_entries(%d)", profile.entries));
 595             for (int i = 0; i &lt; profile.entries; i++) {
 596                 long count = profile.counts[i];
 597                 sb.append(format("%n  %s (%d, %4.2f)", profile.items[i].format("%H.%n(%p)"), count, (double) count / profile.totalCount));
 598             }
 599             return sb;
 600         }
 601     }
 602 
<span class="changed"> 603     static class VirtualCallTypeData extends VirtualCallData {</span>
 604 
<span class="changed"> 605         VirtualCallTypeData(HotSpotVMConfig config, int tag) {</span>
<span class="changed"> 606             super(config, tag, 0);</span>
 607         }
 608 
 609         @Override
 610         protected int getDynamicSize(HotSpotMethodData data, int position) {
 611             assert staticSize == 0;
 612             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
 613         }
 614     }
 615 
<span class="changed"> 616     static final int RET_DATA_ROW_SIZE = cellsToBytes(3);</span>
<span class="changed"> 617     static final int RET_DATA_SIZE = cellIndexToOffset(1) + RET_DATA_ROW_SIZE * config.bciProfileWidth;</span>
 618 
<span class="changed"> 619     static class RetData extends CounterData {</span>

 620 
<span class="changed"> 621         RetData(HotSpotVMConfig config, int tag) {</span>
<span class="changed"> 622             super(config, tag, RET_DATA_SIZE);</span>
 623         }
 624     }
 625 
<span class="changed"> 626     static final int BRANCH_DATA_SIZE = cellIndexToOffset(3);</span>
<span class="changed"> 627     static final int NOT_TAKEN_COUNT_OFFSET = cellIndexToOffset(config.branchDataNotTakenOffset);</span>
 628 
<span class="changed"> 629     static class BranchData extends JumpData {</span>

 630 
<span class="changed"> 631         BranchData(HotSpotVMConfig config, int tag) {</span>
<span class="changed"> 632             super(config, tag, BRANCH_DATA_SIZE);</span>
 633         }
 634 
 635         @Override
 636         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
 637             long takenCount = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET);
 638             long notTakenCount = data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);
 639             long total = takenCount + notTakenCount;
 640 
 641             return total &lt;= 0 ? -1 : takenCount / (double) total;
 642         }
 643 
 644         @Override
 645         public int getExecutionCount(HotSpotMethodData data, int position) {
 646             long count = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET) + data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);
 647             return truncateLongToInt(count);
 648         }
 649 
 650         @Override
 651         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 652             long taken = data.readUnsignedInt(pos, TAKEN_COUNT_OFFSET);
 653             long notTaken = data.readUnsignedInt(pos, NOT_TAKEN_COUNT_OFFSET);
 654             double takenProbability = getBranchTakenProbability(data, pos);
 655             return sb.append(format("taken(%d, %4.2f) not_taken(%d, %4.2f) displacement(%d)", taken, takenProbability, notTaken, 1.0D - takenProbability, getTakenDisplacement(data, pos)));
 656         }
 657     }
 658 
<span class="changed"> 659     static final int ARRAY_DATA_LENGTH_OFFSET = cellIndexToOffset(config.arrayDataArrayLenOffset);</span>
<span class="changed"> 660     static final int ARRAY_DATA_START_OFFSET = cellIndexToOffset(config.arrayDataArrayStartOffset);</span>
 661 
<span class="changed"> 662     static class ArrayData extends HotSpotMethodDataAccessor {</span>

 663 
<span class="changed"> 664         ArrayData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="changed"> 665             super(config, tag, staticSize);</span>
 666         }
 667 
 668         @Override
 669         protected int getDynamicSize(HotSpotMethodData data, int position) {
 670             return cellsToBytes(getLength(data, position));
 671         }
 672 
 673         protected static int getLength(HotSpotMethodData data, int position) {
 674             return data.readInt(position, ARRAY_DATA_LENGTH_OFFSET);
 675         }
 676 
 677         @Override
 678         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 679             return sb.append(format("length(%d)", getLength(data, pos)));
 680         }
 681     }
 682 
<span class="changed"> 683     static final int MULTI_BRANCH_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="changed"> 684     static final int MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS = config.multiBranchDataPerCaseCellCount;</span>
<span class="changed"> 685     static final int MULTI_BRANCH_DATA_ROW_SIZE = cellsToBytes(MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS);</span>
<span class="changed"> 686     static final int MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(0);</span>
<span class="changed"> 687     static final int MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(1);</span>
 688 
<span class="changed"> 689     static class MultiBranchData extends ArrayData {</span>




 690 
<span class="changed"> 691         MultiBranchData(HotSpotVMConfig config, int tag) {</span>
<span class="changed"> 692             super(config, tag, MULTI_BRANCH_DATA_SIZE);</span>
 693         }
 694 
 695         @Override
 696         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {
 697             int arrayLength = getLength(data, position);
 698             assert arrayLength &gt; 0 : "switch must have at least the default case";
 699             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : "array must have full rows";
 700 
 701             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 702             long totalCount = 0;
 703             double[] result = new double[length];
 704 
 705             // default case is first in HotSpot but last for the compiler
 706             long count = readCount(data, position, 0);
 707             totalCount += count;
 708             result[length - 1] = count;
 709 
 710             for (int i = 1; i &lt; length; i++) {
 711                 count = readCount(data, position, i);
 712                 totalCount += count;

</pre><hr></hr><pre>
 749 
 750         private static int getCountOffset(int index) {
 751             return MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;
 752         }
 753 
 754         private static int getDisplacementOffset(int index) {
 755             return MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;
 756         }
 757 
 758         @Override
 759         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 760             int entries = getLength(data, pos) / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 761             sb.append(format("entries(%d)", entries));
 762             for (int i = 0; i &lt; entries; i++) {
 763                 sb.append(format("%n  %d: count(%d) displacement(%d)", i, data.readUnsignedInt(pos, getCountOffset(i)), data.readUnsignedInt(pos, getDisplacementOffset(i))));
 764             }
 765             return sb;
 766         }
 767     }
 768 
<span class="changed"> 769     static final int ARG_INFO_DATA_SIZE = cellIndexToOffset(1);</span>
 770 
<span class="changed"> 771     static class ArgInfoData extends ArrayData {</span>
 772 
<span class="changed"> 773         ArgInfoData(HotSpotVMConfig config, int tag) {</span>
<span class="changed"> 774             super(config, tag, ARG_INFO_DATA_SIZE);</span>
 775         }
 776     }
 777 
<span class="changed"> 778     static class UnknownProfileData extends HotSpotMethodDataAccessor {</span>
<span class="changed"> 779         UnknownProfileData(HotSpotVMConfig config, int tag) {</span>
<span class="changed"> 780             super(config, tag, 0);</span>
 781         }
 782 
 783         @Override
 784         protected int getDynamicSize(HotSpotMethodData data, int position) {
 785             assert staticSize == 0;
 786             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
 787         }
 788 
 789         @Override
 790         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {

 791             return null;
 792         }
 793     }
 794 
 795     public void setCompiledIRSize(int size) {
 796         UNSAFE.putInt(metaspaceMethodData + config.methodDataIRSizeOffset, size);
 797     }
 798 
 799     public int getCompiledIRSize() {
 800         return UNSAFE.getInt(metaspaceMethodData + config.methodDataIRSizeOffset);
 801     }
<span class="new"> 802 </span>
<span class="new"> 803     // sorted by tag</span>
<span class="new"> 804     // @formatter:off</span>
<span class="new"> 805     static final HotSpotMethodDataAccessor[] PROFILE_DATA_ACCESSORS = {</span>
<span class="new"> 806         null,</span>
<span class="new"> 807         new BitData(config, config.dataLayoutBitDataTag),</span>
<span class="new"> 808         new CounterData(config, config.dataLayoutCounterDataTag),</span>
<span class="new"> 809         new JumpData(config, config.dataLayoutJumpDataTag),</span>
<span class="new"> 810         new ReceiverTypeData(config, config.dataLayoutReceiverTypeDataTag),</span>
<span class="new"> 811         new VirtualCallData(config, config.dataLayoutVirtualCallDataTag),</span>
<span class="new"> 812         new RetData(config, config.dataLayoutRetDataTag),</span>
<span class="new"> 813         new BranchData(config, config.dataLayoutBranchDataTag),</span>
<span class="new"> 814         new MultiBranchData(config, config.dataLayoutMultiBranchDataTag),</span>
<span class="new"> 815         new ArgInfoData(config, config.dataLayoutArgInfoDataTag),</span>
<span class="new"> 816         new UnknownProfileData(config, config.dataLayoutCallTypeDataTag),</span>
<span class="new"> 817         new VirtualCallTypeData(config, config.dataLayoutVirtualCallTypeDataTag),</span>
<span class="new"> 818         new UnknownProfileData(config, config.dataLayoutParametersTypeDataTag),</span>
<span class="new"> 819         new UnknownProfileData(config, config.dataLayoutSpeculativeTrapDataTag),</span>
<span class="new"> 820     };</span>
<span class="new"> 821 </span>
<span class="new"> 822     private static boolean checkAccessorTags() {</span>
<span class="new"> 823         int expectedTag = 0;</span>
<span class="new"> 824         for (HotSpotMethodDataAccessor accessor : PROFILE_DATA_ACCESSORS) {</span>
<span class="new"> 825             if (expectedTag ==0 ) {</span>
<span class="new"> 826                 assert accessor == null;</span>
<span class="new"> 827             } else {</span>
<span class="new"> 828                 assert accessor.tag == expectedTag: expectedTag + " != " + accessor.tag + " " + accessor;</span>
<span class="new"> 829             }</span>
<span class="new"> 830             expectedTag++;</span>
<span class="new"> 831         }</span>
<span class="new"> 832         return true;</span>
<span class="new"> 833     }</span>
<span class="new"> 834 </span>
<span class="new"> 835     static {</span>
<span class="new"> 836         assert checkAccessorTags();</span>
<span class="new"> 837     }</span>
<span class="new"> 838     // @formatter:on</span>
 839 }
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotReferenceMap.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
