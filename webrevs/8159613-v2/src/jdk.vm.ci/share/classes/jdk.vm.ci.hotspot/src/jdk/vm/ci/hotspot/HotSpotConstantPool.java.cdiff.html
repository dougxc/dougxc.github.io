<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Cdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotConstantPool.java</title>
</head>
<body id="SUNWwebrev">
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotCompiledCode.java.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotForeignCallTarget.java.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotConstantPool.java</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre></pre>
        <pre>
<hr /><span class="oldmarker">*** 298,363 ****</span>
       * @param index constant pool index
       * @return constant pool entry
       */
      private long getEntryAt(int index) {
          assertBounds(index);
<span class="changed">!         return UNSAFE.getAddress(getMetaspaceConstantPool() + config().constantPoolSize + index * runtime().getHostJVMCIBackend().getTarget().wordSize);</span>
      }
  
      /**
       * Gets the integer constant pool entry at index {@code index}.
       *
       * @param index constant pool index
       * @return integer constant pool entry at index
       */
      private int getIntAt(int index) {
          assertTag(index, JVM_CONSTANT.Integer);
<span class="changed">!         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + index * runtime().getHostJVMCIBackend().getTarget().wordSize);</span>
      }
  
      /**
       * Gets the long constant pool entry at index {@code index}.
       *
       * @param index constant pool index
       * @return long constant pool entry
       */
      private long getLongAt(int index) {
          assertTag(index, JVM_CONSTANT.Long);
<span class="changed">!         return UNSAFE.getLong(getMetaspaceConstantPool() + config().constantPoolSize + index * runtime().getHostJVMCIBackend().getTarget().wordSize);</span>
      }
  
      /**
       * Gets the float constant pool entry at index {@code index}.
       *
       * @param index constant pool index
       * @return float constant pool entry
       */
      private float getFloatAt(int index) {
          assertTag(index, JVM_CONSTANT.Float);
<span class="changed">!         return UNSAFE.getFloat(getMetaspaceConstantPool() + config().constantPoolSize + index * runtime().getHostJVMCIBackend().getTarget().wordSize);</span>
      }
  
      /**
       * Gets the double constant pool entry at index {@code index}.
       *
       * @param index constant pool index
       * @return float constant pool entry
       */
      private double getDoubleAt(int index) {
          assertTag(index, JVM_CONSTANT.Double);
<span class="changed">!         return UNSAFE.getDouble(getMetaspaceConstantPool() + config().constantPoolSize + index * runtime().getHostJVMCIBackend().getTarget().wordSize);</span>
      }
  
      /**
       * Gets the {@code JVM_CONSTANT_NameAndType} constant pool entry at index {@code index}.
       *
       * @param index constant pool index
       * @return {@code JVM_CONSTANT_NameAndType} constant pool entry
       */
      private int getNameAndTypeAt(int index) {
          assertTag(index, JVM_CONSTANT.NameAndType);
<span class="changed">!         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + index * runtime().getHostJVMCIBackend().getTarget().wordSize);</span>
      }
  
      /**
       * Gets the {@code JVM_CONSTANT_NameAndType} reference index constant pool entry at index
       * {@code index}.
<span class="newmarker">--- 298,369 ----</span>
       * @param index constant pool index
       * @return constant pool entry
       */
      private long getEntryAt(int index) {
          assertBounds(index);
<span class="changed">!         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;</span>
<span class="changed">!         return UNSAFE.getAddress(getMetaspaceConstantPool() + config().constantPoolSize + offset);</span>
      }
  
      /**
       * Gets the integer constant pool entry at index {@code index}.
       *
       * @param index constant pool index
       * @return integer constant pool entry at index
       */
      private int getIntAt(int index) {
          assertTag(index, JVM_CONSTANT.Integer);
<span class="changed">!         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;</span>
<span class="changed">!         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);</span>
      }
  
      /**
       * Gets the long constant pool entry at index {@code index}.
       *
       * @param index constant pool index
       * @return long constant pool entry
       */
      private long getLongAt(int index) {
          assertTag(index, JVM_CONSTANT.Long);
<span class="changed">!         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;</span>
<span class="changed">!         return UNSAFE.getLong(getMetaspaceConstantPool() + config().constantPoolSize + offset);</span>
      }
  
      /**
       * Gets the float constant pool entry at index {@code index}.
       *
       * @param index constant pool index
       * @return float constant pool entry
       */
      private float getFloatAt(int index) {
          assertTag(index, JVM_CONSTANT.Float);
<span class="changed">!         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;</span>
<span class="changed">!         return UNSAFE.getFloat(getMetaspaceConstantPool() + config().constantPoolSize + offset);</span>
      }
  
      /**
       * Gets the double constant pool entry at index {@code index}.
       *
       * @param index constant pool index
       * @return float constant pool entry
       */
      private double getDoubleAt(int index) {
          assertTag(index, JVM_CONSTANT.Double);
<span class="changed">!         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;</span>
<span class="changed">!         return UNSAFE.getDouble(getMetaspaceConstantPool() + config().constantPoolSize + offset);</span>
      }
  
      /**
       * Gets the {@code JVM_CONSTANT_NameAndType} constant pool entry at index {@code index}.
       *
       * @param index constant pool index
       * @return {@code JVM_CONSTANT_NameAndType} constant pool entry
       */
      private int getNameAndTypeAt(int index) {
          assertTag(index, JVM_CONSTANT.NameAndType);
<span class="changed">!         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;</span>
<span class="changed">!         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);</span>
      }
  
      /**
       * Gets the {@code JVM_CONSTANT_NameAndType} reference index constant pool entry at index
       * {@code index}.
<hr /><span class="oldmarker">*** 434,444 ****</span>
       * @param index constant pool index
       * @return klass reference index
       */
      private int getUncachedKlassRefIndexAt(int index) {
          assertTagIsFieldOrMethod(index);
<span class="changed">!         final int refIndex = UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + index * runtime().getHostJVMCIBackend().getTarget().wordSize);</span>
          // klass ref index is in the low 16-bits.
          return refIndex &amp; 0xFFFF;
      }
  
      /**
<span class="newmarker">--- 440,451 ----</span>
       * @param index constant pool index
       * @return klass reference index
       */
      private int getUncachedKlassRefIndexAt(int index) {
          assertTagIsFieldOrMethod(index);
<span class="changed">!         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;</span>
<span class="changed">!         final int refIndex = UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);</span>
          // klass ref index is in the low 16-bits.
          return refIndex &amp; 0xFFFF;
      }
  
      /**
<hr /><span class="oldmarker">*** 680,698 ****</span>
                  final HotSpotResolvedObjectTypeImpl type = compilerToVM().resolveTypeInPool(this, index);
                  Class&lt;?&gt; klass = type.mirror();
                  if (!klass.isPrimitive() &amp;&amp; !klass.isArray()) {
                      UNSAFE.ensureClassInitialized(klass);
                  }
<span class="changed">!                 switch (tag) {</span>
<span class="changed">!                     case MethodRef:</span>
                          if (Bytecodes.isInvokeHandleAlias(opcode)) {
                              final int methodRefCacheIndex = rawIndexToConstantPoolIndex(cpi, opcode);
                              if (isInvokeHandle(methodRefCacheIndex, type)) {
                                  compilerToVM().resolveInvokeHandleInPool(this, methodRefCacheIndex);
                              }
                          }
                  }
                  break;
              case InvokeDynamic:
                  if (isInvokedynamicIndex(cpi)) {
                      compilerToVM().resolveInvokeDynamicInPool(this, cpi);
                  }
<span class="newmarker">--- 687,705 ----</span>
                  final HotSpotResolvedObjectTypeImpl type = compilerToVM().resolveTypeInPool(this, index);
                  Class&lt;?&gt; klass = type.mirror();
                  if (!klass.isPrimitive() &amp;&amp; !klass.isArray()) {
                      UNSAFE.ensureClassInitialized(klass);
                  }
<span class="changed">!                 if (tag == JVM_CONSTANT.MethodRef) {</span>
                      if (Bytecodes.isInvokeHandleAlias(opcode)) {
                          final int methodRefCacheIndex = rawIndexToConstantPoolIndex(cpi, opcode);
                          if (isInvokeHandle(methodRefCacheIndex, type)) {
                              compilerToVM().resolveInvokeHandleInPool(this, methodRefCacheIndex);
                          }
                      }
                  }
<span class="new">+ </span>
                  break;
              case InvokeDynamic:
                  if (isInvokedynamicIndex(cpi)) {
                      compilerToVM().resolveInvokeDynamicInPool(this, cpi);
                  }
</pre>
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotCompiledCode.java.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotForeignCallTarget.java.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

