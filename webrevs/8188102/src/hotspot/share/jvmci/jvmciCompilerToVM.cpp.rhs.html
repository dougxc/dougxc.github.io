<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "code/codeCache.hpp"
  27 #include "code/scopeDesc.hpp"
  28 #include "interpreter/linkResolver.hpp"
  29 #include "memory/oopFactory.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "oops/generateOopMap.hpp"
  32 #include "oops/fieldStreams.hpp"
  33 #include "oops/oop.inline.hpp"
  34 #include "oops/objArrayOop.inline.hpp"
  35 #include "runtime/fieldDescriptor.hpp"
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"
  56 #include "utilities/resourceHash.hpp"
  57 
  58 
  59 void JNIHandleMark::push_jni_handle_block() {
  60   JavaThread* thread = JavaThread::current();
  61   if (thread != NULL) {
  62     // Allocate a new block for JNI handles.
  63     // Inlined code from jni_PushLocalFrame()
  64     JNIHandleBlock* java_handles = ((JavaThread*)thread)-&gt;active_handles();
  65     JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
  66     assert(compile_handles != NULL &amp;&amp; java_handles != NULL, "should not be NULL");
  67     compile_handles-&gt;set_pop_frame_link(java_handles);
  68     thread-&gt;set_active_handles(compile_handles);
  69   }
  70 }
  71 
  72 void JNIHandleMark::pop_jni_handle_block() {
  73   JavaThread* thread = JavaThread::current();
  74   if (thread != NULL) {
  75     // Release our JNI handle block
  76     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  77     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  78     thread-&gt;set_active_handles(java_handles);
  79     compile_handles-&gt;set_pop_frame_link(NULL);
  80     JNIHandleBlock::release_block(compile_handles, thread); // may block
  81   }
  82 }
  83 
  84 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  85 #define C2V_VMENTRY(result_type, name, signature) \
  86   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  87   TRACE_jvmci_1("CompilerToVM::" #name); \
  88   TRACE_CALL(result_type, jvmci_ ## name signature) \
  89   JVMCI_VM_ENTRY_MARK; \
  90 
  91 #define C2V_END }
  92 
  93 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  94   if (method() != NULL) {
  95     JavaValue result(T_OBJECT);
  96     JavaCallArguments args;
  97     args.push_long((jlong) (address) method());
  98     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  99 
 100     return (oop)result.get_jobject();
 101   }
 102   return NULL;
 103 }
 104 
 105 oop CompilerToVM::get_jvmci_type(Klass* klass, TRAPS) {
 106   if (klass != NULL) {
 107     JavaValue result(T_OBJECT);
 108     JavaCallArguments args;
 109     args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
 110     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 111 
 112     return (oop)result.get_jobject();
 113   }
 114   return NULL;
 115 }
 116 
 117 
 118 int CompilerToVM::Data::Klass_vtable_start_offset;
 119 int CompilerToVM::Data::Klass_vtable_length_offset;
 120 
 121 int CompilerToVM::Data::Method_extra_stack_entries;
 122 
 123 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
 124 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
 125 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
 126 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 127 
 128 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 129 
 130 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 131 int CompilerToVM::Data::Universe_base_vtable_size;
 132 address CompilerToVM::Data::Universe_narrow_oop_base;
 133 int CompilerToVM::Data::Universe_narrow_oop_shift;
 134 address CompilerToVM::Data::Universe_narrow_klass_base;
 135 int CompilerToVM::Data::Universe_narrow_klass_shift;
 136 void* CompilerToVM::Data::Universe_non_oop_bits;
 137 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 138 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 139 
 140 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 141 HeapWord** CompilerToVM::Data::_heap_end_addr;
 142 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
 143 int CompilerToVM::Data::_max_oop_map_stack_offset;
 144 
 145 jbyte* CompilerToVM::Data::cardtable_start_address;
 146 int CompilerToVM::Data::cardtable_shift;
 147 
 148 int CompilerToVM::Data::vm_page_size;
 149 
 150 int CompilerToVM::Data::sizeof_vtableEntry = sizeof(vtableEntry);
 151 int CompilerToVM::Data::sizeof_ExceptionTableElement = sizeof(ExceptionTableElement);
 152 int CompilerToVM::Data::sizeof_LocalVariableTableElement = sizeof(LocalVariableTableElement);
 153 int CompilerToVM::Data::sizeof_ConstantPool = sizeof(ConstantPool);
 154 int CompilerToVM::Data::sizeof_SymbolPointer = sizeof(Symbol*);
 155 int CompilerToVM::Data::sizeof_narrowKlass = sizeof(narrowKlass);
 156 int CompilerToVM::Data::sizeof_arrayOopDesc = sizeof(arrayOopDesc);
 157 int CompilerToVM::Data::sizeof_BasicLock = sizeof(BasicLock);
 158 
 159 address CompilerToVM::Data::dsin;
 160 address CompilerToVM::Data::dcos;
 161 address CompilerToVM::Data::dtan;
 162 address CompilerToVM::Data::dexp;
 163 address CompilerToVM::Data::dlog;
 164 address CompilerToVM::Data::dlog10;
 165 address CompilerToVM::Data::dpow;
 166 
 167 address CompilerToVM::Data::symbol_init;
 168 address CompilerToVM::Data::symbol_clinit;
 169 
 170 void CompilerToVM::Data::initialize(TRAPS) {
 171   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 172   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 173 
 174   Method_extra_stack_entries = Method::extra_stack_entries();
 175 
 176   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 177   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 178   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 179   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 180 
 181   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 182 
 183   Universe_collectedHeap = Universe::heap();
 184   Universe_base_vtable_size = Universe::base_vtable_size();
 185   Universe_narrow_oop_base = Universe::narrow_oop_base();
 186   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 187   Universe_narrow_klass_base = Universe::narrow_klass_base();
 188   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 189   Universe_non_oop_bits = Universe::non_oop_word();
 190   Universe_verify_oop_mask = Universe::verify_oop_mask();
 191   Universe_verify_oop_bits = Universe::verify_oop_bits();
 192 
 193   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 194   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 195   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
 196 
 197   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 198   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 199   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 200   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 201 
 202   symbol_init = (address) vmSymbols::object_initializer_name();
 203   symbol_clinit = (address) vmSymbols::class_initializer_name();
 204 
 205   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 206   if (bs-&gt;is_a(BarrierSet::CardTableModRef)) {
 207     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 208     assert(base != 0, "unexpected byte_map_base");
 209     cardtable_start_address = base;
 210     cardtable_shift = CardTableModRefBS::card_shift;
 211   } else {
 212     // No card mark barriers
 213     cardtable_start_address = 0;
 214     cardtable_shift = 0;
 215   }
 216 
 217   vm_page_size = os::vm_page_size();
 218 
 219 #define SET_TRIGFUNC(name)                                      \
 220   if (StubRoutines::name() != NULL) {                           \
 221     name = StubRoutines::name();                                \
 222   } else {                                                      \
 223     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 224   }
 225 
 226   SET_TRIGFUNC(dsin);
 227   SET_TRIGFUNC(dcos);
 228   SET_TRIGFUNC(dtan);
 229   SET_TRIGFUNC(dexp);
 230   SET_TRIGFUNC(dlog10);
 231   SET_TRIGFUNC(dlog);
 232   SET_TRIGFUNC(dpow);
 233 
 234 #undef SET_TRIGFUNC
 235 }
 236 
 237 objArrayHandle CompilerToVM::initialize_intrinsics(TRAPS) {
 238   objArrayHandle vmIntrinsics = oopFactory::new_objArray_handle(VMIntrinsicMethod::klass(), (vmIntrinsics::ID_LIMIT - 1), CHECK_(objArrayHandle()));
 239   int index = 0;
 240   // The intrinsics for a class are usually adjacent to each other.
 241   // When they are, the string for the class name can be reused.
 242   vmSymbols::SID kls_sid = vmSymbols::NO_SID;
 243   Handle kls_str;
 244 #define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)
 245 #define VM_SYMBOL_TO_STRING(s) \
 246   java_lang_String::create_from_symbol(vmSymbols::symbol_at(SID_ENUM(s)), CHECK_(objArrayHandle()))
 247 #define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \
 248     instanceHandle vmIntrinsicMethod = InstanceKlass::cast(VMIntrinsicMethod::klass())-&gt;allocate_instance_handle(CHECK_(objArrayHandle())); \
 249     if (kls_sid != SID_ENUM(kls)) {                                       \
 250       kls_str = VM_SYMBOL_TO_STRING(kls);                                 \
 251       kls_sid = SID_ENUM(kls);                                            \
 252     }                                                                     \
 253     Handle name_str = VM_SYMBOL_TO_STRING(name);                          \
 254     Handle sig_str = VM_SYMBOL_TO_STRING(sig);                            \
 255     VMIntrinsicMethod::set_declaringClass(vmIntrinsicMethod, kls_str());  \
 256     VMIntrinsicMethod::set_name(vmIntrinsicMethod, name_str());           \
 257     VMIntrinsicMethod::set_descriptor(vmIntrinsicMethod, sig_str());      \
 258     VMIntrinsicMethod::set_id(vmIntrinsicMethod, vmIntrinsics::id);       \
 259       vmIntrinsics-&gt;obj_at_put(index++, vmIntrinsicMethod());             \
 260   }
 261 
 262   VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
 263 #undef SID_ENUM
 264 #undef VM_SYMBOL_TO_STRING
 265 #undef VM_INTRINSIC_INFO
 266   assert(index == vmIntrinsics::ID_LIMIT - 1, "must be");
 267 
 268   return vmIntrinsics;
 269 }
 270 
 271 /**
 272  * The set of VM flags known to be used.
 273  */
 274 #define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_intx_flag, do_uintx_flag) \
 275   do_intx_flag(AllocateInstancePrefetchLines)                              \
 276   do_intx_flag(AllocatePrefetchDistance)                                   \
 277   do_intx_flag(AllocatePrefetchInstr)                                      \
 278   do_intx_flag(AllocatePrefetchLines)                                      \
 279   do_intx_flag(AllocatePrefetchStepSize)                                   \
 280   do_intx_flag(AllocatePrefetchStyle)                                      \
 281   do_intx_flag(BciProfileWidth)                                            \
 282   do_bool_flag(BootstrapJVMCI)                                             \
 283   do_bool_flag(CITime)                                                     \
 284   do_bool_flag(CITimeEach)                                                 \
 285   do_uintx_flag(CodeCacheSegmentSize)                                      \
 286   do_intx_flag(CodeEntryAlignment)                                         \
 287   do_bool_flag(CompactFields)                                              \
 288   NOT_PRODUCT(do_intx_flag(CompileTheWorldStartAt))                        \
 289   NOT_PRODUCT(do_intx_flag(CompileTheWorldStopAt))                         \
 290   do_intx_flag(ContendedPaddingWidth)                                      \
 291   do_bool_flag(DontCompileHugeMethods)                                     \
 292   do_bool_flag(EnableContended)                                            \
 293   do_intx_flag(FieldsAllocationStyle)                                      \
 294   do_bool_flag(FoldStableValues)                                           \
 295   do_bool_flag(ForceUnreachable)                                           \
 296   do_intx_flag(HugeMethodLimit)                                            \
 297   do_bool_flag(Inline)                                                     \
 298   do_intx_flag(JVMCICounterSize)                                           \
 299   do_bool_flag(JVMCIPrintProperties)                                       \
 300   do_bool_flag(JVMCIUseFastLocking)                                        \
 301   do_intx_flag(MethodProfileWidth)                                         \
 302   do_intx_flag(ObjectAlignmentInBytes)                                     \
 303   do_bool_flag(PrintInlining)                                              \
 304   do_bool_flag(ReduceInitialCardMarks)                                     \
 305   do_bool_flag(RestrictContended)                                          \
 306   do_intx_flag(StackReservedPages)                                         \
 307   do_intx_flag(StackShadowPages)                                           \
 308   do_bool_flag(TLABStats)                                                  \
 309   do_uintx_flag(TLABWasteIncrement)                                        \
 310   do_intx_flag(TypeProfileWidth)                                           \
 311   do_bool_flag(UseAESIntrinsics)                                           \
 312   X86_ONLY(do_intx_flag(UseAVX))                                           \
 313   do_bool_flag(UseBiasedLocking)                                           \
 314   do_bool_flag(UseCRC32Intrinsics)                                         \
 315   do_bool_flag(UseCompressedClassPointers)                                 \
 316   do_bool_flag(UseCompressedOops)                                          \
 317   do_bool_flag(UseConcMarkSweepGC)                                         \
 318   X86_ONLY(do_bool_flag(UseCountLeadingZerosInstruction))                  \
 319   X86_ONLY(do_bool_flag(UseCountTrailingZerosInstruction))                 \
 320   do_bool_flag(UseG1GC)                                                    \
 321   COMPILER2_PRESENT(do_bool_flag(UseMontgomeryMultiplyIntrinsic))          \
 322   COMPILER2_PRESENT(do_bool_flag(UseMontgomerySquareIntrinsic))            \
 323   COMPILER2_PRESENT(do_bool_flag(UseMulAddIntrinsic))                      \
 324   COMPILER2_PRESENT(do_bool_flag(UseMultiplyToLenIntrinsic))               \
 325   do_bool_flag(UsePopCountInstruction)                                     \
 326   do_bool_flag(UseSHA1Intrinsics)                                          \
 327   do_bool_flag(UseSHA256Intrinsics)                                        \
 328   do_bool_flag(UseSHA512Intrinsics)                                        \
 329   do_intx_flag(UseSSE)                                                     \
 330   COMPILER2_PRESENT(do_bool_flag(UseSquareToLenIntrinsic))                 \
 331   do_bool_flag(UseStackBanging)                                            \
 332   do_bool_flag(UseTLAB)                                                    \
 333   do_bool_flag(VerifyOops)                                                 \
 334 
 335 #define BOXED_BOOLEAN(name, value) oop name = ((jboolean)(value) ? boxedTrue() : boxedFalse())
 336 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)
 337 #define BOXED_LONG(name, value) \
 338   oop name; \
 339   do { \
 340     jvalue p; p.j = (jlong) (value); \
 341     Handle* e = longs.get(p.j); \
 342     if (e == NULL) { \
 343       oop o = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); \
 344       Handle h(THREAD, o); \
 345       longs.put(p.j, h); \
 346       name = h(); \
 347     } else { \
 348       name = (*e)(); \
 349     } \
 350   } while (0)
 351 
 352 #define CSTRING_TO_JSTRING(name, value) \
 353   Handle name; \
 354   do { \
 355     if (value != NULL) { \
 356       Handle* e = strings.get(value); \
 357       if (e == NULL) { \
 358         Handle h = java_lang_String::create_from_str(value, CHECK_NULL); \
 359         strings.put(value, h); \
 360         name = h; \
 361       } else { \
 362         name = (*e); \
 363       } \
 364     } \
 365   } while (0)
 366 
 367 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))
 368   ResourceMark rm;
 369   HandleMark hm;
 370 
 371   // Used to canonicalize Long and String values.
 372   ResourceHashtable&lt;jlong, Handle&gt; longs;
 373   ResourceHashtable&lt;const char*, Handle, &amp;CompilerToVM::cstring_hash, &amp;CompilerToVM::cstring_equals&gt; strings;
 374 
 375   jvalue prim;
 376   prim.z = true;  oop boxedTrueOop =  java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 377   Handle boxedTrue(THREAD, boxedTrueOop);
 378   prim.z = false; oop boxedFalseOop = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 379   Handle boxedFalse(THREAD, boxedFalseOop);
 380 
 381   CompilerToVM::Data::initialize(CHECK_NULL);
 382 
 383   VMField::klass()-&gt;initialize(CHECK_NULL);
 384   VMFlag::klass()-&gt;initialize(CHECK_NULL);
 385   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);
 386 
 387   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
 388   objArrayHandle vmFields = oopFactory::new_objArray_handle(VMField::klass(), len, CHECK_NULL);
 389   for (int i = 0; i &lt; len ; i++) {
 390     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
 391     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 392     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* "::" */;
 393     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
 394     sprintf(name_buf, "%s::%s", vmField.typeName, vmField.fieldName);
 395     CSTRING_TO_JSTRING(name, name_buf);
 396     CSTRING_TO_JSTRING(type, vmField.typeString);
 397     VMField::set_name(vmFieldObj, name());
 398     VMField::set_type(vmFieldObj, type());
 399     VMField::set_offset(vmFieldObj, vmField.offset);
 400     VMField::set_address(vmFieldObj, (jlong) vmField.address);
 401     if (vmField.isStatic &amp;&amp; vmField.typeString != NULL) {
 402       if (strcmp(vmField.typeString, "bool") == 0) {
 403         BOXED_BOOLEAN(box, *(jbyte*) vmField.address);
 404         VMField::set_value(vmFieldObj, box);
 405       } else if (strcmp(vmField.typeString, "int") == 0 ||
 406                  strcmp(vmField.typeString, "jint") == 0) {
 407         BOXED_LONG(box, *(jint*) vmField.address);
 408         VMField::set_value(vmFieldObj, box);
 409       } else if (strcmp(vmField.typeString, "uint64_t") == 0) {
 410         BOXED_LONG(box, *(uint64_t*) vmField.address);
 411         VMField::set_value(vmFieldObj, box);
 412       } else if (strcmp(vmField.typeString, "address") == 0 ||
 413                  strcmp(vmField.typeString, "intptr_t") == 0 ||
 414                  strcmp(vmField.typeString, "uintptr_t") == 0 ||
 415                  strcmp(vmField.typeString, "OopHandle") == 0 ||
 416                  strcmp(vmField.typeString, "size_t") == 0 ||
 417                  // All foo* types are addresses.
 418                  vmField.typeString[strlen(vmField.typeString) - 1] == '*') {
 419         BOXED_LONG(box, *((address*) vmField.address));
 420         VMField::set_value(vmFieldObj, box);
 421       } else {
 422         JVMCI_ERROR_NULL("VM field %s has unsupported type %s", name_buf, vmField.typeString);
 423       }
 424     }
 425     vmFields-&gt;obj_at_put(i, vmFieldObj());
 426   }
 427 
 428   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
 429   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
 430   len = ints_len + longs_len;
 431   objArrayHandle vmConstants = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 432   int insert = 0;
 433   for (int i = 0; i &lt; ints_len ; i++) {
 434     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
 435     CSTRING_TO_JSTRING(name, c.name);
 436     BOXED_LONG(value, c.value);
 437     vmConstants-&gt;obj_at_put(insert++, name());
 438     vmConstants-&gt;obj_at_put(insert++, value);
 439   }
 440   for (int i = 0; i &lt; longs_len ; i++) {
 441     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
 442     CSTRING_TO_JSTRING(name, c.name);
 443     BOXED_LONG(value, c.value);
 444     vmConstants-&gt;obj_at_put(insert++, name());
 445     vmConstants-&gt;obj_at_put(insert++, value);
 446   }
 447   assert(insert == len * 2, "must be");
 448 
 449   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
 450   objArrayHandle vmAddresses = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 451   for (int i = 0; i &lt; len ; i++) {
 452     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
 453     CSTRING_TO_JSTRING(name, a.name);
 454     BOXED_LONG(value, a.value);
 455     vmAddresses-&gt;obj_at_put(i * 2, name());
 456     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);
 457   }
 458 
 459 #define COUNT_FLAG(ignore) +1
 460 #ifdef ASSERT
 461 #define CHECK_FLAG(type, name) { \
 462   Flag* flag = Flag::find_flag(#name, strlen(#name), /*allow_locked*/ true, /* return_flag */ true); \
 463   assert(flag != NULL, "No such flag named " #name); \
 464   assert(flag-&gt;is_##type(), "Flag " #name " is not of type " #type); \
 465 }
 466 #else
 467 #define CHECK_FLAG(type, name)
 468 #endif
 469 
 470 #define ADD_FLAG(type, name, convert) { \
 471   CHECK_FLAG(type, name) \
 472   instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL); \
 473   CSTRING_TO_JSTRING(fname, #name); \
 474   CSTRING_TO_JSTRING(ftype, #type); \
 475   VMFlag::set_name(vmFlagObj, fname()); \
 476   VMFlag::set_type(vmFlagObj, ftype()); \
 477   convert(value, name); \
 478   VMFlag::set_value(vmFlagObj, value); \
 479   vmFlags-&gt;obj_at_put(i++, vmFlagObj()); \
 480 }
 481 #define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)
 482 #define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)
 483 #define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)
 484 
 485   len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);
 486   objArrayHandle vmFlags = oopFactory::new_objArray_handle(VMFlag::klass(), len, CHECK_NULL);
 487   int i = 0;
 488   PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)
 489 
 490   objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);
 491 
 492   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 5, CHECK_NULL);
 493   data-&gt;obj_at_put(0, vmFields());
 494   data-&gt;obj_at_put(1, vmConstants());
 495   data-&gt;obj_at_put(2, vmAddresses());
 496   data-&gt;obj_at_put(3, vmFlags());
 497   data-&gt;obj_at_put(4, vmIntrinsics());
 498 
 499   return (jobjectArray) JNIHandles::make_local(THREAD, data);
 500 #undef COUNT_FLAG
 501 #undef ADD_FLAG
 502 #undef ADD_BOOL_FLAG
 503 #undef ADD_INTX_FLAG
 504 #undef ADD_UINTX_FLAG
 505 #undef CHECK_FLAG
 506 C2V_END
 507 
 508 C2V_VMENTRY(jobject, getFlagValue, (JNIEnv *, jobject c2vm, jobject name_handle))
 509 #define RETURN_BOXED_LONG(value) oop box; jvalue p; p.j = (jlong) (value); box = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);
 510 #define RETURN_BOXED_DOUBLE(value) oop box; jvalue p; p.d = (jdouble) (value); box = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);
 511   Handle name(THREAD, JNIHandles::resolve(name_handle));
 512   if (name.is_null()) {
 513     THROW_0(vmSymbols::java_lang_NullPointerException());
 514   }
 515   ResourceMark rm;
 516   const char* cstring = java_lang_String::as_utf8_string(name());
 517   Flag* flag = Flag::find_flag(cstring, strlen(cstring), /* allow_locked */ true, /* return_flag */ true);
 518   if (flag == NULL) {
 519     return c2vm;
 520   }
 521   if (flag-&gt;is_bool()) {
 522     jvalue prim;
 523     prim.z = flag-&gt;get_bool();
 524     oop box = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 525     return JNIHandles::make_local(THREAD, box);
 526   } else if (flag-&gt;is_ccstr()) {
 527     Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
 528     return JNIHandles::make_local(THREAD, value());
 529   } else if (flag-&gt;is_intx()) {
 530     RETURN_BOXED_LONG(flag-&gt;get_intx());
 531   } else if (flag-&gt;is_int()) {
 532     RETURN_BOXED_LONG(flag-&gt;get_int());
 533   } else if (flag-&gt;is_uint()) {
 534     RETURN_BOXED_LONG(flag-&gt;get_uint());
 535   } else if (flag-&gt;is_uint64_t()) {
 536     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());
 537   } else if (flag-&gt;is_size_t()) {
 538     RETURN_BOXED_LONG(flag-&gt;get_size_t());
 539   } else if (flag-&gt;is_uintx()) {
 540     RETURN_BOXED_LONG(flag-&gt;get_uintx());
 541   } else if (flag-&gt;is_double()) {
 542     RETURN_BOXED_DOUBLE(flag-&gt;get_double());
 543   } else {
 544     JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
 545   }
 546 C2V_END
 547 
 548 #undef BOXED_LONG
 549 #undef BOXED_DOUBLE
 550 #undef CSTRING_TO_JSTRING
 551 
 552 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 553   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 554   ResourceMark rm;
 555 
 556   int code_size = method-&gt;code_size();
 557   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 558 
 559   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 560   // iterate over all bytecodes and replace non-Java bytecodes
 561 
 562   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 563     Bytecodes::Code code = s.code();
 564     Bytecodes::Code raw_code = s.raw_code();
 565     int bci = s.bci();
 566     int len = s.instruction_size();
 567 
 568     // Restore original byte code.
 569     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 570     if (len &gt; 1) {
 571       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);
 572     }
 573 
 574     if (len &gt; 1) {
 575       // Restore the big-endian constant pool indexes.
 576       // Cf. Rewriter::scan_method
 577       switch (code) {
 578         case Bytecodes::_getstatic:
 579         case Bytecodes::_putstatic:
 580         case Bytecodes::_getfield:
 581         case Bytecodes::_putfield:
 582         case Bytecodes::_invokevirtual:
 583         case Bytecodes::_invokespecial:
 584         case Bytecodes::_invokestatic:
 585         case Bytecodes::_invokeinterface:
 586         case Bytecodes::_invokehandle: {
 587           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 588           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 589           break;
 590         }
 591 
 592         case Bytecodes::_invokedynamic: {
 593           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 594           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);
 595           break;
 596         }
 597 
 598         default:
 599           break;
 600       }
 601 
 602       // Not all ldc byte code are rewritten.
 603       switch (raw_code) {
 604         case Bytecodes::_fast_aldc: {
 605           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;
 606           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 607           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 608           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);
 609           break;
 610         }
 611 
 612         case Bytecodes::_fast_aldc_w: {
 613           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 614           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 615           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 616           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 617           break;
 618         }
 619 
 620         default:
 621           break;
 622       }
 623     }
 624   }
 625 
 626   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);
 627 C2V_END
 628 
 629 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 630   ResourceMark rm;
 631   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 632   return method-&gt;exception_table_length();
 633 C2V_END
 634 
 635 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 636   ResourceMark rm;
 637   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 638   if (method-&gt;exception_table_length() == 0) {
 639     return 0L;
 640   }
 641   return (jlong) (address) method-&gt;exception_table_start();
 642 C2V_END
 643 
 644 C2V_VMENTRY(jobject, asResolvedJavaMethod, (JNIEnv *, jobject, jobject executable_handle))
 645   oop executable = JNIHandles::resolve(executable_handle);
 646   oop mirror = NULL;
 647   int slot = 0;
 648 
 649   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 650     mirror = java_lang_reflect_Constructor::clazz(executable);
 651     slot = java_lang_reflect_Constructor::slot(executable);
 652   } else {
 653     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), "wrong type");
 654     mirror = java_lang_reflect_Method::clazz(executable);
 655     slot = java_lang_reflect_Method::slot(executable);
 656   }
 657   Klass* holder = java_lang_Class::as_Klass(mirror);
 658   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 659   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 660   return JNIHandles::make_local(THREAD, result);
 661 }
 662 
 663 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))
 664   methodHandle method;
 665   oop base_object = JNIHandles::resolve(base);
 666   if (base_object == NULL) {
 667     method = *((Method**)(offset));
 668   } else if (base_object-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {
 669     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);
 670   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 671     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));
 672   } else {
 673     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 674                 err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 675   }
 676   assert (method.is_null() || method-&gt;is_method(), "invalid read");
 677   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 678   return JNIHandles::make_local(THREAD, result);
 679 }
 680 
 681 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject object_handle))
 682   constantPoolHandle cp;
 683   oop object = JNIHandles::resolve(object_handle);
 684   if (object == NULL) {
 685     THROW_0(vmSymbols::java_lang_NullPointerException());
 686   }
 687   if (object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 688     cp = CompilerToVM::asMethod(object)-&gt;constMethod()-&gt;constants();
 689   } else if (object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 690     cp = InstanceKlass::cast(CompilerToVM::asKlass(object))-&gt;constants();
 691   } else {
 692     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 693                 err_msg("Unexpected type: %s", object-&gt;klass()-&gt;external_name()));
 694   }
 695   assert(!cp.is_null(), "npe");
 696   JavaValue method_result(T_OBJECT);
 697   JavaCallArguments args;
 698   args.push_long((jlong) (address) cp());
 699   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 700   return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());
 701 }
 702 
 703 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))
 704   Klass* klass = NULL;
 705   oop base_object = JNIHandles::resolve(base);
 706   jlong base_address = 0;
 707   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 708     klass = base_object-&gt;klass();
 709   } else if (!compressed) {
 710     if (base_object != NULL) {
 711       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 712         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 713       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 714         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 715       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 716         base_address = (jlong) CompilerToVM::asKlass(base_object);
 717       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {
 718         base_address = (jlong) (address) base_object;
 719       } else {
 720         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 721                     err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 722       }
 723     }
 724     klass = *((Klass**) (intptr_t) (base_address + offset));
 725   } else {
 726     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 727                 err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 728   }
 729   assert (klass == NULL || klass-&gt;is_klass(), "invalid read");
 730   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 731   return JNIHandles::make_local(THREAD, result);
 732 }
 733 
 734 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 735   ResourceMark rm;
 736   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 737   Klass* holder = CompilerToVM::asKlass(jvmci_type);
 738   if (holder-&gt;is_interface()) {
 739     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", holder-&gt;external_name()));
 740   }
 741 
 742   methodHandle ucm;
 743   {
 744     MutexLocker locker(Compile_lock);
 745     ucm = Dependencies::find_unique_concrete_method(holder, method());
 746   }
 747   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);
 748   return JNIHandles::make_local(THREAD, result);
 749 C2V_END
 750 
 751 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))
 752   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 753   oop implementor = CompilerToVM::get_jvmci_type(klass-&gt;implementor(), CHECK_NULL);
 754   return JNIHandles::make_local(THREAD, implementor);
 755 C2V_END
 756 
 757 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))
 758   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 759   return method-&gt;is_ignored_by_security_stack_walk();
 760 C2V_END
 761 
 762 C2V_VMENTRY(jboolean, isCompilable,(JNIEnv *, jobject, jobject jvmci_method))
 763   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 764   return !method-&gt;is_not_compilable(CompLevel_full_optimization);
 765 C2V_END
 766 
 767 C2V_VMENTRY(jboolean, hasNeverInlineDirective,(JNIEnv *, jobject, jobject jvmci_method))
 768   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 769   return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 770 C2V_END
 771 
 772 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 773   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 774   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 775 C2V_END
 776 
 777 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 778   ResourceMark rm;
 779   Handle name(THREAD, JNIHandles::resolve(jname));
 780   Symbol* class_name = java_lang_String::as_symbol(name(), CHECK_0);
 781   if (java_lang_String::length(name()) &lt;= 1) {
 782     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Primitive type %s should be handled in Java code", class_name-&gt;as_C_string()));
 783   }
 784 
 785   Klass* resolved_klass = NULL;
 786   if (JNIHandles::resolve(accessing_class) == NULL) {
 787     THROW_0(vmSymbols::java_lang_NullPointerException());
 788   }
 789   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));
 790   Handle class_loader(THREAD, accessing_klass-&gt;class_loader());
 791   Handle protection_domain(THREAD, accessing_klass-&gt;protection_domain());
 792 
 793   if (resolve) {
 794     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 795   } else {
 796     if (class_name-&gt;byte_at(0) == 'L' &amp;&amp;
 797       class_name-&gt;byte_at(class_name-&gt;utf8_length()-1) == ';') {
 798       // This is a name from a signature.  Strip off the trimmings.
 799       // Call recursive to keep scope of strippedsym.
 800       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 801                                                           class_name-&gt;utf8_length()-2,
 802                                                           CHECK_0);
 803       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 804     } else if (FieldType::is_array(class_name)) {
 805       FieldArrayInfo fd;
 806       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 807       // of this call
 808       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 809       if (t == T_OBJECT) {
 810         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 811                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 812                                                             CHECK_0);
 813         // naked oop "k" is OK here -- we assign back into it
 814         resolved_klass = SystemDictionary::find(strippedsym,
 815                                                              class_loader,
 816                                                              protection_domain,
 817                                                              CHECK_0);
 818         if (resolved_klass != NULL) {
 819           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 820         }
 821       } else {
 822         resolved_klass = Universe::typeArrayKlassObj(t);
 823         resolved_klass = TypeArrayKlass::cast(resolved_klass)-&gt;array_klass(fd.dimension(), CHECK_0);
 824       }
 825     }
 826   }
 827   oop result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 828   return JNIHandles::make_local(THREAD, result);
 829 C2V_END
 830 
 831 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 832   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 833   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);
 834   return JNIHandles::make_local(THREAD, result);
 835 C2V_END
 836 
 837 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 838   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 839   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 840   return JNIHandles::make_local(THREAD, result);
 841 C2V_END
 842 
 843 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 844   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 845   return cp-&gt;name_and_type_ref_index_at(index);
 846 C2V_END
 847 
 848 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 849   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 850   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);
 851   return JNIHandles::make_local(THREAD, sym());
 852 C2V_END
 853 
 854 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 855   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 856   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);
 857   return JNIHandles::make_local(THREAD, sym());
 858 C2V_END
 859 
 860 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 861   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 862   return cp-&gt;klass_ref_index_at(index);
 863 C2V_END
 864 
 865 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 866   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 867   Klass* resolved_klass = cp-&gt;klass_at(index, CHECK_NULL);
 868   oop klass = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 869   return JNIHandles::make_local(THREAD, klass);
 870 C2V_END
 871 
 872 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 873   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 874   Klass* loading_klass = cp-&gt;pool_holder();
 875   bool is_accessible = false;
 876   Klass* klass = JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass);
 877   Symbol* symbol = NULL;
 878   if (klass == NULL) {
 879     symbol = cp-&gt;klass_name_at(index);
 880   }
 881   oop result_oop;
 882   if (klass != NULL) {
 883     result_oop = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 884   } else {
 885     Handle result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
 886     result_oop = result();
 887   }
 888   return JNIHandles::make_local(THREAD, result_oop);
 889 C2V_END
 890 
 891 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 892   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 893   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 894   return JNIHandles::make_local(THREAD, appendix_oop);
 895 C2V_END
 896 
 897 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 898   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 899   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 900   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 901   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 902   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 903   return JNIHandles::make_local(THREAD, result);
 904 C2V_END
 905 
 906 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 907   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 908   return cp-&gt;remap_instruction_operand_from_cache(index);
 909 C2V_END
 910 
 911 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))
 912   ResourceMark rm;
 913   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 914   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 915   fieldDescriptor fd;
 916   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
 917   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 918   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
 919   if (info == NULL || info-&gt;length() != 3) {
 920     JVMCI_ERROR_NULL("info must not be null and have a length of 3");
 921   }
 922   info-&gt;int_at_put(0, fd.access_flags().as_int());
 923   info-&gt;int_at_put(1, fd.offset());
 924   info-&gt;int_at_put(2, fd.index());
 925   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 926   return JNIHandles::make_local(THREAD, field_holder);
 927 C2V_END
 928 
 929 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 930   ResourceMark rm;
 931   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 932   Method* method = CompilerToVM::asMethod(jvmci_method);
 933   if (klass-&gt;is_interface()) {
 934     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 935   }
 936   if (!method-&gt;method_holder()-&gt;is_interface()) {
 937     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 938   }
 939   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 940     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 941   }
 942   return LinkResolver::vtable_index_of_interface_method(klass, method);
 943 C2V_END
 944 
 945 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 946   Klass* recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);
 947   Klass* caller_klass = CompilerToVM::asKlass(caller_jvmci_type);
 948   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 949 
 950   Klass* resolved     = method-&gt;method_holder();
 951   Symbol* h_name      = method-&gt;name();
 952   Symbol* h_signature = method-&gt;signature();
 953 
 954   if (MethodHandles::is_signature_polymorphic_method(method())) {
 955       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 956       return NULL;
 957   }
 958 
 959   LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
 960   methodHandle m;
 961   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 962   // the vtable has not been setup, and the LinkResolver will fail.
 963   if (recv_klass-&gt;is_array_klass() ||
 964       (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
 965     if (resolved-&gt;is_interface()) {
 966       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 967     } else {
 968       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 969     }
 970   }
 971 
 972   if (m.is_null()) {
 973     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 974     return NULL;
 975   }
 976 
 977   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);
 978   return JNIHandles::make_local(THREAD, result);
 979 C2V_END
 980 
 981 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))
 982   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 983   assert(klass != NULL, "method must not be called for primitive types");
 984   return Dependencies::find_finalizable_subclass(klass) != NULL;
 985 C2V_END
 986 
 987 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))
 988   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 989   oop result = CompilerToVM::get_jvmci_method(klass-&gt;class_initializer(), CHECK_NULL);
 990   return JNIHandles::make_local(THREAD, result);
 991 C2V_END
 992 
 993 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))
 994   address target_addr = (address) addr;
 995   if (target_addr != 0x0) {
 996     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 997     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 998     return MAX2(ABS(off_low), ABS(off_high));
 999   }
1000   return -1;
1001 C2V_END
1002 
1003 C2V_VMENTRY(void, setNotInlineableOrCompileable,(JNIEnv *, jobject,  jobject jvmci_method))
1004   methodHandle method = CompilerToVM::asMethod(jvmci_method);
1005   method-&gt;set_not_c1_compilable();
1006   method-&gt;set_not_c2_compilable();
1007   method-&gt;set_dont_inline(true);
1008 C2V_END
1009 
1010 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))
1011   ResourceMark rm;
1012   HandleMark hm;
1013   JNIHandleMark jni_hm;
1014 
1015   Handle target_handle(THREAD, JNIHandles::resolve(target));
1016   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));
1017   CodeBlob* cb = NULL;
1018   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));
1019   Handle speculation_log_handle(THREAD, JNIHandles::resolve(speculation_log));
1020 
1021   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK_JNI_ERR);
1022 
1023   TraceTime install_time("installCode", JVMCICompiler::codeInstallTimer());
1024   bool is_immutable_PIC = HotSpotCompiledCode::isImmutablePIC(compiled_code_handle) &gt; 0;
1025   CodeInstaller installer(is_immutable_PIC);
1026   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);
1027 
1028   if (PrintCodeCacheOnCompilation) {
1029     stringStream s;
1030     // Dump code cache  into a buffer before locking the tty,
1031     {
1032       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1033       CodeCache::print_summary(&amp;s, false);
1034     }
1035     ttyLocker ttyl;
1036     tty-&gt;print_raw_cr(s.as_string());
1037   }
1038 
1039   if (result != JVMCIEnv::ok) {
1040     assert(cb == NULL, "should be");
1041   } else {
<a name="1" id="anc1"></a><span class="changed">1042     if (installed_code_handle.not_null()) {</span>
1043       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), "wrong type");
1044       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);
1045       {
1046         // Ensure that all updates to the InstalledCode fields are consistent.
1047         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
1048         InstalledCode::set_address(installed_code_handle, (jlong) cb);
1049         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);
1050         if (cb-&gt;is_nmethod()) {
1051           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());
1052         } else {
1053           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());
1054         }
1055         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {
1056           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());
1057           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());
1058           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());
1059         }
1060       }
1061       nmethod* nm = cb-&gt;as_nmethod_or_null();
<a name="2" id="anc2"></a>





1062     }
1063   }
1064   return result;
1065 C2V_END
1066 
1067 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))
1068   ResourceMark rm;
1069   HandleMark hm;
1070 
1071   Handle target_handle(THREAD, JNIHandles::resolve(target));
1072   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));
1073   Handle metadata_handle(THREAD, JNIHandles::resolve(metadata));
1074 
1075   CodeMetadata code_metadata;
1076   CodeBlob *cb = NULL;
1077   CodeInstaller installer(true /* immutable PIC compilation */);
1078 
1079   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);
1080   if (result != JVMCIEnv::ok) {
1081     return result;
1082   }
1083 
1084   if (code_metadata.get_nr_pc_desc() &gt; 0) {
1085     typeArrayHandle pcArrayOop = oopFactory::new_byteArray_handle(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));
1086     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());
1087     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());
1088   }
1089 
1090   if (code_metadata.get_scopes_size() &gt; 0) {
1091     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray_handle(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));
1092     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());
1093     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());
1094   }
1095 
1096   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
1097   typeArrayHandle relocArrayOop = oopFactory::new_byteArray_handle((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));
1098   if (reloc_buffer-&gt;size() &gt; 0) {
1099     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());
1100   }
1101   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());
1102 
1103   const OopMapSet* oopMapSet = installer.oopMapSet();
1104   {
1105     ResourceMark mark;
1106     ImmutableOopMapBuilder builder(oopMapSet);
1107     int oopmap_size = builder.heap_size();
1108     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray_handle(oopmap_size, CHECK_(JVMCIEnv::cache_full));
1109     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));
1110     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());
1111   }
1112 
1113   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
1114 
1115   int nr_meta_refs = recorder-&gt;nr_meta_refs();
1116   objArrayOop metadataArray = oopFactory::new_objectArray(nr_meta_refs, CHECK_(JVMCIEnv::cache_full));
1117   objArrayHandle metadataArrayHandle(THREAD, metadataArray);
1118   for (int i = 0; i &lt; nr_meta_refs; ++i) {
1119     jobject element = recorder-&gt;meta_element(i);
1120     if (element == NULL) {
1121       return JVMCIEnv::cache_full;
1122     }
1123     metadataArrayHandle-&gt;obj_at_put(i, JNIHandles::resolve(element));
1124   }
1125   HotSpotMetaData::set_metadata(metadata_handle, metadataArrayHandle());
1126 
1127   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
1128   int table_size = handler-&gt;size_in_bytes();
1129   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray_handle(table_size, CHECK_(JVMCIEnv::cache_full));
1130 
1131   if (table_size &gt; 0) {
1132     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));
1133   }
1134   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());
1135 
1136   return result;
1137 C2V_END
1138 
1139 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))
1140   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK);
1141   CompilerStatistics* stats = compiler-&gt;stats();
1142   stats-&gt;_standard.reset();
1143   stats-&gt;_osr.reset();
1144 C2V_END
1145 
1146 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))
1147   ResourceMark rm;
1148   HandleMark hm;
1149 
1150   if (installedCode == NULL) {
1151     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), "installedCode is null");
1152   }
1153 
1154   jlong codeBlob = InstalledCode::address(installedCode);
1155   if (codeBlob == 0L) {
1156     return NULL;
1157   }
1158 
1159   CodeBlob* cb = (CodeBlob*) (address) codeBlob;
1160   if (cb == NULL) {
1161     return NULL;
1162   }
1163 
1164   // We don't want the stringStream buffer to resize during disassembly as it
1165   // uses scoped resource memory. If a nested function called during disassembly uses
1166   // a ResourceMark and the buffer expands within the scope of the mark,
1167   // the buffer becomes garbage when that scope is exited. Experience shows that
1168   // the disassembled code is typically about 10x the code size so a fixed buffer
1169   // sized to 20x code size plus a fixed amount for header info should be sufficient.
1170   int bufferSize = cb-&gt;code_size() * 20 + 1024;
1171   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
1172   stringStream st(buffer, bufferSize);
1173   if (cb-&gt;is_nmethod()) {
1174     nmethod* nm = (nmethod*) cb;
1175     if (!nm-&gt;is_alive()) {
1176       return NULL;
1177     }
1178   }
1179   Disassembler::decode(cb, &amp;st);
1180   if (st.size() &lt;= 0) {
1181     return NULL;
1182   }
1183 
1184   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);
1185   return JNIHandles::make_local(THREAD, result());
1186 C2V_END
1187 
1188 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))
1189   ResourceMark rm;
1190   HandleMark hm;
1191 
1192   methodHandle method = CompilerToVM::asMethod(jvmci_method);
1193   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);
1194   return JNIHandles::make_local(THREAD, element);
1195 C2V_END
1196 
1197 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))
1198   ResourceMark rm;
1199   HandleMark hm;
1200 
1201   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);
1202   if (nmethodValue == 0L) {
1203     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
1204   }
1205   nmethod* nm = (nmethod*) (address) nmethodValue;
1206   methodHandle mh = nm-&gt;method();
1207   Symbol* signature = mh-&gt;signature();
1208   JavaCallArguments jca(mh-&gt;size_of_parameters());
1209 
1210   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1211   JavaValue result(jap.get_ret_type());
1212   jca.set_alternative_target(nm);
1213   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1214 
1215   if (jap.get_ret_type() == T_VOID) {
1216     return NULL;
1217   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
1218     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
1219   } else {
1220     jvalue *value = (jvalue *) result.get_value_addr();
1221     // Narrow the value down if required (Important on big endian machines)
1222     switch (jap.get_ret_type()) {
1223       case T_BOOLEAN:
1224        value-&gt;z = (jboolean) value-&gt;i;
1225        break;
1226       case T_BYTE:
1227        value-&gt;b = (jbyte) value-&gt;i;
1228        break;
1229       case T_CHAR:
1230        value-&gt;c = (jchar) value-&gt;i;
1231        break;
1232       case T_SHORT:
1233        value-&gt;s = (jshort) value-&gt;i;
1234        break;
1235       default:
1236         break;
1237     }
1238     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);
1239     return JNIHandles::make_local(THREAD, o);
1240   }
1241 C2V_END
1242 
1243 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))
1244   Method* method = CompilerToVM::asMethod(jvmci_method);
1245   if (!method-&gt;has_linenumber_table()) {
1246     return NULL;
1247   }
1248   u2 num_entries = 0;
1249   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1250   while (streamForSize.read_pair()) {
1251     num_entries++;
1252   }
1253 
1254   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1255   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);
1256 
1257   int i = 0;
1258   jlong value;
1259   while (stream.read_pair()) {
1260     value = ((long) stream.bci());
1261     result-&gt;long_at_put(i, value);
1262     value = ((long) stream.line());
1263     result-&gt;long_at_put(i + 1, value);
1264     i += 2;
1265   }
1266 
1267   return (jlongArray) JNIHandles::make_local(THREAD, result);
1268 C2V_END
1269 
1270 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))
1271   ResourceMark rm;
1272   Method* method = CompilerToVM::asMethod(jvmci_method);
1273   if (!method-&gt;has_localvariable_table()) {
1274     return 0;
1275   }
1276   return (jlong) (address) method-&gt;localvariable_table_start();
1277 C2V_END
1278 
1279 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))
1280   ResourceMark rm;
1281   Method* method = CompilerToVM::asMethod(jvmci_method);
1282   return method-&gt;localvariable_table_length();
1283 C2V_END
1284 
1285 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))
1286   Method* method = CompilerToVM::asMethod(jvmci_method);
1287   MethodCounters* mcs = method-&gt;method_counters();
1288   if (mcs != NULL) {
1289     mcs-&gt;clear_counters();
1290   }
1291   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1292 
1293   CompiledMethod* code = method-&gt;code();
1294   if (code != NULL) {
1295     code-&gt;make_not_entrant();
1296   }
1297 
1298   MethodData* method_data = method-&gt;method_data();
1299   if (method_data == NULL) {
1300     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1301     method_data = MethodData::allocate(loader_data, method, CHECK);
1302     method-&gt;set_method_data(method_data);
1303   } else {
1304     method_data-&gt;initialize();
1305   }
1306 C2V_END
1307 
1308 
1309 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))
1310   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));
1311   nmethod::invalidate_installed_code(installed_code_handle, CHECK);
1312 C2V_END
1313 
1314 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))
1315   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);
1316   JavaThread::collect_counters(arrayOop);
1317   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);
1318 C2V_END
1319 
1320 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))
1321   HandleMark hm;
1322   ResourceMark rm;
1323   if (JNIHandles::resolve(jvmci_method) == NULL) {
1324     THROW_0(vmSymbols::java_lang_NullPointerException());
1325   }
1326   Method* method = CompilerToVM::asMethod(jvmci_method);
1327   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1328     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Unexpected bci %d", entry_bci));
1329   }
1330   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1331 C2V_END
1332 
1333 
1334 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))
1335   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1336   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1337 C2V_END
1338 
1339 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1340   Method* method = CompilerToVM::asMethod(jvmci_method);
1341   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1342 C2V_END
1343 
1344 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))
1345   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);
1346   return JNIHandles::make_local(THREAD, sym());
1347 C2V_END
1348 
1349 bool matches(jobjectArray methods, Method* method) {
1350   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1351 
1352   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1353     oop resolved = methods_oop-&gt;obj_at(i);
1354     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {
1355       return true;
1356     }
1357   }
1358   return false;
1359 }
1360 
1361 C2V_VMENTRY(jobject, getNextStackFrame, (JNIEnv*, jobject compilerToVM, jobject hs_frame, jobjectArray methods, jint initialSkip))
1362   ResourceMark rm;
1363 
1364   if (!thread-&gt;has_last_Java_frame()) return NULL;
1365   Handle result = HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1366   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1367 
1368   StackFrameStream fst(thread);
1369   if (hs_frame != NULL) {
1370     // look for the correct stack frame if one is given
1371     intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1372     while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1373       fst.next();
1374     }
1375     if (fst.current()-&gt;sp() != stack_pointer) {
1376       THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1377     }
1378   }
1379 
1380   int frame_number = 0;
1381   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1382   if (hs_frame != NULL) {
1383     // look for the correct vframe within the stack frame if one is given
1384     int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1385     while (frame_number &lt; last_frame_number) {
1386       if (vf-&gt;is_top()) {
1387         THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1388       }
1389       vf = vf-&gt;sender();
1390       frame_number ++;
1391     }
1392     // move one frame forward
1393     if (vf-&gt;is_top()) {
1394       if (fst.is_done()) {
1395         return NULL;
1396       }
1397       fst.next();
1398       vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1399       frame_number = 0;
1400     } else {
1401       vf = vf-&gt;sender();
1402       frame_number++;
1403     }
1404   }
1405 
1406   while (true) {
1407     // look for the given method
1408     while (true) {
1409       StackValueCollection* locals = NULL;
1410       if (vf-&gt;is_compiled_frame()) {
1411         // compiled method frame
1412         compiledVFrame* cvf = compiledVFrame::cast(vf);
1413         if (methods == NULL || matches(methods, cvf-&gt;method())) {
1414           if (initialSkip &gt; 0) {
1415             initialSkip --;
1416           } else {
1417             ScopeDesc* scope = cvf-&gt;scope();
1418             // native wrappers do not have a scope
1419             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1420               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), scope-&gt;objects(), CHECK_NULL);
1421               Deoptimization::reassign_fields(fst.current(), fst.register_map(), scope-&gt;objects(), realloc_failures, false);
1422 
1423               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1424               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1425               typeArrayHandle array(THREAD, array_oop);
1426               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1427                 ScopeValue* value = local_values-&gt;at(i);
1428                 if (value-&gt;is_object()) {
1429                   array-&gt;bool_at_put(i, true);
1430                 }
1431               }
1432               HotSpotStackFrameReference::set_localIsVirtual(result, array());
1433             } else {
1434               HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1435             }
1436 
1437             locals = cvf-&gt;locals();
1438             HotSpotStackFrameReference::set_bci(result, cvf-&gt;bci());
1439             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);
1440             HotSpotStackFrameReference::set_method(result, method);
1441           }
1442         }
1443       } else if (vf-&gt;is_interpreted_frame()) {
1444         // interpreted method frame
1445         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1446         if (methods == NULL || matches(methods, ivf-&gt;method())) {
1447           if (initialSkip &gt; 0) {
1448             initialSkip --;
1449           } else {
1450             locals = ivf-&gt;locals();
1451             HotSpotStackFrameReference::set_bci(result, ivf-&gt;bci());
1452             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);
1453             HotSpotStackFrameReference::set_method(result, method);
1454             HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1455           }
1456         }
1457       }
1458 
1459       // locals != NULL means that we found a matching frame and result is already partially initialized
1460       if (locals != NULL) {
1461         HotSpotStackFrameReference::set_compilerToVM(result, JNIHandles::resolve(compilerToVM));
1462         HotSpotStackFrameReference::set_stackPointer(result, (jlong) fst.current()-&gt;sp());
1463         HotSpotStackFrameReference::set_frameNumber(result, frame_number);
1464 
1465         // initialize the locals array
1466         objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
1467         objArrayHandle array(THREAD, array_oop);
1468         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1469           StackValue* var = locals-&gt;at(i);
1470           if (var-&gt;type() == T_OBJECT) {
1471             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1472           }
1473         }
1474         HotSpotStackFrameReference::set_locals(result, array());
1475 
1476         return JNIHandles::make_local(thread, result());
1477       }
1478 
1479       if (vf-&gt;is_top()) {
1480         break;
1481       }
1482       frame_number++;
1483       vf = vf-&gt;sender();
1484     } // end of vframe loop
1485 
1486     if (fst.is_done()) {
1487       break;
1488     }
1489     fst.next();
1490     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1491     frame_number = 0;
1492   } // end of frame loop
1493 
1494   // the end was reached without finding a matching method
1495   return NULL;
1496 C2V_END
1497 
1498 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1499   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1500   CallInfo callInfo;
1501   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1502   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1503   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1504 C2V_END
1505 
1506 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1507   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1508   Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
1509   Symbol* name = cp-&gt;name_ref_at(index);
1510   if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
1511     CallInfo callInfo;
1512     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1513     ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1514     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1515   }
1516 C2V_END
1517 
1518 C2V_VMENTRY(jint, isResolvedInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1519   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1520   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1521   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
1522     // MethodHandle.invoke* --&gt; LambdaForm?
1523     ResourceMark rm;
1524 
1525     LinkInfo link_info(cp, index, CATCH);
1526 
1527     Klass* resolved_klass = link_info.resolved_klass();
1528 
1529     Symbol* name_sym = cp-&gt;name_ref_at(index);
1530 
1531     vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), "!");
1532     vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), "!");
1533 
1534     methodHandle adapter_method(cp_cache_entry-&gt;f1_as_method());
1535 
1536     methodHandle resolved_method(adapter_method);
1537 
1538     // Can we treat it as a regular invokevirtual?
1539     if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
1540       vmassert(!resolved_method-&gt;is_static(),"!");
1541       vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),"!");
1542       vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), "!");
1543       vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, "!");
1544       vmassert(cp_cache_entry-&gt;method_type_if_resolved(cp) == NULL, "!");
1545 
1546       methodHandle m(LinkResolver::linktime_resolve_virtual_method_or_null(link_info));
1547       vmassert(m == resolved_method, "!!");
1548       return -1;
1549     }
1550 
1551     return Bytecodes::_invokevirtual;
1552   }
1553   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokedynamic)) {
1554     return Bytecodes::_invokedynamic;
1555   }
1556   return -1;
1557 C2V_END
1558 
1559 
1560 C2V_VMENTRY(jobject, getSignaturePolymorphicHolders, (JNIEnv*, jobject))
1561   objArrayHandle holders = oopFactory::new_objArray_handle(SystemDictionary::String_klass(), 2, CHECK_NULL);
1562   Handle mh = java_lang_String::create_from_str("Ljava/lang/invoke/MethodHandle;", CHECK_NULL);
1563   Handle vh = java_lang_String::create_from_str("Ljava/lang/invoke/VarHandle;", CHECK_NULL);
1564   holders-&gt;obj_at_put(0, mh());
1565   holders-&gt;obj_at_put(1, vh());
1566   return JNIHandles::make_local(THREAD, holders());
1567 C2V_END
1568 
1569 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))
1570   //see compute_recording_non_safepoints in debugInfroRec.cpp
1571   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1572     return true;
1573   }
1574   return DebugNonSafepoints;
1575 C2V_END
1576 
1577 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1578 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))
1579   ResourceMark rm;
1580 
1581   if (hs_frame == NULL) {
1582     THROW_MSG(vmSymbols::java_lang_NullPointerException(), "stack frame is null")
1583   }
1584 
1585   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK);
1586 
1587   // look for the given stack frame
1588   StackFrameStream fst(thread);
1589   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1590   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1591     fst.next();
1592   }
1593   if (fst.current()-&gt;sp() != stack_pointer) {
1594     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1595   }
1596 
1597   if (invalidate) {
1598     if (!fst.current()-&gt;is_compiled_frame()) {
1599       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1600     }
1601     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), "nmethod expected");
1602     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1603   }
1604   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1605   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1606   StackFrameStream fstAfterDeopt(thread);
1607   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1608     fstAfterDeopt.next();
1609   }
1610   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1611     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found after deopt")
1612   }
1613 
1614   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1615   if (!vf-&gt;is_compiled_frame()) {
1616     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1617   }
1618 
1619   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1620   while (true) {
1621     assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1622     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1623     if (vf-&gt;is_top()) {
1624       break;
1625     }
1626     vf = vf-&gt;sender();
1627   }
1628 
1629   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1630   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1631     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1632   }
1633 
1634   // Reallocate the non-escaping objects and restore their fields.
1635   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,"invalid scope");
1636   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1637 
1638   if (objects == NULL) {
1639     // no objects to materialize
1640     return;
1641   }
1642 
1643   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, CHECK);
1644   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1645 
1646   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1647     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1648 
1649     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1650     StackValueCollection* locals = cvf-&gt;locals();
1651 
1652     if (locals != NULL) {
1653       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1654         StackValue* var = locals-&gt;at(i2);
1655         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1656           jvalue val;
1657           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1658           cvf-&gt;update_local(T_OBJECT, i2, val);
1659         }
1660       }
1661     }
1662   }
1663 
1664   // all locals are materialized by now
1665   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);
1666 
1667   // update the locals array
1668   objArrayHandle array(THREAD, HotSpotStackFrameReference::locals(hs_frame));
1669   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1670   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1671     StackValue* var = locals-&gt;at(i);
1672     if (var-&gt;type() == T_OBJECT) {
1673       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1674     }
1675   }
1676 C2V_END
1677 
1678 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))
1679   if (bytes == NULL) {
1680     THROW(vmSymbols::java_lang_NullPointerException());
1681   }
1682   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);
1683 
1684   // Check if offset and length are non negative.
1685   if (offset &lt; 0 || length &lt; 0) {
1686     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1687   }
1688   // Check if the range is valid.
1689   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {
1690     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1691   }
1692   while (length &gt; 0) {
1693     jbyte* start = array-&gt;byte_at_addr(offset);
1694     tty-&gt;write((char*) start, MIN2(length, O_BUFLEN));
1695     length -= O_BUFLEN;
1696     offset += O_BUFLEN;
1697   }
1698 C2V_END
1699 
1700 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))
1701   tty-&gt;flush();
1702 C2V_END
1703 
1704 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))
1705   ResourceMark rm;
1706   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1707   ProfileData* profile_data = mdo-&gt;data_at(position);
1708   if (mdo-&gt;is_valid(profile_data)) {
1709     return profile_data-&gt;size_in_bytes();
1710   }
1711   DataLayout* data    = mdo-&gt;extra_data_base();
1712   DataLayout* end   = mdo-&gt;extra_data_limit();
1713   for (;; data = mdo-&gt;next_extra(data)) {
1714     assert(data &lt; end, "moved past end of extra data");
1715     profile_data = data-&gt;data_in();
1716     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1717       return profile_data-&gt;size_in_bytes();
1718     }
1719   }
1720   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Invalid profile data position %d", position));
1721 C2V_END
1722 
1723 C2V_VMENTRY(jlong, getFingerprint, (JNIEnv*, jobject, jlong metaspace_klass))
1724   Klass *k = CompilerToVM::asKlass(metaspace_klass);
1725   if (k-&gt;is_instance_klass()) {
1726     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1727   } else {
1728     return 0;
1729   }
1730 C2V_END
1731 
1732 C2V_VMENTRY(jobject, getHostClass, (JNIEnv*, jobject, jobject jvmci_type))
1733   InstanceKlass* k = InstanceKlass::cast(CompilerToVM::asKlass(jvmci_type));
1734   InstanceKlass* host = k-&gt;host_klass();
1735   oop result = CompilerToVM::get_jvmci_type(host, CHECK_NULL);
1736   return JNIHandles::make_local(THREAD, result);
1737 C2V_END
1738 
1739 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))
1740   if (bytecode_frame_handle == NULL) {
1741     THROW_0(vmSymbols::java_lang_NullPointerException());
1742   }
1743 
1744   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);
1745   oop bytecode_frame = top_bytecode_frame;
1746   int size = 0;
1747   int callee_parameters = 0;
1748   int callee_locals = 0;
1749   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1750   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);
1751 
1752   while (bytecode_frame != NULL) {
1753     int locks = BytecodeFrame::numLocks(bytecode_frame);
1754     int temps = BytecodeFrame::numStack(bytecode_frame);
1755     bool is_top_frame = (bytecode_frame == top_bytecode_frame);
1756     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1757 
1758     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1759                                                                  temps + callee_parameters,
1760                                                                  extra_args,
1761                                                                  locks,
1762                                                                  callee_parameters,
1763                                                                  callee_locals,
1764                                                                  is_top_frame);
1765     size += frame_size;
1766 
1767     callee_parameters = method-&gt;size_of_parameters();
1768     callee_locals = method-&gt;max_locals();
1769     extra_args = 0;
1770     bytecode_frame = BytecodePosition::caller(bytecode_frame);
1771   }
1772   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1773 C2V_END
1774 
1775 C2V_VMENTRY(void, compileToBytecode, (JNIEnv*, jobject, jobject lambda_form_handle))
1776   Handle lambda_form(THREAD, JNIHandles::resolve_non_null(lambda_form_handle));
1777   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1778     TempNewSymbol compileToBytecode = SymbolTable::new_symbol("compileToBytecode", CHECK);
1779     JavaValue result(T_VOID);
1780     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1781   } else {
1782     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1783                 err_msg("Unexpected type: %s", lambda_form-&gt;klass()-&gt;external_name()));
1784   }
1785 C2V_END
1786 
1787 #define CC (char*)  /*cast a literal from (const char*)*/
1788 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1789 
1790 #define STRING                "Ljava/lang/String;"
1791 #define OBJECT                "Ljava/lang/Object;"
1792 #define CLASS                 "Ljava/lang/Class;"
1793 #define EXECUTABLE            "Ljava/lang/reflect/Executable;"
1794 #define STACK_TRACE_ELEMENT   "Ljava/lang/StackTraceElement;"
1795 #define INSTALLED_CODE        "Ljdk/vm/ci/code/InstalledCode;"
1796 #define TARGET_DESCRIPTION    "Ljdk/vm/ci/code/TargetDescription;"
1797 #define BYTECODE_FRAME        "Ljdk/vm/ci/code/BytecodeFrame;"
1798 #define RESOLVED_METHOD       "Ljdk/vm/ci/meta/ResolvedJavaMethod;"
1799 #define HS_RESOLVED_METHOD    "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;"
1800 #define HS_RESOLVED_KLASS     "Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;"
1801 #define HS_CONSTANT_POOL      "Ljdk/vm/ci/hotspot/HotSpotConstantPool;"
1802 #define HS_COMPILED_CODE      "Ljdk/vm/ci/hotspot/HotSpotCompiledCode;"
1803 #define HS_CONFIG             "Ljdk/vm/ci/hotspot/HotSpotVMConfig;"
1804 #define HS_METADATA           "Ljdk/vm/ci/hotspot/HotSpotMetaData;"
1805 #define HS_STACK_FRAME_REF    "Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;"
1806 #define HS_SPECULATION_LOG    "Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;"
1807 #define METASPACE_METHOD_DATA "J"
1808 
1809 JNINativeMethod CompilerToVM::methods[] = {
1810   {CC "getBytecode",                                  CC "(" HS_RESOLVED_METHOD ")[B",                                                      FN_PTR(getBytecode)},
1811   {CC "getExceptionTableStart",                       CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getExceptionTableStart)},
1812   {CC "getExceptionTableLength",                      CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getExceptionTableLength)},
1813   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1814   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1815   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1816   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1817   {CC "setNotInlineableOrCompileable",                CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(setNotInlineableOrCompileable)},
1818   {CC "isCompilable",                                 CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(isCompilable)},
1819   {CC "hasNeverInlineDirective",                      CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(hasNeverInlineDirective)},
1820   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1821   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1822   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1823   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1824   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1825   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1826   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1827   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1828   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1829   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1830   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1831   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1832   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
1833   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[I)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
1834   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1835   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1836   {CC "isResolvedInvokeHandleInPool",                 CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(isResolvedInvokeHandleInPool)},
1837   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1838   {CC "getSignaturePolymorphicHolders",               CC "()[" STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
1839   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1840   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1841   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1842   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1843   {CC "asResolvedJavaMethod",                         CC "(" EXECUTABLE ")" HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
1844   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1845   {CC "getConstantPool",                              CC "(Ljava/lang/Object;)" HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},
1846   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1847   {CC "readConfiguration",                            CC "()[" OBJECT,                                                                      FN_PTR(readConfiguration)},
1848   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1849   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1850   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1851   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1852   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1853   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1854   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1855   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1856   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1857   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1858   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1859   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1860   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1861   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1862   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1863   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1864   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1865   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1866   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1867   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1868   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1869   {CC "getFingerprint",                               CC "(J)J",                                                                            FN_PTR(getFingerprint)},
1870   {CC "getHostClass",                                 CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
1871   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1872   {CC "compileToBytecode",                            CC "(" OBJECT ")V",                                                                   FN_PTR(compileToBytecode)},
1873   {CC "getFlagValue",                                 CC "(" STRING ")" OBJECT,                                                             FN_PTR(getFlagValue)},
1874 };
1875 
1876 int CompilerToVM::methods_count() {
1877   return sizeof(methods) / sizeof(JNINativeMethod);
1878 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="3" type="hidden" /></form></body></html>
