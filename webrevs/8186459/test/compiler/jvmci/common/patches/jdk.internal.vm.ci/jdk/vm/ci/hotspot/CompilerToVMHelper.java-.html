<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old test/compiler/jvmci/common/patches/jdk.internal.vm.ci/jdk/vm/ci/hotspot/CompilerToVMHelper.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package jdk.vm.ci.hotspot;
  25 
  26 import jdk.vm.ci.code.InstalledCode;
  27 import jdk.vm.ci.code.InvalidInstalledCodeException;
  28 import jdk.vm.ci.code.TargetDescription;
  29 import jdk.vm.ci.meta.ConstantPool;
  30 import jdk.vm.ci.meta.ResolvedJavaMethod;
  31 import java.lang.reflect.Executable;
  32 
  33 /**
  34  * A simple "proxy" class to get test access to CompilerToVM package-private methods
  35  */
  36 public class CompilerToVMHelper {
  37     public static final CompilerToVM CTVM = new CompilerToVM();
  38 
  39     public static byte[] getBytecode(HotSpotResolvedJavaMethod method) {
  40         return CTVM.getBytecode((HotSpotResolvedJavaMethodImpl)method);
  41     }
  42 
  43     public static int getExceptionTableLength(HotSpotResolvedJavaMethod method) {
  44         return CTVM.getExceptionTableLength((HotSpotResolvedJavaMethodImpl)method);
  45     }
  46 
  47     public static long getExceptionTableStart(HotSpotResolvedJavaMethod method) {
  48         return CTVM.getExceptionTableStart((HotSpotResolvedJavaMethodImpl)method);
  49     }
  50 
  51     public static Object getFlagValue(String name) {
  52         return CTVM.getFlagValue(name);
  53     }
  54 
  55     public static boolean isCompilable(HotSpotResolvedJavaMethod method) {
  56         return CTVM.isCompilable((HotSpotResolvedJavaMethodImpl)method);
  57     }
  58 
  59     public static boolean hasNeverInlineDirective(HotSpotResolvedJavaMethod method) {
  60         return CTVM.hasNeverInlineDirective((HotSpotResolvedJavaMethodImpl)method);
  61     }
  62 
  63     public static boolean shouldInlineMethod(HotSpotResolvedJavaMethod method) {
  64         return CTVM.shouldInlineMethod((HotSpotResolvedJavaMethodImpl)method);
  65     }
  66 
  67     public static HotSpotResolvedJavaMethod findUniqueConcreteMethod(
  68             HotSpotResolvedObjectType actualHolderType,
  69             HotSpotResolvedJavaMethod method) {
  70         return CTVM.findUniqueConcreteMethod((HotSpotResolvedObjectTypeImpl) actualHolderType, (HotSpotResolvedJavaMethodImpl)method);
  71     }
  72 
  73     public static HotSpotResolvedObjectType getImplementor(HotSpotResolvedObjectType type) {
  74         return CTVM.getImplementor((HotSpotResolvedObjectTypeImpl) type);
  75     }
  76 
  77     public static boolean methodIsIgnoredBySecurityStackWalk(HotSpotResolvedJavaMethod method) {
  78         return CTVM.methodIsIgnoredBySecurityStackWalk((HotSpotResolvedJavaMethodImpl)method);
  79     }
  80 
  81     public static HotSpotResolvedObjectType lookupType(String name,
  82             Class&lt;?&gt; accessingClass, boolean resolve) {
  83         return CTVM.lookupType(name, accessingClass, resolve);
  84     }
  85 
  86     public static Object resolveConstantInPool(ConstantPool constantPool, int cpi) {
  87         return CTVM.resolveConstantInPool((HotSpotConstantPool) constantPool, cpi);
  88     }
  89 
  90     public static Object resolvePossiblyCachedConstantInPool(ConstantPool constantPool, int cpi) {
  91         return CTVM.resolvePossiblyCachedConstantInPool((HotSpotConstantPool) constantPool, cpi);
  92     }
  93 
  94     public static int lookupNameAndTypeRefIndexInPool(ConstantPool constantPool, int cpi) {
  95         return CTVM.lookupNameAndTypeRefIndexInPool((HotSpotConstantPool) constantPool, cpi);
  96     }
  97 
  98     public static String lookupNameInPool(ConstantPool constantPool, int cpi) {
  99         return CTVM.lookupNameInPool((HotSpotConstantPool) constantPool, cpi);
 100     }
 101 
 102     public static String lookupSignatureInPool(ConstantPool constantPool, int cpi) {
 103         return CTVM.lookupSignatureInPool((HotSpotConstantPool) constantPool, cpi);
 104     }
 105 
 106     public static int lookupKlassRefIndexInPool(ConstantPool constantPool, int cpi) {
 107         return CTVM.lookupKlassRefIndexInPool((HotSpotConstantPool) constantPool, cpi);
 108     }
 109 
 110     public static Object lookupKlassInPool(ConstantPool constantPool, int cpi) {
 111         return CTVM.lookupKlassInPool((HotSpotConstantPool) constantPool, cpi);
 112     }
 113 
 114     public static HotSpotResolvedJavaMethod lookupMethodInPool(
 115             ConstantPool constantPool, int cpi, byte opcode) {
 116         return CTVM.lookupMethodInPool((HotSpotConstantPool) constantPool, cpi, opcode);
 117     }
 118 
 119     public static void resolveInvokeDynamicInPool(
 120             ConstantPool constantPool, int cpi) {
 121         CTVM.resolveInvokeDynamicInPool((HotSpotConstantPool) constantPool, cpi);
 122     }
 123 
 124     public static void resolveInvokeHandleInPool(
 125             ConstantPool constantPool, int cpi) {
 126         CTVM.resolveInvokeHandleInPool((HotSpotConstantPool) constantPool, cpi);
 127     }
 128 
 129     public static HotSpotResolvedObjectType resolveTypeInPool(
 130             ConstantPool constantPool, int cpi) {
 131         return CTVM.resolveTypeInPool((HotSpotConstantPool) constantPool, cpi);
 132     }
 133 
 134     public static HotSpotResolvedObjectType resolveFieldInPool(
 135             ConstantPool constantPool, int cpi, ResolvedJavaMethod method, byte opcode, int[] info) {
 136         return CTVM.resolveFieldInPool((HotSpotConstantPool) constantPool, cpi, (HotSpotResolvedJavaMethodImpl) method, opcode, info);
 137     }
 138 
 139     public static int constantPoolRemapInstructionOperandFromCache(
 140             ConstantPool constantPool, int cpci) {
 141         return CTVM.constantPoolRemapInstructionOperandFromCache((HotSpotConstantPool) constantPool, cpci);
 142     }
 143 
 144     public static Object lookupAppendixInPool(
 145             ConstantPool constantPool, int cpi) {
 146         return CTVM.lookupAppendixInPool((HotSpotConstantPool) constantPool, cpi);
 147     }
 148 
 149     public static int installCode(TargetDescription target,
 150             HotSpotCompiledCode compiledCode, InstalledCode code, HotSpotSpeculationLog speculationLog) {
 151         return CTVM.installCode(target, compiledCode, code, speculationLog);
 152     }
 153 
 154     public static int getMetadata(TargetDescription target,
 155             HotSpotCompiledCode compiledCode, HotSpotMetaData metaData) {
 156         return CTVM.getMetadata(target, compiledCode, metaData);
 157     }
 158 
 159     public static void resetCompilationStatistics() {
 160         CTVM.resetCompilationStatistics();
 161     }
 162 
 163     public static Object[] readConfiguration() {
 164         return CTVM.readConfiguration();
 165     }
 166 
 167     public static HotSpotResolvedJavaMethod resolveMethod(
 168             HotSpotResolvedObjectType exactReceiver,
 169             HotSpotResolvedJavaMethod method,
 170             HotSpotResolvedObjectType caller) {
 171         return CTVM.resolveMethod((HotSpotResolvedObjectTypeImpl) exactReceiver, (HotSpotResolvedJavaMethodImpl) method, (HotSpotResolvedObjectTypeImpl) caller);
 172     }
 173 
 174     public static HotSpotResolvedJavaMethod getClassInitializer(
 175             HotSpotResolvedObjectType type) {
 176         return CTVM.getClassInitializer((HotSpotResolvedObjectTypeImpl) type);
 177     }
 178 
 179     public static boolean hasFinalizableSubclass(HotSpotResolvedObjectType type) {
 180         return CTVM.hasFinalizableSubclass((HotSpotResolvedObjectTypeImpl) type);
 181     }
 182 
 183     public static HotSpotResolvedJavaMethodImpl asResolvedJavaMethod(
 184             Executable executable) {
 185         return CTVM.asResolvedJavaMethod(executable);
 186     }
 187 
 188     public static long getMaxCallTargetOffset(long address) {
 189         return CTVM.getMaxCallTargetOffset(address);
 190     }
 191 
 192     public static String disassembleCodeBlob(InstalledCode codeBlob) {
 193         return CTVM.disassembleCodeBlob(codeBlob);
 194     }
 195 
 196     public static StackTraceElement getStackTraceElement(
 197             HotSpotResolvedJavaMethod method, int bci) {
 198         return CTVM.getStackTraceElement((HotSpotResolvedJavaMethodImpl)method, bci);
 199     }
 200 
 201     public static Object executeInstalledCode(Object[] args,
 202             InstalledCode installedCode) throws InvalidInstalledCodeException {
 203         return CTVM.executeInstalledCode(args, installedCode);
 204     }
 205 
 206     public static long[] getLineNumberTable(HotSpotResolvedJavaMethod method) {
 207         return CTVM.getLineNumberTable((HotSpotResolvedJavaMethodImpl)method);
 208     }
 209 
 210     public static int getLocalVariableTableLength(HotSpotResolvedJavaMethod method) {
 211         return CTVM.getLocalVariableTableLength((HotSpotResolvedJavaMethodImpl)method);
 212     }
 213 
 214     public static long getLocalVariableTableStart(HotSpotResolvedJavaMethod method) {
 215         return CTVM.getLocalVariableTableStart((HotSpotResolvedJavaMethodImpl)method);
 216     }
 217 
 218     public static void setNotInlineableOrCompileable(HotSpotResolvedJavaMethod method) {
 219         CTVM.setNotInlineableOrCompileable((HotSpotResolvedJavaMethodImpl)method);
 220     }
 221 
 222     public static void reprofile(HotSpotResolvedJavaMethod method) {
 223         CTVM.reprofile((HotSpotResolvedJavaMethodImpl)method);
 224     }
 225 
 226     public static void invalidateInstalledCode(InstalledCode installedCode) {
 227         CTVM.invalidateInstalledCode(installedCode);
 228     }
 229 
 230     public static long[] collectCounters() {
 231         return CTVM.collectCounters();
 232     }
 233 
 234     public static boolean isMature(long metaspaceMethodData) {
 235         return CTVM.isMature(metaspaceMethodData);
 236     }
 237 
 238     public static int allocateCompileId(HotSpotResolvedJavaMethod method,
 239             int entryBCI) {
 240         return CTVM.allocateCompileId((HotSpotResolvedJavaMethodImpl) method, entryBCI);
 241     }
 242 
 243     public static boolean hasCompiledCodeForOSR(
 244             HotSpotResolvedJavaMethod method, int entryBCI, int level) {
 245         return CTVM.hasCompiledCodeForOSR((HotSpotResolvedJavaMethodImpl) method, entryBCI, level);
 246     }
 247 
 248     public static String getSymbol(long metaspaceSymbol) {
 249         return CTVM.getSymbol(metaspaceSymbol);
 250     }
 251 
 252     public static HotSpotStackFrameReference getNextStackFrame(
 253             HotSpotStackFrameReference frame,
 254             ResolvedJavaMethod[] methods, int initialSkip) {
 255         return CTVM.getNextStackFrame(frame, methods, initialSkip);
 256     }
 257 
 258     public static void materializeVirtualObjects(
 259             HotSpotStackFrameReference stackFrame, boolean invalidate) {
 260         CTVM.materializeVirtualObjects(stackFrame, invalidate);
 261     }
 262 
 263     public static int getVtableIndexForInterfaceMethod(HotSpotResolvedObjectType type,
 264             HotSpotResolvedJavaMethod method) {
 265         return CTVM.getVtableIndexForInterfaceMethod((HotSpotResolvedObjectTypeImpl) type, (HotSpotResolvedJavaMethodImpl) method);
 266     }
 267 
 268     public static boolean shouldDebugNonSafepoints() {
 269         return CTVM.shouldDebugNonSafepoints();
 270     }
 271 
 272     public static void writeDebugOutput(byte[] bytes, int offset, int length) {
 273         CTVM.writeDebugOutput(bytes, offset, length);
 274     }
 275 
 276     public static void flushDebugOutput() {
 277         CTVM.flushDebugOutput();
 278     }
 279 
 280     public static HotSpotResolvedJavaMethod getResolvedJavaMethod(Object base,
 281             long displacement) {
 282         return CTVM.getResolvedJavaMethod(base, displacement);
 283     }
 284 
 285     public static HotSpotConstantPool getConstantPool(Object object) {
 286         return CTVM.getConstantPool(object);
 287     }
 288 
 289     public static HotSpotResolvedObjectType getResolvedJavaType(Object base,
 290             long displacement, boolean compressed) {
 291         return CTVM.getResolvedJavaType(base, displacement, compressed);
 292     }
 293 
 294     public static long getMetaspacePointer(Object o) {
 295         return ((MetaspaceWrapperObject) o).getMetaspacePointer();
 296     }
 297 
 298     public static Class&lt;?&gt; CompilerToVMClass() {
 299         return CompilerToVM.class;
 300     }
 301 
 302     public static Class&lt;?&gt; HotSpotConstantPoolClass() {
 303         return HotSpotConstantPool.class;
 304     }
 305 
 306     public static Class&lt;?&gt; getMirror(HotSpotResolvedObjectType type) {
 307         return ((HotSpotResolvedJavaType) type).mirror();
 308     }
 309 }
</pre></body></html>
