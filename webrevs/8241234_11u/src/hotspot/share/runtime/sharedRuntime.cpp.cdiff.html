<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>open Cdiff src/hotspot/share/runtime/sharedRuntime.cpp</title>
</head>
<body id="SUNWwebrev">
<center><a href='../../../../src/hotspot/share/jvmci/jvmciRuntime.cpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/runtime/sharedRuntime.hpp.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/runtime/sharedRuntime.cpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-52917">52917</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8241234">8241234</a>: Unify monitor enter/exit runtime entries.</pre>
        <pre>
<hr /><span class="oldmarker">*** 1980,1992 ****</span>
  
  JRT_LEAF(void, SharedRuntime::reguard_yellow_pages())
    (void) JavaThread::current()-&gt;reguard_stack();
  JRT_END
  
<span class="changed">! </span>
<span class="changed">! // Handles the uncommon case in locking, i.e., contention or an inflated lock.</span>
<span class="changed">! JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* _obj, BasicLock* lock, JavaThread* thread))</span>
    if (!SafepointSynchronize::is_synchronizing()) {
      // Only try quick_enter() if we're not trying to reach a safepoint
      // so that the calling thread reaches the safepoint more quickly.
      if (ObjectSynchronizer::quick_enter(_obj, thread, lock)) return;
    }
<span class="newmarker">--- 1980,1991 ----</span>
  
  JRT_LEAF(void, SharedRuntime::reguard_yellow_pages())
    (void) JavaThread::current()-&gt;reguard_stack();
  JRT_END
  
<span class="changed">! void SharedRuntime::monitor_enter_helper(oopDesc* _obj, BasicLock* lock, JavaThread* thread,</span>
<span class="changed">!                                          bool use_inlined_fast_locking) {</span>
    if (!SafepointSynchronize::is_synchronizing()) {
      // Only try quick_enter() if we're not trying to reach a safepoint
      // so that the calling thread reaches the safepoint more quickly.
      if (ObjectSynchronizer::quick_enter(_obj, thread, lock)) return;
    }
<hr /><span class="oldmarker">*** 1998,2051 ****</span>
    oop obj(_obj);
    if (PrintBiasedLockingStatistics) {
      Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
    }
    Handle h_obj(THREAD, obj);
    if (UseBiasedLocking) {
      // Retry fast entry if bias is revoked to avoid unnecessary inflation
      ObjectSynchronizer::fast_enter(h_obj, lock, true, CHECK);
    } else {
      ObjectSynchronizer::slow_enter(h_obj, lock, CHECK);
    }
    assert(!HAS_PENDING_EXCEPTION, "Should have no exception here");
    JRT_BLOCK_END
<span class="changed">! JRT_END</span>
  
<span class="changed">! // Handles the uncommon cases of monitor unlocking in compiled code</span>
<span class="changed">! JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* _obj, BasicLock* lock, JavaThread * THREAD))</span>
<span class="changed">!    oop obj(_obj);</span>
<span class="changed">!   assert(JavaThread::current() == THREAD, "invariant");</span>
<span class="changed">!   // I'm not convinced we need the code contained by MIGHT_HAVE_PENDING anymore</span>
<span class="changed">!   // testing was unable to ever fire the assert that guarded it so I have removed it.</span>
<span class="changed">!   assert(!HAS_PENDING_EXCEPTION, "Do we need code below anymore?");</span>
<span class="changed">! #undef MIGHT_HAVE_PENDING</span>
<span class="changed">! #ifdef MIGHT_HAVE_PENDING</span>
<span class="changed">!   // Save and restore any pending_exception around the exception mark.</span>
<span class="changed">!   // While the slow_exit must not throw an exception, we could come into</span>
<span class="changed">!   // this routine with one set.</span>
<span class="changed">!   oop pending_excep = NULL;</span>
<span class="changed">!   const char* pending_file;</span>
<span class="changed">!   int pending_line;</span>
<span class="changed">!   if (HAS_PENDING_EXCEPTION) {</span>
<span class="changed">!     pending_excep = PENDING_EXCEPTION;</span>
<span class="changed">!     pending_file  = THREAD-&gt;exception_file();</span>
<span class="changed">!     pending_line  = THREAD-&gt;exception_line();</span>
<span class="changed">!     CLEAR_PENDING_EXCEPTION;</span>
<span class="changed">!   }</span>
<span class="changed">! #endif /* MIGHT_HAVE_PENDING */</span>
  
<span class="changed">!   {</span>
      // Exit must be non-blocking, and therefore no exceptions can be thrown.
      EXCEPTION_MARK;
<span class="changed">!     ObjectSynchronizer::slow_exit(obj, lock, THREAD);</span>
    }
  
<span class="changed">! #ifdef MIGHT_HAVE_PENDING</span>
<span class="changed">!   if (pending_excep != NULL) {</span>
<span class="changed">!     THREAD-&gt;set_pending_exception(pending_excep, pending_file, pending_line);</span>
<span class="changed">!   }</span>
<span class="changed">! #endif /* MIGHT_HAVE_PENDING */</span>
  JRT_END
  
  #ifndef PRODUCT
  
  void SharedRuntime::print_statistics() {
<span class="newmarker">--- 1997,2043 ----</span>
    oop obj(_obj);
    if (PrintBiasedLockingStatistics) {
      Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
    }
    Handle h_obj(THREAD, obj);
<span class="new">+   assert(oopDesc::is_oop(h_obj()), "must be NULL or an object");</span>
    if (UseBiasedLocking) {
      // Retry fast entry if bias is revoked to avoid unnecessary inflation
      ObjectSynchronizer::fast_enter(h_obj, lock, true, CHECK);
    } else {
<span class="new">+     if (use_inlined_fast_locking) {</span>
        ObjectSynchronizer::slow_enter(h_obj, lock, CHECK);
<span class="new">+     } else {</span>
<span class="new">+       ObjectSynchronizer::fast_enter(h_obj, lock, false, CHECK);</span>
<span class="new">+     }</span>
    }
    assert(!HAS_PENDING_EXCEPTION, "Should have no exception here");
    JRT_BLOCK_END
<span class="changed">! }</span>
  
<span class="changed">! // Handles the uncommon case in locking, i.e., contention or an inflated lock.</span>
<span class="changed">! JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* _obj, BasicLock* lock, JavaThread* thread))</span>
<span class="changed">!   SharedRuntime::monitor_enter_helper(_obj, lock, thread, true);</span>
<span class="changed">! JRT_END</span>
  
<span class="changed">! void SharedRuntime::monitor_exit_helper(oop _obj, BasicLock* lock, JavaThread* thread,</span>
<span class="changed">!                                         bool use_inlined_fast_locking) {</span>
<span class="changed">!   assert(JavaThread::current() == thread, "invariant");</span>
    // Exit must be non-blocking, and therefore no exceptions can be thrown.
    EXCEPTION_MARK;
<span class="changed">!   if (use_inlined_fast_locking) {</span>
<span class="changed">!     // When using fast locking, the compiled code has already tried the fast case</span>
<span class="changed">!     ObjectSynchronizer::slow_exit(_obj, lock, THREAD);</span>
<span class="changed">!   } else {</span>
<span class="changed">!     ObjectSynchronizer::fast_exit(_obj, lock, THREAD);</span>
    }
<span class="new">+ }</span>
  
<span class="changed">! // Handles the uncommon cases of monitor unlocking in compiled code</span>
<span class="changed">! JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* _obj, BasicLock* lock, JavaThread* thread))</span>
<span class="changed">!   oop obj(_obj);</span>
<span class="changed">!   SharedRuntime::monitor_exit_helper(obj, lock, thread, true);</span>
  JRT_END
  
  #ifndef PRODUCT
  
  void SharedRuntime::print_statistics() {
</pre>
<center><a href='../../../../src/hotspot/share/jvmci/jvmciRuntime.cpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/runtime/sharedRuntime.hpp.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

