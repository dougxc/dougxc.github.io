<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "compiler/compileBroker.hpp"
  26 #include "jvmci/jniAccessMark.inline.hpp"
  27 #include "jvmci/jvmciCompilerToVM.hpp"
  28 #include "jvmci/jvmciRuntime.hpp"
  29 #include "logging/log.hpp"
  30 #include "memory/oopFactory.hpp"
  31 #include "oops/constantPool.inline.hpp"
  32 #include "oops/method.inline.hpp"
  33 #include "oops/oop.inline.hpp"
  34 #include "runtime/biasedLocking.hpp"
  35 #include "runtime/deoptimization.hpp"
  36 #include "runtime/frame.inline.hpp"
  37 #include "runtime/sharedRuntime.hpp"
  38 #if INCLUDE_G1GC
  39 #include "gc/g1/g1ThreadLocalData.hpp"
  40 #endif // INCLUDE_G1GC
  41 
  42 // Simple helper to see if the caller of a runtime stub which
  43 // entered the VM has been deoptimized
  44 
  45 static bool caller_is_deopted() {
  46   JavaThread* thread = JavaThread::current();
  47   RegisterMap reg_map(thread, false);
  48   frame runtime_frame = thread-&gt;last_frame();
  49   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  50   assert(caller_frame.is_compiled_frame(), "must be compiled");
  51   return caller_frame.is_deoptimized_frame();
  52 }
  53 
  54 // Stress deoptimization
  55 static void deopt_caller() {
  56   if ( !caller_is_deopted()) {
  57     JavaThread* thread = JavaThread::current();
  58     RegisterMap reg_map(thread, false);
  59     frame runtime_frame = thread-&gt;last_frame();
  60     frame caller_frame = runtime_frame.sender(&amp;reg_map);
  61     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
  62     assert(caller_is_deopted(), "Must be deoptimized");
  63   }
  64 }
  65 
  66 // Manages a scope for a JVMCI runtime call that attempts a heap allocation.
  67 // If there is a pending exception upon closing the scope and the runtime
  68 // call is of the variety where allocation failure returns NULL without an
  69 // exception, the following action is taken:
  70 //   1. The pending exception is cleared
  71 //   2. NULL is written to JavaThread::_vm_result
  72 //   3. Checks that an OutOfMemoryError is Universe::out_of_memory_error_retry().
  73 class RetryableAllocationMark: public StackObj {
  74  private:
  75   JavaThread* _thread;
  76  public:
  77   RetryableAllocationMark(JavaThread* thread, bool activate) {
  78     if (activate) {
  79       assert(!thread-&gt;in_retryable_allocation(), "retryable allocation scope is non-reentrant");
  80       _thread = thread;
  81       _thread-&gt;set_in_retryable_allocation(true);
  82     } else {
  83       _thread = NULL;
  84     }
  85   }
  86   ~RetryableAllocationMark() {
  87     if (_thread != NULL) {
  88       _thread-&gt;set_in_retryable_allocation(false);
  89       JavaThread* THREAD = _thread;
  90       if (HAS_PENDING_EXCEPTION) {
  91         oop ex = PENDING_EXCEPTION;
  92         CLEAR_PENDING_EXCEPTION;
  93         oop retry_oome = Universe::out_of_memory_error_retry();
  94         if (ex-&gt;is_a(retry_oome-&gt;klass()) &amp;&amp; retry_oome != ex) {
  95           ResourceMark rm;
  96           fatal("Unexpected exception in scope of retryable allocation: " INTPTR_FORMAT " of type %s", p2i(ex), ex-&gt;klass()-&gt;external_name());
  97         }
  98         _thread-&gt;set_vm_result(NULL);
  99       }
 100     }
 101   }
 102 };
 103 
 104 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail))
 105   JRT_BLOCK;
 106   assert(klass-&gt;is_klass(), "not a class");
 107   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 108   InstanceKlass* h = InstanceKlass::cast(klass);
 109   {
 110     RetryableAllocationMark ram(thread, null_on_fail);
 111     h-&gt;check_valid_for_instantiation(true, CHECK);
 112     oop obj;
 113     if (null_on_fail) {
 114       if (!h-&gt;is_initialized()) {
 115         // Cannot re-execute class initialization without side effects
 116         // so return without attempting the initialization
 117         return;
 118       }
 119     } else {
 120       // make sure klass is initialized
 121       h-&gt;initialize(CHECK);
 122     }
 123     // allocate instance and return via TLS
 124     obj = h-&gt;allocate_instance(CHECK);
 125     thread-&gt;set_vm_result(obj);
 126   }
 127   JRT_BLOCK_END;
 128   SharedRuntime::on_slowpath_allocation_exit(thread);
 129 JRT_END
 130 
 131 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* thread, Klass* array_klass, jint length, bool null_on_fail))
 132   JRT_BLOCK;
 133   // Note: no handle for klass needed since they are not used
 134   //       anymore after new_objArray() and no GC can happen before.
 135   //       (This may have to change if this code changes!)
 136   assert(array_klass-&gt;is_klass(), "not a class");
 137   oop obj;
 138   if (array_klass-&gt;is_typeArray_klass()) {
 139     BasicType elt_type = TypeArrayKlass::cast(array_klass)-&gt;element_type();
 140     RetryableAllocationMark ram(thread, null_on_fail);
 141     obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 142   } else {
 143     Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
 144     Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();
 145     RetryableAllocationMark ram(thread, null_on_fail);
 146     obj = oopFactory::new_objArray(elem_klass, length, CHECK);
 147   }
 148   thread-&gt;set_vm_result(obj);
 149   // This is pretty rare but this runtime patch is stressful to deoptimization
 150   // if we deoptimize here so force a deopt to stress the path.
 151   if (DeoptimizeALot) {
 152     static int deopts = 0;
 153     // Alternate between deoptimizing and raising an error (which will also cause a deopt)
 154     if (deopts++ % 2 == 0) {
 155       if (null_on_fail) {
 156         return;
 157       } else {
 158         ResourceMark rm(THREAD);
 159         THROW(vmSymbols::java_lang_OutOfMemoryError());
 160       }
 161     } else {
 162       deopt_caller();
 163     }
 164   }
 165   JRT_BLOCK_END;
 166   SharedRuntime::on_slowpath_allocation_exit(thread);
 167 JRT_END
 168 
 169 JRT_ENTRY(void, JVMCIRuntime::new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail))
 170   assert(klass-&gt;is_klass(), "not a class");
 171   assert(rank &gt;= 1, "rank must be nonzero");
 172   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 173   RetryableAllocationMark ram(thread, null_on_fail);
 174   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
 175   thread-&gt;set_vm_result(obj);
 176 JRT_END
 177 
 178 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail))
 179   RetryableAllocationMark ram(thread, null_on_fail);
 180   oop obj = Reflection::reflect_new_array(element_mirror, length, CHECK);
 181   thread-&gt;set_vm_result(obj);
 182 JRT_END
 183 
 184 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail))
 185   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(type_mirror));
 186 
 187   if (klass == NULL) {
 188     ResourceMark rm(THREAD);
 189     THROW(vmSymbols::java_lang_InstantiationException());
 190   }
 191   RetryableAllocationMark ram(thread, null_on_fail);
 192 
 193   // Create new instance (the receiver)
 194   klass-&gt;check_valid_for_instantiation(false, CHECK);
 195 
 196   if (null_on_fail) {
 197     if (!klass-&gt;is_initialized()) {
 198       // Cannot re-execute class initialization without side effects
 199       // so return without attempting the initialization
 200       return;
 201     }
 202   } else {
 203     // Make sure klass gets initialized
 204     klass-&gt;initialize(CHECK);
 205   }
 206 
 207   oop obj = klass-&gt;allocate_instance(CHECK);
 208   thread-&gt;set_vm_result(obj);
 209 JRT_END
 210 
 211 extern void vm_exit(int code);
 212 
 213 // Enter this method from compiled code handler below. This is where we transition
 214 // to VM mode. This is done as a helper routine so that the method called directly
 215 // from compiled code does not have to transition to VM. This allows the entry
 216 // method to see if the nmethod that we have just looked up a handler for has
 217 // been deoptimized while we were in the vm. This simplifies the assembly code
 218 // cpu directories.
 219 //
 220 // We are entering here from exception stub (via the entry method below)
 221 // If there is a compiled exception handler in this method, we will continue there;
 222 // otherwise we will unwind the stack and continue at the caller of top frame method
 223 // Note: we enter in Java using a special JRT wrapper. This wrapper allows us to
 224 // control the area where we can allow a safepoint. After we exit the safepoint area we can
 225 // check to see if the handler we are going to return is now in a nmethod that has
 226 // been deoptimized. If that is the case we return the deopt blob
 227 // unpack_with_exception entry instead. This makes life for the exception blob easier
 228 // because making that same check and diverting is painful from assembly language.
 229 JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, CompiledMethod*&amp; cm))
 230   // Reset method handle flag.
 231   thread-&gt;set_is_method_handle_return(false);
 232 
 233   Handle exception(thread, ex);
 234   cm = CodeCache::find_compiled(pc);
 235   assert(cm != NULL, "this is not a compiled method");
 236   // Adjust the pc as needed/
 237   if (cm-&gt;is_deopt_pc(pc)) {
 238     RegisterMap map(thread, false);
 239     frame exception_frame = thread-&gt;last_frame().sender(&amp;map);
 240     // if the frame isn't deopted then pc must not correspond to the caller of last_frame
 241     assert(exception_frame.is_deoptimized_frame(), "must be deopted");
 242     pc = exception_frame.pc();
 243   }
 244 #ifdef ASSERT
 245   assert(exception.not_null(), "NULL exceptions should be handled by throw_exception");
 246   assert(oopDesc::is_oop(exception()), "just checking");
 247   // Check that exception is a subclass of Throwable, otherwise we have a VerifyError
 248   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
 249     if (ExitVMOnVerifyError) vm_exit(-1);
 250     ShouldNotReachHere();
 251   }
 252 #endif
 253 
 254   // Check the stack guard pages and reenable them if necessary and there is
 255   // enough space on the stack to do so.  Use fast exceptions only if the guard
 256   // pages are enabled.
 257   bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
 258   if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
 259 
 260   if (JvmtiExport::can_post_on_exceptions()) {
 261     // To ensure correct notification of exception catches and throws
 262     // we have to deoptimize here.  If we attempted to notify the
 263     // catches and throws during this exception lookup it's possible
 264     // we could deoptimize on the way out of the VM and end back in
 265     // the interpreter at the throw site.  This would result in double
 266     // notifications since the interpreter would also notify about
 267     // these same catches and throws as it unwound the frame.
 268 
 269     RegisterMap reg_map(thread);
 270     frame stub_frame = thread-&gt;last_frame();
 271     frame caller_frame = stub_frame.sender(&amp;reg_map);
 272 
 273     // We don't really want to deoptimize the nmethod itself since we
 274     // can actually continue in the exception handler ourselves but I
 275     // don't see an easy way to have the desired effect.
 276     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
 277     assert(caller_is_deopted(), "Must be deoptimized");
 278 
 279     return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 280   }
 281 
 282   // ExceptionCache is used only for exceptions at call sites and not for implicit exceptions
 283   if (guard_pages_enabled) {
 284     address fast_continuation = cm-&gt;handler_for_exception_and_pc(exception, pc);
 285     if (fast_continuation != NULL) {
 286       // Set flag if return address is a method handle call site.
 287       thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 288       return fast_continuation;
 289     }
 290   }
 291 
 292   // If the stack guard pages are enabled, check whether there is a handler in
 293   // the current method.  Otherwise (guard pages disabled), force an unwind and
 294   // skip the exception cache update (i.e., just leave continuation==NULL).
 295   address continuation = NULL;
 296   if (guard_pages_enabled) {
 297 
 298     // New exception handling mechanism can support inlined methods
 299     // with exception handlers since the mappings are from PC to PC
 300 
 301     // debugging support
 302     // tracing
 303     if (log_is_enabled(Info, exceptions)) {
 304       ResourceMark rm;
 305       stringStream tempst;
 306       tempst.print("compiled method &lt;%s&gt;\n"
 307                    " at PC" INTPTR_FORMAT " for thread " INTPTR_FORMAT,
 308                    cm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
 309       Exceptions::log_exception(exception, tempst.as_string());
 310     }
 311     // for AbortVMOnException flag
 312     NOT_PRODUCT(Exceptions::debug_check_abort(exception));
 313 
 314     // Clear out the exception oop and pc since looking up an
 315     // exception handler can cause class loading, which might throw an
 316     // exception and those fields are expected to be clear during
 317     // normal bytecode execution.
 318     thread-&gt;clear_exception_oop_and_pc();
 319 
 320     bool recursive_exception = false;
 321     continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);
 322     // If an exception was thrown during exception dispatch, the exception oop may have changed
 323     thread-&gt;set_exception_oop(exception());
 324     thread-&gt;set_exception_pc(pc);
 325 
 326     // The exception cache is used only for non-implicit exceptions
 327     // Update the exception cache only when another exception did
 328     // occur during the computation of the compiled exception handler
 329     // (e.g., when loading the class of the catch type).
 330     // Checking for exception oop equality is not
 331     // sufficient because some exceptions are pre-allocated and reused.
 332     if (continuation != NULL &amp;&amp; !recursive_exception &amp;&amp; !SharedRuntime::deopt_blob()-&gt;contains(continuation)) {
 333       cm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
 334     }
 335   }
 336 
 337   // Set flag if return address is a method handle call site.
 338   thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 339 
 340   if (log_is_enabled(Info, exceptions)) {
 341     ResourceMark rm;
 342     log_info(exceptions)("Thread " PTR_FORMAT " continuing at PC " PTR_FORMAT
 343                          " for exception thrown at PC " PTR_FORMAT,
 344                          p2i(thread), p2i(continuation), p2i(pc));
 345   }
 346 
 347   return continuation;
 348 JRT_END
 349 
 350 // Enter this method from compiled code only if there is a Java exception handler
 351 // in the method handling the exception.
 352 // We are entering here from exception stub. We don't do a normal VM transition here.
 353 // We do it in a helper. This is so we can check to see if the nmethod we have just
 354 // searched for an exception handler has been deoptimized in the meantime.
 355 address JVMCIRuntime::exception_handler_for_pc(JavaThread* thread) {
 356   oop exception = thread-&gt;exception_oop();
 357   address pc = thread-&gt;exception_pc();
 358   // Still in Java mode
 359   DEBUG_ONLY(ResetNoHandleMark rnhm);
 360   CompiledMethod* cm = NULL;
 361   address continuation = NULL;
 362   {
 363     // Enter VM mode by calling the helper
 364     ResetNoHandleMark rnhm;
 365     continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);
 366   }
 367   // Back in JAVA, use no oops DON'T safepoint
 368 
 369   // Now check to see if the compiled method we were called from is now deoptimized.
 370   // If so we must return to the deopt blob and deoptimize the nmethod
 371   if (cm != NULL &amp;&amp; caller_is_deopted()) {
 372     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 373   }
 374 
 375   assert(continuation != NULL, "no handler found");
 376   return continuation;
 377 }
 378 
<a name="1" id="anc1"></a><span class="changed"> 379 JRT_ENTRY_NO_ASYNC(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))</span>
<span class="changed"> 380   IF_TRACE_jvmci_3 {</span>
<span class="changed"> 381     char type[O_BUFLEN];</span>
<span class="changed"> 382     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);</span>
<span class="changed"> 383     markOop mark = obj-&gt;mark();</span>
<span class="changed"> 384     TRACE_jvmci_3("%s: entered locking slow case with obj=" INTPTR_FORMAT ", type=%s, mark=" INTPTR_FORMAT ", lock=" INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, p2i(mark), p2i(lock));</span>
<span class="changed"> 385     tty-&gt;flush();</span>
<span class="changed"> 386   }</span>
<span class="changed"> 387   if (PrintBiasedLockingStatistics) {</span>
<span class="changed"> 388     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span>
<span class="changed"> 389   }</span>
<span class="changed"> 390   Handle h_obj(thread, obj);</span>
<span class="changed"> 391   assert(oopDesc::is_oop(h_obj()), "must be NULL or an object");</span>
<span class="changed"> 392   if (UseBiasedLocking) {</span>
<span class="changed"> 393     // Retry fast entry if bias is revoked to avoid unnecessary inflation</span>
<span class="changed"> 394     ObjectSynchronizer::fast_enter(h_obj, lock, true, CHECK);</span>
<span class="changed"> 395   } else {</span>
<span class="changed"> 396     if (JVMCIUseFastLocking) {</span>
<span class="changed"> 397       // When using fast locking, the compiled code has already tried the fast case</span>
<span class="changed"> 398       ObjectSynchronizer::slow_enter(h_obj, lock, THREAD);</span>
<span class="changed"> 399     } else {</span>
<span class="changed"> 400       ObjectSynchronizer::fast_enter(h_obj, lock, false, THREAD);</span>
<span class="changed"> 401     }</span>
<span class="changed"> 402   }</span>
<span class="changed"> 403   TRACE_jvmci_3("%s: exiting locking slow with obj=" INTPTR_FORMAT, thread-&gt;name(), p2i(obj));</span>
 404 JRT_END
 405 
 406 JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
<a name="2" id="anc2"></a><span class="removed"> 407   assert(thread == JavaThread::current(), "threads must correspond");</span>
 408   assert(thread-&gt;last_Java_sp(), "last_Java_sp must be set");
<a name="3" id="anc3"></a><span class="changed"> 409   // monitorexit is non-blocking (leaf routine) =&gt; no exceptions can be thrown</span>
<span class="changed"> 410   EXCEPTION_MARK;</span>
<span class="changed"> 411 </span>
<span class="changed"> 412 #ifdef ASSERT</span>
<span class="changed"> 413   if (!oopDesc::is_oop(obj)) {</span>
<span class="changed"> 414     ResetNoHandleMark rhm;</span>
<span class="changed"> 415     nmethod* method = thread-&gt;last_frame().cb()-&gt;as_nmethod_or_null();</span>
<span class="changed"> 416     if (method != NULL) {</span>
<span class="changed"> 417       tty-&gt;print_cr("ERROR in monitorexit in method %s wrong obj " INTPTR_FORMAT, method-&gt;name(), p2i(obj));</span>
<span class="changed"> 418     }</span>
<span class="changed"> 419     thread-&gt;print_stack_on(tty);</span>
<span class="changed"> 420     assert(false, "invalid lock object pointer dected");</span>
<span class="changed"> 421   }</span>
<span class="changed"> 422 #endif</span>
<span class="changed"> 423 </span>
<span class="changed"> 424   if (JVMCIUseFastLocking) {</span>
<span class="changed"> 425     // When using fast locking, the compiled code has already tried the fast case</span>
<span class="changed"> 426     ObjectSynchronizer::slow_exit(obj, lock, THREAD);</span>
<span class="changed"> 427   } else {</span>
<span class="changed"> 428     ObjectSynchronizer::fast_exit(obj, lock, THREAD);</span>
<span class="changed"> 429   }</span>
<span class="changed"> 430   IF_TRACE_jvmci_3 {</span>
<span class="changed"> 431     char type[O_BUFLEN];</span>
<span class="changed"> 432     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);</span>
<span class="changed"> 433     TRACE_jvmci_3("%s: exited locking slow case with obj=" INTPTR_FORMAT ", type=%s, mark=" INTPTR_FORMAT ", lock=" INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, p2i(obj-&gt;mark()), p2i(lock));</span>
<span class="changed"> 434     tty-&gt;flush();</span>
<span class="changed"> 435   }</span>
 436 JRT_END
 437 
 438 // Object.notify() fast path, caller does slow path
 439 JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *thread, oopDesc* obj))
 440 
 441   // Very few notify/notifyAll operations find any threads on the waitset, so
 442   // the dominant fast-path is to simply return.
 443   // Relatedly, it's critical that notify/notifyAll be fast in order to
 444   // reduce lock hold times.
 445   if (!SafepointSynchronize::is_synchronizing()) {
 446     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 447       return true;
 448     }
 449   }
 450   return false; // caller must perform slow path
 451 
 452 JRT_END
 453 
 454 // Object.notifyAll() fast path, caller does slow path
 455 JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *thread, oopDesc* obj))
 456 
 457   if (!SafepointSynchronize::is_synchronizing() ) {
 458     if (ObjectSynchronizer::quick_notify(obj, thread, true)) {
 459       return true;
 460     }
 461   }
 462   return false; // caller must perform slow path
 463 
 464 JRT_END
 465 
 466 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))
 467   JRT_BLOCK;
 468   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK_EXIT_(0));
 469   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 470   JRT_BLOCK_END;
 471   return caller_is_deopted();
 472 JRT_END
 473 
 474 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))
 475   JRT_BLOCK;
 476   ResourceMark rm(thread);
 477   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK_EXIT_(0));
 478   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass-&gt;external_name());
 479   JRT_BLOCK_END;
 480   return caller_is_deopted();
 481 JRT_END
 482 
 483 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))
 484   JRT_BLOCK;
 485   ResourceMark rm(thread);
 486   const char* message = SharedRuntime::generate_class_cast_message(caster_klass, target_klass);
 487   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK_EXIT_(0));
 488   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 489   JRT_BLOCK_END;
 490   return caller_is_deopted();
 491 JRT_END
 492 
 493 JRT_LEAF(void, JVMCIRuntime::log_object(JavaThread* thread, oopDesc* obj, bool as_string, bool newline))
 494   ttyLocker ttyl;
 495 
 496   if (obj == NULL) {
 497     tty-&gt;print("NULL");
 498   } else if (oopDesc::is_oop_or_null(obj, true) &amp;&amp; (!as_string || !java_lang_String::is_instance(obj))) {
 499     if (oopDesc::is_oop_or_null(obj, true)) {
 500       char buf[O_BUFLEN];
 501       tty-&gt;print("%s@" INTPTR_FORMAT, obj-&gt;klass()-&gt;name()-&gt;as_C_string(buf, O_BUFLEN), p2i(obj));
 502     } else {
 503       tty-&gt;print(INTPTR_FORMAT, p2i(obj));
 504     }
 505   } else {
 506     ResourceMark rm;
 507     assert(obj != NULL &amp;&amp; java_lang_String::is_instance(obj), "must be");
 508     char *buf = java_lang_String::as_utf8_string(obj);
 509     tty-&gt;print_raw(buf);
 510   }
 511   if (newline) {
 512     tty-&gt;cr();
 513   }
 514 JRT_END
 515 
 516 #if INCLUDE_G1GC
 517 
 518 JRT_LEAF(void, JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj))
 519   G1ThreadLocalData::satb_mark_queue(thread).enqueue(obj);
 520 JRT_END
 521 
 522 JRT_LEAF(void, JVMCIRuntime::write_barrier_post(JavaThread* thread, void* card_addr))
 523   G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);
 524 JRT_END
 525 
 526 #endif // INCLUDE_G1GC
 527 
 528 JRT_LEAF(jboolean, JVMCIRuntime::validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child))
 529   bool ret = true;
 530   if(!Universe::heap()-&gt;is_in_closed_subset(parent)) {
 531     tty-&gt;print_cr("Parent Object " INTPTR_FORMAT " not in heap", p2i(parent));
 532     parent-&gt;print();
 533     ret=false;
 534   }
 535   if(!Universe::heap()-&gt;is_in_closed_subset(child)) {
 536     tty-&gt;print_cr("Child Object " INTPTR_FORMAT " not in heap", p2i(child));
 537     child-&gt;print();
 538     ret=false;
 539   }
 540   return (jint)ret;
 541 JRT_END
 542 
 543 JRT_ENTRY(void, JVMCIRuntime::vm_error(JavaThread* thread, jlong where, jlong format, jlong value))
 544   ResourceMark rm;
 545   const char *error_msg = where == 0L ? "&lt;internal JVMCI error&gt;" : (char*) (address) where;
 546   char *detail_msg = NULL;
 547   if (format != 0L) {
 548     const char* buf = (char*) (address) format;
 549     size_t detail_msg_length = strlen(buf) * 2;
 550     detail_msg = (char *) NEW_RESOURCE_ARRAY(u_char, detail_msg_length);
 551     jio_snprintf(detail_msg, detail_msg_length, buf, value);
 552   }
 553   report_vm_error(__FILE__, __LINE__, error_msg, "%s", detail_msg);
 554 JRT_END
 555 
 556 JRT_LEAF(oopDesc*, JVMCIRuntime::load_and_clear_exception(JavaThread* thread))
 557   oop exception = thread-&gt;exception_oop();
 558   assert(exception != NULL, "npe");
 559   thread-&gt;set_exception_oop(NULL);
 560   thread-&gt;set_exception_pc(0);
 561   return exception;
 562 JRT_END
 563 
 564 PRAGMA_DIAG_PUSH
 565 PRAGMA_FORMAT_NONLITERAL_IGNORED
 566 JRT_LEAF(void, JVMCIRuntime::log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3))
 567   ResourceMark rm;
 568   tty-&gt;print(format, v1, v2, v3);
 569 JRT_END
 570 PRAGMA_DIAG_POP
 571 
 572 static void decipher(jlong v, bool ignoreZero) {
 573   if (v != 0 || !ignoreZero) {
 574     void* p = (void *)(address) v;
 575     CodeBlob* cb = CodeCache::find_blob(p);
 576     if (cb) {
 577       if (cb-&gt;is_nmethod()) {
 578         char buf[O_BUFLEN];
 579         tty-&gt;print("%s [" INTPTR_FORMAT "+" JLONG_FORMAT "]", cb-&gt;as_nmethod_or_null()-&gt;method()-&gt;name_and_sig_as_C_string(buf, O_BUFLEN), p2i(cb-&gt;code_begin()), (jlong)((address)v - cb-&gt;code_begin()));
 580         return;
 581       }
 582       cb-&gt;print_value_on(tty);
 583       return;
 584     }
 585     if (Universe::heap()-&gt;is_in(p)) {
 586       oop obj = oop(p);
 587       obj-&gt;print_value_on(tty);
 588       return;
 589     }
 590     tty-&gt;print(INTPTR_FORMAT " [long: " JLONG_FORMAT ", double %lf, char %c]",p2i((void *)v), (jlong)v, (jdouble)v, (char)v);
 591   }
 592 }
 593 
 594 PRAGMA_DIAG_PUSH
 595 PRAGMA_FORMAT_NONLITERAL_IGNORED
 596 JRT_LEAF(void, JVMCIRuntime::vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3))
 597   ResourceMark rm;
 598   const char *buf = (const char*) (address) format;
 599   if (vmError) {
 600     if (buf != NULL) {
 601       fatal(buf, v1, v2, v3);
 602     } else {
 603       fatal("&lt;anonymous error&gt;");
 604     }
 605   } else if (buf != NULL) {
 606     tty-&gt;print(buf, v1, v2, v3);
 607   } else {
 608     assert(v2 == 0, "v2 != 0");
 609     assert(v3 == 0, "v3 != 0");
 610     decipher(v1, false);
 611   }
 612 JRT_END
 613 PRAGMA_DIAG_POP
 614 
 615 JRT_LEAF(void, JVMCIRuntime::log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline))
 616   union {
 617       jlong l;
 618       jdouble d;
 619       jfloat f;
 620   } uu;
 621   uu.l = value;
 622   switch (typeChar) {
 623     case 'Z': tty-&gt;print(value == 0 ? "false" : "true"); break;
 624     case 'B': tty-&gt;print("%d", (jbyte) value); break;
 625     case 'C': tty-&gt;print("%c", (jchar) value); break;
 626     case 'S': tty-&gt;print("%d", (jshort) value); break;
 627     case 'I': tty-&gt;print("%d", (jint) value); break;
 628     case 'F': tty-&gt;print("%f", uu.f); break;
 629     case 'J': tty-&gt;print(JLONG_FORMAT, value); break;
 630     case 'D': tty-&gt;print("%lf", uu.d); break;
 631     default: assert(false, "unknown typeChar"); break;
 632   }
 633   if (newline) {
 634     tty-&gt;cr();
 635   }
 636 JRT_END
 637 
 638 JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))
 639   return (jint) obj-&gt;identity_hash();
 640 JRT_END
 641 
 642 JRT_ENTRY(jboolean, JVMCIRuntime::thread_is_interrupted(JavaThread* thread, oopDesc* receiver, jboolean clear_interrupted))
 643   Handle receiverHandle(thread, receiver);
 644   // A nested ThreadsListHandle may require the Threads_lock which
 645   // requires thread_in_vm which is why this method cannot be JRT_LEAF.
 646   ThreadsListHandle tlh;
 647 
 648   JavaThread* receiverThread = java_lang_Thread::thread(receiverHandle());
 649   if (receiverThread == NULL || (EnableThreadSMRExtraValidityChecks &amp;&amp; !tlh.includes(receiverThread))) {
 650     // The other thread may exit during this process, which is ok so return false.
 651     return JNI_FALSE;
 652   } else {
 653     return (jint) Thread::is_interrupted(receiverThread, clear_interrupted != 0);
 654   }
 655 JRT_END
 656 
 657 JRT_ENTRY(jint, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))
 658   deopt_caller();
 659   return (jint) value;
 660 JRT_END
 661 
 662 
 663 // private static JVMCIRuntime JVMCI.initializeRuntime()
 664 JVM_ENTRY_NO_ENV(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))
 665   JNI_JVMCIENV(thread, env);
 666   if (!EnableJVMCI) {
 667     JVMCI_THROW_MSG_NULL(InternalError, "JVMCI is not enabled");
 668   }
 669   JVMCIENV-&gt;runtime()-&gt;initialize_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);
 670   JVMCIObject runtime = JVMCIENV-&gt;runtime()-&gt;get_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);
 671   return JVMCIENV-&gt;get_jobject(runtime);
 672 JVM_END
 673 
 674 void JVMCIRuntime::call_getCompiler(TRAPS) {
 675   THREAD_JVMCIENV(JavaThread::current());
 676   JVMCIObject jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_CHECK);
 677   initialize(JVMCIENV);
 678   JVMCIENV-&gt;call_HotSpotJVMCIRuntime_getCompiler(jvmciRuntime, JVMCI_CHECK);
 679 }
 680 
 681 void JVMCINMethodData::initialize(
 682   int nmethod_mirror_index,
 683   const char* name,
 684   FailedSpeculation** failed_speculations)
 685 {
 686   _failed_speculations = failed_speculations;
 687   _nmethod_mirror_index = nmethod_mirror_index;
 688   if (name != NULL) {
 689     _has_name = true;
 690     char* dest = (char*) this-&gt;name();
 691     strcpy(dest, name);
 692   } else {
 693     _has_name = false;
 694   }
 695 }
 696 
 697 void JVMCINMethodData::add_failed_speculation(nmethod* nm, jlong speculation) {
 698   uint index = (speculation &gt;&gt; 32) &amp; 0xFFFFFFFF;
 699   int length = (int) speculation;
 700   if (index + length &gt; (uint) nm-&gt;speculations_size()) {
 701     fatal(INTPTR_FORMAT "[index: %d, length: %d] out of bounds wrt encoded speculations of length %u", speculation, index, length, nm-&gt;speculations_size());
 702   }
 703   address data = nm-&gt;speculations_begin() + index;
 704   FailedSpeculation::add_failed_speculation(nm, _failed_speculations, data, length);
 705 }
 706 
 707 oop JVMCINMethodData::get_nmethod_mirror(nmethod* nm, bool phantom_ref) {
 708   if (_nmethod_mirror_index == -1) {
 709     return NULL;
 710   }
 711   if (phantom_ref) {
 712     return nm-&gt;oop_at_phantom(_nmethod_mirror_index);
 713   } else {
 714     return nm-&gt;oop_at(_nmethod_mirror_index);
 715   }
 716 }
 717 
 718 void JVMCINMethodData::set_nmethod_mirror(nmethod* nm, oop new_mirror) {
 719   assert(_nmethod_mirror_index != -1, "cannot set JVMCI mirror for nmethod");
 720   oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);
 721   assert(new_mirror != NULL, "use clear_nmethod_mirror to clear the mirror");
 722   assert(*addr == NULL, "cannot overwrite non-null mirror");
 723 
 724   *addr = new_mirror;
 725 
 726   // Since we've patched some oops in the nmethod,
 727   // (re)register it with the heap.
 728   Universe::heap()-&gt;register_nmethod(nm);
 729 }
 730 
 731 void JVMCINMethodData::clear_nmethod_mirror(nmethod* nm) {
 732   if (_nmethod_mirror_index != -1) {
 733     oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);
 734     *addr = NULL;
 735   }
 736 }
 737 
 738 void JVMCINMethodData::invalidate_nmethod_mirror(nmethod* nm) {
 739   oop nmethod_mirror = get_nmethod_mirror(nm, /* phantom_ref */ false);
 740   if (nmethod_mirror == NULL) {
 741     return;
 742   }
 743 
 744   // Update the values in the mirror if it still refers to nm.
 745   // We cannot use JVMCIObject to wrap the mirror as this is called
 746   // during GC, forbidding the creation of JNIHandles.
 747   JVMCIEnv* jvmciEnv = NULL;
 748   nmethod* current = (nmethod*) HotSpotJVMCI::InstalledCode::address(jvmciEnv, nmethod_mirror);
 749   if (nm == current) {
 750     if (!nm-&gt;is_alive()) {
 751       // Break the link from the mirror to nm such that
 752       // future invocations via the mirror will result in
 753       // an InvalidInstalledCodeException.
 754       HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, 0);
 755       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 756     } else if (nm-&gt;is_not_entrant()) {
 757       // Zero the entry point so any new invocation will fail but keep
 758       // the address link around that so that existing activations can
 759       // be deoptimized via the mirror (i.e. JVMCIEnv::invalidate_installed_code).
 760       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 761     }
 762   }
 763 }
 764 
 765 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 766   if (is_HotSpotJVMCIRuntime_initialized()) {
 767     if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {
 768       JVMCI_THROW_MSG(InternalError, "JVMCI has already been enabled in the JVMCI shared library");
 769     }
 770   }
 771 
 772   initialize(JVMCIENV);
 773 
 774   // This should only be called in the context of the JVMCI class being initialized
 775   JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
 776 
 777   _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);
 778 }
 779 
 780 void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {
 781   assert(this != NULL, "sanity");
 782   // Check first without JVMCI_lock
 783   if (_initialized) {
 784     return;
 785   }
 786 
 787   MutexLocker locker(JVMCI_lock);
 788   // Check again under JVMCI_lock
 789   if (_initialized) {
 790     return;
 791   }
 792 
 793   while (_being_initialized) {
 794     JVMCI_lock-&gt;wait();
 795     if (_initialized) {
 796       return;
 797     }
 798   }
 799 
 800   _being_initialized = true;
 801 
 802   {
 803     MutexUnlocker unlock(JVMCI_lock);
 804 
 805     HandleMark hm;
 806     ResourceMark rm;
 807     JavaThread* THREAD = JavaThread::current();
 808     if (JVMCIENV-&gt;is_hotspot()) {
 809       HotSpotJVMCI::compute_offsets(CHECK_EXIT);
 810     } else {
 811       JNIAccessMark jni(JVMCIENV);
 812 
 813       JNIJVMCI::initialize_ids(jni.env());
 814       if (jni()-&gt;ExceptionCheck()) {
 815         jni()-&gt;ExceptionDescribe();
 816         fatal("JNI exception during init");
 817       }
 818     }
 819     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));
 820     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));
 821     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));
 822     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));
 823     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));
 824     create_jvmci_primitive_type(T_LONG, JVMCI_CHECK_EXIT_((void)0));
 825     create_jvmci_primitive_type(T_FLOAT, JVMCI_CHECK_EXIT_((void)0));
 826     create_jvmci_primitive_type(T_DOUBLE, JVMCI_CHECK_EXIT_((void)0));
 827     create_jvmci_primitive_type(T_VOID, JVMCI_CHECK_EXIT_((void)0));
 828 
 829     if (!JVMCIENV-&gt;is_hotspot()) {
 830       JVMCIENV-&gt;copy_saved_properties();
 831     }
 832   }
 833 
 834   _initialized = true;
 835   _being_initialized = false;
 836   JVMCI_lock-&gt;notify_all();
 837 }
 838 
 839 JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
 840   Thread* THREAD = Thread::current();
 841   // These primitive types are long lived and are created before the runtime is fully set up
 842   // so skip registering them for scanning.
 843   JVMCIObject mirror = JVMCIENV-&gt;get_object_constant(java_lang_Class::primitive_mirror(type), false, true);
 844   if (JVMCIENV-&gt;is_hotspot()) {
 845     JavaValue result(T_OBJECT);
 846     JavaCallArguments args;
 847     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(mirror)));
 848     args.push_int(type2char(type));
 849     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedPrimitiveType::klass(), vmSymbols::fromMetaspace_name(), vmSymbols::primitive_fromMetaspace_signature(), &amp;args, CHECK_(JVMCIObject()));
 850 
 851     return JVMCIENV-&gt;wrap(JNIHandles::make_local((oop)result.get_jobject()));
 852   } else {
 853     JNIAccessMark jni(JVMCIENV);
 854     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedPrimitiveType::clazz(),
 855                                            JNIJVMCI::HotSpotResolvedPrimitiveType_fromMetaspace_method(),
 856                                            mirror.as_jobject(), type2char(type));
 857     if (jni()-&gt;ExceptionCheck()) {
 858       return JVMCIObject();
 859     }
 860     return JVMCIENV-&gt;wrap(result);
 861   }
 862 }
 863 
 864 void JVMCIRuntime::initialize_JVMCI(JVMCI_TRAPS) {
 865   if (!is_HotSpotJVMCIRuntime_initialized()) {
 866     initialize(JVMCI_CHECK);
 867     JVMCIENV-&gt;call_JVMCI_getRuntime(JVMCI_CHECK);
 868   }
 869 }
 870 
 871 JVMCIObject JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 872   initialize(JVMCIENV);
 873   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
 874   return _HotSpotJVMCIRuntime_instance;
 875 }
 876 
 877 
 878 // private void CompilerToVM.registerNatives()
 879 JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
 880 
 881 #ifdef _LP64
 882 #ifndef TARGET_ARCH_sparc
 883   uintptr_t heap_end = (uintptr_t) Universe::heap()-&gt;reserved_region().end();
 884   uintptr_t allocation_end = heap_end + ((uintptr_t)16) * 1024 * 1024 * 1024;
 885   guarantee(heap_end &lt; allocation_end, "heap end too close to end of address space (might lead to erroneous TLAB allocations)");
 886 #endif // TARGET_ARCH_sparc
 887 #else
 888   fatal("check TLAB allocation code for address space conflicts");
 889 #endif
 890 
 891   JNI_JVMCIENV(thread, env);
 892 
 893   if (!EnableJVMCI) {
 894     JVMCI_THROW_MSG(InternalError, "JVMCI is not enabled");
 895   }
 896 
 897   JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
 898 
 899   {
 900     ResourceMark rm;
 901     HandleMark hm(thread);
 902     ThreadToNativeFromVM trans(thread);
 903 
 904     // Ensure _non_oop_bits is initialized
 905     Universe::non_oop_word();
 906 
 907     if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count())) {
 908       if (!env-&gt;ExceptionCheck()) {
 909         for (int i = 0; i &lt; CompilerToVM::methods_count(); i++) {
 910           if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods + i, 1)) {
 911             guarantee(false, "Error registering JNI method %s%s", CompilerToVM::methods[i].name, CompilerToVM::methods[i].signature);
 912             break;
 913           }
 914         }
 915       } else {
 916         env-&gt;ExceptionDescribe();
 917       }
 918       guarantee(false, "Failed registering CompilerToVM native methods");
 919     }
 920   }
 921 JVM_END
 922 
 923 
 924 void JVMCIRuntime::shutdown() {
 925   if (is_HotSpotJVMCIRuntime_initialized()) {
 926     _shutdown_called = true;
 927 
 928     THREAD_JVMCIENV(JavaThread::current());
 929     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);
 930   }
 931 }
 932 
 933 void JVMCIRuntime::bootstrap_finished(TRAPS) {
 934   if (is_HotSpotJVMCIRuntime_initialized()) {
 935     THREAD_JVMCIENV(JavaThread::current());
 936     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
 937   }
 938 }
 939 
 940 void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {
 941   if (HAS_PENDING_EXCEPTION) {
 942     Handle exception(THREAD, PENDING_EXCEPTION);
 943     const char* exception_file = THREAD-&gt;exception_file();
 944     int exception_line = THREAD-&gt;exception_line();
 945     CLEAR_PENDING_EXCEPTION;
 946     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 947       // Don't print anything if we are being killed.
 948     } else {
 949       java_lang_Throwable::print_stack_trace(exception, tty);
 950 
 951       // Clear and ignore any exceptions raised during printing
 952       CLEAR_PENDING_EXCEPTION;
 953     }
 954     if (!clear) {
 955       THREAD-&gt;set_pending_exception(exception(), exception_file, exception_line);
 956     }
 957   }
 958 }
 959 
 960 
 961 void JVMCIRuntime::exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message) {
 962   JavaThread* THREAD = JavaThread::current();
 963 
 964   static volatile int report_error = 0;
 965   if (!report_error &amp;&amp; Atomic::cmpxchg(1, &amp;report_error, 0) == 0) {
 966     // Only report an error once
 967     tty-&gt;print_raw_cr(message);
 968     if (JVMCIENV != NULL) {
 969       JVMCIENV-&gt;describe_pending_exception(true);
 970     } else {
 971       describe_pending_hotspot_exception(THREAD, true);
 972     }
 973   } else {
 974     // Allow error reporting thread to print the stack trace.  Windows
 975     // doesn't allow uninterruptible wait for JavaThreads
 976     const bool interruptible = true;
 977     os::sleep(THREAD, 200, interruptible);
 978   }
 979 
 980   before_exit(THREAD);
 981   vm_exit(-1);
 982 }
 983 
 984 // ------------------------------------------------------------------
 985 // Note: the logic of this method should mirror the logic of
 986 // constantPoolOopDesc::verify_constant_pool_resolve.
 987 bool JVMCIRuntime::check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass) {
 988   if (accessing_klass-&gt;is_objArray_klass()) {
 989     accessing_klass = ObjArrayKlass::cast(accessing_klass)-&gt;bottom_klass();
 990   }
 991   if (!accessing_klass-&gt;is_instance_klass()) {
 992     return true;
 993   }
 994 
 995   if (resolved_klass-&gt;is_objArray_klass()) {
 996     // Find the element klass, if this is an array.
 997     resolved_klass = ObjArrayKlass::cast(resolved_klass)-&gt;bottom_klass();
 998   }
 999   if (resolved_klass-&gt;is_instance_klass()) {
1000     Reflection::VerifyClassAccessResults result =
1001       Reflection::verify_class_access(accessing_klass, InstanceKlass::cast(resolved_klass), true);
1002     return result == Reflection::ACCESS_OK;
1003   }
1004   return true;
1005 }
1006 
1007 // ------------------------------------------------------------------
1008 Klass* JVMCIRuntime::get_klass_by_name_impl(Klass*&amp; accessing_klass,
1009                                           const constantPoolHandle&amp; cpool,
1010                                           Symbol* sym,
1011                                           bool require_local) {
1012   JVMCI_EXCEPTION_CONTEXT;
1013 
1014   // Now we need to check the SystemDictionary
1015   if (sym-&gt;byte_at(0) == 'L' &amp;&amp;
1016     sym-&gt;byte_at(sym-&gt;utf8_length()-1) == ';') {
1017     // This is a name from a signature.  Strip off the trimmings.
1018     // Call recursive to keep scope of strippedsym.
1019     TempNewSymbol strippedsym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
1020                     sym-&gt;utf8_length()-2,
1021                     CHECK_NULL);
1022     return get_klass_by_name_impl(accessing_klass, cpool, strippedsym, require_local);
1023   }
1024 
1025   Handle loader(THREAD, (oop)NULL);
1026   Handle domain(THREAD, (oop)NULL);
1027   if (accessing_klass != NULL) {
1028     loader = Handle(THREAD, accessing_klass-&gt;class_loader());
1029     domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
1030   }
1031 
1032   Klass* found_klass;
1033   {
1034     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems
1035     MutexLocker ml(Compile_lock);
1036     if (!require_local) {
1037       found_klass = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, CHECK_NULL);
1038     } else {
1039       found_klass = SystemDictionary::find_instance_or_array_klass(sym, loader, domain, CHECK_NULL);
1040     }
1041   }
1042 
1043   // If we fail to find an array klass, look again for its element type.
1044   // The element type may be available either locally or via constraints.
1045   // In either case, if we can find the element type in the system dictionary,
1046   // we must build an array type around it.  The CI requires array klasses
1047   // to be loaded if their element klasses are loaded, except when memory
1048   // is exhausted.
1049   if (sym-&gt;byte_at(0) == '[' &amp;&amp;
1050       (sym-&gt;byte_at(1) == '[' || sym-&gt;byte_at(1) == 'L')) {
1051     // We have an unloaded array.
1052     // Build it on the fly if the element class exists.
1053     TempNewSymbol elem_sym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
1054                                                  sym-&gt;utf8_length()-1,
1055                                                  CHECK_NULL);
1056 
1057     // Get element Klass recursively.
1058     Klass* elem_klass =
1059       get_klass_by_name_impl(accessing_klass,
1060                              cpool,
1061                              elem_sym,
1062                              require_local);
1063     if (elem_klass != NULL) {
1064       // Now make an array for it
1065       return elem_klass-&gt;array_klass(CHECK_NULL);
1066     }
1067   }
1068 
1069   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {
1070     // Look inside the constant pool for pre-resolved class entries.
1071     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {
1072       if (cpool-&gt;tag_at(i).is_klass()) {
1073         Klass*  kls = cpool-&gt;resolved_klass_at(i);
1074         if (kls-&gt;name() == sym) {
1075           return kls;
1076         }
1077       }
1078     }
1079   }
1080 
1081   return found_klass;
1082 }
1083 
1084 // ------------------------------------------------------------------
1085 Klass* JVMCIRuntime::get_klass_by_name(Klass* accessing_klass,
1086                                   Symbol* klass_name,
1087                                   bool require_local) {
1088   ResourceMark rm;
1089   constantPoolHandle cpool;
1090   return get_klass_by_name_impl(accessing_klass,
1091                                                  cpool,
1092                                                  klass_name,
1093                                                  require_local);
1094 }
1095 
1096 // ------------------------------------------------------------------
1097 // Implementation of get_klass_by_index.
1098 Klass* JVMCIRuntime::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
1099                                         int index,
1100                                         bool&amp; is_accessible,
1101                                         Klass* accessor) {
1102   JVMCI_EXCEPTION_CONTEXT;
1103   Klass* klass = ConstantPool::klass_at_if_loaded(cpool, index);
1104   Symbol* klass_name = NULL;
1105   if (klass == NULL) {
1106     klass_name = cpool-&gt;klass_name_at(index);
1107   }
1108 
1109   if (klass == NULL) {
1110     // Not found in constant pool.  Use the name to do the lookup.
1111     Klass* k = get_klass_by_name_impl(accessor,
1112                                         cpool,
1113                                         klass_name,
1114                                         false);
1115     // Calculate accessibility the hard way.
1116     if (k == NULL) {
1117       is_accessible = false;
1118     } else if (k-&gt;class_loader() != accessor-&gt;class_loader() &amp;&amp;
1119                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {
1120       // Loaded only remotely.  Not linked yet.
1121       is_accessible = false;
1122     } else {
1123       // Linked locally, and we must also check public/private, etc.
1124       is_accessible = check_klass_accessibility(accessor, k);
1125     }
1126     if (!is_accessible) {
1127       return NULL;
1128     }
1129     return k;
1130   }
1131 
1132   // It is known to be accessible, since it was found in the constant pool.
1133   is_accessible = true;
1134   return klass;
1135 }
1136 
1137 // ------------------------------------------------------------------
1138 // Get a klass from the constant pool.
1139 Klass* JVMCIRuntime::get_klass_by_index(const constantPoolHandle&amp; cpool,
1140                                    int index,
1141                                    bool&amp; is_accessible,
1142                                    Klass* accessor) {
1143   ResourceMark rm;
1144   Klass* result = get_klass_by_index_impl(cpool, index, is_accessible, accessor);
1145   return result;
1146 }
1147 
1148 // ------------------------------------------------------------------
1149 // Implementation of get_field_by_index.
1150 //
1151 // Implementation note: the results of field lookups are cached
1152 // in the accessor klass.
1153 void JVMCIRuntime::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor&amp; field_desc,
1154                                         int index) {
1155   JVMCI_EXCEPTION_CONTEXT;
1156 
1157   assert(klass-&gt;is_linked(), "must be linked before using its constant-pool");
1158 
1159   constantPoolHandle cpool(thread, klass-&gt;constants());
1160 
1161   // Get the field's name, signature, and type.
1162   Symbol* name  = cpool-&gt;name_ref_at(index);
1163 
1164   int nt_index = cpool-&gt;name_and_type_ref_index_at(index);
1165   int sig_index = cpool-&gt;signature_ref_index_at(nt_index);
1166   Symbol* signature = cpool-&gt;symbol_at(sig_index);
1167 
1168   // Get the field's declared holder.
1169   int holder_index = cpool-&gt;klass_ref_index_at(index);
1170   bool holder_is_accessible;
1171   Klass* declared_holder = get_klass_by_index(cpool, holder_index,
1172                                                holder_is_accessible,
1173                                                klass);
1174 
1175   // The declared holder of this field may not have been loaded.
1176   // Bail out with partial field information.
1177   if (!holder_is_accessible) {
1178     return;
1179   }
1180 
1181 
1182   // Perform the field lookup.
1183   Klass*  canonical_holder =
1184     InstanceKlass::cast(declared_holder)-&gt;find_field(name, signature, &amp;field_desc);
1185   if (canonical_holder == NULL) {
1186     return;
1187   }
1188 
1189   assert(canonical_holder == field_desc.field_holder(), "just checking");
1190 }
1191 
1192 // ------------------------------------------------------------------
1193 // Get a field by index from a klass's constant pool.
1194 void JVMCIRuntime::get_field_by_index(InstanceKlass* accessor, fieldDescriptor&amp; fd, int index) {
1195   ResourceMark rm;
1196   return get_field_by_index_impl(accessor, fd, index);
1197 }
1198 
1199 // ------------------------------------------------------------------
1200 // Perform an appropriate method lookup based on accessor, holder,
1201 // name, signature, and bytecode.
1202 methodHandle JVMCIRuntime::lookup_method(InstanceKlass* accessor,
1203                                Klass*        holder,
1204                                Symbol*       name,
1205                                Symbol*       sig,
1206                                Bytecodes::Code bc,
1207                                constantTag   tag) {
1208   // Accessibility checks are performed in JVMCIEnv::get_method_by_index_impl().
1209   assert(check_klass_accessibility(accessor, holder), "holder not accessible");
1210 
1211   methodHandle dest_method;
1212   LinkInfo link_info(holder, name, sig, accessor, LinkInfo::needs_access_check, tag);
1213   switch (bc) {
1214   case Bytecodes::_invokestatic:
1215     dest_method =
1216       LinkResolver::resolve_static_call_or_null(link_info);
1217     break;
1218   case Bytecodes::_invokespecial:
1219     dest_method =
1220       LinkResolver::resolve_special_call_or_null(link_info);
1221     break;
1222   case Bytecodes::_invokeinterface:
1223     dest_method =
1224       LinkResolver::linktime_resolve_interface_method_or_null(link_info);
1225     break;
1226   case Bytecodes::_invokevirtual:
1227     dest_method =
1228       LinkResolver::linktime_resolve_virtual_method_or_null(link_info);
1229     break;
1230   default: ShouldNotReachHere();
1231   }
1232 
1233   return dest_method;
1234 }
1235 
1236 
1237 // ------------------------------------------------------------------
1238 methodHandle JVMCIRuntime::get_method_by_index_impl(const constantPoolHandle&amp; cpool,
1239                                           int index, Bytecodes::Code bc,
1240                                           InstanceKlass* accessor) {
1241   if (bc == Bytecodes::_invokedynamic) {
1242     ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);
1243     bool is_resolved = !cpce-&gt;is_f1_null();
1244     if (is_resolved) {
1245       // Get the invoker Method* from the constant pool.
1246       // (The appendix argument, if any, will be noted in the method's signature.)
1247       Method* adapter = cpce-&gt;f1_as_method();
1248       return methodHandle(adapter);
1249     }
1250 
1251     return NULL;
1252   }
1253 
1254   int holder_index = cpool-&gt;klass_ref_index_at(index);
1255   bool holder_is_accessible;
1256   Klass* holder = get_klass_by_index_impl(cpool, holder_index, holder_is_accessible, accessor);
1257 
1258   // Get the method's name and signature.
1259   Symbol* name_sym = cpool-&gt;name_ref_at(index);
1260   Symbol* sig_sym  = cpool-&gt;signature_ref_at(index);
1261 
1262   if (cpool-&gt;has_preresolution()
1263       || ((holder == SystemDictionary::MethodHandle_klass() || holder == SystemDictionary::VarHandle_klass()) &amp;&amp;
1264           MethodHandles::is_signature_polymorphic_name(holder, name_sym))) {
1265     // Short-circuit lookups for JSR 292-related call sites.
1266     // That is, do not rely only on name-based lookups, because they may fail
1267     // if the names are not resolvable in the boot class loader (7056328).
1268     switch (bc) {
1269     case Bytecodes::_invokevirtual:
1270     case Bytecodes::_invokeinterface:
1271     case Bytecodes::_invokespecial:
1272     case Bytecodes::_invokestatic:
1273       {
1274         Method* m = ConstantPool::method_at_if_loaded(cpool, index);
1275         if (m != NULL) {
1276           return m;
1277         }
1278       }
1279       break;
1280     default:
1281       break;
1282     }
1283   }
1284 
1285   if (holder_is_accessible) { // Our declared holder is loaded.
1286     constantTag tag = cpool-&gt;tag_ref_at(index);
1287     methodHandle m = lookup_method(accessor, holder, name_sym, sig_sym, bc, tag);
1288     if (!m.is_null()) {
1289       // We found the method.
1290       return m;
1291     }
1292   }
1293 
1294   // Either the declared holder was not loaded, or the method could
1295   // not be found.
1296 
1297   return NULL;
1298 }
1299 
1300 // ------------------------------------------------------------------
1301 InstanceKlass* JVMCIRuntime::get_instance_klass_for_declared_method_holder(Klass* method_holder) {
1302   // For the case of &lt;array&gt;.clone(), the method holder can be an ArrayKlass*
1303   // instead of an InstanceKlass*.  For that case simply pretend that the
1304   // declared holder is Object.clone since that's where the call will bottom out.
1305   if (method_holder-&gt;is_instance_klass()) {
1306     return InstanceKlass::cast(method_holder);
1307   } else if (method_holder-&gt;is_array_klass()) {
1308     return InstanceKlass::cast(SystemDictionary::Object_klass());
1309   } else {
1310     ShouldNotReachHere();
1311   }
1312   return NULL;
1313 }
1314 
1315 
1316 // ------------------------------------------------------------------
1317 methodHandle JVMCIRuntime::get_method_by_index(const constantPoolHandle&amp; cpool,
1318                                      int index, Bytecodes::Code bc,
1319                                      InstanceKlass* accessor) {
1320   ResourceMark rm;
1321   return get_method_by_index_impl(cpool, index, bc, accessor);
1322 }
1323 
1324 // ------------------------------------------------------------------
1325 // Check for changes to the system dictionary during compilation
1326 // class loads, evolution, breakpoints
1327 JVMCI::CodeInstallResult JVMCIRuntime::validate_compile_task_dependencies(Dependencies* dependencies, JVMCICompileState* compile_state, char** failure_detail) {
1328   // If JVMTI capabilities were enabled during compile, the compilation is invalidated.
1329   if (compile_state != NULL &amp;&amp; compile_state-&gt;jvmti_state_changed()) {
1330     *failure_detail = (char*) "Jvmti state change during compilation invalidated dependencies";
1331     return JVMCI::dependencies_failed;
1332   }
1333 
1334   // Dependencies must be checked when the system dictionary changes
1335   // or if we don't know whether it has changed (i.e., compile_state == NULL).
1336   bool counter_changed = compile_state == NULL || compile_state-&gt;system_dictionary_modification_counter() != SystemDictionary::number_of_modifications();
1337   CompileTask* task = compile_state == NULL ? NULL : compile_state-&gt;task();
1338   Dependencies::DepType result = dependencies-&gt;validate_dependencies(task, counter_changed, failure_detail);
1339   if (result == Dependencies::end_marker) {
1340     return JVMCI::ok;
1341   }
1342 
1343   if (!Dependencies::is_klass_type(result) || counter_changed) {
1344     return JVMCI::dependencies_failed;
1345   }
1346   // The dependencies were invalid at the time of installation
1347   // without any intervening modification of the system
1348   // dictionary.  That means they were invalidly constructed.
1349   return JVMCI::dependencies_invalid;
1350 }
1351 
1352 // Reports a pending exception and exits the VM.
1353 static void fatal_exception_in_compile(JVMCIEnv* JVMCIENV, JavaThread* thread, const char* msg) {
1354   // Only report a fatal JVMCI compilation exception once
1355   static volatile int report_init_failure = 0;
1356   if (!report_init_failure &amp;&amp; Atomic::cmpxchg(1, &amp;report_init_failure, 0) == 0) {
1357       tty-&gt;print_cr("%s:", msg);
1358       JVMCIENV-&gt;describe_pending_exception(true);
1359   }
1360   JVMCIENV-&gt;clear_pending_exception();
1361   before_exit(thread);
1362   vm_exit(-1);
1363 }
1364 
1365 void JVMCIRuntime::compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; method, int entry_bci) {
1366   JVMCI_EXCEPTION_CONTEXT
1367 
1368   JVMCICompileState* compile_state = JVMCIENV-&gt;compile_state();
1369 
1370   bool is_osr = entry_bci != InvocationEntryBci;
1371   if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {
1372     // no OSR compilations during bootstrap - the compiler is just too slow at this point,
1373     // and we know that there are no endless loops
1374     compile_state-&gt;set_failure(true, "No OSR during boostrap");
1375     return;
1376   }
1377   if (JVMCI::shutdown_called()) {
1378     compile_state-&gt;set_failure(false, "Avoiding compilation during shutdown");
1379     return;
1380   }
1381 
1382   HandleMark hm;
1383   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);
1384   if (JVMCIENV-&gt;has_pending_exception()) {
1385     fatal_exception_in_compile(JVMCIENV, thread, "Exception during HotSpotJVMCIRuntime initialization");
1386   }
1387   JVMCIObject jvmci_method = JVMCIENV-&gt;get_jvmci_method(method, JVMCIENV);
1388   if (JVMCIENV-&gt;has_pending_exception()) {
1389     JVMCIENV-&gt;describe_pending_exception(true);
1390     compile_state-&gt;set_failure(false, "exception getting JVMCI wrapper method");
1391     return;
1392   }
1393 
1394   JVMCIObject result_object = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_compileMethod(receiver, jvmci_method, entry_bci,
1395                                                                      (jlong) compile_state, compile_state-&gt;task()-&gt;compile_id());
1396   if (!JVMCIENV-&gt;has_pending_exception()) {
1397     if (result_object.is_non_null()) {
1398       JVMCIObject failure_message = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_failureMessage(result_object);
1399       if (failure_message.is_non_null()) {
1400         // Copy failure reason into resource memory first ...
1401         const char* failure_reason = JVMCIENV-&gt;as_utf8_string(failure_message);
1402         // ... and then into the C heap.
1403         failure_reason = os::strdup(failure_reason, mtJVMCI);
1404         bool retryable = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_retry(result_object) != 0;
1405         compile_state-&gt;set_failure(retryable, failure_reason, true);
1406       } else {
1407         if (compile_state-&gt;task()-&gt;code() == NULL) {
1408           compile_state-&gt;set_failure(true, "no nmethod produced");
1409         } else {
1410           compile_state-&gt;task()-&gt;set_num_inlined_bytecodes(JVMCIENV-&gt;get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));
1411           compiler-&gt;inc_methods_compiled();
1412         }
1413       }
1414     } else {
1415       assert(false, "JVMCICompiler.compileMethod should always return non-null");
1416     }
1417   } else {
1418     // An uncaught exception here implies failure during compiler initialization.
1419     // The only sensible thing to do here is to exit the VM.
1420     fatal_exception_in_compile(JVMCIENV, thread, "Exception during JVMCI compiler initialization");
1421   }
1422   if (compiler-&gt;is_bootstrapping()) {
1423     compiler-&gt;set_bootstrap_compilation_request_handled();
1424   }
1425 }
1426 
1427 
1428 // ------------------------------------------------------------------
1429 JVMCI::CodeInstallResult JVMCIRuntime::register_method(JVMCIEnv* JVMCIENV,
1430                                 const methodHandle&amp; method,
1431                                 nmethod*&amp; nm,
1432                                 int entry_bci,
1433                                 CodeOffsets* offsets,
1434                                 int orig_pc_offset,
1435                                 CodeBuffer* code_buffer,
1436                                 int frame_words,
1437                                 OopMapSet* oop_map_set,
1438                                 ExceptionHandlerTable* handler_table,
1439                                 ImplicitExceptionTable* implicit_exception_table,
1440                                 AbstractCompiler* compiler,
1441                                 DebugInformationRecorder* debug_info,
1442                                 Dependencies* dependencies,
1443                                 int compile_id,
1444                                 bool has_unsafe_access,
1445                                 bool has_wide_vector,
1446                                 JVMCIObject compiled_code,
1447                                 JVMCIObject nmethod_mirror,
1448                                 FailedSpeculation** failed_speculations,
1449                                 char* speculations,
1450                                 int speculations_len) {
1451   JVMCI_EXCEPTION_CONTEXT;
1452   nm = NULL;
1453   int comp_level = CompLevel_full_optimization;
1454   char* failure_detail = NULL;
1455 
1456   bool install_default = JVMCIENV-&gt;get_HotSpotNmethod_isDefault(nmethod_mirror) != 0;
1457   assert(JVMCIENV-&gt;isa_HotSpotNmethod(nmethod_mirror), "must be");
1458   JVMCIObject name = JVMCIENV-&gt;get_InstalledCode_name(nmethod_mirror);
1459   const char* nmethod_mirror_name = name.is_null() ? NULL : JVMCIENV-&gt;as_utf8_string(name);
1460   int nmethod_mirror_index;
1461   if (!install_default) {
1462     // Reserve or initialize mirror slot in the oops table.
1463     OopRecorder* oop_recorder = debug_info-&gt;oop_recorder();
1464     nmethod_mirror_index = oop_recorder-&gt;allocate_oop_index(nmethod_mirror.is_hotspot() ? nmethod_mirror.as_jobject() : NULL);
1465   } else {
1466     // A default HotSpotNmethod mirror is never tracked by the nmethod
1467     nmethod_mirror_index = -1;
1468   }
1469 
1470   JVMCI::CodeInstallResult result;
1471   {
1472     // To prevent compile queue updates.
1473     MutexLocker locker(MethodCompileQueue_lock, THREAD);
1474 
1475     // Prevent SystemDictionary::add_to_hierarchy from running
1476     // and invalidating our dependencies until we install this method.
1477     MutexLocker ml(Compile_lock);
1478 
1479     // Encode the dependencies now, so we can check them right away.
1480     dependencies-&gt;encode_content_bytes();
1481 
1482     // Record the dependencies for the current compile in the log
1483     if (LogCompilation) {
1484       for (Dependencies::DepStream deps(dependencies); deps.next(); ) {
1485         deps.log_dependency();
1486       }
1487     }
1488 
1489     // Check for {class loads, evolution, breakpoints} during compilation
1490     result = validate_compile_task_dependencies(dependencies, JVMCIENV-&gt;compile_state(), &amp;failure_detail);
1491     if (result != JVMCI::ok) {
1492       // While not a true deoptimization, it is a preemptive decompile.
1493       MethodData* mdp = method()-&gt;method_data();
1494       if (mdp != NULL) {
1495         mdp-&gt;inc_decompile_count();
1496 #ifdef ASSERT
1497         if (mdp-&gt;decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
1498           ResourceMark m;
1499           tty-&gt;print_cr("WARN: endless recompilation of %s. Method was set to not compilable.", method()-&gt;name_and_sig_as_C_string());
1500         }
1501 #endif
1502       }
1503 
1504       // All buffers in the CodeBuffer are allocated in the CodeCache.
1505       // If the code buffer is created on each compile attempt
1506       // as in C2, then it must be freed.
1507       //code_buffer-&gt;free_blob();
1508     } else {
1509       nm =  nmethod::new_nmethod(method,
1510                                  compile_id,
1511                                  entry_bci,
1512                                  offsets,
1513                                  orig_pc_offset,
1514                                  debug_info, dependencies, code_buffer,
1515                                  frame_words, oop_map_set,
1516                                  handler_table, implicit_exception_table,
1517                                  compiler, comp_level,
1518                                  speculations, speculations_len,
1519                                  nmethod_mirror_index, nmethod_mirror_name, failed_speculations);
1520 
1521 
1522       // Free codeBlobs
1523       if (nm == NULL) {
1524         // The CodeCache is full.  Print out warning and disable compilation.
1525         {
1526           MutexUnlocker ml(Compile_lock);
1527           MutexUnlocker locker(MethodCompileQueue_lock);
1528           CompileBroker::handle_full_code_cache(CodeCache::get_code_blob_type(comp_level));
1529         }
1530       } else {
1531         nm-&gt;set_has_unsafe_access(has_unsafe_access);
1532         nm-&gt;set_has_wide_vectors(has_wide_vector);
1533 
1534         // Record successful registration.
1535         // (Put nm into the task handle *before* publishing to the Java heap.)
1536         if (JVMCIENV-&gt;compile_state() != NULL) {
1537           JVMCIENV-&gt;compile_state()-&gt;task()-&gt;set_code(nm);
1538         }
1539 
1540         JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
1541         assert(data != NULL, "must be");
1542         if (install_default) {
1543           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == NULL, "must be");
1544           if (entry_bci == InvocationEntryBci) {
1545             if (TieredCompilation) {
1546               // If there is an old version we're done with it
1547               CompiledMethod* old = method-&gt;code();
1548               if (TraceMethodReplacement &amp;&amp; old != NULL) {
1549                 ResourceMark rm;
1550                 char *method_name = method-&gt;name_and_sig_as_C_string();
1551                 tty-&gt;print_cr("Replacing method %s", method_name);
1552               }
1553               if (old != NULL ) {
1554                 old-&gt;make_not_entrant();
1555               }
1556             }
1557             if (TraceNMethodInstalls) {
1558               ResourceMark rm;
1559               char *method_name = method-&gt;name_and_sig_as_C_string();
1560               ttyLocker ttyl;
1561               tty-&gt;print_cr("Installing method (%d) %s [entry point: %p]",
1562                             comp_level,
1563                             method_name, nm-&gt;entry_point());
1564             }
1565             // Allow the code to be executed
1566             method-&gt;set_code(method, nm);
1567           } else {
1568             if (TraceNMethodInstalls ) {
1569               ResourceMark rm;
1570               char *method_name = method-&gt;name_and_sig_as_C_string();
1571               ttyLocker ttyl;
1572               tty-&gt;print_cr("Installing osr method (%d) %s @ %d",
1573                             comp_level,
1574                             method_name,
1575                             entry_bci);
1576             }
1577             InstanceKlass::cast(method-&gt;method_holder())-&gt;add_osr_nmethod(nm);
1578           }
1579         } else {
1580           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == HotSpotJVMCI::resolve(nmethod_mirror), "must be");
1581         }
1582         nm-&gt;make_in_use();
1583       }
1584       result = nm != NULL ? JVMCI::ok :JVMCI::cache_full;
1585     }
1586   }
1587 
1588   // String creation must be done outside lock
1589   if (failure_detail != NULL) {
1590     // A failure to allocate the string is silently ignored.
1591     JVMCIObject message = JVMCIENV-&gt;create_string(failure_detail, JVMCIENV);
1592     JVMCIENV-&gt;set_HotSpotCompiledNmethod_installationFailureMessage(compiled_code, message);
1593   }
1594 
1595   // JVMTI -- compiled method notification (must be done outside lock)
1596   if (nm != NULL) {
1597     nm-&gt;post_compiled_method_load_event();
1598   }
1599 
1600   return result;
1601 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="4" type="hidden" /></form></body></html>
