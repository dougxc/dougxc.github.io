<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/hotspot/share/prims/jni.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include "precompiled.hpp"
  27 #include "jni.h"
  28 #include "jvm.h"
  29 #include "ci/ciReplay.hpp"
  30 #include "classfile/altHashing.hpp"
  31 #include "classfile/classFileStream.hpp"
  32 #include "classfile/classLoader.hpp"
  33 #include "classfile/javaClasses.hpp"
  34 #include "classfile/javaClasses.inline.hpp"
  35 #include "classfile/modules.hpp"
  36 #include "classfile/symbolTable.hpp"
  37 #include "classfile/systemDictionary.hpp"
  38 #include "classfile/vmSymbols.hpp"
  39 #include "gc/shared/gcLocker.inline.hpp"
  40 #include "interpreter/linkResolver.hpp"
  41 #include "memory/allocation.hpp"
  42 #include "memory/allocation.inline.hpp"
  43 #include "memory/oopFactory.hpp"
  44 #include "memory/resourceArea.hpp"
  45 #include "memory/universe.inline.hpp"
  46 #include "oops/instanceKlass.hpp"
  47 #include "oops/instanceOop.hpp"
  48 #include "oops/markOop.hpp"
  49 #include "oops/method.hpp"
  50 #include "oops/objArrayKlass.hpp"
  51 #include "oops/objArrayOop.inline.hpp"
  52 #include "oops/oop.inline.hpp"
  53 #include "oops/symbol.hpp"
  54 #include "oops/typeArrayKlass.hpp"
  55 #include "oops/typeArrayOop.hpp"
  56 #include "prims/jniCheck.hpp"
  57 #include "prims/jniExport.hpp"
  58 #include "prims/jniFastGetField.hpp"
  59 #include "prims/jvm_misc.hpp"
  60 #include "prims/jvmtiExport.hpp"
  61 #include "prims/jvmtiThreadState.hpp"
  62 #include "runtime/atomic.hpp"
  63 #include "runtime/compilationPolicy.hpp"
  64 #include "runtime/fieldDescriptor.hpp"
  65 #include "runtime/handles.inline.hpp"
  66 #include "runtime/interfaceSupport.hpp"
  67 #include "runtime/java.hpp"
  68 #include "runtime/javaCalls.hpp"
  69 #include "runtime/jfieldIDWorkaround.hpp"
  70 #include "runtime/orderAccess.inline.hpp"
  71 #include "runtime/reflection.hpp"
  72 #include "runtime/sharedRuntime.hpp"
  73 #include "runtime/signature.hpp"
  74 #include "runtime/thread.inline.hpp"
  75 #include "runtime/vm_operations.hpp"
  76 #include "services/memTracker.hpp"
  77 #include "services/runtimeService.hpp"
  78 #include "trace/traceMacros.hpp"
  79 #include "trace/tracing.hpp"
  80 #include "utilities/defaultStream.hpp"
  81 #include "utilities/dtrace.hpp"
  82 #include "utilities/events.hpp"
  83 #include "utilities/histogram.hpp"
  84 #include "utilities/internalVMTests.hpp"
  85 #include "utilities/macros.hpp"
  86 #include "utilities/vmError.hpp"
  87 #if INCLUDE_ALL_GCS
  88 #include "gc/g1/g1SATBCardTableModRefBS.hpp"
  89 #endif // INCLUDE_ALL_GCS
  90 #if INCLUDE_JVMCI
  91 #include "jvmci/jvmciCompiler.hpp"
  92 #include "jvmci/jvmciRuntime.hpp"
  93 #endif
  94 
  95 static jint CurrentVersion = JNI_VERSION_10;
  96 
  97 #ifdef _WIN32
  98 extern LONG WINAPI topLevelExceptionFilter(_EXCEPTION_POINTERS* );
  99 #endif
 100 
 101 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
 102 // '-return' probe regardless of the return path is taken out of the function.
 103 // Methods that have multiple return paths use this to avoid having to
 104 // instrument each return path.  Methods that use CHECK or THROW must use this
 105 // since those macros can cause an immedate uninstrumented return.
 106 //
 107 // In order to get the return value, a reference to the variable containing
 108 // the return value must be passed to the contructor of the object, and
 109 // the return value must be set before return (since the mark object has
 110 // a reference to it).
 111 //
 112 // Example:
 113 // DT_RETURN_MARK_DECL(SomeFunc, int);
 114 // JNI_ENTRY(int, SomeFunc, ...)
 115 //   int return_value = 0;
 116 //   DT_RETURN_MARK(SomeFunc, int, (const int&amp;)return_value);
 117 //   foo(CHECK_0)
 118 //   return_value = 5;
 119 //   return return_value;
 120 // JNI_END
 121 #define DT_RETURN_MARK_DECL(name, type, probe)                             \
 122   DTRACE_ONLY(                                                             \
 123     class DTraceReturnProbeMark_##name {                                   \
 124      public:                                                               \
 125       const type&amp; _ret_ref;                                                \
 126       DTraceReturnProbeMark_##name(const type&amp; v) : _ret_ref(v) {}         \
 127       ~DTraceReturnProbeMark_##name() {                                    \
 128         probe;                                                             \
 129       }                                                                    \
 130     }                                                                      \
 131   )
 132 // Void functions are simpler since there's no return value
 133 #define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
 134   DTRACE_ONLY(                                                             \
 135     class DTraceReturnProbeMark_##name {                                   \
 136      public:                                                               \
 137       ~DTraceReturnProbeMark_##name() {                                    \
 138         probe;                                                             \
 139       }                                                                    \
 140     }                                                                      \
 141   )
 142 
 143 // Place these macros in the function to mark the return.  Non-void
 144 // functions need the type and address of the return value.
 145 #define DT_RETURN_MARK(name, type, ref) \
 146   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark(ref) )
 147 #define DT_VOID_RETURN_MARK(name) \
 148   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark )
 149 
 150 
 151 // Use these to select distinct code for floating-point vs. non-floating point
 152 // situations.  Used from within common macros where we need slightly
 153 // different behavior for Float/Double
 154 #define FP_SELECT_Boolean(intcode, fpcode) intcode
 155 #define FP_SELECT_Byte(intcode, fpcode)    intcode
 156 #define FP_SELECT_Char(intcode, fpcode)    intcode
 157 #define FP_SELECT_Short(intcode, fpcode)   intcode
 158 #define FP_SELECT_Object(intcode, fpcode)  intcode
 159 #define FP_SELECT_Int(intcode, fpcode)     intcode
 160 #define FP_SELECT_Long(intcode, fpcode)    intcode
 161 #define FP_SELECT_Float(intcode, fpcode)   fpcode
 162 #define FP_SELECT_Double(intcode, fpcode)  fpcode
 163 #define FP_SELECT(TypeName, intcode, fpcode) \
 164   FP_SELECT_##TypeName(intcode, fpcode)
 165 
 166 // Choose DT_RETURN_MARK macros  based on the type: float/double -&gt; void
 167 // (dtrace doesn't do FP yet)
 168 #define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
 169   FP_SELECT(TypeName, \
 170     DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
 171 #define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
 172   FP_SELECT(TypeName, \
 173     DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )
 174 
 175 
 176 // out-of-line helpers for class jfieldIDWorkaround:
 177 
 178 bool jfieldIDWorkaround::is_valid_jfieldID(Klass* k, jfieldID id) {
 179   if (jfieldIDWorkaround::is_instance_jfieldID(k, id)) {
 180     uintptr_t as_uint = (uintptr_t) id;
 181     intptr_t offset = raw_instance_offset(id);
 182     if (is_checked_jfieldID(id)) {
 183       if (!klass_hash_ok(k, id)) {
 184         return false;
 185       }
 186     }
 187     return InstanceKlass::cast(k)-&gt;contains_field_offset(offset);
 188   } else {
 189     JNIid* result = (JNIid*) id;
 190 #ifdef ASSERT
 191     return result != NULL &amp;&amp; result-&gt;is_static_field_id();
 192 #else
 193     return result != NULL;
 194 #endif
 195   }
 196 }
 197 
 198 
 199 intptr_t jfieldIDWorkaround::encode_klass_hash(Klass* k, intptr_t offset) {
 200   if (offset &lt;= small_offset_mask) {
 201     Klass* field_klass = k;
 202     Klass* super_klass = field_klass-&gt;super();
 203     // With compressed oops the most super class with nonstatic fields would
 204     // be the owner of fields embedded in the header.
 205     while (InstanceKlass::cast(super_klass)-&gt;has_nonstatic_fields() &amp;&amp;
 206            InstanceKlass::cast(super_klass)-&gt;contains_field_offset(offset)) {
 207       field_klass = super_klass;   // super contains the field also
 208       super_klass = field_klass-&gt;super();
 209     }
 210     debug_only(NoSafepointVerifier nosafepoint;)
 211     uintptr_t klass_hash = field_klass-&gt;identity_hash();
 212     return ((klass_hash &amp; klass_mask) &lt;&lt; klass_shift) | checked_mask_in_place;
 213   } else {
 214 #if 0
 215     #ifndef PRODUCT
 216     {
 217       ResourceMark rm;
 218       warning("VerifyJNIFields: long offset %d in %s", offset, k-&gt;external_name());
 219     }
 220     #endif
 221 #endif
 222     return 0;
 223   }
 224 }
 225 
 226 bool jfieldIDWorkaround::klass_hash_ok(Klass* k, jfieldID id) {
 227   uintptr_t as_uint = (uintptr_t) id;
 228   intptr_t klass_hash = (as_uint &gt;&gt; klass_shift) &amp; klass_mask;
 229   do {
 230     debug_only(NoSafepointVerifier nosafepoint;)
 231     // Could use a non-blocking query for identity_hash here...
 232     if ((k-&gt;identity_hash() &amp; klass_mask) == klass_hash)
 233       return true;
 234     k = k-&gt;super();
 235   } while (k != NULL);
 236   return false;
 237 }
 238 
 239 void jfieldIDWorkaround::verify_instance_jfieldID(Klass* k, jfieldID id) {
 240   guarantee(jfieldIDWorkaround::is_instance_jfieldID(k, id), "must be an instance field" );
 241   uintptr_t as_uint = (uintptr_t) id;
 242   intptr_t offset = raw_instance_offset(id);
 243   if (VerifyJNIFields) {
 244     if (is_checked_jfieldID(id)) {
 245       guarantee(klass_hash_ok(k, id),
 246     "Bug in native code: jfieldID class must match object");
 247     } else {
 248 #if 0
 249       #ifndef PRODUCT
 250       if (Verbose) {
 251   ResourceMark rm;
 252   warning("VerifyJNIFields: unverified offset %d for %s", offset, k-&gt;external_name());
 253       }
 254       #endif
 255 #endif
 256     }
 257   }
 258   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 259       "Bug in native code: jfieldID offset must address interior of object");
 260 }
 261 
 262 // Wrapper to trace JNI functions
 263 
 264 #ifdef ASSERT
 265   Histogram* JNIHistogram;
 266   static volatile int JNIHistogram_lock = 0;
 267 
 268   class JNIHistogramElement : public HistogramElement {
 269     public:
 270      JNIHistogramElement(const char* name);
 271   };
 272 
 273   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 274     _name = elementName;
 275     uintx count = 0;
 276 
 277     while (Atomic::cmpxchg(1, &amp;JNIHistogram_lock, 0) != 0) {
 278       while (OrderAccess::load_acquire(&amp;JNIHistogram_lock) != 0) {
 279         count +=1;
 280         if ( (WarnOnStalledSpinLock &gt; 0)
 281           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 282           warning("JNIHistogram_lock seems to be stalled");
 283         }
 284       }
 285      }
 286 
 287 
 288     if(JNIHistogram == NULL)
 289       JNIHistogram = new Histogram("JNI Call Counts",100);
 290 
 291     JNIHistogram-&gt;add_element(this);
 292     Atomic::dec(&amp;JNIHistogram_lock);
 293   }
 294 
 295   #define JNICountWrapper(arg)                                     \
 296      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 297       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 298      if (e != NULL) e-&gt;increment_count()
 299   #define JNIWrapper(arg) JNICountWrapper(arg);
 300 #else
 301   #define JNIWrapper(arg)
 302 #endif
 303 
 304 
 305 // Implementation of JNI entries
 306 
 307 DT_RETURN_MARK_DECL(DefineClass, jclass
 308                     , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));
 309 
 310 JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
 311                                   const jbyte *buf, jsize bufLen))
 312   JNIWrapper("DefineClass");
 313 
 314   HOTSPOT_JNI_DEFINECLASS_ENTRY(
 315     env, (char*) name, loaderRef, (char*) buf, bufLen);
 316 
 317   jclass cls = NULL;
 318   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 319 
 320   TempNewSymbol class_name = NULL;
 321   // Since exceptions can be thrown, class initialization can take place
 322   // if name is NULL no check for class name in .class stream has to be made.
 323   if (name != NULL) {
 324     const int str_len = (int)strlen(name);
 325     if (str_len &gt; Symbol::max_length()) {
 326       // It's impossible to create this class;  the name cannot fit
 327       // into the constant pool.
 328       Exceptions::fthrow(THREAD_AND_LOCATION,
 329                          vmSymbols::java_lang_NoClassDefFoundError(),
 330                          "Class name exceeds maximum length of %d: %s",
 331                          Symbol::max_length(),
 332                          name);
 333       return 0;
 334     }
 335     class_name = SymbolTable::new_symbol(name, CHECK_NULL);
 336   }
 337   ResourceMark rm(THREAD);
 338   ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
 339   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 340 
 341   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 342     // check whether the current caller thread holds the lock or not.
 343     // If not, increment the corresponding counter
 344     if (ObjectSynchronizer::
 345         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 346         ObjectSynchronizer::owner_self) {
 347       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 348     }
 349   }
 350   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 351                                                    class_loader,
 352                                                    Handle(),
 353                                                    &amp;st,
 354                                                    CHECK_NULL);
 355 
 356   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 357     trace_class_resolution(k);
 358   }
 359 
 360   cls = (jclass)JNIHandles::make_local(
 361     env, k-&gt;java_mirror());
 362   return cls;
 363 JNI_END
 364 
 365 
 366 
 367 static bool first_time_FindClass = true;
 368 
 369 DT_RETURN_MARK_DECL(FindClass, jclass
 370                     , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));
 371 
 372 JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
 373   JNIWrapper("FindClass");
 374 
 375   HOTSPOT_JNI_FINDCLASS_ENTRY(env, (char *)name);
 376 
 377   jclass result = NULL;
 378   DT_RETURN_MARK(FindClass, jclass, (const jclass&amp;)result);
 379 
 380   // Remember if we are the first invocation of jni_FindClass
 381   bool first_time = first_time_FindClass;
 382   first_time_FindClass = false;
 383 
 384   // Sanity check the name:  it cannot be null or larger than the maximum size
 385   // name we can fit in the constant pool.
 386   if (name == NULL) {
 387     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), "No class name given");
 388   }
 389   if ((int)strlen(name) &gt; Symbol::max_length()) {
 390     Exceptions::fthrow(THREAD_AND_LOCATION,
 391                        vmSymbols::java_lang_NoClassDefFoundError(),
 392                        "Class name exceeds maximum length of %d: %s",
 393                        Symbol::max_length(),
 394                        name);
 395     return 0;
 396   }
 397 
 398   //%note jni_3
 399   Handle protection_domain;
 400   // Find calling class
 401   Klass* k = thread-&gt;security_get_caller_class(0);
 402   // default to the system loader when no context
 403   Handle loader(THREAD, SystemDictionary::java_system_loader());
 404   if (k != NULL) {
 405     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 406     // in the correct class context.
 407     if (k-&gt;class_loader() == NULL &amp;&amp;
 408         k-&gt;name() == vmSymbols::java_lang_ClassLoader_NativeLibrary()) {
 409       JavaValue result(T_OBJECT);
 410       JavaCalls::call_static(&amp;result, k,
 411                              vmSymbols::getFromClass_name(),
 412                              vmSymbols::void_class_signature(),
 413                              CHECK_NULL);
 414       // When invoked from JNI_OnLoad, NativeLibrary::getFromClass returns
 415       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 416       // it will return NULL to indicate no context.
 417       oop mirror = (oop) result.get_jobject();
 418       if (mirror != NULL) {
 419         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 420         loader = Handle(THREAD, fromClass-&gt;class_loader());
 421         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 422       }
 423     } else {
 424       loader = Handle(THREAD, k-&gt;class_loader());
 425     }
 426   }
 427 
 428   TempNewSymbol sym = SymbolTable::new_symbol(name, CHECK_NULL);
 429   result = find_class_from_class_loader(env, sym, true, loader,
 430                                         protection_domain, true, thread);
 431 
 432   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 433     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 434   }
 435 
 436   // If we were the first invocation of jni_FindClass, we enable compilation again
 437   // rather than just allowing invocation counter to overflow and decay.
 438   // Controlled by flag DelayCompilationDuringStartup.
 439   if (first_time &amp;&amp; !CompileTheWorld)
 440     CompilationPolicy::completed_vm_startup();
 441 
 442   return result;
 443 JNI_END
 444 
 445 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 446                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 447 
 448 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 449   JNIWrapper("FromReflectedMethod");
 450 
 451   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 452 
 453   jmethodID ret = NULL;
 454   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
 455 
 456   // method is a handle to a java.lang.reflect.Method object
 457   oop reflected  = JNIHandles::resolve_non_null(method);
 458   oop mirror     = NULL;
 459   int slot       = 0;
 460 
 461   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 462     mirror = java_lang_reflect_Constructor::clazz(reflected);
 463     slot   = java_lang_reflect_Constructor::slot(reflected);
 464   } else {
 465     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(), "wrong type");
 466     mirror = java_lang_reflect_Method::clazz(reflected);
 467     slot   = java_lang_reflect_Method::slot(reflected);
 468   }
 469   Klass* k1 = java_lang_Class::as_Klass(mirror);
 470 
 471   // Make sure class is initialized before handing id's out to methods
 472   k1-&gt;initialize(CHECK_NULL);
 473   Method* m = InstanceKlass::cast(k1)-&gt;method_with_idnum(slot);
 474   ret = m==NULL? NULL : m-&gt;jmethod_id();  // return NULL if reflected method deleted
 475   return ret;
 476 JNI_END
 477 
 478 DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
 479                     , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));
 480 
 481 JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
 482   JNIWrapper("FromReflectedField");
 483 
 484   HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(env, field);
 485 
 486   jfieldID ret = NULL;
 487   DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&amp;)ret);
 488 
 489   // field is a handle to a java.lang.reflect.Field object
 490   oop reflected   = JNIHandles::resolve_non_null(field);
 491   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 492   Klass* k1       = java_lang_Class::as_Klass(mirror);
 493   int slot        = java_lang_reflect_Field::slot(reflected);
 494   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 495 
 496   // Make sure class is initialized before handing id's out to fields
 497   k1-&gt;initialize(CHECK_NULL);
 498 
 499   // First check if this is a static field
 500   if (modifiers &amp; JVM_ACC_STATIC) {
 501     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 502     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 503     assert(id != NULL, "corrupt Field object");
 504     debug_only(id-&gt;set_is_static_field_id();)
 505     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 506     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 507     return ret;
 508   }
 509 
 510   // The slot is the index of the field description in the field-array
 511   // The jfieldID is the offset of the field within the object
 512   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 513   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 514   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), "stay within object");
 515   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);
 516   return ret;
 517 JNI_END
 518 
 519 
 520 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 521                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 522 
 523 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 524   JNIWrapper("ToReflectedMethod");
 525 
 526   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 527 
 528   jobject ret = NULL;
 529   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 530 
 531   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 532   assert(m-&gt;is_static() == (isStatic != 0), "jni_ToReflectedMethod access flags doesn't match");
 533   oop reflection_method;
 534   if (m-&gt;is_initializer()) {
 535     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 536   } else {
 537     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 538   }
 539   ret = JNIHandles::make_local(env, reflection_method);
 540   return ret;
 541 JNI_END
 542 
 543 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 544                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 545 
 546 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 547   JNIWrapper("GetSuperclass");
 548 
 549   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 550 
 551   jclass obj = NULL;
 552   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 553 
 554   oop mirror = JNIHandles::resolve_non_null(sub);
 555   // primitive classes return NULL
 556   if (java_lang_Class::is_primitive(mirror)) return NULL;
 557 
 558   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 559   // arrays return Object
 560   // interfaces return NULL
 561   // proper classes return Klass::super()
 562   Klass* k = java_lang_Class::as_Klass(mirror);
 563   if (k-&gt;is_interface()) return NULL;
 564 
 565   // return mirror for superclass
 566   Klass* super = k-&gt;java_super();
 567   // super2 is the value computed by the compiler's getSuperClass intrinsic:
 568   debug_only(Klass* super2 = ( k-&gt;is_array_klass()
 569                                  ? SystemDictionary::Object_klass()
 570                                  : k-&gt;super() ) );
 571   assert(super == super2,
 572          "java_super computation depends on interface, array, other super");
 573   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 574   return obj;
 575 JNI_END
 576 
 577 JNI_QUICK_ENTRY(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 578   JNIWrapper("IsSubclassOf");
 579 
 580   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 581 
 582   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 583   oop super_mirror = JNIHandles::resolve_non_null(super);
 584   if (java_lang_Class::is_primitive(sub_mirror) ||
 585       java_lang_Class::is_primitive(super_mirror)) {
 586     jboolean ret = (sub_mirror == super_mirror);
 587 
 588     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 589     return ret;
 590   }
 591   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 592   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 593   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, "invalid arguments to jni_IsAssignableFrom");
 594   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 595                    JNI_TRUE : JNI_FALSE;
 596 
 597   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 598   return ret;
 599 JNI_END
 600 
 601 
 602 DT_RETURN_MARK_DECL(Throw, jint
 603                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 604 
 605 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 606   JNIWrapper("Throw");
 607 
 608   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 609 
 610   jint ret = JNI_OK;
 611   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 612 
 613   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 614   ShouldNotReachHere();
 615   return 0;  // Mute compiler.
 616 JNI_END
 617 
 618 
 619 DT_RETURN_MARK_DECL(ThrowNew, jint
 620                     , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));
 621 
 622 JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
 623   JNIWrapper("ThrowNew");
 624 
 625   HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char *) message);
 626 
 627   jint ret = JNI_OK;
 628   DT_RETURN_MARK(ThrowNew, jint, (const jint&amp;)ret);
 629 
 630   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 631   Symbol*  name = k-&gt;name();
 632   Handle class_loader (THREAD,  k-&gt;class_loader());
 633   Handle protection_domain (THREAD, k-&gt;protection_domain());
 634   THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);
 635   ShouldNotReachHere();
 636   return 0;  // Mute compiler.
 637 JNI_END
 638 
 639 
 640 // JNI functions only transform a pending async exception to a synchronous
 641 // exception in ExceptionOccurred and ExceptionCheck calls, since
 642 // delivering an async exception in other places won't change the native
 643 // code's control flow and would be harmful when native code further calls
 644 // JNI functions with a pending exception. Async exception is also checked
 645 // during the call, so ExceptionOccurred/ExceptionCheck won't return
 646 // false but deliver the async exception at the very end during
 647 // state transition.
 648 
 649 static void jni_check_async_exceptions(JavaThread *thread) {
 650   assert(thread == Thread::current(), "must be itself");
 651   thread-&gt;check_and_handle_async_exceptions();
 652 }
 653 
 654 JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
 655   JNIWrapper("ExceptionOccurred");
 656 
 657   HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(env);
 658 
 659   jni_check_async_exceptions(thread);
 660   oop exception = thread-&gt;pending_exception();
 661   jthrowable ret = (jthrowable) JNIHandles::make_local(env, exception);
 662 
 663   HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(ret);
 664   return ret;
 665 JNI_END
 666 
 667 
 668 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
 669   JNIWrapper("ExceptionDescribe");
 670 
 671   HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(env);
 672 
 673   if (thread-&gt;has_pending_exception()) {
 674     Handle ex(thread, thread-&gt;pending_exception());
 675     thread-&gt;clear_pending_exception();
 676     if (ex-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 677       // Don't print anything if we are being killed.
 678     } else {
 679       jio_fprintf(defaultStream::error_stream(), "Exception ");
 680       if (thread != NULL &amp;&amp; thread-&gt;threadObj() != NULL) {
 681         ResourceMark rm(THREAD);
 682         jio_fprintf(defaultStream::error_stream(),
 683         "in thread \"%s\" ", thread-&gt;get_thread_name());
 684       }
 685       if (ex-&gt;is_a(SystemDictionary::Throwable_klass())) {
 686         JavaValue result(T_VOID);
 687         JavaCalls::call_virtual(&amp;result,
 688                                 ex,
 689                                 SystemDictionary::Throwable_klass(),
 690                                 vmSymbols::printStackTrace_name(),
 691                                 vmSymbols::void_method_signature(),
 692                                 THREAD);
 693         // If an exception is thrown in the call it gets thrown away. Not much
 694         // we can do with it. The native code that calls this, does not check
 695         // for the exception - hence, it might still be in the thread when DestroyVM gets
 696         // called, potentially causing a few asserts to trigger - since no pending exception
 697         // is expected.
 698         CLEAR_PENDING_EXCEPTION;
 699       } else {
 700         ResourceMark rm(THREAD);
 701         jio_fprintf(defaultStream::error_stream(),
 702         ". Uncaught exception of type %s.",
 703         ex-&gt;klass()-&gt;external_name());
 704       }
 705     }
 706   }
 707 
 708   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 709 JNI_END
 710 
 711 
 712 JNI_QUICK_ENTRY(void, jni_ExceptionClear(JNIEnv *env))
 713   JNIWrapper("ExceptionClear");
 714 
 715   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 716 
 717   // The jni code might be using this API to clear java thrown exception.
 718   // So just mark jvmti thread exception state as exception caught.
 719   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 720   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 721     state-&gt;set_exception_caught();
 722   }
 723   thread-&gt;clear_pending_exception();
 724 
 725   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 726 JNI_END
 727 
 728 
 729 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 730   JNIWrapper("FatalError");
 731 
 732   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
 733 
 734   tty-&gt;print_cr("FATAL ERROR in native method: %s", msg);
 735   thread-&gt;print_stack();
 736   os::abort(); // Dump core and abort
 737 JNI_END
 738 
 739 
 740 JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
 741   JNIWrapper("PushLocalFrame");
 742 
 743   HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(env, capacity);
 744 
 745   //%note jni_11
 746   if (capacity &lt; 0 ||
 747       ((MaxJNILocalCapacity &gt; 0) &amp;&amp; (capacity &gt; MaxJNILocalCapacity))) {
 748     HOTSPOT_JNI_PUSHLOCALFRAME_RETURN((uint32_t)JNI_ERR);
 749     return JNI_ERR;
 750   }
 751   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 752   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 753   assert(new_handles != NULL, "should not be NULL");
 754   new_handles-&gt;set_pop_frame_link(old_handles);
 755   thread-&gt;set_active_handles(new_handles);
 756   jint ret = JNI_OK;
 757   HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(ret);
 758   return ret;
 759 JNI_END
 760 
 761 
 762 JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
 763   JNIWrapper("PopLocalFrame");
 764 
 765   HOTSPOT_JNI_POPLOCALFRAME_ENTRY(env, result);
 766 
 767   //%note jni_11
 768   Handle result_handle(thread, JNIHandles::resolve(result));
 769   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 770   JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 771   if (new_handles != NULL) {
 772     // As a sanity check we only release the handle blocks if the pop_frame_link is not NULL.
 773     // This way code will still work if PopLocalFrame is called without a corresponding
 774     // PushLocalFrame call. Note that we set the pop_frame_link to NULL explicitly, otherwise
 775     // the release_block call will release the blocks.
 776     thread-&gt;set_active_handles(new_handles);
 777     old_handles-&gt;set_pop_frame_link(NULL);              // clear link we won't release new_handles below
 778     JNIHandleBlock::release_block(old_handles, thread); // may block
 779     result = JNIHandles::make_local(thread, result_handle());
 780   }
 781   HOTSPOT_JNI_POPLOCALFRAME_RETURN(result);
 782   return result;
 783 JNI_END
 784 
 785 
 786 JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
 787   JNIWrapper("NewGlobalRef");
 788 
 789   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 790 
 791   Handle ref_handle(thread, JNIHandles::resolve(ref));
 792   jobject ret = JNIHandles::make_global(ref_handle);
 793 
 794   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 795   return ret;
 796 JNI_END
 797 
 798 // Must be JNI_ENTRY (with HandleMark)
 799 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 800   JNIWrapper("DeleteGlobalRef");
 801 
 802   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 803 
 804   JNIHandles::destroy_global(ref);
 805 
 806   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 807 JNI_END
 808 
 809 JNI_QUICK_ENTRY(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
 810   JNIWrapper("DeleteLocalRef");
 811 
 812   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 813 
 814   JNIHandles::destroy_local(obj);
 815 
 816   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 817 JNI_END
 818 
 819 JNI_QUICK_ENTRY(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
 820   JNIWrapper("IsSameObject");
 821 
 822   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 823 
 824   oop a = JNIHandles::resolve(r1);
 825   oop b = JNIHandles::resolve(r2);
 826   jboolean ret = (a == b) ? JNI_TRUE : JNI_FALSE;
 827 
 828   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 829   return ret;
 830 JNI_END
 831 
 832 
 833 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 834   JNIWrapper("NewLocalRef");
 835 
 836   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 837 
 838   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 839 
 840   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 841   return ret;
 842 JNI_END
 843 
 844 JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
 845   JNIWrapper("EnsureLocalCapacity");
 846 
 847   HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(env, capacity);
 848 
 849   jint ret;
 850   if (capacity &gt;= 0 &amp;&amp;
 851       ((MaxJNILocalCapacity &lt;= 0) || (capacity &lt;= MaxJNILocalCapacity))) {
 852     ret = JNI_OK;
 853   } else {
 854     ret = JNI_ERR;
 855   }
 856 
 857   HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(ret);
 858   return ret;
 859 JNI_END
 860 
 861 // Return the Handle Type
 862 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 863   JNIWrapper("GetObjectRefType");
 864 
 865   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 866 
 867   jobjectRefType ret;
 868   if (JNIHandles::is_local_handle(thread, obj) ||
 869       JNIHandles::is_frame_handle(thread, obj))
 870     ret = JNILocalRefType;
 871   else if (JNIHandles::is_global_handle(obj))
 872     ret = JNIGlobalRefType;
 873   else if (JNIHandles::is_weak_global_handle(obj))
 874     ret = JNIWeakGlobalRefType;
 875   else
 876     ret = JNIInvalidRefType;
 877 
 878   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 879   return ret;
 880 JNI_END
 881 
 882 
 883 class JNI_ArgumentPusher : public SignatureIterator {
 884  protected:
 885   JavaCallArguments*  _arguments;
 886 
 887   virtual void get_bool   () = 0;
 888   virtual void get_char   () = 0;
 889   virtual void get_short  () = 0;
 890   virtual void get_byte   () = 0;
 891   virtual void get_int    () = 0;
 892   virtual void get_long   () = 0;
 893   virtual void get_float  () = 0;
 894   virtual void get_double () = 0;
 895   virtual void get_object () = 0;
 896 
 897   JNI_ArgumentPusher(Symbol* signature) : SignatureIterator(signature) {
 898     this-&gt;_return_type = T_ILLEGAL;
 899     _arguments = NULL;
 900   }
 901 
 902  public:
 903   virtual void iterate( uint64_t fingerprint ) = 0;
 904 
 905   void set_java_argument_object(JavaCallArguments *arguments) { _arguments = arguments; }
 906 
 907   inline void do_bool()                     { if (!is_return_type()) get_bool();   }
 908   inline void do_char()                     { if (!is_return_type()) get_char();   }
 909   inline void do_short()                    { if (!is_return_type()) get_short();  }
 910   inline void do_byte()                     { if (!is_return_type()) get_byte();   }
 911   inline void do_int()                      { if (!is_return_type()) get_int();    }
 912   inline void do_long()                     { if (!is_return_type()) get_long();   }
 913   inline void do_float()                    { if (!is_return_type()) get_float();  }
 914   inline void do_double()                   { if (!is_return_type()) get_double(); }
 915   inline void do_object(int begin, int end) { if (!is_return_type()) get_object(); }
 916   inline void do_array(int begin, int end)  { if (!is_return_type()) get_object(); } // do_array uses get_object -- there is no get_array
 917   inline void do_void()                     { }
 918 
 919   JavaCallArguments* arguments()     { return _arguments; }
 920   void push_receiver(Handle h)       { _arguments-&gt;push_oop(h); }
 921 };
 922 
 923 
 924 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 925  protected:
 926   va_list _ap;
 927 
 928   inline void get_bool()   {
 929     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
 930     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
 931     // TemplateInterpreterGenerator::generate_result_handler_for and
 932     // SharedRuntime::generate_native_wrapper.
 933     jboolean b = va_arg(_ap, jint);
 934     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));
 935   }
 936   inline void get_char()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // char is coerced to int when using va_arg
 937   inline void get_short()  { _arguments-&gt;push_int(va_arg(_ap, jint)); } // short is coerced to int when using va_arg
 938   inline void get_byte()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // byte is coerced to int when using va_arg
 939   inline void get_int()    { _arguments-&gt;push_int(va_arg(_ap, jint)); }
 940 
 941   // each of these paths is exercized by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 942 
 943   inline void get_long()   { _arguments-&gt;push_long(va_arg(_ap, jlong)); }
 944   inline void get_float()  { _arguments-&gt;push_float((jfloat)va_arg(_ap, jdouble)); } // float is coerced to double w/ va_arg
 945   inline void get_double() { _arguments-&gt;push_double(va_arg(_ap, jdouble)); }
 946   inline void get_object() { _arguments-&gt;push_jobject(va_arg(_ap, jobject)); }
 947 
 948   inline void set_ap(va_list rap) {
 949     va_copy(_ap, rap);
 950   }
 951 
 952  public:
 953   JNI_ArgumentPusherVaArg(Symbol* signature, va_list rap)
 954        : JNI_ArgumentPusher(signature) {
 955     set_ap(rap);
 956   }
 957   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 958       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {
 959     set_ap(rap);
 960   }
 961 
 962   // Optimized path if we have the bitvector form of signature
 963   void iterate( uint64_t fingerprint ) {
 964     if (fingerprint == (uint64_t)CONST64(-1)) {
 965       SignatureIterator::iterate(); // Must be too many arguments
 966     } else {
 967       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;
 968                                   result_feature_mask);
 969 
 970       assert(fingerprint, "Fingerprint should not be 0");
 971       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);
 972       while ( 1 ) {
 973         switch ( fingerprint &amp; parameter_feature_mask ) {
 974           case bool_parm:
 975             get_bool();
 976             break;
 977           case char_parm:
 978             get_char();
 979             break;
 980           case short_parm:
 981             get_short();
 982             break;
 983           case byte_parm:
 984             get_byte();
 985             break;
 986           case int_parm:
 987             get_int();
 988             break;
 989           case obj_parm:
 990             get_object();
 991             break;
 992           case long_parm:
 993             get_long();
 994             break;
 995           case float_parm:
 996             get_float();
 997             break;
 998           case double_parm:
 999             get_double();
1000             break;
1001           case done_parm:
1002             return;
1003             break;
1004           default:
1005             ShouldNotReachHere();
1006             break;
1007         }
1008         fingerprint &gt;&gt;= parameter_feature_size;
1009       }
1010     }
1011   }
1012 };
1013 
1014 
1015 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
1016  protected:
1017   const jvalue *_ap;
1018 
1019   inline void get_bool()   {
1020     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
1021     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
1022     // TemplateInterpreterGenerator::generate_result_handler_for and
1023     // SharedRuntime::generate_native_wrapper.
1024     jboolean b = (_ap++)-&gt;z;
1025     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));
1026   }
1027   inline void get_char()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;c); }
1028   inline void get_short()  { _arguments-&gt;push_int((jint)(_ap++)-&gt;s); }
1029   inline void get_byte()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;b); }
1030   inline void get_int()    { _arguments-&gt;push_int((jint)(_ap++)-&gt;i); }
1031 
1032   inline void get_long()   { _arguments-&gt;push_long((_ap++)-&gt;j);  }
1033   inline void get_float()  { _arguments-&gt;push_float((_ap++)-&gt;f); }
1034   inline void get_double() { _arguments-&gt;push_double((_ap++)-&gt;d);}
1035   inline void get_object() { _arguments-&gt;push_jobject((_ap++)-&gt;l); }
1036 
1037   inline void set_ap(const jvalue *rap) { _ap = rap; }
1038 
1039  public:
1040   JNI_ArgumentPusherArray(Symbol* signature, const jvalue *rap)
1041        : JNI_ArgumentPusher(signature) {
1042     set_ap(rap);
1043   }
1044   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
1045       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {
1046     set_ap(rap);
1047   }
1048 
1049   // Optimized path if we have the bitvector form of signature
1050   void iterate( uint64_t fingerprint ) {
1051     if (fingerprint == (uint64_t)CONST64(-1)) {
1052       SignatureIterator::iterate(); // Must be too many arguments
1053     } else {
1054       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;
1055                                   result_feature_mask);
1056       assert(fingerprint, "Fingerprint should not be 0");
1057       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);
1058       while ( 1 ) {
1059         switch ( fingerprint &amp; parameter_feature_mask ) {
1060           case bool_parm:
1061             get_bool();
1062             break;
1063           case char_parm:
1064             get_char();
1065             break;
1066           case short_parm:
1067             get_short();
1068             break;
1069           case byte_parm:
1070             get_byte();
1071             break;
1072           case int_parm:
1073             get_int();
1074             break;
1075           case obj_parm:
1076             get_object();
1077             break;
1078           case long_parm:
1079             get_long();
1080             break;
1081           case float_parm:
1082             get_float();
1083             break;
1084           case double_parm:
1085             get_double();
1086             break;
1087           case done_parm:
1088             return;
1089             break;
1090           default:
1091             ShouldNotReachHere();
1092             break;
1093         }
1094         fingerprint &gt;&gt;= parameter_feature_size;
1095       }
1096     }
1097   }
1098 };
1099 
1100 
1101 enum JNICallType {
1102   JNI_STATIC,
1103   JNI_VIRTUAL,
1104   JNI_NONVIRTUAL
1105 };
1106 
1107 
1108 
1109 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1110   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
1111 
1112   // Create object to hold arguments for the JavaCall, and associate it with
1113   // the jni parser
1114   ResourceMark rm(THREAD);
1115   int number_of_parameters = method-&gt;size_of_parameters();
1116   JavaCallArguments java_args(number_of_parameters);
1117   args-&gt;set_java_argument_object(&amp;java_args);
1118 
1119   assert(method-&gt;is_static(), "method should be static");
1120 
1121   // Fill out JavaCallArguments object
1122   args-&gt;iterate( Fingerprinter(method).fingerprint() );
1123   // Initialize result type
1124   result-&gt;set_type(args-&gt;get_ret_type());
1125 
1126   // Invoke the method. Result is returned as oop.
1127   JavaCalls::call(result, method, &amp;java_args, CHECK);
1128 
1129   // Convert result
1130   if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) {
1131     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1132   }
1133 }
1134 
1135 
1136 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1137   oop recv = JNIHandles::resolve(receiver);
1138   if (recv == NULL) {
1139     THROW(vmSymbols::java_lang_NullPointerException());
1140   }
1141   Handle h_recv(THREAD, recv);
1142 
1143   int number_of_parameters;
1144   Method* selected_method;
1145   {
1146     Method* m = Method::resolve_jmethod_id(method_id);
1147     number_of_parameters = m-&gt;size_of_parameters();
1148     Klass* holder = m-&gt;method_holder();
1149     if (call_type != JNI_VIRTUAL) {
1150         selected_method = m;
1151     } else if (!m-&gt;has_itable_index()) {
1152       // non-interface call -- for that little speed boost, don't handlize
1153       debug_only(NoSafepointVerifier nosafepoint;)
1154       // jni_GetMethodID makes sure class is linked and initialized
1155       // so m should have a valid vtable index.
1156       assert(m-&gt;valid_vtable_index(), "no valid vtable index");
1157       int vtbl_index = m-&gt;vtable_index();
1158       if (vtbl_index != Method::nonvirtual_vtable_index) {
1159         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1160       } else {
1161         // final method
1162         selected_method = m;
1163       }
1164     } else {
1165       // interface call
1166       int itbl_index = m-&gt;itable_index();
1167       Klass* k = h_recv-&gt;klass();
1168       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1169     }
1170   }
1171 
1172   methodHandle method(THREAD, selected_method);
1173 
1174   // Create object to hold arguments for the JavaCall, and associate it with
1175   // the jni parser
1176   ResourceMark rm(THREAD);
1177   JavaCallArguments java_args(number_of_parameters);
1178   args-&gt;set_java_argument_object(&amp;java_args);
1179 
1180   // handle arguments
1181   assert(!method-&gt;is_static(), "method %s should not be static", method-&gt;name_and_sig_as_C_string());
1182   args-&gt;push_receiver(h_recv); // Push jobject handle
1183 
1184   // Fill out JavaCallArguments object
1185   args-&gt;iterate( Fingerprinter(method).fingerprint() );
1186   // Initialize result type
1187   result-&gt;set_type(args-&gt;get_ret_type());
1188 
1189   // Invoke the method. Result is returned as oop.
1190   JavaCalls::call(result, method, &amp;java_args, CHECK);
1191 
1192   // Convert result
1193   if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) {
1194     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1195   }
1196 }
1197 
1198 
1199 static instanceOop alloc_object(jclass clazz, TRAPS) {
1200   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1201   if (k == NULL) {
1202     ResourceMark rm(THREAD);
1203     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1204   }
1205   k-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1206   k-&gt;initialize(CHECK_NULL);
1207   instanceOop ih = InstanceKlass::cast(k)-&gt;allocate_instance(THREAD);
1208   return ih;
1209 }
1210 
1211 DT_RETURN_MARK_DECL(AllocObject, jobject
1212                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1213 
1214 JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
1215   JNIWrapper("AllocObject");
1216 
1217   HOTSPOT_JNI_ALLOCOBJECT_ENTRY(env, clazz);
1218 
1219   jobject ret = NULL;
1220   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1221 
1222   instanceOop i = alloc_object(clazz, CHECK_NULL);
1223   ret = JNIHandles::make_local(env, i);
1224   return ret;
1225 JNI_END
1226 
1227 DT_RETURN_MARK_DECL(NewObjectA, jobject
1228                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1229 
1230 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1231   JNIWrapper("NewObjectA");
1232 
1233   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1234 
1235   jobject obj = NULL;
1236   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1237 
1238   instanceOop i = alloc_object(clazz, CHECK_NULL);
1239   obj = JNIHandles::make_local(env, i);
1240   JavaValue jvalue(T_VOID);
1241   JNI_ArgumentPusherArray ap(methodID, args);
1242   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1243   return obj;
1244 JNI_END
1245 
1246 
1247 DT_RETURN_MARK_DECL(NewObjectV, jobject
1248                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1249 
1250 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1251   JNIWrapper("NewObjectV");
1252 
1253   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1254 
1255   jobject obj = NULL;
1256   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1257 
1258   instanceOop i = alloc_object(clazz, CHECK_NULL);
1259   obj = JNIHandles::make_local(env, i);
1260   JavaValue jvalue(T_VOID);
1261   JNI_ArgumentPusherVaArg ap(methodID, args);
1262   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1263   return obj;
1264 JNI_END
1265 
1266 
1267 DT_RETURN_MARK_DECL(NewObject, jobject
1268                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1269 
1270 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1271   JNIWrapper("NewObject");
1272 
1273   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1274 
1275   jobject obj = NULL;
1276   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1277 
1278   instanceOop i = alloc_object(clazz, CHECK_NULL);
1279   obj = JNIHandles::make_local(env, i);
1280   va_list args;
1281   va_start(args, methodID);
1282   JavaValue jvalue(T_VOID);
1283   JNI_ArgumentPusherVaArg ap(methodID, args);
1284   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1285   va_end(args);
1286   return obj;
1287 JNI_END
1288 
1289 
1290 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1291   JNIWrapper("GetObjectClass");
1292 
1293   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1294 
1295   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1296   jclass ret =
1297     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1298 
1299   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1300   return ret;
1301 JNI_END
1302 
1303 JNI_QUICK_ENTRY(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1304   JNIWrapper("IsInstanceOf");
1305 
1306   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1307 
1308   jboolean ret = JNI_TRUE;
1309   if (obj != NULL) {
1310     ret = JNI_FALSE;
1311     Klass* k = java_lang_Class::as_Klass(
1312       JNIHandles::resolve_non_null(clazz));
1313     if (k != NULL) {
1314       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1315     }
1316   }
1317 
1318   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1319   return ret;
1320 JNI_END
1321 
1322 
1323 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1324                                const char *sig, bool is_static, TRAPS) {
1325   // %%%% This code should probably just call into a method in the LinkResolver
1326   //
1327   // The class should have been loaded (we have an instance of the class
1328   // passed in) so the method and signature should already be in the symbol
1329   // table.  If they're not there, the method doesn't exist.
1330   const char *name_to_probe = (name_str == NULL)
1331                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1332                         : name_str;
1333   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1334   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1335 
1336   if (name == NULL || signature == NULL) {
1337     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1338   }
1339 
1340   // Throw a NoSuchMethodError exception if we have an instance of a
1341   // primitive java.lang.Class
1342   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
1343     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1344   }
1345 
1346   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1347 
1348   // Make sure class is linked and initialized before handing id's out to
1349   // Method*s.
1350   klass-&gt;initialize(CHECK_NULL);
1351 
1352   Method* m;
1353   if (name == vmSymbols::object_initializer_name() ||
1354       name == vmSymbols::class_initializer_name()) {
1355     // Never search superclasses for constructors
1356     if (klass-&gt;is_instance_klass()) {
1357       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
1358     } else {
1359       m = NULL;
1360     }
1361   } else {
1362     m = klass-&gt;lookup_method(name, signature);
1363     if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
1364       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
1365     }
1366   }
1367   if (m == NULL || (m-&gt;is_static() != is_static)) {
1368     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1369   }
1370   return m-&gt;jmethod_id();
1371 }
1372 
1373 
1374 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1375           const char *name, const char *sig))
1376   JNIWrapper("GetMethodID");
1377   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1378   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1379   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1380   return ret;
1381 JNI_END
1382 
1383 
1384 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1385           const char *name, const char *sig))
1386   JNIWrapper("GetStaticMethodID");
1387   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1388   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
1389   HOTSPOT_JNI_GETSTATICMETHODID_RETURN((uintptr_t) ret);
1390   return ret;
1391 JNI_END
1392 
1393 
1394 
1395 //
1396 // Calling Methods
1397 //
1398 
1399 
1400 #define DEFINE_CALLMETHOD(ResultType, Result, Tag \
1401                           , EntryProbe, ReturnProbe)    \
1402 \
1403   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
1404                           , ReturnProbe);                          \
1405 \
1406 JNI_ENTRY(ResultType, \
1407           jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
1408   JNIWrapper("Call" XSTR(Result) "Method"); \
1409 \
1410   EntryProbe; \
1411   ResultType ret = 0;\
1412   DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
1413                      (const ResultType&amp;)ret);\
1414 \
1415   va_list args; \
1416   va_start(args, methodID); \
1417   JavaValue jvalue(Tag); \
1418   JNI_ArgumentPusherVaArg ap(methodID, args); \
1419   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1420   va_end(args); \
1421   ret = jvalue.get_##ResultType(); \
1422   return ret;\
1423 JNI_END
1424 
1425 // the runtime type of subword integral basic types is integer
1426 DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
1427                   , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1428                   HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
1429 DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
1430                   , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1431                   HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
1432 DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
1433                   , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1434                   HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
1435 DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
1436                   , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1437                   HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
1438 
1439 DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
1440                   , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1441                   HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
1442 DEFINE_CALLMETHOD(jint,     Int,     T_INT,
1443                   HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1444                   HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
1445 DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
1446                   , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1447                   HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
1448 // Float and double probes don't return value because dtrace doesn't currently support it
1449 DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
1450                   , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1451                   HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
1452 DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
1453                   , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1454                   HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
1455 
1456 #define DEFINE_CALLMETHODV(ResultType, Result, Tag \
1457                           , EntryProbe, ReturnProbe)    \
1458 \
1459   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
1460                           , ReturnProbe);                          \
1461 \
1462 JNI_ENTRY(ResultType, \
1463           jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
1464   JNIWrapper("Call" XSTR(Result) "MethodV"); \
1465 \
1466   EntryProbe;\
1467   ResultType ret = 0;\
1468   DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
1469                      (const ResultType&amp;)ret);\
1470 \
1471   JavaValue jvalue(Tag); \
1472   JNI_ArgumentPusherVaArg ap(methodID, args); \
1473   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1474   ret = jvalue.get_##ResultType(); \
1475   return ret;\
1476 JNI_END
1477 
1478 // the runtime type of subword integral basic types is integer
1479 DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
1480                   , HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1481                   HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(_ret_ref))
1482 DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
1483                   , HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1484                   HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(_ret_ref))
1485 DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
1486                   , HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1487                   HOTSPOT_JNI_CALLCHARMETHODV_RETURN(_ret_ref))
1488 DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
1489                   , HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1490                   HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(_ret_ref))
1491 
1492 DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
1493                   , HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1494                   HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(_ret_ref))
1495 DEFINE_CALLMETHODV(jint,     Int,     T_INT,
1496                   HOTSPOT_JNI_CALLINTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1497                   HOTSPOT_JNI_CALLINTMETHODV_RETURN(_ret_ref))
1498 DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
1499                   , HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1500                   HOTSPOT_JNI_CALLLONGMETHODV_RETURN(_ret_ref))
1501 // Float and double probes don't return value because dtrace doesn't currently support it
1502 DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
1503                   , HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1504                   HOTSPOT_JNI_CALLFLOATMETHODV_RETURN())
1505 DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
1506                   , HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1507                   HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN())
1508 
1509 #define DEFINE_CALLMETHODA(ResultType, Result, Tag \
1510                           , EntryProbe, ReturnProbe)    \
1511 \
1512   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
1513                           , ReturnProbe);                          \
1514 \
1515 JNI_ENTRY(ResultType, \
1516           jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
1517   JNIWrapper("Call" XSTR(Result) "MethodA"); \
1518   EntryProbe; \
1519   ResultType ret = 0;\
1520   DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
1521                      (const ResultType&amp;)ret);\
1522 \
1523   JavaValue jvalue(Tag); \
1524   JNI_ArgumentPusherArray ap(methodID, args); \
1525   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1526   ret = jvalue.get_##ResultType(); \
1527   return ret;\
1528 JNI_END
1529 
1530 // the runtime type of subword integral basic types is integer
1531 DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
1532                   , HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1533                   HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(_ret_ref))
1534 DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
1535                   , HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1536                   HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(_ret_ref))
1537 DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
1538                   , HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1539                   HOTSPOT_JNI_CALLCHARMETHODA_RETURN(_ret_ref))
1540 DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
1541                   , HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1542                   HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(_ret_ref))
1543 
1544 DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
1545                   , HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1546                   HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(_ret_ref))
1547 DEFINE_CALLMETHODA(jint,     Int,     T_INT,
1548                   HOTSPOT_JNI_CALLINTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1549                   HOTSPOT_JNI_CALLINTMETHODA_RETURN(_ret_ref))
1550 DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
1551                   , HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1552                   HOTSPOT_JNI_CALLLONGMETHODA_RETURN(_ret_ref))
1553 // Float and double probes don't return value because dtrace doesn't currently support it
1554 DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
1555                   , HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1556                   HOTSPOT_JNI_CALLFLOATMETHODA_RETURN())
1557 DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
1558                   , HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1559                   HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN())
1560 
1561 DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
1562 DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
1563 DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());
1564 
1565 
1566 JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
1567   JNIWrapper("CallVoidMethod");
1568   HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t) methodID);
1569   DT_VOID_RETURN_MARK(CallVoidMethod);
1570 
1571   va_list args;
1572   va_start(args, methodID);
1573   JavaValue jvalue(T_VOID);
1574   JNI_ArgumentPusherVaArg ap(methodID, args);
1575   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1576   va_end(args);
1577 JNI_END
1578 
1579 
1580 JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
1581   JNIWrapper("CallVoidMethodV");
1582   HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(env, obj, (uintptr_t) methodID);
1583   DT_VOID_RETURN_MARK(CallVoidMethodV);
1584 
1585   JavaValue jvalue(T_VOID);
1586   JNI_ArgumentPusherVaArg ap(methodID, args);
1587   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1588 JNI_END
1589 
1590 
1591 JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
1592   JNIWrapper("CallVoidMethodA");
1593   HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(env, obj, (uintptr_t) methodID);
1594   DT_VOID_RETURN_MARK(CallVoidMethodA);
1595 
1596   JavaValue jvalue(T_VOID);
1597   JNI_ArgumentPusherArray ap(methodID, args);
1598   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1599 JNI_END
1600 
1601 
1602 
1603 #define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
1604                                     , EntryProbe, ReturnProbe)      \
1605 \
1606   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
1607                           , ReturnProbe);\
1608 \
1609 JNI_ENTRY(ResultType, \
1610           jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
1611   JNIWrapper("CallNonvitual" XSTR(Result) "Method"); \
1612 \
1613   EntryProbe;\
1614   ResultType ret;\
1615   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
1616                      (const ResultType&amp;)ret);\
1617 \
1618   va_list args; \
1619   va_start(args, methodID); \
1620   JavaValue jvalue(Tag); \
1621   JNI_ArgumentPusherVaArg ap(methodID, args); \
1622   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1623   va_end(args); \
1624   ret = jvalue.get_##ResultType(); \
1625   return ret;\
1626 JNI_END
1627 
1628 // the runtime type of subword integral basic types is integer
1629 DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
1630                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1631                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
1632 DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
1633                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1634                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
1635 DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
1636                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1637                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
1638 DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
1639                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1640                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))
1641 
1642 DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
1643                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1644                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
1645 DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
1646                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1647                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
1648 DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
1649                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1650 // Float and double probes don't return value because dtrace doesn't currently support it
1651                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
1652 DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
1653                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1654                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
1655 DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
1656                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1657                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())
1658 
1659 #define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
1660                                     , EntryProbe, ReturnProbe)      \
1661 \
1662   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
1663                           , ReturnProbe);\
1664 \
1665 JNI_ENTRY(ResultType, \
1666           jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
1667   JNIWrapper("CallNonvitual" XSTR(Result) "MethodV"); \
1668 \
1669   EntryProbe;\
1670   ResultType ret;\
1671   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
1672                      (const ResultType&amp;)ret);\
1673 \
1674   JavaValue jvalue(Tag); \
1675   JNI_ArgumentPusherVaArg ap(methodID, args); \
1676   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1677   ret = jvalue.get_##ResultType(); \
1678   return ret;\
1679 JNI_END
1680 
1681 // the runtime type of subword integral basic types is integer
1682 DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
1683                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1684                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
1685 DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
1686                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1687                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
1688 DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
1689                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1690                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
1691 DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
1692                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1693                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))
1694 
1695 DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
1696                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1697                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
1698 DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
1699                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1700                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
1701 DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
1702                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1703 // Float and double probes don't return value because dtrace doesn't currently support it
1704                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
1705 DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
1706                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1707                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
1708 DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
1709                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1710                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())
1711 
1712 #define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
1713                                     , EntryProbe, ReturnProbe)      \
1714 \
1715   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
1716                           , ReturnProbe);\
1717 \
1718 JNI_ENTRY(ResultType, \
1719           jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
1720   JNIWrapper("CallNonvitual" XSTR(Result) "MethodA"); \
1721 \
1722   EntryProbe;\
1723   ResultType ret;\
1724   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
1725                      (const ResultType&amp;)ret);\
1726 \
1727   JavaValue jvalue(Tag); \
1728   JNI_ArgumentPusherArray ap(methodID, args); \
1729   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1730   ret = jvalue.get_##ResultType(); \
1731   return ret;\
1732 JNI_END
1733 
1734 // the runtime type of subword integral basic types is integer
1735 DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
1736                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1737                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
1738 DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
1739                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1740                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
1741 DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
1742                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1743                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
1744 DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
1745                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1746                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))
1747 
1748 DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
1749                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1750                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
1751 DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
1752                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1753                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
1754 DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
1755                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1756 // Float and double probes don't return value because dtrace doesn't currently support it
1757                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
1758 DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
1759                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1760                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
1761 DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
1762                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1763                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())
1764 
1765 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
1766                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
1767 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
1768                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
1769 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
1770                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());
1771 
1772 JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
1773   JNIWrapper("CallNonvirtualVoidMethod");
1774 
1775   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t) methodID);
1776   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);
1777 
1778   va_list args;
1779   va_start(args, methodID);
1780   JavaValue jvalue(T_VOID);
1781   JNI_ArgumentPusherVaArg ap(methodID, args);
1782   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1783   va_end(args);
1784 JNI_END
1785 
1786 
1787 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
1788   JNIWrapper("CallNonvirtualVoidMethodV");
1789 
1790   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
1791                env, obj, cls, (uintptr_t) methodID);
1792   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);
1793 
1794   JavaValue jvalue(T_VOID);
1795   JNI_ArgumentPusherVaArg ap(methodID, args);
1796   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1797 JNI_END
1798 
1799 
1800 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
1801   JNIWrapper("CallNonvirtualVoidMethodA");
1802   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
1803                 env, obj, cls, (uintptr_t) methodID);
1804   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
1805   JavaValue jvalue(T_VOID);
1806   JNI_ArgumentPusherArray ap(methodID, args);
1807   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1808 JNI_END
1809 
1810 
1811 
1812 #define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
1813                                 , EntryProbe, ResultProbe) \
1814 \
1815   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
1816                           , ResultProbe);                               \
1817 \
1818 JNI_ENTRY(ResultType, \
1819           jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
1820   JNIWrapper("CallStatic" XSTR(Result) "Method"); \
1821 \
1822   EntryProbe; \
1823   ResultType ret = 0;\
1824   DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
1825                      (const ResultType&amp;)ret);\
1826 \
1827   va_list args; \
1828   va_start(args, methodID); \
1829   JavaValue jvalue(Tag); \
1830   JNI_ArgumentPusherVaArg ap(methodID, args); \
1831   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1832   va_end(args); \
1833   ret = jvalue.get_##ResultType(); \
1834   return ret;\
1835 JNI_END
1836 
1837 // the runtime type of subword integral basic types is integer
1838 DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
1839                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1840                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
1841 DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
1842                         , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1843                         HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
1844 DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
1845                         , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1846                         HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
1847 DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
1848                         , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1849                         HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));
1850 
1851 DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
1852                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1853                         HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
1854 DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
1855                         , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1856                         HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
1857 DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
1858                         , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1859                         HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
1860 // Float and double probes don't return value because dtrace doesn't currently support it
1861 DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
1862                         , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1863                         HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
1864 DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
1865                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1866                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());
1867 
1868 #define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
1869                                 , EntryProbe, ResultProbe) \
1870 \
1871   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
1872                           , ResultProbe);                               \
1873 \
1874 JNI_ENTRY(ResultType, \
1875           jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
1876   JNIWrapper("CallStatic" XSTR(Result) "MethodV"); \
1877 \
1878   EntryProbe; \
1879   ResultType ret = 0;\
1880   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
1881                      (const ResultType&amp;)ret);\
1882 \
1883   JavaValue jvalue(Tag); \
1884   JNI_ArgumentPusherVaArg ap(methodID, args); \
1885   /* Make sure class is initialized before trying to invoke its method */ \
1886   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls)); \
1887   k-&gt;initialize(CHECK_0); \
1888   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1889   va_end(args); \
1890   ret = jvalue.get_##ResultType(); \
1891   return ret;\
1892 JNI_END
1893 
1894 // the runtime type of subword integral basic types is integer
1895 DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
1896                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1897                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
1898 DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
1899                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1900                         HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
1901 DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
1902                         , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1903                         HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
1904 DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
1905                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1906                         HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));
1907 
1908 DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
1909                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1910                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
1911 DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
1912                         , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1913                         HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
1914 DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
1915                         , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1916                         HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
1917 // Float and double probes don't return value because dtrace doesn't currently support it
1918 DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
1919                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1920                         HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
1921 DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
1922                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1923                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());
1924 
1925 #define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
1926                                 , EntryProbe, ResultProbe) \
1927 \
1928   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
1929                           , ResultProbe);                               \
1930 \
1931 JNI_ENTRY(ResultType, \
1932           jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
1933   JNIWrapper("CallStatic" XSTR(Result) "MethodA"); \
1934 \
1935   EntryProbe; \
1936   ResultType ret = 0;\
1937   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
1938                      (const ResultType&amp;)ret);\
1939 \
1940   JavaValue jvalue(Tag); \
1941   JNI_ArgumentPusherArray ap(methodID, args); \
1942   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1943   ret = jvalue.get_##ResultType(); \
1944   return ret;\
1945 JNI_END
1946 
1947 // the runtime type of subword integral basic types is integer
1948 DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
1949                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1950                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
1951 DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
1952                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1953                         HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
1954 DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
1955                         , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1956                         HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
1957 DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
1958                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1959                         HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));
1960 
1961 DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
1962                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1963                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
1964 DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
1965                         , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1966                         HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
1967 DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
1968                         , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1969                         HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
1970 // Float and double probes don't return value because dtrace doesn't currently support it
1971 DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
1972                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1973                         HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
1974 DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
1975                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1976                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());
1977 
1978 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
1979                          , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
1980 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
1981                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
1982 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
1983                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());
1984 
1985 JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
1986   JNIWrapper("CallStaticVoidMethod");
1987   HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t) methodID);
1988   DT_VOID_RETURN_MARK(CallStaticVoidMethod);
1989 
1990   va_list args;
1991   va_start(args, methodID);
1992   JavaValue jvalue(T_VOID);
1993   JNI_ArgumentPusherVaArg ap(methodID, args);
1994   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1995   va_end(args);
1996 JNI_END
1997 
1998 
1999 JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
2000   JNIWrapper("CallStaticVoidMethodV");
2001   HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(env, cls, (uintptr_t) methodID);
2002   DT_VOID_RETURN_MARK(CallStaticVoidMethodV);
2003 
2004   JavaValue jvalue(T_VOID);
2005   JNI_ArgumentPusherVaArg ap(methodID, args);
2006   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
2007 JNI_END
2008 
2009 
2010 JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
2011   JNIWrapper("CallStaticVoidMethodA");
2012   HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(env, cls, (uintptr_t) methodID);
2013   DT_VOID_RETURN_MARK(CallStaticVoidMethodA);
2014 
2015   JavaValue jvalue(T_VOID);
2016   JNI_ArgumentPusherArray ap(methodID, args);
2017   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
2018 JNI_END
2019 
2020 
2021 //
2022 // Accessing Fields
2023 //
2024 
2025 
2026 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
2027                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
2028 
2029 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
2030           const char *name, const char *sig))
2031   JNIWrapper("GetFieldID");
2032   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2033   jfieldID ret = 0;
2034   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
2035 
2036   // The class should have been loaded (we have an instance of the class
2037   // passed in) so the field and signature should already be in the symbol
2038   // table.  If they're not there, the field doesn't exist.
2039   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2040   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2041   if (fieldname == NULL || signame == NULL) {
2042     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2043   }
2044   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2045   // Make sure class is initialized before handing id's out to fields
2046   k-&gt;initialize(CHECK_NULL);
2047 
2048   fieldDescriptor fd;
2049   if (!k-&gt;is_instance_klass() ||
2050       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
2051     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2052   }
2053 
2054   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
2055   // It may also have hash bits for k, if VerifyJNIFields is turned on.
2056   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());
2057   return ret;
2058 JNI_END
2059 
2060 
2061 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
2062   JNIWrapper("GetObjectField");
2063   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
2064   oop o = JNIHandles::resolve_non_null(obj);
2065   Klass* k = o-&gt;klass();
2066   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2067   // Keep JVMTI addition small and only check enabled flag here.
2068   // jni_GetField_probe() assumes that is okay to create handles.
2069   if (JvmtiExport::should_post_field_access()) {
2070     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
2071   }
2072   jobject ret = JNIHandles::make_local(env, o-&gt;obj_field(offset));
2073 #if INCLUDE_ALL_GCS
2074   // If G1 is enabled and we are accessing the value of the referent
2075   // field in a reference object then we need to register a non-null
2076   // referent with the SATB barrier.
2077   if (UseG1GC) {
2078     bool needs_barrier = false;
2079 
2080     if (ret != NULL &amp;&amp;
2081         offset == java_lang_ref_Reference::referent_offset &amp;&amp;
2082         InstanceKlass::cast(k)-&gt;reference_type() != REF_NONE) {
2083       assert(InstanceKlass::cast(k)-&gt;is_subclass_of(SystemDictionary::Reference_klass()), "sanity");
2084       needs_barrier = true;
2085     }
2086 
2087     if (needs_barrier) {
2088       oop referent = JNIHandles::resolve(ret);
2089       G1SATBCardTableModRefBS::enqueue(referent);
2090     }
2091   }
2092 #endif // INCLUDE_ALL_GCS
2093 HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
2094   return ret;
2095 JNI_END
2096 
2097 
2098 
2099 #define DEFINE_GETFIELD(Return,Fieldname,Result \
2100   , EntryProbe, ReturnProbe) \
2101 \
2102   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
2103   , ReturnProbe); \
2104 \
2105 JNI_QUICK_ENTRY(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
2106   JNIWrapper("Get" XSTR(Result) "Field"); \
2107 \
2108   EntryProbe; \
2109   Return ret = 0;\
2110   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
2111 \
2112   oop o = JNIHandles::resolve_non_null(obj); \
2113   Klass* k = o-&gt;klass(); \
2114   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2115   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2116   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
2117   /* and creates a ResetNoHandleMark.                                   */ \
2118   if (JvmtiExport::should_post_field_access()) { \
2119     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
2120   } \
2121   ret = o-&gt;Fieldname##_field(offset); \
2122   return ret; \
2123 JNI_END
2124 
2125 DEFINE_GETFIELD(jboolean, bool,   Boolean
2126                 , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2127                 HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
2128 DEFINE_GETFIELD(jbyte,    byte,   Byte
2129                 , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2130                 HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
2131 DEFINE_GETFIELD(jchar,    char,   Char
2132                 , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2133                 HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
2134 DEFINE_GETFIELD(jshort,   short,  Short
2135                 , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2136                 HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
2137 DEFINE_GETFIELD(jint,     int,    Int
2138                 , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2139                 HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
2140 DEFINE_GETFIELD(jlong,    long,   Long
2141                 , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2142                 HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
2143 // Float and double probes don't return value because dtrace doesn't currently support it
2144 DEFINE_GETFIELD(jfloat,   float,  Float
2145                 , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2146                 HOTSPOT_JNI_GETFLOATFIELD_RETURN())
2147 DEFINE_GETFIELD(jdouble,  double, Double
2148                 , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2149                 HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())
2150 
2151 address jni_GetBooleanField_addr() {
2152   return (address)jni_GetBooleanField;
2153 }
2154 address jni_GetByteField_addr() {
2155   return (address)jni_GetByteField;
2156 }
2157 address jni_GetCharField_addr() {
2158   return (address)jni_GetCharField;
2159 }
2160 address jni_GetShortField_addr() {
2161   return (address)jni_GetShortField;
2162 }
2163 address jni_GetIntField_addr() {
2164   return (address)jni_GetIntField;
2165 }
2166 address jni_GetLongField_addr() {
2167   return (address)jni_GetLongField;
2168 }
2169 address jni_GetFloatField_addr() {
2170   return (address)jni_GetFloatField;
2171 }
2172 address jni_GetDoubleField_addr() {
2173   return (address)jni_GetDoubleField;
2174 }
2175 
2176 JNI_QUICK_ENTRY(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2177   JNIWrapper("SetObjectField");
2178   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2179   oop o = JNIHandles::resolve_non_null(obj);
2180   Klass* k = o-&gt;klass();
2181   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2182   // Keep JVMTI addition small and only check enabled flag here.
2183   // jni_SetField_probe_nh() assumes that is not okay to create handles
2184   // and creates a ResetNoHandleMark.
2185   if (JvmtiExport::should_post_field_modification()) {
2186     jvalue field_value;
2187     field_value.l = value;
2188     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, 'L', (jvalue *)&amp;field_value);
2189   }
2190   o-&gt;obj_field_put(offset, JNIHandles::resolve(value));
2191   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2192 JNI_END
2193 
2194 
2195 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2196                         , EntryProbe, ReturnProbe) \
2197 \
2198 JNI_QUICK_ENTRY(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2199   JNIWrapper("Set" XSTR(Result) "Field"); \
2200 \
2201   EntryProbe; \
2202 \
2203   oop o = JNIHandles::resolve_non_null(obj); \
2204   Klass* k = o-&gt;klass(); \
2205   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2206   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2207   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2208   /* and creates a ResetNoHandleMark.                                   */ \
2209   if (JvmtiExport::should_post_field_modification()) { \
2210     jvalue field_value; \
2211     field_value.unionType = value; \
2212     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2213   } \
2214   if (SigType == 'Z') { value = ((jboolean)value) &amp; 1; } \
2215   o-&gt;Fieldname##_field_put(offset, value); \
2216   ReturnProbe; \
2217 JNI_END
2218 
2219 DEFINE_SETFIELD(jboolean, bool,   Boolean, 'Z', z
2220                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2221                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
2222 DEFINE_SETFIELD(jbyte,    byte,   Byte,    'B', b
2223                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2224                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
2225 DEFINE_SETFIELD(jchar,    char,   Char,    'C', c
2226                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2227                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
2228 DEFINE_SETFIELD(jshort,   short,  Short,   'S', s
2229                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2230                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
2231 DEFINE_SETFIELD(jint,     int,    Int,     'I', i
2232                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2233                 HOTSPOT_JNI_SETINTFIELD_RETURN())
2234 DEFINE_SETFIELD(jlong,    long,   Long,    'J', j
2235                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2236                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2237 // Float and double probes don't return value because dtrace doesn't currently support it
2238 DEFINE_SETFIELD(jfloat,   float,  Float,   'F', f
2239                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2240                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
2241 DEFINE_SETFIELD(jdouble,  double, Double,  'D', d
2242                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2243                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2244 
2245 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2246                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2247 
2248 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2249   JNIWrapper("ToReflectedField");
2250   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2251   jobject ret = NULL;
2252   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2253 
2254   fieldDescriptor fd;
2255   bool found = false;
2256   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2257 
2258   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), "invalid fieldID");
2259 
2260   if (isStatic) {
2261     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
2262     JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2263     assert(id-&gt;is_static_field_id(), "invalid static field id");
2264     found = id-&gt;find_local_field(&amp;fd);
2265   } else {
2266     // Non-static field. The fieldID is really the offset of the field within the instanceOop.
2267     int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2268     found = InstanceKlass::cast(k)-&gt;find_field_from_offset(offset, false, &amp;fd);
2269   }
2270   assert(found, "bad fieldID passed into jni_ToReflectedField");
2271   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2272   ret = JNIHandles::make_local(env, reflected);
2273   return ret;
2274 JNI_END
2275 
2276 
2277 //
2278 // Accessing Static Fields
2279 //
2280 DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
2281                     , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));
2282 
2283 JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
2284           const char *name, const char *sig))
2285   JNIWrapper("GetStaticFieldID");
2286   HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2287   jfieldID ret = NULL;
2288   DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&amp;)ret);
2289 
2290   // The class should have been loaded (we have an instance of the class
2291   // passed in) so the field and signature should already be in the symbol
2292   // table.  If they're not there, the field doesn't exist.
2293   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2294   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2295   if (fieldname == NULL || signame == NULL) {
2296     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2297   }
2298   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2299   // Make sure class is initialized before handing id's out to static fields
2300   k-&gt;initialize(CHECK_NULL);
2301 
2302   fieldDescriptor fd;
2303   if (!k-&gt;is_instance_klass() ||
2304       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, true, &amp;fd)) {
2305     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2306   }
2307 
2308   // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
2309   JNIid* id = fd.field_holder()-&gt;jni_id_for(fd.offset());
2310   debug_only(id-&gt;set_is_static_field_id();)
2311 
2312   debug_only(id-&gt;verify(fd.field_holder()));
2313 
2314   ret = jfieldIDWorkaround::to_static_jfieldID(id);
2315   return ret;
2316 JNI_END
2317 
2318 
2319 JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
2320   JNIWrapper("GetStaticObjectField");
2321   HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID);
2322 #if INCLUDE_JNI_CHECK
2323   DEBUG_ONLY(Klass* param_k = jniCheck::validate_class(thread, clazz);)
2324 #endif // INCLUDE_JNI_CHECK
2325   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2326   assert(id-&gt;is_static_field_id(), "invalid static field id");
2327   // Keep JVMTI addition small and only check enabled flag here.
2328   // jni_GetField_probe() assumes that is okay to create handles.
2329   if (JvmtiExport::should_post_field_access()) {
2330     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true);
2331   }
2332   jobject ret = JNIHandles::make_local(id-&gt;holder()-&gt;java_mirror()-&gt;obj_field(id-&gt;offset()));
2333   HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
2334   return ret;
2335 JNI_END
2336 
2337 
2338 #define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
2339                               , EntryProbe, ReturnProbe) \
2340 \
2341   DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
2342                           , ReturnProbe);                                          \
2343 \
2344 JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
2345   JNIWrapper("GetStatic" XSTR(Result) "Field"); \
2346   EntryProbe; \
2347   Return ret = 0;\
2348   DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
2349                      (const Return&amp;)ret);\
2350   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2351   assert(id-&gt;is_static_field_id(), "invalid static field id"); \
2352   /* Keep JVMTI addition small and only check enabled flag here. */ \
2353   /* jni_GetField_probe() assumes that is okay to create handles. */ \
2354   if (JvmtiExport::should_post_field_access()) { \
2355     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true); \
2356   } \
2357   ret = id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field (id-&gt;offset()); \
2358   return ret;\
2359 JNI_END
2360 
2361 DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
2362                       , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
2363 DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
2364                       , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
2365 DEFINE_GETSTATICFIELD(jchar,    char,   Char
2366                       , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
2367 DEFINE_GETSTATICFIELD(jshort,   short,  Short
2368                       , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
2369 DEFINE_GETSTATICFIELD(jint,     int,    Int
2370                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2371 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2372                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2373 // Float and double probes don't return value because dtrace doesn't currently support it
2374 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2375                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2376 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2377                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2378 
2379 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2380   JNIWrapper("SetStaticObjectField");
2381  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2382   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2383   assert(id-&gt;is_static_field_id(), "invalid static field id");
2384   // Keep JVMTI addition small and only check enabled flag here.
2385   // jni_SetField_probe() assumes that is okay to create handles.
2386   if (JvmtiExport::should_post_field_modification()) {
2387     jvalue field_value;
2388     field_value.l = value;
2389     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, 'L', (jvalue *)&amp;field_value);
2390   }
2391   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2392   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2393 JNI_END
2394 
2395 
2396 
2397 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2398                               , EntryProbe, ReturnProbe) \
2399 \
2400 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2401   JNIWrapper("SetStatic" XSTR(Result) "Field"); \
2402   EntryProbe; \
2403 \
2404   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2405   assert(id-&gt;is_static_field_id(), "invalid static field id"); \
2406   /* Keep JVMTI addition small and only check enabled flag here. */ \
2407   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2408   if (JvmtiExport::should_post_field_modification()) { \
2409     jvalue field_value; \
2410     field_value.unionType = value; \
2411     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2412   } \
2413   if (SigType == 'Z') { value = ((jboolean)value) &amp; 1; } \
2414   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2415   ReturnProbe;\
2416 JNI_END
2417 
2418 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, 'Z', z
2419                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2420                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
2421 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    'B', b
2422                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2423                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
2424 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    'C', c
2425                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2426                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
2427 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   'S', s
2428                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2429                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
2430 DEFINE_SETSTATICFIELD(jint,     int,    Int,     'I', i
2431                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2432                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
2433 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    'J', j
2434                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2435                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2436 // Float and double probes don't return value because dtrace doesn't currently support it
2437 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   'F', f
2438                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2439                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
2440 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  'D', d
2441                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2442                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2443 
2444 //
2445 // String Operations
2446 //
2447 
2448 // Unicode Interface
2449 
2450 DT_RETURN_MARK_DECL(NewString, jstring
2451                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2452 
2453 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2454   JNIWrapper("NewString");
2455  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2456   jstring ret = NULL;
2457   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2458   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2459   ret = (jstring) JNIHandles::make_local(env, string);
2460   return ret;
2461 JNI_END
2462 
2463 
2464 JNI_QUICK_ENTRY(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
2465   JNIWrapper("GetStringLength");
2466   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2467   jsize ret = 0;
2468   oop s = JNIHandles::resolve_non_null(string);
2469   if (java_lang_String::value(s) != NULL) {
2470     ret = java_lang_String::length(s);
2471   }
2472  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2473   return ret;
2474 JNI_END
2475 
2476 
2477 JNI_QUICK_ENTRY(const jchar*, jni_GetStringChars(
2478   JNIEnv *env, jstring string, jboolean *isCopy))
2479   JNIWrapper("GetStringChars");
2480  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2481   jchar* buf = NULL;
2482   oop s = JNIHandles::resolve_non_null(string);
2483   typeArrayOop s_value = java_lang_String::value(s);
2484   if (s_value != NULL) {
2485     int s_len = java_lang_String::length(s);
2486     bool is_latin1 = java_lang_String::is_latin1(s);
2487     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2488     /* JNI Specification states return NULL on OOM */
2489     if (buf != NULL) {
2490       if (s_len &gt; 0) {
2491         if (!is_latin1) {
2492           memcpy(buf, s_value-&gt;char_at_addr(0), sizeof(jchar)*s_len);
2493         } else {
2494           for (int i = 0; i &lt; s_len; i++) {
2495             buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
2496           }
2497         }
2498       }
2499       buf[s_len] = 0;
2500       //%note jni_5
2501       if (isCopy != NULL) {
2502         *isCopy = JNI_TRUE;
2503       }
2504     }
2505   }
2506   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2507   return buf;
2508 JNI_END
2509 
2510 
2511 JNI_QUICK_ENTRY(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
2512   JNIWrapper("ReleaseStringChars");
2513   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2514   //%note jni_6
2515   if (chars != NULL) {
2516     // Since String objects are supposed to be immutable, don't copy any
2517     // new data back.  A bad user will have to go after the char array.
2518     FreeHeap((void*) chars);
2519   }
2520   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2521 JNI_END
2522 
2523 
2524 // UTF Interface
2525 
2526 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2527                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2528 
2529 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2530   JNIWrapper("NewStringUTF");
2531   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
2532   jstring ret;
2533   DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&amp;)ret);
2534 
2535   oop result = java_lang_String::create_oop_from_str((char*) bytes, CHECK_NULL);
2536   ret = (jstring) JNIHandles::make_local(env, result);
2537   return ret;
2538 JNI_END
2539 
2540 
2541 JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
2542   JNIWrapper("GetStringUTFLength");
2543  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);
2544   jsize ret = 0;
2545   oop java_string = JNIHandles::resolve_non_null(string);
2546   if (java_lang_String::value(java_string) != NULL) {
2547     ret = java_lang_String::utf8_length(java_string);
2548   }
2549   HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(ret);
2550   return ret;
2551 JNI_END
2552 
2553 
2554 JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
2555   JNIWrapper("GetStringUTFChars");
2556  HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2557   char* result = NULL;
2558   oop java_string = JNIHandles::resolve_non_null(string);
2559   if (java_lang_String::value(java_string) != NULL) {
2560     size_t length = java_lang_String::utf8_length(java_string);
2561     /* JNI Specification states return NULL on OOM */
2562     result = AllocateHeap(length + 1, mtInternal, 0, AllocFailStrategy::RETURN_NULL);
2563     if (result != NULL) {
2564       java_lang_String::as_utf8_string(java_string, result, (int) length + 1);
2565       if (isCopy != NULL) {
2566         *isCopy = JNI_TRUE;
2567       }
2568     }
2569   }
2570  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2571   return result;
2572 JNI_END
2573 
2574 
2575 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2576   JNIWrapper("ReleaseStringUTFChars");
2577  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2578   if (chars != NULL) {
2579     FreeHeap((char*) chars);
2580   }
2581 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2582 JNI_END
2583 
2584 
2585 JNI_QUICK_ENTRY(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
2586   JNIWrapper("GetArrayLength");
2587  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2588   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2589   assert(a-&gt;is_array(), "must be array");
2590   jsize ret = a-&gt;length();
2591  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2592   return ret;
2593 JNI_END
2594 
2595 
2596 //
2597 // Object Array Operations
2598 //
2599 
2600 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2601                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2602 
2603 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2604   JNIWrapper("NewObjectArray");
2605  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
2606   jobjectArray ret = NULL;
2607   DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&amp;)ret);
2608   Klass* ek = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass));
2609   Klass* ak = ek-&gt;array_klass(CHECK_NULL);
2610   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2611   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2612   oop initial_value = JNIHandles::resolve(initialElement);
2613   if (initial_value != NULL) {  // array already initialized with NULL
2614     for (int index = 0; index &lt; length; index++) {
2615       result-&gt;obj_at_put(index, initial_value);
2616     }
2617   }
2618   ret = (jobjectArray) JNIHandles::make_local(env, result);
2619   return ret;
2620 JNI_END
2621 
2622 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2623                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2624 
2625 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2626   JNIWrapper("GetObjectArrayElement");
2627  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2628   jobject ret = NULL;
2629   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2630   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2631   if (a-&gt;is_within_bounds(index)) {
2632     ret = JNIHandles::make_local(env, a-&gt;obj_at(index));
2633     return ret;
2634   } else {
2635     char buf[jintAsStringSize];
2636     sprintf(buf, "%d", index);
2637     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), buf);
2638   }
2639 JNI_END
2640 
2641 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2642                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2643 
2644 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2645   JNIWrapper("SetObjectArrayElement");
2646  HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2647   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2648 
2649   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2650   oop v = JNIHandles::resolve(value);
2651   if (a-&gt;is_within_bounds(index)) {
2652     if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2653       a-&gt;obj_at_put(index, v);
2654     } else {
2655       THROW(vmSymbols::java_lang_ArrayStoreException());
2656     }
2657   } else {
2658     char buf[jintAsStringSize];
2659     sprintf(buf, "%d", index);
2660     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), buf);
2661   }
2662 JNI_END
2663 
2664 
2665 
2666 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2667                               ,EntryProbe,ReturnProbe)  \
2668 \
2669   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2670                       , ReturnProbe); \
2671 \
2672 JNI_ENTRY(Return, \
2673           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2674   JNIWrapper("New" XSTR(Result) "Array"); \
2675   EntryProbe; \
2676   Return ret = NULL;\
2677   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2678 \
2679   oop obj= oopFactory::Allocator(len, CHECK_0); \
2680   ret = (Return) JNIHandles::make_local(env, obj); \
2681   return ret;\
2682 JNI_END
2683 
2684 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2685                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2686                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2687 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2688                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2689                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2690 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2691                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2692                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2693 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2694                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2695                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2696 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2697                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2698                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2699 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
2700                       HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
2701                       HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
2702 DEFINE_NEWSCALARARRAY(jfloatArray,   new_singleArray, Float,
2703                       HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
2704                       HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
2705 DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
2706                       HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
2707                       HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))
2708 
2709 // Return an address which will fault if the caller writes to it.
2710 
2711 static char* get_bad_address() {
2712   static char* bad_address = NULL;
2713   if (bad_address == NULL) {
2714     size_t size = os::vm_allocation_granularity();
2715     bad_address = os::reserve_memory(size);
2716     if (bad_address != NULL) {
2717       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2718                          /*is_committed*/false);
2719       MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
2720     }
2721   }
2722   return bad_address;
2723 }
2724 
2725 
2726 
2727 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2728                                       , EntryProbe, ReturnProbe) \
2729 \
2730 JNI_QUICK_ENTRY(ElementType*, \
2731           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2732   JNIWrapper("Get" XSTR(Result) "ArrayElements"); \
2733   EntryProbe; \
2734   /* allocate an chunk of memory in c land */ \
2735   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2736   ElementType* result; \
2737   int len = a-&gt;length(); \
2738   if (len == 0) { \
2739     /* Empty array: legal but useless, can't return NULL. \
2740      * Return a pointer to something useless. \
2741      * Avoid asserts in typeArrayOop. */ \
2742     result = (ElementType*)get_bad_address(); \
2743   } else { \
2744     /* JNI Specification states return NULL on OOM */                    \
2745     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2746     if (result != NULL) {                                                \
2747       /* copy the array to the c chunk */                                \
2748       memcpy(result, a-&gt;Tag##_at_addr(0), sizeof(ElementType)*len);      \
2749       if (isCopy) {                                                      \
2750         *isCopy = JNI_TRUE;                                              \
2751       }                                                                  \
2752     }                                                                    \
2753   } \
2754   ReturnProbe; \
2755   return result; \
2756 JNI_END
2757 
2758 DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2759                               , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2760                               HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
2761 DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2762                               , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2763                               HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
2764 DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2765                               , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2766                               HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
2767 DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2768                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2769                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2770 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2771                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2772                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2773 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2774                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2775                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2776 // Float and double probes don't return value because dtrace doesn't currently support it
2777 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2778                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2779                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2780 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2781                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2782                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2783 
2784 
2785 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2786                                           , EntryProbe, ReturnProbe);\
2787 \
2788 JNI_QUICK_ENTRY(void, \
2789           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2790                                              ElementType *buf, jint mode)) \
2791   JNIWrapper("Release" XSTR(Result) "ArrayElements"); \
2792   EntryProbe; \
2793   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2794   int len = a-&gt;length(); \
2795   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2796     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2797       memcpy(a-&gt;Tag##_at_addr(0), buf, sizeof(ElementType)*len); \
2798     } \
2799     if ((mode == 0) || (mode == JNI_ABORT)) { \
2800       FreeHeap(buf); \
2801     } \
2802   } \
2803   ReturnProbe; \
2804 JNI_END
2805 
2806 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2807                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2808                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
2809 DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2810                                   , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
2811                                   HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
2812 DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2813                                   ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2814                                   HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
2815 DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2816                                   ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2817                                   HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
2818 DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2819                                   , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
2820                                   HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
2821 DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2822                                   , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2823                                   HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
2824 DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2825                                   , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
2826                                   HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
2827 DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2828                                   , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
2829                                   HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())
2830 
2831 
2832 #define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2833                                     , EntryProbe, ReturnProbe); \
2834   DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
2835                            , ReturnProbe); \
2836 \
2837 JNI_ENTRY(void, \
2838 jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2839              jsize len, ElementType *buf)) \
2840   JNIWrapper("Get" XSTR(Result) "ArrayRegion"); \
2841   EntryProbe; \
2842   DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
2843   typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2844   if (start &lt; 0 || len &lt; 0 || ((unsigned int)start + (unsigned int)len &gt; (unsigned int)src-&gt;length())) { \
2845     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException()); \
2846   } else { \
2847     if (len &gt; 0) { \
2848       int sc = TypeArrayKlass::cast(src-&gt;klass())-&gt;log2_element_size(); \
2849       memcpy((u_char*) buf, \
2850              (u_char*) src-&gt;Tag##_at_addr(start), \
2851              len &lt;&lt; sc);                          \
2852     } \
2853   } \
2854 JNI_END
2855 
2856 DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
2857                             , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2858                             HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
2859 DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
2860                             ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2861                             HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
2862 DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
2863                             , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2864                             HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
2865 DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
2866                             ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
2867                             HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
2868 DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
2869                             , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
2870                             HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
2871 DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
2872                             ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2873                             HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
2874 DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
2875                             , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2876                             HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
2877 DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
2878                             , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2879                             HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());
2880 
2881 
2882 #define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2883                                     , EntryProbe, ReturnProbe); \
2884   DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
2885                            ,ReturnProbe);           \
2886 \
2887 JNI_ENTRY(void, \
2888 jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2889              jsize len, const ElementType *buf)) \
2890   JNIWrapper("Set" XSTR(Result) "ArrayRegion"); \
2891   EntryProbe; \
2892   DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
2893   typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2894   if (start &lt; 0 || len &lt; 0 || ((unsigned int)start + (unsigned int)len &gt; (unsigned int)dst-&gt;length())) { \
2895     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException()); \
2896   } else { \
2897     if (len &gt; 0) { \
2898       int sc = TypeArrayKlass::cast(dst-&gt;klass())-&gt;log2_element_size(); \
2899       memcpy((u_char*) dst-&gt;Tag##_at_addr(start), \
2900              (u_char*) buf, \
2901              len &lt;&lt; sc);    \
2902     } \
2903   } \
2904 JNI_END
2905 
2906 DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
2907                             , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
2908                             HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
2909 DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
2910                             , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2911                             HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
2912 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2913                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2914                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2915 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2916                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2917                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2918 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2919                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2920                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2921 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2922                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2923                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2924 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2925                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2926                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2927 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2928                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2929                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2930 
2931 
2932 //
2933 // Interception of natives
2934 //
2935 
2936 // The RegisterNatives call being attempted tried to register with a method that
2937 // is not native.  Ask JVM TI what prefixes have been specified.  Then check
2938 // to see if the native method is now wrapped with the prefixes.  See the
2939 // SetNativeMethodPrefix(es) functions in the JVM TI Spec for details.
2940 static Method* find_prefixed_native(Klass* k, Symbol* name, Symbol* signature, TRAPS) {
2941 #if INCLUDE_JVMTI
2942   ResourceMark rm(THREAD);
2943   Method* method;
2944   int name_len = name-&gt;utf8_length();
2945   char* name_str = name-&gt;as_utf8();
2946   int prefix_count;
2947   char** prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
2948   for (int i = 0; i &lt; prefix_count; i++) {
2949     char* prefix = prefixes[i];
2950     int prefix_len = (int)strlen(prefix);
2951 
2952     // try adding this prefix to the method name and see if it matches another method name
2953     int trial_len = name_len + prefix_len;
2954     char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);
2955     strcpy(trial_name_str, prefix);
2956     strcat(trial_name_str, name_str);
2957     TempNewSymbol trial_name = SymbolTable::probe(trial_name_str, trial_len);
2958     if (trial_name == NULL) {
2959       continue; // no such symbol, so this prefix wasn't used, try the next prefix
2960     }
2961     method = k-&gt;lookup_method(trial_name, signature);
2962     if (method == NULL) {
2963       continue; // signature doesn't match, try the next prefix
2964     }
2965     if (method-&gt;is_native()) {
2966       method-&gt;set_is_prefixed_native();
2967       return method; // wahoo, we found a prefixed version of the method, return it
2968     }
2969     // found as non-native, so prefix is good, add it, probably just need more prefixes
2970     name_len = trial_len;
2971     name_str = trial_name_str;
2972   }
2973 #endif // INCLUDE_JVMTI
2974   return NULL; // not found
2975 }
2976 
2977 static bool register_native(Klass* k, Symbol* name, Symbol* signature, address entry, TRAPS) {
2978   Method* method = k-&gt;lookup_method(name, signature);
2979   if (method == NULL) {
2980     ResourceMark rm;
2981     stringStream st;
2982     st.print("Method %s name or signature does not match",
2983              Method::name_and_sig_as_C_string(k, name, signature));
2984     THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);
2985   }
2986   if (!method-&gt;is_native()) {
2987     // trying to register to a non-native method, see if a JVM TI agent has added prefix(es)
2988     method = find_prefixed_native(k, name, signature, THREAD);
2989     if (method == NULL) {
2990       ResourceMark rm;
2991       stringStream st;
2992       st.print("Method %s is not declared as native",
2993                Method::name_and_sig_as_C_string(k, name, signature));
2994       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);
2995     }
2996   }
2997 
2998   if (entry != NULL) {
2999     method-&gt;set_native_function(entry,
3000       Method::native_bind_event_is_interesting);
3001   } else {
3002     method-&gt;clear_native_function();
3003   }
3004   if (PrintJNIResolving) {
3005     ResourceMark rm(THREAD);
3006     tty-&gt;print_cr("[Registering JNI native method %s.%s]",
3007       method-&gt;method_holder()-&gt;external_name(),
3008       method-&gt;name()-&gt;as_C_string());
3009   }
3010   return true;
3011 }
3012 
3013 DT_RETURN_MARK_DECL(RegisterNatives, jint
3014                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
3015 
3016 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
3017                                     const JNINativeMethod *methods,
3018                                     jint nMethods))
3019   JNIWrapper("RegisterNatives");
3020   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
3021   jint ret = 0;
3022   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
3023 
3024   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
3025 
3026   for (int index = 0; index &lt; nMethods; index++) {
3027     const char* meth_name = methods[index].name;
3028     const char* meth_sig = methods[index].signature;
3029     int meth_name_len = (int)strlen(meth_name);
3030 
3031     // The class should have been loaded (we have an instance of the class
3032     // passed in) so the method and signature should already be in the symbol
3033     // table.  If they're not there, the method doesn't exist.
3034     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
3035     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
3036 
3037     if (name == NULL || signature == NULL) {
3038       ResourceMark rm;
3039       stringStream st;
3040       st.print("Method %s.%s%s not found", k-&gt;external_name(), meth_name, meth_sig);
3041       // Must return negative value on failure
3042       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
3043     }
3044 
3045     bool res = register_native(k, name, signature,
3046                                (address) methods[index].fnPtr, THREAD);
3047     if (!res) {
3048       ret = -1;
3049       break;
3050     }
3051   }
3052   return ret;
3053 JNI_END
3054 
3055 
3056 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
3057   JNIWrapper("UnregisterNatives");
3058  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
3059   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
3060   //%note jni_2
3061   if (k-&gt;is_instance_klass()) {
3062     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
3063       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
3064       if (m-&gt;is_native()) {
3065         m-&gt;clear_native_function();
3066         m-&gt;set_signature_handler(NULL);
3067       }
3068     }
3069   }
3070  HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(0);
3071   return 0;
3072 JNI_END
3073 
3074 //
3075 // Monitor functions
3076 //
3077 
3078 DT_RETURN_MARK_DECL(MonitorEnter, jint
3079                     , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));
3080 
3081 JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
3082  HOTSPOT_JNI_MONITORENTER_ENTRY(env, jobj);
3083   jint ret = JNI_ERR;
3084   DT_RETURN_MARK(MonitorEnter, jint, (const jint&amp;)ret);
3085 
3086   // If the object is null, we can't do anything with it
3087   if (jobj == NULL) {
3088     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3089   }
3090 
3091   Handle obj(thread, JNIHandles::resolve_non_null(jobj));
3092   ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));
3093   ret = JNI_OK;
3094   return ret;
3095 JNI_END
3096 
3097 DT_RETURN_MARK_DECL(MonitorExit, jint
3098                     , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));
3099 
3100 JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
3101  HOTSPOT_JNI_MONITOREXIT_ENTRY(env, jobj);
3102   jint ret = JNI_ERR;
3103   DT_RETURN_MARK(MonitorExit, jint, (const jint&amp;)ret);
3104 
3105   // Don't do anything with a null object
3106   if (jobj == NULL) {
3107     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3108   }
3109 
3110   Handle obj(THREAD, JNIHandles::resolve_non_null(jobj));
3111   ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));
3112 
3113   ret = JNI_OK;
3114   return ret;
3115 JNI_END
3116 
3117 //
3118 // Extensions
3119 //
3120 
3121 DT_VOID_RETURN_MARK_DECL(GetStringRegion
3122                          , HOTSPOT_JNI_GETSTRINGREGION_RETURN());
3123 
3124 JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
3125   JNIWrapper("GetStringRegion");
3126  HOTSPOT_JNI_GETSTRINGREGION_ENTRY(env, string, start, len, buf);
3127   DT_VOID_RETURN_MARK(GetStringRegion);
3128   oop s = JNIHandles::resolve_non_null(string);
3129   int s_len = java_lang_String::length(s);
3130   if (start &lt; 0 || len &lt; 0 || start + len &gt; s_len) {
3131     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3132   } else {
3133     if (len &gt; 0) {
3134       typeArrayOop s_value = java_lang_String::value(s);
3135       bool is_latin1 = java_lang_String::is_latin1(s);
3136       if (!is_latin1) {
3137         memcpy(buf, s_value-&gt;char_at_addr(start), sizeof(jchar)*len);
3138       } else {
3139         for (int i = 0; i &lt; len; i++) {
3140           buf[i] = ((jchar) s_value-&gt;byte_at(i + start)) &amp; 0xff;
3141         }
3142       }
3143     }
3144   }
3145 JNI_END
3146 
3147 DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
3148                          , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());
3149 
3150 JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
3151   JNIWrapper("GetStringUTFRegion");
3152  HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(env, string, start, len, buf);
3153   DT_VOID_RETURN_MARK(GetStringUTFRegion);
3154   oop s = JNIHandles::resolve_non_null(string);
3155   int s_len = java_lang_String::length(s);
3156   if (start &lt; 0 || len &lt; 0 || start + len &gt; s_len) {
3157     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3158   } else {
3159     //%note jni_7
3160     if (len &gt; 0) {
3161       // Assume the buffer is large enough as the JNI spec. does not require user error checking
3162       java_lang_String::as_utf8_string(s, start, len, buf, INT_MAX);
3163       // as_utf8_string null-terminates the result string
3164     } else {
3165       // JDK null-terminates the buffer even in len is zero
3166       if (buf != NULL) {
3167         buf[0] = 0;
3168       }
3169     }
3170   }
3171 JNI_END
3172 
3173 
3174 JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
3175   JNIWrapper("GetPrimitiveArrayCritical");
3176  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(env, array, (uintptr_t *) isCopy);
3177   GCLocker::lock_critical(thread);
3178   if (isCopy != NULL) {
3179     *isCopy = JNI_FALSE;
3180   }
3181   oop a = JNIHandles::resolve_non_null(array);
3182   assert(a-&gt;is_array(), "just checking");
3183   BasicType type;
3184   if (a-&gt;is_objArray()) {
3185     type = T_OBJECT;
3186   } else {
3187     type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
3188   }
3189   void* ret = arrayOop(a)-&gt;base(type);
3190  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(ret);
3191   return ret;
3192 JNI_END
3193 
3194 
3195 JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
3196   JNIWrapper("ReleasePrimitiveArrayCritical");
3197   HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(env, array, carray, mode);
3198   // The array, carray and mode arguments are ignored
3199   GCLocker::unlock_critical(thread);
3200 HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN();
3201 JNI_END
3202 
3203 
3204 JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
3205   JNIWrapper("GetStringCritical");
3206   HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(env, string, (uintptr_t *) isCopy);
3207   GCLocker::lock_critical(thread);
3208   oop s = JNIHandles::resolve_non_null(string);
3209   typeArrayOop s_value = java_lang_String::value(s);
3210   bool is_latin1 = java_lang_String::is_latin1(s);
3211   if (isCopy != NULL) {
3212     *isCopy = is_latin1 ? JNI_TRUE : JNI_FALSE;
3213   }
3214   jchar* ret;
3215   if (!is_latin1) {
3216     ret = (jchar*) s_value-&gt;base(T_CHAR);
3217   } else {
3218     // Inflate latin1 encoded string to UTF16
3219     int s_len = java_lang_String::length(s);
3220     ret = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
3221     /* JNI Specification states return NULL on OOM */
3222     if (ret != NULL) {
3223       for (int i = 0; i &lt; s_len; i++) {
3224         ret[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
3225       }
3226       ret[s_len] = 0;
3227     }
3228   }
3229  HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN((uint16_t *) ret);
3230   return ret;
3231 JNI_END
3232 
3233 
3234 JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
3235   JNIWrapper("ReleaseStringCritical");
3236   HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(env, str, (uint16_t *) chars);
3237   // The str and chars arguments are ignored for UTF16 strings
3238   oop s = JNIHandles::resolve_non_null(str);
3239   bool is_latin1 = java_lang_String::is_latin1(s);
3240   if (is_latin1) {
3241     // For latin1 string, free jchar array allocated by earlier call to GetStringCritical.
3242     // This assumes that ReleaseStringCritical bookends GetStringCritical.
3243     FREE_C_HEAP_ARRAY(jchar, chars);
3244   }
3245   GCLocker::unlock_critical(thread);
3246 HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN();
3247 JNI_END
3248 
3249 
3250 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3251   JNIWrapper("jni_NewWeakGlobalRef");
3252  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3253   Handle ref_handle(thread, JNIHandles::resolve(ref));
3254   jweak ret = JNIHandles::make_weak_global(ref_handle);
3255  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3256   return ret;
3257 JNI_END
3258 
3259 // Must be JNI_ENTRY (with HandleMark)
3260 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3261   JNIWrapper("jni_DeleteWeakGlobalRef");
3262   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3263   JNIHandles::destroy_weak_global(ref);
3264   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3265 JNI_END
3266 
3267 
3268 JNI_QUICK_ENTRY(jboolean, jni_ExceptionCheck(JNIEnv *env))
3269   JNIWrapper("jni_ExceptionCheck");
3270  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3271   jni_check_async_exceptions(thread);
3272   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3273  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3274   return ret;
3275 JNI_END
3276 
3277 
3278 // Initialization state for three routines below relating to
3279 // java.nio.DirectBuffers
3280 static          int directBufferSupportInitializeStarted = 0;
3281 static volatile int directBufferSupportInitializeEnded   = 0;
3282 static volatile int directBufferSupportInitializeFailed  = 0;
3283 static jclass    bufferClass                 = NULL;
3284 static jclass    directBufferClass           = NULL;
3285 static jclass    directByteBufferClass       = NULL;
3286 static jmethodID directByteBufferConstructor = NULL;
3287 static jfieldID  directBufferAddressField    = NULL;
3288 static jfieldID  bufferCapacityField         = NULL;
3289 
3290 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3291   Handle loader;            // null (bootstrap) loader
3292   Handle protection_domain; // null protection domain
3293 
3294   TempNewSymbol sym = SymbolTable::new_symbol(name, CHECK_NULL);
3295   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3296 
3297   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
3298     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3299   }
3300   return result;
3301 }
3302 
3303 // These lookups are done with the NULL (bootstrap) ClassLoader to
3304 // circumvent any security checks that would be done by jni_FindClass.
3305 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3306 {
3307   if ((bufferClass           = lookupOne(env, "java/nio/Buffer", thread))           == NULL) { return false; }
3308   if ((directBufferClass     = lookupOne(env, "sun/nio/ch/DirectBuffer", thread))   == NULL) { return false; }
3309   if ((directByteBufferClass = lookupOne(env, "java/nio/DirectByteBuffer", thread)) == NULL) { return false; }
3310   return true;
3311 }
3312 JNI_END
3313 
3314 
3315 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3316   if (directBufferSupportInitializeFailed) {
3317     return false;
3318   }
3319 
3320   if (Atomic::cmpxchg(1, &amp;directBufferSupportInitializeStarted, 0) == 0) {
3321     if (!lookupDirectBufferClasses(env)) {
3322       directBufferSupportInitializeFailed = 1;
3323       return false;
3324     }
3325 
3326     // Make global references for these
3327     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3328     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3329     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3330 
3331     // Get needed field and method IDs
3332     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, "&lt;init&gt;", "(JI)V");
3333     if (env-&gt;ExceptionCheck()) {
3334       env-&gt;ExceptionClear();
3335       directBufferSupportInitializeFailed = 1;
3336       return false;
3337     }
3338     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, "address", "J");
3339     if (env-&gt;ExceptionCheck()) {
3340       env-&gt;ExceptionClear();
3341       directBufferSupportInitializeFailed = 1;
3342       return false;
3343     }
3344     bufferCapacityField         = env-&gt;GetFieldID(bufferClass, "capacity", "I");
3345     if (env-&gt;ExceptionCheck()) {
3346       env-&gt;ExceptionClear();
3347       directBufferSupportInitializeFailed = 1;
3348       return false;
3349     }
3350 
3351     if ((directByteBufferConstructor == NULL) ||
3352         (directBufferAddressField    == NULL) ||
3353         (bufferCapacityField         == NULL)) {
3354       directBufferSupportInitializeFailed = 1;
3355       return false;
3356     }
3357 
3358     directBufferSupportInitializeEnded = 1;
3359   } else {
3360     while (!directBufferSupportInitializeEnded &amp;&amp; !directBufferSupportInitializeFailed) {
3361       os::naked_yield();
3362     }
3363   }
3364 
3365   return !directBufferSupportInitializeFailed;
3366 }
3367 
3368 extern "C" jobject JNICALL jni_NewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
3369 {
3370   // thread_from_jni_environment() will block if VM is gone.
3371   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3372 
3373   JNIWrapper("jni_NewDirectByteBuffer");
3374  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(env, address, capacity);
3375 
3376   if (!directBufferSupportInitializeEnded) {
3377     if (!initializeDirectBufferSupport(env, thread)) {
3378       HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(NULL);
3379       return NULL;
3380     }
3381   }
3382 
3383   // Being paranoid about accidental sign extension on address
3384   jlong addr = (jlong) ((uintptr_t) address);
3385   // NOTE that package-private DirectByteBuffer constructor currently
3386   // takes int capacity
3387   jint  cap  = (jint)  capacity;
3388   jobject ret = env-&gt;NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);
3389   HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(ret);
3390   return ret;
3391 }
3392 
3393 DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
3394                     , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));
3395 
3396 extern "C" void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
3397 {
3398   // thread_from_jni_environment() will block if VM is gone.
3399   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3400 
3401   JNIWrapper("jni_GetDirectBufferAddress");
3402   HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(env, buf);
3403   void* ret = NULL;
3404   DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&amp;)ret);
3405 
3406   if (!directBufferSupportInitializeEnded) {
3407     if (!initializeDirectBufferSupport(env, thread)) {
3408       return 0;
3409     }
3410   }
3411 
3412   if ((buf != NULL) &amp;&amp; (!env-&gt;IsInstanceOf(buf, directBufferClass))) {
3413     return 0;
3414   }
3415 
3416   ret = (void*)(intptr_t)env-&gt;GetLongField(buf, directBufferAddressField);
3417   return ret;
3418 }
3419 
3420 DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
3421                     , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));
3422 
3423 extern "C" jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
3424 {
3425   // thread_from_jni_environment() will block if VM is gone.
3426   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3427 
3428   JNIWrapper("jni_GetDirectBufferCapacity");
3429   HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(env, buf);
3430   jlong ret = -1;
3431   DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&amp;)ret);
3432 
3433   if (!directBufferSupportInitializeEnded) {
3434     if (!initializeDirectBufferSupport(env, thread)) {
3435       ret = 0;
3436       return ret;
3437     }
3438   }
3439 
3440   if (buf == NULL) {
3441     return -1;
3442   }
3443 
3444   if (!env-&gt;IsInstanceOf(buf, directBufferClass)) {
3445     return -1;
3446   }
3447 
3448   // NOTE that capacity is currently an int in the implementation
3449   ret = env-&gt;GetIntField(buf, bufferCapacityField);
3450   return ret;
3451 }
3452 
3453 
3454 JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
3455   JNIWrapper("GetVersion");
3456   HOTSPOT_JNI_GETVERSION_ENTRY(env);
3457   HOTSPOT_JNI_GETVERSION_RETURN(CurrentVersion);
3458   return CurrentVersion;
3459 JNI_END
3460 
3461 extern struct JavaVM_ main_vm;
3462 
3463 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3464   JNIWrapper("jni_GetJavaVM");
3465   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3466   *vm  = (JavaVM *)(&amp;main_vm);
3467   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3468   return JNI_OK;
3469 JNI_END
3470 
3471 
3472 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3473   JNIWrapper("GetModule");
3474   return Modules::get_module(clazz, THREAD);
3475 JNI_END
3476 
3477 
3478 // Structure containing all jni functions
3479 struct JNINativeInterface_ jni_NativeInterface = {
3480     NULL,
3481     NULL,
3482     NULL,
3483 
3484     NULL,
3485 
3486     jni_GetVersion,
3487 
3488     jni_DefineClass,
3489     jni_FindClass,
3490 
3491     jni_FromReflectedMethod,
3492     jni_FromReflectedField,
3493 
3494     jni_ToReflectedMethod,
3495 
3496     jni_GetSuperclass,
3497     jni_IsAssignableFrom,
3498 
3499     jni_ToReflectedField,
3500 
3501     jni_Throw,
3502     jni_ThrowNew,
3503     jni_ExceptionOccurred,
3504     jni_ExceptionDescribe,
3505     jni_ExceptionClear,
3506     jni_FatalError,
3507 
3508     jni_PushLocalFrame,
3509     jni_PopLocalFrame,
3510 
3511     jni_NewGlobalRef,
3512     jni_DeleteGlobalRef,
3513     jni_DeleteLocalRef,
3514     jni_IsSameObject,
3515 
3516     jni_NewLocalRef,
3517     jni_EnsureLocalCapacity,
3518 
3519     jni_AllocObject,
3520     jni_NewObject,
3521     jni_NewObjectV,
3522     jni_NewObjectA,
3523 
3524     jni_GetObjectClass,
3525     jni_IsInstanceOf,
3526 
3527     jni_GetMethodID,
3528 
3529     jni_CallObjectMethod,
3530     jni_CallObjectMethodV,
3531     jni_CallObjectMethodA,
3532     jni_CallBooleanMethod,
3533     jni_CallBooleanMethodV,
3534     jni_CallBooleanMethodA,
3535     jni_CallByteMethod,
3536     jni_CallByteMethodV,
3537     jni_CallByteMethodA,
3538     jni_CallCharMethod,
3539     jni_CallCharMethodV,
3540     jni_CallCharMethodA,
3541     jni_CallShortMethod,
3542     jni_CallShortMethodV,
3543     jni_CallShortMethodA,
3544     jni_CallIntMethod,
3545     jni_CallIntMethodV,
3546     jni_CallIntMethodA,
3547     jni_CallLongMethod,
3548     jni_CallLongMethodV,
3549     jni_CallLongMethodA,
3550     jni_CallFloatMethod,
3551     jni_CallFloatMethodV,
3552     jni_CallFloatMethodA,
3553     jni_CallDoubleMethod,
3554     jni_CallDoubleMethodV,
3555     jni_CallDoubleMethodA,
3556     jni_CallVoidMethod,
3557     jni_CallVoidMethodV,
3558     jni_CallVoidMethodA,
3559 
3560     jni_CallNonvirtualObjectMethod,
3561     jni_CallNonvirtualObjectMethodV,
3562     jni_CallNonvirtualObjectMethodA,
3563     jni_CallNonvirtualBooleanMethod,
3564     jni_CallNonvirtualBooleanMethodV,
3565     jni_CallNonvirtualBooleanMethodA,
3566     jni_CallNonvirtualByteMethod,
3567     jni_CallNonvirtualByteMethodV,
3568     jni_CallNonvirtualByteMethodA,
3569     jni_CallNonvirtualCharMethod,
3570     jni_CallNonvirtualCharMethodV,
3571     jni_CallNonvirtualCharMethodA,
3572     jni_CallNonvirtualShortMethod,
3573     jni_CallNonvirtualShortMethodV,
3574     jni_CallNonvirtualShortMethodA,
3575     jni_CallNonvirtualIntMethod,
3576     jni_CallNonvirtualIntMethodV,
3577     jni_CallNonvirtualIntMethodA,
3578     jni_CallNonvirtualLongMethod,
3579     jni_CallNonvirtualLongMethodV,
3580     jni_CallNonvirtualLongMethodA,
3581     jni_CallNonvirtualFloatMethod,
3582     jni_CallNonvirtualFloatMethodV,
3583     jni_CallNonvirtualFloatMethodA,
3584     jni_CallNonvirtualDoubleMethod,
3585     jni_CallNonvirtualDoubleMethodV,
3586     jni_CallNonvirtualDoubleMethodA,
3587     jni_CallNonvirtualVoidMethod,
3588     jni_CallNonvirtualVoidMethodV,
3589     jni_CallNonvirtualVoidMethodA,
3590 
3591     jni_GetFieldID,
3592 
3593     jni_GetObjectField,
3594     jni_GetBooleanField,
3595     jni_GetByteField,
3596     jni_GetCharField,
3597     jni_GetShortField,
3598     jni_GetIntField,
3599     jni_GetLongField,
3600     jni_GetFloatField,
3601     jni_GetDoubleField,
3602 
3603     jni_SetObjectField,
3604     jni_SetBooleanField,
3605     jni_SetByteField,
3606     jni_SetCharField,
3607     jni_SetShortField,
3608     jni_SetIntField,
3609     jni_SetLongField,
3610     jni_SetFloatField,
3611     jni_SetDoubleField,
3612 
3613     jni_GetStaticMethodID,
3614 
3615     jni_CallStaticObjectMethod,
3616     jni_CallStaticObjectMethodV,
3617     jni_CallStaticObjectMethodA,
3618     jni_CallStaticBooleanMethod,
3619     jni_CallStaticBooleanMethodV,
3620     jni_CallStaticBooleanMethodA,
3621     jni_CallStaticByteMethod,
3622     jni_CallStaticByteMethodV,
3623     jni_CallStaticByteMethodA,
3624     jni_CallStaticCharMethod,
3625     jni_CallStaticCharMethodV,
3626     jni_CallStaticCharMethodA,
3627     jni_CallStaticShortMethod,
3628     jni_CallStaticShortMethodV,
3629     jni_CallStaticShortMethodA,
3630     jni_CallStaticIntMethod,
3631     jni_CallStaticIntMethodV,
3632     jni_CallStaticIntMethodA,
3633     jni_CallStaticLongMethod,
3634     jni_CallStaticLongMethodV,
3635     jni_CallStaticLongMethodA,
3636     jni_CallStaticFloatMethod,
3637     jni_CallStaticFloatMethodV,
3638     jni_CallStaticFloatMethodA,
3639     jni_CallStaticDoubleMethod,
3640     jni_CallStaticDoubleMethodV,
3641     jni_CallStaticDoubleMethodA,
3642     jni_CallStaticVoidMethod,
3643     jni_CallStaticVoidMethodV,
3644     jni_CallStaticVoidMethodA,
3645 
3646     jni_GetStaticFieldID,
3647 
3648     jni_GetStaticObjectField,
3649     jni_GetStaticBooleanField,
3650     jni_GetStaticByteField,
3651     jni_GetStaticCharField,
3652     jni_GetStaticShortField,
3653     jni_GetStaticIntField,
3654     jni_GetStaticLongField,
3655     jni_GetStaticFloatField,
3656     jni_GetStaticDoubleField,
3657 
3658     jni_SetStaticObjectField,
3659     jni_SetStaticBooleanField,
3660     jni_SetStaticByteField,
3661     jni_SetStaticCharField,
3662     jni_SetStaticShortField,
3663     jni_SetStaticIntField,
3664     jni_SetStaticLongField,
3665     jni_SetStaticFloatField,
3666     jni_SetStaticDoubleField,
3667 
3668     jni_NewString,
3669     jni_GetStringLength,
3670     jni_GetStringChars,
3671     jni_ReleaseStringChars,
3672 
3673     jni_NewStringUTF,
3674     jni_GetStringUTFLength,
3675     jni_GetStringUTFChars,
3676     jni_ReleaseStringUTFChars,
3677 
3678     jni_GetArrayLength,
3679 
3680     jni_NewObjectArray,
3681     jni_GetObjectArrayElement,
3682     jni_SetObjectArrayElement,
3683 
3684     jni_NewBooleanArray,
3685     jni_NewByteArray,
3686     jni_NewCharArray,
3687     jni_NewShortArray,
3688     jni_NewIntArray,
3689     jni_NewLongArray,
3690     jni_NewFloatArray,
3691     jni_NewDoubleArray,
3692 
3693     jni_GetBooleanArrayElements,
3694     jni_GetByteArrayElements,
3695     jni_GetCharArrayElements,
3696     jni_GetShortArrayElements,
3697     jni_GetIntArrayElements,
3698     jni_GetLongArrayElements,
3699     jni_GetFloatArrayElements,
3700     jni_GetDoubleArrayElements,
3701 
3702     jni_ReleaseBooleanArrayElements,
3703     jni_ReleaseByteArrayElements,
3704     jni_ReleaseCharArrayElements,
3705     jni_ReleaseShortArrayElements,
3706     jni_ReleaseIntArrayElements,
3707     jni_ReleaseLongArrayElements,
3708     jni_ReleaseFloatArrayElements,
3709     jni_ReleaseDoubleArrayElements,
3710 
3711     jni_GetBooleanArrayRegion,
3712     jni_GetByteArrayRegion,
3713     jni_GetCharArrayRegion,
3714     jni_GetShortArrayRegion,
3715     jni_GetIntArrayRegion,
3716     jni_GetLongArrayRegion,
3717     jni_GetFloatArrayRegion,
3718     jni_GetDoubleArrayRegion,
3719 
3720     jni_SetBooleanArrayRegion,
3721     jni_SetByteArrayRegion,
3722     jni_SetCharArrayRegion,
3723     jni_SetShortArrayRegion,
3724     jni_SetIntArrayRegion,
3725     jni_SetLongArrayRegion,
3726     jni_SetFloatArrayRegion,
3727     jni_SetDoubleArrayRegion,
3728 
3729     jni_RegisterNatives,
3730     jni_UnregisterNatives,
3731 
3732     jni_MonitorEnter,
3733     jni_MonitorExit,
3734 
3735     jni_GetJavaVM,
3736 
3737     jni_GetStringRegion,
3738     jni_GetStringUTFRegion,
3739 
3740     jni_GetPrimitiveArrayCritical,
3741     jni_ReleasePrimitiveArrayCritical,
3742 
3743     jni_GetStringCritical,
3744     jni_ReleaseStringCritical,
3745 
3746     jni_NewWeakGlobalRef,
3747     jni_DeleteWeakGlobalRef,
3748 
3749     jni_ExceptionCheck,
3750 
3751     jni_NewDirectByteBuffer,
3752     jni_GetDirectBufferAddress,
3753     jni_GetDirectBufferCapacity,
3754 
3755     // New 1_6 features
3756 
3757     jni_GetObjectRefType,
3758 
3759     // Module features
3760 
3761     jni_GetModule
3762 };
3763 
3764 
3765 // For jvmti use to modify jni function table.
3766 // Java threads in native contiues to run until it is transitioned
3767 // to VM at safepoint. Before the transition or before it is blocked
3768 // for safepoint it may access jni function table. VM could crash if
3769 // any java thread access the jni function table in the middle of memcpy.
3770 // To avoid this each function pointers are copied automically.
3771 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3772   assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint");
3773   intptr_t *a = (intptr_t *) jni_functions();
3774   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3775   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
3776     Atomic::store(*b++, a++);
3777   }
3778 }
3779 
3780 void quicken_jni_functions() {
3781   // Replace Get&lt;Primitive&gt;Field with fast versions
3782   if (UseFastJNIAccessors &amp;&amp; !JvmtiExport::can_post_field_access()
3783       &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls
3784 #if defined(_WINDOWS) &amp;&amp; defined(IA32) &amp;&amp; defined(COMPILER2)
3785       // windows x86 currently needs SEH wrapper and the gain of the fast
3786       // versions currently isn't certain for server vm on uniprocessor.
3787       &amp;&amp; os::is_MP()
3788 #endif
3789   ) {
3790     address func;
3791     func = JNI_FastGetField::generate_fast_get_boolean_field();
3792     if (func != (address)-1) {
3793       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
3794     }
3795     func = JNI_FastGetField::generate_fast_get_byte_field();
3796     if (func != (address)-1) {
3797       jni_NativeInterface.GetByteField = (GetByteField_t)func;
3798     }
3799     func = JNI_FastGetField::generate_fast_get_char_field();
3800     if (func != (address)-1) {
3801       jni_NativeInterface.GetCharField = (GetCharField_t)func;
3802     }
3803     func = JNI_FastGetField::generate_fast_get_short_field();
3804     if (func != (address)-1) {
3805       jni_NativeInterface.GetShortField = (GetShortField_t)func;
3806     }
3807     func = JNI_FastGetField::generate_fast_get_int_field();
3808     if (func != (address)-1) {
3809       jni_NativeInterface.GetIntField = (GetIntField_t)func;
3810     }
3811     func = JNI_FastGetField::generate_fast_get_long_field();
3812     if (func != (address)-1) {
3813       jni_NativeInterface.GetLongField = (GetLongField_t)func;
3814     }
3815     func = JNI_FastGetField::generate_fast_get_float_field();
3816     if (func != (address)-1) {
3817       jni_NativeInterface.GetFloatField = (GetFloatField_t)func;
3818     }
3819     func = JNI_FastGetField::generate_fast_get_double_field();
3820     if (func != (address)-1) {
3821       jni_NativeInterface.GetDoubleField = (GetDoubleField_t)func;
3822     }
3823   }
3824 }
3825 
3826 // Returns the function structure
3827 struct JNINativeInterface_* jni_functions() {
3828 #if INCLUDE_JNI_CHECK
3829   if (CheckJNICalls) return jni_functions_check();
3830 #endif // INCLUDE_JNI_CHECK
3831   return &amp;jni_NativeInterface;
3832 }
3833 
3834 // Returns the function structure
3835 struct JNINativeInterface_* jni_functions_nocheck() {
3836   return &amp;jni_NativeInterface;
3837 }
3838 
3839 
3840 // Invocation API
3841 
3842 
3843 // Forward declaration
3844 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
3845 
3846 // Global invocation API vars
3847 volatile int vm_created = 0;
3848 // Indicate whether it is safe to recreate VM
3849 volatile int safe_to_recreate_vm = 1;
3850 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
3851 
3852 
3853 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
3854 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
3855 
3856 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
3857                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
3858 
3859 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
3860   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
3861   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
3862   jint ret = JNI_ERR;
3863   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
3864 
3865   if (Threads::is_supported_jni_version(args-&gt;version)) {
3866     ret = JNI_OK;
3867   }
3868   // 1.1 style no longer supported in hotspot.
3869   // According the JNI spec, we should update args-&gt;version on return.
3870   // We also use the structure to communicate with launcher about default
3871   // stack size.
3872   if (args-&gt;version == JNI_VERSION_1_1) {
3873     args-&gt;version = JNI_VERSION_1_2;
3874     // javaStackSize is int in arguments structure
3875     assert(jlong(ThreadStackSize) * K &lt; INT_MAX, "integer overflow");
3876     args-&gt;javaStackSize = (jint)(ThreadStackSize * K);
3877   }
3878   return ret;
3879 }
3880 
3881 DT_RETURN_MARK_DECL(CreateJavaVM, jint
3882                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
3883 
3884 static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
3885   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
3886 
3887   jint result = JNI_ERR;
3888   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
3889 
3890   // We're about to use Atomic::xchg for synchronization.  Some Zero
3891   // platforms use the GCC builtin __sync_lock_test_and_set for this,
3892   // but __sync_lock_test_and_set is not guaranteed to do what we want
3893   // on all architectures.  So we check it works before relying on it.
3894 #if defined(ZERO) &amp;&amp; defined(ASSERT)
3895   {
3896     jint a = 0xcafebabe;
3897     jint b = Atomic::xchg((jint) 0xdeadbeef, &amp;a);
3898     void *c = &amp;a;
3899     void *d = Atomic::xchg(&amp;b, &amp;c);
3900     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, "Atomic::xchg() works");
3901     assert(c == &amp;b &amp;&amp; d == &amp;a, "Atomic::xchg() works");
3902   }
3903 #endif // ZERO &amp;&amp; ASSERT
3904 
3905   // At the moment it's only possible to have one Java VM,
3906   // since some of the runtime state is in global variables.
3907 
3908   // We cannot use our mutex locks here, since they only work on
3909   // Threads. We do an atomic compare and exchange to ensure only
3910   // one thread can call this method at a time
3911 
3912   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
3913   // the add/dec implementations are dependent on whether we are running
3914   // on a multiprocessor, and at this stage of initialization the os::is_MP
3915   // function used to determine this will always return false. Atomic::xchg
3916   // does not have this problem.
3917   if (Atomic::xchg(1, &amp;vm_created) == 1) {
3918     return JNI_EEXIST;   // already created, or create attempt in progress
3919   }
3920   if (Atomic::xchg(0, &amp;safe_to_recreate_vm) == 0) {
3921     return JNI_ERR;  // someone tried and failed and retry not allowed.
3922   }
3923 
3924   assert(vm_created == 1, "vm_created is true during the creation");
3925 
3926   /**
3927    * Certain errors during initialization are recoverable and do not
3928    * prevent this method from being called again at a later time
3929    * (perhaps with different arguments).  However, at a certain
3930    * point during initialization if an error occurs we cannot allow
3931    * this function to be called again (or it will crash).  In those
3932    * situations, the 'canTryAgain' flag is set to false, which atomically
3933    * sets safe_to_recreate_vm to 1, such that any new call to
3934    * JNI_CreateJavaVM will immediately fail using the above logic.
3935    */
3936   bool can_try_again = true;
3937 
3938   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
3939   if (result == JNI_OK) {
3940     JavaThread *thread = JavaThread::current();
3941     assert(!thread-&gt;has_pending_exception(), "should have returned not OK");
3942     /* thread is thread_in_vm here */
3943     *vm = (JavaVM *)(&amp;main_vm);
3944     *(JNIEnv**)penv = thread-&gt;jni_environment();
3945 
3946 #if INCLUDE_JVMCI
3947     if (EnableJVMCI) {
3948       if (UseJVMCICompiler) {
3949         // JVMCI is initialized on a CompilerThread
3950         if (BootstrapJVMCI) {
3951           JavaThread* THREAD = thread;
3952           JVMCICompiler* compiler = JVMCICompiler::instance(CATCH);
3953           compiler-&gt;bootstrap(THREAD);
3954           if (HAS_PENDING_EXCEPTION) {
3955             HandleMark hm;
3956             vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
3957           }
3958         }
3959       }
3960     }
3961 #endif
3962 
3963     // Tracks the time application was running before GC
3964     RuntimeService::record_application_start();
3965 
3966     // Notify JVMTI
3967     if (JvmtiExport::should_post_thread_life()) {
3968        JvmtiExport::post_thread_start(thread);
3969     }
3970 
3971     EventThreadStart event;
3972     if (event.should_commit()) {
3973       event.set_thread(THREAD_TRACE_ID(thread));
3974       event.commit();
3975     }
3976 
3977 #ifndef PRODUCT
3978     // Check if we should compile all classes on bootclasspath
3979     if (CompileTheWorld) ClassLoader::compile_the_world();
3980     if (ReplayCompiles) ciReplay::replay(thread);
3981 
3982     // Some platforms (like Win*) need a wrapper around these test
3983     // functions in order to properly handle error conditions.
3984     VMError::test_error_handler();
3985     if (ExecuteInternalVMTests) {
3986       InternalVMTests::run();
3987     }
3988 #endif
3989 
3990     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
3991     ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
3992   } else {
3993     // If create_vm exits because of a pending exception, exit with that
3994     // exception.  In the future when we figure out how to reclaim memory,
3995     // we may be able to exit with JNI_ERR and allow the calling application
3996     // to continue.
3997     if (Universe::is_fully_initialized()) {
3998       // otherwise no pending exception possible - VM will already have aborted
3999       JavaThread* THREAD = JavaThread::current();
4000       if (HAS_PENDING_EXCEPTION) {
4001         HandleMark hm;
4002         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
4003       }
4004     }
4005 
4006     if (can_try_again) {
4007       // reset safe_to_recreate_vm to 1 so that retrial would be possible
4008       safe_to_recreate_vm = 1;
4009     }
4010 
4011     // Creation failed. We must reset vm_created
4012     *vm = 0;
4013     *(JNIEnv**)penv = 0;
4014     // reset vm_created last to avoid race condition. Use OrderAccess to
4015     // control both compiler and architectural-based reordering.
4016     OrderAccess::release_store(&amp;vm_created, 0);
4017   }
4018 
4019   // Flush stdout and stderr before exit.
4020   fflush(stdout);
4021   fflush(stderr);
4022 
4023   return result;
4024 
4025 }
4026 
4027 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
4028   jint result = JNI_ERR;
4029   // On Windows, let CreateJavaVM run with SEH protection
4030 #ifdef _WIN32
4031   __try {
4032 #endif
4033     result = JNI_CreateJavaVM_inner(vm, penv, args);
4034 #ifdef _WIN32
4035   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4036     // Nothing to do.
4037   }
4038 #endif
4039   return result;
4040 }
4041 
4042 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
4043   // See bug 4367188, the wrapper can sometimes cause VM crashes
4044   // JNIWrapper("GetCreatedJavaVMs");
4045 
4046   HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY((void **) vm_buf, bufLen, (uintptr_t *) numVMs);
4047 
4048   if (vm_created == 1) {
4049     if (numVMs != NULL) *numVMs = 1;
4050     if (bufLen &gt; 0)     *vm_buf = (JavaVM *)(&amp;main_vm);
4051   } else {
4052     if (numVMs != NULL) *numVMs = 0;
4053   }
4054   HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(JNI_OK);
4055   return JNI_OK;
4056 }
4057 
4058 extern "C" {
4059 
4060 DT_RETURN_MARK_DECL(DestroyJavaVM, jint
4061                     , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));
4062 
4063 static jint JNICALL jni_DestroyJavaVM_inner(JavaVM *vm) {
4064   HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(vm);
4065   jint res = JNI_ERR;
4066   DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&amp;)res);
4067 
4068   if (vm_created == 0) {
4069     res = JNI_ERR;
4070     return res;
4071   }
4072 
4073   JNIWrapper("DestroyJavaVM");
4074   JNIEnv *env;
4075   JavaVMAttachArgs destroyargs;
4076   destroyargs.version = CurrentVersion;
4077   destroyargs.name = (char *)"DestroyJavaVM";
4078   destroyargs.group = NULL;
4079   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
4080   if (res != JNI_OK) {
4081     return res;
4082   }
4083 
4084   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
4085   JavaThread* thread = JavaThread::current();
4086   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4087   if (Threads::destroy_vm()) {
4088     // Should not change thread state, VM is gone
4089     vm_created = 0;
4090     res = JNI_OK;
4091     return res;
4092   } else {
4093     ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
4094     res = JNI_ERR;
4095     return res;
4096   }
4097 }
4098 
4099 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
4100   jint result = JNI_ERR;
4101   // On Windows, we need SEH protection
4102 #ifdef _WIN32
4103   __try {
4104 #endif
4105     result = jni_DestroyJavaVM_inner(vm);
4106 #ifdef _WIN32
4107   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4108     // Nothing to do.
4109   }
4110 #endif
4111   return result;
4112 }
4113 
4114 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
4115   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
4116 
4117   // Check below commented out from JDK1.2fcs as well
4118   /*
4119   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
4120     return JNI_EVERSION;
4121   }
4122   */
4123 
4124   Thread* t = Thread::current_or_null();
4125   if (t != NULL) {
4126     // If the thread has been attached this operation is a no-op
4127     *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();
4128     return JNI_OK;
4129   }
4130 
4131   // Create a thread and mark it as attaching so it will be skipped by the
4132   // ThreadsListEnumerator - see CR 6404306
4133   JavaThread* thread = new JavaThread(true);
4134 
4135   // Set correct safepoint info. The thread is going to call into Java when
4136   // initializing the Java level thread object. Hence, the correct state must
4137   // be set in order for the Safepoint code to deal with it correctly.
4138   thread-&gt;set_thread_state(_thread_in_vm);
4139   thread-&gt;record_stack_base_and_size();
4140   thread-&gt;initialize_thread_current();
4141 
4142   if (!os::create_attached_thread(thread)) {
4143     delete thread;
4144     return JNI_ERR;
4145   }
4146   // Enable stack overflow checks
4147   thread-&gt;create_stack_guard_pages();
4148 
4149   thread-&gt;initialize_tlab();
4150 
4151   thread-&gt;cache_global_variables();
4152 
4153   // Crucial that we do not have a safepoint check for this thread, since it has
4154   // not been added to the Thread list yet.
4155   { Threads_lock-&gt;lock_without_safepoint_check();
4156     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
4157     // avoid this thread trying to do a GC before it is added to the thread-list
4158     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
4159     Threads::add(thread, daemon);
4160     Threads_lock-&gt;unlock();
4161   }
4162   // Create thread group and name info from attach arguments
4163   oop group = NULL;
4164   char* thread_name = NULL;
4165   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
4166     group = JNIHandles::resolve(args-&gt;group);
4167     thread_name = args-&gt;name; // may be NULL
4168   }
4169   if (group == NULL) group = Universe::main_thread_group();
4170 
4171   // Create Java level thread object and attach it to this thread
4172   bool attach_failed = false;
4173   {
4174     EXCEPTION_MARK;
4175     HandleMark hm(THREAD);
4176     Handle thread_group(THREAD, group);
4177     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
4178     if (HAS_PENDING_EXCEPTION) {
4179       CLEAR_PENDING_EXCEPTION;
4180       // cleanup outside the handle mark.
4181       attach_failed = true;
4182     }
4183   }
4184 
4185   if (attach_failed) {
4186     // Added missing cleanup
4187     thread-&gt;cleanup_failed_attach_current_thread();
4188     return JNI_ERR;
4189   }
4190 
4191   // mark the thread as no longer attaching
4192   // this uses a fence to push the change through so we don't have
4193   // to regrab the threads_lock
4194   thread-&gt;set_done_attaching_via_jni();
4195 
4196   // Set java thread status.
4197   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4198               java_lang_Thread::RUNNABLE);
4199 
4200   // Notify the debugger
4201   if (JvmtiExport::should_post_thread_life()) {
4202     JvmtiExport::post_thread_start(thread);
4203   }
4204 
4205   EventThreadStart event;
4206   if (event.should_commit()) {
4207     event.set_thread(THREAD_TRACE_ID(thread));
4208     event.commit();
4209   }
4210 
4211   *(JNIEnv**)penv = thread-&gt;jni_environment();
4212 
4213   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4214   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4215   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4216   // needed.
4217 
4218   ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
4219 
4220   // Perform any platform dependent FPU setup
4221   os::setup_fpu();
4222 
4223   return JNI_OK;
4224 }
4225 
4226 
4227 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4228   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4229   if (vm_created == 0) {
4230   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4231     return JNI_ERR;
4232   }
4233 
4234   JNIWrapper("AttachCurrentThread");
4235   jint ret = attach_current_thread(vm, penv, _args, false);
4236   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4237   return ret;
4238 }
4239 
4240 
4241 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4242   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
4243   VM_Exit::block_if_vm_exited();
4244 
4245   JNIWrapper("DetachCurrentThread");
4246 
4247   // If the thread has already been detached the operation is a no-op
4248   if (Thread::current_or_null() == NULL) {
4249   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4250     return JNI_OK;
4251   }
4252 
4253   JavaThread* thread = JavaThread::current();
4254   if (thread-&gt;has_last_Java_frame()) {
4255   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4256     // Can't detach a thread that's running java, that can't work.
4257     return JNI_ERR;
4258   }
4259 
4260   // Safepoint support. Have to do call-back to safepoint code, if in the
4261   // middel of a safepoint operation
4262   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4263 
4264   // XXX: Note that JavaThread::exit() call below removes the guards on the
4265   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4266   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4267   // of the guards is visible in jni_AttachCurrentThread above,
4268   // the removal of the guards is buried below in JavaThread::exit()
4269   // here. The abstraction should be more symmetrically either exposed
4270   // or hidden (e.g. it could probably be hidden in the same
4271   // (platform-dependent) methods where we do alternate stack
4272   // maintenance work?)
4273   thread-&gt;exit(false, JavaThread::jni_detach);
4274   delete thread;
4275 
4276   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4277   return JNI_OK;
4278 }
4279 
4280 DT_RETURN_MARK_DECL(GetEnv, jint
4281                     , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));
4282 
4283 jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
4284   HOTSPOT_JNI_GETENV_ENTRY(vm, penv, version);
4285   jint ret = JNI_ERR;
4286   DT_RETURN_MARK(GetEnv, jint, (const jint&amp;)ret);
4287 
4288   if (vm_created == 0) {
4289     *penv = NULL;
4290     ret = JNI_EDETACHED;
4291     return ret;
4292   }
4293 
4294   if (JniExportedInterface::GetExportedInterface(vm, penv, version, &amp;ret)) {
4295     return ret;
4296   }
4297 
4298 #ifndef JVMPI_VERSION_1
4299 // need these in order to be polite about older agents
4300 #define JVMPI_VERSION_1   ((jint)0x10000001)
4301 #define JVMPI_VERSION_1_1 ((jint)0x10000002)
4302 #define JVMPI_VERSION_1_2 ((jint)0x10000003)
4303 #endif // !JVMPI_VERSION_1
4304 
4305   Thread* thread = Thread::current_or_null();
4306   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread()) {
4307     if (Threads::is_supported_jni_version_including_1_1(version)) {
4308       *(JNIEnv**)penv = ((JavaThread*) thread)-&gt;jni_environment();
4309       ret = JNI_OK;
4310       return ret;
4311 
4312     } else if (version == JVMPI_VERSION_1 ||
4313                version == JVMPI_VERSION_1_1 ||
4314                version == JVMPI_VERSION_1_2) {
4315       tty-&gt;print_cr("ERROR: JVMPI, an experimental interface, is no longer supported.");
4316       tty-&gt;print_cr("Please use the supported interface: the JVM Tool Interface (JVM TI).");
4317       ret = JNI_EVERSION;
4318       return ret;
4319     } else if (JvmtiExport::is_jvmdi_version(version)) {
4320       tty-&gt;print_cr("FATAL ERROR: JVMDI is no longer supported.");
4321       tty-&gt;print_cr("Please use the supported interface: the JVM Tool Interface (JVM TI).");
4322       ret = JNI_EVERSION;
4323       return ret;
4324     } else {
4325       *penv = NULL;
4326       ret = JNI_EVERSION;
4327       return ret;
4328     }
4329   } else {
4330     *penv = NULL;
4331     ret = JNI_EDETACHED;
4332     return ret;
4333   }
4334 }
4335 
4336 
4337 jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
4338   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(vm, penv, _args);
4339   if (vm_created == 0) {
4340   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);
4341     return JNI_ERR;
4342   }
4343 
4344   JNIWrapper("AttachCurrentThreadAsDaemon");
4345   jint ret = attach_current_thread(vm, penv, _args, true);
4346   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(ret);
4347   return ret;
4348 }
4349 
4350 
4351 } // End extern "C"
4352 
4353 const struct JNIInvokeInterface_ jni_InvokeInterface = {
4354     NULL,
4355     NULL,
4356     NULL,
4357 
4358     jni_DestroyJavaVM,
4359     jni_AttachCurrentThread,
4360     jni_DetachCurrentThread,
4361     jni_GetEnv,
4362     jni_AttachCurrentThreadAsDaemon
4363 };
</pre></body></html>
