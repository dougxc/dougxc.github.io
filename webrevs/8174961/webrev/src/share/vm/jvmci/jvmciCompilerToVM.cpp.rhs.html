<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12631">12631</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8174961">8174961</a>: [JVMCI] incorrect implementation of isCompilable</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "code/codeCache.hpp"
  27 #include "code/scopeDesc.hpp"
  28 #include "interpreter/linkResolver.hpp"
  29 #include "memory/oopFactory.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "oops/generateOopMap.hpp"
  32 #include "oops/fieldStreams.hpp"
  33 #include "oops/oop.inline.hpp"
  34 #include "oops/objArrayOop.inline.hpp"
  35 #include "runtime/fieldDescriptor.hpp"
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"
  56 #include "utilities/resourceHash.hpp"
  57 
  58 
  59 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  60 #define C2V_VMENTRY(result_type, name, signature) \
  61   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  62   TRACE_jvmci_1("CompilerToVM::" #name); \
  63   TRACE_CALL(result_type, jvmci_ ## name signature) \
  64   JVMCI_VM_ENTRY_MARK; \
  65 
  66 #define C2V_END }
  67 
  68 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  69   if (method() != NULL) {
  70     JavaValue result(T_OBJECT);
  71     JavaCallArguments args;
  72     args.push_long((jlong) (address) method());
  73     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  74 
  75     return (oop)result.get_jobject();
  76   }
  77   return NULL;
  78 }
  79 
  80 oop CompilerToVM::get_jvmci_type(KlassHandle klass, TRAPS) {
  81   if (klass() != NULL) {
  82     JavaValue result(T_OBJECT);
  83     JavaCallArguments args;
  84     args.push_oop(klass-&gt;java_mirror());
  85     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  86 
  87     return (oop)result.get_jobject();
  88   }
  89   return NULL;
  90 }
  91 
  92 int CompilerToVM::Data::Klass_vtable_start_offset;
  93 int CompilerToVM::Data::Klass_vtable_length_offset;
  94 
  95 int CompilerToVM::Data::Method_extra_stack_entries;
  96 
  97 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
  98 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
  99 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
 100 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 101 
 102 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 103 
 104 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 105 int CompilerToVM::Data::Universe_base_vtable_size;
 106 address CompilerToVM::Data::Universe_narrow_oop_base;
 107 int CompilerToVM::Data::Universe_narrow_oop_shift;
 108 address CompilerToVM::Data::Universe_narrow_klass_base;
 109 int CompilerToVM::Data::Universe_narrow_klass_shift;
 110 void* CompilerToVM::Data::Universe_non_oop_bits;
 111 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 112 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 113 
 114 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 115 HeapWord** CompilerToVM::Data::_heap_end_addr;
 116 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
 117 int CompilerToVM::Data::_max_oop_map_stack_offset;
 118 
 119 jbyte* CompilerToVM::Data::cardtable_start_address;
 120 int CompilerToVM::Data::cardtable_shift;
 121 
 122 int CompilerToVM::Data::vm_page_size;
 123 
 124 int CompilerToVM::Data::sizeof_vtableEntry = sizeof(vtableEntry);
 125 int CompilerToVM::Data::sizeof_ExceptionTableElement = sizeof(ExceptionTableElement);
 126 int CompilerToVM::Data::sizeof_LocalVariableTableElement = sizeof(LocalVariableTableElement);
 127 int CompilerToVM::Data::sizeof_ConstantPool = sizeof(ConstantPool);
 128 int CompilerToVM::Data::sizeof_SymbolPointer = sizeof(Symbol*);
 129 int CompilerToVM::Data::sizeof_narrowKlass = sizeof(narrowKlass);
 130 int CompilerToVM::Data::sizeof_arrayOopDesc = sizeof(arrayOopDesc);
 131 int CompilerToVM::Data::sizeof_BasicLock = sizeof(BasicLock);
 132 
 133 address CompilerToVM::Data::dsin;
 134 address CompilerToVM::Data::dcos;
 135 address CompilerToVM::Data::dtan;
 136 address CompilerToVM::Data::dexp;
 137 address CompilerToVM::Data::dlog;
 138 address CompilerToVM::Data::dlog10;
 139 address CompilerToVM::Data::dpow;
 140 
 141 address CompilerToVM::Data::symbol_init;
 142 address CompilerToVM::Data::symbol_clinit;
 143 
 144 void CompilerToVM::Data::initialize(TRAPS) {
 145   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 146   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 147 
 148   Method_extra_stack_entries = Method::extra_stack_entries();
 149 
 150   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 151   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 152   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 153   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 154 
 155   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 156 
 157   Universe_collectedHeap = Universe::heap();
 158   Universe_base_vtable_size = Universe::base_vtable_size();
 159   Universe_narrow_oop_base = Universe::narrow_oop_base();
 160   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 161   Universe_narrow_klass_base = Universe::narrow_klass_base();
 162   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 163   Universe_non_oop_bits = Universe::non_oop_word();
 164   Universe_verify_oop_mask = Universe::verify_oop_mask();
 165   Universe_verify_oop_bits = Universe::verify_oop_bits();
 166 
 167   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 168   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 169   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
 170 
 171   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 172   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 173   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 174   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 175 
 176   symbol_init = (address) vmSymbols::object_initializer_name();
 177   symbol_clinit = (address) vmSymbols::class_initializer_name();
 178 
 179   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 180   switch (bs-&gt;kind()) {
 181   case BarrierSet::CardTableModRef:
 182   case BarrierSet::CardTableForRS:
 183   case BarrierSet::CardTableExtension:
 184   case BarrierSet::G1SATBCT:
 185   case BarrierSet::G1SATBCTLogging: {
 186     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 187     assert(base != 0, "unexpected byte_map_base");
 188     cardtable_start_address = base;
 189     cardtable_shift = CardTableModRefBS::card_shift;
 190     break;
 191   }
 192   case BarrierSet::ModRef:
 193     cardtable_start_address = 0;
 194     cardtable_shift = 0;
 195     // No post barriers
 196     break;
 197   default:
 198     JVMCI_ERROR("Unsupported BarrierSet kind %d", bs-&gt;kind());
 199     break;
 200   }
 201 
 202   vm_page_size = os::vm_page_size();
 203 
 204 #define SET_TRIGFUNC(name)                                      \
 205   if (StubRoutines::name() != NULL) {                           \
 206     name = StubRoutines::name();                                \
 207   } else {                                                      \
 208     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 209   }
 210 
 211   SET_TRIGFUNC(dsin);
 212   SET_TRIGFUNC(dcos);
 213   SET_TRIGFUNC(dtan);
 214   SET_TRIGFUNC(dexp);
 215   SET_TRIGFUNC(dlog10);
 216   SET_TRIGFUNC(dlog);
 217   SET_TRIGFUNC(dpow);
 218 
 219 #undef SET_TRIGFUNC
 220 }
 221 
 222 objArrayHandle CompilerToVM::initialize_intrinsics(TRAPS) {
 223   objArrayHandle vmIntrinsics = oopFactory::new_objArray(VMIntrinsicMethod::klass(), (vmIntrinsics::ID_LIMIT - 1), CHECK_(objArrayHandle()));
 224   int index = 0;
 225   // The intrinsics for a class are usually adjacent to each other.
 226   // When they are, the string for the class name can be reused.
 227   vmSymbols::SID kls_sid = vmSymbols::NO_SID;
 228   Handle kls_str;
 229 #define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)
 230 #define VM_SYMBOL_TO_STRING(s) \
 231   java_lang_String::create_from_symbol(vmSymbols::symbol_at(SID_ENUM(s)), CHECK_(objArrayHandle()))
 232 #define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \
 233     instanceHandle vmIntrinsicMethod = InstanceKlass::cast(VMIntrinsicMethod::klass())-&gt;allocate_instance_handle(CHECK_(objArrayHandle())); \
 234     if (kls_sid != SID_ENUM(kls)) {                                       \
 235       kls_str = VM_SYMBOL_TO_STRING(kls);                                 \
 236       kls_sid = SID_ENUM(kls);                                            \
 237     }                                                                     \
 238     Handle name_str = VM_SYMBOL_TO_STRING(name);                          \
 239     Handle sig_str = VM_SYMBOL_TO_STRING(sig);                            \
 240     VMIntrinsicMethod::set_declaringClass(vmIntrinsicMethod, kls_str());  \
 241     VMIntrinsicMethod::set_name(vmIntrinsicMethod, name_str());           \
 242     VMIntrinsicMethod::set_descriptor(vmIntrinsicMethod, sig_str());      \
 243     VMIntrinsicMethod::set_id(vmIntrinsicMethod, vmIntrinsics::id);       \
 244       vmIntrinsics-&gt;obj_at_put(index++, vmIntrinsicMethod());             \
 245   }
 246 
 247   VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
 248 #undef SID_ENUM
 249 #undef VM_SYMBOL_TO_STRING
 250 #undef VM_INTRINSIC_INFO
 251   assert(index == vmIntrinsics::ID_LIMIT - 1, "must be");
 252 
 253   return vmIntrinsics;
 254 }
 255 
 256 /**
 257  * The set of VM flags known to be used.
 258  */
 259 #define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_intx_flag, do_uintx_flag) \
 260   do_intx_flag(AllocateInstancePrefetchLines)                              \
 261   do_intx_flag(AllocatePrefetchDistance)                                   \
 262   do_intx_flag(AllocatePrefetchInstr)                                      \
 263   do_intx_flag(AllocatePrefetchLines)                                      \
 264   do_intx_flag(AllocatePrefetchStepSize)                                   \
 265   do_intx_flag(AllocatePrefetchStyle)                                      \
 266   do_intx_flag(BciProfileWidth)                                            \
 267   do_bool_flag(BootstrapJVMCI)                                             \
 268   do_bool_flag(CITime)                                                     \
 269   do_bool_flag(CITimeEach)                                                 \
 270   do_uintx_flag(CodeCacheSegmentSize)                                      \
 271   do_intx_flag(CodeEntryAlignment)                                         \
 272   do_bool_flag(CompactFields)                                              \
 273   NOT_PRODUCT(do_intx_flag(CompileTheWorldStartAt))                        \
 274   NOT_PRODUCT(do_intx_flag(CompileTheWorldStopAt))                         \
 275   do_intx_flag(ContendedPaddingWidth)                                      \
 276   do_bool_flag(DontCompileHugeMethods)                                     \
 277   do_bool_flag(EnableContended)                                            \
 278   do_intx_flag(FieldsAllocationStyle)                                      \
 279   do_bool_flag(FoldStableValues)                                           \
 280   do_bool_flag(ForceUnreachable)                                           \
 281   do_intx_flag(HugeMethodLimit)                                            \
 282   do_bool_flag(Inline)                                                     \
 283   do_intx_flag(JVMCICounterSize)                                           \
 284   do_bool_flag(JVMCIPrintProperties)                                       \
 285   do_bool_flag(JVMCIUseFastLocking)                                        \
 286   do_intx_flag(MethodProfileWidth)                                         \
 287   do_intx_flag(ObjectAlignmentInBytes)                                     \
 288   do_bool_flag(PrintInlining)                                              \
 289   do_bool_flag(ReduceInitialCardMarks)                                     \
 290   do_bool_flag(RestrictContended)                                          \
 291   do_intx_flag(StackReservedPages)                                         \
 292   do_intx_flag(StackShadowPages)                                           \
 293   do_bool_flag(TLABStats)                                                  \
 294   do_uintx_flag(TLABWasteIncrement)                                        \
 295   do_intx_flag(TypeProfileWidth)                                           \
 296   do_bool_flag(UseAESIntrinsics)                                           \
 297   X86_ONLY(do_intx_flag(UseAVX))                                           \
 298   do_bool_flag(UseBiasedLocking)                                           \
 299   do_bool_flag(UseCRC32Intrinsics)                                         \
 300   do_bool_flag(UseCompressedClassPointers)                                 \
 301   do_bool_flag(UseCompressedOops)                                          \
 302   do_bool_flag(UseConcMarkSweepGC)                                         \
 303   X86_ONLY(do_bool_flag(UseCountLeadingZerosInstruction))                  \
 304   X86_ONLY(do_bool_flag(UseCountTrailingZerosInstruction))                 \
 305   do_bool_flag(UseG1GC)                                                    \
 306   COMPILER2_PRESENT(do_bool_flag(UseMontgomeryMultiplyIntrinsic))          \
 307   COMPILER2_PRESENT(do_bool_flag(UseMontgomerySquareIntrinsic))            \
 308   COMPILER2_PRESENT(do_bool_flag(UseMulAddIntrinsic))                      \
 309   COMPILER2_PRESENT(do_bool_flag(UseMultiplyToLenIntrinsic))               \
 310   do_bool_flag(UsePopCountInstruction)                                     \
 311   do_bool_flag(UseSHA1Intrinsics)                                          \
 312   do_bool_flag(UseSHA256Intrinsics)                                        \
 313   do_bool_flag(UseSHA512Intrinsics)                                        \
 314   do_intx_flag(UseSSE)                                                     \
 315   COMPILER2_PRESENT(do_bool_flag(UseSquareToLenIntrinsic))                 \
 316   do_bool_flag(UseStackBanging)                                            \
 317   do_bool_flag(UseTLAB)                                                    \
 318   do_bool_flag(VerifyOops)                                                 \
 319 
 320 #define BOXED_BOOLEAN(name, value) oop name = ((jboolean)(value) ? boxedTrue() : boxedFalse())
 321 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)
 322 #define BOXED_LONG(name, value) \
 323   oop name; \
 324   do { \
 325     jvalue p; p.j = (jlong) (value); \
 326     Handle* e = longs.get(p.j); \
 327     if (e == NULL) { \
 328       Handle h = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); \
 329       longs.put(p.j, h); \
 330       name = h(); \
 331     } else { \
 332       name = (*e)(); \
 333     } \
 334   } while (0)
 335 
 336 #define CSTRING_TO_JSTRING(name, value) \
 337   Handle name; \
 338   do { \
 339     if (value != NULL) { \
 340       Handle* e = strings.get(value); \
 341       if (e == NULL) { \
 342         Handle h = java_lang_String::create_from_str(value, CHECK_NULL); \
 343         strings.put(value, h); \
 344         name = h(); \
 345       } else { \
 346         name = (*e)(); \
 347       } \
 348     } \
 349   } while (0)
 350 
 351 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))
 352   ResourceMark rm;
 353   HandleMark hm;
 354 
 355   // Used to canonicalize Long and String values.
 356   ResourceHashtable&lt;jlong, Handle&gt; longs;
 357   ResourceHashtable&lt;const char*, Handle, &amp;CompilerToVM::cstring_hash, &amp;CompilerToVM::cstring_equals&gt; strings;
 358 
 359   jvalue prim;
 360   prim.z = true;  Handle boxedTrue =  java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 361   prim.z = false; Handle boxedFalse = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 362 
 363   CompilerToVM::Data::initialize(CHECK_NULL);
 364 
 365   VMField::klass()-&gt;initialize(CHECK_NULL);
 366   VMFlag::klass()-&gt;initialize(CHECK_NULL);
 367   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);
 368 
 369   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
 370   objArrayHandle vmFields = oopFactory::new_objArray(VMField::klass(), len, CHECK_NULL);
 371   for (int i = 0; i &lt; len ; i++) {
 372     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
 373     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 374     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* "::" */;
 375     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
 376     sprintf(name_buf, "%s::%s", vmField.typeName, vmField.fieldName);
 377     CSTRING_TO_JSTRING(name, name_buf);
 378     CSTRING_TO_JSTRING(type, vmField.typeString);
 379     VMField::set_name(vmFieldObj, name());
 380     VMField::set_type(vmFieldObj, type());
 381     VMField::set_offset(vmFieldObj, vmField.offset);
 382     VMField::set_address(vmFieldObj, (jlong) vmField.address);
 383     if (vmField.isStatic &amp;&amp; vmField.typeString != NULL) {
 384       if (strcmp(vmField.typeString, "bool") == 0) {
 385         BOXED_BOOLEAN(box, *(jbyte*) vmField.address);
 386         VMField::set_value(vmFieldObj, box);
 387       } else if (strcmp(vmField.typeString, "int") == 0 ||
 388                  strcmp(vmField.typeString, "jint") == 0) {
 389         BOXED_LONG(box, *(jint*) vmField.address);
 390         VMField::set_value(vmFieldObj, box);
 391       } else if (strcmp(vmField.typeString, "uint64_t") == 0) {
 392         BOXED_LONG(box, *(uint64_t*) vmField.address);
 393         VMField::set_value(vmFieldObj, box);
 394       } else if (strcmp(vmField.typeString, "address") == 0 ||
 395                  strcmp(vmField.typeString, "intptr_t") == 0 ||
 396                  strcmp(vmField.typeString, "uintptr_t") == 0 ||
 397                  strcmp(vmField.typeString, "size_t") == 0 ||
 398                  // All foo* types are addresses.
 399                  vmField.typeString[strlen(vmField.typeString) - 1] == '*') {
 400         BOXED_LONG(box, *((address*) vmField.address));
 401         VMField::set_value(vmFieldObj, box);
 402       } else {
 403         JVMCI_ERROR_NULL("VM field %s has unsupported type %s", name_buf, vmField.typeString);
 404       }
 405     }
 406     vmFields-&gt;obj_at_put(i, vmFieldObj());
 407   }
 408 
 409   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
 410   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
 411   len = ints_len + longs_len;
 412   objArrayHandle vmConstants = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 413   int insert = 0;
 414   for (int i = 0; i &lt; ints_len ; i++) {
 415     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
 416     CSTRING_TO_JSTRING(name, c.name);
 417     BOXED_LONG(value, c.value);
 418     vmConstants-&gt;obj_at_put(insert++, name());
 419     vmConstants-&gt;obj_at_put(insert++, value);
 420   }
 421   for (int i = 0; i &lt; longs_len ; i++) {
 422     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
 423     CSTRING_TO_JSTRING(name, c.name);
 424     BOXED_LONG(value, c.value);
 425     vmConstants-&gt;obj_at_put(insert++, name());
 426     vmConstants-&gt;obj_at_put(insert++, value);
 427   }
 428   assert(insert == len * 2, "must be");
 429 
 430   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
 431   objArrayHandle vmAddresses = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 432   for (int i = 0; i &lt; len ; i++) {
 433     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
 434     CSTRING_TO_JSTRING(name, a.name);
 435     BOXED_LONG(value, a.value);
 436     vmAddresses-&gt;obj_at_put(i * 2, name());
 437     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);
 438   }
 439 
 440 #define COUNT_FLAG(ignore) +1
 441 #ifdef ASSERT
 442 #define CHECK_FLAG(type, name) { \
 443   Flag* flag = Flag::find_flag(#name, strlen(#name), /*allow_locked*/ true, /* return_flag */ true); \
 444   assert(flag != NULL, "No such flag named " #name); \
 445   assert(flag-&gt;is_##type(), "Flag " #name " is not of type " #type); \
 446 }
 447 #else
 448 #define CHECK_FLAG(type, name)
 449 #endif
 450 
 451 #define ADD_FLAG(type, name, convert) { \
 452   CHECK_FLAG(type, name) \
 453   instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL); \
 454   CSTRING_TO_JSTRING(fname, #name); \
 455   CSTRING_TO_JSTRING(ftype, #type); \
 456   VMFlag::set_name(vmFlagObj, fname()); \
 457   VMFlag::set_type(vmFlagObj, ftype()); \
 458   convert(value, name); \
 459   VMFlag::set_value(vmFlagObj, value); \
 460   vmFlags-&gt;obj_at_put(i++, vmFlagObj()); \
 461 }
 462 #define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)
 463 #define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)
 464 #define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)
 465 
 466   len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);
 467   objArrayHandle vmFlags = oopFactory::new_objArray(VMFlag::klass(), len, CHECK_NULL);
 468   int i = 0;
 469   PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)
 470 
 471   objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);
 472 
 473   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 5, CHECK_NULL);
 474   data-&gt;obj_at_put(0, vmFields());
 475   data-&gt;obj_at_put(1, vmConstants());
 476   data-&gt;obj_at_put(2, vmAddresses());
 477   data-&gt;obj_at_put(3, vmFlags());
 478   data-&gt;obj_at_put(4, vmIntrinsics());
 479 
 480   return (jobjectArray) JNIHandles::make_local(THREAD, data);
 481 #undef COUNT_FLAG
 482 #undef ADD_FLAG
 483 #undef ADD_BOOL_FLAG
 484 #undef ADD_INTX_FLAG
 485 #undef ADD_UINTX_FLAG
 486 #undef CHECK_FLAG
 487 C2V_END
 488 
 489 C2V_VMENTRY(jobject, getFlagValue, (JNIEnv *, jobject c2vm, jobject name_handle))
 490 #define RETURN_BOXED_LONG(value) oop box; jvalue p; p.j = (jlong) (value); box = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);
 491 #define RETURN_BOXED_DOUBLE(value) oop box; jvalue p; p.d = (jdouble) (value); box = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);
 492   Handle name = JNIHandles::resolve(name_handle);
 493   if (name.is_null()) {
 494     THROW_0(vmSymbols::java_lang_NullPointerException());
 495   }
 496   ResourceMark rm;
 497   const char* cstring = java_lang_String::as_utf8_string(name());
 498   Flag* flag = Flag::find_flag(cstring, strlen(cstring), /* allow_locked */ true, /* return_flag */ true);
 499   if (flag == NULL) {
 500     return c2vm;
 501   }
 502   if (flag-&gt;is_bool()) {
 503     jvalue prim;
 504     prim.z = flag-&gt;get_bool();
 505     oop box = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 506     return JNIHandles::make_local(THREAD, box);
 507   } else if (flag-&gt;is_ccstr()) {
 508     Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
 509     return JNIHandles::make_local(THREAD, value());
 510   } else if (flag-&gt;is_intx()) {
 511     RETURN_BOXED_LONG(flag-&gt;get_intx());
 512   } else if (flag-&gt;is_int()) {
 513     RETURN_BOXED_LONG(flag-&gt;get_int());
 514   } else if (flag-&gt;is_uint()) {
 515     RETURN_BOXED_LONG(flag-&gt;get_uint());
 516   } else if (flag-&gt;is_uint64_t()) {
 517     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());
 518   } else if (flag-&gt;is_size_t()) {
 519     RETURN_BOXED_LONG(flag-&gt;get_size_t());
 520   } else if (flag-&gt;is_uintx()) {
 521     RETURN_BOXED_LONG(flag-&gt;get_uintx());
 522   } else if (flag-&gt;is_double()) {
 523     RETURN_BOXED_DOUBLE(flag-&gt;get_double());
 524   } else {
 525     JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
 526   }
 527 C2V_END
 528 
 529 #undef BOXED_LONG
 530 #undef BOXED_DOUBLE
 531 #undef CSTRING_TO_JSTRING
 532 
 533 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 534   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 535   ResourceMark rm;
 536 
 537   int code_size = method-&gt;code_size();
 538   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 539 
 540   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 541   // iterate over all bytecodes and replace non-Java bytecodes
 542 
 543   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 544     Bytecodes::Code code = s.code();
 545     Bytecodes::Code raw_code = s.raw_code();
 546     int bci = s.bci();
 547     int len = s.instruction_size();
 548 
 549     // Restore original byte code.
 550     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 551     if (len &gt; 1) {
 552       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);
 553     }
 554 
 555     if (len &gt; 1) {
 556       // Restore the big-endian constant pool indexes.
 557       // Cf. Rewriter::scan_method
 558       switch (code) {
 559         case Bytecodes::_getstatic:
 560         case Bytecodes::_putstatic:
 561         case Bytecodes::_getfield:
 562         case Bytecodes::_putfield:
 563         case Bytecodes::_invokevirtual:
 564         case Bytecodes::_invokespecial:
 565         case Bytecodes::_invokestatic:
 566         case Bytecodes::_invokeinterface:
 567         case Bytecodes::_invokehandle: {
 568           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 569           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 570           break;
 571         }
 572 
 573         case Bytecodes::_invokedynamic:
 574           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 575           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);
 576           break;
 577       }
 578 
 579       // Not all ldc byte code are rewritten.
 580       switch (raw_code) {
 581         case Bytecodes::_fast_aldc: {
 582           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;
 583           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 584           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 585           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);
 586           break;
 587         }
 588 
 589         case Bytecodes::_fast_aldc_w: {
 590           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 591           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 592           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 593           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 594           break;
 595         }
 596       }
 597     }
 598   }
 599 
 600   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);
 601 C2V_END
 602 
 603 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 604   ResourceMark rm;
 605   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 606   return method-&gt;exception_table_length();
 607 C2V_END
 608 
 609 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 610   ResourceMark rm;
 611   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 612   if (method-&gt;exception_table_length() == 0) {
 613     return 0L;
 614   }
 615   return (jlong) (address) method-&gt;exception_table_start();
 616 C2V_END
 617 
 618 C2V_VMENTRY(jobject, asResolvedJavaMethod, (JNIEnv *, jobject, jobject executable_handle))
 619   oop executable = JNIHandles::resolve(executable_handle);
 620   oop mirror = NULL;
 621   int slot = 0;
 622 
 623   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 624     mirror = java_lang_reflect_Constructor::clazz(executable);
 625     slot = java_lang_reflect_Constructor::slot(executable);
 626   } else {
 627     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), "wrong type");
 628     mirror = java_lang_reflect_Method::clazz(executable);
 629     slot = java_lang_reflect_Method::slot(executable);
 630   }
 631   Klass* holder = java_lang_Class::as_Klass(mirror);
 632   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 633   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 634   return JNIHandles::make_local(THREAD, result);
 635 }
 636 
 637 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))
 638   methodHandle method;
 639   oop base_object = JNIHandles::resolve(base);
 640   if (base_object == NULL) {
 641     method = *((Method**)(offset));
 642   } else if (base_object-&gt;is_a(SystemDictionary::MemberName_klass())) {
 643     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);
 644   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 645     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));
 646   } else {
 647     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 648                 err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 649   }
 650   assert (method.is_null() || method-&gt;is_method(), "invalid read");
 651   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 652   return JNIHandles::make_local(THREAD, result);
 653 }
 654 
 655 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject object_handle))
 656   constantPoolHandle cp;
 657   oop object = JNIHandles::resolve(object_handle);
 658   if (object == NULL) {
 659     THROW_0(vmSymbols::java_lang_NullPointerException());
 660   }
 661   if (object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 662     cp = CompilerToVM::asMethod(object)-&gt;constMethod()-&gt;constants();
 663   } else if (object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 664     cp = InstanceKlass::cast(CompilerToVM::asKlass(object))-&gt;constants();
 665   } else {
 666     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 667                 err_msg("Unexpected type: %s", object-&gt;klass()-&gt;external_name()));
 668   }
 669   assert(!cp.is_null(), "npe");
 670   JavaValue method_result(T_OBJECT);
 671   JavaCallArguments args;
 672   args.push_long((jlong) (address) cp());
 673   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 674   return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());
 675 }
 676 
 677 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))
 678   KlassHandle klass;
 679   oop base_object = JNIHandles::resolve(base);
 680   jlong base_address = 0;
 681   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 682     klass = base_object-&gt;klass();
 683   } else if (!compressed) {
 684     if (base_object != NULL) {
 685       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 686         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 687       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 688         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 689       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 690         base_address = (jlong) CompilerToVM::asKlass(base_object);
 691       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {
 692         base_address = (jlong) (address) base_object;
 693       } else {
 694         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 695                     err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 696       }
 697     }
 698     klass = *((Klass**) (intptr_t) (base_address + offset));
 699   } else {
 700     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 701                 err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 702   }
 703   assert (klass.is_null() || klass-&gt;is_klass(), "invalid read");
 704   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 705   return JNIHandles::make_local(THREAD, result);
 706 }
 707 
 708 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 709   ResourceMark rm;
 710   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 711   KlassHandle holder = CompilerToVM::asKlass(jvmci_type);
 712   if (holder-&gt;is_interface()) {
 713     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", holder-&gt;external_name()));
 714   }
 715 
 716   methodHandle ucm;
 717   {
 718     MutexLocker locker(Compile_lock);
 719     ucm = Dependencies::find_unique_concrete_method(holder(), method());
 720   }
 721   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);
 722   return JNIHandles::make_local(THREAD, result);
 723 C2V_END
 724 
 725 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))
 726   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 727   oop implementor = CompilerToVM::get_jvmci_type(klass-&gt;implementor(), CHECK_NULL);
 728   return JNIHandles::make_local(THREAD, implementor);
 729 C2V_END
 730 
 731 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))
 732   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 733   return method-&gt;is_ignored_by_security_stack_walk();
 734 C2V_END
 735 
 736 C2V_VMENTRY(jboolean, isCompilable,(JNIEnv *, jobject, jobject jvmci_method))
 737   methodHandle method = CompilerToVM::asMethod(jvmci_method);
<a name="1" id="anc1"></a><span class="changed"> 738   return !method-&gt;is_not_compilable(CompLevel_full_optimization);</span>


 739 C2V_END
 740 
 741 C2V_VMENTRY(jboolean, hasNeverInlineDirective,(JNIEnv *, jobject, jobject jvmci_method))
 742   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 743   return CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 744 C2V_END
 745 
 746 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 747   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 748   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 749 C2V_END
 750 
 751 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 752   ResourceMark rm;
 753   Handle name = JNIHandles::resolve(jname);
 754   Symbol* class_name = java_lang_String::as_symbol(name, CHECK_0);
 755   if (java_lang_String::length(name()) &lt;= 1) {
 756     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Primitive type %s should be handled in Java code", class_name-&gt;as_C_string()));
 757   }
 758 
 759   Klass* resolved_klass = NULL;
 760   Handle class_loader;
 761   Handle protection_domain;
 762   if (JNIHandles::resolve(accessing_class) == NULL) {
 763     THROW_0(vmSymbols::java_lang_NullPointerException());
 764   }
 765   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));
 766   class_loader = accessing_klass-&gt;class_loader();
 767   protection_domain = accessing_klass-&gt;protection_domain();
 768 
 769   if (resolve) {
 770     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 771   } else {
 772     if (class_name-&gt;byte_at(0) == 'L' &amp;&amp;
 773       class_name-&gt;byte_at(class_name-&gt;utf8_length()-1) == ';') {
 774       // This is a name from a signature.  Strip off the trimmings.
 775       // Call recursive to keep scope of strippedsym.
 776       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 777                                                           class_name-&gt;utf8_length()-2,
 778                                                           CHECK_0);
 779       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 780     } else if (FieldType::is_array(class_name)) {
 781       FieldArrayInfo fd;
 782       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 783       // of this call
 784       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 785       if (t == T_OBJECT) {
 786         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 787                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 788                                                             CHECK_0);
 789         // naked oop "k" is OK here -- we assign back into it
 790         resolved_klass = SystemDictionary::find(strippedsym,
 791                                                              class_loader,
 792                                                              protection_domain,
 793                                                              CHECK_0);
 794         if (resolved_klass != NULL) {
 795           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 796         }
 797       } else {
 798         resolved_klass = Universe::typeArrayKlassObj(t);
 799         resolved_klass = TypeArrayKlass::cast(resolved_klass)-&gt;array_klass(fd.dimension(), CHECK_0);
 800       }
 801     }
 802   }
 803   Handle result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 804   return JNIHandles::make_local(THREAD, result());
 805 C2V_END
 806 
 807 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 808   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 809   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);
 810   return JNIHandles::make_local(THREAD, result);
 811 C2V_END
 812 
 813 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 814   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 815   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 816   return JNIHandles::make_local(THREAD, result);
 817 C2V_END
 818 
 819 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 820   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 821   return cp-&gt;name_and_type_ref_index_at(index);
 822 C2V_END
 823 
 824 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 825   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 826   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);
 827   return JNIHandles::make_local(THREAD, sym());
 828 C2V_END
 829 
 830 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 831   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 832   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);
 833   return JNIHandles::make_local(THREAD, sym());
 834 C2V_END
 835 
 836 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 837   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 838   return cp-&gt;klass_ref_index_at(index);
 839 C2V_END
 840 
 841 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 842   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 843   Klass* resolved_klass = cp-&gt;klass_at(index, CHECK_NULL);
 844   Handle klass = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 845   return JNIHandles::make_local(THREAD, klass());
 846 C2V_END
 847 
 848 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 849   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 850   KlassHandle loading_klass(cp-&gt;pool_holder());
 851   bool is_accessible = false;
 852   KlassHandle klass = JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass);
 853   Symbol* symbol = NULL;
 854   if (klass.is_null()) {
 855     symbol = cp-&gt;klass_name_at(index);
 856   }
 857   Handle result;
 858   if (!klass.is_null()) {
 859     result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 860   } else {
 861     result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
 862   }
 863   return JNIHandles::make_local(THREAD, result());
 864 C2V_END
 865 
 866 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 867   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 868   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 869   return JNIHandles::make_local(THREAD, appendix_oop);
 870 C2V_END
 871 
 872 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 873   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 874   instanceKlassHandle pool_holder(cp-&gt;pool_holder());
 875   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 876   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 877   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 878   return JNIHandles::make_local(THREAD, result);
 879 C2V_END
 880 
 881 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 882   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 883   return cp-&gt;remap_instruction_operand_from_cache(index);
 884 C2V_END
 885 
 886 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))
 887   ResourceMark rm;
 888   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 889   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 890   fieldDescriptor fd;
 891   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
 892   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 893   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
 894   if (info == NULL || info-&gt;length() != 3) {
 895     JVMCI_ERROR_NULL("info must not be null and have a length of 3");
 896   }
 897   info-&gt;int_at_put(0, fd.access_flags().as_int());
 898   info-&gt;int_at_put(1, fd.offset());
 899   info-&gt;int_at_put(2, fd.index());
 900   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 901   return JNIHandles::make_local(THREAD, field_holder);
 902 C2V_END
 903 
 904 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 905   ResourceMark rm;
 906   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 907   Method* method = CompilerToVM::asMethod(jvmci_method);
 908   if (klass-&gt;is_interface()) {
 909     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 910   }
 911   if (!method-&gt;method_holder()-&gt;is_interface()) {
 912     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 913   }
 914   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 915     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 916   }
 917   return LinkResolver::vtable_index_of_interface_method(klass, method);
 918 C2V_END
 919 
 920 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 921   KlassHandle recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);
 922   KlassHandle caller_klass = CompilerToVM::asKlass(caller_jvmci_type);
 923   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 924 
 925   KlassHandle h_resolved   (THREAD, method-&gt;method_holder());
 926   Symbol* h_name      = method-&gt;name();
 927   Symbol* h_signature = method-&gt;signature();
 928 
 929   if (MethodHandles::is_signature_polymorphic_method(method())) {
 930       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 931       return NULL;
 932   }
 933 
 934   LinkInfo link_info(h_resolved, h_name, h_signature, caller_klass);
 935   methodHandle m;
 936   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 937   // the vtable has not been setup, and the LinkResolver will fail.
 938   if (recv_klass-&gt;is_array_klass() ||
 939       InstanceKlass::cast(recv_klass())-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface()) {
 940     if (h_resolved-&gt;is_interface()) {
 941       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 942     } else {
 943       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 944     }
 945   }
 946 
 947   if (m.is_null()) {
 948     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 949     return NULL;
 950   }
 951 
 952   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);
 953   return JNIHandles::make_local(THREAD, result);
 954 C2V_END
 955 
 956 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))
 957   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 958   assert(klass != NULL, "method must not be called for primitive types");
 959   return Dependencies::find_finalizable_subclass(klass) != NULL;
 960 C2V_END
 961 
 962 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))
 963   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 964   oop result = CompilerToVM::get_jvmci_method(klass-&gt;class_initializer(), CHECK_NULL);
 965   return JNIHandles::make_local(THREAD, result);
 966 C2V_END
 967 
 968 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))
 969   address target_addr = (address) addr;
 970   if (target_addr != 0x0) {
 971     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 972     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 973     return MAX2(ABS(off_low), ABS(off_high));
 974   }
 975   return -1;
 976 C2V_END
 977 
 978 C2V_VMENTRY(void, doNotInlineOrCompile,(JNIEnv *, jobject,  jobject jvmci_method))
 979   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 980   method-&gt;set_not_c1_compilable();
 981   method-&gt;set_not_c2_compilable();
 982   method-&gt;set_dont_inline(true);
 983 C2V_END
 984 
 985 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))
 986   ResourceMark rm;
 987   HandleMark hm;
 988   Handle target_handle = JNIHandles::resolve(target);
 989   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 990   CodeBlob* cb = NULL;
 991   Handle installed_code_handle = JNIHandles::resolve(installed_code);
 992   Handle speculation_log_handle = JNIHandles::resolve(speculation_log);
 993 
 994   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK_JNI_ERR);
 995 
 996   TraceTime install_time("installCode", JVMCICompiler::codeInstallTimer());
 997   bool is_immutable_PIC = HotSpotCompiledCode::isImmutablePIC(compiled_code_handle) &gt; 0;
 998   CodeInstaller installer(is_immutable_PIC);
 999   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);
1000 
1001   if (PrintCodeCacheOnCompilation) {
1002     stringStream s;
1003     // Dump code cache  into a buffer before locking the tty,
1004     {
1005       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1006       CodeCache::print_summary(&amp;s, false);
1007     }
1008     ttyLocker ttyl;
1009     tty-&gt;print_raw_cr(s.as_string());
1010   }
1011 
1012   if (result != JVMCIEnv::ok) {
1013     assert(cb == NULL, "should be");
1014   } else {
1015     if (!installed_code_handle.is_null()) {
1016       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), "wrong type");
1017       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);
1018       {
1019         // Ensure that all updates to the InstalledCode fields are consistent.
1020         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
1021         InstalledCode::set_address(installed_code_handle, (jlong) cb);
1022         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);
1023         if (cb-&gt;is_nmethod()) {
1024           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());
1025         } else {
1026           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());
1027         }
1028         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {
1029           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());
1030           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());
1031           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());
1032         }
1033       }
1034       nmethod* nm = cb-&gt;as_nmethod_or_null();
1035       if (nm != NULL &amp;&amp; installed_code_handle-&gt;is_scavengable()) {
1036         assert(nm-&gt;detect_scavenge_root_oops(), "nm should be scavengable if installed_code is scavengable");
1037         if (!UseG1GC) {
1038           assert(nm-&gt;on_scavenge_root_list(), "nm should be on scavengable list");
1039         }
1040       }
1041     }
1042   }
1043   return result;
1044 C2V_END
1045 
1046 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))
1047   ResourceMark rm;
1048   HandleMark hm;
1049 
1050   Handle target_handle = JNIHandles::resolve(target);
1051   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
1052   Handle metadata_handle = JNIHandles::resolve(metadata);
1053 
1054   CodeMetadata code_metadata;
1055   CodeBlob *cb = NULL;
1056   CodeInstaller installer(true /* immutable PIC compilation */);
1057 
1058   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);
1059   if (result != JVMCIEnv::ok) {
1060     return result;
1061   }
1062 
1063   if (code_metadata.get_nr_pc_desc() &gt; 0) {
1064     typeArrayHandle pcArrayOop = oopFactory::new_byteArray(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));
1065     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());
1066     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());
1067   }
1068 
1069   if (code_metadata.get_scopes_size() &gt; 0) {
1070     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));
1071     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());
1072     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());
1073   }
1074 
1075   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
1076   typeArrayHandle relocArrayOop = oopFactory::new_byteArray((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));
1077   if (reloc_buffer-&gt;size() &gt; 0) {
1078     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());
1079   }
1080   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());
1081 
1082   const OopMapSet* oopMapSet = installer.oopMapSet();
1083   {
1084     ResourceMark mark;
1085     ImmutableOopMapBuilder builder(oopMapSet);
1086     int oopmap_size = builder.heap_size();
1087     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray(oopmap_size, CHECK_(JVMCIEnv::cache_full));
1088     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));
1089     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());
1090   }
1091 
1092   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
1093 
1094   int nr_meta_strings = recorder-&gt;nr_meta_strings();
1095   objArrayHandle metadataArrayHandle = oopFactory::new_objectArray(nr_meta_strings, CHECK_(JVMCIEnv::cache_full));
1096   for (int i = 0; i &lt; nr_meta_strings; ++i) {
1097     const char* element = recorder-&gt;meta_element(i);
1098     Handle java_string = java_lang_String::create_from_str(element, CHECK_(JVMCIEnv::cache_full));
1099     metadataArrayHandle-&gt;obj_at_put(i, java_string());
1100   }
1101   HotSpotMetaData::set_metadata(metadata_handle, metadataArrayHandle());
1102 
1103   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
1104   int table_size = handler-&gt;size_in_bytes();
1105   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray(table_size, CHECK_(JVMCIEnv::cache_full));
1106 
1107   if (table_size &gt; 0) {
1108     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));
1109   }
1110   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());
1111 
1112   return result;
1113 C2V_END
1114 
1115 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))
1116   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK);
1117   CompilerStatistics* stats = compiler-&gt;stats();
1118   stats-&gt;_standard.reset();
1119   stats-&gt;_osr.reset();
1120 C2V_END
1121 
1122 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))
1123   ResourceMark rm;
1124   HandleMark hm;
1125 
1126   if (installedCode == NULL) {
1127     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), "installedCode is null");
1128   }
1129 
1130   jlong codeBlob = InstalledCode::address(installedCode);
1131   if (codeBlob == 0L) {
1132     return NULL;
1133   }
1134 
1135   CodeBlob* cb = (CodeBlob*) (address) codeBlob;
1136   if (cb == NULL) {
1137     return NULL;
1138   }
1139 
1140   // We don't want the stringStream buffer to resize during disassembly as it
1141   // uses scoped resource memory. If a nested function called during disassembly uses
1142   // a ResourceMark and the buffer expands within the scope of the mark,
1143   // the buffer becomes garbage when that scope is exited. Experience shows that
1144   // the disassembled code is typically about 10x the code size so a fixed buffer
1145   // sized to 20x code size plus a fixed amount for header info should be sufficient.
1146   int bufferSize = cb-&gt;code_size() * 20 + 1024;
1147   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
1148   stringStream st(buffer, bufferSize);
1149   if (cb-&gt;is_nmethod()) {
1150     nmethod* nm = (nmethod*) cb;
1151     if (!nm-&gt;is_alive()) {
1152       return NULL;
1153     }
1154   }
1155   Disassembler::decode(cb, &amp;st);
1156   if (st.size() &lt;= 0) {
1157     return NULL;
1158   }
1159 
1160   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);
1161   return JNIHandles::make_local(THREAD, result());
1162 C2V_END
1163 
1164 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))
1165   ResourceMark rm;
1166   HandleMark hm;
1167 
1168   methodHandle method = CompilerToVM::asMethod(jvmci_method);
1169   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);
1170   return JNIHandles::make_local(THREAD, element);
1171 C2V_END
1172 
1173 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))
1174   ResourceMark rm;
1175   HandleMark hm;
1176 
1177   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);
1178   if (nmethodValue == 0L) {
1179     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
1180   }
1181   nmethod* nm = (nmethod*) (address) nmethodValue;
1182   methodHandle mh = nm-&gt;method();
1183   Symbol* signature = mh-&gt;signature();
1184   JavaCallArguments jca(mh-&gt;size_of_parameters());
1185 
1186   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1187   JavaValue result(jap.get_ret_type());
1188   jca.set_alternative_target(nm);
1189   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1190 
1191   if (jap.get_ret_type() == T_VOID) {
1192     return NULL;
1193   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
1194     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
1195   } else {
1196     jvalue *value = (jvalue *) result.get_value_addr();
1197     // Narrow the value down if required (Important on big endian machines)
1198     switch (jap.get_ret_type()) {
1199       case T_BOOLEAN:
1200        value-&gt;z = (jboolean) value-&gt;i;
1201        break;
1202       case T_BYTE:
1203        value-&gt;b = (jbyte) value-&gt;i;
1204        break;
1205       case T_CHAR:
1206        value-&gt;c = (jchar) value-&gt;i;
1207        break;
1208       case T_SHORT:
1209        value-&gt;s = (jshort) value-&gt;i;
1210        break;
1211      }
1212     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);
1213     return JNIHandles::make_local(THREAD, o);
1214   }
1215 C2V_END
1216 
1217 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))
1218   Method* method = CompilerToVM::asMethod(jvmci_method);
1219   if (!method-&gt;has_linenumber_table()) {
1220     return NULL;
1221   }
1222   u2 num_entries = 0;
1223   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1224   while (streamForSize.read_pair()) {
1225     num_entries++;
1226   }
1227 
1228   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1229   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);
1230 
1231   int i = 0;
1232   jlong value;
1233   while (stream.read_pair()) {
1234     value = ((long) stream.bci());
1235     result-&gt;long_at_put(i, value);
1236     value = ((long) stream.line());
1237     result-&gt;long_at_put(i + 1, value);
1238     i += 2;
1239   }
1240 
1241   return (jlongArray) JNIHandles::make_local(THREAD, result);
1242 C2V_END
1243 
1244 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))
1245   ResourceMark rm;
1246   Method* method = CompilerToVM::asMethod(jvmci_method);
1247   if (!method-&gt;has_localvariable_table()) {
1248     return 0;
1249   }
1250   return (jlong) (address) method-&gt;localvariable_table_start();
1251 C2V_END
1252 
1253 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))
1254   ResourceMark rm;
1255   Method* method = CompilerToVM::asMethod(jvmci_method);
1256   return method-&gt;localvariable_table_length();
1257 C2V_END
1258 
1259 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))
1260   Method* method = CompilerToVM::asMethod(jvmci_method);
1261   MethodCounters* mcs = method-&gt;method_counters();
1262   if (mcs != NULL) {
1263     mcs-&gt;clear_counters();
1264   }
1265   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1266 
1267   CompiledMethod* code = method-&gt;code();
1268   if (code != NULL) {
1269     code-&gt;make_not_entrant();
1270   }
1271 
1272   MethodData* method_data = method-&gt;method_data();
1273   if (method_data == NULL) {
1274     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1275     method_data = MethodData::allocate(loader_data, method, CHECK);
1276     method-&gt;set_method_data(method_data);
1277   } else {
1278     method_data-&gt;initialize();
1279   }
1280 C2V_END
1281 
1282 
1283 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))
1284   Handle installed_code_handle = JNIHandles::resolve(installed_code);
1285   nmethod::invalidate_installed_code(installed_code_handle, CHECK);
1286 C2V_END
1287 
1288 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))
1289   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);
1290   JavaThread::collect_counters(arrayOop);
1291   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);
1292 C2V_END
1293 
1294 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))
1295   HandleMark hm;
1296   ResourceMark rm;
1297   if (JNIHandles::resolve(jvmci_method) == NULL) {
1298     THROW_0(vmSymbols::java_lang_NullPointerException());
1299   }
1300   Method* method = CompilerToVM::asMethod(jvmci_method);
1301   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1302     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Unexpected bci %d", entry_bci));
1303   }
1304   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1305 C2V_END
1306 
1307 
1308 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))
1309   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1310   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1311 C2V_END
1312 
1313 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1314   Method* method = CompilerToVM::asMethod(jvmci_method);
1315   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1316 C2V_END
1317 
1318 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))
1319   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);
1320   return JNIHandles::make_local(THREAD, sym());
1321 C2V_END
1322 
1323 bool matches(jobjectArray methods, Method* method) {
1324   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1325 
1326   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1327     oop resolved = methods_oop-&gt;obj_at(i);
1328     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {
1329       return true;
1330     }
1331   }
1332   return false;
1333 }
1334 
1335 C2V_VMENTRY(jobject, getNextStackFrame, (JNIEnv*, jobject compilerToVM, jobject hs_frame, jobjectArray methods, jint initialSkip))
1336   ResourceMark rm;
1337 
1338   if (!thread-&gt;has_last_Java_frame()) return NULL;
1339   Handle result = HotSpotStackFrameReference::klass()-&gt;allocate_instance(thread);
1340   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1341 
1342   StackFrameStream fst(thread);
1343   if (hs_frame != NULL) {
1344     // look for the correct stack frame if one is given
1345     intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1346     while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1347       fst.next();
1348     }
1349     if (fst.current()-&gt;sp() != stack_pointer) {
1350       THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1351     }
1352   }
1353 
1354   int frame_number = 0;
1355   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1356   if (hs_frame != NULL) {
1357     // look for the correct vframe within the stack frame if one is given
1358     int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1359     while (frame_number &lt; last_frame_number) {
1360       if (vf-&gt;is_top()) {
1361         THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1362       }
1363       vf = vf-&gt;sender();
1364       frame_number ++;
1365     }
1366     // move one frame forward
1367     if (vf-&gt;is_top()) {
1368       if (fst.is_done()) {
1369         return NULL;
1370       }
1371       fst.next();
1372       vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1373       frame_number = 0;
1374     } else {
1375       vf = vf-&gt;sender();
1376       frame_number++;
1377     }
1378   }
1379 
1380   while (true) {
1381     // look for the given method
1382     while (true) {
1383       StackValueCollection* locals = NULL;
1384       if (vf-&gt;is_compiled_frame()) {
1385         // compiled method frame
1386         compiledVFrame* cvf = compiledVFrame::cast(vf);
1387         if (methods == NULL || matches(methods, cvf-&gt;method())) {
1388           if (initialSkip &gt; 0) {
1389             initialSkip --;
1390           } else {
1391             ScopeDesc* scope = cvf-&gt;scope();
1392             // native wrapper do not have a scope
1393             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1394               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), scope-&gt;objects(), THREAD);
1395               Deoptimization::reassign_fields(fst.current(), fst.register_map(), scope-&gt;objects(), realloc_failures, false);
1396 
1397               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1398               typeArrayHandle array = oopFactory::new_boolArray(local_values-&gt;length(), thread);
1399               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1400                 ScopeValue* value = local_values-&gt;at(i);
1401                 if (value-&gt;is_object()) {
1402                   array-&gt;bool_at_put(i, true);
1403                 }
1404               }
1405               HotSpotStackFrameReference::set_localIsVirtual(result, array());
1406             } else {
1407               HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1408             }
1409 
1410             locals = cvf-&gt;locals();
1411             HotSpotStackFrameReference::set_bci(result, cvf-&gt;bci());
1412             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);
1413             HotSpotStackFrameReference::set_method(result, method);
1414           }
1415         }
1416       } else if (vf-&gt;is_interpreted_frame()) {
1417         // interpreted method frame
1418         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1419         if (methods == NULL || matches(methods, ivf-&gt;method())) {
1420           if (initialSkip &gt; 0) {
1421             initialSkip --;
1422           } else {
1423             locals = ivf-&gt;locals();
1424             HotSpotStackFrameReference::set_bci(result, ivf-&gt;bci());
1425             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);
1426             HotSpotStackFrameReference::set_method(result, method);
1427             HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1428           }
1429         }
1430       }
1431 
1432       // locals != NULL means that we found a matching frame and result is already partially initialized
1433       if (locals != NULL) {
1434         HotSpotStackFrameReference::set_compilerToVM(result, JNIHandles::resolve(compilerToVM));
1435         HotSpotStackFrameReference::set_stackPointer(result, (jlong) fst.current()-&gt;sp());
1436         HotSpotStackFrameReference::set_frameNumber(result, frame_number);
1437 
1438         // initialize the locals array
1439         objArrayHandle array = oopFactory::new_objectArray(locals-&gt;size(), thread);
1440         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1441           StackValue* var = locals-&gt;at(i);
1442           if (var-&gt;type() == T_OBJECT) {
1443             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1444           }
1445         }
1446         HotSpotStackFrameReference::set_locals(result, array());
1447 
1448         return JNIHandles::make_local(thread, result());
1449       }
1450 
1451       if (vf-&gt;is_top()) {
1452         break;
1453       }
1454       frame_number++;
1455       vf = vf-&gt;sender();
1456     } // end of vframe loop
1457 
1458     if (fst.is_done()) {
1459       break;
1460     }
1461     fst.next();
1462     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1463     frame_number = 0;
1464   } // end of frame loop
1465 
1466   // the end was reached without finding a matching method
1467   return NULL;
1468 C2V_END
1469 
1470 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1471   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1472   CallInfo callInfo;
1473   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1474   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1475   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1476 C2V_END
1477 
1478 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1479   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1480   KlassHandle holder = cp-&gt;klass_ref_at(index, CHECK);
1481   Symbol* name = cp-&gt;name_ref_at(index);
1482   if (MethodHandles::is_signature_polymorphic_name(holder(), name)) {
1483     CallInfo callInfo;
1484     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1485     ConstantPoolCacheEntry* cp_cache_entry = cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1486     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1487   }
1488 C2V_END
1489 
1490 C2V_VMENTRY(jobject, getSignaturePolymorphicHolders, (JNIEnv*, jobject))
1491   objArrayHandle holders = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
1492   Handle mh = java_lang_String::create_from_str("Ljava/lang/invoke/MethodHandle;", CHECK_NULL);
1493   Handle vh = java_lang_String::create_from_str("Ljava/lang/invoke/VarHandle;", CHECK_NULL);
1494   holders-&gt;obj_at_put(0, mh());
1495   holders-&gt;obj_at_put(1, vh());
1496   return JNIHandles::make_local(THREAD, holders());
1497 C2V_END
1498 
1499 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))
1500   //see compute_recording_non_safepoints in debugInfroRec.cpp
1501   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1502     return true;
1503   }
1504   return DebugNonSafepoints;
1505 C2V_END
1506 
1507 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1508 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))
1509   ResourceMark rm;
1510 
1511   if (hs_frame == NULL) {
1512     THROW_MSG(vmSymbols::java_lang_NullPointerException(), "stack frame is null")
1513   }
1514 
1515   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1516 
1517   // look for the given stack frame
1518   StackFrameStream fst(thread);
1519   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1520   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1521     fst.next();
1522   }
1523   if (fst.current()-&gt;sp() != stack_pointer) {
1524     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1525   }
1526 
1527   if (invalidate) {
1528     if (!fst.current()-&gt;is_compiled_frame()) {
1529       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1530     }
1531     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), "nmethod expected");
1532     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1533   }
1534   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1535   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1536   StackFrameStream fstAfterDeopt(thread);
1537   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1538     fstAfterDeopt.next();
1539   }
1540   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1541     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found after deopt")
1542   }
1543 
1544   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1545   if (!vf-&gt;is_compiled_frame()) {
1546     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1547   }
1548 
1549   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1550   while (true) {
1551     assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1552     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1553     if (vf-&gt;is_top()) {
1554       break;
1555     }
1556     vf = vf-&gt;sender();
1557   }
1558 
1559   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1560   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1561     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1562   }
1563 
1564   // Reallocate the non-escaping objects and restore their fields.
1565   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,"invalid scope");
1566   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1567 
1568   if (objects == NULL) {
1569     // no objects to materialize
1570     return;
1571   }
1572 
1573   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, THREAD);
1574   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1575 
1576   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1577     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1578 
1579     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1580     StackValueCollection* locals = cvf-&gt;locals();
1581 
1582     if (locals != NULL) {
1583       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1584         StackValue* var = locals-&gt;at(i2);
1585         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1586           jvalue val;
1587           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1588           cvf-&gt;update_local(T_OBJECT, i2, val);
1589         }
1590       }
1591     }
1592   }
1593 
1594   // all locals are materialized by now
1595   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);
1596 
1597   // update the locals array
1598   objArrayHandle array = HotSpotStackFrameReference::locals(hs_frame);
1599   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1600   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1601     StackValue* var = locals-&gt;at(i);
1602     if (var-&gt;type() == T_OBJECT) {
1603       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1604     }
1605   }
1606 C2V_END
1607 
1608 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))
1609   if (bytes == NULL) {
1610     THROW(vmSymbols::java_lang_NullPointerException());
1611   }
1612   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);
1613 
1614   // Check if offset and length are non negative.
1615   if (offset &lt; 0 || length &lt; 0) {
1616     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1617   }
1618   // Check if the range is valid.
1619   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {
1620     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1621   }
1622   while (length &gt; 0) {
1623     jbyte* start = array-&gt;byte_at_addr(offset);
1624     tty-&gt;write((char*) start, MIN2(length, O_BUFLEN));
1625     length -= O_BUFLEN;
1626     offset += O_BUFLEN;
1627   }
1628 C2V_END
1629 
1630 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))
1631   tty-&gt;flush();
1632 C2V_END
1633 
1634 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))
1635   ResourceMark rm;
1636   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1637   ProfileData* profile_data = mdo-&gt;data_at(position);
1638   if (mdo-&gt;is_valid(profile_data)) {
1639     return profile_data-&gt;size_in_bytes();
1640   }
1641   DataLayout* data    = mdo-&gt;extra_data_base();
1642   DataLayout* end   = mdo-&gt;extra_data_limit();
1643   for (;; data = mdo-&gt;next_extra(data)) {
1644     assert(data &lt; end, "moved past end of extra data");
1645     profile_data = data-&gt;data_in();
1646     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1647       return profile_data-&gt;size_in_bytes();
1648     }
1649   }
1650   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Invalid profile data position %d", position));
1651 C2V_END
1652 
1653 C2V_VMENTRY(jlong, getFingerprint, (JNIEnv*, jobject, jlong metaspace_klass))
1654   Klass *k = CompilerToVM::asKlass(metaspace_klass);
1655   if (k-&gt;is_instance_klass()) {
1656     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1657   } else {
1658     return 0;
1659   }
1660 C2V_END
1661 
1662 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))
1663   if (bytecode_frame_handle == NULL) {
1664     THROW_0(vmSymbols::java_lang_NullPointerException());
1665   }
1666 
1667   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);
1668   oop bytecode_frame = top_bytecode_frame;
1669   int size = 0;
1670   int callee_parameters = 0;
1671   int callee_locals = 0;
1672   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1673   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);
1674 
1675   while (bytecode_frame != NULL) {
1676     int locks = BytecodeFrame::numLocks(bytecode_frame);
1677     int temps = BytecodeFrame::numStack(bytecode_frame);
1678     bool is_top_frame = (bytecode_frame == top_bytecode_frame);
1679     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1680 
1681     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1682                                                                  temps + callee_parameters,
1683                                                                  extra_args,
1684                                                                  locks,
1685                                                                  callee_parameters,
1686                                                                  callee_locals,
1687                                                                  is_top_frame);
1688     size += frame_size;
1689 
1690     callee_parameters = method-&gt;size_of_parameters();
1691     callee_locals = method-&gt;max_locals();
1692     extra_args = 0;
1693     bytecode_frame = BytecodePosition::caller(bytecode_frame);
1694   }
1695   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1696 C2V_END
1697 
1698 C2V_VMENTRY(void, compileToBytecode, (JNIEnv*, jobject, jobject lambda_form_handle))
1699   Handle lambda_form = JNIHandles::resolve_non_null(lambda_form_handle);
1700   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1701     TempNewSymbol compileToBytecode = SymbolTable::new_symbol("compileToBytecode", CHECK);
1702     JavaValue result(T_VOID);
1703     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1704   } else {
1705     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1706                 err_msg("Unexpected type: %s", lambda_form-&gt;klass()-&gt;external_name()));
1707   }
1708 C2V_END
1709 
1710 #define CC (char*)  /*cast a literal from (const char*)*/
1711 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1712 
1713 #define STRING                "Ljava/lang/String;"
1714 #define OBJECT                "Ljava/lang/Object;"
1715 #define CLASS                 "Ljava/lang/Class;"
1716 #define EXECUTABLE            "Ljava/lang/reflect/Executable;"
1717 #define STACK_TRACE_ELEMENT   "Ljava/lang/StackTraceElement;"
1718 #define INSTALLED_CODE        "Ljdk/vm/ci/code/InstalledCode;"
1719 #define TARGET_DESCRIPTION    "Ljdk/vm/ci/code/TargetDescription;"
1720 #define BYTECODE_FRAME        "Ljdk/vm/ci/code/BytecodeFrame;"
1721 #define RESOLVED_METHOD       "Ljdk/vm/ci/meta/ResolvedJavaMethod;"
1722 #define HS_RESOLVED_METHOD    "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;"
1723 #define HS_RESOLVED_KLASS     "Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;"
1724 #define HS_CONSTANT_POOL      "Ljdk/vm/ci/hotspot/HotSpotConstantPool;"
1725 #define HS_COMPILED_CODE      "Ljdk/vm/ci/hotspot/HotSpotCompiledCode;"
1726 #define HS_CONFIG             "Ljdk/vm/ci/hotspot/HotSpotVMConfig;"
1727 #define HS_METADATA           "Ljdk/vm/ci/hotspot/HotSpotMetaData;"
1728 #define HS_STACK_FRAME_REF    "Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;"
1729 #define HS_SPECULATION_LOG    "Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;"
1730 #define METASPACE_METHOD_DATA "J"
1731 
1732 JNINativeMethod CompilerToVM::methods[] = {
1733   {CC "getBytecode",                                  CC "(" HS_RESOLVED_METHOD ")[B",                                                      FN_PTR(getBytecode)},
1734   {CC "getExceptionTableStart",                       CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getExceptionTableStart)},
1735   {CC "getExceptionTableLength",                      CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getExceptionTableLength)},
1736   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1737   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1738   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1739   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1740   {CC "doNotInlineOrCompile",                         CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(doNotInlineOrCompile)},
1741   {CC "isCompilable",                                 CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(isCompilable)},
1742   {CC "hasNeverInlineDirective",                      CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(hasNeverInlineDirective)},
1743   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1744   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1745   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1746   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1747   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1748   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1749   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1750   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1751   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1752   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1753   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1754   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1755   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
1756   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[I)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
1757   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1758   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1759   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1760   {CC "getSignaturePolymorphicHolders",               CC "()[" STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
1761   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1762   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1763   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1764   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1765   {CC "asResolvedJavaMethod",                         CC "(" EXECUTABLE ")" HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
1766   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1767   {CC "getConstantPool",                              CC "(Ljava/lang/Object;)" HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},
1768   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1769   {CC "readConfiguration",                            CC "()[" OBJECT,                                                                      FN_PTR(readConfiguration)},
1770   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1771   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1772   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1773   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1774   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1775   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1776   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1777   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1778   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1779   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1780   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1781   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1782   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1783   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1784   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1785   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1786   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1787   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1788   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1789   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1790   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1791   {CC "getFingerprint",                               CC "(J)J",                                                                            FN_PTR(getFingerprint)},
1792   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1793   {CC "compileToBytecode",                            CC "(" OBJECT ")V",                                                                   FN_PTR(compileToBytecode)},
1794   {CC "getFlagValue",                                 CC "(" STRING ")" OBJECT,                                                             FN_PTR(getFlagValue)},
1795 };
1796 
1797 int CompilerToVM::methods_count() {
1798   return sizeof(methods) / sizeof(JNINativeMethod);
1799 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
