<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>open Sdiff src/hotspot/share/jvmci </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/hotspot/share/jvmci/jvmciCompilerToVM.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/jvmci/vmStructs_jvmci.cpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/jvmci/jvmciCompilerToVMInit.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  44 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
  45 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
  46 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
  47 
  48 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
  49 
  50 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
  51 int CompilerToVM::Data::Universe_base_vtable_size;
  52 address CompilerToVM::Data::Universe_narrow_oop_base;
  53 int CompilerToVM::Data::Universe_narrow_oop_shift;
  54 address CompilerToVM::Data::Universe_narrow_klass_base;
  55 int CompilerToVM::Data::Universe_narrow_klass_shift;
  56 void* CompilerToVM::Data::Universe_non_oop_bits;
  57 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
  58 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
  59 
  60 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
  61 HeapWord** CompilerToVM::Data::_heap_end_addr;
  62 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
  63 int CompilerToVM::Data::_max_oop_map_stack_offset;

  64 
  65 jbyte* CompilerToVM::Data::cardtable_start_address;
  66 int CompilerToVM::Data::cardtable_shift;
  67 
  68 int CompilerToVM::Data::vm_page_size;
  69 
  70 int CompilerToVM::Data::sizeof_vtableEntry = sizeof(vtableEntry);
  71 int CompilerToVM::Data::sizeof_ExceptionTableElement = sizeof(ExceptionTableElement);
  72 int CompilerToVM::Data::sizeof_LocalVariableTableElement = sizeof(LocalVariableTableElement);
  73 int CompilerToVM::Data::sizeof_ConstantPool = sizeof(ConstantPool);
<span class="removed">  74 int CompilerToVM::Data::sizeof_SymbolPointer = sizeof(Symbol*);</span>
  75 int CompilerToVM::Data::sizeof_narrowKlass = sizeof(narrowKlass);
  76 int CompilerToVM::Data::sizeof_arrayOopDesc = sizeof(arrayOopDesc);
  77 int CompilerToVM::Data::sizeof_BasicLock = sizeof(BasicLock);
  78 
  79 address CompilerToVM::Data::dsin;
  80 address CompilerToVM::Data::dcos;
  81 address CompilerToVM::Data::dtan;
  82 address CompilerToVM::Data::dexp;
  83 address CompilerToVM::Data::dlog;
  84 address CompilerToVM::Data::dlog10;
  85 address CompilerToVM::Data::dpow;
  86 
  87 address CompilerToVM::Data::symbol_init;
  88 address CompilerToVM::Data::symbol_clinit;
  89 
  90 void CompilerToVM::Data::initialize(TRAPS) {
  91   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
  92   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
  93 
  94   Method_extra_stack_entries = Method::extra_stack_entries();

</pre><hr></hr><pre>
 105   Universe_narrow_oop_base = Universe::narrow_oop_base();
 106   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 107   Universe_narrow_klass_base = Universe::narrow_klass_base();
 108   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 109   Universe_non_oop_bits = Universe::non_oop_word();
 110   Universe_verify_oop_mask = Universe::verify_oop_mask();
 111   Universe_verify_oop_bits = Universe::verify_oop_bits();
 112 
 113   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 114   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 115   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
 116 
 117   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 118   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 119   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 120   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 121 
 122   symbol_init = (address) vmSymbols::object_initializer_name();
 123   symbol_clinit = (address) vmSymbols::class_initializer_name();
 124 


 125   BarrierSet* bs = BarrierSet::barrier_set();
 126   if (bs-&gt;is_a(BarrierSet::CardTableBarrierSet)) {
 127     jbyte* base = ci_card_table_address();
 128     assert(base != NULL, "unexpected byte_map_base");
 129     cardtable_start_address = base;
 130     cardtable_shift = CardTable::card_shift;
 131   } else {
 132     // No card mark barriers
 133     cardtable_start_address = 0;
 134     cardtable_shift = 0;
 135   }
 136 
 137   vm_page_size = os::vm_page_size();
 138 
 139 #define SET_TRIGFUNC(name)                                      \
 140   if (StubRoutines::name() != NULL) {                           \
 141     name = StubRoutines::name();                                \
 142   } else {                                                      \
 143     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 144   }

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
  44 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
  45 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
  46 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
  47 
  48 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
  49 
  50 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
  51 int CompilerToVM::Data::Universe_base_vtable_size;
  52 address CompilerToVM::Data::Universe_narrow_oop_base;
  53 int CompilerToVM::Data::Universe_narrow_oop_shift;
  54 address CompilerToVM::Data::Universe_narrow_klass_base;
  55 int CompilerToVM::Data::Universe_narrow_klass_shift;
  56 void* CompilerToVM::Data::Universe_non_oop_bits;
  57 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
  58 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
  59 
  60 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
  61 HeapWord** CompilerToVM::Data::_heap_end_addr;
  62 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
  63 int CompilerToVM::Data::_max_oop_map_stack_offset;
<span class="new">  64 int CompilerToVM::Data::_fields_annotations_base_offset;</span>
  65 
  66 jbyte* CompilerToVM::Data::cardtable_start_address;
  67 int CompilerToVM::Data::cardtable_shift;
  68 
  69 int CompilerToVM::Data::vm_page_size;
  70 
  71 int CompilerToVM::Data::sizeof_vtableEntry = sizeof(vtableEntry);
  72 int CompilerToVM::Data::sizeof_ExceptionTableElement = sizeof(ExceptionTableElement);
  73 int CompilerToVM::Data::sizeof_LocalVariableTableElement = sizeof(LocalVariableTableElement);
  74 int CompilerToVM::Data::sizeof_ConstantPool = sizeof(ConstantPool);

  75 int CompilerToVM::Data::sizeof_narrowKlass = sizeof(narrowKlass);
  76 int CompilerToVM::Data::sizeof_arrayOopDesc = sizeof(arrayOopDesc);
  77 int CompilerToVM::Data::sizeof_BasicLock = sizeof(BasicLock);
  78 
  79 address CompilerToVM::Data::dsin;
  80 address CompilerToVM::Data::dcos;
  81 address CompilerToVM::Data::dtan;
  82 address CompilerToVM::Data::dexp;
  83 address CompilerToVM::Data::dlog;
  84 address CompilerToVM::Data::dlog10;
  85 address CompilerToVM::Data::dpow;
  86 
  87 address CompilerToVM::Data::symbol_init;
  88 address CompilerToVM::Data::symbol_clinit;
  89 
  90 void CompilerToVM::Data::initialize(TRAPS) {
  91   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
  92   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
  93 
  94   Method_extra_stack_entries = Method::extra_stack_entries();

</pre><hr></hr><pre>
 105   Universe_narrow_oop_base = Universe::narrow_oop_base();
 106   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 107   Universe_narrow_klass_base = Universe::narrow_klass_base();
 108   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 109   Universe_non_oop_bits = Universe::non_oop_word();
 110   Universe_verify_oop_mask = Universe::verify_oop_mask();
 111   Universe_verify_oop_bits = Universe::verify_oop_bits();
 112 
 113   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 114   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 115   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
 116 
 117   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 118   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 119   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 120   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 121 
 122   symbol_init = (address) vmSymbols::object_initializer_name();
 123   symbol_clinit = (address) vmSymbols::class_initializer_name();
 124 
<span class="new"> 125   _fields_annotations_base_offset = Array&lt;AnnotationArray*&gt;::base_offset_in_bytes();</span>
<span class="new"> 126 </span>
 127   BarrierSet* bs = BarrierSet::barrier_set();
 128   if (bs-&gt;is_a(BarrierSet::CardTableBarrierSet)) {
 129     jbyte* base = ci_card_table_address();
 130     assert(base != NULL, "unexpected byte_map_base");
 131     cardtable_start_address = base;
 132     cardtable_shift = CardTable::card_shift;
 133   } else {
 134     // No card mark barriers
 135     cardtable_start_address = 0;
 136     cardtable_shift = 0;
 137   }
 138 
 139   vm_page_size = os::vm_page_size();
 140 
 141 #define SET_TRIGFUNC(name)                                      \
 142   if (StubRoutines::name() != NULL) {                           \
 143     name = StubRoutines::name();                                \
 144   } else {                                                      \
 145     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 146   }

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/hotspot/share/jvmci/jvmciCompilerToVM.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/jvmci/vmStructs_jvmci.cpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
