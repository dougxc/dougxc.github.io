<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotConstantPool.isSignaturePolymorphicHolder;
  28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  29 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  30 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  31 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  32 
  33 import java.lang.annotation.Annotation;
  34 import java.lang.reflect.Array;
  35 import java.lang.reflect.Constructor;
<a name="1" id="anc1"></a><span class="new">  36 import java.lang.reflect.Field;</span>
  37 import java.lang.reflect.Method;
  38 import java.lang.reflect.Modifier;
  39 import java.nio.ByteOrder;
  40 import java.util.HashMap;
  41 
  42 import jdk.vm.ci.common.JVMCIError;
  43 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  45 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  46 import jdk.vm.ci.meta.Assumptions.LeafType;
  47 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  48 import jdk.vm.ci.meta.Constant;
  49 import jdk.vm.ci.meta.JavaConstant;
  50 import jdk.vm.ci.meta.JavaKind;
  51 import jdk.vm.ci.meta.JavaType;
  52 import jdk.vm.ci.meta.ResolvedJavaField;
  53 import jdk.vm.ci.meta.ResolvedJavaMethod;
  54 import jdk.vm.ci.meta.ResolvedJavaType;
  55 import jdk.vm.ci.meta.UnresolvedJavaField;
  56 import jdk.vm.ci.meta.UnresolvedJavaType;
  57 
  58 /**
  59  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.
  60  */
  61 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceWrapperObject {
  62 
  63     private static final HotSpotResolvedJavaField[] NO_FIELDS = new HotSpotResolvedJavaField[0];
  64     private static final int METHOD_CACHE_ARRAY_CAPACITY = 8;
  65 
  66     /**
  67      * The Java class this type represents.
  68      */
  69     private final Class&lt;?&gt; javaClass;
  70     private HotSpotResolvedJavaMethodImpl[] methodCacheArray;
  71     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCacheHashMap;
  72     private HotSpotResolvedJavaField[] instanceFields;
  73     private HotSpotResolvedObjectTypeImpl[] interfaces;
  74     private HotSpotConstantPool constantPool;
  75     final HotSpotJVMCIMetaAccessContext context;
  76     private HotSpotResolvedObjectType arrayOfType;
  77 
  78     /**
<a name="2" id="anc2"></a><span class="new">  79      * Managed exclusively by {@link HotSpotResolvedJavaFieldImpl#toJava}.</span>
<span class="new">  80      */</span>
<span class="new">  81     HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; reflectionFieldCache;</span>
<span class="new">  82 </span>
<span class="new">  83     /**</span>
  84      * Gets the JVMCI mirror for a {@link Class} object.
  85      *
  86      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}
  87      */
  88     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {
  89         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);
  90     }
  91 
  92     /**
  93      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the
  94      * underlying Klass*, it is used instead of the raw Klass*.
  95      *
  96      * Called from the VM.
  97      *
  98      * @param javaClass a {@link Class} object
  99      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
 100      */
 101     @SuppressWarnings("unused")
 102     private static HotSpotResolvedObjectTypeImpl fromMetaspace(Class&lt;?&gt; javaClass) {
 103         return fromObjectClass(javaClass);
 104     }
 105 
 106     /**
 107      * Creates the JVMCI mirror for a {@link Class} object.
 108      *
 109      * &lt;p&gt;
 110      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
 111      * {@link Class} type. Use {@link #fromObjectClass(Class)} or {@link #fromMetaspace(Class)}
 112      * instead.
 113      * &lt;/p&gt;
 114      *
 115      * @param javaClass the Class to create the mirror for
 116      * @param context
 117      */
 118     HotSpotResolvedObjectTypeImpl(Class&lt;?&gt; javaClass, HotSpotJVMCIMetaAccessContext context) {
 119         super(getSignatureName(javaClass));
 120         this.javaClass = javaClass;
 121         this.context = context;
 122         assert getName().charAt(0) != '[' || isArray() : getName();
 123     }
 124 
 125     /**
 126      * Returns the name of this type as it would appear in a signature.
 127      */
 128     private static String getSignatureName(Class&lt;?&gt; javaClass) {
 129         if (javaClass.isArray()) {
 130             return javaClass.getName().replace('.', '/');
 131         }
 132         return "L" + javaClass.getName().replace('.', '/') + ";";
 133     }
 134 
 135     /**
 136      * Gets the metaspace Klass for this type.
 137      */
 138     long getMetaspaceKlass() {
 139         if (HotSpotJVMCIRuntime.getHostWordKind() == JavaKind.Long) {
 140             return UNSAFE.getLong(javaClass, config().klassOffset);
 141         }
 142         return UNSAFE.getInt(javaClass, config().klassOffset) &amp; 0xFFFFFFFFL;
 143     }
 144 
 145     @Override
 146     public long getMetaspacePointer() {
 147         return getMetaspaceKlass();
 148     }
 149 
 150     /**
 151      * The Klass* for this object is kept alive by the direct reference to {@link #javaClass} so no
 152      * extra work is required.
 153      */
 154     @Override
 155     public boolean isRegistered() {
 156         return true;
 157     }
 158 
 159     @Override
 160     public int getModifiers() {
 161         if (isArray()) {
 162             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 163         } else {
 164             return getAccessFlags() &amp; jvmClassModifiers();
 165         }
 166     }
 167 
 168     public int getAccessFlags() {
 169         HotSpotVMConfig config = config();
 170         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 171     }
 172 
 173     @Override
 174     public HotSpotResolvedObjectType getArrayClass() {
 175         if (arrayOfType == null) {
 176             arrayOfType = fromObjectClass(Array.newInstance(mirror(), 0).getClass());
 177         }
 178         return arrayOfType;
 179     }
 180 
 181     @Override
 182     public ResolvedJavaType getComponentType() {
 183         Class&lt;?&gt; javaComponentType = mirror().getComponentType();
 184         return javaComponentType == null ? null : runtime().fromClass(javaComponentType);
 185     }
 186 
 187     @Override
 188     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 189         if (isLeaf()) {
 190             // No assumptions are required.
 191             return new AssumptionResult&lt;&gt;(this);
 192         }
 193         HotSpotVMConfig config = config();
 194         if (isArray()) {
 195             ResolvedJavaType elementalType = getElementalType();
 196             AssumptionResult&lt;ResolvedJavaType&gt; elementType = elementalType.findLeafConcreteSubtype();
 197             if (elementType != null &amp;&amp; elementType.getResult().equals(elementalType)) {
 198                 /*
 199                  * If the elementType is leaf then the array is leaf under the same assumptions but
 200                  * only if the element type is exactly the leaf type. The element type can be
 201                  * abstract even if there is only one implementor of the abstract type.
 202                  */
 203                 AssumptionResult&lt;ResolvedJavaType&gt; result = new AssumptionResult&lt;&gt;(this);
 204                 result.add(elementType);
 205                 return result;
 206             }
 207             return null;
 208         } else if (isInterface()) {
 209             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
 210             /*
 211              * If the implementor field contains itself that indicates that the interface has more
 212              * than one implementors (see: InstanceKlass::add_implementor).
 213              */
 214             if (implementor == null || implementor.equals(this)) {
 215                 return null;
 216             }
 217 
 218             assert !implementor.isInterface();
 219             if (implementor.isAbstract() || !implementor.isLeafClass()) {
 220                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
 221                 if (leafConcreteSubtype != null) {
 222                     assert !leafConcreteSubtype.getResult().equals(implementor);
 223                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
 224                     // Accumulate leaf assumptions and return the combined result.
 225                     newResult.add(leafConcreteSubtype);
 226                     return newResult;
 227                 }
 228                 return null;
 229             }
 230             return concreteSubtype(implementor);
 231         } else {
 232             HotSpotResolvedObjectTypeImpl type = this;
 233             while (type.isAbstract()) {
 234                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
 235                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
 236                     return null;
 237                 }
 238                 type = subklass;
 239             }
 240             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
 241                 return null;
 242             }
 243             if (this.isAbstract()) {
 244                 return concreteSubtype(type);
 245             } else {
 246                 assert this.equals(type);
 247                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 248             }
 249         }
 250     }
 251 
 252     private AssumptionResult&lt;ResolvedJavaType&gt; concreteSubtype(HotSpotResolvedObjectTypeImpl type) {
 253         if (type.isLeaf()) {
 254             return new AssumptionResult&lt;&gt;(type, new ConcreteSubtype(this, type));
 255         } else {
 256             return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 257         }
 258     }
 259 
 260     /**
 261      * Returns if type {@code type} is a leaf class. This is the case if the
 262      * {@code Klass::_subklass} field of the underlying class is zero.
 263      *
 264      * @return true if the type is a leaf class
 265      */
 266     private boolean isLeafClass() {
 267         return UNSAFE.getLong(this.getMetaspaceKlass() + config().subklassOffset) == 0;
 268     }
 269 
 270     /**
 271      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 272      * type {@code type}.
 273      *
 274      * @return value of the subklass field as metaspace klass pointer
 275      */
 276     private HotSpotResolvedObjectTypeImpl getSubklass() {
 277         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 278     }
 279 
 280     @Override
 281     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 282         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();
 283         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);
 284     }
 285 
 286     @Override
 287     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 288         if (interfaces == null) {
 289             Class&lt;?&gt;[] javaInterfaces = mirror().getInterfaces();
 290             HotSpotResolvedObjectTypeImpl[] result = new HotSpotResolvedObjectTypeImpl[javaInterfaces.length];
 291             for (int i = 0; i &lt; javaInterfaces.length; i++) {
 292                 result[i] = fromObjectClass(javaInterfaces[i]);
 293             }
 294             interfaces = result;
 295         }
 296         return interfaces;
 297     }
 298 
 299     @Override
 300     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 301         if (!isInterface()) {
 302             throw new JVMCIError("Cannot call getSingleImplementor() on a non-interface type: %s", this);
 303         }
 304         return compilerToVM().getImplementor(this);
 305     }
 306 
 307     @Override
 308     public HotSpotResolvedObjectTypeImpl getSupertype() {
 309         if (isArray()) {
 310             ResolvedJavaType componentType = getComponentType();
 311             if (mirror() == Object[].class || componentType.isPrimitive()) {
 312                 return fromObjectClass(Object.class);
 313             }
 314             return (HotSpotResolvedObjectTypeImpl) ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype().getArrayClass();
 315         }
 316         if (isInterface()) {
 317             return fromObjectClass(Object.class);
 318         }
 319         return getSuperclass();
 320     }
 321 
 322     @Override
 323     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 324         if (otherType.isPrimitive()) {
 325             return null;
 326         } else {
 327             HotSpotResolvedObjectTypeImpl t1 = this;
 328             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 329             while (true) {
 330                 if (t1.isAssignableFrom(t2)) {
 331                     return t1;
 332                 }
 333                 if (t2.isAssignableFrom(t1)) {
 334                     return t2;
 335                 }
 336                 t1 = t1.getSupertype();
 337                 t2 = t2.getSupertype();
 338             }
 339         }
 340     }
 341 
 342     @Override
 343     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 344         assert !isArray();
 345         if (!compilerToVM().hasFinalizableSubclass(this)) {
 346             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 347         }
 348         return new AssumptionResult&lt;&gt;(true);
 349     }
 350 
 351     @Override
 352     public boolean hasFinalizer() {
 353         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 354     }
 355 
 356     @Override
 357     public boolean isPrimitive() {
 358         return false;
 359     }
 360 
 361     @Override
 362     public boolean isArray() {
 363         return mirror().isArray();
 364     }
 365 
 366     @Override
 367     public boolean isEnum() {
 368         return mirror().isEnum();
 369     }
 370 
 371     @Override
 372     public boolean isInitialized() {
 373         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 374     }
 375 
 376     @Override
 377     public boolean isLinked() {
 378         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 379     }
 380 
 381     /**
 382      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 383      * klass.
 384      *
 385      * @return state field value of this type
 386      */
 387     private int getInitState() {
 388         assert !isArray() : "_init_state only exists in InstanceKlass";
 389         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 390     }
 391 
 392     @Override
 393     public void initialize() {
 394         if (!isInitialized()) {
 395             UNSAFE.ensureClassInitialized(mirror());
 396             assert isInitialized();
 397         }
 398     }
 399 
 400     @Override
 401     public boolean isInstance(JavaConstant obj) {
 402         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
 403             return mirror().isInstance(((HotSpotObjectConstantImpl) obj).object());
 404         }
 405         return false;
 406     }
 407 
 408     @Override
 409     public boolean isInstanceClass() {
 410         return !isArray() &amp;&amp; !isInterface();
 411     }
 412 
 413     @Override
 414     public boolean isInterface() {
 415         return mirror().isInterface();
 416     }
 417 
 418     @Override
 419     public boolean isAssignableFrom(ResolvedJavaType other) {
 420         assert other != null;
 421         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 422             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
 423             return mirror().isAssignableFrom(otherType.mirror());
 424         }
 425         return false;
 426     }
 427 
 428     @Override
 429     public ResolvedJavaType getHostClass() {
 430         if (isArray()) {
 431             return null;
 432         }
 433         return compilerToVM().getHostClass(this);
 434     }
 435 
 436     @Override
 437     public boolean isJavaLangObject() {
 438         return javaClass.equals(Object.class);
 439     }
 440 
 441     @Override
 442     public JavaKind getJavaKind() {
 443         return JavaKind.Object;
 444     }
 445 
 446     @Override
 447     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 448         assert !callerType.isArray();
 449         if (isInterface()) {
 450             // Methods can only be resolved against concrete types
 451             return null;
 452         }
 453         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic() &amp;&amp; !isSignaturePolymorphicHolder(method.getDeclaringClass())) {
 454             return method;
 455         }
 456         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 457             return null;
 458         }
 459         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
 460         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
 461         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
 462     }
 463 
 464     @Override
 465     public HotSpotConstantPool getConstantPool() {
 466         if (constantPool == null || !isArray() &amp;&amp; UNSAFE.getAddress(getMetaspaceKlass() + config().instanceKlassConstantsOffset) != constantPool.getMetaspaceConstantPool()) {
 467             /*
 468              * If the pointer to the ConstantPool has changed since this was last read refresh the
 469              * HotSpotConstantPool wrapper object. This ensures that uses of the constant pool are
 470              * operating on the latest one and that HotSpotResolvedJavaMethodImpls will be able to
 471              * use the shared copy instead of creating their own instance.
 472              */
 473             constantPool = compilerToVM().getConstantPool(this);
 474         }
 475         return constantPool;
 476     }
 477 
 478     /**
 479      * Gets the instance size of this type. If an instance of this type cannot be fast path
 480      * allocated, then the returned value is negative (its absolute value gives the size). Must not
 481      * be called if this is an array or interface type.
 482      */
 483     @Override
 484     public int instanceSize() {
 485         assert !isArray();
 486         assert !isInterface();
 487 
 488         HotSpotVMConfig config = config();
 489         final int layoutHelper = layoutHelper();
 490         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : "must be instance";
 491 
 492         // See: Klass::layout_helper_size_in_bytes
 493         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 494 
 495         // See: Klass::layout_helper_needs_slow_path
 496         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 497 
 498         return needsSlowPath ? -size : size;
 499     }
 500 
 501     @Override
 502     public int layoutHelper() {
 503         HotSpotVMConfig config = config();
 504         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 505     }
 506 
 507     @Override
 508     public long getFingerprint() {
 509         return compilerToVM().getFingerprint(getMetaspaceKlass());
 510     }
 511 
 512     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {
 513         // Maintain cache as array.
 514         if (methodCacheArray == null) {
 515             methodCacheArray = new HotSpotResolvedJavaMethodImpl[METHOD_CACHE_ARRAY_CAPACITY];
 516         }
 517 
 518         int i = 0;
 519         for (; i &lt; methodCacheArray.length; ++i) {
 520             HotSpotResolvedJavaMethodImpl curMethod = methodCacheArray[i];
 521             if (curMethod == null) {
 522                 HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);
 523                 methodCacheArray[i] = newMethod;
 524                 context.add(newMethod);
 525                 return newMethod;
 526             } else if (curMethod.getMetaspacePointer() == metaspaceMethod) {
 527                 return curMethod;
 528             }
 529         }
 530 
 531         // Fall-back to hash table.
 532         if (methodCacheHashMap == null) {
 533             methodCacheHashMap = new HashMap&lt;&gt;();
 534         }
 535 
 536         HotSpotResolvedJavaMethodImpl lookupResult = methodCacheHashMap.get(metaspaceMethod);
 537         if (lookupResult == null) {
 538             HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);
 539             methodCacheHashMap.put(metaspaceMethod, newMethod);
 540             context.add(lookupResult);
 541             return newMethod;
 542         } else {
 543             return lookupResult;
 544         }
 545     }
 546 
 547     @Override
 548     public int getVtableLength() {
 549         HotSpotVMConfig config = config();
 550         if (isInterface() || isArray()) {
 551             /* Everything has the core vtable of java.lang.Object */
 552             return config.baseVtableLength();
 553         }
 554         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 555         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + " " + config.vtableEntrySize;
 556         return result;
 557     }
 558 
 559     HotSpotResolvedJavaField createField(JavaType type, long offset, int rawFlags, int index) {
 560         return new HotSpotResolvedJavaFieldImpl(this, type, offset, rawFlags, index);
 561     }
 562 
 563     @Override
 564     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 565         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 566         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 567         /*
 568          * Sometimes the receiver type in the graph hasn't stabilized to a subtype of declared
 569          * holder, usually because of phis, so make sure that the type is related to the declared
 570          * type before using it for lookup. Unlinked types should also be ignored because we can't
 571          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 572          * a deopt instead since they can't really be used if they aren't linked yet.
 573          */
 574         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 575             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 576             if (result != null) {
 577                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 578             }
 579             return null;
 580         }
 581         /*
 582          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 583          * the correct method for the subtype.
 584          */
 585         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 586         if (resolvedMethod == null) {
 587             // The type isn't known to implement the method.
 588             return null;
 589         }
 590 
 591         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 592         if (result != null) {
 593             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 594         }
 595         return null;
 596     }
 597 
 598     FieldInfo createFieldInfo(int index) {
 599         return new FieldInfo(index);
 600     }
 601 
 602     /**
 603      * This class represents the field information for one field contained in the fields array of an
 604      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 605      */
 606     class FieldInfo {
 607         /**
 608          * Native pointer into the array of Java shorts.
 609          */
 610         private final long metaspaceData;
 611 
 612         /**
 613          * Creates a field info for the field in the fields array at index {@code index}.
 614          *
 615          * @param index index to the fields array
 616          */
 617         FieldInfo(int index) {
 618             HotSpotVMConfig config = config();
 619             // Get Klass::_fields
 620             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 621             assert config.fieldInfoFieldSlots == 6 : "revisit the field parsing code";
 622             int offset = config.fieldInfoFieldSlots * Short.BYTES * index;
 623             metaspaceData = metaspaceFields + config.arrayU2DataOffset + offset;
 624         }
 625 
 626         private int getAccessFlags() {
 627             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
 628         }
 629 
 630         private int getNameIndex() {
 631             return readFieldSlot(config().fieldInfoNameIndexOffset);
 632         }
 633 
 634         private int getSignatureIndex() {
 635             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
 636         }
 637 
 638         public int getOffset() {
 639             HotSpotVMConfig config = config();
 640             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
 641             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
 642             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
 643             return offset;
 644         }
 645 
 646         /**
 647          * Helper method to read an entry (slot) from the field array. Currently field info is laid
 648          * on top an array of Java shorts.
 649          */
 650         private int readFieldSlot(int index) {
 651             int offset = Short.BYTES * index;
 652             return UNSAFE.getChar(metaspaceData + offset);
 653         }
 654 
 655         /**
 656          * Returns the name of this field as a {@link String}. If the field is an internal field the
 657          * name index is pointing into the vmSymbols table.
 658          */
 659         public String getName() {
 660             final int nameIndex = getNameIndex();
 661             return isInternal() ? config().symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
 662         }
 663 
 664         /**
 665          * Returns the signature of this field as {@link String}. If the field is an internal field
 666          * the signature index is pointing into the vmSymbols table.
 667          */
 668         public String getSignature() {
 669             final int signatureIndex = getSignatureIndex();
 670             return isInternal() ? config().symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
 671         }
 672 
 673         public JavaType getType() {
 674             String signature = getSignature();
 675             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 676         }
 677 
 678         private boolean isInternal() {
 679             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 680         }
 681 
 682         public boolean isStatic() {
 683             return Modifier.isStatic(getAccessFlags());
 684         }
 685 
 686         public boolean hasGenericSignature() {
 687             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 688         }
 689     }
 690 
 691     @Override
 692     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 693         if (instanceFields == null) {
 694             if (isArray() || isInterface()) {
 695                 instanceFields = NO_FIELDS;
 696             } else {
 697                 HotSpotResolvedJavaField[] prepend = NO_FIELDS;
 698                 if (getSuperclass() != null) {
 699                     prepend = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 700                 }
 701                 instanceFields = getFields(false, prepend);
 702             }
 703         }
 704         if (!includeSuperclasses &amp;&amp; getSuperclass() != null) {
 705             int superClassFieldCount = getSuperclass().getInstanceFields(true).length;
 706             if (superClassFieldCount == instanceFields.length) {
 707                 // This class does not have any instance fields of its own.
 708                 return NO_FIELDS;
 709             } else if (superClassFieldCount != 0) {
 710                 HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[instanceFields.length - superClassFieldCount];
 711                 System.arraycopy(instanceFields, superClassFieldCount, result, 0, result.length);
 712                 return result;
 713             } else {
 714                 // The super classes of this class do not have any instance fields.
 715             }
 716         }
 717         return instanceFields;
 718     }
 719 
 720     @Override
 721     public ResolvedJavaField[] getStaticFields() {
 722         if (isArray()) {
 723             return new HotSpotResolvedJavaField[0];
 724         } else {
 725             return getFields(true, NO_FIELDS);
 726         }
 727     }
 728 
 729     /**
 730      * Gets the instance or static fields of this class.
 731      *
 732      * @param retrieveStaticFields specifies whether to return instance or static fields
 733      * @param prepend an array to be prepended to the returned result
 734      */
 735     private HotSpotResolvedJavaField[] getFields(boolean retrieveStaticFields, HotSpotResolvedJavaField[] prepend) {
 736         HotSpotVMConfig config = config();
 737         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 738         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
 739         int resultCount = 0;
 740         int index = 0;
 741         for (int i = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
 742             FieldInfo field = new FieldInfo(index);
 743             if (field.hasGenericSignature()) {
 744                 metaspaceFieldsLength--;
 745             }
 746 
 747             if (field.isStatic() == retrieveStaticFields) {
 748                 resultCount++;
 749             }
 750         }
 751 
 752         if (resultCount == 0) {
 753             return prepend;
 754         }
 755 
 756         int prependLength = prepend.length;
 757         resultCount += prependLength;
 758 
 759         HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[resultCount];
 760         if (prependLength != 0) {
 761             System.arraycopy(prepend, 0, result, 0, prependLength);
 762         }
 763 
 764         int resultIndex = prependLength;
 765         for (int i = 0; i &lt; index; ++i) {
 766             FieldInfo field = new FieldInfo(i);
 767             if (field.isStatic() == retrieveStaticFields) {
 768                 int offset = field.getOffset();
 769                 HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);
 770 
 771                 // Make sure the result is sorted by offset.
 772                 int j;
 773                 for (j = resultIndex - 1; j &gt;= prependLength &amp;&amp; result[j].getOffset() &gt; offset; j--) {
 774                     result[j + 1] = result[j];
 775                 }
 776                 result[j + 1] = resolvedJavaField;
 777                 resultIndex++;
 778             }
 779         }
 780 
 781         return result;
 782     }
 783 
 784     @Override
 785     public Class&lt;?&gt; mirror() {
 786         return javaClass;
 787     }
 788 
 789     @Override
 790     public String getSourceFileName() {
 791         HotSpotVMConfig config = config();
 792         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
 793         if (sourceFileNameIndex == 0) {
 794             return null;
 795         }
 796         return getConstantPool().lookupUtf8(sourceFileNameIndex);
 797     }
 798 
 799     @Override
 800     public Annotation[] getAnnotations() {
 801         return mirror().getAnnotations();
 802     }
 803 
 804     @Override
 805     public Annotation[] getDeclaredAnnotations() {
 806         return mirror().getDeclaredAnnotations();
 807     }
 808 
 809     @Override
 810     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 811         return mirror().getAnnotation(annotationClass);
 812     }
 813 
 814     /**
 815      * Performs a fast-path check that this type is resolved in the context of a given accessing
 816      * class. A negative result does not mean this type is not resolved with respect to
 817      * {@code accessingClass}. That can only be determined by
 818      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 819      * re-resolving} the type.
 820      */
 821     @Override
 822     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 823         assert accessingClass != null;
 824         ResolvedJavaType elementType = getElementalType();
 825         if (elementType.isPrimitive()) {
 826             // Primitive type resolution is context free.
 827             return true;
 828         }
 829         if (elementType.getName().startsWith("Ljava/")) {
 830             // Classes in a java.* package can only be defined by the
 831             // boot or platform class loader.
 832             return true;
 833         }
 834         ClassLoader thisCl = mirror().getClassLoader();
 835         ClassLoader accessingClassCl = ((HotSpotResolvedObjectTypeImpl) accessingClass).mirror().getClassLoader();
 836         return thisCl == accessingClassCl;
 837     }
 838 
 839     @Override
 840     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 841         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 842             return this;
 843         }
 844         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 845         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 846     }
 847 
 848     /**
 849      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 850      */
 851     @Override
 852     public Constant klass() {
 853         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 854     }
 855 
 856     @Override
 857     public boolean isPrimaryType() {
 858         return config().secondarySuperCacheOffset != superCheckOffset();
 859     }
 860 
 861     @Override
 862     public int superCheckOffset() {
 863         HotSpotVMConfig config = config();
 864         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
 865     }
 866 
 867     @Override
 868     public long prototypeMarkWord() {
 869         HotSpotVMConfig config = config();
 870         if (isArray()) {
 871             return config.arrayPrototypeMarkWord();
 872         } else {
 873             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 874         }
 875     }
 876 
 877     @Override
 878     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 879         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 880         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 881     }
 882 
 883     public ResolvedJavaField findStaticFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 884         ResolvedJavaField[] declaredFields = getStaticFields();
 885         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 886     }
 887 
 888     private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {
 889         for (ResolvedJavaField field : declaredFields) {
 890             HotSpotResolvedJavaField resolvedField = (HotSpotResolvedJavaField) field;
 891             long resolvedFieldOffset = resolvedField.getOffset();
 892             // @formatter:off
 893             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN  &amp;&amp;
 894                             expectedEntryKind.isPrimitive() &amp;&amp;
 895                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;
 896                             resolvedField.getJavaKind().isPrimitive()) {
 897                 resolvedFieldOffset +=
 898                                 resolvedField.getJavaKind().getByteCount() -
 899                                 Math.min(resolvedField.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());
 900             }
 901             if (resolvedFieldOffset == offset) {
 902                 return field;
 903             }
 904             // @formatter:on
 905         }
 906         return null;
 907     }
 908 
 909     @Override
 910     public boolean isLocal() {
 911         return mirror().isLocalClass();
 912     }
 913 
 914     @Override
 915     public boolean isMember() {
 916         return mirror().isMemberClass();
 917     }
 918 
 919     @Override
 920     public HotSpotResolvedObjectTypeImpl getEnclosingType() {
 921         final Class&lt;?&gt; encl = mirror().getEnclosingClass();
 922         return encl == null ? null : fromObjectClass(encl);
 923     }
 924 
 925     @Override
 926     public ResolvedJavaMethod[] getDeclaredConstructors() {
 927         Constructor&lt;?&gt;[] constructors = mirror().getDeclaredConstructors();
 928         ResolvedJavaMethod[] result = new ResolvedJavaMethod[constructors.length];
 929         for (int i = 0; i &lt; constructors.length; i++) {
 930             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(constructors[i]);
 931             assert result[i].isConstructor();
 932         }
 933         return result;
 934     }
 935 
 936     @Override
 937     public ResolvedJavaMethod[] getDeclaredMethods() {
 938         Method[] methods = mirror().getDeclaredMethods();
 939         ResolvedJavaMethod[] result = new ResolvedJavaMethod[methods.length];
 940         for (int i = 0; i &lt; methods.length; i++) {
 941             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(methods[i]);
 942             assert !result[i].isConstructor();
 943         }
 944         return result;
 945     }
 946 
 947     @Override
 948     public ResolvedJavaMethod getClassInitializer() {
 949         if (!isArray()) {
 950             return compilerToVM().getClassInitializer(this);
 951         }
 952         return null;
 953     }
 954 
 955     @Override
 956     public String toString() {
 957         return "HotSpotType&lt;" + getName() + ", resolved&gt;";
 958     }
 959 
 960     @Override
 961     public ResolvedJavaType lookupType(UnresolvedJavaType unresolvedJavaType, boolean resolve) {
 962         JavaType javaType = HotSpotJVMCIRuntime.runtime().lookupType(unresolvedJavaType.getName(), this, resolve);
 963         if (javaType instanceof ResolvedJavaType) {
 964             return (ResolvedJavaType) javaType;
 965         }
 966         return null;
 967     }
 968 
 969     @Override
 970     public ResolvedJavaField resolveField(UnresolvedJavaField unresolvedJavaField, ResolvedJavaType accessingClass) {
 971         for (ResolvedJavaField field : getInstanceFields(false)) {
 972             if (field.getName().equals(unresolvedJavaField.getName())) {
 973                 return field;
 974             }
 975         }
 976         for (ResolvedJavaField field : getStaticFields()) {
 977             if (field.getName().equals(unresolvedJavaField.getName())) {
 978                 return field;
 979             }
 980         }
 981         throw new InternalError(unresolvedJavaField.toString());
 982     }
 983 
 984     @Override
 985     public boolean isCloneableWithAllocation() {
 986         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
 987     }
 988 
 989     private int getMiscFlags() {
 990         return UNSAFE.getInt(getMetaspaceKlass() + config().instanceKlassMiscFlagsOffset);
 991     }
 992 
 993     @Override
 994     public boolean isUnsafeAnonymous() {
 995         return (getMiscFlags() &amp; config().instanceKlassMiscIsUnsafeAnonymous) != 0;
 996     }
 997 
 998 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="3" type="hidden" /></form></body></html>
