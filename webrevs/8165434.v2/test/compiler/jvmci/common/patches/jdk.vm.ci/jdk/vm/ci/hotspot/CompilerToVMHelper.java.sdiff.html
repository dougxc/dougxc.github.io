<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff test/compiler/jvmci/common/patches/jdk.vm.ci/jdk/vm/ci/hotspot </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../test/compiler/jvmci/common/CTVMUtilities.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../test/compiler/jvmci/compilerToVM/FindUniqueConcreteMethodTest.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>test/compiler/jvmci/common/patches/jdk.vm.ci/jdk/vm/ci/hotspot/CompilerToVMHelper.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package jdk.vm.ci.hotspot;
  25 
  26 import jdk.vm.ci.code.InstalledCode;
  27 import jdk.vm.ci.code.InvalidInstalledCodeException;
  28 import jdk.vm.ci.code.TargetDescription;
  29 import jdk.vm.ci.meta.ConstantPool;
  30 import jdk.vm.ci.meta.ResolvedJavaMethod;

  31 
  32 /**
  33  * A simple "proxy" class to get test access to CompilerToVM package-private methods
  34  */
  35 public class CompilerToVMHelper {
  36     public static final CompilerToVM CTVM = new CompilerToVM();
  37 
  38     public static byte[] getBytecode(HotSpotResolvedJavaMethod method) {
  39         return CTVM.getBytecode((HotSpotResolvedJavaMethodImpl)method);
  40     }
  41 
  42     public static int getExceptionTableLength(HotSpotResolvedJavaMethod method) {
  43         return CTVM.getExceptionTableLength((HotSpotResolvedJavaMethodImpl)method);
  44     }
  45 
  46     public static long getExceptionTableStart(HotSpotResolvedJavaMethod method) {
  47         return CTVM.getExceptionTableStart((HotSpotResolvedJavaMethodImpl)method);
  48     }
  49 
  50     public static boolean canInlineMethod(HotSpotResolvedJavaMethod method) {

</pre><hr></hr><pre>
 154     public static Object[] readConfiguration() {
 155         return CTVM.readConfiguration();
 156     }
 157 
 158     public static HotSpotResolvedJavaMethod resolveMethod(
 159             HotSpotResolvedObjectType exactReceiver,
 160             HotSpotResolvedJavaMethod method,
 161             HotSpotResolvedObjectType caller) {
 162         return CTVM.resolveMethod((HotSpotResolvedObjectTypeImpl) exactReceiver, (HotSpotResolvedJavaMethodImpl) method, (HotSpotResolvedObjectTypeImpl) caller);
 163     }
 164 
 165     public static HotSpotResolvedJavaMethod getClassInitializer(
 166             HotSpotResolvedObjectType type) {
 167         return CTVM.getClassInitializer((HotSpotResolvedObjectTypeImpl) type);
 168     }
 169 
 170     public static boolean hasFinalizableSubclass(HotSpotResolvedObjectType type) {
 171         return CTVM.hasFinalizableSubclass((HotSpotResolvedObjectTypeImpl) type);
 172     }
 173 
<span class="changed"> 174     public static HotSpotResolvedJavaMethodImpl getResolvedJavaMethodAtSlot(</span>
<span class="changed"> 175             Class&lt;?&gt; holder, int slot) {</span>
<span class="changed"> 176         return CTVM.getResolvedJavaMethodAtSlot(holder, slot);</span>
 177     }
 178 
 179     public static long getMaxCallTargetOffset(long address) {
 180         return CTVM.getMaxCallTargetOffset(address);
 181     }
 182 
 183     public static String disassembleCodeBlob(InstalledCode codeBlob) {
 184         return CTVM.disassembleCodeBlob(codeBlob);
 185     }
 186 
 187     public static StackTraceElement getStackTraceElement(
 188             HotSpotResolvedJavaMethod method, int bci) {
 189         return CTVM.getStackTraceElement((HotSpotResolvedJavaMethodImpl)method, bci);
 190     }
 191 
 192     public static Object executeInstalledCode(Object[] args,
 193             InstalledCode installedCode) throws InvalidInstalledCodeException {
 194         return CTVM.executeInstalledCode(args, installedCode);
 195     }
 196 

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package jdk.vm.ci.hotspot;
  25 
  26 import jdk.vm.ci.code.InstalledCode;
  27 import jdk.vm.ci.code.InvalidInstalledCodeException;
  28 import jdk.vm.ci.code.TargetDescription;
  29 import jdk.vm.ci.meta.ConstantPool;
  30 import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="new">  31 import java.lang.reflect.Executable;</span>
  32 
  33 /**
  34  * A simple "proxy" class to get test access to CompilerToVM package-private methods
  35  */
  36 public class CompilerToVMHelper {
  37     public static final CompilerToVM CTVM = new CompilerToVM();
  38 
  39     public static byte[] getBytecode(HotSpotResolvedJavaMethod method) {
  40         return CTVM.getBytecode((HotSpotResolvedJavaMethodImpl)method);
  41     }
  42 
  43     public static int getExceptionTableLength(HotSpotResolvedJavaMethod method) {
  44         return CTVM.getExceptionTableLength((HotSpotResolvedJavaMethodImpl)method);
  45     }
  46 
  47     public static long getExceptionTableStart(HotSpotResolvedJavaMethod method) {
  48         return CTVM.getExceptionTableStart((HotSpotResolvedJavaMethodImpl)method);
  49     }
  50 
  51     public static boolean canInlineMethod(HotSpotResolvedJavaMethod method) {

</pre><hr></hr><pre>
 155     public static Object[] readConfiguration() {
 156         return CTVM.readConfiguration();
 157     }
 158 
 159     public static HotSpotResolvedJavaMethod resolveMethod(
 160             HotSpotResolvedObjectType exactReceiver,
 161             HotSpotResolvedJavaMethod method,
 162             HotSpotResolvedObjectType caller) {
 163         return CTVM.resolveMethod((HotSpotResolvedObjectTypeImpl) exactReceiver, (HotSpotResolvedJavaMethodImpl) method, (HotSpotResolvedObjectTypeImpl) caller);
 164     }
 165 
 166     public static HotSpotResolvedJavaMethod getClassInitializer(
 167             HotSpotResolvedObjectType type) {
 168         return CTVM.getClassInitializer((HotSpotResolvedObjectTypeImpl) type);
 169     }
 170 
 171     public static boolean hasFinalizableSubclass(HotSpotResolvedObjectType type) {
 172         return CTVM.hasFinalizableSubclass((HotSpotResolvedObjectTypeImpl) type);
 173     }
 174 
<span class="changed"> 175     public static HotSpotResolvedJavaMethodImpl asResolvedJavaMethod(</span>
<span class="changed"> 176             Executable executable) {</span>
<span class="changed"> 177         return CTVM.asResolvedJavaMethod(executable);</span>
 178     }
 179 
 180     public static long getMaxCallTargetOffset(long address) {
 181         return CTVM.getMaxCallTargetOffset(address);
 182     }
 183 
 184     public static String disassembleCodeBlob(InstalledCode codeBlob) {
 185         return CTVM.disassembleCodeBlob(codeBlob);
 186     }
 187 
 188     public static StackTraceElement getStackTraceElement(
 189             HotSpotResolvedJavaMethod method, int bci) {
 190         return CTVM.getStackTraceElement((HotSpotResolvedJavaMethodImpl)method, bci);
 191     }
 192 
 193     public static Object executeInstalledCode(Object[] args,
 194             InstalledCode installedCode) throws InvalidInstalledCodeException {
 195         return CTVM.executeInstalledCode(args, installedCode);
 196     }
 197 

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../test/compiler/jvmci/common/CTVMUtilities.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../test/compiler/jvmci/compilerToVM/FindUniqueConcreteMethodTest.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
