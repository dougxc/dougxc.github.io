<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>open Sdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HandleCleaner.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/hotspot/share/jvmci/metadataHandleBlock.cpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-59942">59942</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8248359">8248359</a>: [JVMCI] miscellaneous code cleanups and improvements</pre>

<table><tr valign="top">
<td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.InitTimer.timer;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;
  27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  29 
  30 import java.io.IOException;
  31 import java.io.OutputStream;
  32 import java.io.PrintStream;
  33 import java.io.Serializable;
  34 import java.lang.invoke.CallSite;
  35 import java.lang.invoke.ConstantCallSite;
  36 import java.lang.invoke.MethodHandle;
  37 import java.lang.ref.WeakReference;
  38 import java.util.ArrayList;
  39 import java.util.Collections;

  40 import java.util.HashMap;
  41 import java.util.List;
  42 import java.util.Map;
  43 import java.util.Objects;
  44 import java.util.ServiceLoader;
  45 import java.util.function.Predicate;
  46 
  47 import jdk.vm.ci.code.Architecture;
  48 import jdk.vm.ci.code.CompilationRequestResult;
  49 import jdk.vm.ci.code.CompiledCode;
  50 import jdk.vm.ci.code.InstalledCode;
  51 import jdk.vm.ci.common.InitTimer;
  52 import jdk.vm.ci.common.JVMCIError;
  53 import jdk.vm.ci.common.NativeImageReinitialize;
  54 import jdk.vm.ci.meta.JavaKind;
  55 import jdk.vm.ci.meta.JavaType;
  56 import jdk.vm.ci.meta.ResolvedJavaType;
  57 import jdk.vm.ci.meta.UnresolvedJavaType;
  58 import jdk.vm.ci.runtime.JVMCI;
  59 import jdk.vm.ci.runtime.JVMCIBackend;

</pre><hr></hr><pre>
 194         }
 195         return result;
 196     }
 197 
 198     @VMEntryPoint
 199     static Throwable decodeThrowable(String encodedThrowable) throws Throwable {
 200         return TranslatedException.decodeThrowable(encodedThrowable);
 201     }
 202 
 203     @VMEntryPoint
 204     static String encodeThrowable(Throwable throwable) throws Throwable {
 205         return TranslatedException.encodeThrowable(throwable);
 206     }
 207 
 208     @VMEntryPoint
 209     static String callToString(Object o) {
 210         return o.toString();
 211     }
 212 
 213     /**









 214      * A list of all supported JVMCI options.
 215      */
 216     public enum Option {
 217         // @formatter:off
 218         Compiler(String.class, null, "Selects the system compiler. This must match the getCompilerName() value returned " +
 219                 "by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. " +
 220                 "An empty string or the value \"null\" selects a compiler " +
 221                 "that will raise an exception upon receiving a compilation request."),
 222         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
 223         // so that -XX:+JVMCIPrintProperties shows the option.
 224         InitTimer(Boolean.class, false, "Specifies if initialization timing is enabled."),
 225         PrintConfig(Boolean.class, false, "Prints VM configuration available via JVMCI."),
 226         AuditHandles(Boolean.class, false, "Record stack trace along with scoped foreign object reference wrappers " +
 227                 "to debug issue with a wrapper being used after its scope has closed."),
 228         TraceMethodDataFilter(String.class, null,
 229                 "Enables tracing of profiling info when read by JVMCI.",
 230                 "Empty value: trace all methods",
 231                 "Non-empty value: trace methods whose fully qualified name contains the value."),
 232         UseProfilingInformation(Boolean.class, true, "");
 233         // @formatter:on
 234 
 235         /**
 236          * The prefix for system properties that are JVMCI options.
 237          */
 238         private static final String JVMCI_OPTION_PROPERTY_PREFIX = "jvmci.";
 239 
 240         /**
 241          * Sentinel for value initialized to {@code null} since {@code null} means uninitialized.
 242          */
 243         private static final String NULL_VALUE = "NULL";
 244 
 245         private final Class&lt;?&gt; type;
 246         @NativeImageReinitialize private Object value;
 247         private final Object defaultValue;
<span class="changed"> 248         private boolean isDefault;</span>
 249         private final String[] helpLines;
 250 
 251         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
 252             assert Character.isUpperCase(name().charAt(0)) : "Option name must start with upper-case letter: " + name();
 253             this.type = type;
 254             this.defaultValue = defaultValue;
 255             this.helpLines = helpLines;


 256         }
 257 
 258         @SuppressFBWarnings(value = "ES_COMPARING_STRINGS_WITH_EQ", justification = "sentinel must be String since it's a static final in an enum")
<span class="changed"> 259         private Object getValue() {</span>
<span class="changed"> 260             if (value == null) {</span>
<span class="changed"> 261                 String propertyValue = Services.getSavedProperty(getPropertyName());</span>
 262                 if (propertyValue == null) {
 263                     this.value = defaultValue == null ? NULL_VALUE : defaultValue;
 264                     this.isDefault = true;
 265                 } else {
 266                     if (type == Boolean.class) {
 267                         this.value = Boolean.parseBoolean(propertyValue);
 268                     } else if (type == String.class) {
 269                         this.value = propertyValue;
 270                     } else {
 271                         throw new JVMCIError("Unexpected option type " + type);
 272                     }
 273                     this.isDefault = false;
 274                 }
 275             }
<span class="changed"> 276             return value == NULL_VALUE ? null : value;</span>









 277         }
 278 
 279         /**
 280          * Gets the name of system property from which this option gets its value.
 281          */
 282         public String getPropertyName() {
 283             return JVMCI_OPTION_PROPERTY_PREFIX + name();
 284         }
 285 
 286         /**
 287          * Returns the option's value as boolean.
 288          *
 289          * @return option's value
 290          */
 291         public boolean getBoolean() {
 292             return (boolean) getValue();
 293         }
 294 
 295         /**
 296          * Returns the option's value as String.

</pre><hr></hr><pre>
 317                 if (value instanceof String) {
 318                     value = '"' + String.valueOf(value) + '"';
 319                 }
 320 
 321                 String name = option.getPropertyName();
 322                 String assign = option.isDefault ? "=" : ":=";
 323                 String typeName = option.type.getSimpleName();
 324                 String linePrefix = String.format("%s %s %s ", name, assign, value);
 325                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
 326                 int linePad = typeStartPos - linePrefix.length();
 327                 if (linePad &gt; 0) {
 328                     out.printf("%s%-" + linePad + "s[%s]%n", linePrefix, "", typeName);
 329                 } else {
 330                     out.printf("%s[%s]%n", linePrefix, typeName);
 331                 }
 332                 for (String line : option.helpLines) {
 333                     out.printf("%" + PROPERTY_HELP_INDENT + "s%s%n", "", line);
 334                 }
 335             }
 336         }























































 337     }
 338 
 339     private static HotSpotJVMCIBackendFactory findFactory(String architecture) {
 340         Iterable&lt;HotSpotJVMCIBackendFactory&gt; factories = getHotSpotJVMCIBackendFactories();
 341         assert factories != null : "sanity";
 342         for (HotSpotJVMCIBackendFactory factory : factories) {
 343             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
 344                 return factory;
 345             }
 346         }
 347 
 348         throw new JVMCIError("No JVMCI runtime available for the %s architecture", architecture);
 349     }
 350 
 351     private static volatile List&lt;HotSpotJVMCIBackendFactory&gt; cachedHotSpotJVMCIBackendFactories;
 352 
 353     @SuppressFBWarnings(value = "LI_LAZY_INIT_UPDATE_STATIC", justification = "not sure about this")
 354     private static Iterable&lt;HotSpotJVMCIBackendFactory&gt; getHotSpotJVMCIBackendFactories() {
 355         if (IS_IN_NATIVE_IMAGE || cachedHotSpotJVMCIBackendFactories != null) {
 356             return cachedHotSpotJVMCIBackendFactories;

</pre><hr></hr><pre>
 437 
 438     @SuppressWarnings("try")
 439     private HotSpotJVMCIRuntime() {
 440         compilerToVm = new CompilerToVM();
 441 
 442         try (InitTimer t = timer("HotSpotVMConfig&lt;init&gt;")) {
 443             configStore = new HotSpotVMConfigStore(compilerToVm);
 444             config = new HotSpotVMConfig(configStore);
 445         }
 446 
 447         reflection = IS_IN_NATIVE_IMAGE ? new SharedLibraryJVMCIReflection() : new HotSpotJDKReflection();
 448 
 449         PrintStream vmLogStream = null;
 450         if (IS_IN_NATIVE_IMAGE) {
 451             // Redirect System.out and System.err to HotSpot's TTY stream
 452             vmLogStream = new PrintStream(getLogStream());
 453             System.setOut(vmLogStream);
 454             System.setErr(vmLogStream);
 455         }
 456 



 457         String hostArchitecture = config.getHostArchitectureName();
 458 
 459         HotSpotJVMCIBackendFactory factory;
 460         try (InitTimer t = timer("find factory:", hostArchitecture)) {
 461             factory = findFactory(hostArchitecture);
 462         }
 463 
 464         try (InitTimer t = timer("create JVMCI backend:", hostArchitecture)) {
 465             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
 466         }
 467 
 468         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
 469         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
 470             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
 471             if (hsCompilerFactory.getCompilationLevelAdjustment() != None) {
 472                 String name = HotSpotJVMCICompilerFactory.class.getName();
 473                 String msg = String.format("%s.getCompilationLevelAdjustment() is no longer supported. " +
 474                                 "Use %s.excludeFromJVMCICompilation() instead.", name, name);
 475                 throw new UnsupportedOperationException(msg);
 476             }

</pre><hr></hr><pre>
 897      * import java.lang.reflect.Method;
 898      *
 899      * public static class JCompile {
 900      *     static {
 901      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
 902      *     }
 903      *     public static boolean compile(Method method, String[] options) {
 904      *         // Convert to simpler data types for passing/serializing across native interface
 905      *         long metaspaceMethodHandle = getHandle(method);
 906      *         char[] opts = convertToCharArray(options);
 907      *         return compile(metaspaceMethodHandle, opts);
 908      *     }
 909      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
 910      *
 911      *     private static long getHandle(Method method) { ... }
 912      *     private static char[] convertToCharArray(String[] a) { ... }
 913      * }
 914      * &lt;/pre&gt;
 915      *
 916      * The implementation of the native {@code JCompile.compile0} method would be in the JVMCI
<span class="changed"> 917      * shared library that contains the bulk of the JVMCI compiler. The {@code JCompile.compile0}</span>
<span class="changed"> 918      * implementation will be exported as the following JNI-compatible symbol:</span>
 919      *
 920      * &lt;pre&gt;
 921      * Java_com_jcompile_JCompile_compile0
 922      * &lt;/pre&gt;
 923      *
 924      * @see "https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names"
 925      * @see "https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#creating_the_vm"
 926      * @see "https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#invocation_api_functions"
 927      *
 928      *
<span class="changed"> 929      * @return an array of 4 longs where the first value is the {@code JavaVM*} value representing</span>
<span class="changed"> 930      *         the Java VM in the JVMCI shared library, and the remaining values are the first 3</span>
<span class="changed"> 931      *         pointers in the Invocation API function table (i.e., {@code JNIInvokeInterface})</span>









 932      * @throws NullPointerException if {@code clazz == null}
 933      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
 934      *             {@code -XX:-UseJVMCINativeLibrary})
 935      * @throws IllegalStateException if the current execution context is the JVMCI shared library
 936      * @throws IllegalArgumentException if {@code clazz} is {@link Class#isPrimitive()}
 937      * @throws UnsatisfiedLinkError if there's a problem linking a native method in {@code clazz}
 938      *             (no matching JNI symbol or the native method is already linked to a different
 939      *             address)
 940      */
 941     public long[] registerNativeMethods(Class&lt;?&gt; clazz) {
 942         return compilerToVm.registerNativeMethods(clazz);
 943     }
 944 
 945     /**
 946      * Creates or retrieves an object in the peer runtime that mirrors {@code obj}. The types whose
 947      * objects can be translated are:
 948      * &lt;ul&gt;
 949      * &lt;li&gt;{@link HotSpotResolvedJavaMethodImpl},&lt;/li&gt;
 950      * &lt;li&gt;{@link HotSpotResolvedObjectTypeImpl},&lt;/li&gt;
 951      * &lt;li&gt;{@link HotSpotResolvedPrimitiveType},&lt;/li&gt;

</pre><hr></hr><pre>
1000     }
1001 
1002     /**
1003      * Gets the address of the HotSpot {@code JavaThread} C++ object for the current thread. This
1004      * will return {@code 0} if called from an unattached JVMCI shared library thread.
1005      */
1006     public long getCurrentJavaThread() {
1007         return compilerToVm.getCurrentJavaThread();
1008     }
1009 
1010     /**
1011      * Ensures the current thread is attached to the peer runtime.
1012      *
1013      * @param asDaemon if the thread is not yet attached, should it be attached as a daemon
1014      * @return {@code true} if this call attached the current thread, {@code false} if the current
1015      *         thread was already attached
1016      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1017      *             {@code -XX:-UseJVMCINativeLibrary})
1018      * @throws IllegalStateException if the peer runtime has not been initialized or there is an
1019      *             error while trying to attach the thread


1020      */
1021     public boolean attachCurrentThread(boolean asDaemon) {
1022         return compilerToVm.attachCurrentThread(asDaemon);
1023     }
1024 
1025     /**
1026      * Detaches the current thread from the peer runtime.
1027      *
1028      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1029      *             {@code -XX:-UseJVMCINativeLibrary})
1030      * @throws IllegalStateException if the peer runtime has not been initialized or if the current
1031      *             thread is not attached or if there is an error while trying to detach the thread
1032      */
1033     public void detachCurrentThread() {
1034         compilerToVm.detachCurrentThread();
1035     }
1036 
1037     /**
1038      * Informs HotSpot that no method whose module is in {@code modules} is to be compiled
1039      * with {@link #compileMethod}.
</pre></td><td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.InitTimer.timer;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;
  27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  29 
  30 import java.io.IOException;
  31 import java.io.OutputStream;
  32 import java.io.PrintStream;
  33 import java.io.Serializable;
  34 import java.lang.invoke.CallSite;
  35 import java.lang.invoke.ConstantCallSite;
  36 import java.lang.invoke.MethodHandle;
  37 import java.lang.ref.WeakReference;
  38 import java.util.ArrayList;
  39 import java.util.Collections;
<span class="new">  40 import java.util.Formatter;</span>
  41 import java.util.HashMap;
  42 import java.util.List;
  43 import java.util.Map;
  44 import java.util.Objects;
  45 import java.util.ServiceLoader;
  46 import java.util.function.Predicate;
  47 
  48 import jdk.vm.ci.code.Architecture;
  49 import jdk.vm.ci.code.CompilationRequestResult;
  50 import jdk.vm.ci.code.CompiledCode;
  51 import jdk.vm.ci.code.InstalledCode;
  52 import jdk.vm.ci.common.InitTimer;
  53 import jdk.vm.ci.common.JVMCIError;
  54 import jdk.vm.ci.common.NativeImageReinitialize;
  55 import jdk.vm.ci.meta.JavaKind;
  56 import jdk.vm.ci.meta.JavaType;
  57 import jdk.vm.ci.meta.ResolvedJavaType;
  58 import jdk.vm.ci.meta.UnresolvedJavaType;
  59 import jdk.vm.ci.runtime.JVMCI;
  60 import jdk.vm.ci.runtime.JVMCIBackend;

</pre><hr></hr><pre>
 195         }
 196         return result;
 197     }
 198 
 199     @VMEntryPoint
 200     static Throwable decodeThrowable(String encodedThrowable) throws Throwable {
 201         return TranslatedException.decodeThrowable(encodedThrowable);
 202     }
 203 
 204     @VMEntryPoint
 205     static String encodeThrowable(Throwable throwable) throws Throwable {
 206         return TranslatedException.encodeThrowable(throwable);
 207     }
 208 
 209     @VMEntryPoint
 210     static String callToString(Object o) {
 211         return o.toString();
 212     }
 213 
 214     /**
<span class="new"> 215      * Set of recognized {@code "jvmci.*"} system properties. Entries not associated with an</span>
<span class="new"> 216      * {@link Option} have this object as their value.</span>
<span class="new"> 217      */</span>
<span class="new"> 218     static final Map&lt;String, Object&gt; options = new HashMap&lt;&gt;();</span>
<span class="new"> 219     static {</span>
<span class="new"> 220         options.put("jvmci.class.path.append", options);</span>
<span class="new"> 221     }</span>
<span class="new"> 222 </span>
<span class="new"> 223     /**</span>
 224      * A list of all supported JVMCI options.
 225      */
 226     public enum Option {
 227         // @formatter:off
 228         Compiler(String.class, null, "Selects the system compiler. This must match the getCompilerName() value returned " +
 229                 "by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. " +
 230                 "An empty string or the value \"null\" selects a compiler " +
 231                 "that will raise an exception upon receiving a compilation request."),
 232         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
 233         // so that -XX:+JVMCIPrintProperties shows the option.
 234         InitTimer(Boolean.class, false, "Specifies if initialization timing is enabled."),
 235         PrintConfig(Boolean.class, false, "Prints VM configuration available via JVMCI."),
 236         AuditHandles(Boolean.class, false, "Record stack trace along with scoped foreign object reference wrappers " +
 237                 "to debug issue with a wrapper being used after its scope has closed."),
 238         TraceMethodDataFilter(String.class, null,
 239                 "Enables tracing of profiling info when read by JVMCI.",
 240                 "Empty value: trace all methods",
 241                         "Non-empty value: trace methods whose fully qualified name contains the value."),
 242         UseProfilingInformation(Boolean.class, true, "");
 243         // @formatter:on
 244 
 245         /**
 246          * The prefix for system properties that are JVMCI options.
 247          */
 248         private static final String JVMCI_OPTION_PROPERTY_PREFIX = "jvmci.";
 249 
 250         /**
 251          * Sentinel for value initialized to {@code null} since {@code null} means uninitialized.
 252          */
 253         private static final String NULL_VALUE = "NULL";
 254 
 255         private final Class&lt;?&gt; type;
 256         @NativeImageReinitialize private Object value;
 257         private final Object defaultValue;
<span class="changed"> 258         private boolean isDefault = true;</span>
 259         private final String[] helpLines;
 260 
 261         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
 262             assert Character.isUpperCase(name().charAt(0)) : "Option name must start with upper-case letter: " + name();
 263             this.type = type;
 264             this.defaultValue = defaultValue;
 265             this.helpLines = helpLines;
<span class="new"> 266             Object existing = options.put(getPropertyName(), this);</span>
<span class="new"> 267             assert existing == null : getPropertyName();</span>
 268         }
 269 
 270         @SuppressFBWarnings(value = "ES_COMPARING_STRINGS_WITH_EQ", justification = "sentinel must be String since it's a static final in an enum")
<span class="changed"> 271         private void init(String propertyValue) {</span>
<span class="changed"> 272             assert value == null : "cannot re-initialize " + name();</span>

 273             if (propertyValue == null) {
 274                 this.value = defaultValue == null ? NULL_VALUE : defaultValue;
 275                 this.isDefault = true;
 276             } else {
 277                 if (type == Boolean.class) {
 278                     this.value = Boolean.parseBoolean(propertyValue);
 279                 } else if (type == String.class) {
 280                     this.value = propertyValue;
 281                 } else {
 282                     throw new JVMCIError("Unexpected option type " + type);
 283                 }
 284                 this.isDefault = false;
 285             }
 286         }
<span class="changed"> 287 </span>
<span class="changed"> 288         @SuppressFBWarnings(value = "ES_COMPARING_STRINGS_WITH_EQ", justification = "sentinel must be String since it's a static final in an enum")</span>
<span class="changed"> 289         private Object getValue() {</span>
<span class="changed"> 290             if (value == NULL_VALUE) {</span>
<span class="changed"> 291                 return null;</span>
<span class="changed"> 292             }</span>
<span class="changed"> 293             if (value == null) {</span>
<span class="changed"> 294                 return defaultValue;</span>
<span class="changed"> 295             }</span>
<span class="changed"> 296             return value;</span>
 297         }
 298 
 299         /**
 300          * Gets the name of system property from which this option gets its value.
 301          */
 302         public String getPropertyName() {
 303             return JVMCI_OPTION_PROPERTY_PREFIX + name();
 304         }
 305 
 306         /**
 307          * Returns the option's value as boolean.
 308          *
 309          * @return option's value
 310          */
 311         public boolean getBoolean() {
 312             return (boolean) getValue();
 313         }
 314 
 315         /**
 316          * Returns the option's value as String.

</pre><hr></hr><pre>
 337                 if (value instanceof String) {
 338                     value = '"' + String.valueOf(value) + '"';
 339                 }
 340 
 341                 String name = option.getPropertyName();
 342                 String assign = option.isDefault ? "=" : ":=";
 343                 String typeName = option.type.getSimpleName();
 344                 String linePrefix = String.format("%s %s %s ", name, assign, value);
 345                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
 346                 int linePad = typeStartPos - linePrefix.length();
 347                 if (linePad &gt; 0) {
 348                     out.printf("%s%-" + linePad + "s[%s]%n", linePrefix, "", typeName);
 349                 } else {
 350                     out.printf("%s[%s]%n", linePrefix, typeName);
 351                 }
 352                 for (String line : option.helpLines) {
 353                     out.printf("%" + PROPERTY_HELP_INDENT + "s%s%n", "", line);
 354                 }
 355             }
 356         }
<span class="new"> 357 </span>
<span class="new"> 358         /**</span>
<span class="new"> 359          * Compute string similarity based on Dice's coefficient.</span>
<span class="new"> 360          *</span>
<span class="new"> 361          * Ported from str_similar() in globals.cpp.</span>
<span class="new"> 362          */</span>
<span class="new"> 363         static float stringSimiliarity(String str1, String str2) {</span>
<span class="new"> 364             int hit = 0;</span>
<span class="new"> 365             for (int i = 0; i &lt; str1.length() - 1; ++i) {</span>
<span class="new"> 366                 for (int j = 0; j &lt; str2.length() - 1; ++j) {</span>
<span class="new"> 367                     if ((str1.charAt(i) == str2.charAt(j)) &amp;&amp; (str1.charAt(i + 1) == str2.charAt(j + 1))) {</span>
<span class="new"> 368                         ++hit;</span>
<span class="new"> 369                         break;</span>
<span class="new"> 370                     }</span>
<span class="new"> 371                 }</span>
<span class="new"> 372             }</span>
<span class="new"> 373             return 2.0f * hit / (str1.length() + str2.length());</span>
<span class="new"> 374         }</span>
<span class="new"> 375 </span>
<span class="new"> 376         private static final float FUZZY_MATCH_THRESHOLD = 0.7F;</span>
<span class="new"> 377 </span>
<span class="new"> 378         /**</span>
<span class="new"> 379          * Parses all system properties starting with {@value #JVMCI_OPTION_PROPERTY_PREFIX} and</span>
<span class="new"> 380          * initializes the options based on their values.</span>
<span class="new"> 381          */</span>
<span class="new"> 382         static void parse() {</span>
<span class="new"> 383             Map&lt;String, String&gt; savedProps = jdk.vm.ci.services.Services.getSavedProperties();</span>
<span class="new"> 384             for (Map.Entry&lt;String, String&gt; e : savedProps.entrySet()) {</span>
<span class="new"> 385                 String name = e.getKey();</span>
<span class="new"> 386                 if (name.startsWith(Option.JVMCI_OPTION_PROPERTY_PREFIX)) {</span>
<span class="new"> 387                     Object value = options.get(name);</span>
<span class="new"> 388                     if (value == null) {</span>
<span class="new"> 389                         List&lt;String&gt; matches = new ArrayList&lt;&gt;();</span>
<span class="new"> 390                         for (String pn : options.keySet()) {</span>
<span class="new"> 391                             float score = stringSimiliarity(pn, name);</span>
<span class="new"> 392                             if (score &gt;= FUZZY_MATCH_THRESHOLD) {</span>
<span class="new"> 393                                 matches.add(pn);</span>
<span class="new"> 394                             }</span>
<span class="new"> 395                         }</span>
<span class="new"> 396                         Formatter msg = new Formatter();</span>
<span class="new"> 397                         msg.format("Could not find option %s", name);</span>
<span class="new"> 398                         if (!matches.isEmpty()) {</span>
<span class="new"> 399                             msg.format("%nDid you mean one of the following?");</span>
<span class="new"> 400                             for (String match : matches) {</span>
<span class="new"> 401                                 msg.format("%n    %s=&lt;value&gt;", match);</span>
<span class="new"> 402                             }</span>
<span class="new"> 403                         }</span>
<span class="new"> 404                         throw new IllegalArgumentException(msg.toString());</span>
<span class="new"> 405                     } else if (value instanceof Option) {</span>
<span class="new"> 406                         Option option = (Option) value;</span>
<span class="new"> 407                         option.init(e.getValue());</span>
<span class="new"> 408                     }</span>
<span class="new"> 409                 }</span>
<span class="new"> 410             }</span>
<span class="new"> 411         }</span>
 412     }
 413 
 414     private static HotSpotJVMCIBackendFactory findFactory(String architecture) {
 415         Iterable&lt;HotSpotJVMCIBackendFactory&gt; factories = getHotSpotJVMCIBackendFactories();
 416         assert factories != null : "sanity";
 417         for (HotSpotJVMCIBackendFactory factory : factories) {
 418             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
 419                 return factory;
 420             }
 421         }
 422 
 423         throw new JVMCIError("No JVMCI runtime available for the %s architecture", architecture);
 424     }
 425 
 426     private static volatile List&lt;HotSpotJVMCIBackendFactory&gt; cachedHotSpotJVMCIBackendFactories;
 427 
 428     @SuppressFBWarnings(value = "LI_LAZY_INIT_UPDATE_STATIC", justification = "not sure about this")
 429     private static Iterable&lt;HotSpotJVMCIBackendFactory&gt; getHotSpotJVMCIBackendFactories() {
 430         if (IS_IN_NATIVE_IMAGE || cachedHotSpotJVMCIBackendFactories != null) {
 431             return cachedHotSpotJVMCIBackendFactories;

</pre><hr></hr><pre>
 512 
 513     @SuppressWarnings("try")
 514     private HotSpotJVMCIRuntime() {
 515         compilerToVm = new CompilerToVM();
 516 
 517         try (InitTimer t = timer("HotSpotVMConfig&lt;init&gt;")) {
 518             configStore = new HotSpotVMConfigStore(compilerToVm);
 519             config = new HotSpotVMConfig(configStore);
 520         }
 521 
 522         reflection = IS_IN_NATIVE_IMAGE ? new SharedLibraryJVMCIReflection() : new HotSpotJDKReflection();
 523 
 524         PrintStream vmLogStream = null;
 525         if (IS_IN_NATIVE_IMAGE) {
 526             // Redirect System.out and System.err to HotSpot's TTY stream
 527             vmLogStream = new PrintStream(getLogStream());
 528             System.setOut(vmLogStream);
 529             System.setErr(vmLogStream);
 530         }
 531 
<span class="new"> 532         // Initialize the Option values.</span>
<span class="new"> 533         Option.parse();</span>
<span class="new"> 534 </span>
 535         String hostArchitecture = config.getHostArchitectureName();
 536 
 537         HotSpotJVMCIBackendFactory factory;
 538         try (InitTimer t = timer("find factory:", hostArchitecture)) {
 539             factory = findFactory(hostArchitecture);
 540         }
 541 
 542         try (InitTimer t = timer("create JVMCI backend:", hostArchitecture)) {
 543             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
 544         }
 545 
 546         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
 547         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
 548             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
 549             if (hsCompilerFactory.getCompilationLevelAdjustment() != None) {
 550                 String name = HotSpotJVMCICompilerFactory.class.getName();
 551                 String msg = String.format("%s.getCompilationLevelAdjustment() is no longer supported. " +
 552                                 "Use %s.excludeFromJVMCICompilation() instead.", name, name);
 553                 throw new UnsupportedOperationException(msg);
 554             }

</pre><hr></hr><pre>
 975      * import java.lang.reflect.Method;
 976      *
 977      * public static class JCompile {
 978      *     static {
 979      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
 980      *     }
 981      *     public static boolean compile(Method method, String[] options) {
 982      *         // Convert to simpler data types for passing/serializing across native interface
 983      *         long metaspaceMethodHandle = getHandle(method);
 984      *         char[] opts = convertToCharArray(options);
 985      *         return compile(metaspaceMethodHandle, opts);
 986      *     }
 987      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
 988      *
 989      *     private static long getHandle(Method method) { ... }
 990      *     private static char[] convertToCharArray(String[] a) { ... }
 991      * }
 992      * &lt;/pre&gt;
 993      *
 994      * The implementation of the native {@code JCompile.compile0} method would be in the JVMCI
<span class="changed"> 995      * shared library that contains the JVMCI compiler. The {@code JCompile.compile0} implementation</span>
<span class="changed"> 996      * must be exported as the following JNI-compatible symbol:</span>
 997      *
 998      * &lt;pre&gt;
 999      * Java_com_jcompile_JCompile_compile0
1000      * &lt;/pre&gt;
1001      *
1002      * @see "https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names"
1003      * @see "https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#creating_the_vm"
1004      * @see "https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#invocation_api_functions"
1005      *
1006      *
<span class="changed">1007      * @return info about the Java VM in the JVMCI shared library {@code JavaVM*}. The info is</span>
<span class="changed">1008      *         encoded in a long array as follows:</span>
<span class="changed">1009      *</span>
<span class="changed">1010      *         &lt;pre&gt;</span>
<span class="changed">1011      *     long[] info = {</span>
<span class="changed">1012      *         javaVM, // the {@code JavaVM*} value</span>
<span class="changed">1013      *         javaVM-&gt;functions-&gt;reserved0,</span>
<span class="changed">1014      *         javaVM-&gt;functions-&gt;reserved1,</span>
<span class="changed">1015      *         javaVM-&gt;functions-&gt;reserved2</span>
<span class="changed">1016      *     }</span>
<span class="changed">1017      *         &lt;/pre&gt;</span>
<span class="changed">1018      *</span>
1019      * @throws NullPointerException if {@code clazz == null}
1020      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1021      *             {@code -XX:-UseJVMCINativeLibrary})
1022      * @throws IllegalStateException if the current execution context is the JVMCI shared library
1023      * @throws IllegalArgumentException if {@code clazz} is {@link Class#isPrimitive()}
1024      * @throws UnsatisfiedLinkError if there's a problem linking a native method in {@code clazz}
1025      *             (no matching JNI symbol or the native method is already linked to a different
1026      *             address)
1027      */
1028     public long[] registerNativeMethods(Class&lt;?&gt; clazz) {
1029         return compilerToVm.registerNativeMethods(clazz);
1030     }
1031 
1032     /**
1033      * Creates or retrieves an object in the peer runtime that mirrors {@code obj}. The types whose
1034      * objects can be translated are:
1035      * &lt;ul&gt;
1036      * &lt;li&gt;{@link HotSpotResolvedJavaMethodImpl},&lt;/li&gt;
1037      * &lt;li&gt;{@link HotSpotResolvedObjectTypeImpl},&lt;/li&gt;
1038      * &lt;li&gt;{@link HotSpotResolvedPrimitiveType},&lt;/li&gt;

</pre><hr></hr><pre>
1087     }
1088 
1089     /**
1090      * Gets the address of the HotSpot {@code JavaThread} C++ object for the current thread. This
1091      * will return {@code 0} if called from an unattached JVMCI shared library thread.
1092      */
1093     public long getCurrentJavaThread() {
1094         return compilerToVm.getCurrentJavaThread();
1095     }
1096 
1097     /**
1098      * Ensures the current thread is attached to the peer runtime.
1099      *
1100      * @param asDaemon if the thread is not yet attached, should it be attached as a daemon
1101      * @return {@code true} if this call attached the current thread, {@code false} if the current
1102      *         thread was already attached
1103      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1104      *             {@code -XX:-UseJVMCINativeLibrary})
1105      * @throws IllegalStateException if the peer runtime has not been initialized or there is an
1106      *             error while trying to attach the thread
<span class="new">1107      * @throws ArrayIndexOutOfBoundsException if {@code javaVMInfo} is non-null and is shorter than</span>
<span class="new">1108      *             the length of the array returned by {@link #registerNativeMethods}</span>
1109      */
1110     public boolean attachCurrentThread(boolean asDaemon) {
1111         return compilerToVm.attachCurrentThread(asDaemon);
1112     }
1113 
1114     /**
1115      * Detaches the current thread from the peer runtime.
1116      *
1117      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1118      *             {@code -XX:-UseJVMCINativeLibrary})
1119      * @throws IllegalStateException if the peer runtime has not been initialized or if the current
1120      *             thread is not attached or if there is an error while trying to detach the thread
1121      */
1122     public void detachCurrentThread() {
1123         compilerToVm.detachCurrentThread();
1124     }
1125 
1126     /**
1127      * Informs HotSpot that no method whose module is in {@code modules} is to be compiled
1128      * with {@link #compileMethod}.
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HandleCleaner.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/hotspot/share/jvmci/metadataHandleBlock.cpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
