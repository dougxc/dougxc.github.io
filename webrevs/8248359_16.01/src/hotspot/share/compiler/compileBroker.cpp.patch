--- old/src/hotspot/share/compiler/compileBroker.cpp	2020-06-29 10:28:15.000000000 +0200
+++ new/src/hotspot/share/compiler/compileBroker.cpp	2020-06-29 10:28:15.000000000 +0200
@@ -1201,7 +1201,7 @@
       // Don't allow blocking compilation requests if we are in JVMCIRuntime::shutdown
       // to avoid deadlock between compiler thread(s) and threads run at shutdown
       // such as the DestroyJavaVM thread.
-      if (JVMCI::shutdown_called()) {
+      if (JVMCI::in_shutdown()) {
         blocking = false;
       }
     }
@@ -2150,16 +2150,22 @@
     TraceTime t1("compilation", &time);
     EventCompilation event;
     JVMCICompileState compile_state(task);
+    JVMCIRuntime *runtime = NULL;
 
-    // Skip redefined methods
-    if (compile_state.target_method_is_old()) {
+    if (JVMCI::in_shutdown()) {
+      failure_reason = "in JVMCI shutdown";
+      retry_message = "not retryable";
+      compilable = ciEnv::MethodCompilable_never;
+    } else if (compile_state.target_method_is_old()) {
+      // Skip redefined methods
       failure_reason = "redefined method";
       retry_message = "not retryable";
       compilable = ciEnv::MethodCompilable_never;
     } else {
       JVMCIEnv env(thread, &compile_state, __FILE__, __LINE__);
       methodHandle method(thread, target_handle);
-      env.runtime()->compile_method(&env, jvmci, method, osr_bci);
+      runtime = env.runtime();
+      runtime->compile_method(&env, jvmci, method, osr_bci);
 
       failure_reason = compile_state.failure_reason();
       failure_reason_on_C_heap = compile_state.failure_reason_on_C_heap();
