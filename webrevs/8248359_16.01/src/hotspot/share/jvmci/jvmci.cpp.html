<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/jvmci/jvmci.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/systemDictionary.hpp"
  26 #include "gc/shared/collectedHeap.hpp"
  27 #include "jvmci/jvmci.hpp"
  28 #include "jvmci/jvmciJavaClasses.hpp"
  29 #include "jvmci/jvmciRuntime.hpp"
  30 #include "jvmci/metadataHandles.hpp"
  31 #include "memory/resourceArea.hpp"
  32 #include "memory/universe.hpp"
  33 
  34 JVMCIRuntime* JVMCI::_compiler_runtime = NULL;
  35 JVMCIRuntime* JVMCI::_java_runtime = NULL;
  36 volatile bool JVMCI::_is_initialized = false;
  37 void* JVMCI::_shared_library_handle = NULL;
  38 char* JVMCI::_shared_library_path = NULL;
  39 volatile bool JVMCI::_in_shutdown = false;
  40 
  41 void jvmci_vmStructs_init() NOT_DEBUG_RETURN;
  42 
  43 bool JVMCI::can_initialize_JVMCI() {
  44   // Initializing JVMCI requires the module system to be initialized past phase 3.
  45   // The JVMCI API itself isn't available until phase 2 and ServiceLoader (which
  46   // JVMCI initialization requires) isn't usable until after phase 3. Testing
  47   // whether the system loader is initialized satisfies all these invariants.
  48   if (SystemDictionary::java_system_loader() == NULL) {
  49     return false;
  50   }
  51   assert(Universe::is_module_initialized(), "must be");
  52   return true;
  53 }
  54 
  55 void* JVMCI::get_shared_library(char*&amp; path, bool load) {
  56   void* sl_handle = _shared_library_handle;
  57   if (sl_handle != NULL || !load) {
  58     path = _shared_library_path;
  59     return sl_handle;
  60   }
  61   assert(JVMCI_lock-&gt;owner() == Thread::current(), "must be");
  62   path = NULL;
  63   if (_shared_library_handle == NULL) {
  64     char path[JVM_MAXPATHLEN];
  65     char ebuf[1024];
  66     if (JVMCILibPath != NULL) {
  67       if (!os::dll_locate_lib(path, sizeof(path), JVMCILibPath, JVMCI_SHARED_LIBRARY_NAME)) {
  68         vm_exit_during_initialization("Unable to locate JVMCI shared library in path specified by -XX:JVMCILibPath value", JVMCILibPath);
  69       }
  70     } else {
  71       if (!os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {
  72         vm_exit_during_initialization("Unable to create path to JVMCI shared library");
  73       }
  74     }
  75 
  76     void* handle = os::dll_load(path, ebuf, sizeof ebuf);
  77     if (handle == NULL) {
  78       vm_exit_during_initialization("Unable to load JVMCI shared library", ebuf);
  79     }
  80     _shared_library_handle = handle;
  81     _shared_library_path = strdup(path);
  82 
  83     TRACE_jvmci_1("loaded JVMCI shared library from %s", path);
  84   }
  85   path = _shared_library_path;
  86   return _shared_library_handle;
  87 }
  88 
  89 void JVMCI::initialize_compiler(TRAPS) {
  90   if (JVMCILibDumpJNIConfig) {
  91     JNIJVMCI::initialize_ids(NULL);
  92     ShouldNotReachHere();
  93   }
  94 
  95   JVMCI::compiler_runtime()-&gt;call_getCompiler(CHECK);
  96 }
  97 
  98 void JVMCI::initialize_globals() {
  99   jvmci_vmStructs_init();
 100   if (UseJVMCINativeLibrary) {
 101     // There are two runtimes.
 102     _compiler_runtime = new JVMCIRuntime(0);
 103     _java_runtime = new JVMCIRuntime(-1);
 104   } else {
 105     // There is only a single runtime
 106     _java_runtime = _compiler_runtime = new JVMCIRuntime(0);
 107   }
 108 }
 109 
 110 
 111 void JVMCI::metadata_do(void f(Metadata*)) {
 112   if (_java_runtime != NULL) {
 113     _java_runtime-&gt;_metadata_handles-&gt;metadata_do(f);
 114   }
 115   if (_compiler_runtime != NULL &amp;&amp; _compiler_runtime != _java_runtime) {
 116     _compiler_runtime-&gt;_metadata_handles-&gt;metadata_do(f);
 117   }
 118 }
 119 
 120 void JVMCI::do_unloading(bool unloading_occurred) {
 121   if (unloading_occurred) {
 122     if (_java_runtime != NULL) {
 123       _java_runtime-&gt;_metadata_handles-&gt;do_unloading();
 124     }
 125     if (_compiler_runtime != NULL &amp;&amp; _compiler_runtime != _java_runtime) {
 126       _compiler_runtime-&gt;_metadata_handles-&gt;do_unloading();
 127     }
 128   }
 129 }
 130 
 131 bool JVMCI::is_compiler_initialized() {
 132   return _is_initialized;
 133 }
 134 
 135 void JVMCI::shutdown() {
 136   ResourceMark rm;
 137   {
 138     MutexLocker locker(JVMCI_lock);
 139     _in_shutdown = true;
 140     TRACE_jvmci_1("shutting down JVMCI");
 141   }
 142   JVMCIRuntime* java_runtime = _java_runtime;
 143   if (java_runtime != compiler_runtime()) {
 144     java_runtime-&gt;shutdown();
 145   }
 146   if (compiler_runtime() != NULL) {
 147     compiler_runtime()-&gt;shutdown();
 148   }
 149 }
 150 
 151 bool JVMCI::in_shutdown() {
 152   return _in_shutdown;
 153 }
</pre></body></html>
