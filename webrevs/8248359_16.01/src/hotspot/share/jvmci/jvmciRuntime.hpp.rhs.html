<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #ifndef SHARE_JVMCI_JVMCIRUNTIME_HPP
  25 #define SHARE_JVMCI_JVMCIRUNTIME_HPP
  26 
  27 #include "code/nmethod.hpp"
  28 #include "jvmci/jvmci.hpp"
  29 #include "jvmci/jvmciExceptions.hpp"
  30 #include "jvmci/jvmciObject.hpp"
<a name="1" id="anc1"></a><span class="new">  31 #include "utilities/linkedlist.hpp"</span>
  32 
  33 class JVMCIEnv;
  34 class JVMCICompiler;
  35 class JVMCICompileState;
<a name="2" id="anc2"></a><span class="new">  36 class MetadataHandles;</span>
  37 
  38 // Encapsulates the JVMCI metadata for an nmethod.
  39 // JVMCINMethodData objects are inlined into nmethods
  40 // at nmethod::_jvmci_data_offset.
  41 class JVMCINMethodData {
  42   // Index for the HotSpotNmethod mirror in the nmethod's oops table.
  43   // This is -1 if there is no mirror in the oops table.
  44   int _nmethod_mirror_index;
  45 
  46   // Is HotSpotNmethod.name non-null? If so, the value is
  47   // embedded in the end of this object.
  48   bool _has_name;
  49 
  50   // Address of the failed speculations list to which a speculation
  51   // is appended when it causes a deoptimization.
  52   FailedSpeculation** _failed_speculations;
  53 
  54 public:
  55   // Computes the size of a JVMCINMethodData object
  56   static int compute_size(const char* nmethod_mirror_name) {
  57     int size = sizeof(JVMCINMethodData);
  58     if (nmethod_mirror_name != NULL) {
  59       size += (int) strlen(nmethod_mirror_name) + 1;
  60     }
  61     return size;
  62   }
  63 
  64   void initialize(int nmethod_mirror_index,
  65              const char* name,
  66              FailedSpeculation** failed_speculations);
  67 
  68   // Adds `speculation` to the failed speculations list.
  69   void add_failed_speculation(nmethod* nm, jlong speculation);
  70 
  71   // Gets the JVMCI name of the nmethod (which may be NULL).
  72   const char* name() { return _has_name ? (char*)(((address) this) + sizeof(JVMCINMethodData)) : NULL; }
  73 
  74   // Clears the HotSpotNmethod.address field in the  mirror. If nm
  75   // is dead, the HotSpotNmethod.entryPoint field is also cleared.
  76   void invalidate_nmethod_mirror(nmethod* nm);
  77 
  78   // Gets the mirror from nm's oops table.
  79   oop get_nmethod_mirror(nmethod* nm, bool phantom_ref);
  80 
  81   // Sets the mirror in nm's oops table.
  82   void set_nmethod_mirror(nmethod* nm, oop mirror);
  83 
  84   // Clears the mirror in nm's oops table.
  85   void clear_nmethod_mirror(nmethod* nm);
  86 };
  87 
  88 // A top level class that represents an initialized JVMCI runtime.
  89 // There is one instance of this class per HotSpotJVMCIRuntime object.
  90 class JVMCIRuntime: public CHeapObj&lt;mtJVMCI&gt; {
<a name="3" id="anc3"></a><span class="new">  91   friend class JVMCI;</span>
  92  public:
  93   // Constants describing whether JVMCI wants to be able to adjust the compilation
  94   // level selected for a method by the VM compilation policy and if so, based on
  95   // what information about the method being schedule for compilation.
  96   enum CompLevelAdjustment {
  97      none = 0,             // no adjustment
  98      by_holder = 1,        // adjust based on declaring class of method
  99      by_full_signature = 2 // adjust based on declaring class, name and signature of method
 100   };
 101 
 102  private:
<a name="4" id="anc4"></a><span class="changed"> 103 </span>
<span class="changed"> 104   enum InitState {</span>
<span class="changed"> 105     uninitialized,</span>
<span class="changed"> 106     being_initialized,</span>
<span class="changed"> 107     fully_initialized</span>
<span class="changed"> 108   };</span>
<span class="changed"> 109 </span>
<span class="changed"> 110   // Initialization state of this JVMCIRuntime.</span>
<span class="changed"> 111   InitState _init_state;</span>
 112 
 113   JVMCIObject _HotSpotJVMCIRuntime_instance;
 114 
<a name="5" id="anc5"></a><span class="changed"> 115   // Result of calling JNI_CreateJavaVM in the JVMCI shared library.</span>
<span class="changed"> 116   // Must only be modified under JVMCI_lock.</span>
<span class="changed"> 117   volatile JavaVM* _shared_library_javavm;</span>
<span class="changed"> 118 </span>
<span class="changed"> 119   // The HotSpot heap based runtime will have an id of -1 and the</span>
<span class="changed"> 120   // JVMCI shared library runtime will have an id of 0.</span>
<span class="changed"> 121   int _id;</span>
<span class="changed"> 122 </span>
<span class="changed"> 123   // Handles to Metadata objects.</span>
<span class="changed"> 124   MetadataHandles* _metadata_handles;</span>
 125 
 126   JVMCIObject create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS);
 127 
 128   // Implementation methods for loading and constant pool access.
 129   static Klass* get_klass_by_name_impl(Klass*&amp; accessing_klass,
 130                                        const constantPoolHandle&amp; cpool,
 131                                        Symbol* klass_name,
 132                                        bool require_local);
 133   static Klass*   get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
 134                                           int klass_index,
 135                                           bool&amp; is_accessible,
 136                                           Klass* loading_klass);
 137   static void   get_field_by_index_impl(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,
 138                                         int field_index);
 139   static Method*  get_method_by_index_impl(const constantPoolHandle&amp; cpool,
 140                                            int method_index, Bytecodes::Code bc,
 141                                            InstanceKlass* loading_klass);
 142 
 143   // Helper methods
 144   static bool       check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass);
 145   static Method*    lookup_method(InstanceKlass*  accessor,
 146                                   Klass*  holder,
 147                                   Symbol*         name,
 148                                   Symbol*         sig,
 149                                   Bytecodes::Code bc,
 150                                   constantTag     tag);
 151 
 152  public:
<a name="6" id="anc6"></a><span class="changed"> 153   JVMCIRuntime(int id);</span>
<span class="changed"> 154 </span>
<span class="changed"> 155   int id() const        { return _id;   }</span>
<span class="changed"> 156 </span>
<span class="changed"> 157   // Ensures that a JVMCI shared library JavaVM exists for this runtime.</span>
<span class="changed"> 158   // If the JavaVM was created by this call, then the thread-local JNI</span>
<span class="changed"> 159   // interface pointer for the JavaVM is returned otherwise NULL is returned.</span>
<span class="changed"> 160   JNIEnv* init_shared_library_javavm();</span>
<span class="changed"> 161 </span>
<span class="changed"> 162   // Determines if the JVMCI shared library JavaVM exists for this runtime.</span>
<span class="changed"> 163   bool has_shared_library_javavm() { return _shared_library_javavm != NULL; }</span>
<span class="changed"> 164 </span>
<span class="changed"> 165   // Copies info about the JVMCI shared library JavaVM associated with this</span>
<span class="changed"> 166   // runtime into `info` as follows:</span>
<span class="changed"> 167   // {</span>
<span class="changed"> 168   //     javaVM, // the {@code JavaVM*} value</span>
<span class="changed"> 169   //     javaVM-&gt;functions-&gt;reserved0,</span>
<span class="changed"> 170   //     javaVM-&gt;functions-&gt;reserved1,</span>
<span class="changed"> 171   //     javaVM-&gt;functions-&gt;reserved2</span>
<span class="changed"> 172   // }</span>
<span class="changed"> 173   void init_JavaVM_info(jlongArray info, JVMCI_TRAPS);</span>
<span class="changed"> 174 </span>
<span class="changed"> 175   // Wrappers for calling Invocation Interface functions on the</span>
<span class="changed"> 176   // JVMCI shared library JavaVM associated with this runtime.</span>
<span class="changed"> 177   // These wrappers ensure all required thread state transitions are performed.</span>
<span class="changed"> 178   jint AttachCurrentThread(JavaThread* thread, void **penv, void *args);</span>
<span class="changed"> 179   jint AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args);</span>
<span class="changed"> 180   jint DetachCurrentThread(JavaThread* thread);</span>
<span class="changed"> 181   jint GetEnv(JavaThread* thread, void **penv, jint version);</span>
 182 
<a name="7" id="anc7"></a><span class="changed"> 183   // Compute offsets and construct any state required before executing JVMCI code.</span>


 184   void initialize(JVMCIEnv* jvmciEnv);
 185 
<a name="8" id="anc8"></a><span class="changed"> 186   // Allocation and management of JNI global object handles.</span>
<span class="changed"> 187   jobject make_global(const Handle&amp; obj);</span>
<span class="changed"> 188   void destroy_global(jobject handle);</span>
<span class="changed"> 189   bool is_global_handle(jobject handle);</span>
<span class="changed"> 190 </span>
<span class="changed"> 191   // Allocation and management of metadata handles.</span>
<span class="changed"> 192   jmetadata allocate_handle(const methodHandle&amp; handle);</span>
<span class="changed"> 193   jmetadata allocate_handle(const constantPoolHandle&amp; handle);</span>
<span class="changed"> 194   void release_handle(jmetadata handle);</span>
<span class="changed"> 195 </span>
<span class="changed"> 196   // Gets the HotSpotJVMCIRuntime instance for this runtime,</span>
<span class="changed"> 197   // initializing it first if necessary.</span>
 198   JVMCIObject get_HotSpotJVMCIRuntime(JVMCI_TRAPS);
 199 
 200   bool is_HotSpotJVMCIRuntime_initialized() {
 201     return _HotSpotJVMCIRuntime_instance.is_non_null();
 202   }
 203 
<a name="9" id="anc9"></a><span class="changed"> 204   // Gets the current HotSpotJVMCIRuntime instance for this runtime which</span>
<span class="changed"> 205   // may be a "null" JVMCIObject value.</span>
<span class="changed"> 206   JVMCIObject probe_HotSpotJVMCIRuntime() {</span>
<span class="changed"> 207     return _HotSpotJVMCIRuntime_instance;</span>
<span class="changed"> 208   }</span>
<span class="changed"> 209 </span>
<span class="changed"> 210   // Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()</span>
 211   void initialize_JVMCI(JVMCI_TRAPS);
 212 
<a name="10" id="anc10"></a><span class="changed"> 213   // Explicitly initialize HotSpotJVMCIRuntime itself</span>


 214   void initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS);
 215 
 216   void call_getCompiler(TRAPS);
 217 
<a name="11" id="anc11"></a><span class="new"> 218   // Shuts down this runtime by calling HotSpotJVMCIRuntime.shutdown().</span>
 219   void shutdown();
 220 
<a name="12" id="anc12"></a>



 221   void bootstrap_finished(TRAPS);
 222 
 223   // Look up a klass by name from a particular class loader (the accessor's).
 224   // If require_local, result must be defined in that class loader, or NULL.
 225   // If !require_local, a result from remote class loader may be reported,
 226   // if sufficient class loader constraints exist such that initiating
 227   // a class loading request from the given loader is bound to return
 228   // the class defined in the remote loader (or throw an error).
 229   //
 230   // Return an unloaded klass if !require_local and no class at all is found.
 231   //
 232   // The CI treats a klass as loaded if it is consistently defined in
 233   // another loader, even if it hasn't yet been loaded in all loaders
 234   // that could potentially see it via delegation.
 235   static Klass* get_klass_by_name(Klass* accessing_klass,
 236                                   Symbol* klass_name,
 237                                   bool require_local);
 238 
 239   // Constant pool access.
 240   static Klass*   get_klass_by_index(const constantPoolHandle&amp; cpool,
 241                                      int klass_index,
 242                                      bool&amp; is_accessible,
 243                                      Klass* loading_klass);
 244   static void   get_field_by_index(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,
 245                                    int field_index);
 246   static Method*  get_method_by_index(const constantPoolHandle&amp; cpool,
 247                                       int method_index, Bytecodes::Code bc,
 248                                       InstanceKlass* loading_klass);
 249 
 250   // converts the Klass* representing the holder of a method into a
 251   // InstanceKlass*.  This is needed since the holder of a method in
 252   // the bytecodes could be an array type.  Basically this converts
 253   // array types into java/lang/Object and other types stay as they are.
 254   static InstanceKlass* get_instance_klass_for_declared_method_holder(Klass* klass);
 255 
 256   // Helper routine for determining the validity of a compilation
 257   // with respect to concurrent class loading.
 258   static JVMCI::CodeInstallResult validate_compile_task_dependencies(Dependencies* target, JVMCICompileState* task, char** failure_detail);
 259 
 260   // Compiles `target` with the JVMCI compiler.
 261   void compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; target, int entry_bci);
 262 
 263   // Register the result of a compilation.
 264   JVMCI::CodeInstallResult register_method(JVMCIEnv* JVMCIENV,
 265                        const methodHandle&amp;       target,
 266                        nmethod*&amp;                 nm,
 267                        int                       entry_bci,
 268                        CodeOffsets*              offsets,
 269                        int                       orig_pc_offset,
 270                        CodeBuffer*               code_buffer,
 271                        int                       frame_words,
 272                        OopMapSet*                oop_map_set,
 273                        ExceptionHandlerTable*    handler_table,
 274                        ImplicitExceptionTable*   implicit_exception_table,
 275                        AbstractCompiler*         compiler,
 276                        DebugInformationRecorder* debug_info,
 277                        Dependencies*             dependencies,
 278                        int                       compile_id,
 279                        bool                      has_unsafe_access,
 280                        bool                      has_wide_vector,
 281                        JVMCIObject               compiled_code,
 282                        JVMCIObject               nmethod_mirror,
 283                        FailedSpeculation**       failed_speculations,
 284                        char*                     speculations,
 285                        int                       speculations_len);
 286 
<a name="13" id="anc13"></a><span class="changed"> 287   // Exits the VM due to an unexpected exception.</span>


 288   static void exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message);
 289 
 290   static void describe_pending_hotspot_exception(JavaThread* THREAD, bool clear);
 291 
 292 #define CHECK_EXIT THREAD); \
 293   if (HAS_PENDING_EXCEPTION) { \
 294     char buf[256]; \
 295     jio_snprintf(buf, 256, "Uncaught exception at %s:%d", __FILE__, __LINE__); \
 296     JVMCIRuntime::exit_on_pending_exception(NULL, buf); \
 297     return; \
 298   } \
 299   (void)(0
 300 
 301 #define CHECK_EXIT_(v) THREAD);                 \
 302   if (HAS_PENDING_EXCEPTION) { \
 303     char buf[256]; \
 304     jio_snprintf(buf, 256, "Uncaught exception at %s:%d", __FILE__, __LINE__); \
 305     JVMCIRuntime::exit_on_pending_exception(NULL, buf); \
 306     return v; \
 307   } \
 308   (void)(0
 309 
 310 #define JVMCI_CHECK_EXIT JVMCIENV); \
 311   if (JVMCIENV-&gt;has_pending_exception()) {      \
 312     char buf[256]; \
 313     jio_snprintf(buf, 256, "Uncaught exception at %s:%d", __FILE__, __LINE__); \
 314     JVMCIRuntime::exit_on_pending_exception(JVMCIENV, buf); \
 315     return; \
 316   } \
 317   (void)(0
 318 
 319 #define JVMCI_CHECK_EXIT_(result) JVMCIENV); \
 320   if (JVMCIENV-&gt;has_pending_exception()) {      \
 321     char buf[256]; \
 322     jio_snprintf(buf, 256, "Uncaught exception at %s:%d", __FILE__, __LINE__); \
 323     JVMCIRuntime::exit_on_pending_exception(JVMCIENV, buf); \
 324     return result; \
 325   } \
 326   (void)(0
 327 
 328   static BasicType kindToBasicType(const Handle&amp; kind, TRAPS);
 329 
 330   static void new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail);
 331   static void new_array_common(JavaThread* thread, Klass* klass, jint length, bool null_on_fail);
 332   static void new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail);
 333   static void dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail);
 334   static void dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail);
 335 
 336   // The following routines are called from compiled JVMCI code
 337 
 338   // When allocation fails, these stubs:
 339   // 1. Exercise -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError handling and also
 340   //    post a JVMTI_EVENT_RESOURCE_EXHAUSTED event if the failure is an OutOfMemroyError
 341   // 2. Return NULL with a pending exception.
 342   // Compiled code must ensure these stubs are not called twice for the same allocation
 343   // site due to the non-repeatable side effects in the case of OOME.
 344   static void new_instance(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, false); }
 345   static void new_array(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, false); }
 346   static void new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, false); }
 347   static void dynamic_new_array(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, false); }
 348   static void dynamic_new_instance(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, false); }
 349 
 350   // When allocation fails, these stubs return NULL and have no pending exception. Compiled code
 351   // can use these stubs if a failed allocation will be retried (e.g., by deoptimizing and
 352   // re-executing in the interpreter).
 353   static void new_instance_or_null(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, true); }
 354   static void new_array_or_null(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, true); }
 355   static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, true); }
 356   static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, true); }
 357   static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, true); }
 358 
 359   static void vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3);
 360   static jint identity_hash_code(JavaThread* thread, oopDesc* obj);
 361   static address exception_handler_for_pc(JavaThread* thread);
 362   static void monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock);
 363   static void monitorexit (JavaThread* thread, oopDesc* obj, BasicLock* lock);
 364   static jboolean object_notify(JavaThread* thread, oopDesc* obj);
 365   static jboolean object_notifyAll(JavaThread* thread, oopDesc* obj);
 366   static void vm_error(JavaThread* thread, jlong where, jlong format, jlong value);
 367   static oopDesc* load_and_clear_exception(JavaThread* thread);
 368   static void log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3);
 369   static void log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline);
 370   // Print the passed in object, optionally followed by a newline.  If
 371   // as_string is true and the object is a java.lang.String then it
 372   // printed as a string, otherwise the type of the object is printed
 373   // followed by its address.
 374   static void log_object(JavaThread* thread, oopDesc* object, bool as_string, bool newline);
 375 #if INCLUDE_G1GC
 376   static void write_barrier_pre(JavaThread* thread, oopDesc* obj);
 377   static void write_barrier_post(JavaThread* thread, void* card);
 378 #endif
 379   static jboolean validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child);
 380 
 381   // used to throw exceptions from compiled JVMCI code
 382   static int throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message);
 383   // helper methods to throw exception with complex messages
 384   static int throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass);
 385   static int throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);
 386 
 387   // Test only function
 388   static jint test_deoptimize_call_int(JavaThread* thread, int value);
<a name="14" id="anc14"></a><span class="new"> 389 </span>
<span class="new"> 390   // Emits the following on tty:</span>
<span class="new"> 391   //   "JVMCITrace-" &lt;level&gt; "[" &lt;current thread name&gt; "]:" &lt;padding of width `level`&gt;</span>
<span class="new"> 392   // Returns true.</span>
<span class="new"> 393   static bool trace_prefix(int level);</span>
 394 };
 395 
 396 // Tracing macros.
 397 
 398 #define IF_TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1)) ; else
 399 #define IF_TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2)) ; else
 400 #define IF_TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3)) ; else
 401 #define IF_TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4)) ; else
 402 #define IF_TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5)) ; else
 403 
<a name="15" id="anc15"></a><span class="changed"> 404 #define TRACE_jvmci_(n) if (!(JVMCITraceLevel &gt;= n &amp;&amp; JVMCIRuntime::trace_prefix(n))) ; else tty-&gt;print_cr</span>
<span class="changed"> 405 #define TRACE_jvmci_1 TRACE_jvmci_(1)</span>
<span class="changed"> 406 #define TRACE_jvmci_2 TRACE_jvmci_(2)</span>
<span class="changed"> 407 #define TRACE_jvmci_3 TRACE_jvmci_(3)</span>
<span class="changed"> 408 #define TRACE_jvmci_4 TRACE_jvmci_(4)</span>
<span class="changed"> 409 #define TRACE_jvmci_5 TRACE_jvmci_(5)</span>
 410 
 411 #endif // SHARE_JVMCI_JVMCIRUNTIME_HPP
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="16" type="hidden" /></form></body></html>
