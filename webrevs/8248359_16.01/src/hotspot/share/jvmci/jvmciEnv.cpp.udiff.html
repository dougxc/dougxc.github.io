<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>open Udiff src/hotspot/share/jvmci/jvmciEnv.cpp</title>

<style type="text/css" media="screen">
span.new {
    color: blue;
    font-weight: normal;
}
</style>

</head>
<body id="SUNWwebrev">
<center><a href='../../../../src/hotspot/share/jvmci/jvmciCompilerToVM.cpp.udiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/jvmci/jvmciEnv.hpp.udiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/jvmci/jvmciEnv.cpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre></pre>
        <pre>
</pre><hr /><pre>
<span class="newmarker">@@ -75,14 +75,10 @@</span>
     return true;
   }
   return false;
 }
 
<span class="removed">-JavaVM* JVMCIEnv::_shared_library_javavm = NULL;</span>
<span class="removed">-void* JVMCIEnv::_shared_library_handle = NULL;</span>
<span class="removed">-char* JVMCIEnv::_shared_library_path = NULL;</span>
<span class="removed">-</span>
 void JVMCIEnv::copy_saved_properties() {
   assert(!is_hotspot(), "can only copy saved properties from HotSpot to native image");
 
   JavaThread* THREAD = JavaThread::current();
 
</pre><hr /><pre>
<span class="newmarker">@@ -129,79 +125,26 @@</span>
   }
 
   // Initialize saved properties in shared library
   jclass servicesClass = JNIJVMCI::Services::clazz();
   jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();
<span class="removed">-  JNIAccessMark jni(this);</span>
<span class="new">+  JNIAccessMark jni(this, THREAD);</span>
   jni()-&gt;CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());
   if (jni()-&gt;ExceptionCheck()) {
     jni()-&gt;ExceptionDescribe();
     fatal("Error calling jdk.vm.ci.services.Services.initializeSavedProperties");
   }
 }
 
<span class="removed">-JNIEnv* JVMCIEnv::init_shared_library(JavaThread* thread) {</span>
<span class="removed">-  if (_shared_library_javavm == NULL) {</span>
<span class="removed">-    MutexLocker locker(JVMCI_lock);</span>
<span class="removed">-    if (_shared_library_javavm == NULL) {</span>
<span class="removed">-      char path[JVM_MAXPATHLEN];</span>
<span class="removed">-      char ebuf[1024];</span>
<span class="removed">-      if (JVMCILibPath != NULL) {</span>
<span class="removed">-        if (!os::dll_locate_lib(path, sizeof(path), JVMCILibPath, JVMCI_SHARED_LIBRARY_NAME)) {</span>
<span class="removed">-          vm_exit_during_initialization("Unable to create JVMCI shared library path from -XX:JVMCILibPath value", JVMCILibPath);</span>
<span class="removed">-        }</span>
<span class="removed">-      } else {</span>
<span class="removed">-        if (!os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {</span>
<span class="removed">-          vm_exit_during_initialization("Unable to create path to JVMCI shared library");</span>
<span class="removed">-        }</span>
<span class="removed">-      }</span>
<span class="removed">-</span>
<span class="removed">-      void* handle = os::dll_load(path, ebuf, sizeof ebuf);</span>
<span class="removed">-      if (handle == NULL) {</span>
<span class="removed">-        vm_exit_during_initialization("Unable to load JVMCI shared library", ebuf);</span>
<span class="removed">-      }</span>
<span class="removed">-      _shared_library_handle = handle;</span>
<span class="removed">-      _shared_library_path = strdup(path);</span>
<span class="removed">-      jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);</span>
<span class="removed">-      typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);</span>
<span class="removed">-</span>
<span class="removed">-      JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(handle, "JNI_CreateJavaVM"));</span>
<span class="removed">-      JNIEnv* env;</span>
<span class="removed">-      if (JNI_CreateJavaVM == NULL) {</span>
<span class="removed">-        vm_exit_during_initialization("Unable to find JNI_CreateJavaVM", path);</span>
<span class="removed">-      }</span>
<span class="removed">-</span>
<span class="removed">-      ResourceMark rm;</span>
<span class="removed">-      JavaVMInitArgs vm_args;</span>
<span class="removed">-      vm_args.version = JNI_VERSION_1_2;</span>
<span class="removed">-      vm_args.ignoreUnrecognized = JNI_TRUE;</span>
<span class="removed">-      vm_args.options = NULL;</span>
<span class="removed">-      vm_args.nOptions = 0;</span>
<span class="removed">-</span>
<span class="removed">-      JavaVM* the_javavm = NULL;</span>
<span class="removed">-      int result = (*JNI_CreateJavaVM)(&amp;the_javavm, (void**) &amp;env, &amp;vm_args);</span>
<span class="removed">-      if (result == JNI_OK) {</span>
<span class="removed">-        guarantee(env != NULL, "missing env");</span>
<span class="removed">-        _shared_library_javavm = the_javavm;</span>
<span class="removed">-        return env;</span>
<span class="removed">-      } else {</span>
<span class="removed">-        vm_exit_during_initialization(err_msg("JNI_CreateJavaVM failed with return value %d", result), path);</span>
<span class="removed">-      }</span>
<span class="removed">-    }</span>
<span class="removed">-  }</span>
<span class="removed">-  return NULL;</span>
<span class="removed">-}</span>
<span class="removed">-</span>
 void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {
   assert(thread != NULL, "npe");
<span class="removed">-  // By default there is only one runtime which is the compiler runtime.</span>
<span class="removed">-  _runtime = JVMCI::compiler_runtime();</span>
   _env = NULL;
   _pop_frame_on_close = false;
   _detach_on_close = false;
   if (!UseJVMCINativeLibrary) {
     // In HotSpot mode, JNI isn't used at all.
<span class="new">+    _runtime = JVMCI::java_runtime();</span>
     _is_hotspot = true;
     return;
   }
 
   if (parent_env != NULL) {
</pre><hr /><pre>
<span class="newmarker">@@ -211,24 +154,28 @@</span>
     if (_is_hotspot) {
       // Select the Java runtime
       _runtime = JVMCI::java_runtime();
       return;
     }
<span class="new">+    _runtime = JVMCI::compiler_runtime();</span>
<span class="new">+    assert(_runtime != NULL, "npe");</span>
     _env = parent_env;
     return;
   }
 
   // Running in JVMCI shared library mode so ensure the shared library
   // is loaded and initialized and get a shared library JNIEnv
   _is_hotspot = false;
<span class="removed">-  _env = init_shared_library(thread);</span>
<span class="new">+</span>
<span class="new">+  _runtime = JVMCI::compiler_runtime();</span>
<span class="new">+  _env = _runtime-&gt;init_shared_library_javavm();</span>
 
   if (_env != NULL) {
     // Creating the JVMCI shared library VM also attaches the current thread
     _detach_on_close = true;
   } else {
<span class="removed">-    _shared_library_javavm-&gt;GetEnv((void**)&amp;parent_env, JNI_VERSION_1_2);</span>
<span class="new">+    _runtime-&gt;GetEnv(thread, (void**)&amp;parent_env, JNI_VERSION_1_2);</span>
     if (parent_env != NULL) {
       // Even though there's a parent JNI env, there's no guarantee
       // it was opened by a JVMCIEnv scope and thus may not have
       // pushed a local JNI frame. As such, we use a new JNI local
       // frame in this scope to ensure local JNI refs are collected
</pre><hr /><pre>
<span class="newmarker">@@ -238,21 +185,21 @@</span>
       ResourceMark rm; // Thread name is resource allocated
       JavaVMAttachArgs attach_args;
       attach_args.version = JNI_VERSION_1_2;
       attach_args.name = thread-&gt;name();
       attach_args.group = NULL;
<span class="removed">-      if (_shared_library_javavm-&gt;AttachCurrentThread((void**)&amp;_env, &amp;attach_args) != JNI_OK) {</span>
<span class="new">+      if (_runtime-&gt;AttachCurrentThread(thread, (void**) &amp;_env, &amp;attach_args) != JNI_OK) {</span>
         fatal("Error attaching current thread (%s) to JVMCI shared library JNI interface", attach_args.name);
       }
       _detach_on_close = true;
     }
   }
 
   assert(_env != NULL, "missing env");
   assert(_throw_to_caller == false, "must be");
 
<span class="removed">-  JNIAccessMark jni(this);</span>
<span class="new">+  JNIAccessMark jni(this, thread);</span>
   jint result = _env-&gt;PushLocalFrame(32);
   if (result != JNI_OK) {
     char message[256];
     jio_snprintf(message, 256, "Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d", _file, _line);
     JVMCIRuntime::exit_on_pending_exception(this, message);
</pre><hr /><pre>
<span class="newmarker">@@ -292,21 +239,21 @@</span>
   }
 }
 
 // Prints a pending exception (if any) and its stack trace.
 void JVMCIEnv::describe_pending_exception(bool clear) {
<span class="new">+  Thread* THREAD = Thread::current();</span>
   if (!is_hotspot()) {
     JNIAccessMark jni(this);
     if (jni()-&gt;ExceptionCheck()) {
       jthrowable ex = !clear ? jni()-&gt;ExceptionOccurred() : NULL;
       jni()-&gt;ExceptionDescribe();
       if (ex != NULL) {
         jni()-&gt;Throw(ex);
       }
     }
   } else {
<span class="removed">-    Thread* THREAD = Thread::current();</span>
     if (HAS_PENDING_EXCEPTION) {
       JVMCIRuntime::describe_pending_hotspot_exception((JavaThread*) THREAD, clear);
     }
   }
 }
</pre><hr /><pre>
<span class="newmarker">@@ -330,11 +277,11 @@</span>
   oop encoded_throwable_string = (oop) result.get_jobject();
 
   ResourceMark rm;
   const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);
 
<span class="removed">-  JNIAccessMark jni(this);</span>
<span class="new">+  JNIAccessMark jni(this, THREAD);</span>
   jobject jni_encoded_throwable_string = jni()-&gt;NewStringUTF(encoded_throwable_chars);
   jthrowable jni_throwable = (jthrowable) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
                                 JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),
                                 jni_encoded_throwable_string);
   jni()-&gt;Throw(jni_throwable);
</pre><hr /><pre>
<span class="newmarker">@@ -366,11 +313,11 @@</span>
       jio_snprintf(message, 256, "Uncaught exception exiting JVMCIEnv scope entered at %s:%d", _file, _line);
       JVMCIRuntime::exit_on_pending_exception(this, message);
     }
 
     if (_detach_on_close) {
<span class="removed">-      get_shared_library_javavm()-&gt;DetachCurrentThread();</span>
<span class="new">+      _runtime-&gt;DetachCurrentThread(JavaThread::current());</span>
     }
   }
 }
 
 jboolean JVMCIEnv::has_pending_exception() {
</pre><hr /><pre>
<span class="newmarker">@@ -601,16 +548,16 @@</span>
     case T_DOUBLE:
       break;
     default:
       JVMCI_THROW_MSG_(IllegalArgumentException, "Only boxes for primitive values can be created", JVMCIObject());
   }
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     oop box = java_lang_boxing_object::create(type, value, CHECK_(JVMCIObject()));
     return HotSpotJVMCI::wrap(box);
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject box = jni()-&gt;NewObjectA(JNIJVMCI::box_class(type), JNIJVMCI::box_constructor(type), value);
     assert(box != NULL, "");
     return wrap(box);
   }
 }
</pre><hr /><pre>
<span class="newmarker">@@ -670,17 +617,17 @@</span>
   va_start(ap, format);
   char msg[max_msg_size];
   vsnprintf(msg, max_msg_size, format, ap);
   msg[max_msg_size-1] = '\0';
   va_end(ap);
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     Handle h_loader = Handle();
     Handle h_protection_domain = Handle();
     Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jni()-&gt;ThrowNew(JNIJVMCI::JVMCIError::clazz(), msg);
   }
 }
 
 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_compileMethod (JVMCIObject runtime, JVMCIObject method, int entry_bci,
</pre><hr /><pre>
<span class="newmarker">@@ -733,11 +680,11 @@</span>
     JavaCallArguments jargs;
     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
     JavaValue result(T_VOID);
     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &amp;jargs, THREAD);
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::shutdown_method());
   }
   if (has_pending_exception()) {
     // This should never happen as HotSpotJVMCIRuntime.shutdown() should
     // handle all exceptions.
</pre><hr /><pre>
<span class="newmarker">@@ -751,11 +698,11 @@</span>
     JavaCallArguments jargs;
     JavaValue result(T_OBJECT);
     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::runtime_name(), vmSymbols::runtime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::runtime_method());
     if (jni()-&gt;ExceptionCheck()) {
       return JVMCIObject();
     }
     return wrap(result);
</pre><hr /><pre>
<span class="newmarker">@@ -768,11 +715,11 @@</span>
     JavaCallArguments jargs;
     JavaValue result(T_OBJECT);
     JavaCalls::call_static(&amp;result, HotSpotJVMCI::JVMCI::klass(), vmSymbols::getRuntime_name(), vmSymbols::getRuntime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JVMCI::clazz(), JNIJVMCI::JVMCI::getRuntime_method());
     if (jni()-&gt;ExceptionCheck()) {
       return JVMCIObject();
     }
     return wrap(result);
</pre><hr /><pre>
<span class="newmarker">@@ -786,11 +733,11 @@</span>
     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
     JavaValue result(T_OBJECT);
     JavaCalls::call_virtual(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::getCompiler_name(), vmSymbols::getCompiler_signature(), &amp;jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject result = jni()-&gt;CallObjectMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::getCompiler_method());
     if (jni()-&gt;ExceptionCheck()) {
       return JVMCIObject();
     }
     return wrap(result);
</pre><hr /><pre>
<span class="newmarker">@@ -808,11 +755,11 @@</span>
                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
                            vmSymbols::callToString_name(),
                            vmSymbols::callToString_signature(), &amp;jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
                                                      JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),
                                                      object.as_jobject());
     if (jni()-&gt;ExceptionCheck()) {
       return JVMCIObject();
</pre><hr /><pre>
<span class="newmarker">@@ -833,11 +780,11 @@</span>
                            HotSpotJVMCI::PrimitiveConstant::klass(),
                            vmSymbols::forTypeChar_name(),
                            vmSymbols::forTypeChar_signature(), &amp;jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),
                                                      JNIJVMCI::PrimitiveConstant::forTypeChar_method(),
                                                      kind, value);
     if (jni()-&gt;ExceptionCheck()) {
       return JVMCIObject();
</pre><hr /><pre>
<span class="newmarker">@@ -856,11 +803,11 @@</span>
                            HotSpotJVMCI::JavaConstant::klass(),
                            vmSymbols::forFloat_name(),
                            vmSymbols::forFloat_signature(), &amp;jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
                                                      JNIJVMCI::JavaConstant::forFloat_method(),
                                                      value);
     if (jni()-&gt;ExceptionCheck()) {
       return JVMCIObject();
</pre><hr /><pre>
<span class="newmarker">@@ -879,11 +826,11 @@</span>
                            HotSpotJVMCI::JavaConstant::klass(),
                            vmSymbols::forDouble_name(),
                            vmSymbols::forDouble_signature(), &amp;jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
                                                      JNIJVMCI::JavaConstant::forDouble_method(),
                                                      value);
     if (jni()-&gt;ExceptionCheck()) {
       return JVMCIObject();
</pre><hr /><pre>
<span class="newmarker">@@ -924,11 +871,11 @@</span>
       HotSpotJVMCI::StackTraceElement::set_fileName(this, obj(), file_name);
     }
     HotSpotJVMCI::StackTraceElement::set_lineNumber(this, obj(), line_number);
     return wrap(obj());
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject declaring_class = jni()-&gt;NewStringUTF(declaring_class_str);
     if (jni()-&gt;ExceptionCheck()) {
       return JVMCIObject();
     }
     jobject method_name = jni()-&gt;NewStringUTF(method_name_sym-&gt;as_C_string());
</pre><hr /><pre>
<span class="newmarker">@@ -976,11 +923,11 @@</span>
                             vmSymbols::object_initializer_name(),
                             vmSymbols::method_string_bool_long_signature(),
                             &amp;jargs, CHECK_(JVMCIObject()));
     return wrap(obj_h());
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject nameStr = name == NULL ? NULL : jni()-&gt;NewStringUTF(name);
     if (jni()-&gt;ExceptionCheck()) {
       return JVMCIObject();
     }
 
</pre><hr /><pre>
<span class="newmarker">@@ -1013,22 +960,10 @@</span>
     JNIAccessMark jni(this);
     return wrap(jni()-&gt;NewGlobalRef(object.as_jobject()));
   }
 }
 
<span class="removed">-JVMCIObject JVMCIEnv::make_weak(JVMCIObject object) {</span>
<span class="removed">-  if (object.is_null()) {</span>
<span class="removed">-    return JVMCIObject();</span>
<span class="removed">-  }</span>
<span class="removed">-  if (is_hotspot()) {</span>
<span class="removed">-    return wrap(JNIHandles::make_weak_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));</span>
<span class="removed">-  } else {</span>
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="removed">-    return wrap(jni()-&gt;NewWeakGlobalRef(object.as_jobject()));</span>
<span class="removed">-  }</span>
<span class="removed">-}</span>
<span class="removed">-</span>
 void JVMCIEnv::destroy_local(JVMCIObject object) {
   if (is_hotspot()) {
     JNIHandles::destroy_local(object.as_jobject());
   } else {
     JNIAccessMark jni(this);
</pre><hr /><pre>
<span class="newmarker">@@ -1043,19 +978,10 @@</span>
     JNIAccessMark jni(this);
     jni()-&gt;DeleteGlobalRef(object.as_jobject());
   }
 }
 
<span class="removed">-void JVMCIEnv::destroy_weak(JVMCIObject object) {</span>
<span class="removed">-  if (is_hotspot()) {</span>
<span class="removed">-    JNIHandles::destroy_weak_global(object.as_jweak());</span>
<span class="removed">-  } else {</span>
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="removed">-    jni()-&gt;DeleteWeakGlobalRef(object.as_jweak());</span>
<span class="removed">-  }</span>
<span class="removed">-}</span>
<span class="removed">-</span>
 const char* JVMCIEnv::klass_name(JVMCIObject object) {
   if (is_hotspot()) {
     return HotSpotJVMCI::resolve(object)-&gt;klass()-&gt;signature_name();
   } else {
     JVMCIObject name;
</pre><hr /><pre>
<span class="newmarker">@@ -1074,11 +1000,11 @@</span>
   if (method() == NULL) {
     return method_object;
   }
 
   Thread* THREAD = Thread::current();
<span class="removed">-  jmetadata handle = JVMCI::allocate_handle(method);</span>
<span class="new">+  jmetadata handle = _runtime-&gt;allocate_handle(method);</span>
   jboolean exception = false;
   if (is_hotspot()) {
     JavaValue result(T_OBJECT);
     JavaCallArguments args;
     args.push_long((jlong) handle);
</pre><hr /><pre>
<span class="newmarker">@@ -1097,17 +1023,17 @@</span>
                                                                   (jlong) handle));
     exception = jni()-&gt;ExceptionCheck();
   }
 
   if (exception) {
<span class="removed">-    JVMCI::release_handle(handle);</span>
<span class="new">+    _runtime-&gt;release_handle(handle);</span>
     return JVMCIObject();
   }
 
   assert(asMethod(method_object) == method(), "must be");
   if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {
<span class="removed">-    JVMCI::release_handle(handle);</span>
<span class="new">+    _runtime-&gt;release_handle(handle);</span>
   }
   assert(!method_object.is_null(), "must be");
   return method_object;
 }
 
</pre><hr /><pre>
<span class="newmarker">@@ -1135,11 +1061,11 @@</span>
       exception = true;
     } else {
       type = wrap((oop)result.get_jobject());
     }
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
 
     HandleMark hm(THREAD);
     type = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedObjectTypeImpl::clazz(),
                                                         JNIJVMCI::HotSpotResolvedObjectTypeImpl_fromMetaspace_method(),
                                                         pointer, signature.as_jstring()));
</pre><hr /><pre>
<span class="newmarker">@@ -1153,14 +1079,14 @@</span>
   return type;
 }
 
 JVMCIObject JVMCIEnv::get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS) {
   JVMCIObject cp_object;
<span class="removed">-  jmetadata handle = JVMCI::allocate_handle(cp);</span>
<span class="new">+  jmetadata handle = _runtime-&gt;allocate_handle(cp);</span>
   jboolean exception = false;
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     JavaValue result(T_OBJECT);
     JavaCallArguments args;
     args.push_long((jlong) handle);
     JavaCalls::call_static(&amp;result,
                            HotSpotJVMCI::HotSpotConstantPool::klass(),
</pre><hr /><pre>
<span class="newmarker">@@ -1170,139 +1096,139 @@</span>
       exception = true;
     } else {
       cp_object = wrap((oop)result.get_jobject());
     }
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     cp_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotConstantPool::clazz(),
                                                              JNIJVMCI::HotSpotConstantPool_fromMetaspace_method(),
                                                              (jlong) handle));
     exception = jni()-&gt;ExceptionCheck();
   }
 
   if (exception) {
<span class="removed">-    JVMCI::release_handle(handle);</span>
<span class="new">+    _runtime-&gt;release_handle(handle);</span>
     return JVMCIObject();
   }
 
   assert(!cp_object.is_null(), "must be");
   // Constant pools aren't cached so this is always a newly created object using the handle
   assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, "must use same handle");
   return cp_object;
 }
 
 JVMCIPrimitiveArray JVMCIEnv::new_booleanArray(int length, JVMCI_TRAPS) {
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     typeArrayOop result = oopFactory::new_boolArray(length, CHECK_(JVMCIObject()));
     return wrap(result);
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jbooleanArray result = jni()-&gt;NewBooleanArray(length);
     return wrap(result);
   }
 }
 
 JVMCIPrimitiveArray JVMCIEnv::new_byteArray(int length, JVMCI_TRAPS) {
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     typeArrayOop result = oopFactory::new_byteArray(length, CHECK_(JVMCIObject()));
     return wrap(result);
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jbyteArray result = jni()-&gt;NewByteArray(length);
     return wrap(result);
   }
 }
 
 JVMCIObjectArray JVMCIEnv::new_byte_array_array(int length, JVMCI_TRAPS) {
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())-&gt;array_klass(CHECK_(JVMCIObject()));
     objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) -&gt;allocate(length, CHECK_(JVMCIObject()));
     return wrap(result);
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::byte_array(), NULL);
     return wrap(result);
   }
 }
 
 JVMCIPrimitiveArray JVMCIEnv::new_intArray(int length, JVMCI_TRAPS) {
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     typeArrayOop result = oopFactory::new_intArray(length, CHECK_(JVMCIObject()));
     return wrap(result);
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jintArray result = jni()-&gt;NewIntArray(length);
     return wrap(result);
   }
 }
 
 JVMCIPrimitiveArray JVMCIEnv::new_longArray(int length, JVMCI_TRAPS) {
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     typeArrayOop result = oopFactory::new_longArray(length, CHECK_(JVMCIObject()));
     return wrap(result);
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jlongArray result = jni()-&gt;NewLongArray(length);
     return wrap(result);
   }
 }
 
 JVMCIObject JVMCIEnv::new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS) {
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     HotSpotJVMCI::VMField::klass()-&gt;initialize(CHECK_(JVMCIObject()));
     oop obj = HotSpotJVMCI::VMField::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
     HotSpotJVMCI::VMField::set_name(this, obj, HotSpotJVMCI::resolve(name));
     HotSpotJVMCI::VMField::set_type(this, obj, HotSpotJVMCI::resolve(type));
     HotSpotJVMCI::VMField::set_offset(this, obj, offset);
     HotSpotJVMCI::VMField::set_address(this, obj, address);
     HotSpotJVMCI::VMField::set_value(this, obj, HotSpotJVMCI::resolve(value));
     return wrap(obj);
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMField::clazz(),
                                     JNIJVMCI::VMField::constructor(),
                                     get_jobject(name), get_jobject(type), offset, address, get_jobject(value));
     return wrap(result);
   }
 }
 
 JVMCIObject JVMCIEnv::new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS) {
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     HotSpotJVMCI::VMFlag::klass()-&gt;initialize(CHECK_(JVMCIObject()));
     oop obj = HotSpotJVMCI::VMFlag::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
     HotSpotJVMCI::VMFlag::set_name(this, obj, HotSpotJVMCI::resolve(name));
     HotSpotJVMCI::VMFlag::set_type(this, obj, HotSpotJVMCI::resolve(type));
     HotSpotJVMCI::VMFlag::set_value(this, obj, HotSpotJVMCI::resolve(value));
     return wrap(obj);
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMFlag::clazz(),
                                     JNIJVMCI::VMFlag::constructor(),
                                     get_jobject(name), get_jobject(type), get_jobject(value));
     return wrap(result);
   }
 }
 
 JVMCIObject JVMCIEnv::new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS) {
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;initialize(CHECK_(JVMCIObject()));
     oop obj = HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
     HotSpotJVMCI::VMIntrinsicMethod::set_declaringClass(this, obj, HotSpotJVMCI::resolve(declaringClass));
     HotSpotJVMCI::VMIntrinsicMethod::set_name(this, obj, HotSpotJVMCI::resolve(name));
     HotSpotJVMCI::VMIntrinsicMethod::set_descriptor(this, obj, HotSpotJVMCI::resolve(descriptor));
     HotSpotJVMCI::VMIntrinsicMethod::set_id(this, obj, id);
     return wrap(obj);
   } else {
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMIntrinsicMethod::clazz(),
                                     JNIJVMCI::VMIntrinsicMethod::constructor(),
                                     get_jobject(declaringClass), get_jobject(name), get_jobject(descriptor), id);
     return wrap(result);
   }
</pre><hr /><pre>
<span class="newmarker">@@ -1344,11 +1270,11 @@</span>
     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::set_object(this, constant, obj());
     HotSpotJVMCI::HotSpotObjectConstantImpl::set_compressed(this, constant, compressed);
     return wrap(constant);
   } else {
     jlong handle = make_handle(obj);
<span class="removed">-    JNIAccessMark jni(this);</span>
<span class="new">+    JNIAccessMark jni(this, THREAD);</span>
     jobject result = jni()-&gt;NewObject(JNIJVMCI::IndirectHotSpotObjectConstantImpl::clazz(),
                                       JNIJVMCI::IndirectHotSpotObjectConstantImpl::constructor(),
                                       handle, compressed, dont_register);
     return wrap(result);
   }
</pre><hr /><pre>
<span class="newmarker">@@ -1383,11 +1309,11 @@</span>
   return JVMCIObject::create(object, is_hotspot());
 }
 
 jlong JVMCIEnv::make_handle(const Handle&amp; obj) {
   assert(!obj.is_null(), "should only create handle for non-NULL oops");
<span class="removed">-  jobject handle = JVMCI::make_global(obj);</span>
<span class="new">+  jobject handle = _runtime-&gt;make_global(obj);</span>
   return (jlong) handle;
 }
 
 oop JVMCIEnv::resolve_handle(jlong objectHandle) {
   assert(objectHandle != 0, "should be a valid handle");
</pre><hr /><pre>
<span class="newmarker">@@ -1397,19 +1323,19 @@</span>
   }
   return obj;
 }
 
 JVMCIObject JVMCIEnv::create_string(const char* str, JVMCI_TRAPS) {
<span class="removed">-  if (is_hotspot()) {</span>
     JavaThread* THREAD = JavaThread::current();
<span class="new">+  if (is_hotspot()) {</span>
     Handle result = java_lang_String::create_from_str(str, CHECK_(JVMCIObject()));
     return HotSpotJVMCI::wrap(result());
   } else {
     jobject result;
     jboolean exception = false;
     {
<span class="removed">-      JNIAccessMark jni(this);</span>
<span class="new">+      JNIAccessMark jni(this, THREAD);</span>
       result = jni()-&gt;NewStringUTF(str);
       exception = jni()-&gt;ExceptionCheck();
     }
     return wrap(result);
   }
</pre>
<center><a href='../../../../src/hotspot/share/jvmci/jvmciCompilerToVM.cpp.udiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/jvmci/jvmciEnv.hpp.udiff.html' target='_top'>next &gt</a></center>
</body></html>

