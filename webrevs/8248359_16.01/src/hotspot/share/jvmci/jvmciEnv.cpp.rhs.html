<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-59942">59942</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8248359">8248359</a>: [JVMCI] miscellaneous code cleanups and improvements</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "classfile/stringTable.hpp"
  27 #include "classfile/symbolTable.hpp"
  28 #include "code/codeCache.hpp"
  29 #include "compiler/compileTask.hpp"
  30 #include "memory/oopFactory.hpp"
  31 #include "memory/resourceArea.hpp"
  32 #include "memory/universe.hpp"
  33 #include "oops/objArrayKlass.hpp"
  34 #include "oops/typeArrayOop.inline.hpp"
  35 #include "runtime/deoptimization.hpp"
  36 #include "runtime/jniHandles.inline.hpp"
  37 #include "runtime/javaCalls.hpp"
  38 #include "jvmci/jniAccessMark.inline.hpp"
  39 #include "jvmci/jvmciRuntime.hpp"
  40 
  41 JVMCICompileState::JVMCICompileState(CompileTask* task):
  42   _task(task),
  43   _retryable(true),
  44   _failure_reason(NULL),
  45   _failure_reason_on_C_heap(false) {
  46   // Get Jvmti capabilities under lock to get consistent values.
  47   MutexLocker mu(JvmtiThreadState_lock);
  48   _jvmti_redefinition_count             = JvmtiExport::redefinition_count();
  49   _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint() ? 1 : 0;
  50   _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables() ? 1 : 0;
  51   _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions() ? 1 : 0;
  52   _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame() ? 1 : 0;
  53   _target_method_is_old                 = _task != NULL &amp;&amp; _task-&gt;method()-&gt;is_old();
  54 }
  55 
  56 bool JVMCICompileState::jvmti_state_changed() const {
  57   // Some classes were redefined
  58   if (jvmti_redefinition_count() != JvmtiExport::redefinition_count()) {
  59     return true;
  60   }
  61   if (!jvmti_can_access_local_variables() &amp;&amp;
  62       JvmtiExport::can_access_local_variables()) {
  63     return true;
  64   }
  65   if (!jvmti_can_hotswap_or_post_breakpoint() &amp;&amp;
  66       JvmtiExport::can_hotswap_or_post_breakpoint()) {
  67     return true;
  68   }
  69   if (!jvmti_can_post_on_exceptions() &amp;&amp;
  70       JvmtiExport::can_post_on_exceptions()) {
  71     return true;
  72   }
  73   if (!jvmti_can_pop_frame() &amp;&amp;
  74       JvmtiExport::can_pop_frame()) {
  75     return true;
  76   }
  77   return false;
  78 }
  79 
<a name="1" id="anc1"></a>



  80 void JVMCIEnv::copy_saved_properties() {
  81   assert(!is_hotspot(), "can only copy saved properties from HotSpot to native image");
  82 
  83   JavaThread* THREAD = JavaThread::current();
  84 
  85   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_services_Services(), Handle(), Handle(), true, THREAD);
  86   if (HAS_PENDING_EXCEPTION) {
  87     JVMCIRuntime::exit_on_pending_exception(NULL, "Error initializing jdk.vm.ci.services.Services");
  88   }
  89   InstanceKlass* ik = InstanceKlass::cast(k);
  90   if (ik-&gt;should_be_initialized()) {
  91     ik-&gt;initialize(THREAD);
  92     if (HAS_PENDING_EXCEPTION) {
  93       JVMCIRuntime::exit_on_pending_exception(NULL, "Error initializing jdk.vm.ci.services.Services");
  94     }
  95   }
  96 
  97   // Get the serialized saved properties from HotSpot
  98   TempNewSymbol serializeSavedProperties = SymbolTable::new_symbol("serializeSavedProperties");
  99   JavaValue result(T_OBJECT);
 100   JavaCallArguments args;
 101   JavaCalls::call_static(&amp;result, ik, serializeSavedProperties, vmSymbols::serializePropertiesToByteArray_signature(), &amp;args, THREAD);
 102   if (HAS_PENDING_EXCEPTION) {
 103     JVMCIRuntime::exit_on_pending_exception(NULL, "Error calling jdk.vm.ci.services.Services.serializeSavedProperties");
 104   }
 105   oop res = (oop) result.get_jobject();
 106   assert(res-&gt;is_typeArray(), "must be");
 107   assert(TypeArrayKlass::cast(res-&gt;klass())-&gt;element_type() == T_BYTE, "must be");
 108   typeArrayOop ba = typeArrayOop(res);
 109   int serialized_properties_len = ba-&gt;length();
 110 
 111   // Copy serialized saved properties from HotSpot object into native buffer
 112   jbyte* serialized_properties = NEW_RESOURCE_ARRAY(jbyte, serialized_properties_len);
 113   memcpy(serialized_properties, ba-&gt;byte_at_addr(0), serialized_properties_len);
 114 
 115   // Copy native buffer into shared library object
 116   JVMCIPrimitiveArray buf = new_byteArray(serialized_properties_len, this);
 117   if (has_pending_exception()) {
 118     describe_pending_exception(true);
 119     fatal("Error in copy_saved_properties");
 120   }
 121   copy_bytes_from(serialized_properties, buf, 0, serialized_properties_len);
 122   if (has_pending_exception()) {
 123     describe_pending_exception(true);
 124     fatal("Error in copy_saved_properties");
 125   }
 126 
 127   // Initialize saved properties in shared library
 128   jclass servicesClass = JNIJVMCI::Services::clazz();
 129   jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();
<a name="2" id="anc2"></a><span class="changed"> 130   JNIAccessMark jni(this, THREAD);</span>
 131   jni()-&gt;CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());
 132   if (jni()-&gt;ExceptionCheck()) {
 133     jni()-&gt;ExceptionDescribe();
 134     fatal("Error calling jdk.vm.ci.services.Services.initializeSavedProperties");
 135   }
 136 }
 137 
<a name="3" id="anc3"></a>



















































 138 void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {
 139   assert(thread != NULL, "npe");
<a name="4" id="anc4"></a>

 140   _env = NULL;
 141   _pop_frame_on_close = false;
 142   _detach_on_close = false;
 143   if (!UseJVMCINativeLibrary) {
 144     // In HotSpot mode, JNI isn't used at all.
<a name="5" id="anc5"></a><span class="new"> 145     _runtime = JVMCI::java_runtime();</span>
 146     _is_hotspot = true;
 147     return;
 148   }
 149 
 150   if (parent_env != NULL) {
 151     // If the parent JNI environment is non-null then figure out whether it
 152     // is a HotSpot or shared library JNIEnv and set the state appropriately.
 153     _is_hotspot = thread-&gt;jni_environment() == parent_env;
 154     if (_is_hotspot) {
 155       // Select the Java runtime
 156       _runtime = JVMCI::java_runtime();
 157       return;
 158     }
<a name="6" id="anc6"></a><span class="new"> 159     _runtime = JVMCI::compiler_runtime();</span>
<span class="new"> 160     assert(_runtime != NULL, "npe");</span>
 161     _env = parent_env;
 162     return;
 163   }
 164 
 165   // Running in JVMCI shared library mode so ensure the shared library
 166   // is loaded and initialized and get a shared library JNIEnv
 167   _is_hotspot = false;
<a name="7" id="anc7"></a><span class="changed"> 168 </span>
<span class="changed"> 169   _runtime = JVMCI::compiler_runtime();</span>
<span class="changed"> 170   _env = _runtime-&gt;init_shared_library_javavm();</span>
 171 
 172   if (_env != NULL) {
 173     // Creating the JVMCI shared library VM also attaches the current thread
 174     _detach_on_close = true;
 175   } else {
<a name="8" id="anc8"></a><span class="changed"> 176     _runtime-&gt;GetEnv(thread, (void**)&amp;parent_env, JNI_VERSION_1_2);</span>
 177     if (parent_env != NULL) {
 178       // Even though there's a parent JNI env, there's no guarantee
 179       // it was opened by a JVMCIEnv scope and thus may not have
 180       // pushed a local JNI frame. As such, we use a new JNI local
 181       // frame in this scope to ensure local JNI refs are collected
 182       // in a timely manner after leaving this scope.
 183       _env = parent_env;
 184     } else {
 185       ResourceMark rm; // Thread name is resource allocated
 186       JavaVMAttachArgs attach_args;
 187       attach_args.version = JNI_VERSION_1_2;
 188       attach_args.name = thread-&gt;name();
 189       attach_args.group = NULL;
<a name="9" id="anc9"></a><span class="changed"> 190       if (_runtime-&gt;AttachCurrentThread(thread, (void**) &amp;_env, &amp;attach_args) != JNI_OK) {</span>
 191         fatal("Error attaching current thread (%s) to JVMCI shared library JNI interface", attach_args.name);
 192       }
 193       _detach_on_close = true;
 194     }
 195   }
 196 
 197   assert(_env != NULL, "missing env");
 198   assert(_throw_to_caller == false, "must be");
 199 
<a name="10" id="anc10"></a><span class="changed"> 200   JNIAccessMark jni(this, thread);</span>
 201   jint result = _env-&gt;PushLocalFrame(32);
 202   if (result != JNI_OK) {
 203     char message[256];
 204     jio_snprintf(message, 256, "Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d", _file, _line);
 205     JVMCIRuntime::exit_on_pending_exception(this, message);
 206   }
 207   _pop_frame_on_close = true;
 208 }
 209 
 210 JVMCIEnv::JVMCIEnv(JavaThread* thread, JVMCICompileState* compile_state, const char* file, int line):
 211     _throw_to_caller(false), _file(file), _line(line), _compile_state(compile_state) {
 212   init_env_mode_runtime(thread, NULL);
 213 }
 214 
 215 JVMCIEnv::JVMCIEnv(JavaThread* thread, const char* file, int line):
 216     _throw_to_caller(false), _file(file), _line(line), _compile_state(NULL) {
 217   init_env_mode_runtime(thread, NULL);
 218 }
 219 
 220 JVMCIEnv::JVMCIEnv(JavaThread* thread, JNIEnv* parent_env, const char* file, int line):
 221     _throw_to_caller(true), _file(file), _line(line), _compile_state(NULL) {
 222   init_env_mode_runtime(thread, parent_env);
 223   assert(_env == NULL || parent_env == _env, "mismatched JNIEnvironment");
 224 }
 225 
 226 void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, const char* file, int line) {
 227   _compile_state = NULL;
 228   _throw_to_caller = false;
 229   _file = file;
 230   _line = line;
 231   if (is_hotspot) {
 232     _env = NULL;
 233     _pop_frame_on_close = false;
 234     _detach_on_close = false;
 235     _is_hotspot = true;
 236     _runtime = JVMCI::java_runtime();
 237   } else {
 238     init_env_mode_runtime(thread, NULL);
 239   }
 240 }
 241 
 242 // Prints a pending exception (if any) and its stack trace.
 243 void JVMCIEnv::describe_pending_exception(bool clear) {
<a name="11" id="anc11"></a><span class="new"> 244   Thread* THREAD = Thread::current();</span>
 245   if (!is_hotspot()) {
 246     JNIAccessMark jni(this);
 247     if (jni()-&gt;ExceptionCheck()) {
 248       jthrowable ex = !clear ? jni()-&gt;ExceptionOccurred() : NULL;
 249       jni()-&gt;ExceptionDescribe();
 250       if (ex != NULL) {
 251         jni()-&gt;Throw(ex);
 252       }
 253     }
 254   } else {
<a name="12" id="anc12"></a>
 255     if (HAS_PENDING_EXCEPTION) {
 256       JVMCIRuntime::describe_pending_hotspot_exception((JavaThread*) THREAD, clear);
 257     }
 258   }
 259 }
 260 
 261 void JVMCIEnv::translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle&amp; throwable) {
 262   assert(!is_hotspot(), "must_be");
 263   // Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets
 264   // may not have been called.
 265   Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);
 266   JavaCallArguments jargs;
 267   jargs.push_oop(throwable);
 268   JavaValue result(T_OBJECT);
 269   JavaCalls::call_static(&amp;result,
 270                           runtimeKlass,
 271                           vmSymbols::encodeThrowable_name(),
 272                           vmSymbols::encodeThrowable_signature(), &amp;jargs, THREAD);
 273   if (HAS_PENDING_EXCEPTION) {
 274     JVMCIRuntime::exit_on_pending_exception(this, "HotSpotJVMCIRuntime.encodeThrowable should not throw an exception");
 275   }
 276 
 277   oop encoded_throwable_string = (oop) result.get_jobject();
 278 
 279   ResourceMark rm;
 280   const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);
 281 
<a name="13" id="anc13"></a><span class="changed"> 282   JNIAccessMark jni(this, THREAD);</span>
 283   jobject jni_encoded_throwable_string = jni()-&gt;NewStringUTF(encoded_throwable_chars);
 284   jthrowable jni_throwable = (jthrowable) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 285                                 JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),
 286                                 jni_encoded_throwable_string);
 287   jni()-&gt;Throw(jni_throwable);
 288 }
 289 
 290 JVMCIEnv::~JVMCIEnv() {
 291   if (_throw_to_caller) {
 292     if (is_hotspot()) {
 293       // Nothing to do
 294     } else {
 295       if (Thread::current()-&gt;is_Java_thread()) {
 296         JavaThread* THREAD = JavaThread::current();
 297         if (HAS_PENDING_EXCEPTION) {
 298           Handle throwable = Handle(THREAD, PENDING_EXCEPTION);
 299           CLEAR_PENDING_EXCEPTION;
 300           translate_hotspot_exception_to_jni_exception(THREAD, throwable);
 301         }
 302       }
 303     }
 304   } else {
 305     if (_pop_frame_on_close) {
 306       // Pop the JNI local frame that was pushed when entering this JVMCIEnv scope.
 307       JNIAccessMark jni(this);
 308       jni()-&gt;PopLocalFrame(NULL);
 309     }
 310 
 311     if (has_pending_exception()) {
 312       char message[256];
 313       jio_snprintf(message, 256, "Uncaught exception exiting JVMCIEnv scope entered at %s:%d", _file, _line);
 314       JVMCIRuntime::exit_on_pending_exception(this, message);
 315     }
 316 
 317     if (_detach_on_close) {
<a name="14" id="anc14"></a><span class="changed"> 318       _runtime-&gt;DetachCurrentThread(JavaThread::current());</span>
 319     }
 320   }
 321 }
 322 
 323 jboolean JVMCIEnv::has_pending_exception() {
 324   if (is_hotspot()) {
 325     Thread* THREAD = Thread::current();
 326     return HAS_PENDING_EXCEPTION;
 327   } else {
 328     JNIAccessMark jni(this);
 329     return jni()-&gt;ExceptionCheck();
 330   }
 331 }
 332 
 333 void JVMCIEnv::clear_pending_exception() {
 334   if (is_hotspot()) {
 335     Thread* THREAD = Thread::current();
 336     CLEAR_PENDING_EXCEPTION;
 337   } else {
 338     JNIAccessMark jni(this);
 339     jni()-&gt;ExceptionClear();
 340   }
 341 }
 342 
 343 int JVMCIEnv::get_length(JVMCIArray array) {
 344   if (is_hotspot()) {
 345     return HotSpotJVMCI::resolve(array)-&gt;length();
 346   } else {
 347     JNIAccessMark jni(this);
 348     return jni()-&gt;GetArrayLength(get_jarray(array));
 349   }
 350 }
 351 
 352 JVMCIObject JVMCIEnv::get_object_at(JVMCIObjectArray array, int index) {
 353   if (is_hotspot()) {
 354     oop result = HotSpotJVMCI::resolve(array)-&gt;obj_at(index);
 355     return wrap(result);
 356   } else {
 357     JNIAccessMark jni(this);
 358     jobject result = jni()-&gt;GetObjectArrayElement(get_jobjectArray(array), index);
 359     return wrap(result);
 360   }
 361 }
 362 
 363 void JVMCIEnv::put_object_at(JVMCIObjectArray array, int index, JVMCIObject value) {
 364   if (is_hotspot()) {
 365     HotSpotJVMCI::resolve(array)-&gt;obj_at_put(index, HotSpotJVMCI::resolve(value));
 366   } else {
 367     JNIAccessMark jni(this);
 368     jni()-&gt;SetObjectArrayElement(get_jobjectArray(array), index, get_jobject(value));
 369   }
 370 }
 371 
 372 jboolean JVMCIEnv::get_bool_at(JVMCIPrimitiveArray array, int index) {
 373   if (is_hotspot()) {
 374     return HotSpotJVMCI::resolve(array)-&gt;bool_at(index);
 375   } else {
 376     JNIAccessMark jni(this);
 377     jboolean result;
 378     jni()-&gt;GetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;result);
 379     return result;
 380   }
 381 }
 382 void JVMCIEnv::put_bool_at(JVMCIPrimitiveArray array, int index, jboolean value) {
 383   if (is_hotspot()) {
 384     HotSpotJVMCI::resolve(array)-&gt;bool_at_put(index, value);
 385   } else {
 386     JNIAccessMark jni(this);
 387     jni()-&gt;SetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;value);
 388   }
 389 }
 390 
 391 jbyte JVMCIEnv::get_byte_at(JVMCIPrimitiveArray array, int index) {
 392   if (is_hotspot()) {
 393     return HotSpotJVMCI::resolve(array)-&gt;byte_at(index);
 394   } else {
 395     JNIAccessMark jni(this);
 396     jbyte result;
 397     jni()-&gt;GetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;result);
 398     return result;
 399   }
 400 }
 401 void JVMCIEnv::put_byte_at(JVMCIPrimitiveArray array, int index, jbyte value) {
 402   if (is_hotspot()) {
 403     HotSpotJVMCI::resolve(array)-&gt;byte_at_put(index, value);
 404   } else {
 405     JNIAccessMark jni(this);
 406     jni()-&gt;SetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;value);
 407   }
 408 }
 409 
 410 jint JVMCIEnv::get_int_at(JVMCIPrimitiveArray array, int index) {
 411   if (is_hotspot()) {
 412     return HotSpotJVMCI::resolve(array)-&gt;int_at(index);
 413   } else {
 414     JNIAccessMark jni(this);
 415     jint result;
 416     jni()-&gt;GetIntArrayRegion(array.as_jintArray(), index, 1, &amp;result);
 417     return result;
 418   }
 419 }
 420 void JVMCIEnv::put_int_at(JVMCIPrimitiveArray array, int index, jint value) {
 421   if (is_hotspot()) {
 422     HotSpotJVMCI::resolve(array)-&gt;int_at_put(index, value);
 423   } else {
 424     JNIAccessMark jni(this);
 425     jni()-&gt;SetIntArrayRegion(array.as_jintArray(), index, 1, &amp;value);
 426   }
 427 }
 428 
 429 long JVMCIEnv::get_long_at(JVMCIPrimitiveArray array, int index) {
 430   if (is_hotspot()) {
 431     return HotSpotJVMCI::resolve(array)-&gt;long_at(index);
 432   } else {
 433     JNIAccessMark jni(this);
 434     jlong result;
 435     jni()-&gt;GetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;result);
 436     return result;
 437   }
 438 }
 439 void JVMCIEnv::put_long_at(JVMCIPrimitiveArray array, int index, jlong value) {
 440   if (is_hotspot()) {
 441     HotSpotJVMCI::resolve(array)-&gt;long_at_put(index, value);
 442   } else {
 443     JNIAccessMark jni(this);
 444     jni()-&gt;SetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;value);
 445   }
 446 }
 447 
 448 void JVMCIEnv::copy_bytes_to(JVMCIPrimitiveArray src, jbyte* dest, int offset, jsize length) {
 449   if (length == 0) {
 450     return;
 451   }
 452   if (is_hotspot()) {
 453     memcpy(dest, HotSpotJVMCI::resolve(src)-&gt;byte_at_addr(offset), length);
 454   } else {
 455     JNIAccessMark jni(this);
 456     jni()-&gt;GetByteArrayRegion(src.as_jbyteArray(), offset, length, dest);
 457   }
 458 }
 459 void JVMCIEnv::copy_bytes_from(jbyte* src, JVMCIPrimitiveArray dest, int offset, jsize length) {
 460   if (length == 0) {
 461     return;
 462   }
 463   if (is_hotspot()) {
 464     memcpy(HotSpotJVMCI::resolve(dest)-&gt;byte_at_addr(offset), src, length);
 465   } else {
 466     JNIAccessMark jni(this);
 467     jni()-&gt;SetByteArrayRegion(dest.as_jbyteArray(), offset, length, src);
 468   }
 469 }
 470 
 471 void JVMCIEnv::copy_longs_from(jlong* src, JVMCIPrimitiveArray dest, int offset, jsize length) {
 472   if (length == 0) {
 473     return;
 474   }
 475   if (is_hotspot()) {
 476     memcpy(HotSpotJVMCI::resolve(dest)-&gt;long_at_addr(offset), src, length * sizeof(jlong));
 477   } else {
 478     JNIAccessMark jni(this);
 479     jni()-&gt;SetLongArrayRegion(dest.as_jlongArray(), offset, length, src);
 480   }
 481 }
 482 
 483 jboolean JVMCIEnv::is_boxing_object(BasicType type, JVMCIObject object) {
 484   if (is_hotspot()) {
 485     return java_lang_boxing_object::is_instance(HotSpotJVMCI::resolve(object), type);
 486   } else {
 487     JNIAccessMark jni(this);
 488     return jni()-&gt;IsInstanceOf(get_jobject(object), JNIJVMCI::box_class(type));
 489   }
 490 }
 491 
 492 // Get the primitive value from a Java boxing object.  It's hard error to
 493 // pass a non-primitive BasicType.
 494 jvalue JVMCIEnv::get_boxed_value(BasicType type, JVMCIObject object) {
 495   jvalue result;
 496   if (is_hotspot()) {
 497     if (java_lang_boxing_object::get_value(HotSpotJVMCI::resolve(object), &amp;result) == T_ILLEGAL) {
 498       ShouldNotReachHere();
 499     }
 500   } else {
 501     JNIAccessMark jni(this);
 502     jfieldID field = JNIJVMCI::box_field(type);
 503     switch (type) {
 504       case T_BOOLEAN: result.z = jni()-&gt;GetBooleanField(get_jobject(object), field); break;
 505       case T_BYTE:    result.b = jni()-&gt;GetByteField(get_jobject(object), field); break;
 506       case T_SHORT:   result.s = jni()-&gt;GetShortField(get_jobject(object), field); break;
 507       case T_CHAR:    result.c = jni()-&gt;GetCharField(get_jobject(object), field); break;
 508       case T_INT:     result.i = jni()-&gt;GetIntField(get_jobject(object), field); break;
 509       case T_LONG:    result.j = jni()-&gt;GetLongField(get_jobject(object), field); break;
 510       case T_FLOAT:   result.f = jni()-&gt;GetFloatField(get_jobject(object), field); break;
 511       case T_DOUBLE:  result.d = jni()-&gt;GetDoubleField(get_jobject(object), field); break;
 512       default:
 513         ShouldNotReachHere();
 514     }
 515   }
 516   return result;
 517 }
 518 
 519 // Return the BasicType of the object if it's a boxing object, otherwise return T_ILLEGAL.
 520 BasicType JVMCIEnv::get_box_type(JVMCIObject object) {
 521   if (is_hotspot()) {
 522     return java_lang_boxing_object::basic_type(HotSpotJVMCI::resolve(object));
 523   } else {
 524     JNIAccessMark jni(this);
 525     jclass clazz = jni()-&gt;GetObjectClass(get_jobject(object));
 526     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BOOLEAN))) return T_BOOLEAN;
 527     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BYTE))) return T_BYTE;
 528     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_SHORT))) return T_SHORT;
 529     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_CHAR))) return T_CHAR;
 530     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_INT))) return T_INT;
 531     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_LONG))) return T_LONG;
 532     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_FLOAT))) return T_FLOAT;
 533     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_DOUBLE))) return T_DOUBLE;
 534     return T_ILLEGAL;
 535   }
 536 }
 537 
 538 // Create a boxing object of the appropriate primitive type.
 539 JVMCIObject JVMCIEnv::create_box(BasicType type, jvalue* value, JVMCI_TRAPS) {
 540   switch (type) {
 541     case T_BOOLEAN:
 542     case T_BYTE:
 543     case T_CHAR:
 544     case T_SHORT:
 545     case T_INT:
 546     case T_LONG:
 547     case T_FLOAT:
 548     case T_DOUBLE:
 549       break;
 550     default:
 551       JVMCI_THROW_MSG_(IllegalArgumentException, "Only boxes for primitive values can be created", JVMCIObject());
 552   }
<a name="15" id="anc15"></a>
 553   JavaThread* THREAD = JavaThread::current();
<a name="16" id="anc16"></a><span class="new"> 554   if (is_hotspot()) {</span>
 555     oop box = java_lang_boxing_object::create(type, value, CHECK_(JVMCIObject()));
 556     return HotSpotJVMCI::wrap(box);
 557   } else {
<a name="17" id="anc17"></a><span class="changed"> 558     JNIAccessMark jni(this, THREAD);</span>
 559     jobject box = jni()-&gt;NewObjectA(JNIJVMCI::box_class(type), JNIJVMCI::box_constructor(type), value);
 560     assert(box != NULL, "");
 561     return wrap(box);
 562   }
 563 }
 564 
 565 const char* JVMCIEnv::as_utf8_string(JVMCIObject str) {
 566   if (is_hotspot()) {
 567     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str));
 568   } else {
 569     JNIAccessMark jni(this);
 570     int length = jni()-&gt;GetStringLength(str.as_jstring());
 571     char* result = NEW_RESOURCE_ARRAY(char, length + 1);
 572     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, result);
 573     return result;
 574   }
 575 }
 576 
 577 char* JVMCIEnv::as_utf8_string(JVMCIObject str, char* buf, int buflen) {
 578   if (is_hotspot()) {
 579     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str), buf, buflen);
 580   } else {
 581     JNIAccessMark jni(this);
 582     int length = jni()-&gt;GetStringLength(str.as_jstring());
 583     if (length &gt;= buflen) {
 584       length = buflen;
 585     }
 586     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, buf);
 587     return buf;
 588   }
 589 }
 590 
 591 #define DO_THROW(name)                             \
 592 void JVMCIEnv::throw_##name(const char* msg) {     \
 593   if (is_hotspot()) {                              \
 594     JavaThread* THREAD = JavaThread::current();    \
 595     THROW_MSG(HotSpotJVMCI::name::symbol(), msg);  \
 596   } else {                                         \
 597     JNIAccessMark jni(this);                       \
 598     jni()-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg); \
 599   }                                                \
 600 }
 601 
 602 DO_THROW(InternalError)
 603 DO_THROW(ArrayIndexOutOfBoundsException)
 604 DO_THROW(IllegalStateException)
 605 DO_THROW(NullPointerException)
 606 DO_THROW(IllegalArgumentException)
 607 DO_THROW(InvalidInstalledCodeException)
 608 DO_THROW(UnsatisfiedLinkError)
 609 DO_THROW(UnsupportedOperationException)
 610 DO_THROW(ClassNotFoundException)
 611 
 612 #undef DO_THROW
 613 
 614 void JVMCIEnv::fthrow_error(const char* file, int line, const char* format, ...) {
 615   const int max_msg_size = 1024;
 616   va_list ap;
 617   va_start(ap, format);
 618   char msg[max_msg_size];
 619   vsnprintf(msg, max_msg_size, format, ap);
 620   msg[max_msg_size-1] = '\0';
 621   va_end(ap);
<a name="18" id="anc18"></a>
 622   JavaThread* THREAD = JavaThread::current();
<a name="19" id="anc19"></a><span class="new"> 623   if (is_hotspot()) {</span>
 624     Handle h_loader = Handle();
 625     Handle h_protection_domain = Handle();
 626     Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);
 627   } else {
<a name="20" id="anc20"></a><span class="changed"> 628     JNIAccessMark jni(this, THREAD);</span>
 629     jni()-&gt;ThrowNew(JNIJVMCI::JVMCIError::clazz(), msg);
 630   }
 631 }
 632 
 633 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_compileMethod (JVMCIObject runtime, JVMCIObject method, int entry_bci,
 634                                                               jlong compile_state, int id) {
 635   if (is_hotspot()) {
 636     Thread* THREAD = Thread::current();
 637     JavaCallArguments jargs;
 638     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 639     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(method)));
 640     jargs.push_int(entry_bci);
 641     jargs.push_long(compile_state);
 642     jargs.push_int(id);
 643     JavaValue result(T_OBJECT);
 644     JavaCalls::call_special(&amp;result,
 645                             HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 646                             vmSymbols::compileMethod_name(),
 647                             vmSymbols::compileMethod_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 648     return wrap((oop) result.get_jobject());
 649   } else {
 650     JNIAccessMark jni(this);
 651     jobject result = jni()-&gt;CallNonvirtualObjectMethod(runtime.as_jobject(),
 652                                                      JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 653                                                      JNIJVMCI::HotSpotJVMCIRuntime::compileMethod_method(),
 654                                                      method.as_jobject(), entry_bci, compile_state, id);
 655     if (jni()-&gt;ExceptionCheck()) {
 656       return JVMCIObject();
 657     }
 658     return wrap(result);
 659   }
 660 }
 661 
 662 void JVMCIEnv::call_HotSpotJVMCIRuntime_bootstrapFinished (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 663   if (is_hotspot()) {
 664     Thread* THREAD = Thread::current();
 665     JavaCallArguments jargs;
 666     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 667     JavaValue result(T_VOID);
 668     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::bootstrapFinished_name(), vmSymbols::void_method_signature(), &amp;jargs, CHECK);
 669   } else {
 670     JNIAccessMark jni(this);
 671     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::bootstrapFinished_method());
 672 
 673   }
 674 }
 675 
 676 void JVMCIEnv::call_HotSpotJVMCIRuntime_shutdown (JVMCIObject runtime) {
 677   HandleMark hm;
 678   JavaThread* THREAD = JavaThread::current();
 679   if (is_hotspot()) {
 680     JavaCallArguments jargs;
 681     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 682     JavaValue result(T_VOID);
 683     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &amp;jargs, THREAD);
 684   } else {
<a name="21" id="anc21"></a><span class="changed"> 685     JNIAccessMark jni(this, THREAD);</span>
 686     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::shutdown_method());
 687   }
 688   if (has_pending_exception()) {
 689     // This should never happen as HotSpotJVMCIRuntime.shutdown() should
 690     // handle all exceptions.
 691     describe_pending_exception(true);
 692   }
 693 }
 694 
 695 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_runtime (JVMCIEnv* JVMCIENV) {
 696   JavaThread* THREAD = JavaThread::current();
 697   if (is_hotspot()) {
 698     JavaCallArguments jargs;
 699     JavaValue result(T_OBJECT);
 700     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::runtime_name(), vmSymbols::runtime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 701     return wrap((oop) result.get_jobject());
 702   } else {
<a name="22" id="anc22"></a><span class="changed"> 703     JNIAccessMark jni(this, THREAD);</span>
 704     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::runtime_method());
 705     if (jni()-&gt;ExceptionCheck()) {
 706       return JVMCIObject();
 707     }
 708     return wrap(result);
 709   }
 710 }
 711 
 712 JVMCIObject JVMCIEnv::call_JVMCI_getRuntime (JVMCIEnv* JVMCIENV) {
 713   JavaThread* THREAD = JavaThread::current();
 714   if (is_hotspot()) {
 715     JavaCallArguments jargs;
 716     JavaValue result(T_OBJECT);
 717     JavaCalls::call_static(&amp;result, HotSpotJVMCI::JVMCI::klass(), vmSymbols::getRuntime_name(), vmSymbols::getRuntime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 718     return wrap((oop) result.get_jobject());
 719   } else {
<a name="23" id="anc23"></a><span class="changed"> 720     JNIAccessMark jni(this, THREAD);</span>
 721     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JVMCI::clazz(), JNIJVMCI::JVMCI::getRuntime_method());
 722     if (jni()-&gt;ExceptionCheck()) {
 723       return JVMCIObject();
 724     }
 725     return wrap(result);
 726   }
 727 }
 728 
 729 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_getCompiler (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 730   JavaThread* THREAD = JavaThread::current();
 731   if (is_hotspot()) {
 732     JavaCallArguments jargs;
 733     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 734     JavaValue result(T_OBJECT);
 735     JavaCalls::call_virtual(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::getCompiler_name(), vmSymbols::getCompiler_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 736     return wrap((oop) result.get_jobject());
 737   } else {
<a name="24" id="anc24"></a><span class="changed"> 738     JNIAccessMark jni(this, THREAD);</span>
 739     jobject result = jni()-&gt;CallObjectMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::getCompiler_method());
 740     if (jni()-&gt;ExceptionCheck()) {
 741       return JVMCIObject();
 742     }
 743     return wrap(result);
 744   }
 745 }
 746 
 747 
 748 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCIEnv* JVMCIENV) {
 749   JavaThread* THREAD = JavaThread::current();
 750   if (is_hotspot()) {
 751     JavaCallArguments jargs;
 752     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));
 753     JavaValue result(T_OBJECT);
 754     JavaCalls::call_static(&amp;result,
 755                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 756                            vmSymbols::callToString_name(),
 757                            vmSymbols::callToString_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 758     return wrap((oop) result.get_jobject());
 759   } else {
<a name="25" id="anc25"></a><span class="changed"> 760     JNIAccessMark jni(this, THREAD);</span>
 761     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 762                                                      JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),
 763                                                      object.as_jobject());
 764     if (jni()-&gt;ExceptionCheck()) {
 765       return JVMCIObject();
 766     }
 767     return wrap(result);
 768   }
 769 }
 770 
 771 
 772 JVMCIObject JVMCIEnv::call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS) {
 773   JavaThread* THREAD = JavaThread::current();
 774   if (is_hotspot()) {
 775     JavaCallArguments jargs;
 776     jargs.push_int(kind);
 777     jargs.push_long(value);
 778     JavaValue result(T_OBJECT);
 779     JavaCalls::call_static(&amp;result,
 780                            HotSpotJVMCI::PrimitiveConstant::klass(),
 781                            vmSymbols::forTypeChar_name(),
 782                            vmSymbols::forTypeChar_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 783     return wrap((oop) result.get_jobject());
 784   } else {
<a name="26" id="anc26"></a><span class="changed"> 785     JNIAccessMark jni(this, THREAD);</span>
 786     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),
 787                                                      JNIJVMCI::PrimitiveConstant::forTypeChar_method(),
 788                                                      kind, value);
 789     if (jni()-&gt;ExceptionCheck()) {
 790       return JVMCIObject();
 791     }
 792     return wrap(result);
 793   }
 794 }
 795 
 796 JVMCIObject JVMCIEnv::call_JavaConstant_forFloat(float value, JVMCI_TRAPS) {
 797   JavaThread* THREAD = JavaThread::current();
 798   if (is_hotspot()) {
 799     JavaCallArguments jargs;
 800     jargs.push_float(value);
 801     JavaValue result(T_OBJECT);
 802     JavaCalls::call_static(&amp;result,
 803                            HotSpotJVMCI::JavaConstant::klass(),
 804                            vmSymbols::forFloat_name(),
 805                            vmSymbols::forFloat_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 806     return wrap((oop) result.get_jobject());
 807   } else {
<a name="27" id="anc27"></a><span class="changed"> 808     JNIAccessMark jni(this, THREAD);</span>
 809     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 810                                                      JNIJVMCI::JavaConstant::forFloat_method(),
 811                                                      value);
 812     if (jni()-&gt;ExceptionCheck()) {
 813       return JVMCIObject();
 814     }
 815     return wrap(result);
 816   }
 817 }
 818 
 819 JVMCIObject JVMCIEnv::call_JavaConstant_forDouble(double value, JVMCI_TRAPS) {
 820   JavaThread* THREAD = JavaThread::current();
 821   if (is_hotspot()) {
 822     JavaCallArguments jargs;
 823     jargs.push_double(value);
 824     JavaValue result(T_OBJECT);
 825     JavaCalls::call_static(&amp;result,
 826                            HotSpotJVMCI::JavaConstant::klass(),
 827                            vmSymbols::forDouble_name(),
 828                            vmSymbols::forDouble_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 829     return wrap((oop) result.get_jobject());
 830   } else {
<a name="28" id="anc28"></a><span class="changed"> 831     JNIAccessMark jni(this, THREAD);</span>
 832     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 833                                                      JNIJVMCI::JavaConstant::forDouble_method(),
 834                                                      value);
 835     if (jni()-&gt;ExceptionCheck()) {
 836       return JVMCIObject();
 837     }
 838     return wrap(result);
 839   }
 840 }
 841 
 842 JVMCIObject JVMCIEnv::get_jvmci_primitive_type(BasicType type) {
 843   JVMCIObjectArray primitives = get_HotSpotResolvedPrimitiveType_primitives();
 844   JVMCIObject result = get_object_at(primitives, type);
 845   return result;
 846 }
 847 
 848 JVMCIObject JVMCIEnv::new_StackTraceElement(const methodHandle&amp; method, int bci, JVMCI_TRAPS) {
 849   JavaThread* THREAD = JavaThread::current();
 850   Symbol* file_name_sym;
 851   int line_number;
 852   java_lang_StackTraceElement::decode(method, bci, file_name_sym, line_number, CHECK_(JVMCIObject()));
 853 
 854   Symbol* method_name_sym = method-&gt;name();
 855   InstanceKlass* holder = method-&gt;method_holder();
 856   const char* declaring_class_str = holder-&gt;external_name();
 857 
 858   if (is_hotspot()) {
 859     HotSpotJVMCI::StackTraceElement::klass()-&gt;initialize(CHECK_(JVMCIObject()));
 860     oop objOop = HotSpotJVMCI::StackTraceElement::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
 861     Handle obj = Handle(THREAD, objOop);
 862 
 863     oop declaring_class = StringTable::intern((char*) declaring_class_str, CHECK_(JVMCIObject()));
 864     HotSpotJVMCI::StackTraceElement::set_declaringClass(this, obj(), declaring_class);
 865 
 866     oop method_name = StringTable::intern(method_name_sym, CHECK_(JVMCIObject()));
 867     HotSpotJVMCI::StackTraceElement::set_methodName(this, obj(), method_name);
 868 
 869     if (file_name_sym != NULL) {
 870       oop file_name = StringTable::intern(file_name_sym, CHECK_(JVMCIObject()));
 871       HotSpotJVMCI::StackTraceElement::set_fileName(this, obj(), file_name);
 872     }
 873     HotSpotJVMCI::StackTraceElement::set_lineNumber(this, obj(), line_number);
 874     return wrap(obj());
 875   } else {
<a name="29" id="anc29"></a><span class="changed"> 876     JNIAccessMark jni(this, THREAD);</span>
 877     jobject declaring_class = jni()-&gt;NewStringUTF(declaring_class_str);
 878     if (jni()-&gt;ExceptionCheck()) {
 879       return JVMCIObject();
 880     }
 881     jobject method_name = jni()-&gt;NewStringUTF(method_name_sym-&gt;as_C_string());
 882     if (jni()-&gt;ExceptionCheck()) {
 883       return JVMCIObject();
 884     }
 885     jobject file_name = NULL;
 886     if (file_name_sym != NULL) {
 887       file_name = jni()-&gt;NewStringUTF(file_name_sym-&gt;as_C_string());
 888       if (jni()-&gt;ExceptionCheck()) {
 889         return JVMCIObject();
 890       }
 891     }
 892 
 893     jobject result = jni()-&gt;NewObject(JNIJVMCI::StackTraceElement::clazz(),
 894                                       JNIJVMCI::StackTraceElement::constructor(),
 895                                       declaring_class, method_name, file_name, line_number);
 896     return wrap(result);
 897   }
 898 }
 899 
 900 JVMCIObject JVMCIEnv::new_HotSpotNmethod(const methodHandle&amp; method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS) {
 901   JavaThread* THREAD = JavaThread::current();
 902 
 903   JVMCIObject methodObject = get_jvmci_method(method, JVMCI_CHECK_(JVMCIObject()));
 904 
 905   if (is_hotspot()) {
 906     InstanceKlass* ik = InstanceKlass::cast(HotSpotJVMCI::HotSpotNmethod::klass());
 907     if (ik-&gt;should_be_initialized()) {
 908       ik-&gt;initialize(CHECK_(JVMCIObject()));
 909     }
 910     oop obj = ik-&gt;allocate_instance(CHECK_(JVMCIObject()));
 911     Handle obj_h(THREAD, obj);
 912     Handle nameStr = java_lang_String::create_from_str(name, CHECK_(JVMCIObject()));
 913 
 914     // Call constructor
 915     JavaCallArguments jargs;
 916     jargs.push_oop(obj_h);
 917     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(methodObject)));
 918     jargs.push_oop(nameStr);
 919     jargs.push_int(isDefault);
 920     jargs.push_long(compileId);
 921     JavaValue result(T_VOID);
 922     JavaCalls::call_special(&amp;result, ik,
 923                             vmSymbols::object_initializer_name(),
 924                             vmSymbols::method_string_bool_long_signature(),
 925                             &amp;jargs, CHECK_(JVMCIObject()));
 926     return wrap(obj_h());
 927   } else {
<a name="30" id="anc30"></a><span class="changed"> 928     JNIAccessMark jni(this, THREAD);</span>
 929     jobject nameStr = name == NULL ? NULL : jni()-&gt;NewStringUTF(name);
 930     if (jni()-&gt;ExceptionCheck()) {
 931       return JVMCIObject();
 932     }
 933 
 934     jobject result = jni()-&gt;NewObject(JNIJVMCI::HotSpotNmethod::clazz(),
 935                                       JNIJVMCI::HotSpotNmethod::constructor(),
 936                                       methodObject.as_jobject(), nameStr, isDefault);
 937     return wrap(result);
 938   }
 939 }
 940 
 941 JVMCIObject JVMCIEnv::make_local(JVMCIObject object) {
 942   if (object.is_null()) {
 943     return JVMCIObject();
 944   }
 945   if (is_hotspot()) {
 946     return wrap(JNIHandles::make_local(HotSpotJVMCI::resolve(object)));
 947   } else {
 948     JNIAccessMark jni(this);
 949     return wrap(jni()-&gt;NewLocalRef(object.as_jobject()));
 950   }
 951 }
 952 
 953 JVMCIObject JVMCIEnv::make_global(JVMCIObject object) {
 954   if (object.is_null()) {
 955     return JVMCIObject();
 956   }
 957   if (is_hotspot()) {
 958     return wrap(JNIHandles::make_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));
 959   } else {
 960     JNIAccessMark jni(this);
 961     return wrap(jni()-&gt;NewGlobalRef(object.as_jobject()));
 962   }
 963 }
 964 
<a name="31" id="anc31"></a>











 965 void JVMCIEnv::destroy_local(JVMCIObject object) {
 966   if (is_hotspot()) {
 967     JNIHandles::destroy_local(object.as_jobject());
 968   } else {
 969     JNIAccessMark jni(this);
 970     jni()-&gt;DeleteLocalRef(object.as_jobject());
 971   }
 972 }
 973 
 974 void JVMCIEnv::destroy_global(JVMCIObject object) {
 975   if (is_hotspot()) {
 976     JNIHandles::destroy_global(object.as_jobject());
 977   } else {
 978     JNIAccessMark jni(this);
 979     jni()-&gt;DeleteGlobalRef(object.as_jobject());
 980   }
 981 }
 982 
<a name="32" id="anc32"></a>








 983 const char* JVMCIEnv::klass_name(JVMCIObject object) {
 984   if (is_hotspot()) {
 985     return HotSpotJVMCI::resolve(object)-&gt;klass()-&gt;signature_name();
 986   } else {
 987     JVMCIObject name;
 988     {
 989       JNIAccessMark jni(this);
 990       jclass jcl = jni()-&gt;GetObjectClass(object.as_jobject());
 991       jobject result = jni()-&gt;CallObjectMethod(jcl, JNIJVMCI::Class_getName_method());
 992       name = JVMCIObject::create(result, is_hotspot());
 993     }
 994     return as_utf8_string(name);
 995   }
 996 }
 997 
 998 JVMCIObject JVMCIEnv::get_jvmci_method(const methodHandle&amp; method, JVMCI_TRAPS) {
 999   JVMCIObject method_object;
1000   if (method() == NULL) {
1001     return method_object;
1002   }
1003 
1004   Thread* THREAD = Thread::current();
<a name="33" id="anc33"></a><span class="changed">1005   jmetadata handle = _runtime-&gt;allocate_handle(method);</span>
1006   jboolean exception = false;
1007   if (is_hotspot()) {
1008     JavaValue result(T_OBJECT);
1009     JavaCallArguments args;
1010     args.push_long((jlong) handle);
1011     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass(),
1012                            vmSymbols::fromMetaspace_name(),
1013                            vmSymbols::method_fromMetaspace_signature(), &amp;args, THREAD);
1014     if (HAS_PENDING_EXCEPTION) {
1015       exception = true;
1016     } else {
1017       method_object = wrap((oop)result.get_jobject());
1018     }
1019   } else {
1020     JNIAccessMark jni(this);
1021     method_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedJavaMethodImpl::clazz(),
1022                                                                   JNIJVMCI::HotSpotResolvedJavaMethodImpl_fromMetaspace_method(),
1023                                                                   (jlong) handle));
1024     exception = jni()-&gt;ExceptionCheck();
1025   }
1026 
1027   if (exception) {
<a name="34" id="anc34"></a><span class="changed">1028     _runtime-&gt;release_handle(handle);</span>
1029     return JVMCIObject();
1030   }
1031 
1032   assert(asMethod(method_object) == method(), "must be");
1033   if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {
<a name="35" id="anc35"></a><span class="changed">1034     _runtime-&gt;release_handle(handle);</span>
1035   }
1036   assert(!method_object.is_null(), "must be");
1037   return method_object;
1038 }
1039 
1040 JVMCIObject JVMCIEnv::get_jvmci_type(const JVMCIKlassHandle&amp; klass, JVMCI_TRAPS) {
1041   JVMCIObject type;
1042   if (klass.is_null()) {
1043     return type;
1044   }
1045 
1046   jlong pointer = (jlong) klass();
1047   JavaThread* THREAD = JavaThread::current();
1048   JVMCIObject signature = create_string(klass-&gt;signature_name(), JVMCI_CHECK_(JVMCIObject()));
1049   jboolean exception = false;
1050   if (is_hotspot()) {
1051     JavaValue result(T_OBJECT);
1052     JavaCallArguments args;
1053     args.push_long(pointer);
1054     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(signature)));
1055     JavaCalls::call_static(&amp;result,
1056                            HotSpotJVMCI::HotSpotResolvedObjectTypeImpl::klass(),
1057                            vmSymbols::fromMetaspace_name(),
1058                            vmSymbols::klass_fromMetaspace_signature(), &amp;args, THREAD);
1059 
1060     if (HAS_PENDING_EXCEPTION) {
1061       exception = true;
1062     } else {
1063       type = wrap((oop)result.get_jobject());
1064     }
1065   } else {
<a name="36" id="anc36"></a><span class="changed">1066     JNIAccessMark jni(this, THREAD);</span>
1067 
1068     HandleMark hm(THREAD);
1069     type = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedObjectTypeImpl::clazz(),
1070                                                         JNIJVMCI::HotSpotResolvedObjectTypeImpl_fromMetaspace_method(),
1071                                                         pointer, signature.as_jstring()));
1072     exception = jni()-&gt;ExceptionCheck();
1073   }
1074   if (exception) {
1075     return JVMCIObject();
1076   }
1077 
1078   assert(type.is_non_null(), "must have result");
1079   return type;
1080 }
1081 
1082 JVMCIObject JVMCIEnv::get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS) {
1083   JVMCIObject cp_object;
<a name="37" id="anc37"></a><span class="changed">1084   jmetadata handle = _runtime-&gt;allocate_handle(cp);</span>
1085   jboolean exception = false;
<a name="38" id="anc38"></a>
1086   JavaThread* THREAD = JavaThread::current();
<a name="39" id="anc39"></a><span class="new">1087   if (is_hotspot()) {</span>
1088     JavaValue result(T_OBJECT);
1089     JavaCallArguments args;
1090     args.push_long((jlong) handle);
1091     JavaCalls::call_static(&amp;result,
1092                            HotSpotJVMCI::HotSpotConstantPool::klass(),
1093                            vmSymbols::fromMetaspace_name(),
1094                            vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, THREAD);
1095     if (HAS_PENDING_EXCEPTION) {
1096       exception = true;
1097     } else {
1098       cp_object = wrap((oop)result.get_jobject());
1099     }
1100   } else {
<a name="40" id="anc40"></a><span class="changed">1101     JNIAccessMark jni(this, THREAD);</span>
1102     cp_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotConstantPool::clazz(),
1103                                                              JNIJVMCI::HotSpotConstantPool_fromMetaspace_method(),
1104                                                              (jlong) handle));
1105     exception = jni()-&gt;ExceptionCheck();
1106   }
1107 
1108   if (exception) {
<a name="41" id="anc41"></a><span class="changed">1109     _runtime-&gt;release_handle(handle);</span>
1110     return JVMCIObject();
1111   }
1112 
1113   assert(!cp_object.is_null(), "must be");
1114   // Constant pools aren't cached so this is always a newly created object using the handle
1115   assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, "must use same handle");
1116   return cp_object;
1117 }
1118 
1119 JVMCIPrimitiveArray JVMCIEnv::new_booleanArray(int length, JVMCI_TRAPS) {
<a name="42" id="anc42"></a>
1120   JavaThread* THREAD = JavaThread::current();
<a name="43" id="anc43"></a><span class="new">1121   if (is_hotspot()) {</span>
1122     typeArrayOop result = oopFactory::new_boolArray(length, CHECK_(JVMCIObject()));
1123     return wrap(result);
1124   } else {
<a name="44" id="anc44"></a><span class="changed">1125     JNIAccessMark jni(this, THREAD);</span>
1126     jbooleanArray result = jni()-&gt;NewBooleanArray(length);
1127     return wrap(result);
1128   }
1129 }
1130 
1131 JVMCIPrimitiveArray JVMCIEnv::new_byteArray(int length, JVMCI_TRAPS) {
<a name="45" id="anc45"></a>
1132   JavaThread* THREAD = JavaThread::current();
<a name="46" id="anc46"></a><span class="new">1133   if (is_hotspot()) {</span>
1134     typeArrayOop result = oopFactory::new_byteArray(length, CHECK_(JVMCIObject()));
1135     return wrap(result);
1136   } else {
<a name="47" id="anc47"></a><span class="changed">1137     JNIAccessMark jni(this, THREAD);</span>
1138     jbyteArray result = jni()-&gt;NewByteArray(length);
1139     return wrap(result);
1140   }
1141 }
1142 
1143 JVMCIObjectArray JVMCIEnv::new_byte_array_array(int length, JVMCI_TRAPS) {
<a name="48" id="anc48"></a>
1144   JavaThread* THREAD = JavaThread::current();
<a name="49" id="anc49"></a><span class="new">1145   if (is_hotspot()) {</span>
1146     Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())-&gt;array_klass(CHECK_(JVMCIObject()));
1147     objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) -&gt;allocate(length, CHECK_(JVMCIObject()));
1148     return wrap(result);
1149   } else {
<a name="50" id="anc50"></a><span class="changed">1150     JNIAccessMark jni(this, THREAD);</span>
1151     jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::byte_array(), NULL);
1152     return wrap(result);
1153   }
1154 }
1155 
1156 JVMCIPrimitiveArray JVMCIEnv::new_intArray(int length, JVMCI_TRAPS) {
<a name="51" id="anc51"></a>
1157   JavaThread* THREAD = JavaThread::current();
<a name="52" id="anc52"></a><span class="new">1158   if (is_hotspot()) {</span>
1159     typeArrayOop result = oopFactory::new_intArray(length, CHECK_(JVMCIObject()));
1160     return wrap(result);
1161   } else {
<a name="53" id="anc53"></a><span class="changed">1162     JNIAccessMark jni(this, THREAD);</span>
1163     jintArray result = jni()-&gt;NewIntArray(length);
1164     return wrap(result);
1165   }
1166 }
1167 
1168 JVMCIPrimitiveArray JVMCIEnv::new_longArray(int length, JVMCI_TRAPS) {
<a name="54" id="anc54"></a>
1169   JavaThread* THREAD = JavaThread::current();
<a name="55" id="anc55"></a><span class="new">1170   if (is_hotspot()) {</span>
1171     typeArrayOop result = oopFactory::new_longArray(length, CHECK_(JVMCIObject()));
1172     return wrap(result);
1173   } else {
<a name="56" id="anc56"></a><span class="changed">1174     JNIAccessMark jni(this, THREAD);</span>
1175     jlongArray result = jni()-&gt;NewLongArray(length);
1176     return wrap(result);
1177   }
1178 }
1179 
1180 JVMCIObject JVMCIEnv::new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS) {
<a name="57" id="anc57"></a>
1181   JavaThread* THREAD = JavaThread::current();
<a name="58" id="anc58"></a><span class="new">1182   if (is_hotspot()) {</span>
1183     HotSpotJVMCI::VMField::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1184     oop obj = HotSpotJVMCI::VMField::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1185     HotSpotJVMCI::VMField::set_name(this, obj, HotSpotJVMCI::resolve(name));
1186     HotSpotJVMCI::VMField::set_type(this, obj, HotSpotJVMCI::resolve(type));
1187     HotSpotJVMCI::VMField::set_offset(this, obj, offset);
1188     HotSpotJVMCI::VMField::set_address(this, obj, address);
1189     HotSpotJVMCI::VMField::set_value(this, obj, HotSpotJVMCI::resolve(value));
1190     return wrap(obj);
1191   } else {
<a name="59" id="anc59"></a><span class="changed">1192     JNIAccessMark jni(this, THREAD);</span>
1193     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMField::clazz(),
1194                                     JNIJVMCI::VMField::constructor(),
1195                                     get_jobject(name), get_jobject(type), offset, address, get_jobject(value));
1196     return wrap(result);
1197   }
1198 }
1199 
1200 JVMCIObject JVMCIEnv::new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS) {
<a name="60" id="anc60"></a>
1201   JavaThread* THREAD = JavaThread::current();
<a name="61" id="anc61"></a><span class="new">1202   if (is_hotspot()) {</span>
1203     HotSpotJVMCI::VMFlag::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1204     oop obj = HotSpotJVMCI::VMFlag::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1205     HotSpotJVMCI::VMFlag::set_name(this, obj, HotSpotJVMCI::resolve(name));
1206     HotSpotJVMCI::VMFlag::set_type(this, obj, HotSpotJVMCI::resolve(type));
1207     HotSpotJVMCI::VMFlag::set_value(this, obj, HotSpotJVMCI::resolve(value));
1208     return wrap(obj);
1209   } else {
<a name="62" id="anc62"></a><span class="changed">1210     JNIAccessMark jni(this, THREAD);</span>
1211     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMFlag::clazz(),
1212                                     JNIJVMCI::VMFlag::constructor(),
1213                                     get_jobject(name), get_jobject(type), get_jobject(value));
1214     return wrap(result);
1215   }
1216 }
1217 
1218 JVMCIObject JVMCIEnv::new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS) {
<a name="63" id="anc63"></a>
1219   JavaThread* THREAD = JavaThread::current();
<a name="64" id="anc64"></a><span class="new">1220   if (is_hotspot()) {</span>
1221     HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1222     oop obj = HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1223     HotSpotJVMCI::VMIntrinsicMethod::set_declaringClass(this, obj, HotSpotJVMCI::resolve(declaringClass));
1224     HotSpotJVMCI::VMIntrinsicMethod::set_name(this, obj, HotSpotJVMCI::resolve(name));
1225     HotSpotJVMCI::VMIntrinsicMethod::set_descriptor(this, obj, HotSpotJVMCI::resolve(descriptor));
1226     HotSpotJVMCI::VMIntrinsicMethod::set_id(this, obj, id);
1227     return wrap(obj);
1228   } else {
<a name="65" id="anc65"></a><span class="changed">1229     JNIAccessMark jni(this, THREAD);</span>
1230     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMIntrinsicMethod::clazz(),
1231                                     JNIJVMCI::VMIntrinsicMethod::constructor(),
1232                                     get_jobject(declaringClass), get_jobject(name), get_jobject(descriptor), id);
1233     return wrap(result);
1234   }
1235 }
1236 
1237 JVMCIObject JVMCIEnv::new_HotSpotStackFrameReference(JVMCI_TRAPS) {
1238   if (is_hotspot()) {
1239     JavaThread* THREAD = JavaThread::current();
1240     HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1241     oop obj = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1242     return wrap(obj);
1243   } else {
1244     ShouldNotReachHere();
1245     return JVMCIObject();
1246   }
1247 }
1248 JVMCIObject JVMCIEnv::new_JVMCIError(JVMCI_TRAPS) {
1249   if (is_hotspot()) {
1250     JavaThread* THREAD = JavaThread::current();
1251     HotSpotJVMCI::JVMCIError::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1252     oop obj = HotSpotJVMCI::JVMCIError::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1253     return wrap(obj);
1254   } else {
1255     ShouldNotReachHere();
1256     return JVMCIObject();
1257   }
1258 }
1259 
1260 
1261 JVMCIObject JVMCIEnv::get_object_constant(oop objOop, bool compressed, bool dont_register) {
1262   JavaThread* THREAD = JavaThread::current();
1263   Handle obj = Handle(THREAD, objOop);
1264   if (obj.is_null()) {
1265     return JVMCIObject();
1266   }
1267   if (is_hotspot()) {
1268     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1269     oop constant = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1270     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::set_object(this, constant, obj());
1271     HotSpotJVMCI::HotSpotObjectConstantImpl::set_compressed(this, constant, compressed);
1272     return wrap(constant);
1273   } else {
1274     jlong handle = make_handle(obj);
<a name="66" id="anc66"></a><span class="changed">1275     JNIAccessMark jni(this, THREAD);</span>
1276     jobject result = jni()-&gt;NewObject(JNIJVMCI::IndirectHotSpotObjectConstantImpl::clazz(),
1277                                       JNIJVMCI::IndirectHotSpotObjectConstantImpl::constructor(),
1278                                       handle, compressed, dont_register);
1279     return wrap(result);
1280   }
1281 }
1282 
1283 
1284 Handle JVMCIEnv::asConstant(JVMCIObject constant, JVMCI_TRAPS) {
1285   if (constant.is_null()) {
1286     return Handle();
1287   }
1288   JavaThread* THREAD = JavaThread::current();
1289   if (is_hotspot()) {
1290     assert(HotSpotJVMCI::DirectHotSpotObjectConstantImpl::is_instance(this, constant), "wrong type");
1291     oop obj = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::object(this, HotSpotJVMCI::resolve(constant));
1292     return Handle(THREAD, obj);
1293   } else if (isa_IndirectHotSpotObjectConstantImpl(constant)) {
1294     jlong object_handle = get_IndirectHotSpotObjectConstantImpl_objectHandle(constant);
1295     if (object_handle == 0L) {
1296       JVMCI_THROW_MSG_(NullPointerException, "Foreign object reference has been cleared", Handle());
1297     }
1298     oop result = resolve_handle(object_handle);
1299     if (result == NULL) {
1300       JVMCI_THROW_MSG_(InternalError, "Constant was unexpectedly NULL", Handle());
1301     }
1302     return Handle(THREAD, result);
1303   } else {
1304     JVMCI_THROW_MSG_(IllegalArgumentException, "DirectHotSpotObjectConstantImpl shouldn't reach JVMCI in SVM mode", Handle());
1305   }
1306 }
1307 
1308 JVMCIObject JVMCIEnv::wrap(jobject object) {
1309   return JVMCIObject::create(object, is_hotspot());
1310 }
1311 
1312 jlong JVMCIEnv::make_handle(const Handle&amp; obj) {
1313   assert(!obj.is_null(), "should only create handle for non-NULL oops");
<a name="67" id="anc67"></a><span class="changed">1314   jobject handle = _runtime-&gt;make_global(obj);</span>
1315   return (jlong) handle;
1316 }
1317 
1318 oop JVMCIEnv::resolve_handle(jlong objectHandle) {
1319   assert(objectHandle != 0, "should be a valid handle");
1320   oop obj = *((oopDesc**)objectHandle);
1321   if (obj != NULL) {
1322     oopDesc::verify(obj);
1323   }
1324   return obj;
1325 }
1326 
1327 JVMCIObject JVMCIEnv::create_string(const char* str, JVMCI_TRAPS) {
<a name="68" id="anc68"></a>
1328   JavaThread* THREAD = JavaThread::current();
<a name="69" id="anc69"></a><span class="new">1329   if (is_hotspot()) {</span>
1330     Handle result = java_lang_String::create_from_str(str, CHECK_(JVMCIObject()));
1331     return HotSpotJVMCI::wrap(result());
1332   } else {
1333     jobject result;
1334     jboolean exception = false;
1335     {
<a name="70" id="anc70"></a><span class="changed">1336       JNIAccessMark jni(this, THREAD);</span>
1337       result = jni()-&gt;NewStringUTF(str);
1338       exception = jni()-&gt;ExceptionCheck();
1339     }
1340     return wrap(result);
1341   }
1342 }
1343 
1344 bool JVMCIEnv::equals(JVMCIObject a, JVMCIObject b) {
1345   if (is_hotspot()) {
1346     return HotSpotJVMCI::resolve(a) == HotSpotJVMCI::resolve(b);
1347   } else {
1348     JNIAccessMark jni(this);
1349     return jni()-&gt;IsSameObject(a.as_jobject(), b.as_jobject()) != 0;
1350   }
1351 }
1352 
1353 BasicType JVMCIEnv::kindToBasicType(JVMCIObject kind, JVMCI_TRAPS) {
1354   if (kind.is_null()) {
1355     JVMCI_THROW_(NullPointerException, T_ILLEGAL);
1356   }
1357   jchar ch = get_JavaKind_typeChar(kind);
1358   switch(ch) {
1359     case 'Z': return T_BOOLEAN;
1360     case 'B': return T_BYTE;
1361     case 'S': return T_SHORT;
1362     case 'C': return T_CHAR;
1363     case 'I': return T_INT;
1364     case 'F': return T_FLOAT;
1365     case 'J': return T_LONG;
1366     case 'D': return T_DOUBLE;
1367     case 'A': return T_OBJECT;
1368     case '-': return T_ILLEGAL;
1369     default:
1370       JVMCI_ERROR_(T_ILLEGAL, "unexpected Kind: %c", ch);
1371   }
1372 }
1373 
1374 void JVMCIEnv::initialize_installed_code(JVMCIObject installed_code, CodeBlob* cb, JVMCI_TRAPS) {
1375   // Ensure that all updates to the InstalledCode fields are consistent.
1376   if (get_InstalledCode_address(installed_code) != 0) {
1377     JVMCI_THROW_MSG(InternalError, "InstalledCode instance already in use");
1378   }
1379   if (!isa_HotSpotInstalledCode(installed_code)) {
1380     JVMCI_THROW_MSG(InternalError, "InstalledCode instance must be a subclass of HotSpotInstalledCode");
1381   }
1382 
1383   // Ignore the version which can stay at 0
1384   if (cb-&gt;is_nmethod()) {
1385     nmethod* nm = cb-&gt;as_nmethod_or_null();
1386     if (!nm-&gt;is_alive()) {
1387       JVMCI_THROW_MSG(InternalError, "nmethod has been reclaimed");
1388     }
1389     if (nm-&gt;is_in_use()) {
1390       set_InstalledCode_entryPoint(installed_code, (jlong) nm-&gt;verified_entry_point());
1391     }
1392   } else {
1393     set_InstalledCode_entryPoint(installed_code, (jlong) cb-&gt;code_begin());
1394   }
1395   set_InstalledCode_address(installed_code, (jlong) cb);
1396   set_HotSpotInstalledCode_size(installed_code, cb-&gt;size());
1397   set_HotSpotInstalledCode_codeStart(installed_code, (jlong) cb-&gt;code_begin());
1398   set_HotSpotInstalledCode_codeSize(installed_code, cb-&gt;code_size());
1399 }
1400 
1401 
1402 void JVMCIEnv::invalidate_nmethod_mirror(JVMCIObject mirror, JVMCI_TRAPS) {
1403   if (mirror.is_null()) {
1404     JVMCI_THROW(NullPointerException);
1405   }
1406 
1407   nmethodLocker locker;
1408   nmethod* nm = JVMCIENV-&gt;get_nmethod(mirror, locker);
1409   if (nm == NULL) {
1410     // Nothing to do
1411     return;
1412   }
1413 
1414   Thread* THREAD = Thread::current();
1415   if (!mirror.is_hotspot() &amp;&amp; !THREAD-&gt;is_Java_thread()) {
1416     // Calling back into native might cause the execution to block, so only allow this when calling
1417     // from a JavaThread, which is the normal case anyway.
1418     JVMCI_THROW_MSG(IllegalArgumentException,
1419                     "Cannot invalidate HotSpotNmethod object in shared library VM heap from non-JavaThread");
1420   }
1421 
1422   nmethodLocker nml(nm);
1423   if (nm-&gt;is_alive()) {
1424     // Invalidating the HotSpotNmethod means we want the nmethod to be deoptimized.
1425     Deoptimization::deoptimize_all_marked(nm);
1426   }
1427 
1428   // A HotSpotNmethod instance can only reference a single nmethod
1429   // during its lifetime so simply clear it here.
1430   set_InstalledCode_address(mirror, 0);
1431 }
1432 
1433 Klass* JVMCIEnv::asKlass(JVMCIObject obj) {
1434   return (Klass*) get_HotSpotResolvedObjectTypeImpl_metadataPointer(obj);
1435 }
1436 
1437 Method* JVMCIEnv::asMethod(JVMCIObject obj) {
1438   Method** metadataHandle = (Method**) get_HotSpotResolvedJavaMethodImpl_metadataHandle(obj);
1439   return *metadataHandle;
1440 }
1441 
1442 ConstantPool* JVMCIEnv::asConstantPool(JVMCIObject obj) {
1443   ConstantPool** metadataHandle = (ConstantPool**) get_HotSpotConstantPool_metadataHandle(obj);
1444   return *metadataHandle;
1445 }
1446 
1447 CodeBlob* JVMCIEnv::get_code_blob(JVMCIObject obj, nmethodLocker&amp; locker) {
1448   address code = (address) get_InstalledCode_address(obj);
1449   if (code == NULL) {
1450     return NULL;
1451   }
1452   if (isa_HotSpotNmethod(obj)) {
1453     nmethod* nm = NULL;
1454     {
1455       // Lookup the CodeBlob while holding the CodeCache_lock to ensure the nmethod can't be freed
1456       // by nmethod::flush while we're interrogating it.
1457       MutexLocker cm_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1458       CodeBlob* cb = CodeCache::find_blob_unsafe(code);
1459       if (cb == (CodeBlob*) code) {
1460         nmethod* the_nm = cb-&gt;as_nmethod_or_null();
1461         if (the_nm != NULL &amp;&amp; the_nm-&gt;is_alive()) {
1462           // Lock the nmethod to stop any further transitions by the sweeper.  It's still possible
1463           // for this code to execute in the middle of the sweeping of the nmethod but that will be
1464           // handled below.
1465           locker.set_code(nm, true);
1466           nm = the_nm;
1467         }
1468       }
1469     }
1470 
1471     if (nm != NULL) {
1472       // We found the nmethod but it could be in the process of being freed.  Check the state of the
1473       // nmethod while holding the CompiledMethod_lock.  This ensures that any transitions by other
1474       // threads have seen the is_locked_by_vm() update above.
1475       MutexLocker cm_lock(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1476       if (!nm-&gt;is_alive()) {
1477         //  It was alive when we looked it up but it's no longer alive so release it.
1478         locker.set_code(NULL);
1479         nm = NULL;
1480       }
1481     }
1482 
1483     jlong compile_id_snapshot = get_HotSpotNmethod_compileIdSnapshot(obj);
1484     if (compile_id_snapshot != 0L) {
1485       // Found a live nmethod with the same address, make sure it's the same nmethod
1486       if (nm == (nmethod*) code &amp;&amp; nm-&gt;compile_id() == compile_id_snapshot &amp;&amp; nm-&gt;is_alive()) {
1487         if (nm-&gt;is_not_entrant()) {
1488           // Zero the entry point so that the nmethod
1489           // cannot be invoked by the mirror but can
1490           // still be deoptimized.
1491           set_InstalledCode_entryPoint(obj, 0);
1492         }
1493         return nm;
1494       }
1495       // The HotSpotNmethod no longer refers to a valid nmethod so clear the state
1496       locker.set_code(NULL);
1497       nm = NULL;
1498     }
1499 
1500     if (nm == NULL) {
1501       // The HotSpotNmethod was pointing at some nmethod but the nmethod is no longer valid, so
1502       // clear the InstalledCode fields of this HotSpotNmethod so that it no longer refers to a
1503       // nmethod in the code cache.
1504       set_InstalledCode_address(obj, 0);
1505       set_InstalledCode_entryPoint(obj, 0);
1506     }
1507     return nm;
1508   }
1509 
1510   CodeBlob* cb = (CodeBlob*) code;
1511   assert(!cb-&gt;is_nmethod(), "unexpected nmethod");
1512   return cb;
1513 }
1514 
1515 nmethod* JVMCIEnv::get_nmethod(JVMCIObject obj, nmethodLocker&amp; locker) {
1516   CodeBlob* cb = get_code_blob(obj, locker);
1517   if (cb != NULL) {
1518     return cb-&gt;as_nmethod_or_null();
1519   }
1520   return NULL;
1521 }
1522 
1523 // Generate implementations for the initialize, new, isa, get and set methods for all the types and
1524 // fields declared in the JVMCI_CLASSES_DO macro.
1525 
1526 #define START_CLASS(className, fullClassName)                                                                        \
1527   void JVMCIEnv::className##_initialize(JVMCI_TRAPS) {                                                               \
1528     if (is_hotspot()) {                                                                                              \
1529       HotSpotJVMCI::className::initialize(JVMCI_CHECK);                                                              \
1530     } else {                                                                                                         \
1531       JNIJVMCI::className::initialize(JVMCI_CHECK);                                                                  \
1532     }                                                                                                                \
1533   }                                                                                                                  \
1534   JVMCIObjectArray JVMCIEnv::new_##className##_array(int length, JVMCI_TRAPS) {                                      \
1535     if (is_hotspot()) {                                                                                              \
1536       Thread* THREAD = Thread::current();                                                                            \
1537       objArrayOop array = oopFactory::new_objArray(HotSpotJVMCI::className::klass(), length, CHECK_(JVMCIObject())); \
1538       return (JVMCIObjectArray) wrap(array);                                                                         \
1539     } else {                                                                                                         \
1540       JNIAccessMark jni(this);                                                                                       \
1541       jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::className::clazz(), NULL);                       \
1542       return wrap(result);                                                                                           \
1543     }                                                                                                                \
1544   }                                                                                                                  \
1545   bool JVMCIEnv::isa_##className(JVMCIObject object) {                                                               \
1546     if (is_hotspot()) {                                                                                              \
1547       return HotSpotJVMCI::className::is_instance(this, object);                                                     \
1548     } else {                                                                                                         \
1549       return JNIJVMCI::className::is_instance(this, object);                                                         \
1550     }                                                                                                                \
1551   }
1552 
1553 #define END_CLASS
1554 
1555 #define FIELD(className, name, type, accessor, cast)                 \
1556   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {         \
1557     if (is_hotspot()) {                                              \
1558       return HotSpotJVMCI::className::get_##name(this, obj);         \
1559     } else {                                                         \
1560       return JNIJVMCI::className::get_##name(this, obj);             \
1561     }                                                                \
1562   }                                                                  \
1563   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) { \
1564     if (is_hotspot()) {                                              \
1565       HotSpotJVMCI::className::set_##name(this, obj, x);             \
1566     } else {                                                         \
1567       JNIJVMCI::className::set_##name(this, obj, x);                 \
1568     }                                                                \
1569   }
1570 
1571 #define EMPTY_CAST
1572 #define CHAR_FIELD(className, name)                    FIELD(className, name, jchar, Char, EMPTY_CAST)
1573 #define INT_FIELD(className, name)                     FIELD(className, name, jint, Int, EMPTY_CAST)
1574 #define BOOLEAN_FIELD(className, name)                 FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
1575 #define LONG_FIELD(className, name)                    FIELD(className, name, jlong, Long, EMPTY_CAST)
1576 #define FLOAT_FIELD(className, name)                   FIELD(className, name, jfloat, Float, EMPTY_CAST)
1577 
1578 #define OBJECT_FIELD(className, name, signature)              OOPISH_FIELD(className, name, JVMCIObject, Object, EMPTY_CAST)
1579 #define OBJECTARRAY_FIELD(className, name, signature)         OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
1580 #define PRIMARRAY_FIELD(className, name, signature)           OOPISH_FIELD(className, name, JVMCIPrimitiveArray, Object, (JVMCIPrimitiveArray))
1581 
1582 #define STATIC_OBJECT_FIELD(className, name, signature)       STATIC_OOPISH_FIELD(className, name, JVMCIObject, Object, (JVMCIObject))
1583 #define STATIC_OBJECTARRAY_FIELD(className, name, signature)  STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
1584 
1585 #define OOPISH_FIELD(className, name, type, accessor, cast)           \
1586   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {          \
1587     if (is_hotspot()) {                                               \
1588       return HotSpotJVMCI::className::get_##name(this, obj);          \
1589     } else {                                                          \
1590       return JNIJVMCI::className::get_##name(this, obj);              \
1591     }                                                                 \
1592   }                                                                   \
1593   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) {  \
1594     if (is_hotspot()) {                                               \
1595       HotSpotJVMCI::className::set_##name(this, obj, x);              \
1596     } else {                                                          \
1597       JNIJVMCI::className::set_##name(this, obj, x);                  \
1598     }                                                                 \
1599   }
1600 
1601 #define STATIC_OOPISH_FIELD(className, name, type, accessor, cast)    \
1602   type JVMCIEnv::get_##className##_##name() {                         \
1603     if (is_hotspot()) {                                               \
1604       return HotSpotJVMCI::className::get_##name(this);               \
1605     } else {                                                          \
1606       return JNIJVMCI::className::get_##name(this);                   \
1607     }                                                                 \
1608   }                                                                   \
1609   void JVMCIEnv::set_##className##_##name(type x) {                   \
1610     if (is_hotspot()) {                                               \
1611       HotSpotJVMCI::className::set_##name(this, x);                   \
1612     } else {                                                          \
1613       JNIJVMCI::className::set_##name(this, x);                       \
1614     }                                                                 \
1615   }
1616 
1617 #define STATIC_PRIMITIVE_FIELD(className, name, type, accessor, cast) \
1618   type JVMCIEnv::get_##className##_##name() {                         \
1619     if (is_hotspot()) {                                               \
1620       return HotSpotJVMCI::className::get_##name(this);               \
1621     } else {                                                          \
1622       return JNIJVMCI::className::get_##name(this);                   \
1623     }                                                                 \
1624   }                                                                   \
1625   void JVMCIEnv::set_##className##_##name(type x) {                   \
1626     if (is_hotspot()) {                                               \
1627       HotSpotJVMCI::className::set_##name(this, x);                   \
1628     } else {                                                          \
1629       JNIJVMCI::className::set_##name(this, x);                       \
1630     }                                                                 \
1631   }
1632 #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint, Int, EMPTY_CAST)
1633 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
1634 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
1635 #define CONSTRUCTOR(className, signature)
1636 
1637 JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
1638 
1639 #undef START_CLASS
1640 #undef END_CLASS
1641 #undef METHOD
1642 #undef CONSTRUCTOR
1643 #undef FIELD
1644 #undef CHAR_FIELD
1645 #undef INT_FIELD
1646 #undef BOOLEAN_FIELD
1647 #undef LONG_FIELD
1648 #undef FLOAT_FIELD
1649 #undef OBJECT_FIELD
1650 #undef PRIMARRAY_FIELD
1651 #undef OBJECTARRAY_FIELD
1652 #undef STATIC_OOPISH_FIELD
1653 #undef STATIC_OBJECT_FIELD
1654 #undef STATIC_OBJECTARRAY_FIELD
1655 #undef STATIC_INT_FIELD
1656 #undef STATIC_BOOLEAN_FIELD
1657 #undef EMPTY_CAST
<a name="71" id="anc71"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="71" type="hidden" /></form></body></html>
