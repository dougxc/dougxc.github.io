<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>open Sdiff src/hotspot/share/jvmci </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/hotspot/share/jvmci/jvmciJavaClasses.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/jvmci/jvmciRuntime.hpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/jvmci/jvmciRuntime.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-59942">59942</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8248359">8248359</a>: [JVMCI] miscellaneous code cleanups and improvements</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "classfile/symbolTable.hpp"
  27 #include "compiler/compileBroker.hpp"


  28 #include "jvmci/jniAccessMark.inline.hpp"
  29 #include "jvmci/jvmciCompilerToVM.hpp"
  30 #include "jvmci/jvmciRuntime.hpp"

  31 #include "logging/log.hpp"
  32 #include "memory/oopFactory.hpp"
  33 #include "memory/universe.hpp"
  34 #include "oops/constantPool.inline.hpp"
  35 #include "oops/method.inline.hpp"
  36 #include "oops/objArrayKlass.hpp"
  37 #include "oops/oop.inline.hpp"

  38 #include "runtime/atomic.hpp"
  39 #include "runtime/biasedLocking.hpp"
  40 #include "runtime/deoptimization.hpp"
  41 #include "runtime/fieldDescriptor.inline.hpp"
  42 #include "runtime/frame.inline.hpp"

  43 #include "runtime/sharedRuntime.hpp"
  44 #if INCLUDE_G1GC
  45 #include "gc/g1/g1ThreadLocalData.hpp"
  46 #endif // INCLUDE_G1GC
  47 
  48 // Simple helper to see if the caller of a runtime stub which
  49 // entered the VM has been deoptimized
  50 
  51 static bool caller_is_deopted() {
  52   JavaThread* thread = JavaThread::current();
  53   RegisterMap reg_map(thread, false);
  54   frame runtime_frame = thread-&gt;last_frame();
  55   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  56   assert(caller_frame.is_compiled_frame(), "must be compiled");
  57   return caller_frame.is_deoptimized_frame();
  58 }
  59 
  60 // Stress deoptimization
  61 static void deopt_caller() {
  62   if ( !caller_is_deopted()) {

</pre><hr></hr><pre>
 688   // We cannot use JVMCIObject to wrap the mirror as this is called
 689   // during GC, forbidding the creation of JNIHandles.
 690   JVMCIEnv* jvmciEnv = NULL;
 691   nmethod* current = (nmethod*) HotSpotJVMCI::InstalledCode::address(jvmciEnv, nmethod_mirror);
 692   if (nm == current) {
 693     if (!nm-&gt;is_alive()) {
 694       // Break the link from the mirror to nm such that
 695       // future invocations via the mirror will result in
 696       // an InvalidInstalledCodeException.
 697       HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, 0);
 698       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 699     } else if (nm-&gt;is_not_entrant()) {
 700       // Zero the entry point so any new invocation will fail but keep
 701       // the address link around that so that existing activations can
 702       // be deoptimized via the mirror (i.e. JVMCIEnv::invalidate_installed_code).
 703       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 704     }
 705   }
 706 }
 707 






















































































































































 708 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 709   if (is_HotSpotJVMCIRuntime_initialized()) {
 710     if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {
 711       JVMCI_THROW_MSG(InternalError, "JVMCI has already been enabled in the JVMCI shared library");
 712     }
 713   }
 714 
 715   initialize(JVMCIENV);
 716 
 717   // This should only be called in the context of the JVMCI class being initialized
 718   JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
 719 
 720   _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);

 721 }
 722 
 723 void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {
<span class="removed"> 724   assert(this != NULL, "sanity");</span>
 725   // Check first without JVMCI_lock
<span class="changed"> 726   if (_initialized) {</span>
 727     return;
 728   }
 729 
 730   MutexLocker locker(JVMCI_lock);
 731   // Check again under JVMCI_lock
<span class="changed"> 732   if (_initialized) {</span>
 733     return;
 734   }
 735 
<span class="changed"> 736   while (_being_initialized) {</span>

 737     JVMCI_lock-&gt;wait();
<span class="changed"> 738     if (_initialized) {</span>

 739       return;
 740     }
 741   }
 742 
<span class="changed"> 743   _being_initialized = true;</span>

 744 
 745   {
 746     MutexUnlocker unlock(JVMCI_lock);
 747 
 748     HandleMark hm;
 749     ResourceMark rm;
 750     JavaThread* THREAD = JavaThread::current();
 751     if (JVMCIENV-&gt;is_hotspot()) {
 752       HotSpotJVMCI::compute_offsets(CHECK_EXIT);
 753     } else {
 754       JNIAccessMark jni(JVMCIENV);
 755 
 756       JNIJVMCI::initialize_ids(jni.env());
 757       if (jni()-&gt;ExceptionCheck()) {
 758         jni()-&gt;ExceptionDescribe();
 759         fatal("JNI exception during init");
 760       }
 761     }





 762     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));
 763     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));
 764     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));
 765     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));
 766     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));
 767     create_jvmci_primitive_type(T_LONG, JVMCI_CHECK_EXIT_((void)0));
 768     create_jvmci_primitive_type(T_FLOAT, JVMCI_CHECK_EXIT_((void)0));
 769     create_jvmci_primitive_type(T_DOUBLE, JVMCI_CHECK_EXIT_((void)0));
 770     create_jvmci_primitive_type(T_VOID, JVMCI_CHECK_EXIT_((void)0));
 771 
 772     if (!JVMCIENV-&gt;is_hotspot()) {
 773       JVMCIENV-&gt;copy_saved_properties();
 774     }
 775   }
 776 
<span class="changed"> 777   _initialized = true;</span>
<span class="changed"> 778   _being_initialized = false;</span>
 779   JVMCI_lock-&gt;notify_all();
 780 }
 781 
 782 JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
 783   Thread* THREAD = Thread::current();
 784   // These primitive types are long lived and are created before the runtime is fully set up
 785   // so skip registering them for scanning.
 786   JVMCIObject mirror = JVMCIENV-&gt;get_object_constant(java_lang_Class::primitive_mirror(type), false, true);
 787   if (JVMCIENV-&gt;is_hotspot()) {
 788     JavaValue result(T_OBJECT);
 789     JavaCallArguments args;
 790     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(mirror)));
 791     args.push_int(type2char(type));
 792     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedPrimitiveType::klass(), vmSymbols::fromMetaspace_name(), vmSymbols::primitive_fromMetaspace_signature(), &amp;args, CHECK_(JVMCIObject()));
 793 
 794     return JVMCIENV-&gt;wrap(JNIHandles::make_local((oop)result.get_jobject()));
 795   } else {
 796     JNIAccessMark jni(JVMCIENV);
 797     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedPrimitiveType::clazz(),
 798                                            JNIJVMCI::HotSpotResolvedPrimitiveType_fromMetaspace_method(),

</pre><hr></hr><pre>
 800     if (jni()-&gt;ExceptionCheck()) {
 801       return JVMCIObject();
 802     }
 803     return JVMCIENV-&gt;wrap(result);
 804   }
 805 }
 806 
 807 void JVMCIRuntime::initialize_JVMCI(JVMCI_TRAPS) {
 808   if (!is_HotSpotJVMCIRuntime_initialized()) {
 809     initialize(JVMCI_CHECK);
 810     JVMCIENV-&gt;call_JVMCI_getRuntime(JVMCI_CHECK);
 811   }
 812 }
 813 
 814 JVMCIObject JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 815   initialize(JVMCIENV);
 816   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
 817   return _HotSpotJVMCIRuntime_instance;
 818 }
 819 
<span class="changed"> 820 </span>
<span class="changed"> 821 // private void CompilerToVM.registerNatives()</span>
 822 JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
 823   JNI_JVMCIENV(thread, env);
 824 
 825   if (!EnableJVMCI) {
 826     JVMCI_THROW_MSG(InternalError, "JVMCI is not enabled");
 827   }
 828 
 829   JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
 830 
 831   {
 832     ResourceMark rm;
 833     HandleMark hm(thread);
 834     ThreadToNativeFromVM trans(thread);
 835 
 836     // Ensure _non_oop_bits is initialized
 837     Universe::non_oop_word();
 838 
 839     if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count())) {
 840       if (!env-&gt;ExceptionCheck()) {
 841         for (int i = 0; i &lt; CompilerToVM::methods_count(); i++) {
 842           if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods + i, 1)) {
 843             guarantee(false, "Error registering JNI method %s%s", CompilerToVM::methods[i].name, CompilerToVM::methods[i].signature);
 844             break;
 845           }
 846         }
 847       } else {
 848         env-&gt;ExceptionDescribe();
 849       }
 850       guarantee(false, "Failed registering CompilerToVM native methods");
 851     }
 852   }
 853 JVM_END
 854 
 855 
 856 void JVMCIRuntime::shutdown() {
<span class="changed"> 857   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
<span class="changed"> 858     _shutdown_called = true;</span>
<span class="changed"> 859 </span>
<span class="changed"> 860     THREAD_JVMCIENV(JavaThread::current());</span>
<span class="changed"> 861     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);</span>









 862   }
 863 }
 864 
 865 void JVMCIRuntime::bootstrap_finished(TRAPS) {
<span class="changed"> 866   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
 867     THREAD_JVMCIENV(JavaThread::current());
 868     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
 869   }
 870 }
 871 
 872 void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {
 873   if (HAS_PENDING_EXCEPTION) {
 874     Handle exception(THREAD, PENDING_EXCEPTION);
 875     const char* exception_file = THREAD-&gt;exception_file();
 876     int exception_line = THREAD-&gt;exception_line();
 877     CLEAR_PENDING_EXCEPTION;
 878     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 879       // Don't print anything if we are being killed.
 880     } else {
 881       java_lang_Throwable::print_stack_trace(exception, tty);
 882 
 883       // Clear and ignore any exceptions raised during printing
 884       CLEAR_PENDING_EXCEPTION;
 885     }
 886     if (!clear) {

</pre><hr></hr><pre>
1273   // Only report a fatal JVMCI compilation exception once
1274   static volatile int report_init_failure = 0;
1275   if (!report_init_failure &amp;&amp; Atomic::cmpxchg(&amp;report_init_failure, 0, 1) == 0) {
1276       tty-&gt;print_cr("%s:", msg);
1277       JVMCIENV-&gt;describe_pending_exception(true);
1278   }
1279   JVMCIENV-&gt;clear_pending_exception();
1280   before_exit(thread);
1281   vm_exit(-1);
1282 }
1283 
1284 void JVMCIRuntime::compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; method, int entry_bci) {
1285   JVMCI_EXCEPTION_CONTEXT
1286 
1287   JVMCICompileState* compile_state = JVMCIENV-&gt;compile_state();
1288 
1289   bool is_osr = entry_bci != InvocationEntryBci;
1290   if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {
1291     // no OSR compilations during bootstrap - the compiler is just too slow at this point,
1292     // and we know that there are no endless loops
<span class="changed">1293     compile_state-&gt;set_failure(true, "No OSR during boostrap");</span>
1294     return;
1295   }
<span class="changed">1296   if (JVMCI::shutdown_called()) {</span>
1297     compile_state-&gt;set_failure(false, "Avoiding compilation during shutdown");
1298     return;
1299   }
1300 
1301   HandleMark hm;
1302   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);
1303   if (JVMCIENV-&gt;has_pending_exception()) {
1304     fatal_exception_in_compile(JVMCIENV, thread, "Exception during HotSpotJVMCIRuntime initialization");
1305   }
1306   JVMCIObject jvmci_method = JVMCIENV-&gt;get_jvmci_method(method, JVMCIENV);
1307   if (JVMCIENV-&gt;has_pending_exception()) {
1308     JVMCIENV-&gt;describe_pending_exception(true);
1309     compile_state-&gt;set_failure(false, "exception getting JVMCI wrapper method");
1310     return;
1311   }
1312 
1313   JVMCIObject result_object = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_compileMethod(receiver, jvmci_method, entry_bci,
1314                                                                      (jlong) compile_state, compile_state-&gt;task()-&gt;compile_id());
1315   if (!JVMCIENV-&gt;has_pending_exception()) {
1316     if (result_object.is_non_null()) {

</pre><hr></hr><pre>
1504         }
1505       }
1506       result = nm != NULL ? JVMCI::ok :JVMCI::cache_full;
1507     }
1508   }
1509 
1510   // String creation must be done outside lock
1511   if (failure_detail != NULL) {
1512     // A failure to allocate the string is silently ignored.
1513     JVMCIObject message = JVMCIENV-&gt;create_string(failure_detail, JVMCIENV);
1514     JVMCIENV-&gt;set_HotSpotCompiledNmethod_installationFailureMessage(compiled_code, message);
1515   }
1516 
1517   // JVMTI -- compiled method notification (must be done outside lock)
1518   if (nm != NULL) {
1519     nm-&gt;post_compiled_method_load_event();
1520   }
1521 
1522   return result;
1523 }











</pre></td><td><pre>

</pre><hr></hr><pre>
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "classfile/symbolTable.hpp"
  27 #include "compiler/compileBroker.hpp"
<span class="new">  28 #include "gc/shared/oopStorage.inline.hpp"</span>
<span class="new">  29 #include "gc/shared/oopStorageSet.hpp"</span>
  30 #include "jvmci/jniAccessMark.inline.hpp"
  31 #include "jvmci/jvmciCompilerToVM.hpp"
  32 #include "jvmci/jvmciRuntime.hpp"
<span class="new">  33 #include "jvmci/metadataHandles.hpp"</span>
  34 #include "logging/log.hpp"
  35 #include "memory/oopFactory.hpp"
  36 #include "memory/universe.hpp"
  37 #include "oops/constantPool.inline.hpp"
  38 #include "oops/method.inline.hpp"
  39 #include "oops/objArrayKlass.hpp"
  40 #include "oops/oop.inline.hpp"
<span class="new">  41 #include "oops/typeArrayOop.inline.hpp"</span>
  42 #include "runtime/atomic.hpp"
  43 #include "runtime/biasedLocking.hpp"
  44 #include "runtime/deoptimization.hpp"
  45 #include "runtime/fieldDescriptor.inline.hpp"
  46 #include "runtime/frame.inline.hpp"
<span class="new">  47 #include "runtime/jniHandles.inline.hpp"</span>
  48 #include "runtime/sharedRuntime.hpp"
  49 #if INCLUDE_G1GC
  50 #include "gc/g1/g1ThreadLocalData.hpp"
  51 #endif // INCLUDE_G1GC
  52 
  53 // Simple helper to see if the caller of a runtime stub which
  54 // entered the VM has been deoptimized
  55 
  56 static bool caller_is_deopted() {
  57   JavaThread* thread = JavaThread::current();
  58   RegisterMap reg_map(thread, false);
  59   frame runtime_frame = thread-&gt;last_frame();
  60   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  61   assert(caller_frame.is_compiled_frame(), "must be compiled");
  62   return caller_frame.is_deoptimized_frame();
  63 }
  64 
  65 // Stress deoptimization
  66 static void deopt_caller() {
  67   if ( !caller_is_deopted()) {

</pre><hr></hr><pre>
 693   // We cannot use JVMCIObject to wrap the mirror as this is called
 694   // during GC, forbidding the creation of JNIHandles.
 695   JVMCIEnv* jvmciEnv = NULL;
 696   nmethod* current = (nmethod*) HotSpotJVMCI::InstalledCode::address(jvmciEnv, nmethod_mirror);
 697   if (nm == current) {
 698     if (!nm-&gt;is_alive()) {
 699       // Break the link from the mirror to nm such that
 700       // future invocations via the mirror will result in
 701       // an InvalidInstalledCodeException.
 702       HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, 0);
 703       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 704     } else if (nm-&gt;is_not_entrant()) {
 705       // Zero the entry point so any new invocation will fail but keep
 706       // the address link around that so that existing activations can
 707       // be deoptimized via the mirror (i.e. JVMCIEnv::invalidate_installed_code).
 708       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 709     }
 710   }
 711 }
 712 
<span class="new"> 713 JVMCIRuntime::JVMCIRuntime(int id) {</span>
<span class="new"> 714   _init_state = uninitialized;</span>
<span class="new"> 715   _shared_library_javavm = NULL;</span>
<span class="new"> 716   _id = id;</span>
<span class="new"> 717   _metadata_handles = new MetadataHandles();</span>
<span class="new"> 718   TRACE_jvmci_1("created new JVMCI runtime %d (" PTR_FORMAT ")", id, p2i(this));</span>
<span class="new"> 719 }</span>
<span class="new"> 720 </span>
<span class="new"> 721 // Handles to objects in the Hotspot heap.</span>
<span class="new"> 722 static OopStorage* object_handles() {</span>
<span class="new"> 723   return OopStorageSet::vm_global();</span>
<span class="new"> 724 }</span>
<span class="new"> 725 </span>
<span class="new"> 726 jobject JVMCIRuntime::make_global(const Handle&amp; obj) {</span>
<span class="new"> 727   assert(!Universe::heap()-&gt;is_gc_active(), "can't extend the root set during GC");</span>
<span class="new"> 728   assert(oopDesc::is_oop(obj()), "not an oop");</span>
<span class="new"> 729   oop* ptr = object_handles()-&gt;allocate();</span>
<span class="new"> 730   jobject res = NULL;</span>
<span class="new"> 731   if (ptr != NULL) {</span>
<span class="new"> 732     assert(*ptr == NULL, "invariant");</span>
<span class="new"> 733     NativeAccess&lt;&gt;::oop_store(ptr, obj());</span>
<span class="new"> 734     res = reinterpret_cast&lt;jobject&gt;(ptr);</span>
<span class="new"> 735   } else {</span>
<span class="new"> 736     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,</span>
<span class="new"> 737                           "Cannot create JVMCI oop handle");</span>
<span class="new"> 738   }</span>
<span class="new"> 739   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 740   return res;</span>
<span class="new"> 741 }</span>
<span class="new"> 742 </span>
<span class="new"> 743 void JVMCIRuntime::destroy_global(jobject handle) {</span>
<span class="new"> 744   // Assert before nulling out, for better debugging.</span>
<span class="new"> 745   assert(is_global_handle(handle), "precondition");</span>
<span class="new"> 746   oop* oop_ptr = reinterpret_cast&lt;oop*&gt;(handle);</span>
<span class="new"> 747   NativeAccess&lt;&gt;::oop_store(oop_ptr, (oop)NULL);</span>
<span class="new"> 748   object_handles()-&gt;release(oop_ptr);</span>
<span class="new"> 749   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 750 }</span>
<span class="new"> 751 </span>
<span class="new"> 752 bool JVMCIRuntime::is_global_handle(jobject handle) {</span>
<span class="new"> 753   const oop* ptr = reinterpret_cast&lt;oop*&gt;(handle);</span>
<span class="new"> 754   return object_handles()-&gt;allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;</span>
<span class="new"> 755 }</span>
<span class="new"> 756 </span>
<span class="new"> 757 jmetadata JVMCIRuntime::allocate_handle(const methodHandle&amp; handle) {</span>
<span class="new"> 758   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 759   return _metadata_handles-&gt;allocate_handle(handle);</span>
<span class="new"> 760 }</span>
<span class="new"> 761 </span>
<span class="new"> 762 jmetadata JVMCIRuntime::allocate_handle(const constantPoolHandle&amp; handle) {</span>
<span class="new"> 763   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 764   return _metadata_handles-&gt;allocate_handle(handle);</span>
<span class="new"> 765 }</span>
<span class="new"> 766 </span>
<span class="new"> 767 void JVMCIRuntime::release_handle(jmetadata handle) {</span>
<span class="new"> 768   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 769   _metadata_handles-&gt;chain_free_list(handle);</span>
<span class="new"> 770 }</span>
<span class="new"> 771 </span>
<span class="new"> 772 JNIEnv* JVMCIRuntime::init_shared_library_javavm() {</span>
<span class="new"> 773   JavaVM* javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 774   if (javaVM == NULL) {</span>
<span class="new"> 775     MutexLocker locker(JVMCI_lock);</span>
<span class="new"> 776     // Check again under JVMCI_lock</span>
<span class="new"> 777     javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 778     if (javaVM != NULL) {</span>
<span class="new"> 779       return NULL;</span>
<span class="new"> 780     }</span>
<span class="new"> 781     char* sl_path;</span>
<span class="new"> 782     void* sl_handle = JVMCI::get_shared_library(sl_path, true);</span>
<span class="new"> 783 </span>
<span class="new"> 784     jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);</span>
<span class="new"> 785     typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);</span>
<span class="new"> 786 </span>
<span class="new"> 787     JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(sl_handle, "JNI_CreateJavaVM"));</span>
<span class="new"> 788     if (JNI_CreateJavaVM == NULL) {</span>
<span class="new"> 789       vm_exit_during_initialization("Unable to find JNI_CreateJavaVM", sl_path);</span>
<span class="new"> 790     }</span>
<span class="new"> 791 </span>
<span class="new"> 792     ResourceMark rm;</span>
<span class="new"> 793     JavaVMInitArgs vm_args;</span>
<span class="new"> 794     vm_args.version = JNI_VERSION_1_2;</span>
<span class="new"> 795     vm_args.ignoreUnrecognized = JNI_TRUE;</span>
<span class="new"> 796     JavaVMOption options[1];</span>
<span class="new"> 797     jlong javaVM_id = 0;</span>
<span class="new"> 798 </span>
<span class="new"> 799     // Protocol: JVMCI shared library JavaVM should support a non-standard "_javavm_id"</span>
<span class="new"> 800     // option whose extraInfo info field is a pointer to which a unique id for the</span>
<span class="new"> 801     // JavaVM should be written.</span>
<span class="new"> 802     options[0].optionString = (char*) "_javavm_id";</span>
<span class="new"> 803     options[0].extraInfo = &amp;javaVM_id;</span>
<span class="new"> 804 </span>
<span class="new"> 805     vm_args.version = JNI_VERSION_1_2;</span>
<span class="new"> 806     vm_args.options = options;</span>
<span class="new"> 807     vm_args.nOptions = sizeof(options) / sizeof(JavaVMOption);</span>
<span class="new"> 808 </span>
<span class="new"> 809     JNIEnv* env = NULL;</span>
<span class="new"> 810     int result = (*JNI_CreateJavaVM)(&amp;javaVM, (void**) &amp;env, &amp;vm_args);</span>
<span class="new"> 811     if (result == JNI_OK) {</span>
<span class="new"> 812       guarantee(env != NULL, "missing env");</span>
<span class="new"> 813       _shared_library_javavm = javaVM;</span>
<span class="new"> 814       TRACE_jvmci_1("created JavaVM[%ld]@" PTR_FORMAT " for JVMCI runtime %d", javaVM_id, p2i(javaVM), _id);</span>
<span class="new"> 815       return env;</span>
<span class="new"> 816     } else {</span>
<span class="new"> 817       vm_exit_during_initialization(err_msg("JNI_CreateJavaVM failed with return value %d", result), sl_path);</span>
<span class="new"> 818     }</span>
<span class="new"> 819   }</span>
<span class="new"> 820   return NULL;</span>
<span class="new"> 821 }</span>
<span class="new"> 822 </span>
<span class="new"> 823 void JVMCIRuntime::init_JavaVM_info(jlongArray info, JVMCI_TRAPS) {</span>
<span class="new"> 824   if (info != NULL) {</span>
<span class="new"> 825     typeArrayOop info_oop = (typeArrayOop) JNIHandles::resolve(info);</span>
<span class="new"> 826     if (info_oop-&gt;length() &lt; 4) {</span>
<span class="new"> 827       JVMCI_THROW_MSG(ArrayIndexOutOfBoundsException, err_msg("%d &lt; 4", info_oop-&gt;length()));</span>
<span class="new"> 828     }</span>
<span class="new"> 829     JavaVM* javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 830     info_oop-&gt;long_at_put(0, (jlong) (address) javaVM);</span>
<span class="new"> 831     info_oop-&gt;long_at_put(1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);</span>
<span class="new"> 832     info_oop-&gt;long_at_put(2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);</span>
<span class="new"> 833     info_oop-&gt;long_at_put(3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);</span>
<span class="new"> 834   }</span>
<span class="new"> 835 }</span>
<span class="new"> 836 </span>
<span class="new"> 837 #define JAVAVM_CALL_BLOCK                                             \</span>
<span class="new"> 838   guarantee(thread != NULL &amp;&amp; _shared_library_javavm != NULL, "npe"); \</span>
<span class="new"> 839   ThreadToNativeFromVM ttnfv(thread);                                 \</span>
<span class="new"> 840   JavaVM* javavm = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 841 </span>
<span class="new"> 842 jint JVMCIRuntime::AttachCurrentThread(JavaThread* thread, void **penv, void *args) {</span>
<span class="new"> 843   JAVAVM_CALL_BLOCK</span>
<span class="new"> 844   return javavm-&gt;AttachCurrentThread(penv, args);</span>
<span class="new"> 845 }</span>
<span class="new"> 846 </span>
<span class="new"> 847 jint JVMCIRuntime::AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args) {</span>
<span class="new"> 848   JAVAVM_CALL_BLOCK</span>
<span class="new"> 849   return javavm-&gt;AttachCurrentThreadAsDaemon(penv, args);</span>
<span class="new"> 850 }</span>
<span class="new"> 851 </span>
<span class="new"> 852 jint JVMCIRuntime::DetachCurrentThread(JavaThread* thread) {</span>
<span class="new"> 853   JAVAVM_CALL_BLOCK</span>
<span class="new"> 854   return javavm-&gt;DetachCurrentThread();</span>
<span class="new"> 855 }</span>
<span class="new"> 856 </span>
<span class="new"> 857 jint JVMCIRuntime::GetEnv(JavaThread* thread, void **penv, jint version) {</span>
<span class="new"> 858   JAVAVM_CALL_BLOCK</span>
<span class="new"> 859   return javavm-&gt;GetEnv(penv, version);</span>
<span class="new"> 860 }</span>
<span class="new"> 861 #undef JAVAVM_CALL_BLOCK                                             \</span>
<span class="new"> 862 </span>
 863 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 864   if (is_HotSpotJVMCIRuntime_initialized()) {
 865     if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {
 866       JVMCI_THROW_MSG(InternalError, "JVMCI has already been enabled in the JVMCI shared library");
 867     }
 868   }
 869 
 870   initialize(JVMCIENV);
 871 
 872   // This should only be called in the context of the JVMCI class being initialized
 873   JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
 874 
 875   _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);
<span class="new"> 876   JVMCI::_is_initialized = true;</span>
 877 }
 878 
 879 void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {

 880   // Check first without JVMCI_lock
<span class="changed"> 881   if (_init_state == fully_initialized) {</span>
 882     return;
 883   }
 884 
 885   MutexLocker locker(JVMCI_lock);
 886   // Check again under JVMCI_lock
<span class="changed"> 887   if (_init_state == fully_initialized) {</span>
 888     return;
 889   }
 890 
<span class="changed"> 891   while (_init_state == being_initialized) {</span>
<span class="changed"> 892     TRACE_jvmci_1("waiting for initialization of JVMCI runtime %d", _id);</span>
 893     JVMCI_lock-&gt;wait();
<span class="changed"> 894     if (_init_state == fully_initialized) {</span>
<span class="changed"> 895       TRACE_jvmci_1("done waiting for initialization of JVMCI runtime %d", _id);</span>
 896       return;
 897     }
 898   }
 899 
<span class="changed"> 900   TRACE_jvmci_1("initializing JVMCI runtime %d", _id);</span>
<span class="changed"> 901   _init_state = being_initialized;</span>
 902 
 903   {
 904     MutexUnlocker unlock(JVMCI_lock);
 905 
 906     HandleMark hm;
 907     ResourceMark rm;
 908     JavaThread* THREAD = JavaThread::current();
 909     if (JVMCIENV-&gt;is_hotspot()) {
 910       HotSpotJVMCI::compute_offsets(CHECK_EXIT);
 911     } else {
 912       JNIAccessMark jni(JVMCIENV);
 913 
 914       JNIJVMCI::initialize_ids(jni.env());
 915       if (jni()-&gt;ExceptionCheck()) {
 916         jni()-&gt;ExceptionDescribe();
 917         fatal("JNI exception during init");
 918       }
 919     }
<span class="new"> 920 </span>
<span class="new"> 921     if (!JVMCIENV-&gt;is_hotspot()) {</span>
<span class="new"> 922       JNIAccessMark jni(JVMCIENV, THREAD);</span>
<span class="new"> 923       JNIJVMCI::register_natives(jni.env());</span>
<span class="new"> 924     }</span>
 925     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));
 926     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));
 927     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));
 928     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));
 929     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));
 930     create_jvmci_primitive_type(T_LONG, JVMCI_CHECK_EXIT_((void)0));
 931     create_jvmci_primitive_type(T_FLOAT, JVMCI_CHECK_EXIT_((void)0));
 932     create_jvmci_primitive_type(T_DOUBLE, JVMCI_CHECK_EXIT_((void)0));
 933     create_jvmci_primitive_type(T_VOID, JVMCI_CHECK_EXIT_((void)0));
 934 
 935     if (!JVMCIENV-&gt;is_hotspot()) {
 936       JVMCIENV-&gt;copy_saved_properties();
 937     }
 938   }
 939 
<span class="changed"> 940   _init_state = fully_initialized;</span>
<span class="changed"> 941   TRACE_jvmci_1("initialized JVMCI runtime %d", _id);</span>
 942   JVMCI_lock-&gt;notify_all();
 943 }
 944 
 945 JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
 946   Thread* THREAD = Thread::current();
 947   // These primitive types are long lived and are created before the runtime is fully set up
 948   // so skip registering them for scanning.
 949   JVMCIObject mirror = JVMCIENV-&gt;get_object_constant(java_lang_Class::primitive_mirror(type), false, true);
 950   if (JVMCIENV-&gt;is_hotspot()) {
 951     JavaValue result(T_OBJECT);
 952     JavaCallArguments args;
 953     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(mirror)));
 954     args.push_int(type2char(type));
 955     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedPrimitiveType::klass(), vmSymbols::fromMetaspace_name(), vmSymbols::primitive_fromMetaspace_signature(), &amp;args, CHECK_(JVMCIObject()));
 956 
 957     return JVMCIENV-&gt;wrap(JNIHandles::make_local((oop)result.get_jobject()));
 958   } else {
 959     JNIAccessMark jni(JVMCIENV);
 960     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedPrimitiveType::clazz(),
 961                                            JNIJVMCI::HotSpotResolvedPrimitiveType_fromMetaspace_method(),

</pre><hr></hr><pre>
 963     if (jni()-&gt;ExceptionCheck()) {
 964       return JVMCIObject();
 965     }
 966     return JVMCIENV-&gt;wrap(result);
 967   }
 968 }
 969 
 970 void JVMCIRuntime::initialize_JVMCI(JVMCI_TRAPS) {
 971   if (!is_HotSpotJVMCIRuntime_initialized()) {
 972     initialize(JVMCI_CHECK);
 973     JVMCIENV-&gt;call_JVMCI_getRuntime(JVMCI_CHECK);
 974   }
 975 }
 976 
 977 JVMCIObject JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 978   initialize(JVMCIENV);
 979   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
 980   return _HotSpotJVMCIRuntime_instance;
 981 }
 982 
<span class="changed"> 983 // private static void CompilerToVM.registerNatives()</span>

 984 JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
 985   JNI_JVMCIENV(thread, env);
 986 
 987   if (!EnableJVMCI) {
 988     JVMCI_THROW_MSG(InternalError, "JVMCI is not enabled");
 989   }
 990 
 991   JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
 992 
 993   {
 994     ResourceMark rm;
 995     HandleMark hm(thread);
 996     ThreadToNativeFromVM trans(thread);
 997 
 998     // Ensure _non_oop_bits is initialized
 999     Universe::non_oop_word();
1000 
1001     if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count())) {
1002       if (!env-&gt;ExceptionCheck()) {
1003         for (int i = 0; i &lt; CompilerToVM::methods_count(); i++) {
1004           if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods + i, 1)) {
1005             guarantee(false, "Error registering JNI method %s%s", CompilerToVM::methods[i].name, CompilerToVM::methods[i].signature);
1006             break;
1007           }
1008         }
1009       } else {
1010         env-&gt;ExceptionDescribe();
1011       }
1012       guarantee(false, "Failed registering CompilerToVM native methods");
1013     }
1014   }
1015 JVM_END
1016 
1017 
1018 void JVMCIRuntime::shutdown() {
<span class="changed">1019   JVMCIObject instance = _HotSpotJVMCIRuntime_instance;</span>
<span class="changed">1020   if (instance.is_non_null()) {</span>
<span class="changed">1021     TRACE_jvmci_1("shutting down JVMCI runtime %d", _id);</span>
<span class="changed">1022     _HotSpotJVMCIRuntime_instance = JVMCIObject();</span>
<span class="changed">1023     JVMCIEnv __stack_jvmci_env__(JavaThread::current(), instance.is_hotspot(), __FILE__, __LINE__);</span>
<span class="changed">1024     JVMCIEnv* JVMCIENV = &amp;__stack_jvmci_env__;</span>
<span class="changed">1025     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(instance);</span>
<span class="changed">1026     if (!instance.is_hotspot()) {</span>
<span class="changed">1027       // Need to keep the HotSpot based instance alive for the sake of</span>
<span class="changed">1028       // JVMCICompiler::force_comp_at_level_simple which can race with</span>
<span class="changed">1029       // shutting down the JVMCI runtime.</span>
<span class="changed">1030       JVMCIENV-&gt;destroy_global(instance);</span>
<span class="changed">1031     }</span>
<span class="changed">1032     TRACE_jvmci_1("shut down JVMCI runtime %d", _id);</span>
1033   }
1034 }
1035 
1036 void JVMCIRuntime::bootstrap_finished(TRAPS) {
<span class="changed">1037   if (_HotSpotJVMCIRuntime_instance.is_non_null()) {</span>
1038     THREAD_JVMCIENV(JavaThread::current());
1039     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
1040   }
1041 }
1042 
1043 void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {
1044   if (HAS_PENDING_EXCEPTION) {
1045     Handle exception(THREAD, PENDING_EXCEPTION);
1046     const char* exception_file = THREAD-&gt;exception_file();
1047     int exception_line = THREAD-&gt;exception_line();
1048     CLEAR_PENDING_EXCEPTION;
1049     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
1050       // Don't print anything if we are being killed.
1051     } else {
1052       java_lang_Throwable::print_stack_trace(exception, tty);
1053 
1054       // Clear and ignore any exceptions raised during printing
1055       CLEAR_PENDING_EXCEPTION;
1056     }
1057     if (!clear) {

</pre><hr></hr><pre>
1444   // Only report a fatal JVMCI compilation exception once
1445   static volatile int report_init_failure = 0;
1446   if (!report_init_failure &amp;&amp; Atomic::cmpxchg(&amp;report_init_failure, 0, 1) == 0) {
1447       tty-&gt;print_cr("%s:", msg);
1448       JVMCIENV-&gt;describe_pending_exception(true);
1449   }
1450   JVMCIENV-&gt;clear_pending_exception();
1451   before_exit(thread);
1452   vm_exit(-1);
1453 }
1454 
1455 void JVMCIRuntime::compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; method, int entry_bci) {
1456   JVMCI_EXCEPTION_CONTEXT
1457 
1458   JVMCICompileState* compile_state = JVMCIENV-&gt;compile_state();
1459 
1460   bool is_osr = entry_bci != InvocationEntryBci;
1461   if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {
1462     // no OSR compilations during bootstrap - the compiler is just too slow at this point,
1463     // and we know that there are no endless loops
<span class="changed">1464     compile_state-&gt;set_failure(true, "No OSR during bootstrap");</span>
1465     return;
1466   }
<span class="changed">1467   if (JVMCI::in_shutdown()) {</span>
1468     compile_state-&gt;set_failure(false, "Avoiding compilation during shutdown");
1469     return;
1470   }
1471 
1472   HandleMark hm;
1473   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);
1474   if (JVMCIENV-&gt;has_pending_exception()) {
1475     fatal_exception_in_compile(JVMCIENV, thread, "Exception during HotSpotJVMCIRuntime initialization");
1476   }
1477   JVMCIObject jvmci_method = JVMCIENV-&gt;get_jvmci_method(method, JVMCIENV);
1478   if (JVMCIENV-&gt;has_pending_exception()) {
1479     JVMCIENV-&gt;describe_pending_exception(true);
1480     compile_state-&gt;set_failure(false, "exception getting JVMCI wrapper method");
1481     return;
1482   }
1483 
1484   JVMCIObject result_object = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_compileMethod(receiver, jvmci_method, entry_bci,
1485                                                                      (jlong) compile_state, compile_state-&gt;task()-&gt;compile_id());
1486   if (!JVMCIENV-&gt;has_pending_exception()) {
1487     if (result_object.is_non_null()) {

</pre><hr></hr><pre>
1675         }
1676       }
1677       result = nm != NULL ? JVMCI::ok :JVMCI::cache_full;
1678     }
1679   }
1680 
1681   // String creation must be done outside lock
1682   if (failure_detail != NULL) {
1683     // A failure to allocate the string is silently ignored.
1684     JVMCIObject message = JVMCIENV-&gt;create_string(failure_detail, JVMCIENV);
1685     JVMCIENV-&gt;set_HotSpotCompiledNmethod_installationFailureMessage(compiled_code, message);
1686   }
1687 
1688   // JVMTI -- compiled method notification (must be done outside lock)
1689   if (nm != NULL) {
1690     nm-&gt;post_compiled_method_load_event();
1691   }
1692 
1693   return result;
1694 }
<span class="new">1695 </span>
<span class="new">1696 bool JVMCIRuntime::trace_prefix(int level) {</span>
<span class="new">1697   Thread* thread = Thread::current_or_null_safe();</span>
<span class="new">1698   if (thread != NULL) {</span>
<span class="new">1699     ResourceMark rm;</span>
<span class="new">1700     tty-&gt;print("JVMCITrace-%d[%s]:%*c", level, thread == NULL ? "?" : thread-&gt;name(), level, ' ');</span>
<span class="new">1701   } else {</span>
<span class="new">1702     tty-&gt;print("JVMCITrace-%d[?]:%*c", level, level, ' ');</span>
<span class="new">1703   }</span>
<span class="new">1704   return true;</span>
<span class="new">1705 }</span>
</pre></td>
</tr></table>
<center><a href='../../../../src/hotspot/share/jvmci/jvmciJavaClasses.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/jvmci/jvmciRuntime.hpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
