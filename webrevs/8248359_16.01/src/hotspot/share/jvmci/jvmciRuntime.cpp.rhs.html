<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "classfile/symbolTable.hpp"
  27 #include "compiler/compileBroker.hpp"
<a name="1" id="anc1"></a><span class="new">  28 #include "gc/shared/oopStorage.inline.hpp"</span>
<span class="new">  29 #include "gc/shared/oopStorageSet.hpp"</span>
  30 #include "jvmci/jniAccessMark.inline.hpp"
  31 #include "jvmci/jvmciCompilerToVM.hpp"
  32 #include "jvmci/jvmciRuntime.hpp"
<a name="2" id="anc2"></a><span class="new">  33 #include "jvmci/metadataHandles.hpp"</span>
  34 #include "logging/log.hpp"
  35 #include "memory/oopFactory.hpp"
  36 #include "memory/universe.hpp"
  37 #include "oops/constantPool.inline.hpp"
  38 #include "oops/method.inline.hpp"
  39 #include "oops/objArrayKlass.hpp"
  40 #include "oops/oop.inline.hpp"
<a name="3" id="anc3"></a><span class="new">  41 #include "oops/typeArrayOop.inline.hpp"</span>
  42 #include "runtime/atomic.hpp"
  43 #include "runtime/biasedLocking.hpp"
  44 #include "runtime/deoptimization.hpp"
  45 #include "runtime/fieldDescriptor.inline.hpp"
  46 #include "runtime/frame.inline.hpp"
<a name="4" id="anc4"></a><span class="new">  47 #include "runtime/jniHandles.inline.hpp"</span>
  48 #include "runtime/sharedRuntime.hpp"
  49 #if INCLUDE_G1GC
  50 #include "gc/g1/g1ThreadLocalData.hpp"
  51 #endif // INCLUDE_G1GC
  52 
  53 // Simple helper to see if the caller of a runtime stub which
  54 // entered the VM has been deoptimized
  55 
  56 static bool caller_is_deopted() {
  57   JavaThread* thread = JavaThread::current();
  58   RegisterMap reg_map(thread, false);
  59   frame runtime_frame = thread-&gt;last_frame();
  60   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  61   assert(caller_frame.is_compiled_frame(), "must be compiled");
  62   return caller_frame.is_deoptimized_frame();
  63 }
  64 
  65 // Stress deoptimization
  66 static void deopt_caller() {
  67   if ( !caller_is_deopted()) {
  68     JavaThread* thread = JavaThread::current();
  69     RegisterMap reg_map(thread, false);
  70     frame runtime_frame = thread-&gt;last_frame();
  71     frame caller_frame = runtime_frame.sender(&amp;reg_map);
  72     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
  73     assert(caller_is_deopted(), "Must be deoptimized");
  74   }
  75 }
  76 
  77 // Manages a scope for a JVMCI runtime call that attempts a heap allocation.
  78 // If there is a pending exception upon closing the scope and the runtime
  79 // call is of the variety where allocation failure returns NULL without an
  80 // exception, the following action is taken:
  81 //   1. The pending exception is cleared
  82 //   2. NULL is written to JavaThread::_vm_result
  83 //   3. Checks that an OutOfMemoryError is Universe::out_of_memory_error_retry().
  84 class RetryableAllocationMark: public StackObj {
  85  private:
  86   JavaThread* _thread;
  87  public:
  88   RetryableAllocationMark(JavaThread* thread, bool activate) {
  89     if (activate) {
  90       assert(!thread-&gt;in_retryable_allocation(), "retryable allocation scope is non-reentrant");
  91       _thread = thread;
  92       _thread-&gt;set_in_retryable_allocation(true);
  93     } else {
  94       _thread = NULL;
  95     }
  96   }
  97   ~RetryableAllocationMark() {
  98     if (_thread != NULL) {
  99       _thread-&gt;set_in_retryable_allocation(false);
 100       JavaThread* THREAD = _thread;
 101       if (HAS_PENDING_EXCEPTION) {
 102         oop ex = PENDING_EXCEPTION;
 103         CLEAR_PENDING_EXCEPTION;
 104         oop retry_oome = Universe::out_of_memory_error_retry();
 105         if (ex-&gt;is_a(retry_oome-&gt;klass()) &amp;&amp; retry_oome != ex) {
 106           ResourceMark rm;
 107           fatal("Unexpected exception in scope of retryable allocation: " INTPTR_FORMAT " of type %s", p2i(ex), ex-&gt;klass()-&gt;external_name());
 108         }
 109         _thread-&gt;set_vm_result(NULL);
 110       }
 111     }
 112   }
 113 };
 114 
 115 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail))
 116   JRT_BLOCK;
 117   assert(klass-&gt;is_klass(), "not a class");
 118   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 119   InstanceKlass* h = InstanceKlass::cast(klass);
 120   {
 121     RetryableAllocationMark ram(thread, null_on_fail);
 122     h-&gt;check_valid_for_instantiation(true, CHECK);
 123     oop obj;
 124     if (null_on_fail) {
 125       if (!h-&gt;is_initialized()) {
 126         // Cannot re-execute class initialization without side effects
 127         // so return without attempting the initialization
 128         return;
 129       }
 130     } else {
 131       // make sure klass is initialized
 132       h-&gt;initialize(CHECK);
 133     }
 134     // allocate instance and return via TLS
 135     obj = h-&gt;allocate_instance(CHECK);
 136     thread-&gt;set_vm_result(obj);
 137   }
 138   JRT_BLOCK_END;
 139   SharedRuntime::on_slowpath_allocation_exit(thread);
 140 JRT_END
 141 
 142 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* thread, Klass* array_klass, jint length, bool null_on_fail))
 143   JRT_BLOCK;
 144   // Note: no handle for klass needed since they are not used
 145   //       anymore after new_objArray() and no GC can happen before.
 146   //       (This may have to change if this code changes!)
 147   assert(array_klass-&gt;is_klass(), "not a class");
 148   oop obj;
 149   if (array_klass-&gt;is_typeArray_klass()) {
 150     BasicType elt_type = TypeArrayKlass::cast(array_klass)-&gt;element_type();
 151     RetryableAllocationMark ram(thread, null_on_fail);
 152     obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 153   } else {
 154     Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
 155     Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();
 156     RetryableAllocationMark ram(thread, null_on_fail);
 157     obj = oopFactory::new_objArray(elem_klass, length, CHECK);
 158   }
 159   thread-&gt;set_vm_result(obj);
 160   // This is pretty rare but this runtime patch is stressful to deoptimization
 161   // if we deoptimize here so force a deopt to stress the path.
 162   if (DeoptimizeALot) {
 163     static int deopts = 0;
 164     // Alternate between deoptimizing and raising an error (which will also cause a deopt)
 165     if (deopts++ % 2 == 0) {
 166       if (null_on_fail) {
 167         return;
 168       } else {
 169         ResourceMark rm(THREAD);
 170         THROW(vmSymbols::java_lang_OutOfMemoryError());
 171       }
 172     } else {
 173       deopt_caller();
 174     }
 175   }
 176   JRT_BLOCK_END;
 177   SharedRuntime::on_slowpath_allocation_exit(thread);
 178 JRT_END
 179 
 180 JRT_ENTRY(void, JVMCIRuntime::new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail))
 181   assert(klass-&gt;is_klass(), "not a class");
 182   assert(rank &gt;= 1, "rank must be nonzero");
 183   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 184   RetryableAllocationMark ram(thread, null_on_fail);
 185   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
 186   thread-&gt;set_vm_result(obj);
 187 JRT_END
 188 
 189 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail))
 190   RetryableAllocationMark ram(thread, null_on_fail);
 191   oop obj = Reflection::reflect_new_array(element_mirror, length, CHECK);
 192   thread-&gt;set_vm_result(obj);
 193 JRT_END
 194 
 195 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail))
 196   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(type_mirror));
 197 
 198   if (klass == NULL) {
 199     ResourceMark rm(THREAD);
 200     THROW(vmSymbols::java_lang_InstantiationException());
 201   }
 202   RetryableAllocationMark ram(thread, null_on_fail);
 203 
 204   // Create new instance (the receiver)
 205   klass-&gt;check_valid_for_instantiation(false, CHECK);
 206 
 207   if (null_on_fail) {
 208     if (!klass-&gt;is_initialized()) {
 209       // Cannot re-execute class initialization without side effects
 210       // so return without attempting the initialization
 211       return;
 212     }
 213   } else {
 214     // Make sure klass gets initialized
 215     klass-&gt;initialize(CHECK);
 216   }
 217 
 218   oop obj = klass-&gt;allocate_instance(CHECK);
 219   thread-&gt;set_vm_result(obj);
 220 JRT_END
 221 
 222 extern void vm_exit(int code);
 223 
 224 // Enter this method from compiled code handler below. This is where we transition
 225 // to VM mode. This is done as a helper routine so that the method called directly
 226 // from compiled code does not have to transition to VM. This allows the entry
 227 // method to see if the nmethod that we have just looked up a handler for has
 228 // been deoptimized while we were in the vm. This simplifies the assembly code
 229 // cpu directories.
 230 //
 231 // We are entering here from exception stub (via the entry method below)
 232 // If there is a compiled exception handler in this method, we will continue there;
 233 // otherwise we will unwind the stack and continue at the caller of top frame method
 234 // Note: we enter in Java using a special JRT wrapper. This wrapper allows us to
 235 // control the area where we can allow a safepoint. After we exit the safepoint area we can
 236 // check to see if the handler we are going to return is now in a nmethod that has
 237 // been deoptimized. If that is the case we return the deopt blob
 238 // unpack_with_exception entry instead. This makes life for the exception blob easier
 239 // because making that same check and diverting is painful from assembly language.
 240 JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, CompiledMethod*&amp; cm))
 241   // Reset method handle flag.
 242   thread-&gt;set_is_method_handle_return(false);
 243 
 244   Handle exception(thread, ex);
 245   cm = CodeCache::find_compiled(pc);
 246   assert(cm != NULL, "this is not a compiled method");
 247   // Adjust the pc as needed/
 248   if (cm-&gt;is_deopt_pc(pc)) {
 249     RegisterMap map(thread, false);
 250     frame exception_frame = thread-&gt;last_frame().sender(&amp;map);
 251     // if the frame isn't deopted then pc must not correspond to the caller of last_frame
 252     assert(exception_frame.is_deoptimized_frame(), "must be deopted");
 253     pc = exception_frame.pc();
 254   }
 255 #ifdef ASSERT
 256   assert(exception.not_null(), "NULL exceptions should be handled by throw_exception");
 257   assert(oopDesc::is_oop(exception()), "just checking");
 258   // Check that exception is a subclass of Throwable, otherwise we have a VerifyError
 259   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
 260     if (ExitVMOnVerifyError) vm_exit(-1);
 261     ShouldNotReachHere();
 262   }
 263 #endif
 264 
 265   // Check the stack guard pages and reenable them if necessary and there is
 266   // enough space on the stack to do so.  Use fast exceptions only if the guard
 267   // pages are enabled.
 268   bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
 269   if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
 270 
 271   if (JvmtiExport::can_post_on_exceptions()) {
 272     // To ensure correct notification of exception catches and throws
 273     // we have to deoptimize here.  If we attempted to notify the
 274     // catches and throws during this exception lookup it's possible
 275     // we could deoptimize on the way out of the VM and end back in
 276     // the interpreter at the throw site.  This would result in double
 277     // notifications since the interpreter would also notify about
 278     // these same catches and throws as it unwound the frame.
 279 
 280     RegisterMap reg_map(thread);
 281     frame stub_frame = thread-&gt;last_frame();
 282     frame caller_frame = stub_frame.sender(&amp;reg_map);
 283 
 284     // We don't really want to deoptimize the nmethod itself since we
 285     // can actually continue in the exception handler ourselves but I
 286     // don't see an easy way to have the desired effect.
 287     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
 288     assert(caller_is_deopted(), "Must be deoptimized");
 289 
 290     return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 291   }
 292 
 293   // ExceptionCache is used only for exceptions at call sites and not for implicit exceptions
 294   if (guard_pages_enabled) {
 295     address fast_continuation = cm-&gt;handler_for_exception_and_pc(exception, pc);
 296     if (fast_continuation != NULL) {
 297       // Set flag if return address is a method handle call site.
 298       thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 299       return fast_continuation;
 300     }
 301   }
 302 
 303   // If the stack guard pages are enabled, check whether there is a handler in
 304   // the current method.  Otherwise (guard pages disabled), force an unwind and
 305   // skip the exception cache update (i.e., just leave continuation==NULL).
 306   address continuation = NULL;
 307   if (guard_pages_enabled) {
 308 
 309     // New exception handling mechanism can support inlined methods
 310     // with exception handlers since the mappings are from PC to PC
 311 
 312     // debugging support
 313     // tracing
 314     if (log_is_enabled(Info, exceptions)) {
 315       ResourceMark rm;
 316       stringStream tempst;
 317       assert(cm-&gt;method() != NULL, "Unexpected null method()");
 318       tempst.print("compiled method &lt;%s&gt;\n"
 319                    " at PC" INTPTR_FORMAT " for thread " INTPTR_FORMAT,
 320                    cm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
 321       Exceptions::log_exception(exception, tempst.as_string());
 322     }
 323     // for AbortVMOnException flag
 324     NOT_PRODUCT(Exceptions::debug_check_abort(exception));
 325 
 326     // Clear out the exception oop and pc since looking up an
 327     // exception handler can cause class loading, which might throw an
 328     // exception and those fields are expected to be clear during
 329     // normal bytecode execution.
 330     thread-&gt;clear_exception_oop_and_pc();
 331 
 332     bool recursive_exception = false;
 333     continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);
 334     // If an exception was thrown during exception dispatch, the exception oop may have changed
 335     thread-&gt;set_exception_oop(exception());
 336     thread-&gt;set_exception_pc(pc);
 337 
 338     // The exception cache is used only for non-implicit exceptions
 339     // Update the exception cache only when another exception did
 340     // occur during the computation of the compiled exception handler
 341     // (e.g., when loading the class of the catch type).
 342     // Checking for exception oop equality is not
 343     // sufficient because some exceptions are pre-allocated and reused.
 344     if (continuation != NULL &amp;&amp; !recursive_exception &amp;&amp; !SharedRuntime::deopt_blob()-&gt;contains(continuation)) {
 345       cm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
 346     }
 347   }
 348 
 349   // Set flag if return address is a method handle call site.
 350   thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 351 
 352   if (log_is_enabled(Info, exceptions)) {
 353     ResourceMark rm;
 354     log_info(exceptions)("Thread " PTR_FORMAT " continuing at PC " PTR_FORMAT
 355                          " for exception thrown at PC " PTR_FORMAT,
 356                          p2i(thread), p2i(continuation), p2i(pc));
 357   }
 358 
 359   return continuation;
 360 JRT_END
 361 
 362 // Enter this method from compiled code only if there is a Java exception handler
 363 // in the method handling the exception.
 364 // We are entering here from exception stub. We don't do a normal VM transition here.
 365 // We do it in a helper. This is so we can check to see if the nmethod we have just
 366 // searched for an exception handler has been deoptimized in the meantime.
 367 address JVMCIRuntime::exception_handler_for_pc(JavaThread* thread) {
 368   oop exception = thread-&gt;exception_oop();
 369   address pc = thread-&gt;exception_pc();
 370   // Still in Java mode
 371   DEBUG_ONLY(ResetNoHandleMark rnhm);
 372   CompiledMethod* cm = NULL;
 373   address continuation = NULL;
 374   {
 375     // Enter VM mode by calling the helper
 376     ResetNoHandleMark rnhm;
 377     continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);
 378   }
 379   // Back in JAVA, use no oops DON'T safepoint
 380 
 381   // Now check to see if the compiled method we were called from is now deoptimized.
 382   // If so we must return to the deopt blob and deoptimize the nmethod
 383   if (cm != NULL &amp;&amp; caller_is_deopted()) {
 384     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 385   }
 386 
 387   assert(continuation != NULL, "no handler found");
 388   return continuation;
 389 }
 390 
 391 JRT_BLOCK_ENTRY(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 392   SharedRuntime::monitor_enter_helper(obj, lock, thread);
 393 JRT_END
 394 
 395 JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 396   assert(thread-&gt;last_Java_sp(), "last_Java_sp must be set");
 397   assert(oopDesc::is_oop(obj), "invalid lock object pointer dected");
 398   SharedRuntime::monitor_exit_helper(obj, lock, thread);
 399 JRT_END
 400 
 401 // Object.notify() fast path, caller does slow path
 402 JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *thread, oopDesc* obj))
 403 
 404   // Very few notify/notifyAll operations find any threads on the waitset, so
 405   // the dominant fast-path is to simply return.
 406   // Relatedly, it's critical that notify/notifyAll be fast in order to
 407   // reduce lock hold times.
 408   if (!SafepointSynchronize::is_synchronizing()) {
 409     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 410       return true;
 411     }
 412   }
 413   return false; // caller must perform slow path
 414 
 415 JRT_END
 416 
 417 // Object.notifyAll() fast path, caller does slow path
 418 JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *thread, oopDesc* obj))
 419 
 420   if (!SafepointSynchronize::is_synchronizing() ) {
 421     if (ObjectSynchronizer::quick_notify(obj, thread, true)) {
 422       return true;
 423     }
 424   }
 425   return false; // caller must perform slow path
 426 
 427 JRT_END
 428 
 429 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))
 430   JRT_BLOCK;
 431   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 432   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 433   JRT_BLOCK_END;
 434   return caller_is_deopted();
 435 JRT_END
 436 
 437 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))
 438   JRT_BLOCK;
 439   ResourceMark rm(thread);
 440   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 441   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass-&gt;external_name());
 442   JRT_BLOCK_END;
 443   return caller_is_deopted();
 444 JRT_END
 445 
 446 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))
 447   JRT_BLOCK;
 448   ResourceMark rm(thread);
 449   const char* message = SharedRuntime::generate_class_cast_message(caster_klass, target_klass);
 450   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 451   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 452   JRT_BLOCK_END;
 453   return caller_is_deopted();
 454 JRT_END
 455 
 456 JRT_LEAF(void, JVMCIRuntime::log_object(JavaThread* thread, oopDesc* obj, bool as_string, bool newline))
 457   ttyLocker ttyl;
 458 
 459   if (obj == NULL) {
 460     tty-&gt;print("NULL");
 461   } else if (oopDesc::is_oop_or_null(obj, true) &amp;&amp; (!as_string || !java_lang_String::is_instance(obj))) {
 462     if (oopDesc::is_oop_or_null(obj, true)) {
 463       char buf[O_BUFLEN];
 464       tty-&gt;print("%s@" INTPTR_FORMAT, obj-&gt;klass()-&gt;name()-&gt;as_C_string(buf, O_BUFLEN), p2i(obj));
 465     } else {
 466       tty-&gt;print(INTPTR_FORMAT, p2i(obj));
 467     }
 468   } else {
 469     ResourceMark rm;
 470     assert(obj != NULL &amp;&amp; java_lang_String::is_instance(obj), "must be");
 471     char *buf = java_lang_String::as_utf8_string(obj);
 472     tty-&gt;print_raw(buf);
 473   }
 474   if (newline) {
 475     tty-&gt;cr();
 476   }
 477 JRT_END
 478 
 479 #if INCLUDE_G1GC
 480 
 481 JRT_LEAF(void, JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj))
 482   G1ThreadLocalData::satb_mark_queue(thread).enqueue(obj);
 483 JRT_END
 484 
 485 JRT_LEAF(void, JVMCIRuntime::write_barrier_post(JavaThread* thread, void* card_addr))
 486   G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);
 487 JRT_END
 488 
 489 #endif // INCLUDE_G1GC
 490 
 491 JRT_LEAF(jboolean, JVMCIRuntime::validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child))
 492   bool ret = true;
 493   if(!Universe::heap()-&gt;is_in(parent)) {
 494     tty-&gt;print_cr("Parent Object " INTPTR_FORMAT " not in heap", p2i(parent));
 495     parent-&gt;print();
 496     ret=false;
 497   }
 498   if(!Universe::heap()-&gt;is_in(child)) {
 499     tty-&gt;print_cr("Child Object " INTPTR_FORMAT " not in heap", p2i(child));
 500     child-&gt;print();
 501     ret=false;
 502   }
 503   return (jint)ret;
 504 JRT_END
 505 
 506 JRT_ENTRY(void, JVMCIRuntime::vm_error(JavaThread* thread, jlong where, jlong format, jlong value))
 507   ResourceMark rm;
 508   const char *error_msg = where == 0L ? "&lt;internal JVMCI error&gt;" : (char*) (address) where;
 509   char *detail_msg = NULL;
 510   if (format != 0L) {
 511     const char* buf = (char*) (address) format;
 512     size_t detail_msg_length = strlen(buf) * 2;
 513     detail_msg = (char *) NEW_RESOURCE_ARRAY(u_char, detail_msg_length);
 514     jio_snprintf(detail_msg, detail_msg_length, buf, value);
 515   }
 516   report_vm_error(__FILE__, __LINE__, error_msg, "%s", detail_msg);
 517 JRT_END
 518 
 519 JRT_LEAF(oopDesc*, JVMCIRuntime::load_and_clear_exception(JavaThread* thread))
 520   oop exception = thread-&gt;exception_oop();
 521   assert(exception != NULL, "npe");
 522   thread-&gt;set_exception_oop(NULL);
 523   thread-&gt;set_exception_pc(0);
 524   return exception;
 525 JRT_END
 526 
 527 PRAGMA_DIAG_PUSH
 528 PRAGMA_FORMAT_NONLITERAL_IGNORED
 529 JRT_LEAF(void, JVMCIRuntime::log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3))
 530   ResourceMark rm;
 531   tty-&gt;print(format, v1, v2, v3);
 532 JRT_END
 533 PRAGMA_DIAG_POP
 534 
 535 static void decipher(jlong v, bool ignoreZero) {
 536   if (v != 0 || !ignoreZero) {
 537     void* p = (void *)(address) v;
 538     CodeBlob* cb = CodeCache::find_blob(p);
 539     if (cb) {
 540       if (cb-&gt;is_nmethod()) {
 541         char buf[O_BUFLEN];
 542         tty-&gt;print("%s [" INTPTR_FORMAT "+" JLONG_FORMAT "]", cb-&gt;as_nmethod_or_null()-&gt;method()-&gt;name_and_sig_as_C_string(buf, O_BUFLEN), p2i(cb-&gt;code_begin()), (jlong)((address)v - cb-&gt;code_begin()));
 543         return;
 544       }
 545       cb-&gt;print_value_on(tty);
 546       return;
 547     }
 548     if (Universe::heap()-&gt;is_in(p)) {
 549       oop obj = oop(p);
 550       obj-&gt;print_value_on(tty);
 551       return;
 552     }
 553     tty-&gt;print(INTPTR_FORMAT " [long: " JLONG_FORMAT ", double %lf, char %c]",p2i((void *)v), (jlong)v, (jdouble)v, (char)v);
 554   }
 555 }
 556 
 557 PRAGMA_DIAG_PUSH
 558 PRAGMA_FORMAT_NONLITERAL_IGNORED
 559 JRT_LEAF(void, JVMCIRuntime::vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3))
 560   ResourceMark rm;
 561   const char *buf = (const char*) (address) format;
 562   if (vmError) {
 563     if (buf != NULL) {
 564       fatal(buf, v1, v2, v3);
 565     } else {
 566       fatal("&lt;anonymous error&gt;");
 567     }
 568   } else if (buf != NULL) {
 569     tty-&gt;print(buf, v1, v2, v3);
 570   } else {
 571     assert(v2 == 0, "v2 != 0");
 572     assert(v3 == 0, "v3 != 0");
 573     decipher(v1, false);
 574   }
 575 JRT_END
 576 PRAGMA_DIAG_POP
 577 
 578 JRT_LEAF(void, JVMCIRuntime::log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline))
 579   union {
 580       jlong l;
 581       jdouble d;
 582       jfloat f;
 583   } uu;
 584   uu.l = value;
 585   switch (typeChar) {
 586     case 'Z': tty-&gt;print(value == 0 ? "false" : "true"); break;
 587     case 'B': tty-&gt;print("%d", (jbyte) value); break;
 588     case 'C': tty-&gt;print("%c", (jchar) value); break;
 589     case 'S': tty-&gt;print("%d", (jshort) value); break;
 590     case 'I': tty-&gt;print("%d", (jint) value); break;
 591     case 'F': tty-&gt;print("%f", uu.f); break;
 592     case 'J': tty-&gt;print(JLONG_FORMAT, value); break;
 593     case 'D': tty-&gt;print("%lf", uu.d); break;
 594     default: assert(false, "unknown typeChar"); break;
 595   }
 596   if (newline) {
 597     tty-&gt;cr();
 598   }
 599 JRT_END
 600 
 601 JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))
 602   return (jint) obj-&gt;identity_hash();
 603 JRT_END
 604 
 605 JRT_ENTRY(jint, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))
 606   deopt_caller();
 607   return (jint) value;
 608 JRT_END
 609 
 610 
 611 // private static JVMCIRuntime JVMCI.initializeRuntime()
 612 JVM_ENTRY_NO_ENV(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))
 613   JNI_JVMCIENV(thread, env);
 614   if (!EnableJVMCI) {
 615     JVMCI_THROW_MSG_NULL(InternalError, "JVMCI is not enabled");
 616   }
 617   JVMCIENV-&gt;runtime()-&gt;initialize_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);
 618   JVMCIObject runtime = JVMCIENV-&gt;runtime()-&gt;get_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);
 619   return JVMCIENV-&gt;get_jobject(runtime);
 620 JVM_END
 621 
 622 void JVMCIRuntime::call_getCompiler(TRAPS) {
 623   THREAD_JVMCIENV(JavaThread::current());
 624   JVMCIObject jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_CHECK);
 625   initialize(JVMCIENV);
 626   JVMCIENV-&gt;call_HotSpotJVMCIRuntime_getCompiler(jvmciRuntime, JVMCI_CHECK);
 627 }
 628 
 629 void JVMCINMethodData::initialize(
 630   int nmethod_mirror_index,
 631   const char* name,
 632   FailedSpeculation** failed_speculations)
 633 {
 634   _failed_speculations = failed_speculations;
 635   _nmethod_mirror_index = nmethod_mirror_index;
 636   if (name != NULL) {
 637     _has_name = true;
 638     char* dest = (char*) this-&gt;name();
 639     strcpy(dest, name);
 640   } else {
 641     _has_name = false;
 642   }
 643 }
 644 
 645 void JVMCINMethodData::add_failed_speculation(nmethod* nm, jlong speculation) {
 646   uint index = (speculation &gt;&gt; 32) &amp; 0xFFFFFFFF;
 647   int length = (int) speculation;
 648   if (index + length &gt; (uint) nm-&gt;speculations_size()) {
 649     fatal(INTPTR_FORMAT "[index: %d, length: %d] out of bounds wrt encoded speculations of length %u", speculation, index, length, nm-&gt;speculations_size());
 650   }
 651   address data = nm-&gt;speculations_begin() + index;
 652   FailedSpeculation::add_failed_speculation(nm, _failed_speculations, data, length);
 653 }
 654 
 655 oop JVMCINMethodData::get_nmethod_mirror(nmethod* nm, bool phantom_ref) {
 656   if (_nmethod_mirror_index == -1) {
 657     return NULL;
 658   }
 659   if (phantom_ref) {
 660     return nm-&gt;oop_at_phantom(_nmethod_mirror_index);
 661   } else {
 662     return nm-&gt;oop_at(_nmethod_mirror_index);
 663   }
 664 }
 665 
 666 void JVMCINMethodData::set_nmethod_mirror(nmethod* nm, oop new_mirror) {
 667   assert(_nmethod_mirror_index != -1, "cannot set JVMCI mirror for nmethod");
 668   oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);
 669   assert(new_mirror != NULL, "use clear_nmethod_mirror to clear the mirror");
 670   assert(*addr == NULL, "cannot overwrite non-null mirror");
 671 
 672   *addr = new_mirror;
 673 
 674   // Since we've patched some oops in the nmethod,
 675   // (re)register it with the heap.
 676   Universe::heap()-&gt;register_nmethod(nm);
 677 }
 678 
 679 void JVMCINMethodData::clear_nmethod_mirror(nmethod* nm) {
 680   if (_nmethod_mirror_index != -1) {
 681     oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);
 682     *addr = NULL;
 683   }
 684 }
 685 
 686 void JVMCINMethodData::invalidate_nmethod_mirror(nmethod* nm) {
 687   oop nmethod_mirror = get_nmethod_mirror(nm, /* phantom_ref */ false);
 688   if (nmethod_mirror == NULL) {
 689     return;
 690   }
 691 
 692   // Update the values in the mirror if it still refers to nm.
 693   // We cannot use JVMCIObject to wrap the mirror as this is called
 694   // during GC, forbidding the creation of JNIHandles.
 695   JVMCIEnv* jvmciEnv = NULL;
 696   nmethod* current = (nmethod*) HotSpotJVMCI::InstalledCode::address(jvmciEnv, nmethod_mirror);
 697   if (nm == current) {
 698     if (!nm-&gt;is_alive()) {
 699       // Break the link from the mirror to nm such that
 700       // future invocations via the mirror will result in
 701       // an InvalidInstalledCodeException.
 702       HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, 0);
 703       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 704     } else if (nm-&gt;is_not_entrant()) {
 705       // Zero the entry point so any new invocation will fail but keep
 706       // the address link around that so that existing activations can
 707       // be deoptimized via the mirror (i.e. JVMCIEnv::invalidate_installed_code).
 708       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 709     }
 710   }
 711 }
 712 
<a name="5" id="anc5"></a><span class="new"> 713 JVMCIRuntime::JVMCIRuntime(int id) {</span>
<span class="new"> 714   _init_state = uninitialized;</span>
<span class="new"> 715   _shared_library_javavm = NULL;</span>
<span class="new"> 716   _id = id;</span>
<span class="new"> 717   _metadata_handles = new MetadataHandles();</span>
<span class="new"> 718   TRACE_jvmci_1("created new JVMCI runtime %d (" PTR_FORMAT ")", id, p2i(this));</span>
<span class="new"> 719 }</span>
<span class="new"> 720 </span>
<span class="new"> 721 // Handles to objects in the Hotspot heap.</span>
<span class="new"> 722 static OopStorage* object_handles() {</span>
<span class="new"> 723   return OopStorageSet::vm_global();</span>
<span class="new"> 724 }</span>
<span class="new"> 725 </span>
<span class="new"> 726 jobject JVMCIRuntime::make_global(const Handle&amp; obj) {</span>
<span class="new"> 727   assert(!Universe::heap()-&gt;is_gc_active(), "can't extend the root set during GC");</span>
<span class="new"> 728   assert(oopDesc::is_oop(obj()), "not an oop");</span>
<span class="new"> 729   oop* ptr = object_handles()-&gt;allocate();</span>
<span class="new"> 730   jobject res = NULL;</span>
<span class="new"> 731   if (ptr != NULL) {</span>
<span class="new"> 732     assert(*ptr == NULL, "invariant");</span>
<span class="new"> 733     NativeAccess&lt;&gt;::oop_store(ptr, obj());</span>
<span class="new"> 734     res = reinterpret_cast&lt;jobject&gt;(ptr);</span>
<span class="new"> 735   } else {</span>
<span class="new"> 736     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,</span>
<span class="new"> 737                           "Cannot create JVMCI oop handle");</span>
<span class="new"> 738   }</span>
<span class="new"> 739   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 740   return res;</span>
<span class="new"> 741 }</span>
<span class="new"> 742 </span>
<span class="new"> 743 void JVMCIRuntime::destroy_global(jobject handle) {</span>
<span class="new"> 744   // Assert before nulling out, for better debugging.</span>
<span class="new"> 745   assert(is_global_handle(handle), "precondition");</span>
<span class="new"> 746   oop* oop_ptr = reinterpret_cast&lt;oop*&gt;(handle);</span>
<span class="new"> 747   NativeAccess&lt;&gt;::oop_store(oop_ptr, (oop)NULL);</span>
<span class="new"> 748   object_handles()-&gt;release(oop_ptr);</span>
<span class="new"> 749   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 750 }</span>
<span class="new"> 751 </span>
<span class="new"> 752 bool JVMCIRuntime::is_global_handle(jobject handle) {</span>
<span class="new"> 753   const oop* ptr = reinterpret_cast&lt;oop*&gt;(handle);</span>
<span class="new"> 754   return object_handles()-&gt;allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;</span>
<span class="new"> 755 }</span>
<span class="new"> 756 </span>
<span class="new"> 757 jmetadata JVMCIRuntime::allocate_handle(const methodHandle&amp; handle) {</span>
<span class="new"> 758   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 759   return _metadata_handles-&gt;allocate_handle(handle);</span>
<span class="new"> 760 }</span>
<span class="new"> 761 </span>
<span class="new"> 762 jmetadata JVMCIRuntime::allocate_handle(const constantPoolHandle&amp; handle) {</span>
<span class="new"> 763   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 764   return _metadata_handles-&gt;allocate_handle(handle);</span>
<span class="new"> 765 }</span>
<span class="new"> 766 </span>
<span class="new"> 767 void JVMCIRuntime::release_handle(jmetadata handle) {</span>
<span class="new"> 768   MutexLocker ml(JVMCI_lock);</span>
<span class="new"> 769   _metadata_handles-&gt;chain_free_list(handle);</span>
<span class="new"> 770 }</span>
<span class="new"> 771 </span>
<span class="new"> 772 JNIEnv* JVMCIRuntime::init_shared_library_javavm() {</span>
<span class="new"> 773   JavaVM* javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 774   if (javaVM == NULL) {</span>
<span class="new"> 775     MutexLocker locker(JVMCI_lock);</span>
<span class="new"> 776     // Check again under JVMCI_lock</span>
<span class="new"> 777     javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 778     if (javaVM != NULL) {</span>
<span class="new"> 779       return NULL;</span>
<span class="new"> 780     }</span>
<span class="new"> 781     char* sl_path;</span>
<span class="new"> 782     void* sl_handle = JVMCI::get_shared_library(sl_path, true);</span>
<span class="new"> 783 </span>
<span class="new"> 784     jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);</span>
<span class="new"> 785     typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);</span>
<span class="new"> 786 </span>
<span class="new"> 787     JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(sl_handle, "JNI_CreateJavaVM"));</span>
<span class="new"> 788     if (JNI_CreateJavaVM == NULL) {</span>
<span class="new"> 789       vm_exit_during_initialization("Unable to find JNI_CreateJavaVM", sl_path);</span>
<span class="new"> 790     }</span>
<span class="new"> 791 </span>
<span class="new"> 792     ResourceMark rm;</span>
<span class="new"> 793     JavaVMInitArgs vm_args;</span>
<span class="new"> 794     vm_args.version = JNI_VERSION_1_2;</span>
<span class="new"> 795     vm_args.ignoreUnrecognized = JNI_TRUE;</span>
<span class="new"> 796     JavaVMOption options[1];</span>
<span class="new"> 797     jlong javaVM_id = 0;</span>
<span class="new"> 798 </span>
<span class="new"> 799     // Protocol: JVMCI shared library JavaVM should support a non-standard "_javavm_id"</span>
<span class="new"> 800     // option whose extraInfo info field is a pointer to which a unique id for the</span>
<span class="new"> 801     // JavaVM should be written.</span>
<span class="new"> 802     options[0].optionString = (char*) "_javavm_id";</span>
<span class="new"> 803     options[0].extraInfo = &amp;javaVM_id;</span>
<span class="new"> 804 </span>
<span class="new"> 805     vm_args.version = JNI_VERSION_1_2;</span>
<span class="new"> 806     vm_args.options = options;</span>
<span class="new"> 807     vm_args.nOptions = sizeof(options) / sizeof(JavaVMOption);</span>
<span class="new"> 808 </span>
<span class="new"> 809     JNIEnv* env = NULL;</span>
<span class="new"> 810     int result = (*JNI_CreateJavaVM)(&amp;javaVM, (void**) &amp;env, &amp;vm_args);</span>
<span class="new"> 811     if (result == JNI_OK) {</span>
<span class="new"> 812       guarantee(env != NULL, "missing env");</span>
<span class="new"> 813       _shared_library_javavm = javaVM;</span>
<span class="new"> 814       TRACE_jvmci_1("created JavaVM[%ld]@" PTR_FORMAT " for JVMCI runtime %d", javaVM_id, p2i(javaVM), _id);</span>
<span class="new"> 815       return env;</span>
<span class="new"> 816     } else {</span>
<span class="new"> 817       vm_exit_during_initialization(err_msg("JNI_CreateJavaVM failed with return value %d", result), sl_path);</span>
<span class="new"> 818     }</span>
<span class="new"> 819   }</span>
<span class="new"> 820   return NULL;</span>
<span class="new"> 821 }</span>
<span class="new"> 822 </span>
<span class="new"> 823 void JVMCIRuntime::init_JavaVM_info(jlongArray info, JVMCI_TRAPS) {</span>
<span class="new"> 824   if (info != NULL) {</span>
<span class="new"> 825     typeArrayOop info_oop = (typeArrayOop) JNIHandles::resolve(info);</span>
<span class="new"> 826     if (info_oop-&gt;length() &lt; 4) {</span>
<span class="new"> 827       JVMCI_THROW_MSG(ArrayIndexOutOfBoundsException, err_msg("%d &lt; 4", info_oop-&gt;length()));</span>
<span class="new"> 828     }</span>
<span class="new"> 829     JavaVM* javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 830     info_oop-&gt;long_at_put(0, (jlong) (address) javaVM);</span>
<span class="new"> 831     info_oop-&gt;long_at_put(1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);</span>
<span class="new"> 832     info_oop-&gt;long_at_put(2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);</span>
<span class="new"> 833     info_oop-&gt;long_at_put(3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);</span>
<span class="new"> 834   }</span>
<span class="new"> 835 }</span>
<span class="new"> 836 </span>
<span class="new"> 837 #define JAVAVM_CALL_BLOCK                                             \</span>
<span class="new"> 838   guarantee(thread != NULL &amp;&amp; _shared_library_javavm != NULL, "npe"); \</span>
<span class="new"> 839   ThreadToNativeFromVM ttnfv(thread);                                 \</span>
<span class="new"> 840   JavaVM* javavm = (JavaVM*) _shared_library_javavm;</span>
<span class="new"> 841 </span>
<span class="new"> 842 jint JVMCIRuntime::AttachCurrentThread(JavaThread* thread, void **penv, void *args) {</span>
<span class="new"> 843   JAVAVM_CALL_BLOCK</span>
<span class="new"> 844   return javavm-&gt;AttachCurrentThread(penv, args);</span>
<span class="new"> 845 }</span>
<span class="new"> 846 </span>
<span class="new"> 847 jint JVMCIRuntime::AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args) {</span>
<span class="new"> 848   JAVAVM_CALL_BLOCK</span>
<span class="new"> 849   return javavm-&gt;AttachCurrentThreadAsDaemon(penv, args);</span>
<span class="new"> 850 }</span>
<span class="new"> 851 </span>
<span class="new"> 852 jint JVMCIRuntime::DetachCurrentThread(JavaThread* thread) {</span>
<span class="new"> 853   JAVAVM_CALL_BLOCK</span>
<span class="new"> 854   return javavm-&gt;DetachCurrentThread();</span>
<span class="new"> 855 }</span>
<span class="new"> 856 </span>
<span class="new"> 857 jint JVMCIRuntime::GetEnv(JavaThread* thread, void **penv, jint version) {</span>
<span class="new"> 858   JAVAVM_CALL_BLOCK</span>
<span class="new"> 859   return javavm-&gt;GetEnv(penv, version);</span>
<span class="new"> 860 }</span>
<span class="new"> 861 #undef JAVAVM_CALL_BLOCK                                             \</span>
<span class="new"> 862 </span>
 863 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 864   if (is_HotSpotJVMCIRuntime_initialized()) {
 865     if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {
 866       JVMCI_THROW_MSG(InternalError, "JVMCI has already been enabled in the JVMCI shared library");
 867     }
 868   }
 869 
 870   initialize(JVMCIENV);
 871 
 872   // This should only be called in the context of the JVMCI class being initialized
 873   JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
 874 
 875   _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);
<a name="6" id="anc6"></a><span class="new"> 876   JVMCI::_is_initialized = true;</span>
 877 }
 878 
 879 void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {
<a name="7" id="anc7"></a>
 880   // Check first without JVMCI_lock
<a name="8" id="anc8"></a><span class="changed"> 881   if (_init_state == fully_initialized) {</span>
 882     return;
 883   }
 884 
 885   MutexLocker locker(JVMCI_lock);
 886   // Check again under JVMCI_lock
<a name="9" id="anc9"></a><span class="changed"> 887   if (_init_state == fully_initialized) {</span>
 888     return;
 889   }
 890 
<a name="10" id="anc10"></a><span class="changed"> 891   while (_init_state == being_initialized) {</span>
<span class="changed"> 892     TRACE_jvmci_1("waiting for initialization of JVMCI runtime %d", _id);</span>
 893     JVMCI_lock-&gt;wait();
<a name="11" id="anc11"></a><span class="changed"> 894     if (_init_state == fully_initialized) {</span>
<span class="changed"> 895       TRACE_jvmci_1("done waiting for initialization of JVMCI runtime %d", _id);</span>
 896       return;
 897     }
 898   }
 899 
<a name="12" id="anc12"></a><span class="changed"> 900   TRACE_jvmci_1("initializing JVMCI runtime %d", _id);</span>
<span class="changed"> 901   _init_state = being_initialized;</span>
 902 
 903   {
 904     MutexUnlocker unlock(JVMCI_lock);
 905 
 906     HandleMark hm;
 907     ResourceMark rm;
 908     JavaThread* THREAD = JavaThread::current();
 909     if (JVMCIENV-&gt;is_hotspot()) {
 910       HotSpotJVMCI::compute_offsets(CHECK_EXIT);
 911     } else {
 912       JNIAccessMark jni(JVMCIENV);
 913 
 914       JNIJVMCI::initialize_ids(jni.env());
 915       if (jni()-&gt;ExceptionCheck()) {
 916         jni()-&gt;ExceptionDescribe();
 917         fatal("JNI exception during init");
 918       }
 919     }
<a name="13" id="anc13"></a><span class="new"> 920 </span>
<span class="new"> 921     if (!JVMCIENV-&gt;is_hotspot()) {</span>
<span class="new"> 922       JNIAccessMark jni(JVMCIENV, THREAD);</span>
<span class="new"> 923       JNIJVMCI::register_natives(jni.env());</span>
<span class="new"> 924     }</span>
 925     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));
 926     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));
 927     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));
 928     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));
 929     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));
 930     create_jvmci_primitive_type(T_LONG, JVMCI_CHECK_EXIT_((void)0));
 931     create_jvmci_primitive_type(T_FLOAT, JVMCI_CHECK_EXIT_((void)0));
 932     create_jvmci_primitive_type(T_DOUBLE, JVMCI_CHECK_EXIT_((void)0));
 933     create_jvmci_primitive_type(T_VOID, JVMCI_CHECK_EXIT_((void)0));
 934 
 935     if (!JVMCIENV-&gt;is_hotspot()) {
 936       JVMCIENV-&gt;copy_saved_properties();
 937     }
 938   }
 939 
<a name="14" id="anc14"></a><span class="changed"> 940   _init_state = fully_initialized;</span>
<span class="changed"> 941   TRACE_jvmci_1("initialized JVMCI runtime %d", _id);</span>
 942   JVMCI_lock-&gt;notify_all();
 943 }
 944 
 945 JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
 946   Thread* THREAD = Thread::current();
 947   // These primitive types are long lived and are created before the runtime is fully set up
 948   // so skip registering them for scanning.
 949   JVMCIObject mirror = JVMCIENV-&gt;get_object_constant(java_lang_Class::primitive_mirror(type), false, true);
 950   if (JVMCIENV-&gt;is_hotspot()) {
 951     JavaValue result(T_OBJECT);
 952     JavaCallArguments args;
 953     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(mirror)));
 954     args.push_int(type2char(type));
 955     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedPrimitiveType::klass(), vmSymbols::fromMetaspace_name(), vmSymbols::primitive_fromMetaspace_signature(), &amp;args, CHECK_(JVMCIObject()));
 956 
 957     return JVMCIENV-&gt;wrap(JNIHandles::make_local((oop)result.get_jobject()));
 958   } else {
 959     JNIAccessMark jni(JVMCIENV);
 960     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedPrimitiveType::clazz(),
 961                                            JNIJVMCI::HotSpotResolvedPrimitiveType_fromMetaspace_method(),
 962                                            mirror.as_jobject(), type2char(type));
 963     if (jni()-&gt;ExceptionCheck()) {
 964       return JVMCIObject();
 965     }
 966     return JVMCIENV-&gt;wrap(result);
 967   }
 968 }
 969 
 970 void JVMCIRuntime::initialize_JVMCI(JVMCI_TRAPS) {
 971   if (!is_HotSpotJVMCIRuntime_initialized()) {
 972     initialize(JVMCI_CHECK);
 973     JVMCIENV-&gt;call_JVMCI_getRuntime(JVMCI_CHECK);
 974   }
 975 }
 976 
 977 JVMCIObject JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 978   initialize(JVMCIENV);
 979   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
 980   return _HotSpotJVMCIRuntime_instance;
 981 }
 982 
<a name="15" id="anc15"></a><span class="changed"> 983 // private static void CompilerToVM.registerNatives()</span>

 984 JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
 985   JNI_JVMCIENV(thread, env);
 986 
 987   if (!EnableJVMCI) {
 988     JVMCI_THROW_MSG(InternalError, "JVMCI is not enabled");
 989   }
 990 
 991   JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
 992 
 993   {
 994     ResourceMark rm;
 995     HandleMark hm(thread);
 996     ThreadToNativeFromVM trans(thread);
 997 
 998     // Ensure _non_oop_bits is initialized
 999     Universe::non_oop_word();
1000 
1001     if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count())) {
1002       if (!env-&gt;ExceptionCheck()) {
1003         for (int i = 0; i &lt; CompilerToVM::methods_count(); i++) {
1004           if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods + i, 1)) {
1005             guarantee(false, "Error registering JNI method %s%s", CompilerToVM::methods[i].name, CompilerToVM::methods[i].signature);
1006             break;
1007           }
1008         }
1009       } else {
1010         env-&gt;ExceptionDescribe();
1011       }
1012       guarantee(false, "Failed registering CompilerToVM native methods");
1013     }
1014   }
1015 JVM_END
1016 
1017 
1018 void JVMCIRuntime::shutdown() {
<a name="16" id="anc16"></a><span class="changed">1019   JVMCIObject instance = _HotSpotJVMCIRuntime_instance;</span>
<span class="changed">1020   if (instance.is_non_null()) {</span>
<span class="changed">1021     TRACE_jvmci_1("shutting down JVMCI runtime %d", _id);</span>
<span class="changed">1022     _HotSpotJVMCIRuntime_instance = JVMCIObject();</span>
<span class="changed">1023     JVMCIEnv __stack_jvmci_env__(JavaThread::current(), instance.is_hotspot(), __FILE__, __LINE__);</span>
<span class="changed">1024     JVMCIEnv* JVMCIENV = &amp;__stack_jvmci_env__;</span>
<span class="changed">1025     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(instance);</span>
<span class="changed">1026     if (!instance.is_hotspot()) {</span>
<span class="changed">1027       // Need to keep the HotSpot based instance alive for the sake of</span>
<span class="changed">1028       // JVMCICompiler::force_comp_at_level_simple which can race with</span>
<span class="changed">1029       // shutting down the JVMCI runtime.</span>
<span class="changed">1030       JVMCIENV-&gt;destroy_global(instance);</span>
<span class="changed">1031     }</span>
<span class="changed">1032     TRACE_jvmci_1("shut down JVMCI runtime %d", _id);</span>
1033   }
1034 }
1035 
1036 void JVMCIRuntime::bootstrap_finished(TRAPS) {
<a name="17" id="anc17"></a><span class="changed">1037   if (_HotSpotJVMCIRuntime_instance.is_non_null()) {</span>
1038     THREAD_JVMCIENV(JavaThread::current());
1039     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
1040   }
1041 }
1042 
1043 void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {
1044   if (HAS_PENDING_EXCEPTION) {
1045     Handle exception(THREAD, PENDING_EXCEPTION);
1046     const char* exception_file = THREAD-&gt;exception_file();
1047     int exception_line = THREAD-&gt;exception_line();
1048     CLEAR_PENDING_EXCEPTION;
1049     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
1050       // Don't print anything if we are being killed.
1051     } else {
1052       java_lang_Throwable::print_stack_trace(exception, tty);
1053 
1054       // Clear and ignore any exceptions raised during printing
1055       CLEAR_PENDING_EXCEPTION;
1056     }
1057     if (!clear) {
1058       THREAD-&gt;set_pending_exception(exception(), exception_file, exception_line);
1059     }
1060   }
1061 }
1062 
1063 
1064 void JVMCIRuntime::exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message) {
1065   JavaThread* THREAD = JavaThread::current();
1066 
1067   static volatile int report_error = 0;
1068   if (!report_error &amp;&amp; Atomic::cmpxchg(&amp;report_error, 0, 1) == 0) {
1069     // Only report an error once
1070     tty-&gt;print_raw_cr(message);
1071     if (JVMCIENV != NULL) {
1072       JVMCIENV-&gt;describe_pending_exception(true);
1073     } else {
1074       describe_pending_hotspot_exception(THREAD, true);
1075     }
1076   } else {
1077     // Allow error reporting thread to print the stack trace.
1078     THREAD-&gt;sleep(200);
1079   }
1080 
1081   before_exit(THREAD);
1082   vm_exit(-1);
1083 }
1084 
1085 // ------------------------------------------------------------------
1086 // Note: the logic of this method should mirror the logic of
1087 // constantPoolOopDesc::verify_constant_pool_resolve.
1088 bool JVMCIRuntime::check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass) {
1089   if (accessing_klass-&gt;is_objArray_klass()) {
1090     accessing_klass = ObjArrayKlass::cast(accessing_klass)-&gt;bottom_klass();
1091   }
1092   if (!accessing_klass-&gt;is_instance_klass()) {
1093     return true;
1094   }
1095 
1096   if (resolved_klass-&gt;is_objArray_klass()) {
1097     // Find the element klass, if this is an array.
1098     resolved_klass = ObjArrayKlass::cast(resolved_klass)-&gt;bottom_klass();
1099   }
1100   if (resolved_klass-&gt;is_instance_klass()) {
1101     Reflection::VerifyClassAccessResults result =
1102       Reflection::verify_class_access(accessing_klass, InstanceKlass::cast(resolved_klass), true);
1103     return result == Reflection::ACCESS_OK;
1104   }
1105   return true;
1106 }
1107 
1108 // ------------------------------------------------------------------
1109 Klass* JVMCIRuntime::get_klass_by_name_impl(Klass*&amp; accessing_klass,
1110                                           const constantPoolHandle&amp; cpool,
1111                                           Symbol* sym,
1112                                           bool require_local) {
1113   JVMCI_EXCEPTION_CONTEXT;
1114 
1115   // Now we need to check the SystemDictionary
1116   if (sym-&gt;char_at(0) == JVM_SIGNATURE_CLASS &amp;&amp;
1117       sym-&gt;char_at(sym-&gt;utf8_length()-1) == JVM_SIGNATURE_ENDCLASS) {
1118     // This is a name from a signature.  Strip off the trimmings.
1119     // Call recursive to keep scope of strippedsym.
1120     TempNewSymbol strippedsym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
1121                                                         sym-&gt;utf8_length()-2);
1122     return get_klass_by_name_impl(accessing_klass, cpool, strippedsym, require_local);
1123   }
1124 
1125   Handle loader(THREAD, (oop)NULL);
1126   Handle domain(THREAD, (oop)NULL);
1127   if (accessing_klass != NULL) {
1128     loader = Handle(THREAD, accessing_klass-&gt;class_loader());
1129     domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
1130   }
1131 
1132   Klass* found_klass;
1133   {
1134     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems
1135     MutexLocker ml(Compile_lock);
1136     if (!require_local) {
1137       found_klass = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, CHECK_NULL);
1138     } else {
1139       found_klass = SystemDictionary::find_instance_or_array_klass(sym, loader, domain, CHECK_NULL);
1140     }
1141   }
1142 
1143   // If we fail to find an array klass, look again for its element type.
1144   // The element type may be available either locally or via constraints.
1145   // In either case, if we can find the element type in the system dictionary,
1146   // we must build an array type around it.  The CI requires array klasses
1147   // to be loaded if their element klasses are loaded, except when memory
1148   // is exhausted.
1149   if (sym-&gt;char_at(0) == JVM_SIGNATURE_ARRAY &amp;&amp;
1150       (sym-&gt;char_at(1) == JVM_SIGNATURE_ARRAY || sym-&gt;char_at(1) == JVM_SIGNATURE_CLASS)) {
1151     // We have an unloaded array.
1152     // Build it on the fly if the element class exists.
1153     TempNewSymbol elem_sym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
1154                                                      sym-&gt;utf8_length()-1);
1155 
1156     // Get element Klass recursively.
1157     Klass* elem_klass =
1158       get_klass_by_name_impl(accessing_klass,
1159                              cpool,
1160                              elem_sym,
1161                              require_local);
1162     if (elem_klass != NULL) {
1163       // Now make an array for it
1164       return elem_klass-&gt;array_klass(THREAD);
1165     }
1166   }
1167 
1168   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {
1169     // Look inside the constant pool for pre-resolved class entries.
1170     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {
1171       if (cpool-&gt;tag_at(i).is_klass()) {
1172         Klass*  kls = cpool-&gt;resolved_klass_at(i);
1173         if (kls-&gt;name() == sym) {
1174           return kls;
1175         }
1176       }
1177     }
1178   }
1179 
1180   return found_klass;
1181 }
1182 
1183 // ------------------------------------------------------------------
1184 Klass* JVMCIRuntime::get_klass_by_name(Klass* accessing_klass,
1185                                   Symbol* klass_name,
1186                                   bool require_local) {
1187   ResourceMark rm;
1188   constantPoolHandle cpool;
1189   return get_klass_by_name_impl(accessing_klass,
1190                                                  cpool,
1191                                                  klass_name,
1192                                                  require_local);
1193 }
1194 
1195 // ------------------------------------------------------------------
1196 // Implementation of get_klass_by_index.
1197 Klass* JVMCIRuntime::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
1198                                         int index,
1199                                         bool&amp; is_accessible,
1200                                         Klass* accessor) {
1201   JVMCI_EXCEPTION_CONTEXT;
1202   Klass* klass = ConstantPool::klass_at_if_loaded(cpool, index);
1203   Symbol* klass_name = NULL;
1204   if (klass == NULL) {
1205     klass_name = cpool-&gt;klass_name_at(index);
1206   }
1207 
1208   if (klass == NULL) {
1209     // Not found in constant pool.  Use the name to do the lookup.
1210     Klass* k = get_klass_by_name_impl(accessor,
1211                                         cpool,
1212                                         klass_name,
1213                                         false);
1214     // Calculate accessibility the hard way.
1215     if (k == NULL) {
1216       is_accessible = false;
1217     } else if (k-&gt;class_loader() != accessor-&gt;class_loader() &amp;&amp;
1218                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {
1219       // Loaded only remotely.  Not linked yet.
1220       is_accessible = false;
1221     } else {
1222       // Linked locally, and we must also check public/private, etc.
1223       is_accessible = check_klass_accessibility(accessor, k);
1224     }
1225     if (!is_accessible) {
1226       return NULL;
1227     }
1228     return k;
1229   }
1230 
1231   // It is known to be accessible, since it was found in the constant pool.
1232   is_accessible = true;
1233   return klass;
1234 }
1235 
1236 // ------------------------------------------------------------------
1237 // Get a klass from the constant pool.
1238 Klass* JVMCIRuntime::get_klass_by_index(const constantPoolHandle&amp; cpool,
1239                                    int index,
1240                                    bool&amp; is_accessible,
1241                                    Klass* accessor) {
1242   ResourceMark rm;
1243   Klass* result = get_klass_by_index_impl(cpool, index, is_accessible, accessor);
1244   return result;
1245 }
1246 
1247 // ------------------------------------------------------------------
1248 // Implementation of get_field_by_index.
1249 //
1250 // Implementation note: the results of field lookups are cached
1251 // in the accessor klass.
1252 void JVMCIRuntime::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor&amp; field_desc,
1253                                         int index) {
1254   JVMCI_EXCEPTION_CONTEXT;
1255 
1256   assert(klass-&gt;is_linked(), "must be linked before using its constant-pool");
1257 
1258   constantPoolHandle cpool(thread, klass-&gt;constants());
1259 
1260   // Get the field's name, signature, and type.
1261   Symbol* name  = cpool-&gt;name_ref_at(index);
1262 
1263   int nt_index = cpool-&gt;name_and_type_ref_index_at(index);
1264   int sig_index = cpool-&gt;signature_ref_index_at(nt_index);
1265   Symbol* signature = cpool-&gt;symbol_at(sig_index);
1266 
1267   // Get the field's declared holder.
1268   int holder_index = cpool-&gt;klass_ref_index_at(index);
1269   bool holder_is_accessible;
1270   Klass* declared_holder = get_klass_by_index(cpool, holder_index,
1271                                                holder_is_accessible,
1272                                                klass);
1273 
1274   // The declared holder of this field may not have been loaded.
1275   // Bail out with partial field information.
1276   if (!holder_is_accessible) {
1277     return;
1278   }
1279 
1280 
1281   // Perform the field lookup.
1282   Klass*  canonical_holder =
1283     InstanceKlass::cast(declared_holder)-&gt;find_field(name, signature, &amp;field_desc);
1284   if (canonical_holder == NULL) {
1285     return;
1286   }
1287 
1288   assert(canonical_holder == field_desc.field_holder(), "just checking");
1289 }
1290 
1291 // ------------------------------------------------------------------
1292 // Get a field by index from a klass's constant pool.
1293 void JVMCIRuntime::get_field_by_index(InstanceKlass* accessor, fieldDescriptor&amp; fd, int index) {
1294   ResourceMark rm;
1295   return get_field_by_index_impl(accessor, fd, index);
1296 }
1297 
1298 // ------------------------------------------------------------------
1299 // Perform an appropriate method lookup based on accessor, holder,
1300 // name, signature, and bytecode.
1301 Method* JVMCIRuntime::lookup_method(InstanceKlass* accessor,
1302                                     Klass*        holder,
1303                                     Symbol*       name,
1304                                     Symbol*       sig,
1305                                     Bytecodes::Code bc,
1306                                     constantTag   tag) {
1307   // Accessibility checks are performed in JVMCIEnv::get_method_by_index_impl().
1308   assert(check_klass_accessibility(accessor, holder), "holder not accessible");
1309 
1310   Method* dest_method;
1311   LinkInfo link_info(holder, name, sig, accessor, LinkInfo::needs_access_check, tag);
1312   switch (bc) {
1313   case Bytecodes::_invokestatic:
1314     dest_method =
1315       LinkResolver::resolve_static_call_or_null(link_info);
1316     break;
1317   case Bytecodes::_invokespecial:
1318     dest_method =
1319       LinkResolver::resolve_special_call_or_null(link_info);
1320     break;
1321   case Bytecodes::_invokeinterface:
1322     dest_method =
1323       LinkResolver::linktime_resolve_interface_method_or_null(link_info);
1324     break;
1325   case Bytecodes::_invokevirtual:
1326     dest_method =
1327       LinkResolver::linktime_resolve_virtual_method_or_null(link_info);
1328     break;
1329   default: ShouldNotReachHere();
1330   }
1331 
1332   return dest_method;
1333 }
1334 
1335 
1336 // ------------------------------------------------------------------
1337 Method* JVMCIRuntime::get_method_by_index_impl(const constantPoolHandle&amp; cpool,
1338                                                int index, Bytecodes::Code bc,
1339                                                InstanceKlass* accessor) {
1340   if (bc == Bytecodes::_invokedynamic) {
1341     ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);
1342     bool is_resolved = !cpce-&gt;is_f1_null();
1343     if (is_resolved) {
1344       // Get the invoker Method* from the constant pool.
1345       // (The appendix argument, if any, will be noted in the method's signature.)
1346       Method* adapter = cpce-&gt;f1_as_method();
1347       return adapter;
1348     }
1349 
1350     return NULL;
1351   }
1352 
1353   int holder_index = cpool-&gt;klass_ref_index_at(index);
1354   bool holder_is_accessible;
1355   Klass* holder = get_klass_by_index_impl(cpool, holder_index, holder_is_accessible, accessor);
1356 
1357   // Get the method's name and signature.
1358   Symbol* name_sym = cpool-&gt;name_ref_at(index);
1359   Symbol* sig_sym  = cpool-&gt;signature_ref_at(index);
1360 
1361   if (cpool-&gt;has_preresolution()
1362       || ((holder == SystemDictionary::MethodHandle_klass() || holder == SystemDictionary::VarHandle_klass()) &amp;&amp;
1363           MethodHandles::is_signature_polymorphic_name(holder, name_sym))) {
1364     // Short-circuit lookups for JSR 292-related call sites.
1365     // That is, do not rely only on name-based lookups, because they may fail
1366     // if the names are not resolvable in the boot class loader (7056328).
1367     switch (bc) {
1368     case Bytecodes::_invokevirtual:
1369     case Bytecodes::_invokeinterface:
1370     case Bytecodes::_invokespecial:
1371     case Bytecodes::_invokestatic:
1372       {
1373         Method* m = ConstantPool::method_at_if_loaded(cpool, index);
1374         if (m != NULL) {
1375           return m;
1376         }
1377       }
1378       break;
1379     default:
1380       break;
1381     }
1382   }
1383 
1384   if (holder_is_accessible) { // Our declared holder is loaded.
1385     constantTag tag = cpool-&gt;tag_ref_at(index);
1386     Method* m = lookup_method(accessor, holder, name_sym, sig_sym, bc, tag);
1387     if (m != NULL) {
1388       // We found the method.
1389       return m;
1390     }
1391   }
1392 
1393   // Either the declared holder was not loaded, or the method could
1394   // not be found.
1395 
1396   return NULL;
1397 }
1398 
1399 // ------------------------------------------------------------------
1400 InstanceKlass* JVMCIRuntime::get_instance_klass_for_declared_method_holder(Klass* method_holder) {
1401   // For the case of &lt;array&gt;.clone(), the method holder can be an ArrayKlass*
1402   // instead of an InstanceKlass*.  For that case simply pretend that the
1403   // declared holder is Object.clone since that's where the call will bottom out.
1404   if (method_holder-&gt;is_instance_klass()) {
1405     return InstanceKlass::cast(method_holder);
1406   } else if (method_holder-&gt;is_array_klass()) {
1407     return SystemDictionary::Object_klass();
1408   } else {
1409     ShouldNotReachHere();
1410   }
1411   return NULL;
1412 }
1413 
1414 
1415 // ------------------------------------------------------------------
1416 Method* JVMCIRuntime::get_method_by_index(const constantPoolHandle&amp; cpool,
1417                                      int index, Bytecodes::Code bc,
1418                                      InstanceKlass* accessor) {
1419   ResourceMark rm;
1420   return get_method_by_index_impl(cpool, index, bc, accessor);
1421 }
1422 
1423 // ------------------------------------------------------------------
1424 // Check for changes to the system dictionary during compilation
1425 // class loads, evolution, breakpoints
1426 JVMCI::CodeInstallResult JVMCIRuntime::validate_compile_task_dependencies(Dependencies* dependencies, JVMCICompileState* compile_state, char** failure_detail) {
1427   // If JVMTI capabilities were enabled during compile, the compilation is invalidated.
1428   if (compile_state != NULL &amp;&amp; compile_state-&gt;jvmti_state_changed()) {
1429     *failure_detail = (char*) "Jvmti state change during compilation invalidated dependencies";
1430     return JVMCI::dependencies_failed;
1431   }
1432 
1433   CompileTask* task = compile_state == NULL ? NULL : compile_state-&gt;task();
1434   Dependencies::DepType result = dependencies-&gt;validate_dependencies(task, failure_detail);
1435   if (result == Dependencies::end_marker) {
1436     return JVMCI::ok;
1437   }
1438 
1439   return JVMCI::dependencies_failed;
1440 }
1441 
1442 // Reports a pending exception and exits the VM.
1443 static void fatal_exception_in_compile(JVMCIEnv* JVMCIENV, JavaThread* thread, const char* msg) {
1444   // Only report a fatal JVMCI compilation exception once
1445   static volatile int report_init_failure = 0;
1446   if (!report_init_failure &amp;&amp; Atomic::cmpxchg(&amp;report_init_failure, 0, 1) == 0) {
1447       tty-&gt;print_cr("%s:", msg);
1448       JVMCIENV-&gt;describe_pending_exception(true);
1449   }
1450   JVMCIENV-&gt;clear_pending_exception();
1451   before_exit(thread);
1452   vm_exit(-1);
1453 }
1454 
1455 void JVMCIRuntime::compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; method, int entry_bci) {
1456   JVMCI_EXCEPTION_CONTEXT
1457 
1458   JVMCICompileState* compile_state = JVMCIENV-&gt;compile_state();
1459 
1460   bool is_osr = entry_bci != InvocationEntryBci;
1461   if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {
1462     // no OSR compilations during bootstrap - the compiler is just too slow at this point,
1463     // and we know that there are no endless loops
<a name="18" id="anc18"></a><span class="changed">1464     compile_state-&gt;set_failure(true, "No OSR during bootstrap");</span>
1465     return;
1466   }
<a name="19" id="anc19"></a><span class="changed">1467   if (JVMCI::in_shutdown()) {</span>
1468     compile_state-&gt;set_failure(false, "Avoiding compilation during shutdown");
1469     return;
1470   }
1471 
1472   HandleMark hm;
1473   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);
1474   if (JVMCIENV-&gt;has_pending_exception()) {
1475     fatal_exception_in_compile(JVMCIENV, thread, "Exception during HotSpotJVMCIRuntime initialization");
1476   }
1477   JVMCIObject jvmci_method = JVMCIENV-&gt;get_jvmci_method(method, JVMCIENV);
1478   if (JVMCIENV-&gt;has_pending_exception()) {
1479     JVMCIENV-&gt;describe_pending_exception(true);
1480     compile_state-&gt;set_failure(false, "exception getting JVMCI wrapper method");
1481     return;
1482   }
1483 
1484   JVMCIObject result_object = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_compileMethod(receiver, jvmci_method, entry_bci,
1485                                                                      (jlong) compile_state, compile_state-&gt;task()-&gt;compile_id());
1486   if (!JVMCIENV-&gt;has_pending_exception()) {
1487     if (result_object.is_non_null()) {
1488       JVMCIObject failure_message = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_failureMessage(result_object);
1489       if (failure_message.is_non_null()) {
1490         // Copy failure reason into resource memory first ...
1491         const char* failure_reason = JVMCIENV-&gt;as_utf8_string(failure_message);
1492         // ... and then into the C heap.
1493         failure_reason = os::strdup(failure_reason, mtJVMCI);
1494         bool retryable = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_retry(result_object) != 0;
1495         compile_state-&gt;set_failure(retryable, failure_reason, true);
1496       } else {
1497         if (compile_state-&gt;task()-&gt;code() == NULL) {
1498           compile_state-&gt;set_failure(true, "no nmethod produced");
1499         } else {
1500           compile_state-&gt;task()-&gt;set_num_inlined_bytecodes(JVMCIENV-&gt;get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));
1501           compiler-&gt;inc_methods_compiled();
1502         }
1503       }
1504     } else {
1505       assert(false, "JVMCICompiler.compileMethod should always return non-null");
1506     }
1507   } else {
1508     // An uncaught exception here implies failure during compiler initialization.
1509     // The only sensible thing to do here is to exit the VM.
1510     fatal_exception_in_compile(JVMCIENV, thread, "Exception during JVMCI compiler initialization");
1511   }
1512   if (compiler-&gt;is_bootstrapping()) {
1513     compiler-&gt;set_bootstrap_compilation_request_handled();
1514   }
1515 }
1516 
1517 
1518 // ------------------------------------------------------------------
1519 JVMCI::CodeInstallResult JVMCIRuntime::register_method(JVMCIEnv* JVMCIENV,
1520                                 const methodHandle&amp; method,
1521                                 nmethod*&amp; nm,
1522                                 int entry_bci,
1523                                 CodeOffsets* offsets,
1524                                 int orig_pc_offset,
1525                                 CodeBuffer* code_buffer,
1526                                 int frame_words,
1527                                 OopMapSet* oop_map_set,
1528                                 ExceptionHandlerTable* handler_table,
1529                                 ImplicitExceptionTable* implicit_exception_table,
1530                                 AbstractCompiler* compiler,
1531                                 DebugInformationRecorder* debug_info,
1532                                 Dependencies* dependencies,
1533                                 int compile_id,
1534                                 bool has_unsafe_access,
1535                                 bool has_wide_vector,
1536                                 JVMCIObject compiled_code,
1537                                 JVMCIObject nmethod_mirror,
1538                                 FailedSpeculation** failed_speculations,
1539                                 char* speculations,
1540                                 int speculations_len) {
1541   JVMCI_EXCEPTION_CONTEXT;
1542   nm = NULL;
1543   int comp_level = CompLevel_full_optimization;
1544   char* failure_detail = NULL;
1545 
1546   bool install_default = JVMCIENV-&gt;get_HotSpotNmethod_isDefault(nmethod_mirror) != 0;
1547   assert(JVMCIENV-&gt;isa_HotSpotNmethod(nmethod_mirror), "must be");
1548   JVMCIObject name = JVMCIENV-&gt;get_InstalledCode_name(nmethod_mirror);
1549   const char* nmethod_mirror_name = name.is_null() ? NULL : JVMCIENV-&gt;as_utf8_string(name);
1550   int nmethod_mirror_index;
1551   if (!install_default) {
1552     // Reserve or initialize mirror slot in the oops table.
1553     OopRecorder* oop_recorder = debug_info-&gt;oop_recorder();
1554     nmethod_mirror_index = oop_recorder-&gt;allocate_oop_index(nmethod_mirror.is_hotspot() ? nmethod_mirror.as_jobject() : NULL);
1555   } else {
1556     // A default HotSpotNmethod mirror is never tracked by the nmethod
1557     nmethod_mirror_index = -1;
1558   }
1559 
1560   JVMCI::CodeInstallResult result;
1561   {
1562     // To prevent compile queue updates.
1563     MutexLocker locker(THREAD, MethodCompileQueue_lock);
1564 
1565     // Prevent SystemDictionary::add_to_hierarchy from running
1566     // and invalidating our dependencies until we install this method.
1567     MutexLocker ml(Compile_lock);
1568 
1569     // Encode the dependencies now, so we can check them right away.
1570     dependencies-&gt;encode_content_bytes();
1571 
1572     // Record the dependencies for the current compile in the log
1573     if (LogCompilation) {
1574       for (Dependencies::DepStream deps(dependencies); deps.next(); ) {
1575         deps.log_dependency();
1576       }
1577     }
1578 
1579     // Check for {class loads, evolution, breakpoints} during compilation
1580     result = validate_compile_task_dependencies(dependencies, JVMCIENV-&gt;compile_state(), &amp;failure_detail);
1581     if (result != JVMCI::ok) {
1582       // While not a true deoptimization, it is a preemptive decompile.
1583       MethodData* mdp = method()-&gt;method_data();
1584       if (mdp != NULL) {
1585         mdp-&gt;inc_decompile_count();
1586 #ifdef ASSERT
1587         if (mdp-&gt;decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
1588           ResourceMark m;
1589           tty-&gt;print_cr("WARN: endless recompilation of %s. Method was set to not compilable.", method()-&gt;name_and_sig_as_C_string());
1590         }
1591 #endif
1592       }
1593 
1594       // All buffers in the CodeBuffer are allocated in the CodeCache.
1595       // If the code buffer is created on each compile attempt
1596       // as in C2, then it must be freed.
1597       //code_buffer-&gt;free_blob();
1598     } else {
1599       nm =  nmethod::new_nmethod(method,
1600                                  compile_id,
1601                                  entry_bci,
1602                                  offsets,
1603                                  orig_pc_offset,
1604                                  debug_info, dependencies, code_buffer,
1605                                  frame_words, oop_map_set,
1606                                  handler_table, implicit_exception_table,
1607                                  compiler, comp_level,
1608                                  speculations, speculations_len,
1609                                  nmethod_mirror_index, nmethod_mirror_name, failed_speculations);
1610 
1611 
1612       // Free codeBlobs
1613       if (nm == NULL) {
1614         // The CodeCache is full.  Print out warning and disable compilation.
1615         {
1616           MutexUnlocker ml(Compile_lock);
1617           MutexUnlocker locker(MethodCompileQueue_lock);
1618           CompileBroker::handle_full_code_cache(CodeCache::get_code_blob_type(comp_level));
1619         }
1620       } else {
1621         nm-&gt;set_has_unsafe_access(has_unsafe_access);
1622         nm-&gt;set_has_wide_vectors(has_wide_vector);
1623 
1624         // Record successful registration.
1625         // (Put nm into the task handle *before* publishing to the Java heap.)
1626         if (JVMCIENV-&gt;compile_state() != NULL) {
1627           JVMCIENV-&gt;compile_state()-&gt;task()-&gt;set_code(nm);
1628         }
1629 
1630         JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
1631         assert(data != NULL, "must be");
1632         if (install_default) {
1633           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == NULL, "must be");
1634           if (entry_bci == InvocationEntryBci) {
1635             if (TieredCompilation) {
1636               // If there is an old version we're done with it
1637               CompiledMethod* old = method-&gt;code();
1638               if (TraceMethodReplacement &amp;&amp; old != NULL) {
1639                 ResourceMark rm;
1640                 char *method_name = method-&gt;name_and_sig_as_C_string();
1641                 tty-&gt;print_cr("Replacing method %s", method_name);
1642               }
1643               if (old != NULL ) {
1644                 old-&gt;make_not_entrant();
1645               }
1646             }
1647 
1648             LogTarget(Info, nmethod, install) lt;
1649             if (lt.is_enabled()) {
1650               ResourceMark rm;
1651               char *method_name = method-&gt;name_and_sig_as_C_string();
1652               lt.print("Installing method (%d) %s [entry point: %p]",
1653                         comp_level, method_name, nm-&gt;entry_point());
1654             }
1655             // Allow the code to be executed
1656             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1657             if (nm-&gt;make_in_use()) {
1658               method-&gt;set_code(method, nm);
1659             }
1660           } else {
1661             LogTarget(Info, nmethod, install) lt;
1662             if (lt.is_enabled()) {
1663               ResourceMark rm;
1664               char *method_name = method-&gt;name_and_sig_as_C_string();
1665               lt.print("Installing osr method (%d) %s @ %d",
1666                         comp_level, method_name, entry_bci);
1667             }
1668             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1669             if (nm-&gt;make_in_use()) {
1670               InstanceKlass::cast(method-&gt;method_holder())-&gt;add_osr_nmethod(nm);
1671             }
1672           }
1673         } else {
1674           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == HotSpotJVMCI::resolve(nmethod_mirror), "must be");
1675         }
1676       }
1677       result = nm != NULL ? JVMCI::ok :JVMCI::cache_full;
1678     }
1679   }
1680 
1681   // String creation must be done outside lock
1682   if (failure_detail != NULL) {
1683     // A failure to allocate the string is silently ignored.
1684     JVMCIObject message = JVMCIENV-&gt;create_string(failure_detail, JVMCIENV);
1685     JVMCIENV-&gt;set_HotSpotCompiledNmethod_installationFailureMessage(compiled_code, message);
1686   }
1687 
1688   // JVMTI -- compiled method notification (must be done outside lock)
1689   if (nm != NULL) {
1690     nm-&gt;post_compiled_method_load_event();
1691   }
1692 
1693   return result;
1694 }
<a name="20" id="anc20"></a><span class="new">1695 </span>
<span class="new">1696 bool JVMCIRuntime::trace_prefix(int level) {</span>
<span class="new">1697   Thread* thread = Thread::current_or_null_safe();</span>
<span class="new">1698   if (thread != NULL) {</span>
<span class="new">1699     ResourceMark rm;</span>
<span class="new">1700     tty-&gt;print("JVMCITrace-%d[%s]:%*c", level, thread == NULL ? "?" : thread-&gt;name(), level, ' ');</span>
<span class="new">1701   } else {</span>
<span class="new">1702     tty-&gt;print("JVMCITrace-%d[?]:%*c", level, level, ' ');</span>
<span class="new">1703   }</span>
<span class="new">1704   return true;</span>
<span class="new">1705 }</span>
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="21" type="hidden" /></form></body></html>
