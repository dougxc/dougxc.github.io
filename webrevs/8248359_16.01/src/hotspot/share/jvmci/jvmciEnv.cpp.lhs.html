<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-59942">59942</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8248359">8248359</a>: [JVMCI] miscellaneous code cleanups and improvements</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "classfile/stringTable.hpp"
  27 #include "classfile/symbolTable.hpp"
  28 #include "code/codeCache.hpp"
  29 #include "compiler/compileTask.hpp"
  30 #include "memory/oopFactory.hpp"
  31 #include "memory/resourceArea.hpp"
  32 #include "memory/universe.hpp"
  33 #include "oops/objArrayKlass.hpp"
  34 #include "oops/typeArrayOop.inline.hpp"
  35 #include "runtime/deoptimization.hpp"
  36 #include "runtime/jniHandles.inline.hpp"
  37 #include "runtime/javaCalls.hpp"
  38 #include "jvmci/jniAccessMark.inline.hpp"
  39 #include "jvmci/jvmciRuntime.hpp"
  40 
  41 JVMCICompileState::JVMCICompileState(CompileTask* task):
  42   _task(task),
  43   _retryable(true),
  44   _failure_reason(NULL),
  45   _failure_reason_on_C_heap(false) {
  46   // Get Jvmti capabilities under lock to get consistent values.
  47   MutexLocker mu(JvmtiThreadState_lock);
  48   _jvmti_redefinition_count             = JvmtiExport::redefinition_count();
  49   _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint() ? 1 : 0;
  50   _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables() ? 1 : 0;
  51   _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions() ? 1 : 0;
  52   _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame() ? 1 : 0;
  53   _target_method_is_old                 = _task != NULL &amp;&amp; _task-&gt;method()-&gt;is_old();
  54 }
  55 
  56 bool JVMCICompileState::jvmti_state_changed() const {
  57   // Some classes were redefined
  58   if (jvmti_redefinition_count() != JvmtiExport::redefinition_count()) {
  59     return true;
  60   }
  61   if (!jvmti_can_access_local_variables() &amp;&amp;
  62       JvmtiExport::can_access_local_variables()) {
  63     return true;
  64   }
  65   if (!jvmti_can_hotswap_or_post_breakpoint() &amp;&amp;
  66       JvmtiExport::can_hotswap_or_post_breakpoint()) {
  67     return true;
  68   }
  69   if (!jvmti_can_post_on_exceptions() &amp;&amp;
  70       JvmtiExport::can_post_on_exceptions()) {
  71     return true;
  72   }
  73   if (!jvmti_can_pop_frame() &amp;&amp;
  74       JvmtiExport::can_pop_frame()) {
  75     return true;
  76   }
  77   return false;
  78 }
  79 
<a name="1" id="anc1"></a><span class="removed">  80 JavaVM* JVMCIEnv::_shared_library_javavm = NULL;</span>
<span class="removed">  81 void* JVMCIEnv::_shared_library_handle = NULL;</span>
<span class="removed">  82 char* JVMCIEnv::_shared_library_path = NULL;</span>
<span class="removed">  83 </span>
  84 void JVMCIEnv::copy_saved_properties() {
  85   assert(!is_hotspot(), "can only copy saved properties from HotSpot to native image");
  86 
  87   JavaThread* THREAD = JavaThread::current();
  88 
  89   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_services_Services(), Handle(), Handle(), true, THREAD);
  90   if (HAS_PENDING_EXCEPTION) {
  91     JVMCIRuntime::exit_on_pending_exception(NULL, "Error initializing jdk.vm.ci.services.Services");
  92   }
  93   InstanceKlass* ik = InstanceKlass::cast(k);
  94   if (ik-&gt;should_be_initialized()) {
  95     ik-&gt;initialize(THREAD);
  96     if (HAS_PENDING_EXCEPTION) {
  97       JVMCIRuntime::exit_on_pending_exception(NULL, "Error initializing jdk.vm.ci.services.Services");
  98     }
  99   }
 100 
 101   // Get the serialized saved properties from HotSpot
 102   TempNewSymbol serializeSavedProperties = SymbolTable::new_symbol("serializeSavedProperties");
 103   JavaValue result(T_OBJECT);
 104   JavaCallArguments args;
 105   JavaCalls::call_static(&amp;result, ik, serializeSavedProperties, vmSymbols::serializePropertiesToByteArray_signature(), &amp;args, THREAD);
 106   if (HAS_PENDING_EXCEPTION) {
 107     JVMCIRuntime::exit_on_pending_exception(NULL, "Error calling jdk.vm.ci.services.Services.serializeSavedProperties");
 108   }
 109   oop res = (oop) result.get_jobject();
 110   assert(res-&gt;is_typeArray(), "must be");
 111   assert(TypeArrayKlass::cast(res-&gt;klass())-&gt;element_type() == T_BYTE, "must be");
 112   typeArrayOop ba = typeArrayOop(res);
 113   int serialized_properties_len = ba-&gt;length();
 114 
 115   // Copy serialized saved properties from HotSpot object into native buffer
 116   jbyte* serialized_properties = NEW_RESOURCE_ARRAY(jbyte, serialized_properties_len);
 117   memcpy(serialized_properties, ba-&gt;byte_at_addr(0), serialized_properties_len);
 118 
 119   // Copy native buffer into shared library object
 120   JVMCIPrimitiveArray buf = new_byteArray(serialized_properties_len, this);
 121   if (has_pending_exception()) {
 122     describe_pending_exception(true);
 123     fatal("Error in copy_saved_properties");
 124   }
 125   copy_bytes_from(serialized_properties, buf, 0, serialized_properties_len);
 126   if (has_pending_exception()) {
 127     describe_pending_exception(true);
 128     fatal("Error in copy_saved_properties");
 129   }
 130 
 131   // Initialize saved properties in shared library
 132   jclass servicesClass = JNIJVMCI::Services::clazz();
 133   jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();
<a name="2" id="anc2"></a><span class="changed"> 134   JNIAccessMark jni(this);</span>
 135   jni()-&gt;CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());
 136   if (jni()-&gt;ExceptionCheck()) {
 137     jni()-&gt;ExceptionDescribe();
 138     fatal("Error calling jdk.vm.ci.services.Services.initializeSavedProperties");
 139   }
 140 }
 141 
<a name="3" id="anc3"></a><span class="removed"> 142 JNIEnv* JVMCIEnv::init_shared_library(JavaThread* thread) {</span>
<span class="removed"> 143   if (_shared_library_javavm == NULL) {</span>
<span class="removed"> 144     MutexLocker locker(JVMCI_lock);</span>
<span class="removed"> 145     if (_shared_library_javavm == NULL) {</span>
<span class="removed"> 146       char path[JVM_MAXPATHLEN];</span>
<span class="removed"> 147       char ebuf[1024];</span>
<span class="removed"> 148       if (JVMCILibPath != NULL) {</span>
<span class="removed"> 149         if (!os::dll_locate_lib(path, sizeof(path), JVMCILibPath, JVMCI_SHARED_LIBRARY_NAME)) {</span>
<span class="removed"> 150           vm_exit_during_initialization("Unable to create JVMCI shared library path from -XX:JVMCILibPath value", JVMCILibPath);</span>
<span class="removed"> 151         }</span>
<span class="removed"> 152       } else {</span>
<span class="removed"> 153         if (!os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {</span>
<span class="removed"> 154           vm_exit_during_initialization("Unable to create path to JVMCI shared library");</span>
<span class="removed"> 155         }</span>
<span class="removed"> 156       }</span>
<span class="removed"> 157 </span>
<span class="removed"> 158       void* handle = os::dll_load(path, ebuf, sizeof ebuf);</span>
<span class="removed"> 159       if (handle == NULL) {</span>
<span class="removed"> 160         vm_exit_during_initialization("Unable to load JVMCI shared library", ebuf);</span>
<span class="removed"> 161       }</span>
<span class="removed"> 162       _shared_library_handle = handle;</span>
<span class="removed"> 163       _shared_library_path = strdup(path);</span>
<span class="removed"> 164       jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);</span>
<span class="removed"> 165       typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);</span>
<span class="removed"> 166 </span>
<span class="removed"> 167       JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(handle, "JNI_CreateJavaVM"));</span>
<span class="removed"> 168       JNIEnv* env;</span>
<span class="removed"> 169       if (JNI_CreateJavaVM == NULL) {</span>
<span class="removed"> 170         vm_exit_during_initialization("Unable to find JNI_CreateJavaVM", path);</span>
<span class="removed"> 171       }</span>
<span class="removed"> 172 </span>
<span class="removed"> 173       ResourceMark rm;</span>
<span class="removed"> 174       JavaVMInitArgs vm_args;</span>
<span class="removed"> 175       vm_args.version = JNI_VERSION_1_2;</span>
<span class="removed"> 176       vm_args.ignoreUnrecognized = JNI_TRUE;</span>
<span class="removed"> 177       vm_args.options = NULL;</span>
<span class="removed"> 178       vm_args.nOptions = 0;</span>
<span class="removed"> 179 </span>
<span class="removed"> 180       JavaVM* the_javavm = NULL;</span>
<span class="removed"> 181       int result = (*JNI_CreateJavaVM)(&amp;the_javavm, (void**) &amp;env, &amp;vm_args);</span>
<span class="removed"> 182       if (result == JNI_OK) {</span>
<span class="removed"> 183         guarantee(env != NULL, "missing env");</span>
<span class="removed"> 184         _shared_library_javavm = the_javavm;</span>
<span class="removed"> 185         return env;</span>
<span class="removed"> 186       } else {</span>
<span class="removed"> 187         vm_exit_during_initialization(err_msg("JNI_CreateJavaVM failed with return value %d", result), path);</span>
<span class="removed"> 188       }</span>
<span class="removed"> 189     }</span>
<span class="removed"> 190   }</span>
<span class="removed"> 191   return NULL;</span>
<span class="removed"> 192 }</span>
<span class="removed"> 193 </span>
 194 void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {
 195   assert(thread != NULL, "npe");
<a name="4" id="anc4"></a><span class="removed"> 196   // By default there is only one runtime which is the compiler runtime.</span>
<span class="removed"> 197   _runtime = JVMCI::compiler_runtime();</span>
 198   _env = NULL;
 199   _pop_frame_on_close = false;
 200   _detach_on_close = false;
 201   if (!UseJVMCINativeLibrary) {
 202     // In HotSpot mode, JNI isn't used at all.
<a name="5" id="anc5"></a>
 203     _is_hotspot = true;
 204     return;
 205   }
 206 
 207   if (parent_env != NULL) {
 208     // If the parent JNI environment is non-null then figure out whether it
 209     // is a HotSpot or shared library JNIEnv and set the state appropriately.
 210     _is_hotspot = thread-&gt;jni_environment() == parent_env;
 211     if (_is_hotspot) {
 212       // Select the Java runtime
 213       _runtime = JVMCI::java_runtime();
 214       return;
 215     }
<a name="6" id="anc6"></a>

 216     _env = parent_env;
 217     return;
 218   }
 219 
 220   // Running in JVMCI shared library mode so ensure the shared library
 221   // is loaded and initialized and get a shared library JNIEnv
 222   _is_hotspot = false;
<a name="7" id="anc7"></a><span class="changed"> 223   _env = init_shared_library(thread);</span>


 224 
 225   if (_env != NULL) {
 226     // Creating the JVMCI shared library VM also attaches the current thread
 227     _detach_on_close = true;
 228   } else {
<a name="8" id="anc8"></a><span class="changed"> 229     _shared_library_javavm-&gt;GetEnv((void**)&amp;parent_env, JNI_VERSION_1_2);</span>
 230     if (parent_env != NULL) {
 231       // Even though there's a parent JNI env, there's no guarantee
 232       // it was opened by a JVMCIEnv scope and thus may not have
 233       // pushed a local JNI frame. As such, we use a new JNI local
 234       // frame in this scope to ensure local JNI refs are collected
 235       // in a timely manner after leaving this scope.
 236       _env = parent_env;
 237     } else {
 238       ResourceMark rm; // Thread name is resource allocated
 239       JavaVMAttachArgs attach_args;
 240       attach_args.version = JNI_VERSION_1_2;
 241       attach_args.name = thread-&gt;name();
 242       attach_args.group = NULL;
<a name="9" id="anc9"></a><span class="changed"> 243       if (_shared_library_javavm-&gt;AttachCurrentThread((void**)&amp;_env, &amp;attach_args) != JNI_OK) {</span>
 244         fatal("Error attaching current thread (%s) to JVMCI shared library JNI interface", attach_args.name);
 245       }
 246       _detach_on_close = true;
 247     }
 248   }
 249 
 250   assert(_env != NULL, "missing env");
 251   assert(_throw_to_caller == false, "must be");
 252 
<a name="10" id="anc10"></a><span class="changed"> 253   JNIAccessMark jni(this);</span>
 254   jint result = _env-&gt;PushLocalFrame(32);
 255   if (result != JNI_OK) {
 256     char message[256];
 257     jio_snprintf(message, 256, "Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d", _file, _line);
 258     JVMCIRuntime::exit_on_pending_exception(this, message);
 259   }
 260   _pop_frame_on_close = true;
 261 }
 262 
 263 JVMCIEnv::JVMCIEnv(JavaThread* thread, JVMCICompileState* compile_state, const char* file, int line):
 264     _throw_to_caller(false), _file(file), _line(line), _compile_state(compile_state) {
 265   init_env_mode_runtime(thread, NULL);
 266 }
 267 
 268 JVMCIEnv::JVMCIEnv(JavaThread* thread, const char* file, int line):
 269     _throw_to_caller(false), _file(file), _line(line), _compile_state(NULL) {
 270   init_env_mode_runtime(thread, NULL);
 271 }
 272 
 273 JVMCIEnv::JVMCIEnv(JavaThread* thread, JNIEnv* parent_env, const char* file, int line):
 274     _throw_to_caller(true), _file(file), _line(line), _compile_state(NULL) {
 275   init_env_mode_runtime(thread, parent_env);
 276   assert(_env == NULL || parent_env == _env, "mismatched JNIEnvironment");
 277 }
 278 
 279 void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, const char* file, int line) {
 280   _compile_state = NULL;
 281   _throw_to_caller = false;
 282   _file = file;
 283   _line = line;
 284   if (is_hotspot) {
 285     _env = NULL;
 286     _pop_frame_on_close = false;
 287     _detach_on_close = false;
 288     _is_hotspot = true;
 289     _runtime = JVMCI::java_runtime();
 290   } else {
 291     init_env_mode_runtime(thread, NULL);
 292   }
 293 }
 294 
 295 // Prints a pending exception (if any) and its stack trace.
 296 void JVMCIEnv::describe_pending_exception(bool clear) {
<a name="11" id="anc11"></a>
 297   if (!is_hotspot()) {
 298     JNIAccessMark jni(this);
 299     if (jni()-&gt;ExceptionCheck()) {
 300       jthrowable ex = !clear ? jni()-&gt;ExceptionOccurred() : NULL;
 301       jni()-&gt;ExceptionDescribe();
 302       if (ex != NULL) {
 303         jni()-&gt;Throw(ex);
 304       }
 305     }
 306   } else {
<a name="12" id="anc12"></a><span class="removed"> 307     Thread* THREAD = Thread::current();</span>
 308     if (HAS_PENDING_EXCEPTION) {
 309       JVMCIRuntime::describe_pending_hotspot_exception((JavaThread*) THREAD, clear);
 310     }
 311   }
 312 }
 313 
 314 void JVMCIEnv::translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle&amp; throwable) {
 315   assert(!is_hotspot(), "must_be");
 316   // Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets
 317   // may not have been called.
 318   Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);
 319   JavaCallArguments jargs;
 320   jargs.push_oop(throwable);
 321   JavaValue result(T_OBJECT);
 322   JavaCalls::call_static(&amp;result,
 323                           runtimeKlass,
 324                           vmSymbols::encodeThrowable_name(),
 325                           vmSymbols::encodeThrowable_signature(), &amp;jargs, THREAD);
 326   if (HAS_PENDING_EXCEPTION) {
 327     JVMCIRuntime::exit_on_pending_exception(this, "HotSpotJVMCIRuntime.encodeThrowable should not throw an exception");
 328   }
 329 
 330   oop encoded_throwable_string = (oop) result.get_jobject();
 331 
 332   ResourceMark rm;
 333   const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);
 334 
<a name="13" id="anc13"></a><span class="changed"> 335   JNIAccessMark jni(this);</span>
 336   jobject jni_encoded_throwable_string = jni()-&gt;NewStringUTF(encoded_throwable_chars);
 337   jthrowable jni_throwable = (jthrowable) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 338                                 JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),
 339                                 jni_encoded_throwable_string);
 340   jni()-&gt;Throw(jni_throwable);
 341 }
 342 
 343 JVMCIEnv::~JVMCIEnv() {
 344   if (_throw_to_caller) {
 345     if (is_hotspot()) {
 346       // Nothing to do
 347     } else {
 348       if (Thread::current()-&gt;is_Java_thread()) {
 349         JavaThread* THREAD = JavaThread::current();
 350         if (HAS_PENDING_EXCEPTION) {
 351           Handle throwable = Handle(THREAD, PENDING_EXCEPTION);
 352           CLEAR_PENDING_EXCEPTION;
 353           translate_hotspot_exception_to_jni_exception(THREAD, throwable);
 354         }
 355       }
 356     }
 357   } else {
 358     if (_pop_frame_on_close) {
 359       // Pop the JNI local frame that was pushed when entering this JVMCIEnv scope.
 360       JNIAccessMark jni(this);
 361       jni()-&gt;PopLocalFrame(NULL);
 362     }
 363 
 364     if (has_pending_exception()) {
 365       char message[256];
 366       jio_snprintf(message, 256, "Uncaught exception exiting JVMCIEnv scope entered at %s:%d", _file, _line);
 367       JVMCIRuntime::exit_on_pending_exception(this, message);
 368     }
 369 
 370     if (_detach_on_close) {
<a name="14" id="anc14"></a><span class="changed"> 371       get_shared_library_javavm()-&gt;DetachCurrentThread();</span>
 372     }
 373   }
 374 }
 375 
 376 jboolean JVMCIEnv::has_pending_exception() {
 377   if (is_hotspot()) {
 378     Thread* THREAD = Thread::current();
 379     return HAS_PENDING_EXCEPTION;
 380   } else {
 381     JNIAccessMark jni(this);
 382     return jni()-&gt;ExceptionCheck();
 383   }
 384 }
 385 
 386 void JVMCIEnv::clear_pending_exception() {
 387   if (is_hotspot()) {
 388     Thread* THREAD = Thread::current();
 389     CLEAR_PENDING_EXCEPTION;
 390   } else {
 391     JNIAccessMark jni(this);
 392     jni()-&gt;ExceptionClear();
 393   }
 394 }
 395 
 396 int JVMCIEnv::get_length(JVMCIArray array) {
 397   if (is_hotspot()) {
 398     return HotSpotJVMCI::resolve(array)-&gt;length();
 399   } else {
 400     JNIAccessMark jni(this);
 401     return jni()-&gt;GetArrayLength(get_jarray(array));
 402   }
 403 }
 404 
 405 JVMCIObject JVMCIEnv::get_object_at(JVMCIObjectArray array, int index) {
 406   if (is_hotspot()) {
 407     oop result = HotSpotJVMCI::resolve(array)-&gt;obj_at(index);
 408     return wrap(result);
 409   } else {
 410     JNIAccessMark jni(this);
 411     jobject result = jni()-&gt;GetObjectArrayElement(get_jobjectArray(array), index);
 412     return wrap(result);
 413   }
 414 }
 415 
 416 void JVMCIEnv::put_object_at(JVMCIObjectArray array, int index, JVMCIObject value) {
 417   if (is_hotspot()) {
 418     HotSpotJVMCI::resolve(array)-&gt;obj_at_put(index, HotSpotJVMCI::resolve(value));
 419   } else {
 420     JNIAccessMark jni(this);
 421     jni()-&gt;SetObjectArrayElement(get_jobjectArray(array), index, get_jobject(value));
 422   }
 423 }
 424 
 425 jboolean JVMCIEnv::get_bool_at(JVMCIPrimitiveArray array, int index) {
 426   if (is_hotspot()) {
 427     return HotSpotJVMCI::resolve(array)-&gt;bool_at(index);
 428   } else {
 429     JNIAccessMark jni(this);
 430     jboolean result;
 431     jni()-&gt;GetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;result);
 432     return result;
 433   }
 434 }
 435 void JVMCIEnv::put_bool_at(JVMCIPrimitiveArray array, int index, jboolean value) {
 436   if (is_hotspot()) {
 437     HotSpotJVMCI::resolve(array)-&gt;bool_at_put(index, value);
 438   } else {
 439     JNIAccessMark jni(this);
 440     jni()-&gt;SetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;value);
 441   }
 442 }
 443 
 444 jbyte JVMCIEnv::get_byte_at(JVMCIPrimitiveArray array, int index) {
 445   if (is_hotspot()) {
 446     return HotSpotJVMCI::resolve(array)-&gt;byte_at(index);
 447   } else {
 448     JNIAccessMark jni(this);
 449     jbyte result;
 450     jni()-&gt;GetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;result);
 451     return result;
 452   }
 453 }
 454 void JVMCIEnv::put_byte_at(JVMCIPrimitiveArray array, int index, jbyte value) {
 455   if (is_hotspot()) {
 456     HotSpotJVMCI::resolve(array)-&gt;byte_at_put(index, value);
 457   } else {
 458     JNIAccessMark jni(this);
 459     jni()-&gt;SetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;value);
 460   }
 461 }
 462 
 463 jint JVMCIEnv::get_int_at(JVMCIPrimitiveArray array, int index) {
 464   if (is_hotspot()) {
 465     return HotSpotJVMCI::resolve(array)-&gt;int_at(index);
 466   } else {
 467     JNIAccessMark jni(this);
 468     jint result;
 469     jni()-&gt;GetIntArrayRegion(array.as_jintArray(), index, 1, &amp;result);
 470     return result;
 471   }
 472 }
 473 void JVMCIEnv::put_int_at(JVMCIPrimitiveArray array, int index, jint value) {
 474   if (is_hotspot()) {
 475     HotSpotJVMCI::resolve(array)-&gt;int_at_put(index, value);
 476   } else {
 477     JNIAccessMark jni(this);
 478     jni()-&gt;SetIntArrayRegion(array.as_jintArray(), index, 1, &amp;value);
 479   }
 480 }
 481 
 482 long JVMCIEnv::get_long_at(JVMCIPrimitiveArray array, int index) {
 483   if (is_hotspot()) {
 484     return HotSpotJVMCI::resolve(array)-&gt;long_at(index);
 485   } else {
 486     JNIAccessMark jni(this);
 487     jlong result;
 488     jni()-&gt;GetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;result);
 489     return result;
 490   }
 491 }
 492 void JVMCIEnv::put_long_at(JVMCIPrimitiveArray array, int index, jlong value) {
 493   if (is_hotspot()) {
 494     HotSpotJVMCI::resolve(array)-&gt;long_at_put(index, value);
 495   } else {
 496     JNIAccessMark jni(this);
 497     jni()-&gt;SetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;value);
 498   }
 499 }
 500 
 501 void JVMCIEnv::copy_bytes_to(JVMCIPrimitiveArray src, jbyte* dest, int offset, jsize length) {
 502   if (length == 0) {
 503     return;
 504   }
 505   if (is_hotspot()) {
 506     memcpy(dest, HotSpotJVMCI::resolve(src)-&gt;byte_at_addr(offset), length);
 507   } else {
 508     JNIAccessMark jni(this);
 509     jni()-&gt;GetByteArrayRegion(src.as_jbyteArray(), offset, length, dest);
 510   }
 511 }
 512 void JVMCIEnv::copy_bytes_from(jbyte* src, JVMCIPrimitiveArray dest, int offset, jsize length) {
 513   if (length == 0) {
 514     return;
 515   }
 516   if (is_hotspot()) {
 517     memcpy(HotSpotJVMCI::resolve(dest)-&gt;byte_at_addr(offset), src, length);
 518   } else {
 519     JNIAccessMark jni(this);
 520     jni()-&gt;SetByteArrayRegion(dest.as_jbyteArray(), offset, length, src);
 521   }
 522 }
 523 
 524 void JVMCIEnv::copy_longs_from(jlong* src, JVMCIPrimitiveArray dest, int offset, jsize length) {
 525   if (length == 0) {
 526     return;
 527   }
 528   if (is_hotspot()) {
 529     memcpy(HotSpotJVMCI::resolve(dest)-&gt;long_at_addr(offset), src, length * sizeof(jlong));
 530   } else {
 531     JNIAccessMark jni(this);
 532     jni()-&gt;SetLongArrayRegion(dest.as_jlongArray(), offset, length, src);
 533   }
 534 }
 535 
 536 jboolean JVMCIEnv::is_boxing_object(BasicType type, JVMCIObject object) {
 537   if (is_hotspot()) {
 538     return java_lang_boxing_object::is_instance(HotSpotJVMCI::resolve(object), type);
 539   } else {
 540     JNIAccessMark jni(this);
 541     return jni()-&gt;IsInstanceOf(get_jobject(object), JNIJVMCI::box_class(type));
 542   }
 543 }
 544 
 545 // Get the primitive value from a Java boxing object.  It's hard error to
 546 // pass a non-primitive BasicType.
 547 jvalue JVMCIEnv::get_boxed_value(BasicType type, JVMCIObject object) {
 548   jvalue result;
 549   if (is_hotspot()) {
 550     if (java_lang_boxing_object::get_value(HotSpotJVMCI::resolve(object), &amp;result) == T_ILLEGAL) {
 551       ShouldNotReachHere();
 552     }
 553   } else {
 554     JNIAccessMark jni(this);
 555     jfieldID field = JNIJVMCI::box_field(type);
 556     switch (type) {
 557       case T_BOOLEAN: result.z = jni()-&gt;GetBooleanField(get_jobject(object), field); break;
 558       case T_BYTE:    result.b = jni()-&gt;GetByteField(get_jobject(object), field); break;
 559       case T_SHORT:   result.s = jni()-&gt;GetShortField(get_jobject(object), field); break;
 560       case T_CHAR:    result.c = jni()-&gt;GetCharField(get_jobject(object), field); break;
 561       case T_INT:     result.i = jni()-&gt;GetIntField(get_jobject(object), field); break;
 562       case T_LONG:    result.j = jni()-&gt;GetLongField(get_jobject(object), field); break;
 563       case T_FLOAT:   result.f = jni()-&gt;GetFloatField(get_jobject(object), field); break;
 564       case T_DOUBLE:  result.d = jni()-&gt;GetDoubleField(get_jobject(object), field); break;
 565       default:
 566         ShouldNotReachHere();
 567     }
 568   }
 569   return result;
 570 }
 571 
 572 // Return the BasicType of the object if it's a boxing object, otherwise return T_ILLEGAL.
 573 BasicType JVMCIEnv::get_box_type(JVMCIObject object) {
 574   if (is_hotspot()) {
 575     return java_lang_boxing_object::basic_type(HotSpotJVMCI::resolve(object));
 576   } else {
 577     JNIAccessMark jni(this);
 578     jclass clazz = jni()-&gt;GetObjectClass(get_jobject(object));
 579     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BOOLEAN))) return T_BOOLEAN;
 580     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BYTE))) return T_BYTE;
 581     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_SHORT))) return T_SHORT;
 582     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_CHAR))) return T_CHAR;
 583     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_INT))) return T_INT;
 584     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_LONG))) return T_LONG;
 585     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_FLOAT))) return T_FLOAT;
 586     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_DOUBLE))) return T_DOUBLE;
 587     return T_ILLEGAL;
 588   }
 589 }
 590 
 591 // Create a boxing object of the appropriate primitive type.
 592 JVMCIObject JVMCIEnv::create_box(BasicType type, jvalue* value, JVMCI_TRAPS) {
 593   switch (type) {
 594     case T_BOOLEAN:
 595     case T_BYTE:
 596     case T_CHAR:
 597     case T_SHORT:
 598     case T_INT:
 599     case T_LONG:
 600     case T_FLOAT:
 601     case T_DOUBLE:
 602       break;
 603     default:
 604       JVMCI_THROW_MSG_(IllegalArgumentException, "Only boxes for primitive values can be created", JVMCIObject());
 605   }
<a name="15" id="anc15"></a><span class="removed"> 606   if (is_hotspot()) {</span>
 607     JavaThread* THREAD = JavaThread::current();
<a name="16" id="anc16"></a>
 608     oop box = java_lang_boxing_object::create(type, value, CHECK_(JVMCIObject()));
 609     return HotSpotJVMCI::wrap(box);
 610   } else {
<a name="17" id="anc17"></a><span class="changed"> 611     JNIAccessMark jni(this);</span>
 612     jobject box = jni()-&gt;NewObjectA(JNIJVMCI::box_class(type), JNIJVMCI::box_constructor(type), value);
 613     assert(box != NULL, "");
 614     return wrap(box);
 615   }
 616 }
 617 
 618 const char* JVMCIEnv::as_utf8_string(JVMCIObject str) {
 619   if (is_hotspot()) {
 620     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str));
 621   } else {
 622     JNIAccessMark jni(this);
 623     int length = jni()-&gt;GetStringLength(str.as_jstring());
 624     char* result = NEW_RESOURCE_ARRAY(char, length + 1);
 625     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, result);
 626     return result;
 627   }
 628 }
 629 
 630 char* JVMCIEnv::as_utf8_string(JVMCIObject str, char* buf, int buflen) {
 631   if (is_hotspot()) {
 632     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str), buf, buflen);
 633   } else {
 634     JNIAccessMark jni(this);
 635     int length = jni()-&gt;GetStringLength(str.as_jstring());
 636     if (length &gt;= buflen) {
 637       length = buflen;
 638     }
 639     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, buf);
 640     return buf;
 641   }
 642 }
 643 
 644 #define DO_THROW(name)                             \
 645 void JVMCIEnv::throw_##name(const char* msg) {     \
 646   if (is_hotspot()) {                              \
 647     JavaThread* THREAD = JavaThread::current();    \
 648     THROW_MSG(HotSpotJVMCI::name::symbol(), msg);  \
 649   } else {                                         \
 650     JNIAccessMark jni(this);                       \
 651     jni()-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg); \
 652   }                                                \
 653 }
 654 
 655 DO_THROW(InternalError)
 656 DO_THROW(ArrayIndexOutOfBoundsException)
 657 DO_THROW(IllegalStateException)
 658 DO_THROW(NullPointerException)
 659 DO_THROW(IllegalArgumentException)
 660 DO_THROW(InvalidInstalledCodeException)
 661 DO_THROW(UnsatisfiedLinkError)
 662 DO_THROW(UnsupportedOperationException)
 663 DO_THROW(ClassNotFoundException)
 664 
 665 #undef DO_THROW
 666 
 667 void JVMCIEnv::fthrow_error(const char* file, int line, const char* format, ...) {
 668   const int max_msg_size = 1024;
 669   va_list ap;
 670   va_start(ap, format);
 671   char msg[max_msg_size];
 672   vsnprintf(msg, max_msg_size, format, ap);
 673   msg[max_msg_size-1] = '\0';
 674   va_end(ap);
<a name="18" id="anc18"></a><span class="removed"> 675   if (is_hotspot()) {</span>
 676     JavaThread* THREAD = JavaThread::current();
<a name="19" id="anc19"></a>
 677     Handle h_loader = Handle();
 678     Handle h_protection_domain = Handle();
 679     Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);
 680   } else {
<a name="20" id="anc20"></a><span class="changed"> 681     JNIAccessMark jni(this);</span>
 682     jni()-&gt;ThrowNew(JNIJVMCI::JVMCIError::clazz(), msg);
 683   }
 684 }
 685 
 686 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_compileMethod (JVMCIObject runtime, JVMCIObject method, int entry_bci,
 687                                                               jlong compile_state, int id) {
 688   if (is_hotspot()) {
 689     Thread* THREAD = Thread::current();
 690     JavaCallArguments jargs;
 691     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 692     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(method)));
 693     jargs.push_int(entry_bci);
 694     jargs.push_long(compile_state);
 695     jargs.push_int(id);
 696     JavaValue result(T_OBJECT);
 697     JavaCalls::call_special(&amp;result,
 698                             HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 699                             vmSymbols::compileMethod_name(),
 700                             vmSymbols::compileMethod_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 701     return wrap((oop) result.get_jobject());
 702   } else {
 703     JNIAccessMark jni(this);
 704     jobject result = jni()-&gt;CallNonvirtualObjectMethod(runtime.as_jobject(),
 705                                                      JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 706                                                      JNIJVMCI::HotSpotJVMCIRuntime::compileMethod_method(),
 707                                                      method.as_jobject(), entry_bci, compile_state, id);
 708     if (jni()-&gt;ExceptionCheck()) {
 709       return JVMCIObject();
 710     }
 711     return wrap(result);
 712   }
 713 }
 714 
 715 void JVMCIEnv::call_HotSpotJVMCIRuntime_bootstrapFinished (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 716   if (is_hotspot()) {
 717     Thread* THREAD = Thread::current();
 718     JavaCallArguments jargs;
 719     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 720     JavaValue result(T_VOID);
 721     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::bootstrapFinished_name(), vmSymbols::void_method_signature(), &amp;jargs, CHECK);
 722   } else {
 723     JNIAccessMark jni(this);
 724     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::bootstrapFinished_method());
 725 
 726   }
 727 }
 728 
 729 void JVMCIEnv::call_HotSpotJVMCIRuntime_shutdown (JVMCIObject runtime) {
 730   HandleMark hm;
 731   JavaThread* THREAD = JavaThread::current();
 732   if (is_hotspot()) {
 733     JavaCallArguments jargs;
 734     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 735     JavaValue result(T_VOID);
 736     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &amp;jargs, THREAD);
 737   } else {
<a name="21" id="anc21"></a><span class="changed"> 738     JNIAccessMark jni(this);</span>
 739     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::shutdown_method());
 740   }
 741   if (has_pending_exception()) {
 742     // This should never happen as HotSpotJVMCIRuntime.shutdown() should
 743     // handle all exceptions.
 744     describe_pending_exception(true);
 745   }
 746 }
 747 
 748 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_runtime (JVMCIEnv* JVMCIENV) {
 749   JavaThread* THREAD = JavaThread::current();
 750   if (is_hotspot()) {
 751     JavaCallArguments jargs;
 752     JavaValue result(T_OBJECT);
 753     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::runtime_name(), vmSymbols::runtime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 754     return wrap((oop) result.get_jobject());
 755   } else {
<a name="22" id="anc22"></a><span class="changed"> 756     JNIAccessMark jni(this);</span>
 757     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::runtime_method());
 758     if (jni()-&gt;ExceptionCheck()) {
 759       return JVMCIObject();
 760     }
 761     return wrap(result);
 762   }
 763 }
 764 
 765 JVMCIObject JVMCIEnv::call_JVMCI_getRuntime (JVMCIEnv* JVMCIENV) {
 766   JavaThread* THREAD = JavaThread::current();
 767   if (is_hotspot()) {
 768     JavaCallArguments jargs;
 769     JavaValue result(T_OBJECT);
 770     JavaCalls::call_static(&amp;result, HotSpotJVMCI::JVMCI::klass(), vmSymbols::getRuntime_name(), vmSymbols::getRuntime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 771     return wrap((oop) result.get_jobject());
 772   } else {
<a name="23" id="anc23"></a><span class="changed"> 773     JNIAccessMark jni(this);</span>
 774     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JVMCI::clazz(), JNIJVMCI::JVMCI::getRuntime_method());
 775     if (jni()-&gt;ExceptionCheck()) {
 776       return JVMCIObject();
 777     }
 778     return wrap(result);
 779   }
 780 }
 781 
 782 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_getCompiler (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 783   JavaThread* THREAD = JavaThread::current();
 784   if (is_hotspot()) {
 785     JavaCallArguments jargs;
 786     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 787     JavaValue result(T_OBJECT);
 788     JavaCalls::call_virtual(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::getCompiler_name(), vmSymbols::getCompiler_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 789     return wrap((oop) result.get_jobject());
 790   } else {
<a name="24" id="anc24"></a><span class="changed"> 791     JNIAccessMark jni(this);</span>
 792     jobject result = jni()-&gt;CallObjectMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::getCompiler_method());
 793     if (jni()-&gt;ExceptionCheck()) {
 794       return JVMCIObject();
 795     }
 796     return wrap(result);
 797   }
 798 }
 799 
 800 
 801 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCIEnv* JVMCIENV) {
 802   JavaThread* THREAD = JavaThread::current();
 803   if (is_hotspot()) {
 804     JavaCallArguments jargs;
 805     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));
 806     JavaValue result(T_OBJECT);
 807     JavaCalls::call_static(&amp;result,
 808                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 809                            vmSymbols::callToString_name(),
 810                            vmSymbols::callToString_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 811     return wrap((oop) result.get_jobject());
 812   } else {
<a name="25" id="anc25"></a><span class="changed"> 813     JNIAccessMark jni(this);</span>
 814     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 815                                                      JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),
 816                                                      object.as_jobject());
 817     if (jni()-&gt;ExceptionCheck()) {
 818       return JVMCIObject();
 819     }
 820     return wrap(result);
 821   }
 822 }
 823 
 824 
 825 JVMCIObject JVMCIEnv::call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS) {
 826   JavaThread* THREAD = JavaThread::current();
 827   if (is_hotspot()) {
 828     JavaCallArguments jargs;
 829     jargs.push_int(kind);
 830     jargs.push_long(value);
 831     JavaValue result(T_OBJECT);
 832     JavaCalls::call_static(&amp;result,
 833                            HotSpotJVMCI::PrimitiveConstant::klass(),
 834                            vmSymbols::forTypeChar_name(),
 835                            vmSymbols::forTypeChar_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 836     return wrap((oop) result.get_jobject());
 837   } else {
<a name="26" id="anc26"></a><span class="changed"> 838     JNIAccessMark jni(this);</span>
 839     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),
 840                                                      JNIJVMCI::PrimitiveConstant::forTypeChar_method(),
 841                                                      kind, value);
 842     if (jni()-&gt;ExceptionCheck()) {
 843       return JVMCIObject();
 844     }
 845     return wrap(result);
 846   }
 847 }
 848 
 849 JVMCIObject JVMCIEnv::call_JavaConstant_forFloat(float value, JVMCI_TRAPS) {
 850   JavaThread* THREAD = JavaThread::current();
 851   if (is_hotspot()) {
 852     JavaCallArguments jargs;
 853     jargs.push_float(value);
 854     JavaValue result(T_OBJECT);
 855     JavaCalls::call_static(&amp;result,
 856                            HotSpotJVMCI::JavaConstant::klass(),
 857                            vmSymbols::forFloat_name(),
 858                            vmSymbols::forFloat_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 859     return wrap((oop) result.get_jobject());
 860   } else {
<a name="27" id="anc27"></a><span class="changed"> 861     JNIAccessMark jni(this);</span>
 862     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 863                                                      JNIJVMCI::JavaConstant::forFloat_method(),
 864                                                      value);
 865     if (jni()-&gt;ExceptionCheck()) {
 866       return JVMCIObject();
 867     }
 868     return wrap(result);
 869   }
 870 }
 871 
 872 JVMCIObject JVMCIEnv::call_JavaConstant_forDouble(double value, JVMCI_TRAPS) {
 873   JavaThread* THREAD = JavaThread::current();
 874   if (is_hotspot()) {
 875     JavaCallArguments jargs;
 876     jargs.push_double(value);
 877     JavaValue result(T_OBJECT);
 878     JavaCalls::call_static(&amp;result,
 879                            HotSpotJVMCI::JavaConstant::klass(),
 880                            vmSymbols::forDouble_name(),
 881                            vmSymbols::forDouble_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 882     return wrap((oop) result.get_jobject());
 883   } else {
<a name="28" id="anc28"></a><span class="changed"> 884     JNIAccessMark jni(this);</span>
 885     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 886                                                      JNIJVMCI::JavaConstant::forDouble_method(),
 887                                                      value);
 888     if (jni()-&gt;ExceptionCheck()) {
 889       return JVMCIObject();
 890     }
 891     return wrap(result);
 892   }
 893 }
 894 
 895 JVMCIObject JVMCIEnv::get_jvmci_primitive_type(BasicType type) {
 896   JVMCIObjectArray primitives = get_HotSpotResolvedPrimitiveType_primitives();
 897   JVMCIObject result = get_object_at(primitives, type);
 898   return result;
 899 }
 900 
 901 JVMCIObject JVMCIEnv::new_StackTraceElement(const methodHandle&amp; method, int bci, JVMCI_TRAPS) {
 902   JavaThread* THREAD = JavaThread::current();
 903   Symbol* file_name_sym;
 904   int line_number;
 905   java_lang_StackTraceElement::decode(method, bci, file_name_sym, line_number, CHECK_(JVMCIObject()));
 906 
 907   Symbol* method_name_sym = method-&gt;name();
 908   InstanceKlass* holder = method-&gt;method_holder();
 909   const char* declaring_class_str = holder-&gt;external_name();
 910 
 911   if (is_hotspot()) {
 912     HotSpotJVMCI::StackTraceElement::klass()-&gt;initialize(CHECK_(JVMCIObject()));
 913     oop objOop = HotSpotJVMCI::StackTraceElement::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
 914     Handle obj = Handle(THREAD, objOop);
 915 
 916     oop declaring_class = StringTable::intern((char*) declaring_class_str, CHECK_(JVMCIObject()));
 917     HotSpotJVMCI::StackTraceElement::set_declaringClass(this, obj(), declaring_class);
 918 
 919     oop method_name = StringTable::intern(method_name_sym, CHECK_(JVMCIObject()));
 920     HotSpotJVMCI::StackTraceElement::set_methodName(this, obj(), method_name);
 921 
 922     if (file_name_sym != NULL) {
 923       oop file_name = StringTable::intern(file_name_sym, CHECK_(JVMCIObject()));
 924       HotSpotJVMCI::StackTraceElement::set_fileName(this, obj(), file_name);
 925     }
 926     HotSpotJVMCI::StackTraceElement::set_lineNumber(this, obj(), line_number);
 927     return wrap(obj());
 928   } else {
<a name="29" id="anc29"></a><span class="changed"> 929     JNIAccessMark jni(this);</span>
 930     jobject declaring_class = jni()-&gt;NewStringUTF(declaring_class_str);
 931     if (jni()-&gt;ExceptionCheck()) {
 932       return JVMCIObject();
 933     }
 934     jobject method_name = jni()-&gt;NewStringUTF(method_name_sym-&gt;as_C_string());
 935     if (jni()-&gt;ExceptionCheck()) {
 936       return JVMCIObject();
 937     }
 938     jobject file_name = NULL;
 939     if (file_name_sym != NULL) {
 940       file_name = jni()-&gt;NewStringUTF(file_name_sym-&gt;as_C_string());
 941       if (jni()-&gt;ExceptionCheck()) {
 942         return JVMCIObject();
 943       }
 944     }
 945 
 946     jobject result = jni()-&gt;NewObject(JNIJVMCI::StackTraceElement::clazz(),
 947                                       JNIJVMCI::StackTraceElement::constructor(),
 948                                       declaring_class, method_name, file_name, line_number);
 949     return wrap(result);
 950   }
 951 }
 952 
 953 JVMCIObject JVMCIEnv::new_HotSpotNmethod(const methodHandle&amp; method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS) {
 954   JavaThread* THREAD = JavaThread::current();
 955 
 956   JVMCIObject methodObject = get_jvmci_method(method, JVMCI_CHECK_(JVMCIObject()));
 957 
 958   if (is_hotspot()) {
 959     InstanceKlass* ik = InstanceKlass::cast(HotSpotJVMCI::HotSpotNmethod::klass());
 960     if (ik-&gt;should_be_initialized()) {
 961       ik-&gt;initialize(CHECK_(JVMCIObject()));
 962     }
 963     oop obj = ik-&gt;allocate_instance(CHECK_(JVMCIObject()));
 964     Handle obj_h(THREAD, obj);
 965     Handle nameStr = java_lang_String::create_from_str(name, CHECK_(JVMCIObject()));
 966 
 967     // Call constructor
 968     JavaCallArguments jargs;
 969     jargs.push_oop(obj_h);
 970     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(methodObject)));
 971     jargs.push_oop(nameStr);
 972     jargs.push_int(isDefault);
 973     jargs.push_long(compileId);
 974     JavaValue result(T_VOID);
 975     JavaCalls::call_special(&amp;result, ik,
 976                             vmSymbols::object_initializer_name(),
 977                             vmSymbols::method_string_bool_long_signature(),
 978                             &amp;jargs, CHECK_(JVMCIObject()));
 979     return wrap(obj_h());
 980   } else {
<a name="30" id="anc30"></a><span class="changed"> 981     JNIAccessMark jni(this);</span>
 982     jobject nameStr = name == NULL ? NULL : jni()-&gt;NewStringUTF(name);
 983     if (jni()-&gt;ExceptionCheck()) {
 984       return JVMCIObject();
 985     }
 986 
 987     jobject result = jni()-&gt;NewObject(JNIJVMCI::HotSpotNmethod::clazz(),
 988                                       JNIJVMCI::HotSpotNmethod::constructor(),
 989                                       methodObject.as_jobject(), nameStr, isDefault);
 990     return wrap(result);
 991   }
 992 }
 993 
 994 JVMCIObject JVMCIEnv::make_local(JVMCIObject object) {
 995   if (object.is_null()) {
 996     return JVMCIObject();
 997   }
 998   if (is_hotspot()) {
 999     return wrap(JNIHandles::make_local(HotSpotJVMCI::resolve(object)));
1000   } else {
1001     JNIAccessMark jni(this);
1002     return wrap(jni()-&gt;NewLocalRef(object.as_jobject()));
1003   }
1004 }
1005 
1006 JVMCIObject JVMCIEnv::make_global(JVMCIObject object) {
1007   if (object.is_null()) {
1008     return JVMCIObject();
1009   }
1010   if (is_hotspot()) {
1011     return wrap(JNIHandles::make_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));
1012   } else {
1013     JNIAccessMark jni(this);
1014     return wrap(jni()-&gt;NewGlobalRef(object.as_jobject()));
1015   }
1016 }
1017 
<a name="31" id="anc31"></a><span class="removed">1018 JVMCIObject JVMCIEnv::make_weak(JVMCIObject object) {</span>
<span class="removed">1019   if (object.is_null()) {</span>
<span class="removed">1020     return JVMCIObject();</span>
<span class="removed">1021   }</span>
<span class="removed">1022   if (is_hotspot()) {</span>
<span class="removed">1023     return wrap(JNIHandles::make_weak_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));</span>
<span class="removed">1024   } else {</span>
<span class="removed">1025     JNIAccessMark jni(this);</span>
<span class="removed">1026     return wrap(jni()-&gt;NewWeakGlobalRef(object.as_jobject()));</span>
<span class="removed">1027   }</span>
<span class="removed">1028 }</span>
<span class="removed">1029 </span>
1030 void JVMCIEnv::destroy_local(JVMCIObject object) {
1031   if (is_hotspot()) {
1032     JNIHandles::destroy_local(object.as_jobject());
1033   } else {
1034     JNIAccessMark jni(this);
1035     jni()-&gt;DeleteLocalRef(object.as_jobject());
1036   }
1037 }
1038 
1039 void JVMCIEnv::destroy_global(JVMCIObject object) {
1040   if (is_hotspot()) {
1041     JNIHandles::destroy_global(object.as_jobject());
1042   } else {
1043     JNIAccessMark jni(this);
1044     jni()-&gt;DeleteGlobalRef(object.as_jobject());
1045   }
1046 }
1047 
<a name="32" id="anc32"></a><span class="removed">1048 void JVMCIEnv::destroy_weak(JVMCIObject object) {</span>
<span class="removed">1049   if (is_hotspot()) {</span>
<span class="removed">1050     JNIHandles::destroy_weak_global(object.as_jweak());</span>
<span class="removed">1051   } else {</span>
<span class="removed">1052     JNIAccessMark jni(this);</span>
<span class="removed">1053     jni()-&gt;DeleteWeakGlobalRef(object.as_jweak());</span>
<span class="removed">1054   }</span>
<span class="removed">1055 }</span>
<span class="removed">1056 </span>
1057 const char* JVMCIEnv::klass_name(JVMCIObject object) {
1058   if (is_hotspot()) {
1059     return HotSpotJVMCI::resolve(object)-&gt;klass()-&gt;signature_name();
1060   } else {
1061     JVMCIObject name;
1062     {
1063       JNIAccessMark jni(this);
1064       jclass jcl = jni()-&gt;GetObjectClass(object.as_jobject());
1065       jobject result = jni()-&gt;CallObjectMethod(jcl, JNIJVMCI::Class_getName_method());
1066       name = JVMCIObject::create(result, is_hotspot());
1067     }
1068     return as_utf8_string(name);
1069   }
1070 }
1071 
1072 JVMCIObject JVMCIEnv::get_jvmci_method(const methodHandle&amp; method, JVMCI_TRAPS) {
1073   JVMCIObject method_object;
1074   if (method() == NULL) {
1075     return method_object;
1076   }
1077 
1078   Thread* THREAD = Thread::current();
<a name="33" id="anc33"></a><span class="changed">1079   jmetadata handle = JVMCI::allocate_handle(method);</span>
1080   jboolean exception = false;
1081   if (is_hotspot()) {
1082     JavaValue result(T_OBJECT);
1083     JavaCallArguments args;
1084     args.push_long((jlong) handle);
1085     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass(),
1086                            vmSymbols::fromMetaspace_name(),
1087                            vmSymbols::method_fromMetaspace_signature(), &amp;args, THREAD);
1088     if (HAS_PENDING_EXCEPTION) {
1089       exception = true;
1090     } else {
1091       method_object = wrap((oop)result.get_jobject());
1092     }
1093   } else {
1094     JNIAccessMark jni(this);
1095     method_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedJavaMethodImpl::clazz(),
1096                                                                   JNIJVMCI::HotSpotResolvedJavaMethodImpl_fromMetaspace_method(),
1097                                                                   (jlong) handle));
1098     exception = jni()-&gt;ExceptionCheck();
1099   }
1100 
1101   if (exception) {
<a name="34" id="anc34"></a><span class="changed">1102     JVMCI::release_handle(handle);</span>
1103     return JVMCIObject();
1104   }
1105 
1106   assert(asMethod(method_object) == method(), "must be");
1107   if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {
<a name="35" id="anc35"></a><span class="changed">1108     JVMCI::release_handle(handle);</span>
1109   }
1110   assert(!method_object.is_null(), "must be");
1111   return method_object;
1112 }
1113 
1114 JVMCIObject JVMCIEnv::get_jvmci_type(const JVMCIKlassHandle&amp; klass, JVMCI_TRAPS) {
1115   JVMCIObject type;
1116   if (klass.is_null()) {
1117     return type;
1118   }
1119 
1120   jlong pointer = (jlong) klass();
1121   JavaThread* THREAD = JavaThread::current();
1122   JVMCIObject signature = create_string(klass-&gt;signature_name(), JVMCI_CHECK_(JVMCIObject()));
1123   jboolean exception = false;
1124   if (is_hotspot()) {
1125     JavaValue result(T_OBJECT);
1126     JavaCallArguments args;
1127     args.push_long(pointer);
1128     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(signature)));
1129     JavaCalls::call_static(&amp;result,
1130                            HotSpotJVMCI::HotSpotResolvedObjectTypeImpl::klass(),
1131                            vmSymbols::fromMetaspace_name(),
1132                            vmSymbols::klass_fromMetaspace_signature(), &amp;args, THREAD);
1133 
1134     if (HAS_PENDING_EXCEPTION) {
1135       exception = true;
1136     } else {
1137       type = wrap((oop)result.get_jobject());
1138     }
1139   } else {
<a name="36" id="anc36"></a><span class="changed">1140     JNIAccessMark jni(this);</span>
1141 
1142     HandleMark hm(THREAD);
1143     type = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedObjectTypeImpl::clazz(),
1144                                                         JNIJVMCI::HotSpotResolvedObjectTypeImpl_fromMetaspace_method(),
1145                                                         pointer, signature.as_jstring()));
1146     exception = jni()-&gt;ExceptionCheck();
1147   }
1148   if (exception) {
1149     return JVMCIObject();
1150   }
1151 
1152   assert(type.is_non_null(), "must have result");
1153   return type;
1154 }
1155 
1156 JVMCIObject JVMCIEnv::get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS) {
1157   JVMCIObject cp_object;
<a name="37" id="anc37"></a><span class="changed">1158   jmetadata handle = JVMCI::allocate_handle(cp);</span>
1159   jboolean exception = false;
<a name="38" id="anc38"></a><span class="removed">1160   if (is_hotspot()) {</span>
1161     JavaThread* THREAD = JavaThread::current();
<a name="39" id="anc39"></a>
1162     JavaValue result(T_OBJECT);
1163     JavaCallArguments args;
1164     args.push_long((jlong) handle);
1165     JavaCalls::call_static(&amp;result,
1166                            HotSpotJVMCI::HotSpotConstantPool::klass(),
1167                            vmSymbols::fromMetaspace_name(),
1168                            vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, THREAD);
1169     if (HAS_PENDING_EXCEPTION) {
1170       exception = true;
1171     } else {
1172       cp_object = wrap((oop)result.get_jobject());
1173     }
1174   } else {
<a name="40" id="anc40"></a><span class="changed">1175     JNIAccessMark jni(this);</span>
1176     cp_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotConstantPool::clazz(),
1177                                                              JNIJVMCI::HotSpotConstantPool_fromMetaspace_method(),
1178                                                              (jlong) handle));
1179     exception = jni()-&gt;ExceptionCheck();
1180   }
1181 
1182   if (exception) {
<a name="41" id="anc41"></a><span class="changed">1183     JVMCI::release_handle(handle);</span>
1184     return JVMCIObject();
1185   }
1186 
1187   assert(!cp_object.is_null(), "must be");
1188   // Constant pools aren't cached so this is always a newly created object using the handle
1189   assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, "must use same handle");
1190   return cp_object;
1191 }
1192 
1193 JVMCIPrimitiveArray JVMCIEnv::new_booleanArray(int length, JVMCI_TRAPS) {
<a name="42" id="anc42"></a><span class="removed">1194   if (is_hotspot()) {</span>
1195     JavaThread* THREAD = JavaThread::current();
<a name="43" id="anc43"></a>
1196     typeArrayOop result = oopFactory::new_boolArray(length, CHECK_(JVMCIObject()));
1197     return wrap(result);
1198   } else {
<a name="44" id="anc44"></a><span class="changed">1199     JNIAccessMark jni(this);</span>
1200     jbooleanArray result = jni()-&gt;NewBooleanArray(length);
1201     return wrap(result);
1202   }
1203 }
1204 
1205 JVMCIPrimitiveArray JVMCIEnv::new_byteArray(int length, JVMCI_TRAPS) {
<a name="45" id="anc45"></a><span class="removed">1206   if (is_hotspot()) {</span>
1207     JavaThread* THREAD = JavaThread::current();
<a name="46" id="anc46"></a>
1208     typeArrayOop result = oopFactory::new_byteArray(length, CHECK_(JVMCIObject()));
1209     return wrap(result);
1210   } else {
<a name="47" id="anc47"></a><span class="changed">1211     JNIAccessMark jni(this);</span>
1212     jbyteArray result = jni()-&gt;NewByteArray(length);
1213     return wrap(result);
1214   }
1215 }
1216 
1217 JVMCIObjectArray JVMCIEnv::new_byte_array_array(int length, JVMCI_TRAPS) {
<a name="48" id="anc48"></a><span class="removed">1218   if (is_hotspot()) {</span>
1219     JavaThread* THREAD = JavaThread::current();
<a name="49" id="anc49"></a>
1220     Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())-&gt;array_klass(CHECK_(JVMCIObject()));
1221     objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) -&gt;allocate(length, CHECK_(JVMCIObject()));
1222     return wrap(result);
1223   } else {
<a name="50" id="anc50"></a><span class="changed">1224     JNIAccessMark jni(this);</span>
1225     jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::byte_array(), NULL);
1226     return wrap(result);
1227   }
1228 }
1229 
1230 JVMCIPrimitiveArray JVMCIEnv::new_intArray(int length, JVMCI_TRAPS) {
<a name="51" id="anc51"></a><span class="removed">1231   if (is_hotspot()) {</span>
1232     JavaThread* THREAD = JavaThread::current();
<a name="52" id="anc52"></a>
1233     typeArrayOop result = oopFactory::new_intArray(length, CHECK_(JVMCIObject()));
1234     return wrap(result);
1235   } else {
<a name="53" id="anc53"></a><span class="changed">1236     JNIAccessMark jni(this);</span>
1237     jintArray result = jni()-&gt;NewIntArray(length);
1238     return wrap(result);
1239   }
1240 }
1241 
1242 JVMCIPrimitiveArray JVMCIEnv::new_longArray(int length, JVMCI_TRAPS) {
<a name="54" id="anc54"></a><span class="removed">1243   if (is_hotspot()) {</span>
1244     JavaThread* THREAD = JavaThread::current();
<a name="55" id="anc55"></a>
1245     typeArrayOop result = oopFactory::new_longArray(length, CHECK_(JVMCIObject()));
1246     return wrap(result);
1247   } else {
<a name="56" id="anc56"></a><span class="changed">1248     JNIAccessMark jni(this);</span>
1249     jlongArray result = jni()-&gt;NewLongArray(length);
1250     return wrap(result);
1251   }
1252 }
1253 
1254 JVMCIObject JVMCIEnv::new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS) {
<a name="57" id="anc57"></a><span class="removed">1255   if (is_hotspot()) {</span>
1256     JavaThread* THREAD = JavaThread::current();
<a name="58" id="anc58"></a>
1257     HotSpotJVMCI::VMField::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1258     oop obj = HotSpotJVMCI::VMField::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1259     HotSpotJVMCI::VMField::set_name(this, obj, HotSpotJVMCI::resolve(name));
1260     HotSpotJVMCI::VMField::set_type(this, obj, HotSpotJVMCI::resolve(type));
1261     HotSpotJVMCI::VMField::set_offset(this, obj, offset);
1262     HotSpotJVMCI::VMField::set_address(this, obj, address);
1263     HotSpotJVMCI::VMField::set_value(this, obj, HotSpotJVMCI::resolve(value));
1264     return wrap(obj);
1265   } else {
<a name="59" id="anc59"></a><span class="changed">1266     JNIAccessMark jni(this);</span>
1267     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMField::clazz(),
1268                                     JNIJVMCI::VMField::constructor(),
1269                                     get_jobject(name), get_jobject(type), offset, address, get_jobject(value));
1270     return wrap(result);
1271   }
1272 }
1273 
1274 JVMCIObject JVMCIEnv::new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS) {
<a name="60" id="anc60"></a><span class="removed">1275   if (is_hotspot()) {</span>
1276     JavaThread* THREAD = JavaThread::current();
<a name="61" id="anc61"></a>
1277     HotSpotJVMCI::VMFlag::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1278     oop obj = HotSpotJVMCI::VMFlag::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1279     HotSpotJVMCI::VMFlag::set_name(this, obj, HotSpotJVMCI::resolve(name));
1280     HotSpotJVMCI::VMFlag::set_type(this, obj, HotSpotJVMCI::resolve(type));
1281     HotSpotJVMCI::VMFlag::set_value(this, obj, HotSpotJVMCI::resolve(value));
1282     return wrap(obj);
1283   } else {
<a name="62" id="anc62"></a><span class="changed">1284     JNIAccessMark jni(this);</span>
1285     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMFlag::clazz(),
1286                                     JNIJVMCI::VMFlag::constructor(),
1287                                     get_jobject(name), get_jobject(type), get_jobject(value));
1288     return wrap(result);
1289   }
1290 }
1291 
1292 JVMCIObject JVMCIEnv::new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS) {
<a name="63" id="anc63"></a><span class="removed">1293   if (is_hotspot()) {</span>
1294     JavaThread* THREAD = JavaThread::current();
<a name="64" id="anc64"></a>
1295     HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1296     oop obj = HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1297     HotSpotJVMCI::VMIntrinsicMethod::set_declaringClass(this, obj, HotSpotJVMCI::resolve(declaringClass));
1298     HotSpotJVMCI::VMIntrinsicMethod::set_name(this, obj, HotSpotJVMCI::resolve(name));
1299     HotSpotJVMCI::VMIntrinsicMethod::set_descriptor(this, obj, HotSpotJVMCI::resolve(descriptor));
1300     HotSpotJVMCI::VMIntrinsicMethod::set_id(this, obj, id);
1301     return wrap(obj);
1302   } else {
<a name="65" id="anc65"></a><span class="changed">1303     JNIAccessMark jni(this);</span>
1304     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMIntrinsicMethod::clazz(),
1305                                     JNIJVMCI::VMIntrinsicMethod::constructor(),
1306                                     get_jobject(declaringClass), get_jobject(name), get_jobject(descriptor), id);
1307     return wrap(result);
1308   }
1309 }
1310 
1311 JVMCIObject JVMCIEnv::new_HotSpotStackFrameReference(JVMCI_TRAPS) {
1312   if (is_hotspot()) {
1313     JavaThread* THREAD = JavaThread::current();
1314     HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1315     oop obj = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1316     return wrap(obj);
1317   } else {
1318     ShouldNotReachHere();
1319     return JVMCIObject();
1320   }
1321 }
1322 JVMCIObject JVMCIEnv::new_JVMCIError(JVMCI_TRAPS) {
1323   if (is_hotspot()) {
1324     JavaThread* THREAD = JavaThread::current();
1325     HotSpotJVMCI::JVMCIError::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1326     oop obj = HotSpotJVMCI::JVMCIError::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1327     return wrap(obj);
1328   } else {
1329     ShouldNotReachHere();
1330     return JVMCIObject();
1331   }
1332 }
1333 
1334 
1335 JVMCIObject JVMCIEnv::get_object_constant(oop objOop, bool compressed, bool dont_register) {
1336   JavaThread* THREAD = JavaThread::current();
1337   Handle obj = Handle(THREAD, objOop);
1338   if (obj.is_null()) {
1339     return JVMCIObject();
1340   }
1341   if (is_hotspot()) {
1342     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1343     oop constant = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1344     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::set_object(this, constant, obj());
1345     HotSpotJVMCI::HotSpotObjectConstantImpl::set_compressed(this, constant, compressed);
1346     return wrap(constant);
1347   } else {
1348     jlong handle = make_handle(obj);
<a name="66" id="anc66"></a><span class="changed">1349     JNIAccessMark jni(this);</span>
1350     jobject result = jni()-&gt;NewObject(JNIJVMCI::IndirectHotSpotObjectConstantImpl::clazz(),
1351                                       JNIJVMCI::IndirectHotSpotObjectConstantImpl::constructor(),
1352                                       handle, compressed, dont_register);
1353     return wrap(result);
1354   }
1355 }
1356 
1357 
1358 Handle JVMCIEnv::asConstant(JVMCIObject constant, JVMCI_TRAPS) {
1359   if (constant.is_null()) {
1360     return Handle();
1361   }
1362   JavaThread* THREAD = JavaThread::current();
1363   if (is_hotspot()) {
1364     assert(HotSpotJVMCI::DirectHotSpotObjectConstantImpl::is_instance(this, constant), "wrong type");
1365     oop obj = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::object(this, HotSpotJVMCI::resolve(constant));
1366     return Handle(THREAD, obj);
1367   } else if (isa_IndirectHotSpotObjectConstantImpl(constant)) {
1368     jlong object_handle = get_IndirectHotSpotObjectConstantImpl_objectHandle(constant);
1369     if (object_handle == 0L) {
1370       JVMCI_THROW_MSG_(NullPointerException, "Foreign object reference has been cleared", Handle());
1371     }
1372     oop result = resolve_handle(object_handle);
1373     if (result == NULL) {
1374       JVMCI_THROW_MSG_(InternalError, "Constant was unexpectedly NULL", Handle());
1375     }
1376     return Handle(THREAD, result);
1377   } else {
1378     JVMCI_THROW_MSG_(IllegalArgumentException, "DirectHotSpotObjectConstantImpl shouldn't reach JVMCI in SVM mode", Handle());
1379   }
1380 }
1381 
1382 JVMCIObject JVMCIEnv::wrap(jobject object) {
1383   return JVMCIObject::create(object, is_hotspot());
1384 }
1385 
1386 jlong JVMCIEnv::make_handle(const Handle&amp; obj) {
1387   assert(!obj.is_null(), "should only create handle for non-NULL oops");
<a name="67" id="anc67"></a><span class="changed">1388   jobject handle = JVMCI::make_global(obj);</span>
1389   return (jlong) handle;
1390 }
1391 
1392 oop JVMCIEnv::resolve_handle(jlong objectHandle) {
1393   assert(objectHandle != 0, "should be a valid handle");
1394   oop obj = *((oopDesc**)objectHandle);
1395   if (obj != NULL) {
1396     oopDesc::verify(obj);
1397   }
1398   return obj;
1399 }
1400 
1401 JVMCIObject JVMCIEnv::create_string(const char* str, JVMCI_TRAPS) {
<a name="68" id="anc68"></a><span class="removed">1402   if (is_hotspot()) {</span>
1403     JavaThread* THREAD = JavaThread::current();
<a name="69" id="anc69"></a>
1404     Handle result = java_lang_String::create_from_str(str, CHECK_(JVMCIObject()));
1405     return HotSpotJVMCI::wrap(result());
1406   } else {
1407     jobject result;
1408     jboolean exception = false;
1409     {
<a name="70" id="anc70"></a><span class="changed">1410       JNIAccessMark jni(this);</span>
1411       result = jni()-&gt;NewStringUTF(str);
1412       exception = jni()-&gt;ExceptionCheck();
1413     }
1414     return wrap(result);
1415   }
1416 }
1417 
1418 bool JVMCIEnv::equals(JVMCIObject a, JVMCIObject b) {
1419   if (is_hotspot()) {
1420     return HotSpotJVMCI::resolve(a) == HotSpotJVMCI::resolve(b);
1421   } else {
1422     JNIAccessMark jni(this);
1423     return jni()-&gt;IsSameObject(a.as_jobject(), b.as_jobject()) != 0;
1424   }
1425 }
1426 
1427 BasicType JVMCIEnv::kindToBasicType(JVMCIObject kind, JVMCI_TRAPS) {
1428   if (kind.is_null()) {
1429     JVMCI_THROW_(NullPointerException, T_ILLEGAL);
1430   }
1431   jchar ch = get_JavaKind_typeChar(kind);
1432   switch(ch) {
1433     case 'Z': return T_BOOLEAN;
1434     case 'B': return T_BYTE;
1435     case 'S': return T_SHORT;
1436     case 'C': return T_CHAR;
1437     case 'I': return T_INT;
1438     case 'F': return T_FLOAT;
1439     case 'J': return T_LONG;
1440     case 'D': return T_DOUBLE;
1441     case 'A': return T_OBJECT;
1442     case '-': return T_ILLEGAL;
1443     default:
1444       JVMCI_ERROR_(T_ILLEGAL, "unexpected Kind: %c", ch);
1445   }
1446 }
1447 
1448 void JVMCIEnv::initialize_installed_code(JVMCIObject installed_code, CodeBlob* cb, JVMCI_TRAPS) {
1449   // Ensure that all updates to the InstalledCode fields are consistent.
1450   if (get_InstalledCode_address(installed_code) != 0) {
1451     JVMCI_THROW_MSG(InternalError, "InstalledCode instance already in use");
1452   }
1453   if (!isa_HotSpotInstalledCode(installed_code)) {
1454     JVMCI_THROW_MSG(InternalError, "InstalledCode instance must be a subclass of HotSpotInstalledCode");
1455   }
1456 
1457   // Ignore the version which can stay at 0
1458   if (cb-&gt;is_nmethod()) {
1459     nmethod* nm = cb-&gt;as_nmethod_or_null();
1460     if (!nm-&gt;is_alive()) {
1461       JVMCI_THROW_MSG(InternalError, "nmethod has been reclaimed");
1462     }
1463     if (nm-&gt;is_in_use()) {
1464       set_InstalledCode_entryPoint(installed_code, (jlong) nm-&gt;verified_entry_point());
1465     }
1466   } else {
1467     set_InstalledCode_entryPoint(installed_code, (jlong) cb-&gt;code_begin());
1468   }
1469   set_InstalledCode_address(installed_code, (jlong) cb);
1470   set_HotSpotInstalledCode_size(installed_code, cb-&gt;size());
1471   set_HotSpotInstalledCode_codeStart(installed_code, (jlong) cb-&gt;code_begin());
1472   set_HotSpotInstalledCode_codeSize(installed_code, cb-&gt;code_size());
1473 }
1474 
1475 
1476 void JVMCIEnv::invalidate_nmethod_mirror(JVMCIObject mirror, JVMCI_TRAPS) {
1477   if (mirror.is_null()) {
1478     JVMCI_THROW(NullPointerException);
1479   }
1480 
1481   nmethodLocker locker;
1482   nmethod* nm = JVMCIENV-&gt;get_nmethod(mirror, locker);
1483   if (nm == NULL) {
1484     // Nothing to do
1485     return;
1486   }
1487 
1488   Thread* THREAD = Thread::current();
1489   if (!mirror.is_hotspot() &amp;&amp; !THREAD-&gt;is_Java_thread()) {
1490     // Calling back into native might cause the execution to block, so only allow this when calling
1491     // from a JavaThread, which is the normal case anyway.
1492     JVMCI_THROW_MSG(IllegalArgumentException,
1493                     "Cannot invalidate HotSpotNmethod object in shared library VM heap from non-JavaThread");
1494   }
1495 
1496   nmethodLocker nml(nm);
1497   if (nm-&gt;is_alive()) {
1498     // Invalidating the HotSpotNmethod means we want the nmethod to be deoptimized.
1499     Deoptimization::deoptimize_all_marked(nm);
1500   }
1501 
1502   // A HotSpotNmethod instance can only reference a single nmethod
1503   // during its lifetime so simply clear it here.
1504   set_InstalledCode_address(mirror, 0);
1505 }
1506 
1507 Klass* JVMCIEnv::asKlass(JVMCIObject obj) {
1508   return (Klass*) get_HotSpotResolvedObjectTypeImpl_metadataPointer(obj);
1509 }
1510 
1511 Method* JVMCIEnv::asMethod(JVMCIObject obj) {
1512   Method** metadataHandle = (Method**) get_HotSpotResolvedJavaMethodImpl_metadataHandle(obj);
1513   return *metadataHandle;
1514 }
1515 
1516 ConstantPool* JVMCIEnv::asConstantPool(JVMCIObject obj) {
1517   ConstantPool** metadataHandle = (ConstantPool**) get_HotSpotConstantPool_metadataHandle(obj);
1518   return *metadataHandle;
1519 }
1520 
1521 CodeBlob* JVMCIEnv::get_code_blob(JVMCIObject obj, nmethodLocker&amp; locker) {
1522   address code = (address) get_InstalledCode_address(obj);
1523   if (code == NULL) {
1524     return NULL;
1525   }
1526   if (isa_HotSpotNmethod(obj)) {
1527     nmethod* nm = NULL;
1528     {
1529       // Lookup the CodeBlob while holding the CodeCache_lock to ensure the nmethod can't be freed
1530       // by nmethod::flush while we're interrogating it.
1531       MutexLocker cm_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1532       CodeBlob* cb = CodeCache::find_blob_unsafe(code);
1533       if (cb == (CodeBlob*) code) {
1534         nmethod* the_nm = cb-&gt;as_nmethod_or_null();
1535         if (the_nm != NULL &amp;&amp; the_nm-&gt;is_alive()) {
1536           // Lock the nmethod to stop any further transitions by the sweeper.  It's still possible
1537           // for this code to execute in the middle of the sweeping of the nmethod but that will be
1538           // handled below.
1539           locker.set_code(nm, true);
1540           nm = the_nm;
1541         }
1542       }
1543     }
1544 
1545     if (nm != NULL) {
1546       // We found the nmethod but it could be in the process of being freed.  Check the state of the
1547       // nmethod while holding the CompiledMethod_lock.  This ensures that any transitions by other
1548       // threads have seen the is_locked_by_vm() update above.
1549       MutexLocker cm_lock(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1550       if (!nm-&gt;is_alive()) {
1551         //  It was alive when we looked it up but it's no longer alive so release it.
1552         locker.set_code(NULL);
1553         nm = NULL;
1554       }
1555     }
1556 
1557     jlong compile_id_snapshot = get_HotSpotNmethod_compileIdSnapshot(obj);
1558     if (compile_id_snapshot != 0L) {
1559       // Found a live nmethod with the same address, make sure it's the same nmethod
1560       if (nm == (nmethod*) code &amp;&amp; nm-&gt;compile_id() == compile_id_snapshot &amp;&amp; nm-&gt;is_alive()) {
1561         if (nm-&gt;is_not_entrant()) {
1562           // Zero the entry point so that the nmethod
1563           // cannot be invoked by the mirror but can
1564           // still be deoptimized.
1565           set_InstalledCode_entryPoint(obj, 0);
1566         }
1567         return nm;
1568       }
1569       // The HotSpotNmethod no longer refers to a valid nmethod so clear the state
1570       locker.set_code(NULL);
1571       nm = NULL;
1572     }
1573 
1574     if (nm == NULL) {
1575       // The HotSpotNmethod was pointing at some nmethod but the nmethod is no longer valid, so
1576       // clear the InstalledCode fields of this HotSpotNmethod so that it no longer refers to a
1577       // nmethod in the code cache.
1578       set_InstalledCode_address(obj, 0);
1579       set_InstalledCode_entryPoint(obj, 0);
1580     }
1581     return nm;
1582   }
1583 
1584   CodeBlob* cb = (CodeBlob*) code;
1585   assert(!cb-&gt;is_nmethod(), "unexpected nmethod");
1586   return cb;
1587 }
1588 
1589 nmethod* JVMCIEnv::get_nmethod(JVMCIObject obj, nmethodLocker&amp; locker) {
1590   CodeBlob* cb = get_code_blob(obj, locker);
1591   if (cb != NULL) {
1592     return cb-&gt;as_nmethod_or_null();
1593   }
1594   return NULL;
1595 }
1596 
1597 // Generate implementations for the initialize, new, isa, get and set methods for all the types and
1598 // fields declared in the JVMCI_CLASSES_DO macro.
1599 
1600 #define START_CLASS(className, fullClassName)                                                                        \
1601   void JVMCIEnv::className##_initialize(JVMCI_TRAPS) {                                                               \
1602     if (is_hotspot()) {                                                                                              \
1603       HotSpotJVMCI::className::initialize(JVMCI_CHECK);                                                              \
1604     } else {                                                                                                         \
1605       JNIJVMCI::className::initialize(JVMCI_CHECK);                                                                  \
1606     }                                                                                                                \
1607   }                                                                                                                  \
1608   JVMCIObjectArray JVMCIEnv::new_##className##_array(int length, JVMCI_TRAPS) {                                      \
1609     if (is_hotspot()) {                                                                                              \
1610       Thread* THREAD = Thread::current();                                                                            \
1611       objArrayOop array = oopFactory::new_objArray(HotSpotJVMCI::className::klass(), length, CHECK_(JVMCIObject())); \
1612       return (JVMCIObjectArray) wrap(array);                                                                         \
1613     } else {                                                                                                         \
1614       JNIAccessMark jni(this);                                                                                       \
1615       jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::className::clazz(), NULL);                       \
1616       return wrap(result);                                                                                           \
1617     }                                                                                                                \
1618   }                                                                                                                  \
1619   bool JVMCIEnv::isa_##className(JVMCIObject object) {                                                               \
1620     if (is_hotspot()) {                                                                                              \
1621       return HotSpotJVMCI::className::is_instance(this, object);                                                     \
1622     } else {                                                                                                         \
1623       return JNIJVMCI::className::is_instance(this, object);                                                         \
1624     }                                                                                                                \
1625   }
1626 
1627 #define END_CLASS
1628 
1629 #define FIELD(className, name, type, accessor, cast)                 \
1630   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {         \
1631     if (is_hotspot()) {                                              \
1632       return HotSpotJVMCI::className::get_##name(this, obj);         \
1633     } else {                                                         \
1634       return JNIJVMCI::className::get_##name(this, obj);             \
1635     }                                                                \
1636   }                                                                  \
1637   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) { \
1638     if (is_hotspot()) {                                              \
1639       HotSpotJVMCI::className::set_##name(this, obj, x);             \
1640     } else {                                                         \
1641       JNIJVMCI::className::set_##name(this, obj, x);                 \
1642     }                                                                \
1643   }
1644 
1645 #define EMPTY_CAST
1646 #define CHAR_FIELD(className, name)                    FIELD(className, name, jchar, Char, EMPTY_CAST)
1647 #define INT_FIELD(className, name)                     FIELD(className, name, jint, Int, EMPTY_CAST)
1648 #define BOOLEAN_FIELD(className, name)                 FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
1649 #define LONG_FIELD(className, name)                    FIELD(className, name, jlong, Long, EMPTY_CAST)
1650 #define FLOAT_FIELD(className, name)                   FIELD(className, name, jfloat, Float, EMPTY_CAST)
1651 
1652 #define OBJECT_FIELD(className, name, signature)              OOPISH_FIELD(className, name, JVMCIObject, Object, EMPTY_CAST)
1653 #define OBJECTARRAY_FIELD(className, name, signature)         OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
1654 #define PRIMARRAY_FIELD(className, name, signature)           OOPISH_FIELD(className, name, JVMCIPrimitiveArray, Object, (JVMCIPrimitiveArray))
1655 
1656 #define STATIC_OBJECT_FIELD(className, name, signature)       STATIC_OOPISH_FIELD(className, name, JVMCIObject, Object, (JVMCIObject))
1657 #define STATIC_OBJECTARRAY_FIELD(className, name, signature)  STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
1658 
1659 #define OOPISH_FIELD(className, name, type, accessor, cast)           \
1660   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {          \
1661     if (is_hotspot()) {                                               \
1662       return HotSpotJVMCI::className::get_##name(this, obj);          \
1663     } else {                                                          \
1664       return JNIJVMCI::className::get_##name(this, obj);              \
1665     }                                                                 \
1666   }                                                                   \
1667   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) {  \
1668     if (is_hotspot()) {                                               \
1669       HotSpotJVMCI::className::set_##name(this, obj, x);              \
1670     } else {                                                          \
1671       JNIJVMCI::className::set_##name(this, obj, x);                  \
1672     }                                                                 \
1673   }
1674 
1675 #define STATIC_OOPISH_FIELD(className, name, type, accessor, cast)    \
1676   type JVMCIEnv::get_##className##_##name() {                         \
1677     if (is_hotspot()) {                                               \
1678       return HotSpotJVMCI::className::get_##name(this);               \
1679     } else {                                                          \
1680       return JNIJVMCI::className::get_##name(this);                   \
1681     }                                                                 \
1682   }                                                                   \
1683   void JVMCIEnv::set_##className##_##name(type x) {                   \
1684     if (is_hotspot()) {                                               \
1685       HotSpotJVMCI::className::set_##name(this, x);                   \
1686     } else {                                                          \
1687       JNIJVMCI::className::set_##name(this, x);                       \
1688     }                                                                 \
1689   }
1690 
1691 #define STATIC_PRIMITIVE_FIELD(className, name, type, accessor, cast) \
1692   type JVMCIEnv::get_##className##_##name() {                         \
1693     if (is_hotspot()) {                                               \
1694       return HotSpotJVMCI::className::get_##name(this);               \
1695     } else {                                                          \
1696       return JNIJVMCI::className::get_##name(this);                   \
1697     }                                                                 \
1698   }                                                                   \
1699   void JVMCIEnv::set_##className##_##name(type x) {                   \
1700     if (is_hotspot()) {                                               \
1701       HotSpotJVMCI::className::set_##name(this, x);                   \
1702     } else {                                                          \
1703       JNIJVMCI::className::set_##name(this, x);                       \
1704     }                                                                 \
1705   }
1706 #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint, Int, EMPTY_CAST)
1707 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
1708 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
1709 #define CONSTRUCTOR(className, signature)
1710 
1711 JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
1712 
1713 #undef START_CLASS
1714 #undef END_CLASS
1715 #undef METHOD
1716 #undef CONSTRUCTOR
1717 #undef FIELD
1718 #undef CHAR_FIELD
1719 #undef INT_FIELD
1720 #undef BOOLEAN_FIELD
1721 #undef LONG_FIELD
1722 #undef FLOAT_FIELD
1723 #undef OBJECT_FIELD
1724 #undef PRIMARRAY_FIELD
1725 #undef OBJECTARRAY_FIELD
1726 #undef STATIC_OOPISH_FIELD
1727 #undef STATIC_OBJECT_FIELD
1728 #undef STATIC_OBJECTARRAY_FIELD
1729 #undef STATIC_INT_FIELD
1730 #undef STATIC_BOOLEAN_FIELD
1731 #undef EMPTY_CAST
<a name="71" id="anc71"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="71" type="hidden" /></form></body></html>
