<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "code/codeCache.hpp"
  27 #include "code/scopeDesc.hpp"
  28 #include "interpreter/linkResolver.hpp"
  29 #include "memory/oopFactory.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "oops/generateOopMap.hpp"
  32 #include "oops/fieldStreams.hpp"
  33 #include "oops/oop.inline.hpp"
  34 #include "oops/objArrayOop.inline.hpp"
  35 #include "runtime/fieldDescriptor.hpp"
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"
  56 
  57 
  58 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  59 #define C2V_VMENTRY(result_type, name, signature) \
  60   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  61   TRACE_jvmci_1("CompilerToVM::" #name); \
  62   TRACE_CALL(result_type, jvmci_ ## name signature) \
  63   JVMCI_VM_ENTRY_MARK; \
  64 
  65 #define C2V_END }
  66 
  67 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  68   if (method() != NULL) {
  69     JavaValue result(T_OBJECT);
  70     JavaCallArguments args;
  71     args.push_long((jlong) (address) method());
  72     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  73 
  74     return (oop)result.get_jobject();
  75   }
  76   return NULL;
  77 }
  78 
  79 oop CompilerToVM::get_jvmci_type(KlassHandle klass, TRAPS) {
  80   if (klass() != NULL) {
  81     JavaValue result(T_OBJECT);
  82     JavaCallArguments args;
  83     args.push_oop(klass-&gt;java_mirror());
  84     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  85 
  86     return (oop)result.get_jobject();
  87   }
  88   return NULL;
  89 }
  90 
  91 int CompilerToVM::Data::Klass_vtable_start_offset;
  92 int CompilerToVM::Data::Klass_vtable_length_offset;
  93 
  94 int CompilerToVM::Data::Method_extra_stack_entries;
  95 
  96 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
  97 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
  98 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
  99 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 100 
 101 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 102 
 103 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 104 int CompilerToVM::Data::Universe_base_vtable_size;
 105 address CompilerToVM::Data::Universe_narrow_oop_base;
 106 int CompilerToVM::Data::Universe_narrow_oop_shift;
 107 address CompilerToVM::Data::Universe_narrow_klass_base;
 108 int CompilerToVM::Data::Universe_narrow_klass_shift;
 109 void* CompilerToVM::Data::Universe_non_oop_bits;
 110 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 111 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 112 
 113 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 114 HeapWord** CompilerToVM::Data::_heap_end_addr;
 115 HeapWord** CompilerToVM::Data::_heap_top_addr;
 116 int CompilerToVM::Data::_max_oop_map_stack_offset;
 117 
 118 jbyte* CompilerToVM::Data::cardtable_start_address;
 119 int CompilerToVM::Data::cardtable_shift;
 120 
 121 int CompilerToVM::Data::vm_page_size;
 122 
 123 address CompilerToVM::Data::dsin;
 124 address CompilerToVM::Data::dcos;
 125 address CompilerToVM::Data::dtan;
 126 address CompilerToVM::Data::dexp;
 127 address CompilerToVM::Data::dlog;
 128 address CompilerToVM::Data::dlog10;
 129 address CompilerToVM::Data::dpow;
 130 
 131 void CompilerToVM::Data::initialize() {
 132   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 133   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 134 
 135   Method_extra_stack_entries = Method::extra_stack_entries();
 136 
 137   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 138   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 139   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 140   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 141 
 142   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 143 
 144   Universe_collectedHeap = Universe::heap();
 145   Universe_base_vtable_size = Universe::base_vtable_size();
 146   Universe_narrow_oop_base = Universe::narrow_oop_base();
 147   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 148   Universe_narrow_klass_base = Universe::narrow_klass_base();
 149   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 150   Universe_non_oop_bits = Universe::non_oop_word();
 151   Universe_verify_oop_mask = Universe::verify_oop_mask();
 152   Universe_verify_oop_bits = Universe::verify_oop_bits();
 153 
 154   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 155   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 156   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord**) -1;
 157 
 158   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 159   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 160   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 161   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 162 
 163   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 164   switch (bs-&gt;kind()) {
 165   case BarrierSet::CardTableModRef:
 166   case BarrierSet::CardTableForRS:
 167   case BarrierSet::CardTableExtension:
 168   case BarrierSet::G1SATBCT:
 169   case BarrierSet::G1SATBCTLogging: {
 170     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 171     assert(base != 0, "unexpected byte_map_base");
 172     cardtable_start_address = base;
 173     cardtable_shift = CardTableModRefBS::card_shift;
 174     break;
 175   }
 176   case BarrierSet::ModRef:
 177     cardtable_start_address = 0;
 178     cardtable_shift = 0;
 179     // No post barriers
 180     break;
 181   default:
 182     ShouldNotReachHere();
 183     break;
 184   }
 185 
 186   vm_page_size = os::vm_page_size();
 187 
 188 #define SET_TRIGFUNC(name)                                      \
 189   if (StubRoutines::name() != NULL) {                           \
 190     name = StubRoutines::name();                                \
 191   } else {                                                      \
 192     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 193   }
 194 
 195   SET_TRIGFUNC(dsin);
 196   SET_TRIGFUNC(dcos);
 197   SET_TRIGFUNC(dtan);
 198   SET_TRIGFUNC(dexp);
 199   SET_TRIGFUNC(dlog10);
 200   SET_TRIGFUNC(dlog);
 201   SET_TRIGFUNC(dpow);
 202 
 203 #undef SET_TRIGFUNC
 204 }
 205 
 206 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))
 207 #define BOXED_LONG(name, value) oop name; do { jvalue p; p.j = (jlong) (value); name = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL);} while(0)
 208 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)
 209   ResourceMark rm;
 210   HandleMark hm;
 211 
 212   CompilerToVM::Data::initialize();
 213 
 214   VMField::klass()-&gt;initialize(thread);
 215   VMFlag::klass()-&gt;initialize(thread);
 216 
 217   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
 218   objArrayHandle vmFields = oopFactory::new_objArray(VMField::klass(), len, CHECK_NULL);
 219   for (int i = 0; i &lt; len ; i++) {
 220     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
 221     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 222     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* "::" */;
 223     char* name_buf = NEW_RESOURCE_ARRAY(char, name_buf_len + 1);
 224     sprintf(name_buf, "%s::%s", vmField.typeName, vmField.fieldName);
 225     Handle name = java_lang_String::create_from_str(name_buf, CHECK_NULL);
 226     Handle type = java_lang_String::create_from_str(vmField.typeString, CHECK_NULL);
 227     VMField::set_name(vmFieldObj, name());
 228     VMField::set_type(vmFieldObj, type());
 229     VMField::set_offset(vmFieldObj, vmField.offset);
 230     VMField::set_address(vmFieldObj, (jlong) vmField.address);
 231     if (vmField.isStatic) {
 232       if (strcmp(vmField.typeString, "bool") == 0) {
 233         BOXED_LONG(value, *(jbyte*) vmField.address);
 234         VMField::set_value(vmFieldObj, value);
 235       } else if (strcmp(vmField.typeString, "int") == 0 ||
 236                  strcmp(vmField.typeString, "jint") == 0) {
 237         BOXED_LONG(value, *(jint*) vmField.address);
 238         VMField::set_value(vmFieldObj, value);
 239       } else if (strcmp(vmField.typeString, "uint64_t") == 0) {
 240         BOXED_LONG(value, *(uint64_t*) vmField.address);
 241         VMField::set_value(vmFieldObj, value);
 242       } else if (strcmp(vmField.typeString, "address") == 0 ||
 243                  strcmp(vmField.typeString, "intptr_t") == 0 ||
 244                  strcmp(vmField.typeString, "uintptr_t") == 0 ||
 245                  strcmp(vmField.typeString, "size_t") == 0 ||
 246                  // All foo* types are addresses.
 247                  vmField.typeString[strlen(vmField.typeString) - 1] == '*') {
 248         BOXED_LONG(value, *((address*) vmField.address));
 249         VMField::set_value(vmFieldObj, value);
 250       } else {
 251         JVMCI_ERROR_NULL("VM field %s has unsupported type %s", name_buf, vmField.typeString);
 252       }
 253     }
 254     vmFields-&gt;obj_at_put(i, vmFieldObj());
 255   }
 256 
 257   len = JVMCIVMStructs::localHotSpotVMTypes_count();
 258   objArrayHandle vmTypes = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 259   for (int i = 0; i &lt; len ; i++) {
 260     VMTypeEntry vmType = JVMCIVMStructs::localHotSpotVMTypes[i];
 261     Handle name = java_lang_String::create_from_str(vmType.typeName, CHECK_NULL);
 262     BOXED_LONG(size, vmType.size);
 263     vmTypes-&gt;obj_at_put(i * 2, name());
 264     vmTypes-&gt;obj_at_put(i * 2 + 1, size);
 265   }
 266 
 267   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
 268   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
 269   len = ints_len + longs_len;
 270   objArrayHandle vmConstants = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 271   int insert = 0;
 272   for (int i = 0; i &lt; ints_len ; i++) {
 273     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
 274     Handle name = java_lang_String::create_from_str(c.name, CHECK_NULL);
 275     BOXED_LONG(value, c.value);
 276     vmConstants-&gt;obj_at_put(insert++, name());
 277     vmConstants-&gt;obj_at_put(insert++, value);
 278   }
 279   for (int i = 0; i &lt; longs_len ; i++) {
 280     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
 281     Handle name = java_lang_String::create_from_str(c.name, CHECK_NULL);
 282     BOXED_LONG(value, c.value);
 283     vmConstants-&gt;obj_at_put(insert++, name());
 284     vmConstants-&gt;obj_at_put(insert++, value);
 285   }
 286   assert(insert == len * 2, "must be");
 287 
 288   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
 289   objArrayHandle vmAddresses = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 290   for (int i = 0; i &lt; len ; i++) {
 291     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
 292     Handle name = java_lang_String::create_from_str(a.name, CHECK_NULL);
 293     BOXED_LONG(value, a.value);
 294     vmAddresses-&gt;obj_at_put(i * 2, name());
 295     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);
 296   }
 297 
 298   // The last entry is the null entry.
 299   len = (int) Flag::numFlags - 1;
 300   objArrayHandle vmFlags = oopFactory::new_objArray(VMFlag::klass(), len, CHECK_NULL);
 301   for (int i = 0; i &lt; len; i++) {
 302     Flag* flag = &amp;Flag::flags[i];
 303     instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 304     Handle name = java_lang_String::create_from_str(flag-&gt;_name, CHECK_NULL);
 305     Handle type = java_lang_String::create_from_str(flag-&gt;_type, CHECK_NULL);
 306     VMFlag::set_name(vmFlagObj, name());
 307     VMFlag::set_type(vmFlagObj, type());
 308     if (flag-&gt;is_bool()) {
 309       BOXED_LONG(value, flag-&gt;get_bool());
 310       VMFlag::set_value(vmFlagObj, value);
 311     } else if (flag-&gt;is_ccstr()) {
 312       Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
 313       VMFlag::set_value(vmFlagObj, value());
 314     } else if (flag-&gt;is_int()) {
 315       BOXED_LONG(value, flag-&gt;get_int());
 316       VMFlag::set_value(vmFlagObj, value);
 317     } else if (flag-&gt;is_intx()) {
 318       BOXED_LONG(value, flag-&gt;get_intx());
 319       VMFlag::set_value(vmFlagObj, value);
 320     } else if (flag-&gt;is_uint()) {
 321       BOXED_LONG(value, flag-&gt;get_uint());
 322       VMFlag::set_value(vmFlagObj, value);
 323     } else if (flag-&gt;is_uint64_t()) {
 324       BOXED_LONG(value, flag-&gt;get_uint64_t());
 325       VMFlag::set_value(vmFlagObj, value);
 326     } else if (flag-&gt;is_uintx()) {
 327       BOXED_LONG(value, flag-&gt;get_uintx());
 328       VMFlag::set_value(vmFlagObj, value);
 329     } else if (flag-&gt;is_double()) {
 330       BOXED_DOUBLE(value, flag-&gt;get_double());
 331       VMFlag::set_value(vmFlagObj, value);
 332     } else if (flag-&gt;is_size_t()) {
 333       BOXED_LONG(value, flag-&gt;get_size_t());
 334       VMFlag::set_value(vmFlagObj, value);
 335     } else {
 336       JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
 337     }
 338     vmFlags-&gt;obj_at_put(i, vmFlagObj());
 339   }
 340 
 341   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 5, CHECK_NULL);
 342   data-&gt;obj_at_put(0, vmFields());
 343   data-&gt;obj_at_put(1, vmTypes());
 344   data-&gt;obj_at_put(2, vmConstants());
 345   data-&gt;obj_at_put(3, vmAddresses());
 346   data-&gt;obj_at_put(4, vmFlags());
 347 
 348   return (jobjectArray) JNIHandles::make_local(THREAD, data);
 349 #undef BOXED_LONG
 350 #undef BOXED_DOUBLE
 351 C2V_END
 352 
 353 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 354   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 355   ResourceMark rm;
 356 
 357   int code_size = method-&gt;code_size();
 358   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 359 
 360   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 361   // iterate over all bytecodes and replace non-Java bytecodes
 362 
 363   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 364     Bytecodes::Code code = s.code();
 365     Bytecodes::Code raw_code = s.raw_code();
 366     int bci = s.bci();
 367     int len = s.instruction_size();
 368 
 369     // Restore original byte code.
 370     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 371     if (len &gt; 1) {
 372       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);
 373     }
 374 
 375     if (len &gt; 1) {
 376       // Restore the big-endian constant pool indexes.
 377       // Cf. Rewriter::scan_method
 378       switch (code) {
 379         case Bytecodes::_getstatic:
 380         case Bytecodes::_putstatic:
 381         case Bytecodes::_getfield:
 382         case Bytecodes::_putfield:
 383         case Bytecodes::_invokevirtual:
 384         case Bytecodes::_invokespecial:
 385         case Bytecodes::_invokestatic:
 386         case Bytecodes::_invokeinterface:
 387         case Bytecodes::_invokehandle: {
 388           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 389           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 390           break;
 391         }
 392 
 393         case Bytecodes::_invokedynamic:
 394           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 395           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);
 396           break;
 397       }
 398 
 399       // Not all ldc byte code are rewritten.
 400       switch (raw_code) {
 401         case Bytecodes::_fast_aldc: {
 402           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;
 403           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 404           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 405           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);
 406           break;
 407         }
 408 
 409         case Bytecodes::_fast_aldc_w: {
 410           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 411           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 412           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 413           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 414           break;
 415         }
 416       }
 417     }
 418   }
 419 
 420   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);
 421 C2V_END
 422 
 423 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 424   ResourceMark rm;
 425   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 426   return method-&gt;exception_table_length();
 427 C2V_END
 428 
 429 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 430   ResourceMark rm;
 431   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 432   if (method-&gt;exception_table_length() == 0) {
 433     return 0L;
 434   }
 435   return (jlong) (address) method-&gt;exception_table_start();
 436 C2V_END
 437 
 438 C2V_VMENTRY(jobject, getResolvedJavaMethodAtSlot, (JNIEnv *, jobject, jclass holder_handle, jint slot))
 439   oop java_class = JNIHandles::resolve(holder_handle);
 440   Klass* holder = java_lang_Class::as_Klass(java_class);
 441   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 442   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 443   return JNIHandles::make_local(THREAD, result);
 444 }
 445 
 446 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))
 447   methodHandle method;
 448   oop base_object = JNIHandles::resolve(base);
 449   if (base_object == NULL) {
 450     method = *((Method**)(offset));
 451   } else if (base_object-&gt;is_a(SystemDictionary::MemberName_klass())) {
 452     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);
 453   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 454     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));
 455   } else {
 456     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 457                 err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 458   }
 459   assert (method.is_null() || method-&gt;is_method(), "invalid read");
 460   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 461   return JNIHandles::make_local(THREAD, result);
 462 }
 463 
<a name="1" id="anc1"></a><span class="changed"> 464 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject base, jlong offset))</span>
 465   constantPoolHandle cp;
<a name="2" id="anc2"></a><span class="changed"> 466   oop base_object = JNIHandles::resolve(base);</span>
<span class="changed"> 467   jlong base_address = 0;</span>
<span class="changed"> 468   if (base_object != NULL) {</span>
<span class="changed"> 469     if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {</span>
<span class="changed"> 470       base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);</span>
<span class="changed"> 471     } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {</span>
<span class="changed"> 472       base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);</span>
<span class="changed"> 473     } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {</span>
<span class="changed"> 474       base_address = (jlong) CompilerToVM::asKlass(base_object);</span>
 475     } else {
 476       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
<a name="3" id="anc3"></a><span class="changed"> 477                   err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));</span>
 478     }
<a name="4" id="anc4"></a><span class="changed"> 479   }</span>
<span class="changed"> 480   cp = *((ConstantPool**) (intptr_t) (base_address + offset));</span>
<span class="changed"> 481   if (!cp.is_null()) {</span>
 482     JavaValue method_result(T_OBJECT);
 483     JavaCallArguments args;
 484     args.push_long((jlong) (address) cp());
 485     JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 486     return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());
<a name="5" id="anc5"></a><span class="removed"> 487   }</span>
<span class="removed"> 488   return NULL;</span>
 489 }
 490 
 491 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))
 492   KlassHandle klass;
 493   oop base_object = JNIHandles::resolve(base);
 494   jlong base_address = 0;
 495   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 496     klass = base_object-&gt;klass();
 497   } else if (!compressed) {
 498     if (base_object != NULL) {
 499       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 500         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 501       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 502         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 503       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 504         base_address = (jlong) CompilerToVM::asKlass(base_object);
 505       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {
 506         base_address = (jlong) (address) base_object;
 507       } else {
 508         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 509                     err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 510       }
 511     }
 512     klass = *((Klass**) (intptr_t) (base_address + offset));
 513   } else {
 514     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 515                 err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 516   }
 517   assert (klass.is_null() || klass-&gt;is_klass(), "invalid read");
 518   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 519   return JNIHandles::make_local(THREAD, result);
 520 }
 521 
 522 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 523   ResourceMark rm;
 524   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 525   KlassHandle holder = CompilerToVM::asKlass(jvmci_type);
 526   if (holder-&gt;is_interface()) {
 527     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", holder-&gt;external_name()));
 528   }
 529 
 530   methodHandle ucm;
 531   {
 532     MutexLocker locker(Compile_lock);
 533     ucm = Dependencies::find_unique_concrete_method(holder(), method());
 534   }
 535   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);
 536   return JNIHandles::make_local(THREAD, result);
 537 C2V_END
 538 
 539 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))
 540   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 541   oop implementor = CompilerToVM::get_jvmci_type(klass-&gt;implementor(), CHECK_NULL);
 542   return JNIHandles::make_local(THREAD, implementor);
 543 C2V_END
 544 
 545 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))
 546   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 547   return method-&gt;is_ignored_by_security_stack_walk();
 548 C2V_END
 549 
 550 C2V_VMENTRY(jboolean, canInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 551   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 552   // In hosted mode ignore the not_compilable flags since they are never set by
 553   // the JVMCI compiler.
 554   bool is_compilable = UseJVMCICompiler ? !method-&gt;is_not_compilable(CompLevel_full_optimization) : true;
 555   return is_compilable &amp;&amp; !CompilerOracle::should_not_inline(method) &amp;&amp; !method-&gt;dont_inline();
 556 C2V_END
 557 
 558 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 559   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 560   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 561 C2V_END
 562 
 563 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 564   ResourceMark rm;
 565   Handle name = JNIHandles::resolve(jname);
 566   Symbol* class_name = java_lang_String::as_symbol(name, CHECK_0);
 567   if (java_lang_String::length(name()) &lt;= 1) {
 568     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Primitive type %s should be handled in Java code", class_name-&gt;as_C_string()));
 569   }
 570 
 571   Klass* resolved_klass = NULL;
 572   Handle class_loader;
 573   Handle protection_domain;
 574   if (JNIHandles::resolve(accessing_class) == NULL) {
 575     THROW_0(vmSymbols::java_lang_NullPointerException());
 576   }
 577   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));
 578   class_loader = accessing_klass-&gt;class_loader();
 579   protection_domain = accessing_klass-&gt;protection_domain();
 580 
 581   if (resolve) {
 582     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 583   } else {
 584     if (class_name-&gt;byte_at(0) == 'L' &amp;&amp;
 585       class_name-&gt;byte_at(class_name-&gt;utf8_length()-1) == ';') {
 586       // This is a name from a signature.  Strip off the trimmings.
 587       // Call recursive to keep scope of strippedsym.
 588       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 589                                                           class_name-&gt;utf8_length()-2,
 590                                                           CHECK_0);
 591       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 592     } else if (FieldType::is_array(class_name)) {
 593       FieldArrayInfo fd;
 594       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 595       // of this call
 596       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 597       if (t == T_OBJECT) {
 598         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 599                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 600                                                             CHECK_0);
 601         // naked oop "k" is OK here -- we assign back into it
 602         resolved_klass = SystemDictionary::find(strippedsym,
 603                                                              class_loader,
 604                                                              protection_domain,
 605                                                              CHECK_0);
 606         if (resolved_klass != NULL) {
 607           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 608         }
 609       } else {
 610         resolved_klass = Universe::typeArrayKlassObj(t);
 611         resolved_klass = TypeArrayKlass::cast(resolved_klass)-&gt;array_klass(fd.dimension(), CHECK_0);
 612       }
 613     }
 614   }
 615   Handle result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 616   return JNIHandles::make_local(THREAD, result());
 617 C2V_END
 618 
 619 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 620   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 621   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);
 622   return JNIHandles::make_local(THREAD, result);
 623 C2V_END
 624 
 625 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 626   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 627   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 628   return JNIHandles::make_local(THREAD, result);
 629 C2V_END
 630 
 631 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 632   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 633   return cp-&gt;name_and_type_ref_index_at(index);
 634 C2V_END
 635 
 636 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 637   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 638   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);
 639   return JNIHandles::make_local(THREAD, sym());
 640 C2V_END
 641 
 642 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 643   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 644   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);
 645   return JNIHandles::make_local(THREAD, sym());
 646 C2V_END
 647 
 648 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 649   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 650   return cp-&gt;klass_ref_index_at(index);
 651 C2V_END
 652 
 653 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 654   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 655   Klass* resolved_klass = cp-&gt;klass_at(index, CHECK_NULL);
 656   Handle klass = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 657   return JNIHandles::make_local(THREAD, klass());
 658 C2V_END
 659 
 660 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 661   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 662   KlassHandle loading_klass(cp-&gt;pool_holder());
 663   bool is_accessible = false;
 664   KlassHandle klass = JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass);
 665   Symbol* symbol = NULL;
 666   if (klass.is_null()) {
 667     symbol = cp-&gt;klass_name_at(index);
 668   }
 669   Handle result;
 670   if (!klass.is_null()) {
 671     result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 672   } else {
 673     result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
 674   }
 675   return JNIHandles::make_local(THREAD, result());
 676 C2V_END
 677 
 678 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 679   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 680   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 681   return JNIHandles::make_local(THREAD, appendix_oop);
 682 C2V_END
 683 
 684 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 685   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 686   instanceKlassHandle pool_holder(cp-&gt;pool_holder());
 687   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 688   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 689   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 690   return JNIHandles::make_local(THREAD, result);
 691 C2V_END
 692 
 693 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 694   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 695   return cp-&gt;remap_instruction_operand_from_cache(index);
 696 C2V_END
 697 
 698 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jlongArray info_handle))
 699   ResourceMark rm;
 700   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 701   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 702   fieldDescriptor fd;
 703   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
 704   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 705   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
 706   assert(info != NULL &amp;&amp; info-&gt;length() == 2, "must be");
 707   info-&gt;long_at_put(0, (jlong) fd.access_flags().as_int());
 708   info-&gt;long_at_put(1, (jlong) fd.offset());
 709   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 710   return JNIHandles::make_local(THREAD, field_holder);
 711 C2V_END
 712 
 713 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 714   ResourceMark rm;
 715   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 716   Method* method = CompilerToVM::asMethod(jvmci_method);
 717   if (klass-&gt;is_interface()) {
 718     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 719   }
 720   if (!method-&gt;method_holder()-&gt;is_interface()) {
 721     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 722   }
 723   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 724     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 725   }
 726   return LinkResolver::vtable_index_of_interface_method(klass, method);
 727 C2V_END
 728 
 729 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 730   KlassHandle recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);
 731   KlassHandle caller_klass = CompilerToVM::asKlass(caller_jvmci_type);
 732   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 733 
 734   KlassHandle h_resolved   (THREAD, method-&gt;method_holder());
 735   Symbol* h_name      = method-&gt;name();
 736   Symbol* h_signature = method-&gt;signature();
 737 
 738   LinkInfo link_info(h_resolved, h_name, h_signature, caller_klass);
 739   methodHandle m;
 740   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 741   // the vtable has not been setup, and the LinkResolver will fail.
 742   if (recv_klass-&gt;is_array_klass() ||
 743       InstanceKlass::cast(recv_klass())-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface()) {
 744     if (h_resolved-&gt;is_interface()) {
 745       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 746     } else {
 747       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 748     }
 749   }
 750 
 751   if (m.is_null()) {
 752     // Return NULL only if there was a problem with lookup (uninitialized class, etc.)
 753     return NULL;
 754   }
 755 
 756   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);
 757   return JNIHandles::make_local(THREAD, result);
 758 C2V_END
 759 
 760 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))
 761   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 762   assert(klass != NULL, "method must not be called for primitive types");
 763   return Dependencies::find_finalizable_subclass(klass) != NULL;
 764 C2V_END
 765 
 766 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))
 767   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 768   oop result = CompilerToVM::get_jvmci_method(klass-&gt;class_initializer(), CHECK_NULL);
 769   return JNIHandles::make_local(THREAD, result);
 770 C2V_END
 771 
 772 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))
 773   address target_addr = (address) addr;
 774   if (target_addr != 0x0) {
 775     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 776     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 777     return MAX2(ABS(off_low), ABS(off_high));
 778   }
 779   return -1;
 780 C2V_END
 781 
 782 C2V_VMENTRY(void, doNotInlineOrCompile,(JNIEnv *, jobject,  jobject jvmci_method))
 783   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 784   method-&gt;set_not_c1_compilable();
 785   method-&gt;set_not_c2_compilable();
 786   method-&gt;set_dont_inline(true);
 787 C2V_END
 788 
 789 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))
 790   ResourceMark rm;
 791   HandleMark hm;
 792   Handle target_handle = JNIHandles::resolve(target);
 793   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 794   CodeBlob* cb = NULL;
 795   Handle installed_code_handle = JNIHandles::resolve(installed_code);
 796   Handle speculation_log_handle = JNIHandles::resolve(speculation_log);
 797 
 798   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK_JNI_ERR);
 799 
 800   TraceTime install_time("installCode", JVMCICompiler::codeInstallTimer());
 801   CodeInstaller installer;
 802   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);
 803 
 804   if (PrintCodeCacheOnCompilation) {
 805     stringStream s;
 806     // Dump code cache  into a buffer before locking the tty,
 807     {
 808       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 809       CodeCache::print_summary(&amp;s, false);
 810     }
 811     ttyLocker ttyl;
 812     tty-&gt;print_raw_cr(s.as_string());
 813   }
 814 
 815   if (result != JVMCIEnv::ok) {
 816     assert(cb == NULL, "should be");
 817   } else {
 818     if (!installed_code_handle.is_null()) {
 819       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), "wrong type");
 820       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);
 821       {
 822         // Ensure that all updates to the InstalledCode fields are consistent.
 823         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
 824         InstalledCode::set_address(installed_code_handle, (jlong) cb);
 825         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);
 826         if (cb-&gt;is_nmethod()) {
 827           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());
 828         } else {
 829           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());
 830         }
 831         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {
 832           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());
 833           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());
 834           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());
 835         }
 836       }
 837       nmethod* nm = cb-&gt;as_nmethod_or_null();
 838       if (nm != NULL &amp;&amp; installed_code_handle-&gt;is_scavengable()) {
 839         assert(nm-&gt;detect_scavenge_root_oops(), "nm should be scavengable if installed_code is scavengable");
 840         if (!UseG1GC) {
 841           assert(nm-&gt;on_scavenge_root_list(), "nm should be on scavengable list");
 842         }
 843       }
 844     }
 845   }
 846   return result;
 847 C2V_END
 848 
 849 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))
 850   ResourceMark rm;
 851   HandleMark hm;
 852 
 853   Handle target_handle = JNIHandles::resolve(target);
 854   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 855   Handle metadata_handle = JNIHandles::resolve(metadata);
 856 
 857   CodeMetadata code_metadata;
 858   CodeBlob *cb = NULL;
 859   CodeInstaller installer;
 860 
 861   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);
 862   if (result != JVMCIEnv::ok) {
 863     return result;
 864   }
 865 
 866   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 867     typeArrayHandle pcArrayOop = oopFactory::new_byteArray(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));
 868     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());
 869     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());
 870   }
 871 
 872   if (code_metadata.get_scopes_size() &gt; 0) {
 873     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));
 874     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());
 875     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());
 876   }
 877 
 878   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
 879   typeArrayHandle relocArrayOop = oopFactory::new_byteArray((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));
 880   if (reloc_buffer-&gt;size() &gt; 0) {
 881     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());
 882   }
 883   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());
 884 
 885   const OopMapSet* oopMapSet = installer.oopMapSet();
 886   {
 887     ResourceMark mark;
 888     ImmutableOopMapBuilder builder(oopMapSet);
 889     int oopmap_size = builder.heap_size();
 890     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray(oopmap_size, CHECK_(JVMCIEnv::cache_full));
 891     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));
 892     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());
 893   }
 894 
 895   HotSpotMetaData::set_metadata(metadata_handle, NULL);
 896 
 897   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 898   int table_size = handler-&gt;size_in_bytes();
 899   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray(table_size, CHECK_(JVMCIEnv::cache_full));
 900 
 901   if (table_size &gt; 0) {
 902     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));
 903   }
 904   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());
 905 
 906   return result;
 907 C2V_END
 908 
 909 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))
 910   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK);
 911   CompilerStatistics* stats = compiler-&gt;stats();
 912   stats-&gt;_standard.reset();
 913   stats-&gt;_osr.reset();
 914 C2V_END
 915 
 916 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))
 917   ResourceMark rm;
 918   HandleMark hm;
 919 
 920   if (installedCode == NULL) {
 921     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), "installedCode is null");
 922   }
 923 
 924   jlong codeBlob = InstalledCode::address(installedCode);
 925   if (codeBlob == 0L) {
 926     return NULL;
 927   }
 928 
 929   CodeBlob* cb = (CodeBlob*) (address) codeBlob;
 930   if (cb == NULL) {
 931     return NULL;
 932   }
 933 
 934   // We don't want the stringStream buffer to resize during disassembly as it
 935   // uses scoped resource memory. If a nested function called during disassembly uses
 936   // a ResourceMark and the buffer expands within the scope of the mark,
 937   // the buffer becomes garbage when that scope is exited. Experience shows that
 938   // the disassembled code is typically about 10x the code size so a fixed buffer
 939   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 940   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 941   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 942   stringStream st(buffer, bufferSize);
 943   if (cb-&gt;is_nmethod()) {
 944     nmethod* nm = (nmethod*) cb;
 945     if (!nm-&gt;is_alive()) {
 946       return NULL;
 947     }
 948   }
 949   Disassembler::decode(cb, &amp;st);
 950   if (st.size() &lt;= 0) {
 951     return NULL;
 952   }
 953 
 954   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);
 955   return JNIHandles::make_local(THREAD, result());
 956 C2V_END
 957 
 958 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))
 959   ResourceMark rm;
 960   HandleMark hm;
 961 
 962   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 963   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);
 964   return JNIHandles::make_local(THREAD, element);
 965 C2V_END
 966 
 967 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))
 968   ResourceMark rm;
 969   HandleMark hm;
 970 
 971   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);
 972   if (nmethodValue == 0L) {
 973     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
 974   }
 975   nmethod* nm = (nmethod*) (address) nmethodValue;
 976   methodHandle mh = nm-&gt;method();
 977   Symbol* signature = mh-&gt;signature();
 978   JavaCallArguments jca(mh-&gt;size_of_parameters());
 979 
 980   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
 981   JavaValue result(jap.get_ret_type());
 982   jca.set_alternative_target(nm);
 983   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
 984 
 985   if (jap.get_ret_type() == T_VOID) {
 986     return NULL;
 987   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
 988     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
 989   } else {
 990     jvalue *value = (jvalue *) result.get_value_addr();
 991     // Narrow the value down if required (Important on big endian machines)
 992     switch (jap.get_ret_type()) {
 993       case T_BOOLEAN:
 994        value-&gt;z = (jboolean) value-&gt;i;
 995        break;
 996       case T_BYTE:
 997        value-&gt;b = (jbyte) value-&gt;i;
 998        break;
 999       case T_CHAR:
1000        value-&gt;c = (jchar) value-&gt;i;
1001        break;
1002       case T_SHORT:
1003        value-&gt;s = (jshort) value-&gt;i;
1004        break;
1005      }
1006     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);
1007     return JNIHandles::make_local(THREAD, o);
1008   }
1009 C2V_END
1010 
1011 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))
1012   Method* method = CompilerToVM::asMethod(jvmci_method);
1013   if (!method-&gt;has_linenumber_table()) {
1014     return NULL;
1015   }
1016   u2 num_entries = 0;
1017   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1018   while (streamForSize.read_pair()) {
1019     num_entries++;
1020   }
1021 
1022   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1023   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);
1024 
1025   int i = 0;
1026   jlong value;
1027   while (stream.read_pair()) {
1028     value = ((long) stream.bci());
1029     result-&gt;long_at_put(i, value);
1030     value = ((long) stream.line());
1031     result-&gt;long_at_put(i + 1, value);
1032     i += 2;
1033   }
1034 
1035   return (jlongArray) JNIHandles::make_local(THREAD, result);
1036 C2V_END
1037 
1038 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))
1039   ResourceMark rm;
1040   Method* method = CompilerToVM::asMethod(jvmci_method);
1041   if (!method-&gt;has_localvariable_table()) {
1042     return 0;
1043   }
1044   return (jlong) (address) method-&gt;localvariable_table_start();
1045 C2V_END
1046 
1047 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))
1048   ResourceMark rm;
1049   Method* method = CompilerToVM::asMethod(jvmci_method);
1050   return method-&gt;localvariable_table_length();
1051 C2V_END
1052 
1053 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))
1054   Method* method = CompilerToVM::asMethod(jvmci_method);
1055   MethodCounters* mcs = method-&gt;method_counters();
1056   if (mcs != NULL) {
1057     mcs-&gt;clear_counters();
1058   }
1059   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1060 
1061   CompiledMethod* code = method-&gt;code();
1062   if (code != NULL) {
1063     code-&gt;make_not_entrant();
1064   }
1065 
1066   MethodData* method_data = method-&gt;method_data();
1067   if (method_data == NULL) {
1068     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1069     method_data = MethodData::allocate(loader_data, method, CHECK);
1070     method-&gt;set_method_data(method_data);
1071   } else {
1072     method_data-&gt;initialize();
1073   }
1074 C2V_END
1075 
1076 
1077 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))
1078   Handle installed_code_handle = JNIHandles::resolve(installed_code);
1079   nmethod::invalidate_installed_code(installed_code_handle, CHECK);
1080 C2V_END
1081 
1082 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))
1083   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);
1084   JavaThread::collect_counters(arrayOop);
1085   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);
1086 C2V_END
1087 
1088 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))
1089   HandleMark hm;
1090   ResourceMark rm;
1091   if (JNIHandles::resolve(jvmci_method) == NULL) {
1092     THROW_0(vmSymbols::java_lang_NullPointerException());
1093   }
1094   Method* method = CompilerToVM::asMethod(jvmci_method);
1095   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1096     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Unexpected bci %d", entry_bci));
1097   }
1098   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1099 C2V_END
1100 
1101 
1102 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))
1103   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1104   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1105 C2V_END
1106 
1107 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1108   Method* method = CompilerToVM::asMethod(jvmci_method);
1109   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1110 C2V_END
1111 
1112 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))
1113   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);
1114   return JNIHandles::make_local(THREAD, sym());
1115 C2V_END
1116 
1117 bool matches(jobjectArray methods, Method* method) {
1118   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1119 
1120   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1121     oop resolved = methods_oop-&gt;obj_at(i);
1122     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {
1123       return true;
1124     }
1125   }
1126   return false;
1127 }
1128 
1129 C2V_VMENTRY(jobject, getNextStackFrame, (JNIEnv*, jobject compilerToVM, jobject hs_frame, jobjectArray methods, jint initialSkip))
1130   ResourceMark rm;
1131 
1132   if (!thread-&gt;has_last_Java_frame()) return NULL;
1133   Handle result = HotSpotStackFrameReference::klass()-&gt;allocate_instance(thread);
1134   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1135 
1136   StackFrameStream fst(thread);
1137   if (hs_frame != NULL) {
1138     // look for the correct stack frame if one is given
1139     intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1140     while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1141       fst.next();
1142     }
1143     if (fst.current()-&gt;sp() != stack_pointer) {
1144       THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1145     }
1146   }
1147 
1148   int frame_number = 0;
1149   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1150   if (hs_frame != NULL) {
1151     // look for the correct vframe within the stack frame if one is given
1152     int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1153     while (frame_number &lt; last_frame_number) {
1154       if (vf-&gt;is_top()) {
1155         THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1156       }
1157       vf = vf-&gt;sender();
1158       frame_number ++;
1159     }
1160     // move one frame forward
1161     if (vf-&gt;is_top()) {
1162       if (fst.is_done()) {
1163         return NULL;
1164       }
1165       fst.next();
1166       vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1167       frame_number = 0;
1168     } else {
1169       vf = vf-&gt;sender();
1170       frame_number++;
1171     }
1172   }
1173 
1174   while (true) {
1175     // look for the given method
1176     while (true) {
1177       StackValueCollection* locals = NULL;
1178       if (vf-&gt;is_compiled_frame()) {
1179         // compiled method frame
1180         compiledVFrame* cvf = compiledVFrame::cast(vf);
1181         if (methods == NULL || matches(methods, cvf-&gt;method())) {
1182           if (initialSkip &gt; 0) {
1183             initialSkip --;
1184           } else {
1185             ScopeDesc* scope = cvf-&gt;scope();
1186             // native wrapper do not have a scope
1187             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1188               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), scope-&gt;objects(), THREAD);
1189               Deoptimization::reassign_fields(fst.current(), fst.register_map(), scope-&gt;objects(), realloc_failures, false);
1190 
1191               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1192               typeArrayHandle array = oopFactory::new_boolArray(local_values-&gt;length(), thread);
1193               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1194                 ScopeValue* value = local_values-&gt;at(i);
1195                 if (value-&gt;is_object()) {
1196                   array-&gt;bool_at_put(i, true);
1197                 }
1198               }
1199               HotSpotStackFrameReference::set_localIsVirtual(result, array());
1200             } else {
1201               HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1202             }
1203 
1204             locals = cvf-&gt;locals();
1205             HotSpotStackFrameReference::set_bci(result, cvf-&gt;bci());
1206             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);
1207             HotSpotStackFrameReference::set_method(result, method);
1208           }
1209         }
1210       } else if (vf-&gt;is_interpreted_frame()) {
1211         // interpreted method frame
1212         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1213         if (methods == NULL || matches(methods, ivf-&gt;method())) {
1214           if (initialSkip &gt; 0) {
1215             initialSkip --;
1216           } else {
1217             locals = ivf-&gt;locals();
1218             HotSpotStackFrameReference::set_bci(result, ivf-&gt;bci());
1219             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);
1220             HotSpotStackFrameReference::set_method(result, method);
1221             HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1222           }
1223         }
1224       }
1225 
1226       // locals != NULL means that we found a matching frame and result is already partially initialized
1227       if (locals != NULL) {
1228         HotSpotStackFrameReference::set_compilerToVM(result, JNIHandles::resolve(compilerToVM));
1229         HotSpotStackFrameReference::set_stackPointer(result, (jlong) fst.current()-&gt;sp());
1230         HotSpotStackFrameReference::set_frameNumber(result, frame_number);
1231 
1232         // initialize the locals array
1233         objArrayHandle array = oopFactory::new_objectArray(locals-&gt;size(), thread);
1234         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1235           StackValue* var = locals-&gt;at(i);
1236           if (var-&gt;type() == T_OBJECT) {
1237             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1238           }
1239         }
1240         HotSpotStackFrameReference::set_locals(result, array());
1241 
1242         return JNIHandles::make_local(thread, result());
1243       }
1244 
1245       if (vf-&gt;is_top()) {
1246         break;
1247       }
1248       frame_number++;
1249       vf = vf-&gt;sender();
1250     } // end of vframe loop
1251 
1252     if (fst.is_done()) {
1253       break;
1254     }
1255     fst.next();
1256     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1257     frame_number = 0;
1258   } // end of frame loop
1259 
1260   // the end was reached without finding a matching method
1261   return NULL;
1262 C2V_END
1263 
1264 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1265   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1266   CallInfo callInfo;
1267   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1268   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1269   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1270 C2V_END
1271 
1272 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1273   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1274   CallInfo callInfo;
1275   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1276   ConstantPoolCacheEntry* cp_cache_entry = cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1277   cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1278 C2V_END
1279 
1280 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))
1281   //see compute_recording_non_safepoints in debugInfroRec.cpp
1282   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1283     return true;
1284   }
1285   return DebugNonSafepoints;
1286 C2V_END
1287 
1288 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1289 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))
1290   ResourceMark rm;
1291 
1292   if (hs_frame == NULL) {
1293     THROW_MSG(vmSymbols::java_lang_NullPointerException(), "stack frame is null")
1294   }
1295 
1296   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1297 
1298   // look for the given stack frame
1299   StackFrameStream fst(thread);
1300   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1301   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1302     fst.next();
1303   }
1304   if (fst.current()-&gt;sp() != stack_pointer) {
1305     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1306   }
1307 
1308   if (invalidate) {
1309     if (!fst.current()-&gt;is_compiled_frame()) {
1310       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1311     }
1312     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), "nmethod expected");
1313     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1314   }
1315   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1316   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1317   StackFrameStream fstAfterDeopt(thread);
1318   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1319     fstAfterDeopt.next();
1320   }
1321   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1322     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found after deopt")
1323   }
1324 
1325   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1326   if (!vf-&gt;is_compiled_frame()) {
1327     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1328   }
1329 
1330   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1331   while (true) {
1332     assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1333     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1334     if (vf-&gt;is_top()) {
1335       break;
1336     }
1337     vf = vf-&gt;sender();
1338   }
1339 
1340   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1341   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1342     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1343   }
1344 
1345   // Reallocate the non-escaping objects and restore their fields.
1346   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,"invalid scope");
1347   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1348 
1349   if (objects == NULL) {
1350     // no objects to materialize
1351     return;
1352   }
1353 
1354   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, THREAD);
1355   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1356 
1357   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1358     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1359 
1360     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1361     StackValueCollection* locals = cvf-&gt;locals();
1362 
1363     if (locals != NULL) {
1364       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1365         StackValue* var = locals-&gt;at(i2);
1366         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1367           jvalue val;
1368           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1369           cvf-&gt;update_local(T_OBJECT, i2, val);
1370         }
1371       }
1372     }
1373   }
1374 
1375   // all locals are materialized by now
1376   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);
1377 
1378   // update the locals array
1379   objArrayHandle array = HotSpotStackFrameReference::locals(hs_frame);
1380   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1381   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1382     StackValue* var = locals-&gt;at(i);
1383     if (var-&gt;type() == T_OBJECT) {
1384       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1385     }
1386   }
1387 C2V_END
1388 
1389 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))
1390   if (bytes == NULL) {
1391     THROW(vmSymbols::java_lang_NullPointerException());
1392   }
1393   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);
1394 
1395   // Check if offset and length are non negative.
1396   if (offset &lt; 0 || length &lt; 0) {
1397     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1398   }
1399   // Check if the range is valid.
1400   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {
1401     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1402   }
1403   while (length &gt; 0) {
1404     jbyte* start = array-&gt;byte_at_addr(offset);
1405     tty-&gt;write((char*) start, MIN2(length, O_BUFLEN));
1406     length -= O_BUFLEN;
1407     offset += O_BUFLEN;
1408   }
1409 C2V_END
1410 
1411 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))
1412   tty-&gt;flush();
1413 C2V_END
1414 
1415 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))
1416   ResourceMark rm;
1417   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1418   ProfileData* profile_data = mdo-&gt;data_at(position);
1419   if (mdo-&gt;is_valid(profile_data)) {
1420     return profile_data-&gt;size_in_bytes();
1421   }
1422   DataLayout* data    = mdo-&gt;extra_data_base();
1423   DataLayout* end   = mdo-&gt;extra_data_limit();
1424   for (;; data = mdo-&gt;next_extra(data)) {
1425     assert(data &lt; end, "moved past end of extra data");
1426     profile_data = data-&gt;data_in();
1427     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1428       return profile_data-&gt;size_in_bytes();
1429     }
1430   }
1431   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Invalid profile data position %d", position));
1432 C2V_END
1433 
1434 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))
1435   if (bytecode_frame_handle == NULL) {
1436     THROW_0(vmSymbols::java_lang_NullPointerException());
1437   }
1438 
1439   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);
1440   oop bytecode_frame = top_bytecode_frame;
1441   int size = 0;
1442   int callee_parameters = 0;
1443   int callee_locals = 0;
1444   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1445   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);
1446 
1447   while (bytecode_frame != NULL) {
1448     int locks = BytecodeFrame::numLocks(bytecode_frame);
1449     int temps = BytecodeFrame::numStack(bytecode_frame);
1450     bool is_top_frame = (bytecode_frame == top_bytecode_frame);
1451     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1452 
1453     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1454                                                                  temps + callee_parameters,
1455                                                                  extra_args,
1456                                                                  locks,
1457                                                                  callee_parameters,
1458                                                                  callee_locals,
1459                                                                  is_top_frame);
1460     size += frame_size;
1461 
1462     callee_parameters = method-&gt;size_of_parameters();
1463     callee_locals = method-&gt;max_locals();
1464     extra_args = 0;
1465     bytecode_frame = BytecodePosition::caller(bytecode_frame);
1466   }
1467   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1468 C2V_END
1469 
1470 
1471 #define CC (char*)  /*cast a literal from (const char*)*/
1472 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1473 
1474 #define STRING                "Ljava/lang/String;"
1475 #define OBJECT                "Ljava/lang/Object;"
1476 #define CLASS                 "Ljava/lang/Class;"
1477 #define STACK_TRACE_ELEMENT   "Ljava/lang/StackTraceElement;"
1478 #define INSTALLED_CODE        "Ljdk/vm/ci/code/InstalledCode;"
1479 #define TARGET_DESCRIPTION    "Ljdk/vm/ci/code/TargetDescription;"
1480 #define BYTECODE_FRAME        "Ljdk/vm/ci/code/BytecodeFrame;"
1481 #define RESOLVED_METHOD       "Ljdk/vm/ci/meta/ResolvedJavaMethod;"
1482 #define HS_RESOLVED_METHOD    "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;"
1483 #define HS_RESOLVED_KLASS     "Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;"
1484 #define HS_CONSTANT_POOL      "Ljdk/vm/ci/hotspot/HotSpotConstantPool;"
1485 #define HS_COMPILED_CODE      "Ljdk/vm/ci/hotspot/HotSpotCompiledCode;"
1486 #define HS_CONFIG             "Ljdk/vm/ci/hotspot/HotSpotVMConfig;"
1487 #define HS_METADATA           "Ljdk/vm/ci/hotspot/HotSpotMetaData;"
1488 #define HS_STACK_FRAME_REF    "Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;"
1489 #define HS_SPECULATION_LOG    "Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;"
1490 #define METASPACE_METHOD_DATA "J"
1491 
1492 JNINativeMethod CompilerToVM::methods[] = {
1493   {CC "getBytecode",                                  CC "(" HS_RESOLVED_METHOD ")[B",                                                      FN_PTR(getBytecode)},
1494   {CC "getExceptionTableStart",                       CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getExceptionTableStart)},
1495   {CC "getExceptionTableLength",                      CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getExceptionTableLength)},
1496   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1497   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1498   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1499   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1500   {CC "doNotInlineOrCompile",                         CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(doNotInlineOrCompile)},
1501   {CC "canInlineMethod",                              CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(canInlineMethod)},
1502   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1503   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1504   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1505   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1506   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1507   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1508   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1509   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1510   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1511   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1512   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1513   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1514   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
1515   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[J)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
1516   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1517   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1518   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1519   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1520   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1521   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1522   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1523   {CC "getResolvedJavaMethodAtSlot",                  CC "(" CLASS "I)" HS_RESOLVED_METHOD,                                                 FN_PTR(getResolvedJavaMethodAtSlot)},
1524   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
<a name="6" id="anc6"></a><span class="changed">1525   {CC "getConstantPool",                              CC "(Ljava/lang/Object;J)" HS_CONSTANT_POOL,                                          FN_PTR(getConstantPool)},</span>
1526   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1527   {CC "readConfiguration",                            CC "()[" OBJECT,                                                                      FN_PTR(readConfiguration)},
1528   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1529   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1530   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1531   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1532   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1533   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1534   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1535   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1536   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1537   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1538   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1539   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1540   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1541   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1542   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1543   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1544   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1545   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1546   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1547   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1548   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1549   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1550 };
1551 
1552 int CompilerToVM::methods_count() {
1553   return sizeof(methods) / sizeof(JNINativeMethod);
1554 }
1555 
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="7" type="hidden" /></form></body></html>
