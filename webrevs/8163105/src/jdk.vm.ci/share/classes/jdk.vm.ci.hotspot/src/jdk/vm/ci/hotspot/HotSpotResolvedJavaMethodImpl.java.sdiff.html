<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 104     }
 105 
 106     HotSpotResolvedJavaMethodImpl(HotSpotResolvedObjectTypeImpl holder, long metaspaceMethod) {
 107         // It would be too much work to get the method name here so we fill it in later.
 108         super(null);
 109         this.metaspaceMethod = metaspaceMethod;
 110         this.holder = holder;
 111 
 112         HotSpotVMConfig config = config();
 113         final long constMethod = getConstMethod();
 114 
 115         /*
 116          * Get the constant pool from the metaspace method. Some methods (e.g. intrinsics for
 117          * signature-polymorphic method handle methods) have their own constant pool instead of the
 118          * one from their holder.
 119          */
 120         final long metaspaceConstantPool = UNSAFE.getAddress(constMethod + config.constMethodConstantsOffset);
 121         if (metaspaceConstantPool == holder.getConstantPool().getMetaspaceConstantPool()) {
 122             this.constantPool = holder.getConstantPool();
 123         } else {
<span class="changed"> 124             this.constantPool = compilerToVM().getConstantPool(null, constMethod + config.constMethodConstantsOffset);</span>
 125         }
 126 
 127         final int nameIndex = UNSAFE.getChar(constMethod + config.constMethodNameIndexOffset);
 128         this.name = constantPool.lookupUtf8(nameIndex);
 129 
 130         final int signatureIndex = UNSAFE.getChar(constMethod + config.constMethodSignatureIndexOffset);
 131         this.signature = (HotSpotSignature) constantPool.lookupSignature(signatureIndex);
 132     }
 133 
 134     /**
 135      * Returns a pointer to this method's constant method data structure (
 136      * {@code Method::_constMethod}). This pointer isn't wrapped since it should be safe to use it
 137      * within the context of this HotSpotResolvedJavaMethodImpl since the Method* and ConstMethod*
 138      * are kept alive as a pair.
 139      *
 140      * @return pointer to this method's ConstMethod
 141      */
 142     private long getConstMethod() {
 143         assert metaspaceMethod != 0;
 144         return UNSAFE.getAddress(metaspaceMethod + config().methodConstMethodOffset);

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 104     }
 105 
 106     HotSpotResolvedJavaMethodImpl(HotSpotResolvedObjectTypeImpl holder, long metaspaceMethod) {
 107         // It would be too much work to get the method name here so we fill it in later.
 108         super(null);
 109         this.metaspaceMethod = metaspaceMethod;
 110         this.holder = holder;
 111 
 112         HotSpotVMConfig config = config();
 113         final long constMethod = getConstMethod();
 114 
 115         /*
 116          * Get the constant pool from the metaspace method. Some methods (e.g. intrinsics for
 117          * signature-polymorphic method handle methods) have their own constant pool instead of the
 118          * one from their holder.
 119          */
 120         final long metaspaceConstantPool = UNSAFE.getAddress(constMethod + config.constMethodConstantsOffset);
 121         if (metaspaceConstantPool == holder.getConstantPool().getMetaspaceConstantPool()) {
 122             this.constantPool = holder.getConstantPool();
 123         } else {
<span class="changed"> 124             this.constantPool = compilerToVM().getConstantPool(this);</span>
 125         }
 126 
 127         final int nameIndex = UNSAFE.getChar(constMethod + config.constMethodNameIndexOffset);
 128         this.name = constantPool.lookupUtf8(nameIndex);
 129 
 130         final int signatureIndex = UNSAFE.getChar(constMethod + config.constMethodSignatureIndexOffset);
 131         this.signature = (HotSpotSignature) constantPool.lookupSignature(signatureIndex);
 132     }
 133 
 134     /**
 135      * Returns a pointer to this method's constant method data structure (
 136      * {@code Method::_constMethod}). This pointer isn't wrapped since it should be safe to use it
 137      * within the context of this HotSpotResolvedJavaMethodImpl since the Method* and ConstMethod*
 138      * are kept alive as a pair.
 139      *
 140      * @return pointer to this method's ConstMethod
 141      */
 142     private long getConstMethod() {
 143         assert metaspaceMethod != 0;
 144         return UNSAFE.getAddress(metaspaceMethod + config().methodConstMethodOffset);

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
