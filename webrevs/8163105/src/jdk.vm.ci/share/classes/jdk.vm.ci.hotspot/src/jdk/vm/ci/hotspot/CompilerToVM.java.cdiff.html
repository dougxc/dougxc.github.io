<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Cdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java</title>
</head>
<body id="SUNWwebrev">
<center>&lt prev <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl.java.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre></pre>
        <pre>
<hr /><span class="oldmarker">*** 263,275 ****</span>
       * @throws LinkageError if resolution failed
       */
      native HotSpotResolvedObjectTypeImpl resolveTypeInPool(HotSpotConstantPool constantPool, int cpi) throws LinkageError;
  
      /**
<span class="changed">!      * Looks up and attempts to resolve the {@code JVM_CONSTANT_Field} entry for at index {@code cpi} in</span>
<span class="changed">!      * {@code constantPool}. For some opcodes, checks are performed that require the {@code method}</span>
<span class="changed">!      * that contains {@code opcode} to be specified. The values returned in {@code info} are:</span>
       *
       * &lt;pre&gt;
       *     [(int) flags,   // only valid if field is resolved
       *      (int) offset]  // only valid if field is resolved
       * &lt;/pre&gt;
<span class="newmarker">--- 263,276 ----</span>
       * @throws LinkageError if resolution failed
       */
      native HotSpotResolvedObjectTypeImpl resolveTypeInPool(HotSpotConstantPool constantPool, int cpi) throws LinkageError;
  
      /**
<span class="changed">!      * Looks up and attempts to resolve the {@code JVM_CONSTANT_Field} entry for at index</span>
<span class="changed">!      * {@code cpi} in {@code constantPool}. For some opcodes, checks are performed that require the</span>
<span class="changed">!      * {@code method} that contains {@code opcode} to be specified. The values returned in</span>
<span class="changed">!      * {@code info} are:</span>
       *
       * &lt;pre&gt;
       *     [(int) flags,   // only valid if field is resolved
       *      (int) offset]  // only valid if field is resolved
       * &lt;/pre&gt;
<hr /><span class="oldmarker">*** 554,577 ****</span>
       * @return null or the resolved method for this location
       */
      native HotSpotResolvedJavaMethodImpl getResolvedJavaMethod(Object base, long displacement);
  
      /**
<span class="changed">!      * Read a HotSpot ConstantPool* value from the memory location described by {@code base} plus</span>
<span class="changed">!      * {@code displacement} and return the {@link HotSpotConstantPool} wrapping it. This method does</span>
<span class="changed">!      * no checking that the memory location actually contains a valid pointer and may crash the VM</span>
<span class="changed">!      * if an invalid location is provided. If the {@code base} is null then {@code displacement} is</span>
<span class="changed">!      * used by itself. If {@code base} is a {@link HotSpotResolvedJavaMethodImpl},</span>
<span class="changed">!      * {@link HotSpotConstantPool} or {@link HotSpotResolvedObjectTypeImpl} then the metaspace</span>
<span class="changed">!      * pointer is fetched from that object and added to {@code displacement}. Any other non-null</span>
<span class="changed">!      * object type causes an {@link IllegalArgumentException} to be thrown.</span>
       *
<span class="changed">!      * @param base an object to read from or null</span>
<span class="changed">!      * @param displacement</span>
<span class="changed">!      * @return null or the resolved method for this location</span>
       */
<span class="changed">!     native HotSpotConstantPool getConstantPool(Object base, long displacement);</span>
  
      /**
       * Read a HotSpot Klass* value from the memory location described by {@code base} plus
       * {@code displacement} and return the {@link HotSpotResolvedObjectTypeImpl} wrapping it. This
       * method does no checking that the memory location actually contains a valid pointer and may
<span class="newmarker">--- 555,576 ----</span>
       * @return null or the resolved method for this location
       */
      native HotSpotResolvedJavaMethodImpl getResolvedJavaMethod(Object base, long displacement);
  
      /**
<span class="changed">!      * Gets the {@code ConstantPool*} associated with {@code object} and returns a</span>
<span class="changed">!      * {@link HotSpotConstantPool} wrapping it.</span>
       *
<span class="changed">!      * @param object a {@link HotSpotResolvedJavaMethodImpl} or</span>
<span class="changed">!      *            {@link HotSpotResolvedObjectTypeImpl} object</span>
<span class="changed">!      * @return a {@link HotSpotConstantPool} wrapping the {@code ConstantPool*} associated with</span>
<span class="changed">!      *         {@code object}</span>
<span class="changed">!      * @throws NullPointerException if {@code object == null}</span>
<span class="changed">!      * @throws IllegalArgumentException if {@code object} is neither a</span>
<span class="changed">!      *             {@link HotSpotResolvedJavaMethodImpl} nor a {@link HotSpotResolvedObjectTypeImpl}</span>
       */
<span class="changed">!     native HotSpotConstantPool getConstantPool(Object object);</span>
  
      /**
       * Read a HotSpot Klass* value from the memory location described by {@code base} plus
       * {@code displacement} and return the {@link HotSpotResolvedObjectTypeImpl} wrapping it. This
       * method does no checking that the memory location actually contains a valid pointer and may
</pre>
<center>&lt prev <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl.java.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

