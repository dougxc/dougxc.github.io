<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package jdk.vm.ci.hotspot;
  25 
  26 import jdk.vm.ci.code.InstalledCode;
  27 import jdk.vm.ci.code.InvalidInstalledCodeException;
  28 import jdk.vm.ci.code.TargetDescription;
  29 import jdk.vm.ci.meta.ConstantPool;
  30 import jdk.vm.ci.meta.ResolvedJavaMethod;
<a name="1" id="anc1"></a>
  31 
  32 /**
  33  * A simple "proxy" class to get test access to CompilerToVM package-private methods
  34  */
  35 public class CompilerToVMHelper {
  36     public static final CompilerToVM CTVM = new CompilerToVM();
  37 
  38     public static byte[] getBytecode(HotSpotResolvedJavaMethod method) {
  39         return CTVM.getBytecode((HotSpotResolvedJavaMethodImpl)method);
  40     }
  41 
  42     public static int getExceptionTableLength(HotSpotResolvedJavaMethod method) {
  43         return CTVM.getExceptionTableLength((HotSpotResolvedJavaMethodImpl)method);
  44     }
  45 
  46     public static long getExceptionTableStart(HotSpotResolvedJavaMethod method) {
  47         return CTVM.getExceptionTableStart((HotSpotResolvedJavaMethodImpl)method);
  48     }
  49 
  50     public static boolean canInlineMethod(HotSpotResolvedJavaMethod method) {
  51         return CTVM.canInlineMethod((HotSpotResolvedJavaMethodImpl)method);
  52     }
  53 
  54     public static boolean shouldInlineMethod(HotSpotResolvedJavaMethod method) {
  55         return CTVM.shouldInlineMethod((HotSpotResolvedJavaMethodImpl)method);
  56     }
  57 
  58     public static HotSpotResolvedJavaMethod findUniqueConcreteMethod(
  59             HotSpotResolvedObjectType actualHolderType,
  60             HotSpotResolvedJavaMethod method) {
  61         return CTVM.findUniqueConcreteMethod((HotSpotResolvedObjectTypeImpl) actualHolderType, (HotSpotResolvedJavaMethodImpl)method);
  62     }
  63 
  64     public static HotSpotResolvedObjectType getImplementor(HotSpotResolvedObjectType type) {
  65         return CTVM.getImplementor((HotSpotResolvedObjectTypeImpl) type);
  66     }
  67 
  68     public static boolean methodIsIgnoredBySecurityStackWalk(HotSpotResolvedJavaMethod method) {
  69         return CTVM.methodIsIgnoredBySecurityStackWalk((HotSpotResolvedJavaMethodImpl)method);
  70     }
  71 
  72     public static HotSpotResolvedObjectType lookupType(String name,
  73             Class&lt;?&gt; accessingClass, boolean resolve) {
  74         return CTVM.lookupType(name, accessingClass, resolve);
  75     }
  76 
  77     public static Object resolveConstantInPool(ConstantPool constantPool, int cpi) {
  78         return CTVM.resolveConstantInPool((HotSpotConstantPool) constantPool, cpi);
  79     }
  80 
  81     public static Object resolvePossiblyCachedConstantInPool(ConstantPool constantPool, int cpi) {
  82         return CTVM.resolvePossiblyCachedConstantInPool((HotSpotConstantPool) constantPool, cpi);
  83     }
  84 
  85     public static int lookupNameAndTypeRefIndexInPool(ConstantPool constantPool, int cpi) {
  86         return CTVM.lookupNameAndTypeRefIndexInPool((HotSpotConstantPool) constantPool, cpi);
  87     }
  88 
  89     public static String lookupNameInPool(ConstantPool constantPool, int cpi) {
  90         return CTVM.lookupNameInPool((HotSpotConstantPool) constantPool, cpi);
  91     }
  92 
  93     public static String lookupSignatureInPool(ConstantPool constantPool, int cpi) {
  94         return CTVM.lookupSignatureInPool((HotSpotConstantPool) constantPool, cpi);
  95     }
  96 
  97     public static int lookupKlassRefIndexInPool(ConstantPool constantPool, int cpi) {
  98         return CTVM.lookupKlassRefIndexInPool((HotSpotConstantPool) constantPool, cpi);
  99     }
 100 
 101     public static Object lookupKlassInPool(ConstantPool constantPool, int cpi) {
 102         return CTVM.lookupKlassInPool((HotSpotConstantPool) constantPool, cpi);
 103     }
 104 
 105     public static HotSpotResolvedJavaMethod lookupMethodInPool(
 106             ConstantPool constantPool, int cpi, byte opcode) {
 107         return CTVM.lookupMethodInPool((HotSpotConstantPool) constantPool, cpi, opcode);
 108     }
 109 
 110     public static void resolveInvokeDynamicInPool(
 111             ConstantPool constantPool, int cpi) {
 112         CTVM.resolveInvokeDynamicInPool((HotSpotConstantPool) constantPool, cpi);
 113     }
 114 
 115     public static void resolveInvokeHandleInPool(
 116             ConstantPool constantPool, int cpi) {
 117         CTVM.resolveInvokeHandleInPool((HotSpotConstantPool) constantPool, cpi);
 118     }
 119 
 120     public static HotSpotResolvedObjectType resolveTypeInPool(
 121             ConstantPool constantPool, int cpi) {
 122         return CTVM.resolveTypeInPool((HotSpotConstantPool) constantPool, cpi);
 123     }
 124 
 125     public static HotSpotResolvedObjectType resolveFieldInPool(
 126             ConstantPool constantPool, int cpi, ResolvedJavaMethod method, byte opcode, long[] info) {
 127         return CTVM.resolveFieldInPool((HotSpotConstantPool) constantPool, cpi, (HotSpotResolvedJavaMethodImpl) method, opcode, info);
 128     }
 129 
 130     public static int constantPoolRemapInstructionOperandFromCache(
 131             ConstantPool constantPool, int cpci) {
 132         return CTVM.constantPoolRemapInstructionOperandFromCache((HotSpotConstantPool) constantPool, cpci);
 133     }
 134 
 135     public static Object lookupAppendixInPool(
 136             ConstantPool constantPool, int cpi) {
 137         return CTVM.lookupAppendixInPool((HotSpotConstantPool) constantPool, cpi);
 138     }
 139 
 140     public static int installCode(TargetDescription target,
 141             HotSpotCompiledCode compiledCode, InstalledCode code, HotSpotSpeculationLog speculationLog) {
 142         return CTVM.installCode(target, compiledCode, code, speculationLog);
 143     }
 144 
 145     public static int getMetadata(TargetDescription target,
 146             HotSpotCompiledCode compiledCode, HotSpotMetaData metaData) {
 147         return CTVM.getMetadata(target, compiledCode, metaData);
 148     }
 149 
 150     public static void resetCompilationStatistics() {
 151         CTVM.resetCompilationStatistics();
 152     }
 153 
 154     public static Object[] readConfiguration() {
 155         return CTVM.readConfiguration();
 156     }
 157 
 158     public static HotSpotResolvedJavaMethod resolveMethod(
 159             HotSpotResolvedObjectType exactReceiver,
 160             HotSpotResolvedJavaMethod method,
 161             HotSpotResolvedObjectType caller) {
 162         return CTVM.resolveMethod((HotSpotResolvedObjectTypeImpl) exactReceiver, (HotSpotResolvedJavaMethodImpl) method, (HotSpotResolvedObjectTypeImpl) caller);
 163     }
 164 
 165     public static HotSpotResolvedJavaMethod getClassInitializer(
 166             HotSpotResolvedObjectType type) {
 167         return CTVM.getClassInitializer((HotSpotResolvedObjectTypeImpl) type);
 168     }
 169 
 170     public static boolean hasFinalizableSubclass(HotSpotResolvedObjectType type) {
 171         return CTVM.hasFinalizableSubclass((HotSpotResolvedObjectTypeImpl) type);
 172     }
 173 
<a name="2" id="anc2"></a><span class="changed"> 174     public static HotSpotResolvedJavaMethodImpl getResolvedJavaMethodAtSlot(</span>
<span class="changed"> 175             Class&lt;?&gt; holder, int slot) {</span>
<span class="changed"> 176         return CTVM.getResolvedJavaMethodAtSlot(holder, slot);</span>
 177     }
 178 
 179     public static long getMaxCallTargetOffset(long address) {
 180         return CTVM.getMaxCallTargetOffset(address);
 181     }
 182 
 183     public static String disassembleCodeBlob(InstalledCode codeBlob) {
 184         return CTVM.disassembleCodeBlob(codeBlob);
 185     }
 186 
 187     public static StackTraceElement getStackTraceElement(
 188             HotSpotResolvedJavaMethod method, int bci) {
 189         return CTVM.getStackTraceElement((HotSpotResolvedJavaMethodImpl)method, bci);
 190     }
 191 
 192     public static Object executeInstalledCode(Object[] args,
 193             InstalledCode installedCode) throws InvalidInstalledCodeException {
 194         return CTVM.executeInstalledCode(args, installedCode);
 195     }
 196 
 197     public static long[] getLineNumberTable(HotSpotResolvedJavaMethod method) {
 198         return CTVM.getLineNumberTable((HotSpotResolvedJavaMethodImpl)method);
 199     }
 200 
 201     public static int getLocalVariableTableLength(HotSpotResolvedJavaMethod method) {
 202         return CTVM.getLocalVariableTableLength((HotSpotResolvedJavaMethodImpl)method);
 203     }
 204 
 205     public static long getLocalVariableTableStart(HotSpotResolvedJavaMethod method) {
 206         return CTVM.getLocalVariableTableStart((HotSpotResolvedJavaMethodImpl)method);
 207     }
 208 
 209     public static void doNotInlineOrCompile(HotSpotResolvedJavaMethod method) {
 210         CTVM.doNotInlineOrCompile((HotSpotResolvedJavaMethodImpl)method);
 211     }
 212 
 213     public static void reprofile(HotSpotResolvedJavaMethod method) {
 214         CTVM.reprofile((HotSpotResolvedJavaMethodImpl)method);
 215     }
 216 
 217     public static void invalidateInstalledCode(InstalledCode installedCode) {
 218         CTVM.invalidateInstalledCode(installedCode);
 219     }
 220 
 221     public static long[] collectCounters() {
 222         return CTVM.collectCounters();
 223     }
 224 
 225     public static boolean isMature(long metaspaceMethodData) {
 226         return CTVM.isMature(metaspaceMethodData);
 227     }
 228 
 229     public static int allocateCompileId(HotSpotResolvedJavaMethod method,
 230             int entryBCI) {
 231         return CTVM.allocateCompileId((HotSpotResolvedJavaMethodImpl) method, entryBCI);
 232     }
 233 
 234     public static boolean hasCompiledCodeForOSR(
 235             HotSpotResolvedJavaMethod method, int entryBCI, int level) {
 236         return CTVM.hasCompiledCodeForOSR((HotSpotResolvedJavaMethodImpl) method, entryBCI, level);
 237     }
 238 
 239     public static String getSymbol(long metaspaceSymbol) {
 240         return CTVM.getSymbol(metaspaceSymbol);
 241     }
 242 
 243     public static HotSpotStackFrameReference getNextStackFrame(
 244             HotSpotStackFrameReference frame,
 245             ResolvedJavaMethod[] methods, int initialSkip) {
 246         return CTVM.getNextStackFrame(frame, methods, initialSkip);
 247     }
 248 
 249     public static void materializeVirtualObjects(
 250             HotSpotStackFrameReference stackFrame, boolean invalidate) {
 251         CTVM.materializeVirtualObjects(stackFrame, invalidate);
 252     }
 253 
 254     public static int getVtableIndexForInterfaceMethod(HotSpotResolvedObjectType type,
 255             HotSpotResolvedJavaMethod method) {
 256         return CTVM.getVtableIndexForInterfaceMethod((HotSpotResolvedObjectTypeImpl) type, (HotSpotResolvedJavaMethodImpl) method);
 257     }
 258 
 259     public static boolean shouldDebugNonSafepoints() {
 260         return CTVM.shouldDebugNonSafepoints();
 261     }
 262 
 263     public static void writeDebugOutput(byte[] bytes, int offset, int length) {
 264         CTVM.writeDebugOutput(bytes, offset, length);
 265     }
 266 
 267     public static void flushDebugOutput() {
 268         CTVM.flushDebugOutput();
 269     }
 270 
 271     public static HotSpotResolvedJavaMethod getResolvedJavaMethod(Object base,
 272             long displacement) {
 273         return CTVM.getResolvedJavaMethod(base, displacement);
 274     }
 275 
 276     public static HotSpotConstantPool getConstantPool(Object object) {
 277         return CTVM.getConstantPool(object);
 278     }
 279 
 280     public static HotSpotResolvedObjectType getResolvedJavaType(Object base,
 281             long displacement, boolean compressed) {
 282         return CTVM.getResolvedJavaType(base, displacement, compressed);
 283     }
 284 
 285     public static long getMetaspacePointer(Object o) {
 286         return ((MetaspaceWrapperObject) o).getMetaspacePointer();
 287     }
 288 
 289     public static Class&lt;?&gt; CompilerToVMClass() {
 290         return CompilerToVM.class;
 291     }
 292 
 293     public static Class&lt;?&gt; HotSpotConstantPoolClass() {
 294         return HotSpotConstantPool.class;
 295     }
 296 
 297     public static Class&lt;?&gt; getMirror(HotSpotResolvedObjectType type) {
 298         return ((HotSpotResolvedJavaType) type).mirror();
 299     }
 300 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="3" type="hidden" /></form></body></html>
