<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/share/vm/jvmci/jvmciCompilerToVM.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "code/codeCache.hpp"
  27 #include "code/scopeDesc.hpp"
  28 #include "interpreter/linkResolver.hpp"
  29 #include "memory/oopFactory.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "oops/generateOopMap.hpp"
  32 #include "oops/fieldStreams.hpp"
  33 #include "oops/oop.inline.hpp"
  34 #include "oops/objArrayOop.inline.hpp"
  35 #include "runtime/fieldDescriptor.hpp"
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"
  56 
  57 
  58 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  59 #define C2V_VMENTRY(result_type, name, signature) \
  60   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  61   TRACE_jvmci_1("CompilerToVM::" #name); \
  62   TRACE_CALL(result_type, jvmci_ ## name signature) \
  63   JVMCI_VM_ENTRY_MARK; \
  64 
  65 #define C2V_END }
  66 
  67 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  68   if (method() != NULL) {
  69     JavaValue result(T_OBJECT);
  70     JavaCallArguments args;
  71     args.push_long((jlong) (address) method());
  72     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  73 
  74     return (oop)result.get_jobject();
  75   }
  76   return NULL;
  77 }
  78 
  79 oop CompilerToVM::get_jvmci_type(KlassHandle klass, TRAPS) {
  80   if (klass() != NULL) {
  81     JavaValue result(T_OBJECT);
  82     JavaCallArguments args;
  83     args.push_oop(klass-&gt;java_mirror());
  84     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  85 
  86     return (oop)result.get_jobject();
  87   }
  88   return NULL;
  89 }
  90 
  91 int CompilerToVM::Data::Klass_vtable_start_offset;
  92 int CompilerToVM::Data::Klass_vtable_length_offset;
  93 
  94 int CompilerToVM::Data::Method_extra_stack_entries;
  95 
  96 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
  97 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
  98 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
  99 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 100 
 101 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 102 
 103 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 104 int CompilerToVM::Data::Universe_base_vtable_size;
 105 address CompilerToVM::Data::Universe_narrow_oop_base;
 106 int CompilerToVM::Data::Universe_narrow_oop_shift;
 107 address CompilerToVM::Data::Universe_narrow_klass_base;
 108 int CompilerToVM::Data::Universe_narrow_klass_shift;
 109 void* CompilerToVM::Data::Universe_non_oop_bits;
 110 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 111 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 112 
 113 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 114 HeapWord** CompilerToVM::Data::_heap_end_addr;
 115 HeapWord** CompilerToVM::Data::_heap_top_addr;
 116 int CompilerToVM::Data::_max_oop_map_stack_offset;
 117 
 118 jbyte* CompilerToVM::Data::cardtable_start_address;
 119 int CompilerToVM::Data::cardtable_shift;
 120 
 121 int CompilerToVM::Data::vm_page_size;
 122 
 123 address CompilerToVM::Data::dsin;
 124 address CompilerToVM::Data::dcos;
 125 address CompilerToVM::Data::dtan;
 126 address CompilerToVM::Data::dexp;
 127 address CompilerToVM::Data::dlog;
 128 address CompilerToVM::Data::dlog10;
 129 address CompilerToVM::Data::dpow;
 130 
 131 void CompilerToVM::Data::initialize() {
 132   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 133   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 134 
 135   Method_extra_stack_entries = Method::extra_stack_entries();
 136 
 137   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 138   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 139   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 140   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 141 
 142   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 143 
 144   Universe_collectedHeap = Universe::heap();
 145   Universe_base_vtable_size = Universe::base_vtable_size();
 146   Universe_narrow_oop_base = Universe::narrow_oop_base();
 147   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 148   Universe_narrow_klass_base = Universe::narrow_klass_base();
 149   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 150   Universe_non_oop_bits = Universe::non_oop_word();
 151   Universe_verify_oop_mask = Universe::verify_oop_mask();
 152   Universe_verify_oop_bits = Universe::verify_oop_bits();
 153 
 154   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 155   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 156   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord**) -1;
 157 
 158   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 159   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 160   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 161   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 162 
 163   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 164   switch (bs-&gt;kind()) {
 165   case BarrierSet::CardTableModRef:
 166   case BarrierSet::CardTableForRS:
 167   case BarrierSet::CardTableExtension:
 168   case BarrierSet::G1SATBCT:
 169   case BarrierSet::G1SATBCTLogging: {
 170     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 171     assert(base != 0, "unexpected byte_map_base");
 172     cardtable_start_address = base;
 173     cardtable_shift = CardTableModRefBS::card_shift;
 174     break;
 175   }
 176   case BarrierSet::ModRef:
 177     cardtable_start_address = 0;
 178     cardtable_shift = 0;
 179     // No post barriers
 180     break;
 181   default:
 182     ShouldNotReachHere();
 183     break;
 184   }
 185 
 186   vm_page_size = os::vm_page_size();
 187 
 188 #define SET_TRIGFUNC(name)                                      \
 189   if (StubRoutines::name() != NULL) {                           \
 190     name = StubRoutines::name();                                \
 191   } else {                                                      \
 192     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 193   }
 194 
 195   SET_TRIGFUNC(dsin);
 196   SET_TRIGFUNC(dcos);
 197   SET_TRIGFUNC(dtan);
 198   SET_TRIGFUNC(dexp);
 199   SET_TRIGFUNC(dlog10);
 200   SET_TRIGFUNC(dlog);
 201   SET_TRIGFUNC(dpow);
 202 
 203 #undef SET_TRIGFUNC
 204 }
 205 
 206 objArrayHandle CompilerToVM::initialize_intrinsics(TRAPS) {
 207   objArrayHandle vmIntrinsics = oopFactory::new_objArray(VMIntrinsicMethod::klass(), (vmIntrinsics::ID_LIMIT - 1), CHECK_(objArrayHandle()));
 208   int index = 0;
 209   // The intrinsics for a class are usually adjacent to each other.
 210   // When they are, the string for the class name can be reused.
 211   vmSymbols::SID kls_sid = vmSymbols::NO_SID;
 212   Handle kls_str;
 213 #define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)
 214 #define VM_SYMBOL_TO_STRING(s) \
 215   java_lang_String::create_from_symbol(vmSymbols::symbol_at(SID_ENUM(s)), CHECK_(objArrayHandle()))
 216 #define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \
 217     instanceHandle vmIntrinsicMethod = InstanceKlass::cast(VMIntrinsicMethod::klass())-&gt;allocate_instance_handle(CHECK_(objArrayHandle())); \
 218     if (kls_sid != SID_ENUM(kls)) {                                       \
 219       kls_str = VM_SYMBOL_TO_STRING(kls);                                 \
 220       kls_sid = SID_ENUM(kls);                                            \
 221     }                                                                     \
 222     Handle name_str = VM_SYMBOL_TO_STRING(name);                          \
 223     Handle sig_str = VM_SYMBOL_TO_STRING(sig);                            \
 224     VMIntrinsicMethod::set_declaringClass(vmIntrinsicMethod, kls_str());  \
 225     VMIntrinsicMethod::set_name(vmIntrinsicMethod, name_str());           \
 226     VMIntrinsicMethod::set_descriptor(vmIntrinsicMethod, sig_str());      \
 227     VMIntrinsicMethod::set_id(vmIntrinsicMethod, vmIntrinsics::id);       \
 228       vmIntrinsics-&gt;obj_at_put(index++, vmIntrinsicMethod());             \
 229   }
 230 
 231   VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
 232 #undef SID_ENUM
 233 #undef VM_SYMBOL_TO_STRING
 234 #undef VM_INTRINSIC_INFO
 235   assert(index == vmIntrinsics::ID_LIMIT - 1, "must be");
 236 
 237   return vmIntrinsics;
 238 }
 239 
 240 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))
 241 #define BOXED_LONG(name, value) oop name; do { jvalue p; p.j = (jlong) (value); name = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL);} while(0)
 242 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)
 243   ResourceMark rm;
 244   HandleMark hm;
 245 
 246   CompilerToVM::Data::initialize();
 247 
 248   VMField::klass()-&gt;initialize(CHECK_NULL);
 249   VMFlag::klass()-&gt;initialize(CHECK_NULL);
 250   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);
 251 
 252   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
 253   objArrayHandle vmFields = oopFactory::new_objArray(VMField::klass(), len, CHECK_NULL);
 254   for (int i = 0; i &lt; len ; i++) {
 255     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
 256     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 257     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* "::" */;
 258     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
 259     sprintf(name_buf, "%s::%s", vmField.typeName, vmField.fieldName);
 260     Handle name = java_lang_String::create_from_str(name_buf, CHECK_NULL);
 261     Handle type = java_lang_String::create_from_str(vmField.typeString, CHECK_NULL);
 262     VMField::set_name(vmFieldObj, name());
 263     VMField::set_type(vmFieldObj, type());
 264     VMField::set_offset(vmFieldObj, vmField.offset);
 265     VMField::set_address(vmFieldObj, (jlong) vmField.address);
 266     if (vmField.isStatic) {
 267       if (strcmp(vmField.typeString, "bool") == 0) {
 268         BOXED_LONG(value, *(jbyte*) vmField.address);
 269         VMField::set_value(vmFieldObj, value);
 270       } else if (strcmp(vmField.typeString, "int") == 0 ||
 271                  strcmp(vmField.typeString, "jint") == 0) {
 272         BOXED_LONG(value, *(jint*) vmField.address);
 273         VMField::set_value(vmFieldObj, value);
 274       } else if (strcmp(vmField.typeString, "uint64_t") == 0) {
 275         BOXED_LONG(value, *(uint64_t*) vmField.address);
 276         VMField::set_value(vmFieldObj, value);
 277       } else if (strcmp(vmField.typeString, "address") == 0 ||
 278                  strcmp(vmField.typeString, "intptr_t") == 0 ||
 279                  strcmp(vmField.typeString, "uintptr_t") == 0 ||
 280                  strcmp(vmField.typeString, "size_t") == 0 ||
 281                  // All foo* types are addresses.
 282                  vmField.typeString[strlen(vmField.typeString) - 1] == '*') {
 283         BOXED_LONG(value, *((address*) vmField.address));
 284         VMField::set_value(vmFieldObj, value);
 285       } else {
 286         JVMCI_ERROR_NULL("VM field %s has unsupported type %s", name_buf, vmField.typeString);
 287       }
 288     }
 289     vmFields-&gt;obj_at_put(i, vmFieldObj());
 290   }
 291 
 292   len = JVMCIVMStructs::localHotSpotVMTypes_count();
 293   objArrayHandle vmTypes = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 294   for (int i = 0; i &lt; len ; i++) {
 295     VMTypeEntry vmType = JVMCIVMStructs::localHotSpotVMTypes[i];
 296     Handle name = java_lang_String::create_from_str(vmType.typeName, CHECK_NULL);
 297     BOXED_LONG(size, vmType.size);
 298     vmTypes-&gt;obj_at_put(i * 2, name());
 299     vmTypes-&gt;obj_at_put(i * 2 + 1, size);
 300   }
 301 
 302   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
 303   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
 304   len = ints_len + longs_len;
 305   objArrayHandle vmConstants = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 306   int insert = 0;
 307   for (int i = 0; i &lt; ints_len ; i++) {
 308     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
 309     Handle name = java_lang_String::create_from_str(c.name, CHECK_NULL);
 310     BOXED_LONG(value, c.value);
 311     vmConstants-&gt;obj_at_put(insert++, name());
 312     vmConstants-&gt;obj_at_put(insert++, value);
 313   }
 314   for (int i = 0; i &lt; longs_len ; i++) {
 315     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
 316     Handle name = java_lang_String::create_from_str(c.name, CHECK_NULL);
 317     BOXED_LONG(value, c.value);
 318     vmConstants-&gt;obj_at_put(insert++, name());
 319     vmConstants-&gt;obj_at_put(insert++, value);
 320   }
 321   assert(insert == len * 2, "must be");
 322 
 323   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
 324   objArrayHandle vmAddresses = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 325   for (int i = 0; i &lt; len ; i++) {
 326     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
 327     Handle name = java_lang_String::create_from_str(a.name, CHECK_NULL);
 328     BOXED_LONG(value, a.value);
 329     vmAddresses-&gt;obj_at_put(i * 2, name());
 330     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);
 331   }
 332 
 333   // The last entry is the null entry.
 334   len = (int) Flag::numFlags - 1;
 335   objArrayHandle vmFlags = oopFactory::new_objArray(VMFlag::klass(), len, CHECK_NULL);
 336   for (int i = 0; i &lt; len; i++) {
 337     Flag* flag = &amp;Flag::flags[i];
 338     instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 339     Handle name = java_lang_String::create_from_str(flag-&gt;_name, CHECK_NULL);
 340     Handle type = java_lang_String::create_from_str(flag-&gt;_type, CHECK_NULL);
 341     VMFlag::set_name(vmFlagObj, name());
 342     VMFlag::set_type(vmFlagObj, type());
 343     if (flag-&gt;is_bool()) {
 344       BOXED_LONG(value, flag-&gt;get_bool());
 345       VMFlag::set_value(vmFlagObj, value);
 346     } else if (flag-&gt;is_ccstr()) {
 347       Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
 348       VMFlag::set_value(vmFlagObj, value());
 349     } else if (flag-&gt;is_int()) {
 350       BOXED_LONG(value, flag-&gt;get_int());
 351       VMFlag::set_value(vmFlagObj, value);
 352     } else if (flag-&gt;is_intx()) {
 353       BOXED_LONG(value, flag-&gt;get_intx());
 354       VMFlag::set_value(vmFlagObj, value);
 355     } else if (flag-&gt;is_uint()) {
 356       BOXED_LONG(value, flag-&gt;get_uint());
 357       VMFlag::set_value(vmFlagObj, value);
 358     } else if (flag-&gt;is_uint64_t()) {
 359       BOXED_LONG(value, flag-&gt;get_uint64_t());
 360       VMFlag::set_value(vmFlagObj, value);
 361     } else if (flag-&gt;is_uintx()) {
 362       BOXED_LONG(value, flag-&gt;get_uintx());
 363       VMFlag::set_value(vmFlagObj, value);
 364     } else if (flag-&gt;is_double()) {
 365       BOXED_DOUBLE(value, flag-&gt;get_double());
 366       VMFlag::set_value(vmFlagObj, value);
 367     } else if (flag-&gt;is_size_t()) {
 368       BOXED_LONG(value, flag-&gt;get_size_t());
 369       VMFlag::set_value(vmFlagObj, value);
 370     } else {
 371       JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
 372     }
 373     vmFlags-&gt;obj_at_put(i, vmFlagObj());
 374   }
 375 
 376   objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);
 377 
 378   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 6, CHECK_NULL);
 379   data-&gt;obj_at_put(0, vmFields());
 380   data-&gt;obj_at_put(1, vmTypes());
 381   data-&gt;obj_at_put(2, vmConstants());
 382   data-&gt;obj_at_put(3, vmAddresses());
 383   data-&gt;obj_at_put(4, vmFlags());
 384   data-&gt;obj_at_put(5, vmIntrinsics());
 385 
 386   return (jobjectArray) JNIHandles::make_local(THREAD, data);
 387 #undef BOXED_LONG
 388 #undef BOXED_DOUBLE
 389 C2V_END
 390 
 391 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 392   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 393   ResourceMark rm;
 394 
 395   int code_size = method-&gt;code_size();
 396   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 397 
 398   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 399   // iterate over all bytecodes and replace non-Java bytecodes
 400 
 401   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 402     Bytecodes::Code code = s.code();
 403     Bytecodes::Code raw_code = s.raw_code();
 404     int bci = s.bci();
 405     int len = s.instruction_size();
 406 
 407     // Restore original byte code.
 408     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 409     if (len &gt; 1) {
 410       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);
 411     }
 412 
 413     if (len &gt; 1) {
 414       // Restore the big-endian constant pool indexes.
 415       // Cf. Rewriter::scan_method
 416       switch (code) {
 417         case Bytecodes::_getstatic:
 418         case Bytecodes::_putstatic:
 419         case Bytecodes::_getfield:
 420         case Bytecodes::_putfield:
 421         case Bytecodes::_invokevirtual:
 422         case Bytecodes::_invokespecial:
 423         case Bytecodes::_invokestatic:
 424         case Bytecodes::_invokeinterface:
 425         case Bytecodes::_invokehandle: {
 426           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 427           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 428           break;
 429         }
 430 
 431         case Bytecodes::_invokedynamic:
 432           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 433           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);
 434           break;
 435       }
 436 
 437       // Not all ldc byte code are rewritten.
 438       switch (raw_code) {
 439         case Bytecodes::_fast_aldc: {
 440           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;
 441           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 442           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 443           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);
 444           break;
 445         }
 446 
 447         case Bytecodes::_fast_aldc_w: {
 448           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 449           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 450           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 451           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 452           break;
 453         }
 454       }
 455     }
 456   }
 457 
 458   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);
 459 C2V_END
 460 
 461 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 462   ResourceMark rm;
 463   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 464   return method-&gt;exception_table_length();
 465 C2V_END
 466 
 467 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 468   ResourceMark rm;
 469   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 470   if (method-&gt;exception_table_length() == 0) {
 471     return 0L;
 472   }
 473   return (jlong) (address) method-&gt;exception_table_start();
 474 C2V_END
 475 
 476 C2V_VMENTRY(jobject, asResolvedJavaMethod, (JNIEnv *, jobject, jobject executable_handle))
 477   oop executable = JNIHandles::resolve(executable_handle);
 478   oop mirror = NULL;
 479   int slot = 0;
 480 
 481   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 482     mirror = java_lang_reflect_Constructor::clazz(executable);
 483     slot = java_lang_reflect_Constructor::slot(executable);
 484   } else {
 485     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), "wrong type");
 486     mirror = java_lang_reflect_Method::clazz(executable);
 487     slot = java_lang_reflect_Method::slot(executable);
 488   }
 489   Klass* holder = java_lang_Class::as_Klass(mirror);
 490   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 491   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 492   return JNIHandles::make_local(THREAD, result);
 493 }
 494 
 495 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))
 496   methodHandle method;
 497   oop base_object = JNIHandles::resolve(base);
 498   if (base_object == NULL) {
 499     method = *((Method**)(offset));
 500   } else if (base_object-&gt;is_a(SystemDictionary::MemberName_klass())) {
 501     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);
 502   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 503     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));
 504   } else {
 505     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 506                 err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 507   }
 508   assert (method.is_null() || method-&gt;is_method(), "invalid read");
 509   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 510   return JNIHandles::make_local(THREAD, result);
 511 }
 512 
 513 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject object_handle))
 514   constantPoolHandle cp;
 515   oop object = JNIHandles::resolve(object_handle);
 516   if (object == NULL) {
 517     THROW_0(vmSymbols::java_lang_NullPointerException());
 518   }
 519   if (object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 520     cp = CompilerToVM::asMethod(object)-&gt;constMethod()-&gt;constants();
 521   } else if (object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 522     cp = InstanceKlass::cast(CompilerToVM::asKlass(object))-&gt;constants();
 523   } else {
 524     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 525                 err_msg("Unexpected type: %s", object-&gt;klass()-&gt;external_name()));
 526   }
 527   assert(!cp.is_null(), "npe");
 528   JavaValue method_result(T_OBJECT);
 529   JavaCallArguments args;
 530   args.push_long((jlong) (address) cp());
 531   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 532   return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());
 533 }
 534 
 535 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))
 536   KlassHandle klass;
 537   oop base_object = JNIHandles::resolve(base);
 538   jlong base_address = 0;
 539   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 540     klass = base_object-&gt;klass();
 541   } else if (!compressed) {
 542     if (base_object != NULL) {
 543       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 544         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 545       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 546         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 547       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 548         base_address = (jlong) CompilerToVM::asKlass(base_object);
 549       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {
 550         base_address = (jlong) (address) base_object;
 551       } else {
 552         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 553                     err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 554       }
 555     }
 556     klass = *((Klass**) (intptr_t) (base_address + offset));
 557   } else {
 558     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 559                 err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 560   }
 561   assert (klass.is_null() || klass-&gt;is_klass(), "invalid read");
 562   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 563   return JNIHandles::make_local(THREAD, result);
 564 }
 565 
 566 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 567   ResourceMark rm;
 568   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 569   KlassHandle holder = CompilerToVM::asKlass(jvmci_type);
 570   if (holder-&gt;is_interface()) {
 571     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", holder-&gt;external_name()));
 572   }
 573 
 574   methodHandle ucm;
 575   {
 576     MutexLocker locker(Compile_lock);
 577     ucm = Dependencies::find_unique_concrete_method(holder(), method());
 578   }
 579   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);
 580   return JNIHandles::make_local(THREAD, result);
 581 C2V_END
 582 
 583 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))
 584   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 585   oop implementor = CompilerToVM::get_jvmci_type(klass-&gt;implementor(), CHECK_NULL);
 586   return JNIHandles::make_local(THREAD, implementor);
 587 C2V_END
 588 
 589 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))
 590   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 591   return method-&gt;is_ignored_by_security_stack_walk();
 592 C2V_END
 593 
 594 C2V_VMENTRY(jboolean, canInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 595   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 596   // In hosted mode ignore the not_compilable flags since they are never set by
 597   // the JVMCI compiler.
 598   bool is_compilable = UseJVMCICompiler ? !method-&gt;is_not_compilable(CompLevel_full_optimization) : true;
 599   return is_compilable &amp;&amp; !CompilerOracle::should_not_inline(method) &amp;&amp; !method-&gt;dont_inline();
 600 C2V_END
 601 
 602 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 603   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 604   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 605 C2V_END
 606 
 607 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 608   ResourceMark rm;
 609   Handle name = JNIHandles::resolve(jname);
 610   Symbol* class_name = java_lang_String::as_symbol(name, CHECK_0);
 611   if (java_lang_String::length(name()) &lt;= 1) {
 612     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Primitive type %s should be handled in Java code", class_name-&gt;as_C_string()));
 613   }
 614 
 615   Klass* resolved_klass = NULL;
 616   Handle class_loader;
 617   Handle protection_domain;
 618   if (JNIHandles::resolve(accessing_class) == NULL) {
 619     THROW_0(vmSymbols::java_lang_NullPointerException());
 620   }
 621   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));
 622   class_loader = accessing_klass-&gt;class_loader();
 623   protection_domain = accessing_klass-&gt;protection_domain();
 624 
 625   if (resolve) {
 626     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 627   } else {
 628     if (class_name-&gt;byte_at(0) == 'L' &amp;&amp;
 629       class_name-&gt;byte_at(class_name-&gt;utf8_length()-1) == ';') {
 630       // This is a name from a signature.  Strip off the trimmings.
 631       // Call recursive to keep scope of strippedsym.
 632       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 633                                                           class_name-&gt;utf8_length()-2,
 634                                                           CHECK_0);
 635       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 636     } else if (FieldType::is_array(class_name)) {
 637       FieldArrayInfo fd;
 638       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 639       // of this call
 640       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 641       if (t == T_OBJECT) {
 642         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 643                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 644                                                             CHECK_0);
 645         // naked oop "k" is OK here -- we assign back into it
 646         resolved_klass = SystemDictionary::find(strippedsym,
 647                                                              class_loader,
 648                                                              protection_domain,
 649                                                              CHECK_0);
 650         if (resolved_klass != NULL) {
 651           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 652         }
 653       } else {
 654         resolved_klass = Universe::typeArrayKlassObj(t);
 655         resolved_klass = TypeArrayKlass::cast(resolved_klass)-&gt;array_klass(fd.dimension(), CHECK_0);
 656       }
 657     }
 658   }
 659   Handle result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 660   return JNIHandles::make_local(THREAD, result());
 661 C2V_END
 662 
 663 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 664   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 665   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);
 666   return JNIHandles::make_local(THREAD, result);
 667 C2V_END
 668 
 669 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 670   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 671   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 672   return JNIHandles::make_local(THREAD, result);
 673 C2V_END
 674 
 675 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 676   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 677   return cp-&gt;name_and_type_ref_index_at(index);
 678 C2V_END
 679 
 680 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 681   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 682   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);
 683   return JNIHandles::make_local(THREAD, sym());
 684 C2V_END
 685 
 686 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 687   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 688   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);
 689   return JNIHandles::make_local(THREAD, sym());
 690 C2V_END
 691 
 692 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 693   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 694   return cp-&gt;klass_ref_index_at(index);
 695 C2V_END
 696 
 697 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 698   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 699   Klass* resolved_klass = cp-&gt;klass_at(index, CHECK_NULL);
 700   Handle klass = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 701   return JNIHandles::make_local(THREAD, klass());
 702 C2V_END
 703 
 704 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 705   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 706   KlassHandle loading_klass(cp-&gt;pool_holder());
 707   bool is_accessible = false;
 708   KlassHandle klass = JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass);
 709   Symbol* symbol = NULL;
 710   if (klass.is_null()) {
 711     symbol = cp-&gt;klass_name_at(index);
 712   }
 713   Handle result;
 714   if (!klass.is_null()) {
 715     result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 716   } else {
 717     result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
 718   }
 719   return JNIHandles::make_local(THREAD, result());
 720 C2V_END
 721 
 722 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 723   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 724   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 725   return JNIHandles::make_local(THREAD, appendix_oop);
 726 C2V_END
 727 
 728 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 729   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 730   instanceKlassHandle pool_holder(cp-&gt;pool_holder());
 731   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 732   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 733   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 734   return JNIHandles::make_local(THREAD, result);
 735 C2V_END
 736 
 737 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 738   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 739   return cp-&gt;remap_instruction_operand_from_cache(index);
 740 C2V_END
 741 
 742 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jlongArray info_handle))
 743   ResourceMark rm;
 744   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 745   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 746   fieldDescriptor fd;
 747   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
 748   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 749   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
 750   assert(info != NULL &amp;&amp; info-&gt;length() == 2, "must be");
 751   info-&gt;long_at_put(0, (jlong) fd.access_flags().as_int());
 752   info-&gt;long_at_put(1, (jlong) fd.offset());
 753   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 754   return JNIHandles::make_local(THREAD, field_holder);
 755 C2V_END
 756 
 757 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 758   ResourceMark rm;
 759   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 760   Method* method = CompilerToVM::asMethod(jvmci_method);
 761   if (klass-&gt;is_interface()) {
 762     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 763   }
 764   if (!method-&gt;method_holder()-&gt;is_interface()) {
 765     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 766   }
 767   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 768     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 769   }
 770   return LinkResolver::vtable_index_of_interface_method(klass, method);
 771 C2V_END
 772 
 773 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 774   KlassHandle recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);
 775   KlassHandle caller_klass = CompilerToVM::asKlass(caller_jvmci_type);
 776   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 777 
 778   KlassHandle h_resolved   (THREAD, method-&gt;method_holder());
 779   Symbol* h_name      = method-&gt;name();
 780   Symbol* h_signature = method-&gt;signature();
 781 
 782   if (MethodHandles::is_signature_polymorphic_method(method())) {
 783       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 784       return NULL;
 785   }
 786 
 787   LinkInfo link_info(h_resolved, h_name, h_signature, caller_klass);
 788   methodHandle m;
 789   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 790   // the vtable has not been setup, and the LinkResolver will fail.
 791   if (recv_klass-&gt;is_array_klass() ||
 792       InstanceKlass::cast(recv_klass())-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface()) {
 793     if (h_resolved-&gt;is_interface()) {
 794       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 795     } else {
 796       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 797     }
 798   }
 799 
 800   if (m.is_null()) {
 801     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 802     return NULL;
 803   }
 804 
 805   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);
 806   return JNIHandles::make_local(THREAD, result);
 807 C2V_END
 808 
 809 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))
 810   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 811   assert(klass != NULL, "method must not be called for primitive types");
 812   return Dependencies::find_finalizable_subclass(klass) != NULL;
 813 C2V_END
 814 
 815 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))
 816   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 817   oop result = CompilerToVM::get_jvmci_method(klass-&gt;class_initializer(), CHECK_NULL);
 818   return JNIHandles::make_local(THREAD, result);
 819 C2V_END
 820 
 821 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))
 822   address target_addr = (address) addr;
 823   if (target_addr != 0x0) {
 824     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 825     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 826     return MAX2(ABS(off_low), ABS(off_high));
 827   }
 828   return -1;
 829 C2V_END
 830 
 831 C2V_VMENTRY(void, doNotInlineOrCompile,(JNIEnv *, jobject,  jobject jvmci_method))
 832   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 833   method-&gt;set_not_c1_compilable();
 834   method-&gt;set_not_c2_compilable();
 835   method-&gt;set_dont_inline(true);
 836 C2V_END
 837 
 838 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))
 839   ResourceMark rm;
 840   HandleMark hm;
 841   Handle target_handle = JNIHandles::resolve(target);
 842   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 843   CodeBlob* cb = NULL;
 844   Handle installed_code_handle = JNIHandles::resolve(installed_code);
 845   Handle speculation_log_handle = JNIHandles::resolve(speculation_log);
 846 
 847   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK_JNI_ERR);
 848 
 849   TraceTime install_time("installCode", JVMCICompiler::codeInstallTimer());
 850   CodeInstaller installer;
 851   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);
 852 
 853   if (PrintCodeCacheOnCompilation) {
 854     stringStream s;
 855     // Dump code cache  into a buffer before locking the tty,
 856     {
 857       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 858       CodeCache::print_summary(&amp;s, false);
 859     }
 860     ttyLocker ttyl;
 861     tty-&gt;print_raw_cr(s.as_string());
 862   }
 863 
 864   if (result != JVMCIEnv::ok) {
 865     assert(cb == NULL, "should be");
 866   } else {
 867     if (!installed_code_handle.is_null()) {
 868       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), "wrong type");
 869       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);
 870       {
 871         // Ensure that all updates to the InstalledCode fields are consistent.
 872         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
 873         InstalledCode::set_address(installed_code_handle, (jlong) cb);
 874         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);
 875         if (cb-&gt;is_nmethod()) {
 876           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());
 877         } else {
 878           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());
 879         }
 880         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {
 881           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());
 882           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());
 883           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());
 884         }
 885       }
 886       nmethod* nm = cb-&gt;as_nmethod_or_null();
 887       if (nm != NULL &amp;&amp; installed_code_handle-&gt;is_scavengable()) {
 888         assert(nm-&gt;detect_scavenge_root_oops(), "nm should be scavengable if installed_code is scavengable");
 889         if (!UseG1GC) {
 890           assert(nm-&gt;on_scavenge_root_list(), "nm should be on scavengable list");
 891         }
 892       }
 893     }
 894   }
 895   return result;
 896 C2V_END
 897 
 898 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))
 899   ResourceMark rm;
 900   HandleMark hm;
 901 
 902   Handle target_handle = JNIHandles::resolve(target);
 903   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 904   Handle metadata_handle = JNIHandles::resolve(metadata);
 905 
 906   CodeMetadata code_metadata;
 907   CodeBlob *cb = NULL;
 908   CodeInstaller installer;
 909 
 910   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);
 911   if (result != JVMCIEnv::ok) {
 912     return result;
 913   }
 914 
 915   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 916     typeArrayHandle pcArrayOop = oopFactory::new_byteArray(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));
 917     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());
 918     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());
 919   }
 920 
 921   if (code_metadata.get_scopes_size() &gt; 0) {
 922     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));
 923     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());
 924     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());
 925   }
 926 
 927   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
 928   typeArrayHandle relocArrayOop = oopFactory::new_byteArray((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));
 929   if (reloc_buffer-&gt;size() &gt; 0) {
 930     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());
 931   }
 932   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());
 933 
 934   const OopMapSet* oopMapSet = installer.oopMapSet();
 935   {
 936     ResourceMark mark;
 937     ImmutableOopMapBuilder builder(oopMapSet);
 938     int oopmap_size = builder.heap_size();
 939     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray(oopmap_size, CHECK_(JVMCIEnv::cache_full));
 940     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));
 941     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());
 942   }
 943 
 944   HotSpotMetaData::set_metadata(metadata_handle, NULL);
 945 
 946   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 947   int table_size = handler-&gt;size_in_bytes();
 948   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray(table_size, CHECK_(JVMCIEnv::cache_full));
 949 
 950   if (table_size &gt; 0) {
 951     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));
 952   }
 953   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());
 954 
 955   return result;
 956 C2V_END
 957 
 958 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))
 959   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK);
 960   CompilerStatistics* stats = compiler-&gt;stats();
 961   stats-&gt;_standard.reset();
 962   stats-&gt;_osr.reset();
 963 C2V_END
 964 
 965 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))
 966   ResourceMark rm;
 967   HandleMark hm;
 968 
 969   if (installedCode == NULL) {
 970     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), "installedCode is null");
 971   }
 972 
 973   jlong codeBlob = InstalledCode::address(installedCode);
 974   if (codeBlob == 0L) {
 975     return NULL;
 976   }
 977 
 978   CodeBlob* cb = (CodeBlob*) (address) codeBlob;
 979   if (cb == NULL) {
 980     return NULL;
 981   }
 982 
 983   // We don't want the stringStream buffer to resize during disassembly as it
 984   // uses scoped resource memory. If a nested function called during disassembly uses
 985   // a ResourceMark and the buffer expands within the scope of the mark,
 986   // the buffer becomes garbage when that scope is exited. Experience shows that
 987   // the disassembled code is typically about 10x the code size so a fixed buffer
 988   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 989   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 990   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 991   stringStream st(buffer, bufferSize);
 992   if (cb-&gt;is_nmethod()) {
 993     nmethod* nm = (nmethod*) cb;
 994     if (!nm-&gt;is_alive()) {
 995       return NULL;
 996     }
 997   }
 998   Disassembler::decode(cb, &amp;st);
 999   if (st.size() &lt;= 0) {
1000     return NULL;
1001   }
1002 
1003   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);
1004   return JNIHandles::make_local(THREAD, result());
1005 C2V_END
1006 
1007 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))
1008   ResourceMark rm;
1009   HandleMark hm;
1010 
1011   methodHandle method = CompilerToVM::asMethod(jvmci_method);
1012   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);
1013   return JNIHandles::make_local(THREAD, element);
1014 C2V_END
1015 
1016 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))
1017   ResourceMark rm;
1018   HandleMark hm;
1019 
1020   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);
1021   if (nmethodValue == 0L) {
1022     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
1023   }
1024   nmethod* nm = (nmethod*) (address) nmethodValue;
1025   methodHandle mh = nm-&gt;method();
1026   Symbol* signature = mh-&gt;signature();
1027   JavaCallArguments jca(mh-&gt;size_of_parameters());
1028 
1029   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1030   JavaValue result(jap.get_ret_type());
1031   jca.set_alternative_target(nm);
1032   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1033 
1034   if (jap.get_ret_type() == T_VOID) {
1035     return NULL;
1036   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
1037     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
1038   } else {
1039     jvalue *value = (jvalue *) result.get_value_addr();
1040     // Narrow the value down if required (Important on big endian machines)
1041     switch (jap.get_ret_type()) {
1042       case T_BOOLEAN:
1043        value-&gt;z = (jboolean) value-&gt;i;
1044        break;
1045       case T_BYTE:
1046        value-&gt;b = (jbyte) value-&gt;i;
1047        break;
1048       case T_CHAR:
1049        value-&gt;c = (jchar) value-&gt;i;
1050        break;
1051       case T_SHORT:
1052        value-&gt;s = (jshort) value-&gt;i;
1053        break;
1054      }
1055     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);
1056     return JNIHandles::make_local(THREAD, o);
1057   }
1058 C2V_END
1059 
1060 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))
1061   Method* method = CompilerToVM::asMethod(jvmci_method);
1062   if (!method-&gt;has_linenumber_table()) {
1063     return NULL;
1064   }
1065   u2 num_entries = 0;
1066   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1067   while (streamForSize.read_pair()) {
1068     num_entries++;
1069   }
1070 
1071   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1072   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);
1073 
1074   int i = 0;
1075   jlong value;
1076   while (stream.read_pair()) {
1077     value = ((long) stream.bci());
1078     result-&gt;long_at_put(i, value);
1079     value = ((long) stream.line());
1080     result-&gt;long_at_put(i + 1, value);
1081     i += 2;
1082   }
1083 
1084   return (jlongArray) JNIHandles::make_local(THREAD, result);
1085 C2V_END
1086 
1087 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))
1088   ResourceMark rm;
1089   Method* method = CompilerToVM::asMethod(jvmci_method);
1090   if (!method-&gt;has_localvariable_table()) {
1091     return 0;
1092   }
1093   return (jlong) (address) method-&gt;localvariable_table_start();
1094 C2V_END
1095 
1096 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))
1097   ResourceMark rm;
1098   Method* method = CompilerToVM::asMethod(jvmci_method);
1099   return method-&gt;localvariable_table_length();
1100 C2V_END
1101 
1102 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))
1103   Method* method = CompilerToVM::asMethod(jvmci_method);
1104   MethodCounters* mcs = method-&gt;method_counters();
1105   if (mcs != NULL) {
1106     mcs-&gt;clear_counters();
1107   }
1108   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1109 
1110   CompiledMethod* code = method-&gt;code();
1111   if (code != NULL) {
1112     code-&gt;make_not_entrant();
1113   }
1114 
1115   MethodData* method_data = method-&gt;method_data();
1116   if (method_data == NULL) {
1117     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1118     method_data = MethodData::allocate(loader_data, method, CHECK);
1119     method-&gt;set_method_data(method_data);
1120   } else {
1121     method_data-&gt;initialize();
1122   }
1123 C2V_END
1124 
1125 
1126 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))
1127   Handle installed_code_handle = JNIHandles::resolve(installed_code);
1128   nmethod::invalidate_installed_code(installed_code_handle, CHECK);
1129 C2V_END
1130 
1131 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))
1132   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);
1133   JavaThread::collect_counters(arrayOop);
1134   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);
1135 C2V_END
1136 
1137 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))
1138   HandleMark hm;
1139   ResourceMark rm;
1140   if (JNIHandles::resolve(jvmci_method) == NULL) {
1141     THROW_0(vmSymbols::java_lang_NullPointerException());
1142   }
1143   Method* method = CompilerToVM::asMethod(jvmci_method);
1144   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1145     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Unexpected bci %d", entry_bci));
1146   }
1147   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1148 C2V_END
1149 
1150 
1151 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))
1152   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1153   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1154 C2V_END
1155 
1156 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1157   Method* method = CompilerToVM::asMethod(jvmci_method);
1158   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1159 C2V_END
1160 
1161 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))
1162   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);
1163   return JNIHandles::make_local(THREAD, sym());
1164 C2V_END
1165 
1166 bool matches(jobjectArray methods, Method* method) {
1167   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1168 
1169   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1170     oop resolved = methods_oop-&gt;obj_at(i);
1171     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {
1172       return true;
1173     }
1174   }
1175   return false;
1176 }
1177 
1178 C2V_VMENTRY(jobject, getNextStackFrame, (JNIEnv*, jobject compilerToVM, jobject hs_frame, jobjectArray methods, jint initialSkip))
1179   ResourceMark rm;
1180 
1181   if (!thread-&gt;has_last_Java_frame()) return NULL;
1182   Handle result = HotSpotStackFrameReference::klass()-&gt;allocate_instance(thread);
1183   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1184 
1185   StackFrameStream fst(thread);
1186   if (hs_frame != NULL) {
1187     // look for the correct stack frame if one is given
1188     intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1189     while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1190       fst.next();
1191     }
1192     if (fst.current()-&gt;sp() != stack_pointer) {
1193       THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1194     }
1195   }
1196 
1197   int frame_number = 0;
1198   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1199   if (hs_frame != NULL) {
1200     // look for the correct vframe within the stack frame if one is given
1201     int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1202     while (frame_number &lt; last_frame_number) {
1203       if (vf-&gt;is_top()) {
1204         THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1205       }
1206       vf = vf-&gt;sender();
1207       frame_number ++;
1208     }
1209     // move one frame forward
1210     if (vf-&gt;is_top()) {
1211       if (fst.is_done()) {
1212         return NULL;
1213       }
1214       fst.next();
1215       vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1216       frame_number = 0;
1217     } else {
1218       vf = vf-&gt;sender();
1219       frame_number++;
1220     }
1221   }
1222 
1223   while (true) {
1224     // look for the given method
1225     while (true) {
1226       StackValueCollection* locals = NULL;
1227       if (vf-&gt;is_compiled_frame()) {
1228         // compiled method frame
1229         compiledVFrame* cvf = compiledVFrame::cast(vf);
1230         if (methods == NULL || matches(methods, cvf-&gt;method())) {
1231           if (initialSkip &gt; 0) {
1232             initialSkip --;
1233           } else {
1234             ScopeDesc* scope = cvf-&gt;scope();
1235             // native wrapper do not have a scope
1236             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1237               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), scope-&gt;objects(), THREAD);
1238               Deoptimization::reassign_fields(fst.current(), fst.register_map(), scope-&gt;objects(), realloc_failures, false);
1239 
1240               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1241               typeArrayHandle array = oopFactory::new_boolArray(local_values-&gt;length(), thread);
1242               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1243                 ScopeValue* value = local_values-&gt;at(i);
1244                 if (value-&gt;is_object()) {
1245                   array-&gt;bool_at_put(i, true);
1246                 }
1247               }
1248               HotSpotStackFrameReference::set_localIsVirtual(result, array());
1249             } else {
1250               HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1251             }
1252 
1253             locals = cvf-&gt;locals();
1254             HotSpotStackFrameReference::set_bci(result, cvf-&gt;bci());
1255             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);
1256             HotSpotStackFrameReference::set_method(result, method);
1257           }
1258         }
1259       } else if (vf-&gt;is_interpreted_frame()) {
1260         // interpreted method frame
1261         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1262         if (methods == NULL || matches(methods, ivf-&gt;method())) {
1263           if (initialSkip &gt; 0) {
1264             initialSkip --;
1265           } else {
1266             locals = ivf-&gt;locals();
1267             HotSpotStackFrameReference::set_bci(result, ivf-&gt;bci());
1268             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);
1269             HotSpotStackFrameReference::set_method(result, method);
1270             HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1271           }
1272         }
1273       }
1274 
1275       // locals != NULL means that we found a matching frame and result is already partially initialized
1276       if (locals != NULL) {
1277         HotSpotStackFrameReference::set_compilerToVM(result, JNIHandles::resolve(compilerToVM));
1278         HotSpotStackFrameReference::set_stackPointer(result, (jlong) fst.current()-&gt;sp());
1279         HotSpotStackFrameReference::set_frameNumber(result, frame_number);
1280 
1281         // initialize the locals array
1282         objArrayHandle array = oopFactory::new_objectArray(locals-&gt;size(), thread);
1283         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1284           StackValue* var = locals-&gt;at(i);
1285           if (var-&gt;type() == T_OBJECT) {
1286             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1287           }
1288         }
1289         HotSpotStackFrameReference::set_locals(result, array());
1290 
1291         return JNIHandles::make_local(thread, result());
1292       }
1293 
1294       if (vf-&gt;is_top()) {
1295         break;
1296       }
1297       frame_number++;
1298       vf = vf-&gt;sender();
1299     } // end of vframe loop
1300 
1301     if (fst.is_done()) {
1302       break;
1303     }
1304     fst.next();
1305     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1306     frame_number = 0;
1307   } // end of frame loop
1308 
1309   // the end was reached without finding a matching method
1310   return NULL;
1311 C2V_END
1312 
1313 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1314   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1315   CallInfo callInfo;
1316   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1317   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1318   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1319 C2V_END
1320 
1321 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1322   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1323   KlassHandle holder = cp-&gt;klass_ref_at(index, CHECK);
1324   Symbol* name = cp-&gt;name_ref_at(index);
1325   if (MethodHandles::is_signature_polymorphic_name(holder(), name)) {
1326     CallInfo callInfo;
1327     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1328     ConstantPoolCacheEntry* cp_cache_entry = cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1329     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1330   }
1331 C2V_END
1332 
1333 C2V_VMENTRY(jobject, getSignaturePolymorphicHolders, (JNIEnv*, jobject))
1334   objArrayHandle holders = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
1335   Handle mh = java_lang_String::create_from_str("Ljava/lang/invoke/MethodHandle;", CHECK_NULL);
1336   Handle vh = java_lang_String::create_from_str("Ljava/lang/invoke/VarHandle;", CHECK_NULL);
1337   holders-&gt;obj_at_put(0, mh());
1338   holders-&gt;obj_at_put(1, vh());
1339   return JNIHandles::make_local(THREAD, holders());
1340 C2V_END
1341 
1342 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))
1343   //see compute_recording_non_safepoints in debugInfroRec.cpp
1344   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1345     return true;
1346   }
1347   return DebugNonSafepoints;
1348 C2V_END
1349 
1350 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1351 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))
1352   ResourceMark rm;
1353 
1354   if (hs_frame == NULL) {
1355     THROW_MSG(vmSymbols::java_lang_NullPointerException(), "stack frame is null")
1356   }
1357 
1358   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1359 
1360   // look for the given stack frame
1361   StackFrameStream fst(thread);
1362   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1363   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1364     fst.next();
1365   }
1366   if (fst.current()-&gt;sp() != stack_pointer) {
1367     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1368   }
1369 
1370   if (invalidate) {
1371     if (!fst.current()-&gt;is_compiled_frame()) {
1372       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1373     }
1374     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), "nmethod expected");
1375     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1376   }
1377   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1378   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1379   StackFrameStream fstAfterDeopt(thread);
1380   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1381     fstAfterDeopt.next();
1382   }
1383   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1384     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found after deopt")
1385   }
1386 
1387   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1388   if (!vf-&gt;is_compiled_frame()) {
1389     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1390   }
1391 
1392   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1393   while (true) {
1394     assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1395     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1396     if (vf-&gt;is_top()) {
1397       break;
1398     }
1399     vf = vf-&gt;sender();
1400   }
1401 
1402   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1403   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1404     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1405   }
1406 
1407   // Reallocate the non-escaping objects and restore their fields.
1408   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,"invalid scope");
1409   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1410 
1411   if (objects == NULL) {
1412     // no objects to materialize
1413     return;
1414   }
1415 
1416   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, THREAD);
1417   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1418 
1419   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1420     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1421 
1422     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1423     StackValueCollection* locals = cvf-&gt;locals();
1424 
1425     if (locals != NULL) {
1426       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1427         StackValue* var = locals-&gt;at(i2);
1428         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1429           jvalue val;
1430           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1431           cvf-&gt;update_local(T_OBJECT, i2, val);
1432         }
1433       }
1434     }
1435   }
1436 
1437   // all locals are materialized by now
1438   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);
1439 
1440   // update the locals array
1441   objArrayHandle array = HotSpotStackFrameReference::locals(hs_frame);
1442   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1443   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1444     StackValue* var = locals-&gt;at(i);
1445     if (var-&gt;type() == T_OBJECT) {
1446       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1447     }
1448   }
1449 C2V_END
1450 
1451 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))
1452   if (bytes == NULL) {
1453     THROW(vmSymbols::java_lang_NullPointerException());
1454   }
1455   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);
1456 
1457   // Check if offset and length are non negative.
1458   if (offset &lt; 0 || length &lt; 0) {
1459     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1460   }
1461   // Check if the range is valid.
1462   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {
1463     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1464   }
1465   while (length &gt; 0) {
1466     jbyte* start = array-&gt;byte_at_addr(offset);
1467     tty-&gt;write((char*) start, MIN2(length, O_BUFLEN));
1468     length -= O_BUFLEN;
1469     offset += O_BUFLEN;
1470   }
1471 C2V_END
1472 
1473 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))
1474   tty-&gt;flush();
1475 C2V_END
1476 
1477 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))
1478   ResourceMark rm;
1479   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1480   ProfileData* profile_data = mdo-&gt;data_at(position);
1481   if (mdo-&gt;is_valid(profile_data)) {
1482     return profile_data-&gt;size_in_bytes();
1483   }
1484   DataLayout* data    = mdo-&gt;extra_data_base();
1485   DataLayout* end   = mdo-&gt;extra_data_limit();
1486   for (;; data = mdo-&gt;next_extra(data)) {
1487     assert(data &lt; end, "moved past end of extra data");
1488     profile_data = data-&gt;data_in();
1489     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1490       return profile_data-&gt;size_in_bytes();
1491     }
1492   }
1493   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Invalid profile data position %d", position));
1494 C2V_END
1495 
1496 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))
1497   if (bytecode_frame_handle == NULL) {
1498     THROW_0(vmSymbols::java_lang_NullPointerException());
1499   }
1500 
1501   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);
1502   oop bytecode_frame = top_bytecode_frame;
1503   int size = 0;
1504   int callee_parameters = 0;
1505   int callee_locals = 0;
1506   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1507   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);
1508 
1509   while (bytecode_frame != NULL) {
1510     int locks = BytecodeFrame::numLocks(bytecode_frame);
1511     int temps = BytecodeFrame::numStack(bytecode_frame);
1512     bool is_top_frame = (bytecode_frame == top_bytecode_frame);
1513     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1514 
1515     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1516                                                                  temps + callee_parameters,
1517                                                                  extra_args,
1518                                                                  locks,
1519                                                                  callee_parameters,
1520                                                                  callee_locals,
1521                                                                  is_top_frame);
1522     size += frame_size;
1523 
1524     callee_parameters = method-&gt;size_of_parameters();
1525     callee_locals = method-&gt;max_locals();
1526     extra_args = 0;
1527     bytecode_frame = BytecodePosition::caller(bytecode_frame);
1528   }
1529   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1530 C2V_END
1531 
1532 C2V_VMENTRY(void, compileToBytecode, (JNIEnv*, jobject, jobject lambda_form_handle))
1533   Handle lambda_form = JNIHandles::resolve_non_null(lambda_form_handle);
1534   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1535     TempNewSymbol compileToBytecode = SymbolTable::new_symbol("compileToBytecode", CHECK);
1536     JavaValue result(T_VOID);
1537     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1538   } else {
1539     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1540                 err_msg("Unexpected type: %s", lambda_form-&gt;klass()-&gt;external_name()));
1541   }
1542 C2V_END
1543 
1544 #define CC (char*)  /*cast a literal from (const char*)*/
1545 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1546 
1547 #define STRING                "Ljava/lang/String;"
1548 #define OBJECT                "Ljava/lang/Object;"
1549 #define CLASS                 "Ljava/lang/Class;"
1550 #define EXECUTABLE            "Ljava/lang/reflect/Executable;"
1551 #define STACK_TRACE_ELEMENT   "Ljava/lang/StackTraceElement;"
1552 #define INSTALLED_CODE        "Ljdk/vm/ci/code/InstalledCode;"
1553 #define TARGET_DESCRIPTION    "Ljdk/vm/ci/code/TargetDescription;"
1554 #define BYTECODE_FRAME        "Ljdk/vm/ci/code/BytecodeFrame;"
1555 #define RESOLVED_METHOD       "Ljdk/vm/ci/meta/ResolvedJavaMethod;"
1556 #define HS_RESOLVED_METHOD    "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;"
1557 #define HS_RESOLVED_KLASS     "Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;"
1558 #define HS_CONSTANT_POOL      "Ljdk/vm/ci/hotspot/HotSpotConstantPool;"
1559 #define HS_COMPILED_CODE      "Ljdk/vm/ci/hotspot/HotSpotCompiledCode;"
1560 #define HS_CONFIG             "Ljdk/vm/ci/hotspot/HotSpotVMConfig;"
1561 #define HS_METADATA           "Ljdk/vm/ci/hotspot/HotSpotMetaData;"
1562 #define HS_STACK_FRAME_REF    "Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;"
1563 #define HS_SPECULATION_LOG    "Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;"
1564 #define METASPACE_METHOD_DATA "J"
1565 
1566 JNINativeMethod CompilerToVM::methods[] = {
1567   {CC "getBytecode",                                  CC "(" HS_RESOLVED_METHOD ")[B",                                                      FN_PTR(getBytecode)},
1568   {CC "getExceptionTableStart",                       CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getExceptionTableStart)},
1569   {CC "getExceptionTableLength",                      CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getExceptionTableLength)},
1570   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1571   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1572   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1573   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1574   {CC "doNotInlineOrCompile",                         CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(doNotInlineOrCompile)},
1575   {CC "canInlineMethod",                              CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(canInlineMethod)},
1576   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1577   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1578   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1579   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1580   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1581   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1582   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1583   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1584   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1585   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1586   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1587   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1588   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
1589   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[J)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
1590   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1591   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1592   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1593   {CC "getSignaturePolymorphicHolders",               CC "()[" STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
1594   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1595   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1596   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1597   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1598   {CC "asResolvedJavaMethod",                         CC "(" EXECUTABLE ")" HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
1599   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1600   {CC "getConstantPool",                              CC "(Ljava/lang/Object;)" HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},
1601   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1602   {CC "readConfiguration",                            CC "()[" OBJECT,                                                                      FN_PTR(readConfiguration)},
1603   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1604   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1605   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1606   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1607   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1608   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1609   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1610   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1611   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1612   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1613   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1614   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1615   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1616   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1617   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1618   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1619   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1620   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1621   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1622   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1623   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1624   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1625   {CC "compileToBytecode",                            CC "(" OBJECT ")V",                                                                   FN_PTR(compileToBytecode)},
1626 };
1627 
1628 int CompilerToVM::methods_count() {
1629   return sizeof(methods) / sizeof(JNINativeMethod);
1630 }
1631 
</pre></body></html>
