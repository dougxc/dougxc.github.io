<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodData.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.lang.String.format;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  30 
  31 import java.util.Arrays;
  32 
  33 import jdk.vm.ci.hotspot.HotSpotMethodDataAccessor.Tag;
  34 import jdk.vm.ci.meta.DeoptimizationReason;
  35 import jdk.vm.ci.meta.JavaMethodProfile;
  36 import jdk.vm.ci.meta.JavaMethodProfile.ProfiledMethod;
  37 import jdk.vm.ci.meta.JavaTypeProfile;
  38 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;
  39 import jdk.vm.ci.meta.ResolvedJavaMethod;
  40 import jdk.vm.ci.meta.ResolvedJavaType;
  41 import jdk.vm.ci.meta.TriState;
  42 import jdk.internal.misc.Unsafe;
  43 
  44 /**
  45  * Access to a HotSpot MethodData structure (defined in methodData.hpp).
  46  */
  47 public final class HotSpotMethodData {
  48 
  49     static final HotSpotVMConfig config = config();
  50     static final HotSpotMethodDataAccessor NO_DATA_NO_EXCEPTION_ACCESSOR = new NoMethodData(TriState.FALSE);
  51     static final HotSpotMethodDataAccessor NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR = new NoMethodData(TriState.UNKNOWN);
  52 
  53     static final int BIT_DATA_SIZE = cellIndexToOffset(0);
  54     static final int BIT_DATA_NULL_SEEN_FLAG = 1 &lt;&lt; config.bitDataNullSeenFlag;
  55 
  56     static final int BRANCH_DATA_SIZE = cellIndexToOffset(3);
  57     static final int NOT_TAKEN_COUNT_OFFSET = cellIndexToOffset(config.branchDataNotTakenOffset);
  58 
  59     static final int ARG_INFO_DATA_SIZE = cellIndexToOffset(1);
  60 
  61     static final int COUNTER_DATA_SIZE = cellIndexToOffset(1);
  62     static final int COUNTER_DATA_COUNT_OFFSET = cellIndexToOffset(config.methodDataCountOffset);
  63     static final int JUMP_DATA_SIZE = cellIndexToOffset(2);
  64     static final int TAKEN_COUNT_OFFSET = cellIndexToOffset(config.jumpDataTakenOffset);
  65     static final int TAKEN_DISPLACEMENT_OFFSET = cellIndexToOffset(config.jumpDataDisplacementOffset);
  66     static final int TYPE_DATA_ROW_SIZE = cellsToBytes(config.receiverTypeDataReceiverTypeRowCellCount);
  67 
  68     static final int NONPROFILED_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);
  69     static final int TYPE_DATA_FIRST_TYPE_OFFSET = cellIndexToOffset(config.receiverTypeDataReceiver0Offset);
  70     static final int TYPE_DATA_FIRST_TYPE_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataCount0Offset);
  71     static final int VIRTUAL_CALL_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * (config.typeProfileWidth + config.methodProfileWidth);
  72     static final int VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET = TYPE_DATA_FIRST_TYPE_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;
  73     static final int VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET = TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;
  74 
  75     static final int ARRAY_DATA_LENGTH_OFFSET = cellIndexToOffset(config.arrayDataArrayLenOffset);
  76     static final int ARRAY_DATA_START_OFFSET = cellIndexToOffset(config.arrayDataArrayStartOffset);
  77 
  78     static final int TYPE_CHECK_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;
  79 
  80     static final int RET_DATA_ROW_SIZE = cellsToBytes(3);
  81     static final int RET_DATA_SIZE = cellIndexToOffset(1) + RET_DATA_ROW_SIZE * config.bciProfileWidth;
  82 
  83     static final int MULTI_BRANCH_DATA_SIZE = cellIndexToOffset(1);
  84     static final int MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS = config.multiBranchDataPerCaseCellCount;
  85     static final int MULTI_BRANCH_DATA_ROW_SIZE = cellsToBytes(MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS);
  86     static final int MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(0);
  87     static final int MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(1);
  88 
  89     // sorted by tag
  90     // @formatter:off
  91     static final HotSpotMethodDataAccessor[] PROFILE_DATA_ACCESSORS = {
  92         null,
  93         new BitData(),
  94         new CounterData(),
  95         new JumpData(),
  96         new ReceiverTypeData(),
  97         new VirtualCallData(),
  98         new RetData(),
  99         new BranchData(),
 100         new MultiBranchData(),
 101         new ArgInfoData(),
 102         new UnknownProfileData(Tag.CallTypeData),
 103         new VirtualCallTypeData(),
 104         new UnknownProfileData(Tag.ParametersTypeData),
 105         new UnknownProfileData(Tag.SpeculativeTrapData),
 106     };
 107     // @formatter:on
 108 
 109     /**
 110      * Reference to the C++ MethodData object.
 111      */
 112     private final long metaspaceMethodData;
 113     @SuppressWarnings("unused") private final HotSpotResolvedJavaMethodImpl method;
 114 
 115     public HotSpotMethodData(long metaspaceMethodData, HotSpotResolvedJavaMethodImpl method) {
 116         this.metaspaceMethodData = metaspaceMethodData;
 117         this.method = method;
 118     }
 119 
 120     /**
 121      * @return value of the MethodData::_data_size field
 122      */
 123     private int normalDataSize() {
 124         return UNSAFE.getInt(metaspaceMethodData + config.methodDataDataSize);
 125     }
 126 
 127     /**
 128      * Returns the size of the extra data records. This method does the same calculation as
 129      * MethodData::extra_data_size().
 130      *
 131      * @return size of extra data records
 132      */
 133     private int extraDataSize() {
 134         final int extraDataBase = config.methodDataOopDataOffset + normalDataSize();
 135         final int extraDataLimit = UNSAFE.getInt(metaspaceMethodData + config.methodDataSize);
 136         return extraDataLimit - extraDataBase;
 137     }
 138 
 139     public boolean hasNormalData() {
 140         return normalDataSize() &gt; 0;
 141     }
 142 
 143     public boolean hasExtraData() {
 144         return extraDataSize() &gt; 0;
 145     }
 146 
 147     public int getExtraDataBeginOffset() {
 148         return normalDataSize();
 149     }
 150 
 151     public boolean isWithin(int position) {
 152         return position &gt;= 0 &amp;&amp; position &lt; normalDataSize() + extraDataSize();
 153     }
 154 
 155     public int getDeoptimizationCount(DeoptimizationReason reason) {
 156         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
 157         int reasonIndex = metaAccess.convertDeoptReason(reason);
 158         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + reasonIndex) &amp; 0xFF;
 159     }
 160 
 161     public int getOSRDeoptimizationCount(DeoptimizationReason reason) {
 162         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
 163         int reasonIndex = metaAccess.convertDeoptReason(reason);
 164         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + config.deoptReasonOSROffset + reasonIndex) &amp; 0xFF;
 165     }
 166 
 167     public HotSpotMethodDataAccessor getNormalData(int position) {
 168         if (position &gt;= normalDataSize()) {
 169             return null;
 170         }
 171 
 172         HotSpotMethodDataAccessor result = getData(position);
 173         final Tag tag = AbstractMethodData.readTag(this, position);
 174         assert result != null : "NO_DATA tag is not allowed " + tag;
 175         return result;
 176     }
 177 
 178     public HotSpotMethodDataAccessor getExtraData(int position) {
 179         if (position &gt;= normalDataSize() + extraDataSize()) {
 180             return null;
 181         }
 182         HotSpotMethodDataAccessor data = getData(position);
 183         if (data != null) {
 184             return data;
 185         }
 186         return data;
 187     }
 188 
 189     public static HotSpotMethodDataAccessor getNoDataAccessor(boolean exceptionPossiblyNotRecorded) {
 190         if (exceptionPossiblyNotRecorded) {
 191             return NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR;
 192         } else {
 193             return NO_DATA_NO_EXCEPTION_ACCESSOR;
 194         }
 195     }
 196 
 197     private HotSpotMethodDataAccessor getData(int position) {
 198         assert position &gt;= 0 : "out of bounds";
 199         final Tag tag = AbstractMethodData.readTag(this, position);
 200         HotSpotMethodDataAccessor accessor = PROFILE_DATA_ACCESSORS[tag.getValue()];
 201         assert accessor == null || accessor.getTag() == tag : "wrong data accessor " + accessor + " for tag " + tag;
 202         return accessor;
 203     }
 204 
 205     private int readUnsignedByte(int position, int offsetInBytes) {
 206         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 207         return UNSAFE.getByte(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFF;
 208     }
 209 
 210     private int readUnsignedShort(int position, int offsetInBytes) {
 211         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 212         return UNSAFE.getShort(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFF;
 213     }
 214 
 215     /**
 216      * Since the values are stored in cells (platform words) this method uses
 217      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
 218      */
 219     private long readUnsignedInt(int position, int offsetInBytes) {
 220         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 221         return UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFFFFFFL;
 222     }
 223 
 224     private int readUnsignedIntAsSignedInt(int position, int offsetInBytes) {
 225         long value = readUnsignedInt(position, offsetInBytes);
 226         return truncateLongToInt(value);
 227     }
 228 
 229     /**
 230      * Since the values are stored in cells (platform words) this method uses
 231      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
 232      */
 233     private int readInt(int position, int offsetInBytes) {
 234         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 235         return (int) UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes);
 236     }
 237 
 238     private HotSpotResolvedJavaMethod readMethod(int position, int offsetInBytes) {
 239         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 240         return compilerToVM().getResolvedJavaMethod(null, metaspaceMethodData + fullOffsetInBytes);
 241     }
 242 
 243     private HotSpotResolvedObjectTypeImpl readKlass(int position, int offsetInBytes) {
 244         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);
 245         return compilerToVM().getResolvedJavaType(null, metaspaceMethodData + fullOffsetInBytes, false);
 246     }
 247 
 248     private static int truncateLongToInt(long value) {
 249         return value &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) value;
 250     }
 251 
 252     private static int computeFullOffset(int position, int offsetInBytes) {
 253         return config.methodDataOopDataOffset + position + offsetInBytes;
 254     }
 255 
 256     private static int cellIndexToOffset(int cells) {
 257         return config.dataLayoutHeaderSize + cellsToBytes(cells);
 258     }
 259 
 260     private static int cellsToBytes(int cells) {
 261         return cells * config.dataLayoutCellSize;
 262     }
 263 
 264     /**
 265      * Returns whether profiling ran long enough that the profile information is mature. Other
 266      * informational data will still be valid even if the profile isn't mature.
 267      */
 268     public boolean isProfileMature() {
 269         return runtime().getCompilerToVM().isMature(metaspaceMethodData);
 270     }
 271 
 272     @Override
 273     public String toString() {
 274         StringBuilder sb = new StringBuilder();
 275         String nl = String.format("%n");
 276         String nlIndent = String.format("%n%38s", "");
 277         if (hasNormalData()) {
 278             int pos = 0;
 279             HotSpotMethodDataAccessor data;
 280             while ((data = getNormalData(pos)) != null) {
 281                 if (pos != 0) {
 282                     sb.append(nl);
 283                 }
 284                 int bci = data.getBCI(this, pos);
 285                 sb.append(String.format("%-6d bci: %-6d%-20s", pos, bci, data.getClass().getSimpleName()));
 286                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
 287                 pos = pos + data.getSize(this, pos);
 288             }
 289         }
 290 
 291         if (hasExtraData()) {
 292             int pos = getExtraDataBeginOffset();
 293             HotSpotMethodDataAccessor data;
 294             while ((data = getExtraData(pos)) != null) {
 295                 if (pos == getExtraDataBeginOffset()) {
 296                     sb.append(nl).append("--- Extra data:");
 297                 }
 298                 int bci = data.getBCI(this, pos);
 299                 sb.append(String.format("%n%-6d bci: %-6d%-20s", pos, bci, data.getClass().getSimpleName()));
 300                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
 301                 pos = pos + data.getSize(this, pos);
 302             }
 303 
 304         }
 305         return sb.toString();
 306     }
 307 
 308     /**
 309      * Corresponds to {@code exception_seen_flag}.
 310      */
 311     static final int EXCEPTIONS_MASK = 1 &lt;&lt; config.bitDataExceptionSeenFlag;
 312     static final int NO_DATA_SIZE = cellIndexToOffset(0);
 313 
 314     private abstract static class AbstractMethodData implements HotSpotMethodDataAccessor {
 315 
 316         private final Tag tag;
 317         protected final int staticSize;
 318 
 319         protected AbstractMethodData(Tag tag, int staticSize) {
 320             this.tag = tag;
 321             this.staticSize = staticSize;
 322         }
 323 
 324         public Tag getTag() {
 325             return tag;
 326         }
 327 
 328         public static Tag readTag(HotSpotMethodData data, int position) {
 329             final int tag = data.readUnsignedByte(position, config.dataLayoutTagOffset);
 330             return Tag.getEnum(tag);
 331         }
 332 
 333         @Override
 334         public int getBCI(HotSpotMethodData data, int position) {
 335             return data.readUnsignedShort(position, config.dataLayoutBCIOffset);
 336         }
 337 
 338         @Override
 339         public final int getSize(HotSpotMethodData data, int position) {
 340             int size = staticSize + getDynamicSize(data, position);
 341             // Sanity check against VM
 342             int vmSize = HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
 343             assert size == vmSize : size + " != " + vmSize;
 344             return size;
 345         }
 346 
 347         @Override
 348         public TriState getExceptionSeen(HotSpotMethodData data, int position) {
 349             return TriState.get((getFlags(data, position) &amp; EXCEPTIONS_MASK) != 0);
 350         }
 351 
 352         @Override
 353         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {
 354             return null;
 355         }
 356 
 357         @Override
 358         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {
 359             return null;
 360         }
 361 
 362         @Override
 363         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
 364             return -1;
 365         }
 366 
 367         @Override
 368         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {
 369             return null;
 370         }
 371 
 372         @Override
 373         public int getExecutionCount(HotSpotMethodData data, int position) {
 374             return -1;
 375         }
 376 
 377         @Override
 378         public TriState getNullSeen(HotSpotMethodData data, int position) {
 379             return TriState.UNKNOWN;
 380         }
 381 
 382         protected int getFlags(HotSpotMethodData data, int position) {
 383             return data.readUnsignedByte(position, config.dataLayoutFlagsOffset);
 384         }
 385 
 386         /**
 387          * @param data
 388          * @param position
 389          */
 390         protected int getDynamicSize(HotSpotMethodData data, int position) {
 391             return 0;
 392         }
 393 
 394         public abstract StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos);
 395     }
 396 
 397     static class NoMethodData extends AbstractMethodData {
 398 
 399         private final TriState exceptionSeen;
 400 
 401         protected NoMethodData(TriState exceptionSeen) {
 402             super(Tag.No, NO_DATA_SIZE);
 403             this.exceptionSeen = exceptionSeen;
 404         }
 405 
 406         @Override
 407         public int getBCI(HotSpotMethodData data, int position) {
 408             return -1;
 409         }
 410 
 411         @Override
 412         public TriState getExceptionSeen(HotSpotMethodData data, int position) {
 413             return exceptionSeen;
 414         }
 415 
 416         @Override
 417         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 418             return sb;
 419         }
 420     }
 421 
 422     static class BitData extends AbstractMethodData {
 423 
 424         private BitData() {
 425             super(Tag.BitData, BIT_DATA_SIZE);
 426         }
 427 
 428         protected BitData(Tag tag, int staticSize) {
 429             super(tag, staticSize);
 430         }
 431 
 432         @Override
 433         public TriState getNullSeen(HotSpotMethodData data, int position) {
 434             return TriState.get((getFlags(data, position) &amp; BIT_DATA_NULL_SEEN_FLAG) != 0);
 435         }
 436 
 437         @Override
 438         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 439             return sb.append(format("exception_seen(%s)", getExceptionSeen(data, pos)));
 440         }
 441     }
 442 
 443     static class CounterData extends BitData {
 444 
 445         CounterData() {
 446             super(Tag.CounterData, COUNTER_DATA_SIZE);
 447         }
 448 
 449         protected CounterData(Tag tag, int staticSize) {
 450             super(tag, staticSize);
 451         }
 452 
 453         @Override
 454         public int getExecutionCount(HotSpotMethodData data, int position) {
 455             return getCounterValue(data, position);
 456         }
 457 
 458         protected int getCounterValue(HotSpotMethodData data, int position) {
 459             return data.readUnsignedIntAsSignedInt(position, COUNTER_DATA_COUNT_OFFSET);
 460         }
 461 
 462         @Override
 463         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 464             return sb.append(format("count(%d) null_seen(%s) exception_seen(%s)", getCounterValue(data, pos), getNullSeen(data, pos), getExceptionSeen(data, pos)));
 465         }
 466     }
 467 
 468     static class JumpData extends AbstractMethodData {
 469 
 470         JumpData() {
 471             super(Tag.JumpData, JUMP_DATA_SIZE);
 472         }
 473 
 474         protected JumpData(Tag tag, int staticSize) {
 475             super(tag, staticSize);
 476         }
 477 
 478         @Override
 479         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
 480             return getExecutionCount(data, position) != 0 ? 1 : 0;
 481         }
 482 
 483         @Override
 484         public int getExecutionCount(HotSpotMethodData data, int position) {
 485             return data.readUnsignedIntAsSignedInt(position, TAKEN_COUNT_OFFSET);
 486         }
 487 
 488         public int getTakenDisplacement(HotSpotMethodData data, int position) {
 489             return data.readInt(position, TAKEN_DISPLACEMENT_OFFSET);
 490         }
 491 
 492         @Override
 493         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 494             return sb.append(format("taken(%d) displacement(%d)", getExecutionCount(data, pos), getTakenDisplacement(data, pos)));
 495         }
 496     }
 497 
 498     static class RawItemProfile&lt;T&gt; {
 499         final int entries;
 500         final T[] items;
 501         final long[] counts;
 502         final long totalCount;
 503 
 504         RawItemProfile(int entries, T[] items, long[] counts, long totalCount) {
 505             this.entries = entries;
 506             this.items = items;
 507             this.counts = counts;
 508             this.totalCount = totalCount;
 509         }
 510     }
 511 
 512     abstract static class AbstractTypeData extends CounterData {
 513 
 514         protected AbstractTypeData(Tag tag, int staticSize) {
 515             super(tag, staticSize);
 516         }
 517 
 518         @Override
 519         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {
 520             return createTypeProfile(getNullSeen(data, position), getRawTypeProfile(data, position));
 521         }
 522 
 523         private RawItemProfile&lt;ResolvedJavaType&gt; getRawTypeProfile(HotSpotMethodData data, int position) {
 524             int typeProfileWidth = config.typeProfileWidth;
 525 
 526             ResolvedJavaType[] types = new ResolvedJavaType[typeProfileWidth];
 527             long[] counts = new long[typeProfileWidth];
 528             long totalCount = 0;
 529             int entries = 0;
 530 
 531             outer: for (int i = 0; i &lt; typeProfileWidth; i++) {
 532                 HotSpotResolvedObjectTypeImpl receiverKlass = data.readKlass(position, getTypeOffset(i));
 533                 if (receiverKlass != null) {
 534                     HotSpotResolvedObjectTypeImpl klass = receiverKlass;
 535                     long count = data.readUnsignedInt(position, getTypeCountOffset(i));
 536                     /*
 537                      * Because of races in the profile collection machinery it's possible for a
 538                      * class to appear multiple times so merge them to make the profile look
 539                      * rational.
 540                      */
 541                     for (int j = 0; j &lt; entries; j++) {
 542                         if (types[j].equals(klass)) {
 543                             totalCount += count;
 544                             counts[j] += count;
 545                             continue outer;
 546                         }
 547                     }
 548                     types[entries] = klass;
 549                     totalCount += count;
 550                     counts[entries] = count;
 551                     entries++;
 552                 }
 553             }
 554 
 555             totalCount += getTypesNotRecordedExecutionCount(data, position);
 556             return new RawItemProfile&lt;&gt;(entries, types, counts, totalCount);
 557         }
 558 
 559         protected abstract long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position);
 560 
 561         private static JavaTypeProfile createTypeProfile(TriState nullSeen, RawItemProfile&lt;ResolvedJavaType&gt; profile) {
 562             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
 563                 return null;
 564             }
 565 
 566             ProfiledType[] ptypes = new ProfiledType[profile.entries];
 567             double totalProbability = 0.0;
 568             for (int i = 0; i &lt; profile.entries; i++) {
 569                 double p = profile.counts[i];
 570                 p = p / profile.totalCount;
 571                 totalProbability += p;
 572                 ptypes[i] = new ProfiledType(profile.items[i], p);
 573             }
 574 
 575             Arrays.sort(ptypes);
 576 
 577             double notRecordedTypeProbability = profile.entries &lt; config.typeProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
 578             assert notRecordedTypeProbability == 0 || profile.entries == config.typeProfileWidth;
 579             return new JavaTypeProfile(nullSeen, notRecordedTypeProbability, ptypes);
 580         }
 581 
 582         private static int getTypeOffset(int row) {
 583             return TYPE_DATA_FIRST_TYPE_OFFSET + row * TYPE_DATA_ROW_SIZE;
 584         }
 585 
 586         protected static int getTypeCountOffset(int row) {
 587             return TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;
 588         }
 589 
 590         @Override
 591         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 592             RawItemProfile&lt;ResolvedJavaType&gt; profile = getRawTypeProfile(data, pos);
 593             TriState nullSeen = getNullSeen(data, pos);
 594             TriState exceptionSeen = getExceptionSeen(data, pos);
 595             sb.append(format("count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)", getCounterValue(data, pos), nullSeen, exceptionSeen,
 596                             getTypesNotRecordedExecutionCount(data, pos), profile.entries));
 597             for (int i = 0; i &lt; profile.entries; i++) {
 598                 long count = profile.counts[i];
 599                 sb.append(format("%n  %s (%d, %4.2f)", profile.items[i].toJavaName(), count, (double) count / profile.totalCount));
 600             }
 601             return sb;
 602         }
 603     }
 604 
 605     static class ReceiverTypeData extends AbstractTypeData {
 606 
 607         ReceiverTypeData() {
 608             super(Tag.ReceiverTypeData, TYPE_CHECK_DATA_SIZE);
 609         }
 610 
 611         protected ReceiverTypeData(Tag tag, int staticSize) {
 612             super(tag, staticSize);
 613         }
 614 
 615         @Override
 616         public int getExecutionCount(HotSpotMethodData data, int position) {
 617             return -1;
 618         }
 619 
 620         @Override
 621         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 622             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);
 623         }
 624     }
 625 
 626     static class VirtualCallData extends ReceiverTypeData {
 627 
 628         VirtualCallData() {
 629             super(Tag.VirtualCallData, VIRTUAL_CALL_DATA_SIZE);
 630         }
 631 
 632         protected VirtualCallData(Tag tag, int staticSize) {
 633             super(tag, staticSize);
 634         }
 635 
 636         @Override
 637         public int getExecutionCount(HotSpotMethodData data, int position) {
 638             final int typeProfileWidth = config.typeProfileWidth;
 639 
 640             long total = 0;
 641             for (int i = 0; i &lt; typeProfileWidth; i++) {
 642                 total += data.readUnsignedInt(position, getTypeCountOffset(i));
 643             }
 644 
 645             total += getCounterValue(data, position);
 646             return truncateLongToInt(total);
 647         }
 648 
 649         @Override
 650         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 651             return getCounterValue(data, position);
 652         }
 653 
 654         private static long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {
 655             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);
 656         }
 657 
 658         @Override
 659         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {
 660             return createMethodProfile(getRawMethodProfile(data, position));
 661         }
 662 
 663         private static RawItemProfile&lt;ResolvedJavaMethod&gt; getRawMethodProfile(HotSpotMethodData data, int position) {
 664             int profileWidth = config.methodProfileWidth;
 665 
 666             ResolvedJavaMethod[] methods = new ResolvedJavaMethod[profileWidth];
 667             long[] counts = new long[profileWidth];
 668             long totalCount = 0;
 669             int entries = 0;
 670 
 671             for (int i = 0; i &lt; profileWidth; i++) {
 672                 HotSpotResolvedJavaMethod method = data.readMethod(position, getMethodOffset(i));
 673                 if (method != null) {
 674                     methods[entries] = method;
 675                     long count = data.readUnsignedInt(position, getMethodCountOffset(i));
 676                     totalCount += count;
 677                     counts[entries] = count;
 678 
 679                     entries++;
 680                 }
 681             }
 682 
 683             totalCount += getMethodsNotRecordedExecutionCount(data, position);
 684             return new RawItemProfile&lt;&gt;(entries, methods, counts, totalCount);
 685         }
 686 
 687         private static JavaMethodProfile createMethodProfile(RawItemProfile&lt;ResolvedJavaMethod&gt; profile) {
 688             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
 689                 return null;
 690             }
 691 
 692             ProfiledMethod[] pmethods = new ProfiledMethod[profile.entries];
 693             double totalProbability = 0.0;
 694             for (int i = 0; i &lt; profile.entries; i++) {
 695                 double p = profile.counts[i];
 696                 p = p / profile.totalCount;
 697                 totalProbability += p;
 698                 pmethods[i] = new ProfiledMethod(profile.items[i], p);
 699             }
 700 
 701             Arrays.sort(pmethods);
 702 
 703             double notRecordedMethodProbability = profile.entries &lt; config.methodProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
 704             assert notRecordedMethodProbability == 0 || profile.entries == config.methodProfileWidth;
 705             return new JavaMethodProfile(notRecordedMethodProbability, pmethods);
 706         }
 707 
 708         private static int getMethodOffset(int row) {
 709             return VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET + row * TYPE_DATA_ROW_SIZE;
 710         }
 711 
 712         private static int getMethodCountOffset(int row) {
 713             return VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;
 714         }
 715 
 716         @Override
 717         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 718             RawItemProfile&lt;ResolvedJavaMethod&gt; profile = getRawMethodProfile(data, pos);
 719             super.appendTo(sb.append(format("exception_seen(%s) ", getExceptionSeen(data, pos))), data, pos).append(format("%nmethod_entries(%d)", profile.entries));
 720             for (int i = 0; i &lt; profile.entries; i++) {
 721                 long count = profile.counts[i];
 722                 sb.append(format("%n  %s (%d, %4.2f)", profile.items[i].format("%H.%n(%p)"), count, (double) count / profile.totalCount));
 723             }
 724             return sb;
 725         }
 726     }
 727 
 728     static class VirtualCallTypeData extends VirtualCallData {
 729 
 730         VirtualCallTypeData() {
 731             super(Tag.VirtualCallTypeData, 0);
 732         }
 733 
 734         @Override
 735         protected int getDynamicSize(HotSpotMethodData data, int position) {
 736             assert staticSize == 0;
 737             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
 738         }
 739     }
 740 
 741     static class RetData extends CounterData {
 742 
 743         RetData() {
 744             super(Tag.RetData, RET_DATA_SIZE);
 745         }
 746     }
 747 
 748     static class BranchData extends JumpData {
 749 
 750         BranchData() {
 751             super(Tag.BranchData, BRANCH_DATA_SIZE);
 752         }
 753 
 754         @Override
 755         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
 756             long takenCount = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET);
 757             long notTakenCount = data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);
 758             long total = takenCount + notTakenCount;
 759 
 760             return total &lt;= 0 ? -1 : takenCount / (double) total;
 761         }
 762 
 763         @Override
 764         public int getExecutionCount(HotSpotMethodData data, int position) {
 765             long count = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET) + data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);
 766             return truncateLongToInt(count);
 767         }
 768 
 769         @Override
 770         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 771             long taken = data.readUnsignedInt(pos, TAKEN_COUNT_OFFSET);
 772             long notTaken = data.readUnsignedInt(pos, NOT_TAKEN_COUNT_OFFSET);
 773             double takenProbability = getBranchTakenProbability(data, pos);
 774             return sb.append(format("taken(%d, %4.2f) not_taken(%d, %4.2f) displacement(%d)", taken, takenProbability, notTaken, 1.0D - takenProbability, getTakenDisplacement(data, pos)));
 775         }
 776     }
 777 
 778     static class ArrayData extends AbstractMethodData {
 779 
 780         ArrayData(Tag tag, int staticSize) {
 781             super(tag, staticSize);
 782         }
 783 
 784         @Override
 785         protected int getDynamicSize(HotSpotMethodData data, int position) {
 786             return cellsToBytes(getLength(data, position));
 787         }
 788 
 789         protected static int getLength(HotSpotMethodData data, int position) {
 790             return data.readInt(position, ARRAY_DATA_LENGTH_OFFSET);
 791         }
 792 
 793         @Override
 794         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 795             return sb.append(format("length(%d)", getLength(data, pos)));
 796         }
 797     }
 798 
 799     static class MultiBranchData extends ArrayData {
 800 
 801         MultiBranchData() {
 802             super(Tag.MultiBranchData, MULTI_BRANCH_DATA_SIZE);
 803         }
 804 
 805         @Override
 806         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {
 807             int arrayLength = getLength(data, position);
 808             assert arrayLength &gt; 0 : "switch must have at least the default case";
 809             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : "array must have full rows";
 810 
 811             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 812             long totalCount = 0;
 813             double[] result = new double[length];
 814 
 815             // default case is first in HotSpot but last for the compiler
 816             long count = readCount(data, position, 0);
 817             totalCount += count;
 818             result[length - 1] = count;
 819 
 820             for (int i = 1; i &lt; length; i++) {
 821                 count = readCount(data, position, i);
 822                 totalCount += count;
 823                 result[i - 1] = count;
 824             }
 825 
 826             if (totalCount &lt;= 0) {
 827                 return null;
 828             } else {
 829                 for (int i = 0; i &lt; length; i++) {
 830                     result[i] = result[i] / totalCount;
 831                 }
 832                 return result;
 833             }
 834         }
 835 
 836         private static long readCount(HotSpotMethodData data, int position, int i) {
 837             int offset;
 838             long count;
 839             offset = getCountOffset(i);
 840             count = data.readUnsignedInt(position, offset);
 841             return count;
 842         }
 843 
 844         @Override
 845         public int getExecutionCount(HotSpotMethodData data, int position) {
 846             int arrayLength = getLength(data, position);
 847             assert arrayLength &gt; 0 : "switch must have at least the default case";
 848             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : "array must have full rows";
 849 
 850             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 851             long totalCount = 0;
 852             for (int i = 0; i &lt; length; i++) {
 853                 int offset = getCountOffset(i);
 854                 totalCount += data.readUnsignedInt(position, offset);
 855             }
 856 
 857             return truncateLongToInt(totalCount);
 858         }
 859 
 860         private static int getCountOffset(int index) {
 861             return MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;
 862         }
 863 
 864         private static int getDisplacementOffset(int index) {
 865             return MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;
 866         }
 867 
 868         @Override
 869         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 870             int entries = getLength(data, pos) / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;
 871             sb.append(format("entries(%d)", entries));
 872             for (int i = 0; i &lt; entries; i++) {
 873                 sb.append(format("%n  %d: count(%d) displacement(%d)", i, data.readUnsignedInt(pos, getCountOffset(i)), data.readUnsignedInt(pos, getDisplacementOffset(i))));
 874             }
 875             return sb;
 876         }
 877     }
 878 
 879     static class ArgInfoData extends ArrayData {
 880 
 881         ArgInfoData() {
 882             super(Tag.ArgInfoData, ARG_INFO_DATA_SIZE);
 883         }
 884     }
 885 
 886     static class UnknownProfileData extends AbstractMethodData {
 887         UnknownProfileData(Tag tag) {
 888             super(tag, 0);
 889         }
 890 
 891         @Override
 892         protected int getDynamicSize(HotSpotMethodData data, int position) {
 893             assert staticSize == 0;
 894             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
 895         }
 896 
 897         @Override
 898         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
 899             // TODO Auto-generated method stub
 900             return null;
 901         }
 902     }
 903 
 904     public void setCompiledIRSize(int size) {
 905         UNSAFE.putInt(metaspaceMethodData + config.methodDataIRSizeOffset, size);
 906     }
 907 
 908     public int getCompiledIRSize() {
 909         return UNSAFE.getInt(metaspaceMethodData + config.methodDataIRSizeOffset);
 910     }
 911 }
</pre></body></html>
