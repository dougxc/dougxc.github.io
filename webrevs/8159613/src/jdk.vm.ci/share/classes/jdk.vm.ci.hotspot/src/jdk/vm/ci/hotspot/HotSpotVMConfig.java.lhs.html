<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
<a name="1" id="anc1"></a>


  26 
  27 /**
  28  * Used to access native configuration details.
  29  *
  30  * All non-static, public fields in this class are so that they can be compiled as constants.
  31  */
  32 class HotSpotVMConfig extends HotSpotVMConfigAccess {
  33 
  34     /**
  35      * Gets the configuration associated with the singleton {@link HotSpotJVMCIRuntime}.
  36      */
  37     static HotSpotVMConfig config() {
  38         return runtime().getConfig();
  39     }
  40 
  41     private final String osArch = getHostArchitectureName();
  42 
  43     HotSpotVMConfig(HotSpotVMConfigStore store) {
  44         super(store);
  45     }
  46 
  47     /**
  48      * Gets the host architecture name for the purpose of finding the corresponding
  49      * {@linkplain HotSpotJVMCIBackendFactory backend}.
  50      */
  51     String getHostArchitectureName() {
  52         String arch = System.getProperty("os.arch");
<a name="2" id="anc2"></a><span class="changed">  53         switch (arch) {</span>
<span class="changed">  54             case "x86_64":</span>
  55                 arch = "amd64";
<a name="3" id="anc3"></a><span class="changed">  56                 break;</span>
<span class="changed">  57             case "sparcv9":</span>
  58                 arch = "sparc";
<a name="4" id="anc4"></a><span class="removed">  59                 break;</span>
  60         }
  61         return arch;
  62     }
  63 
  64     final boolean useDeferredInitBarriers = getFlag("ReduceInitialCardMarks", Boolean.class);
  65 
  66     final boolean useCompressedOops = getFlag("UseCompressedOops", Boolean.class);
  67 
  68     final int prototypeMarkWordOffset = getFieldOffset("Klass::_prototype_header", Integer.class, "markOop");
  69     final int subklassOffset = getFieldOffset("Klass::_subklass", Integer.class, "Klass*");
  70     final int nextSiblingOffset = getFieldOffset("Klass::_next_sibling", Integer.class, "Klass*");
  71     final int superCheckOffsetOffset = getFieldOffset("Klass::_super_check_offset", Integer.class, "juint");
  72     final int secondarySuperCacheOffset = getFieldOffset("Klass::_secondary_super_cache", Integer.class, "Klass*");
  73 
  74     /**
  75      * The offset of the _java_mirror field (of type {@link Class}) in a Klass.
  76      */
  77     final int classMirrorOffset = getFieldOffset("Klass::_java_mirror", Integer.class, "oop");
  78 
  79     final int klassAccessFlagsOffset = getFieldOffset("Klass::_access_flags", Integer.class, "AccessFlags");
  80     final int klassLayoutHelperOffset = getFieldOffset("Klass::_layout_helper", Integer.class, "jint");
  81 
  82     final int klassLayoutHelperNeutralValue = getConstant("Klass::_lh_neutral_value", Integer.class);
  83     final int klassLayoutHelperInstanceSlowPathBit = getConstant("Klass::_lh_instance_slow_path_bit", Integer.class);
  84 
  85     final int vtableEntrySize = getTypeSize("vtableEntry");
  86     final int vtableEntryMethodOffset = getFieldOffset("vtableEntry::_method", Integer.class, "Method*");
  87 
  88     final int instanceKlassSourceFileNameIndexOffset = getFieldOffset("InstanceKlass::_source_file_name_index", Integer.class, "u2");
  89     final int instanceKlassInitStateOffset = getFieldOffset("InstanceKlass::_init_state", Integer.class, "u1");
  90     final int instanceKlassConstantsOffset = getFieldOffset("InstanceKlass::_constants", Integer.class, "ConstantPool*");
  91     final int instanceKlassFieldsOffset = getFieldOffset("InstanceKlass::_fields", Integer.class, "Array&lt;u2&gt;*");
  92     final int klassVtableStartOffset = getFieldValue("CompilerToVM::Data::Klass_vtable_start_offset", Integer.class, "int");
  93     final int klassVtableLengthOffset = getFieldValue("CompilerToVM::Data::Klass_vtable_length_offset", Integer.class, "int");
  94 
  95     final int instanceKlassStateLinked = getConstant("InstanceKlass::linked", Integer.class);
  96     final int instanceKlassStateFullyInitialized = getConstant("InstanceKlass::fully_initialized", Integer.class);
  97 
  98     final int arrayU1LengthOffset = getFieldOffset("Array&lt;int&gt;::_length", Integer.class, "int");
  99     final int arrayU1DataOffset = getFieldOffset("Array&lt;u1&gt;::_data", Integer.class);
 100     final int arrayU2DataOffset = getFieldOffset("Array&lt;u2&gt;::_data", Integer.class);
 101 
 102     final int fieldInfoAccessFlagsOffset = getConstant("FieldInfo::access_flags_offset", Integer.class);
 103     final int fieldInfoNameIndexOffset = getConstant("FieldInfo::name_index_offset", Integer.class);
 104     final int fieldInfoSignatureIndexOffset = getConstant("FieldInfo::signature_index_offset", Integer.class);
 105     final int fieldInfoLowPackedOffset = getConstant("FieldInfo::low_packed_offset", Integer.class);
 106     final int fieldInfoHighPackedOffset = getConstant("FieldInfo::high_packed_offset", Integer.class);
 107     final int fieldInfoFieldSlots = getConstant("FieldInfo::field_slots", Integer.class);
 108 
 109     final int fieldInfoTagSize = getConstant("FIELDINFO_TAG_SIZE", Integer.class);
 110 
 111     final int jvmAccHasFinalizer = getConstant("JVM_ACC_HAS_FINALIZER", Integer.class);
 112     final int jvmAccFieldInternal = getConstant("JVM_ACC_FIELD_INTERNAL", Integer.class);
 113     final int jvmAccFieldStable = getConstant("JVM_ACC_FIELD_STABLE", Integer.class);
 114     final int jvmAccFieldHasGenericSignature = getConstant("JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE", Integer.class);
 115     final int jvmAccIsCloneableFast = getConstant("JVM_ACC_IS_CLONEABLE_FAST", Integer.class);
 116 
 117     // Modifier.SYNTHETIC is not public so we get it via vmStructs.
 118     final int jvmAccSynthetic = getConstant("JVM_ACC_SYNTHETIC", Integer.class);
 119 
 120     // This is only valid on AMD64.
 121     final int runtimeCallStackSize = getConstant("frame::arg_reg_save_area_bytes", Integer.class, osArch.equals("amd64") ? null : 0);
 122 
 123     private final int markWordNoHashInPlace = getConstant("markOopDesc::no_hash_in_place", Integer.class);
 124     private final int markWordNoLockInPlace = getConstant("markOopDesc::no_lock_in_place", Integer.class);
 125 
 126     /**
 127      * See {@code markOopDesc::prototype()}.
 128      */
 129     long arrayPrototypeMarkWord() {
 130         return markWordNoHashInPlace | markWordNoLockInPlace;
 131     }
 132 
 133     final int methodAccessFlagsOffset = getFieldOffset("Method::_access_flags", Integer.class, "AccessFlags");
 134     final int methodConstMethodOffset = getFieldOffset("Method::_constMethod", Integer.class, "ConstMethod*");
 135     final int methodIntrinsicIdOffset = getFieldOffset("Method::_intrinsic_id", Integer.class, "u2");
 136     final int methodFlagsOffset = getFieldOffset("Method::_flags", Integer.class, "u2");
 137     final int methodVtableIndexOffset = getFieldOffset("Method::_vtable_index", Integer.class, "int");
 138 
 139     final int methodDataOffset = getFieldOffset("Method::_method_data", Integer.class, "MethodData*");
 140     final int methodCodeOffset = getFieldOffset("Method::_code", Integer.class, "CompiledMethod*");
 141 
 142     final int methodFlagsCallerSensitive = getConstant("Method::_caller_sensitive", Integer.class);
 143     final int methodFlagsForceInline = getConstant("Method::_force_inline", Integer.class);
 144     final int methodFlagsDontInline = getConstant("Method::_dont_inline", Integer.class);
 145     final int methodFlagsReservedStackAccess = getConstant("Method::_reserved_stack_access", Integer.class);
 146     final int nonvirtualVtableIndex = getConstant("Method::nonvirtual_vtable_index", Integer.class);
 147     final int invalidVtableIndex = getConstant("Method::invalid_vtable_index", Integer.class);
 148 
 149     final int methodDataSize = getFieldOffset("MethodData::_size", Integer.class, "int");
 150     final int methodDataDataSize = getFieldOffset("MethodData::_data_size", Integer.class, "int");
 151     final int methodDataOopDataOffset = getFieldOffset("MethodData::_data[0]", Integer.class, "intptr_t");
 152     final int methodDataOopTrapHistoryOffset = getFieldOffset("MethodData::_trap_hist._array[0]", Integer.class, "u1");
 153     final int methodDataIRSizeOffset = getFieldOffset("MethodData::_jvmci_ir_size", Integer.class, "int");
 154 
 155     final int nmethodCompLevelOffset = getFieldOffset("nmethod::_comp_level", Integer.class, "int");
 156 
 157     final int compilationLevelNone = getConstant("CompLevel_none", Integer.class);
 158     final int compilationLevelSimple = getConstant("CompLevel_simple", Integer.class);
 159     final int compilationLevelLimitedProfile = getConstant("CompLevel_limited_profile", Integer.class);
 160     final int compilationLevelFullProfile = getConstant("CompLevel_full_profile", Integer.class);
 161     final int compilationLevelFullOptimization = getConstant("CompLevel_full_optimization", Integer.class);
 162 
 163     final int compLevelAdjustmentNone = getConstant("JVMCIRuntime::none", Integer.class);
 164     final int compLevelAdjustmentByHolder = getConstant("JVMCIRuntime::by_holder", Integer.class);
 165     final int compLevelAdjustmentByFullSignature = getConstant("JVMCIRuntime::by_full_signature", Integer.class);
 166 
 167     final int invocationEntryBci = getConstant("InvocationEntryBci", Integer.class);
 168 
 169     final int extraStackEntries = getFieldValue("CompilerToVM::Data::Method_extra_stack_entries", Integer.class, "int");
 170 
 171     final int constMethodConstantsOffset = getFieldOffset("ConstMethod::_constants", Integer.class, "ConstantPool*");
 172     final int constMethodFlagsOffset = getFieldOffset("ConstMethod::_flags", Integer.class, "u2");
 173     final int constMethodCodeSizeOffset = getFieldOffset("ConstMethod::_code_size", Integer.class, "u2");
 174     final int constMethodNameIndexOffset = getFieldOffset("ConstMethod::_name_index", Integer.class, "u2");
 175     final int constMethodSignatureIndexOffset = getFieldOffset("ConstMethod::_signature_index", Integer.class, "u2");
 176     final int constMethodMaxStackOffset = getFieldOffset("ConstMethod::_max_stack", Integer.class, "u2");
 177     final int methodMaxLocalsOffset = getFieldOffset("ConstMethod::_max_locals", Integer.class, "u2");
 178 
 179     final int constMethodHasLineNumberTable = getConstant("ConstMethod::_has_linenumber_table", Integer.class);
 180     final int constMethodHasLocalVariableTable = getConstant("ConstMethod::_has_localvariable_table", Integer.class);
 181     final int constMethodHasExceptionTable = getConstant("ConstMethod::_has_exception_table", Integer.class);
 182 
 183     final int exceptionTableElementSize = getTypeSize("ExceptionTableElement");
 184     final int exceptionTableElementStartPcOffset = getFieldOffset("ExceptionTableElement::start_pc", Integer.class, "u2");
 185     final int exceptionTableElementEndPcOffset = getFieldOffset("ExceptionTableElement::end_pc", Integer.class, "u2");
 186     final int exceptionTableElementHandlerPcOffset = getFieldOffset("ExceptionTableElement::handler_pc", Integer.class, "u2");
 187     final int exceptionTableElementCatchTypeIndexOffset = getFieldOffset("ExceptionTableElement::catch_type_index", Integer.class, "u2");
 188 
 189     final int localVariableTableElementSize = getTypeSize("LocalVariableTableElement");
 190     final int localVariableTableElementStartBciOffset = getFieldOffset("LocalVariableTableElement::start_bci", Integer.class, "u2");
 191     final int localVariableTableElementLengthOffset = getFieldOffset("LocalVariableTableElement::length", Integer.class, "u2");
 192     final int localVariableTableElementNameCpIndexOffset = getFieldOffset("LocalVariableTableElement::name_cp_index", Integer.class, "u2");
 193     final int localVariableTableElementDescriptorCpIndexOffset = getFieldOffset("LocalVariableTableElement::descriptor_cp_index", Integer.class, "u2");
 194     final int localVariableTableElementSlotOffset = getFieldOffset("LocalVariableTableElement::slot", Integer.class, "u2");
 195 
 196     final int constantPoolSize = getTypeSize("ConstantPool");
 197     final int constantPoolTagsOffset = getFieldOffset("ConstantPool::_tags", Integer.class, "Array&lt;u1&gt;*");
 198     final int constantPoolHolderOffset = getFieldOffset("ConstantPool::_pool_holder", Integer.class, "InstanceKlass*");
 199     final int constantPoolLengthOffset = getFieldOffset("ConstantPool::_length", Integer.class, "int");
 200 
 201     final int constantPoolCpCacheIndexTag = getConstant("ConstantPool::CPCACHE_INDEX_TAG", Integer.class);
 202 
 203     final int jvmConstantUtf8 = getConstant("JVM_CONSTANT_Utf8", Integer.class);
 204     final int jvmConstantInteger = getConstant("JVM_CONSTANT_Integer", Integer.class);
 205     final int jvmConstantLong = getConstant("JVM_CONSTANT_Long", Integer.class);
 206     final int jvmConstantFloat = getConstant("JVM_CONSTANT_Float", Integer.class);
 207     final int jvmConstantDouble = getConstant("JVM_CONSTANT_Double", Integer.class);
 208     final int jvmConstantClass = getConstant("JVM_CONSTANT_Class", Integer.class);
 209     final int jvmConstantUnresolvedClass = getConstant("JVM_CONSTANT_UnresolvedClass", Integer.class);
 210     final int jvmConstantUnresolvedClassInError = getConstant("JVM_CONSTANT_UnresolvedClassInError", Integer.class);
 211     final int jvmConstantString = getConstant("JVM_CONSTANT_String", Integer.class);
 212     final int jvmConstantFieldref = getConstant("JVM_CONSTANT_Fieldref", Integer.class);
 213     final int jvmConstantMethodref = getConstant("JVM_CONSTANT_Methodref", Integer.class);
 214     final int jvmConstantInterfaceMethodref = getConstant("JVM_CONSTANT_InterfaceMethodref", Integer.class);
 215     final int jvmConstantNameAndType = getConstant("JVM_CONSTANT_NameAndType", Integer.class);
 216     final int jvmConstantMethodHandle = getConstant("JVM_CONSTANT_MethodHandle", Integer.class);
 217     final int jvmConstantMethodHandleInError = getConstant("JVM_CONSTANT_MethodHandleInError", Integer.class);
 218     final int jvmConstantMethodType = getConstant("JVM_CONSTANT_MethodType", Integer.class);
 219     final int jvmConstantMethodTypeInError = getConstant("JVM_CONSTANT_MethodTypeInError", Integer.class);
 220     final int jvmConstantInvokeDynamic = getConstant("JVM_CONSTANT_InvokeDynamic", Integer.class);
 221 
 222     final int jvmConstantExternalMax = getConstant("JVM_CONSTANT_ExternalMax", Integer.class);
 223     final int jvmConstantInternalMin = getConstant("JVM_CONSTANT_InternalMin", Integer.class);
 224     final int jvmConstantInternalMax = getConstant("JVM_CONSTANT_InternalMax", Integer.class);
 225 
 226     final int heapWordSize = getConstant("HeapWordSize", Integer.class);
 227 
 228     final int symbolPointerSize = getTypeSize("Symbol*");
 229 
 230     final long vmSymbolsSymbols = getFieldAddress("vmSymbols::_symbols[0]", "Symbol*");
 231     final int vmSymbolsFirstSID = getConstant("vmSymbols::FIRST_SID", Integer.class);
 232     final int vmSymbolsSIDLimit = getConstant("vmSymbols::SID_LIMIT", Integer.class);
 233 
<a name="5" id="anc5"></a>














 234     final int universeBaseVtableSize = getFieldValue("CompilerToVM::Data::Universe_base_vtable_size", Integer.class, "int");
 235 
 236     final int baseVtableLength() {
 237         return universeBaseVtableSize / vtableEntrySize;
 238     }
 239 
 240     final int klassOffset = getFieldValue("java_lang_Class::_klass_offset", Integer.class, "int");
 241 
 242     /**
 243      * The DataLayout header size is the same as the cell size.
 244      */
 245     final int dataLayoutHeaderSize = getConstant("DataLayout::cell_size", Integer.class);
 246     final int dataLayoutTagOffset = getFieldOffset("DataLayout::_header._struct._tag", Integer.class, "u1");
 247     final int dataLayoutFlagsOffset = getFieldOffset("DataLayout::_header._struct._flags", Integer.class, "u1");
 248     final int dataLayoutBCIOffset = getFieldOffset("DataLayout::_header._struct._bci", Integer.class, "u2");
 249     final int dataLayoutCellSize = getConstant("DataLayout::cell_size", Integer.class);
 250 
 251     final int dataLayoutNoTag = getConstant("DataLayout::no_tag", Integer.class);
 252     final int dataLayoutBitDataTag = getConstant("DataLayout::bit_data_tag", Integer.class);
 253     final int dataLayoutCounterDataTag = getConstant("DataLayout::counter_data_tag", Integer.class);
 254     final int dataLayoutJumpDataTag = getConstant("DataLayout::jump_data_tag", Integer.class);
 255     final int dataLayoutReceiverTypeDataTag = getConstant("DataLayout::receiver_type_data_tag", Integer.class);
 256     final int dataLayoutVirtualCallDataTag = getConstant("DataLayout::virtual_call_data_tag", Integer.class);
 257     final int dataLayoutRetDataTag = getConstant("DataLayout::ret_data_tag", Integer.class);
 258     final int dataLayoutBranchDataTag = getConstant("DataLayout::branch_data_tag", Integer.class);
 259     final int dataLayoutMultiBranchDataTag = getConstant("DataLayout::multi_branch_data_tag", Integer.class);
 260     final int dataLayoutArgInfoDataTag = getConstant("DataLayout::arg_info_data_tag", Integer.class);
 261     final int dataLayoutCallTypeDataTag = getConstant("DataLayout::call_type_data_tag", Integer.class);
 262     final int dataLayoutVirtualCallTypeDataTag = getConstant("DataLayout::virtual_call_type_data_tag", Integer.class);
 263     final int dataLayoutParametersTypeDataTag = getConstant("DataLayout::parameters_type_data_tag", Integer.class);
 264     final int dataLayoutSpeculativeTrapDataTag = getConstant("DataLayout::speculative_trap_data_tag", Integer.class);
 265 
 266     final int bciProfileWidth = getFlag("BciProfileWidth", Integer.class);
 267     final int typeProfileWidth = getFlag("TypeProfileWidth", Integer.class);
 268     final int methodProfileWidth = getFlag("MethodProfileWidth", Integer.class);
 269 
 270     final int deoptReasonNone = getConstant("Deoptimization::Reason_none", Integer.class);
 271     final int deoptReasonNullCheck = getConstant("Deoptimization::Reason_null_check", Integer.class);
 272     final int deoptReasonRangeCheck = getConstant("Deoptimization::Reason_range_check", Integer.class);
 273     final int deoptReasonClassCheck = getConstant("Deoptimization::Reason_class_check", Integer.class);
 274     final int deoptReasonArrayCheck = getConstant("Deoptimization::Reason_array_check", Integer.class);
 275     final int deoptReasonUnreached0 = getConstant("Deoptimization::Reason_unreached0", Integer.class);
 276     final int deoptReasonTypeCheckInlining = getConstant("Deoptimization::Reason_type_checked_inlining", Integer.class);
 277     final int deoptReasonOptimizedTypeCheck = getConstant("Deoptimization::Reason_optimized_type_check", Integer.class);
 278     final int deoptReasonNotCompiledExceptionHandler = getConstant("Deoptimization::Reason_not_compiled_exception_handler", Integer.class);
 279     final int deoptReasonUnresolved = getConstant("Deoptimization::Reason_unresolved", Integer.class);
 280     final int deoptReasonJsrMismatch = getConstant("Deoptimization::Reason_jsr_mismatch", Integer.class);
 281     final int deoptReasonDiv0Check = getConstant("Deoptimization::Reason_div0_check", Integer.class);
 282     final int deoptReasonConstraint = getConstant("Deoptimization::Reason_constraint", Integer.class);
 283     final int deoptReasonLoopLimitCheck = getConstant("Deoptimization::Reason_loop_limit_check", Integer.class);
 284     final int deoptReasonAliasing = getConstant("Deoptimization::Reason_aliasing", Integer.class);
 285     final int deoptReasonTransferToInterpreter = getConstant("Deoptimization::Reason_transfer_to_interpreter", Integer.class);
 286     final int deoptReasonOSROffset = getConstant("Deoptimization::Reason_LIMIT", Integer.class);
 287 
 288     final int deoptActionNone = getConstant("Deoptimization::Action_none", Integer.class);
 289     final int deoptActionMaybeRecompile = getConstant("Deoptimization::Action_maybe_recompile", Integer.class);
 290     final int deoptActionReinterpret = getConstant("Deoptimization::Action_reinterpret", Integer.class);
 291     final int deoptActionMakeNotEntrant = getConstant("Deoptimization::Action_make_not_entrant", Integer.class);
 292     final int deoptActionMakeNotCompilable = getConstant("Deoptimization::Action_make_not_compilable", Integer.class);
 293 
 294     final int deoptimizationActionBits = getConstant("Deoptimization::_action_bits", Integer.class);
 295     final int deoptimizationReasonBits = getConstant("Deoptimization::_reason_bits", Integer.class);
 296     final int deoptimizationDebugIdBits = getConstant("Deoptimization::_debug_id_bits", Integer.class);
 297     final int deoptimizationActionShift = getConstant("Deoptimization::_action_shift", Integer.class);
 298     final int deoptimizationReasonShift = getConstant("Deoptimization::_reason_shift", Integer.class);
 299     final int deoptimizationDebugIdShift = getConstant("Deoptimization::_debug_id_shift", Integer.class);
 300 
 301     final int vmIntrinsicInvokeBasic = getConstant("vmIntrinsics::_invokeBasic", Integer.class);
 302     final int vmIntrinsicLinkToVirtual = getConstant("vmIntrinsics::_linkToVirtual", Integer.class);
 303     final int vmIntrinsicLinkToStatic = getConstant("vmIntrinsics::_linkToStatic", Integer.class);
 304     final int vmIntrinsicLinkToSpecial = getConstant("vmIntrinsics::_linkToSpecial", Integer.class);
 305     final int vmIntrinsicLinkToInterface = getConstant("vmIntrinsics::_linkToInterface", Integer.class);
 306 
 307     final int codeInstallResultOk = getConstant("JVMCIEnv::ok", Integer.class);
 308     final int codeInstallResultDependenciesFailed = getConstant("JVMCIEnv::dependencies_failed", Integer.class);
 309     final int codeInstallResultDependenciesInvalid = getConstant("JVMCIEnv::dependencies_invalid", Integer.class);
 310     final int codeInstallResultCacheFull = getConstant("JVMCIEnv::cache_full", Integer.class);
 311     final int codeInstallResultCodeTooLarge = getConstant("JVMCIEnv::code_too_large", Integer.class);
 312 
 313     String getCodeInstallResultDescription(int codeInstallResult) {
 314         if (codeInstallResult == codeInstallResultOk) {
 315             return "ok";
 316         }
 317         if (codeInstallResult == codeInstallResultDependenciesFailed) {
 318             return "dependencies failed";
 319         }
 320         if (codeInstallResult == codeInstallResultDependenciesInvalid) {
 321             return "dependencies invalid";
 322         }
 323         if (codeInstallResult == codeInstallResultCacheFull) {
 324             return "code cache is full";
 325         }
 326         if (codeInstallResult == codeInstallResultCodeTooLarge) {
 327             return "code is too large";
 328         }
 329         assert false : codeInstallResult;
 330         return "unknown";
 331     }
 332 
 333     final int bitDataExceptionSeenFlag = getConstant("BitData::exception_seen_flag", Integer.class);
 334     final int bitDataNullSeenFlag = getConstant("BitData::null_seen_flag", Integer.class);
 335     final int methodDataCountOffset = getConstant("CounterData::count_off", Integer.class);
 336     final int jumpDataTakenOffset = getConstant("JumpData::taken_off_set", Integer.class);
 337     final int jumpDataDisplacementOffset = getConstant("JumpData::displacement_off_set", Integer.class);
 338     final int receiverTypeDataNonprofiledCountOffset = getConstant("ReceiverTypeData::nonprofiled_count_off_set", Integer.class);
 339     final int receiverTypeDataReceiverTypeRowCellCount = getConstant("ReceiverTypeData::receiver_type_row_cell_count", Integer.class);
 340     final int receiverTypeDataReceiver0Offset = getConstant("ReceiverTypeData::receiver0_offset", Integer.class);
 341     final int receiverTypeDataCount0Offset = getConstant("ReceiverTypeData::count0_offset", Integer.class);
 342     final int branchDataNotTakenOffset = getConstant("BranchData::not_taken_off_set", Integer.class);
 343     final int arrayDataArrayLenOffset = getConstant("ArrayData::array_len_off_set", Integer.class);
 344     final int arrayDataArrayStartOffset = getConstant("ArrayData::array_start_off_set", Integer.class);
 345     final int multiBranchDataPerCaseCellCount = getConstant("MultiBranchData::per_case_cell_count", Integer.class);
 346 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="6" type="hidden" /></form></body></html>
