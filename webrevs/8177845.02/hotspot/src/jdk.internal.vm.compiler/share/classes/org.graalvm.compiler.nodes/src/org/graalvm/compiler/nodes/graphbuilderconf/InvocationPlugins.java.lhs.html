<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.graalvm.compiler.nodes.graphbuilderconf;
  24 
  25 import static java.lang.String.format;
<a name="1" id="anc1"></a>
  26 
<a name="2" id="anc2"></a><span class="changed">  27 import java.lang.reflect.Executable;</span>
  28 import java.lang.reflect.Method;
  29 import java.lang.reflect.Modifier;
  30 import java.lang.reflect.Type;
  31 import java.util.ArrayList;
  32 import java.util.Arrays;
  33 import java.util.Collections;
  34 import java.util.HashMap;
<a name="3" id="anc3"></a><span class="removed">  35 import java.util.HashSet;</span>
  36 import java.util.List;
  37 import java.util.Map;
<a name="4" id="anc4"></a><span class="removed">  38 import java.util.Set;</span>
  39 
  40 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  41 import org.graalvm.compiler.api.replacements.MethodSubstitutionRegistry;
  42 import org.graalvm.compiler.bytecode.BytecodeProvider;
  43 import org.graalvm.compiler.debug.GraalError;
  44 import org.graalvm.compiler.graph.Node;
  45 import org.graalvm.compiler.graph.iterators.NodeIterable;
  46 import org.graalvm.compiler.nodes.ValueNode;
  47 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
  48 
<a name="5" id="anc5"></a><span class="removed">  49 import jdk.vm.ci.meta.MetaAccessProvider;</span>
  50 import jdk.vm.ci.meta.MetaUtil;
  51 import jdk.vm.ci.meta.ResolvedJavaMethod;
<a name="6" id="anc6"></a>

  52 
  53 /**
  54  * Manages a set of {@link InvocationPlugin}s.
<a name="7" id="anc7"></a>










  55  */
  56 public class InvocationPlugins {
  57 
  58     public static class InvocationPluginReceiver implements InvocationPlugin.Receiver {
  59         private final GraphBuilderContext parser;
  60         private ValueNode[] args;
  61         private ValueNode value;
  62 
  63         public InvocationPluginReceiver(GraphBuilderContext parser) {
  64             this.parser = parser;
  65         }
  66 
  67         @Override
  68         public ValueNode get(boolean performNullCheck) {
  69             assert args != null : "Cannot get the receiver of a static method";
  70             if (!performNullCheck) {
  71                 return args[0];
  72             }
  73             if (value == null) {
  74                 value = parser.nullCheckedValue(args[0]);
  75                 if (value != args[0]) {
  76                     args[0] = value;
  77                 }
  78             }
  79             return value;
  80         }
  81 
  82         @Override
  83         public boolean isConstant() {
  84             return args[0].isConstant();
  85         }
  86 
  87         public InvocationPluginReceiver init(ResolvedJavaMethod targetMethod, ValueNode[] newArgs) {
  88             if (!targetMethod.isStatic()) {
  89                 this.args = newArgs;
  90                 this.value = null;
  91                 return this;
  92             }
  93             return null;
  94         }
  95     }
  96 
  97     /**
  98      * A symbol that is lazily {@linkplain OptionalLazySymbol#resolve() resolved} to a {@link Type}.
  99      */
 100     static class OptionalLazySymbol implements Type {
 101         private static final Class&lt;?&gt; MASK_NULL = OptionalLazySymbol.class;
 102         private final String name;
 103         private Class&lt;?&gt; resolved;
 104 
 105         OptionalLazySymbol(String name) {
 106             this.name = name;
 107         }
 108 
 109         @Override
 110         public String getTypeName() {
 111             return name;
 112         }
 113 
 114         /**
 115          * Gets the resolved {@link Class} corresponding to this symbol or {@code null} if
 116          * resolution fails.
 117          */
 118         public Class&lt;?&gt; resolve() {
 119             if (resolved == null) {
 120                 Class&lt;?&gt; resolvedOrNull = resolveClass(name, true);
 121                 resolved = resolvedOrNull == null ? MASK_NULL : resolvedOrNull;
 122             }
 123             return resolved == MASK_NULL ? null : resolved;
 124         }
 125 
 126         @Override
 127         public String toString() {
 128             return name;
 129         }
 130     }
 131 
 132     /**
 133      * Utility for {@linkplain InvocationPlugins#register(InvocationPlugin, Class, String, Class...)
 134      * registration} of invocation plugins.
 135      */
 136     public static class Registration implements MethodSubstitutionRegistry {
 137 
 138         private final InvocationPlugins plugins;
 139         private final Type declaringType;
 140         private final BytecodeProvider methodSubstitutionBytecodeProvider;
 141         private boolean allowOverwrite;
 142 
 143         @Override
 144         public Class&lt;?&gt; getReceiverType() {
 145             return Receiver.class;
 146         }
 147 
 148         /**
 149          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 150          * given class.
 151          *
 152          * @param plugins where to register the plugins
 153          * @param declaringType the class declaring the methods for which plugins will be registered
 154          *            via this object
 155          */
 156         public Registration(InvocationPlugins plugins, Type declaringType) {
 157             this.plugins = plugins;
 158             this.declaringType = declaringType;
 159             this.methodSubstitutionBytecodeProvider = null;
 160         }
 161 
 162         /**
 163          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 164          * given class.
 165          *
 166          * @param plugins where to register the plugins
 167          * @param declaringType the class declaring the methods for which plugins will be registered
 168          *            via this object
 169          * @param methodSubstitutionBytecodeProvider provider used to get the bytecodes to parse for
 170          *            method substitutions
 171          */
 172         public Registration(InvocationPlugins plugins, Type declaringType, BytecodeProvider methodSubstitutionBytecodeProvider) {
 173             this.plugins = plugins;
 174             this.declaringType = declaringType;
 175             this.methodSubstitutionBytecodeProvider = methodSubstitutionBytecodeProvider;
 176         }
 177 
 178         /**
 179          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 180          * given class.
 181          *
 182          * @param plugins where to register the plugins
 183          * @param declaringClassName the name of the class class declaring the methods for which
 184          *            plugins will be registered via this object
 185          * @param methodSubstitutionBytecodeProvider provider used to get the bytecodes to parse for
 186          *            method substitutions
 187          */
 188         public Registration(InvocationPlugins plugins, String declaringClassName, BytecodeProvider methodSubstitutionBytecodeProvider) {
 189             this.plugins = plugins;
 190             this.declaringType = new OptionalLazySymbol(declaringClassName);
 191             this.methodSubstitutionBytecodeProvider = methodSubstitutionBytecodeProvider;
 192         }
 193 
 194         /**
 195          * Configures this registration to allow or disallow overwriting of invocation plugins.
 196          */
 197         public Registration setAllowOverwrite(boolean allowOverwrite) {
 198             this.allowOverwrite = allowOverwrite;
 199             return this;
 200         }
 201 
 202         /**
 203          * Registers a plugin for a method with no arguments.
 204          *
 205          * @param name the name of the method
 206          * @param plugin the plugin to be registered
 207          */
 208         public void register0(String name, InvocationPlugin plugin) {
 209             plugins.register(plugin, false, allowOverwrite, declaringType, name);
 210         }
 211 
 212         /**
 213          * Registers a plugin for a method with 1 argument.
 214          *
 215          * @param name the name of the method
 216          * @param plugin the plugin to be registered
 217          */
 218         public void register1(String name, Type arg, InvocationPlugin plugin) {
 219             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg);
 220         }
 221 
 222         /**
 223          * Registers a plugin for a method with 2 arguments.
 224          *
 225          * @param name the name of the method
 226          * @param plugin the plugin to be registered
 227          */
 228         public void register2(String name, Type arg1, Type arg2, InvocationPlugin plugin) {
 229             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2);
 230         }
 231 
 232         /**
 233          * Registers a plugin for a method with 3 arguments.
 234          *
 235          * @param name the name of the method
 236          * @param plugin the plugin to be registered
 237          */
 238         public void register3(String name, Type arg1, Type arg2, Type arg3, InvocationPlugin plugin) {
 239             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3);
 240         }
 241 
 242         /**
 243          * Registers a plugin for a method with 4 arguments.
 244          *
 245          * @param name the name of the method
 246          * @param plugin the plugin to be registered
 247          */
 248         public void register4(String name, Type arg1, Type arg2, Type arg3, Type arg4, InvocationPlugin plugin) {
 249             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4);
 250         }
 251 
 252         /**
 253          * Registers a plugin for a method with 5 arguments.
 254          *
 255          * @param name the name of the method
 256          * @param plugin the plugin to be registered
 257          */
 258         public void register5(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, InvocationPlugin plugin) {
 259             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5);
 260         }
 261 
 262         /**
<a name="8" id="anc8"></a>



















 263          * Registers a plugin for an optional method with no arguments.
 264          *
 265          * @param name the name of the method
 266          * @param plugin the plugin to be registered
 267          */
 268         public void registerOptional0(String name, InvocationPlugin plugin) {
 269             plugins.register(plugin, true, allowOverwrite, declaringType, name);
 270         }
 271 
 272         /**
 273          * Registers a plugin for an optional method with 1 argument.
 274          *
 275          * @param name the name of the method
 276          * @param plugin the plugin to be registered
 277          */
 278         public void registerOptional1(String name, Type arg, InvocationPlugin plugin) {
 279             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg);
 280         }
 281 
 282         /**
 283          * Registers a plugin for an optional method with 2 arguments.
 284          *
 285          * @param name the name of the method
 286          * @param plugin the plugin to be registered
 287          */
 288         public void registerOptional2(String name, Type arg1, Type arg2, InvocationPlugin plugin) {
 289             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg1, arg2);
 290         }
 291 
 292         /**
 293          * Registers a plugin for an optional method with 3 arguments.
 294          *
 295          * @param name the name of the method
 296          * @param plugin the plugin to be registered
 297          */
 298         public void registerOptional3(String name, Type arg1, Type arg2, Type arg3, InvocationPlugin plugin) {
 299             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg1, arg2, arg3);
 300         }
 301 
 302         /**
 303          * Registers a plugin for an optional method with 4 arguments.
 304          *
 305          * @param name the name of the method
 306          * @param plugin the plugin to be registered
 307          */
 308         public void registerOptional4(String name, Type arg1, Type arg2, Type arg3, Type arg4, InvocationPlugin plugin) {
 309             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4);
 310         }
 311 
 312         /**
 313          * Registers a plugin that implements a method based on the bytecode of a substitute method.
 314          *
 315          * @param substituteDeclaringClass the class declaring the substitute method
 316          * @param name the name of both the original and substitute method
 317          * @param argumentTypes the argument types of the method. Element 0 of this array must be
 318          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
 319          *            is non-static. Upon returning, element 0 will have been rewritten to
 320          *            {@code declaringClass}
 321          */
 322         @Override
 323         public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, Type... argumentTypes) {
 324             registerMethodSubstitution(substituteDeclaringClass, name, name, argumentTypes);
 325         }
 326 
 327         /**
 328          * Registers a plugin that implements a method based on the bytecode of a substitute method.
 329          *
 330          * @param substituteDeclaringClass the class declaring the substitute method
 331          * @param name the name of both the original method
 332          * @param substituteName the name of the substitute method
 333          * @param argumentTypes the argument types of the method. Element 0 of this array must be
 334          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
 335          *            is non-static. Upon returning, element 0 will have been rewritten to
 336          *            {@code declaringClass}
 337          */
 338         @Override
 339         public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type... argumentTypes) {
<a name="9" id="anc9"></a>




 340             assert methodSubstitutionBytecodeProvider != null : "Registration used for method substitutions requires a non-null methodSubstitutionBytecodeProvider";
 341             MethodSubstitutionPlugin plugin = new MethodSubstitutionPlugin(methodSubstitutionBytecodeProvider, substituteDeclaringClass, substituteName, argumentTypes);
<a name="10" id="anc10"></a><span class="changed"> 342             plugins.register(plugin, false, allowOverwrite, declaringType, name, argumentTypes);</span>
 343         }
<a name="11" id="anc11"></a>
 344     }
 345 
 346     /**
<a name="12" id="anc12"></a><span class="changed"> 347      * Key for a {@linkplain ClassPlugins#entries resolved} plugin registration. Due to the</span>
<span class="changed"> 348      * possibility of class redefinition, we cannot directly use {@link ResolvedJavaMethod}s as</span>
<span class="changed"> 349      * keys. A {@link ResolvedJavaMethod} implementation might implement {@code equals()} and</span>
<span class="changed"> 350      * {@code hashCode()} based on internal representation subject to change by class redefinition.</span>
 351      */
<a name="13" id="anc13"></a><span class="changed"> 352     static final class ResolvedJavaMethodKey {</span>
<span class="changed"> 353         private final ResolvedJavaMethod method;</span>
 354 
<a name="14" id="anc14"></a><span class="changed"> 355         ResolvedJavaMethodKey(ResolvedJavaMethod method) {</span>
<span class="changed"> 356             this.method = method;</span>
<span class="changed"> 357         }</span>
 358 
<a name="15" id="anc15"></a><span class="changed"> 359         @Override</span>
<span class="changed"> 360         public boolean equals(Object obj) {</span>
<span class="changed"> 361             if (obj instanceof ResolvedJavaMethodKey) {</span>
<span class="changed"> 362                 ResolvedJavaMethodKey that = (ResolvedJavaMethodKey) obj;</span>
<span class="changed"> 363                 if (this.method.isStatic() == that.method.isStatic()) {</span>
<span class="changed"> 364                     if (this.method.getDeclaringClass().equals(that.method.getDeclaringClass())) {</span>
<span class="changed"> 365                         if (this.method.getName().equals(that.method.getName())) {</span>
<span class="changed"> 366                             if (this.method.getSignature().equals(that.method.getSignature())) {</span>
<span class="changed"> 367                                 return true;</span>
<span class="changed"> 368                             }</span>
<span class="changed"> 369                         }</span>
<span class="changed"> 370                     }</span>
<span class="changed"> 371                 }</span>
 372             }
<a name="16" id="anc16"></a><span class="changed"> 373             return false;</span>













 374         }
 375 
<a name="17" id="anc17"></a><span class="changed"> 376         @Override</span>
<span class="changed"> 377         public int hashCode() {</span>
<span class="changed"> 378             return this.method.getName().hashCode();</span>



 379         }
 380 
 381         @Override
<a name="18" id="anc18"></a><span class="changed"> 382         public String toString() {</span>
<span class="changed"> 383             return "ResolvedJavaMethodKey&lt;" + method + "&gt;";</span>


 384         }
 385     }
 386 
 387     /**
<a name="19" id="anc19"></a><span class="changed"> 388      * Key for {@linkplain ClassPlugins#registrations registering} an {@link InvocationPlugin} for a</span>
<span class="changed"> 389      * specific method.</span>
 390      */
<a name="20" id="anc20"></a><span class="changed"> 391     static class MethodKey {</span>
<span class="changed"> 392         final boolean isStatic;</span>



 393 
 394         /**
<a name="21" id="anc21"></a><span class="changed"> 395          * This method is optional. This is used for new API methods not present in previous JDK</span>
<span class="changed"> 396          * versions.</span>
 397          */
<a name="22" id="anc22"></a><span class="changed"> 398         final boolean isOptional;</span>
 399 
<a name="23" id="anc23"></a><span class="changed"> 400         final String name;</span>
<span class="changed"> 401         final Type[] argumentTypes;</span>
<span class="changed"> 402         final InvocationPlugin value;</span>

 403 
 404         /**
<a name="24" id="anc24"></a><span class="changed"> 405          * Used to lazily initialize {@link #resolved}.</span>



 406          */
<a name="25" id="anc25"></a><span class="changed"> 407         private final MetaAccessProvider metaAccess;</span>
 408 
<a name="26" id="anc26"></a><span class="changed"> 409         private volatile ResolvedJavaMethod resolved;</span>



 410 
<a name="27" id="anc27"></a><span class="changed"> 411         MethodKey(MetaAccessProvider metaAccess, InvocationPlugin data, boolean isStatic, boolean isOptional, String name, Type... argumentTypes) {</span>
<span class="changed"> 412             this.metaAccess = metaAccess;</span>
<span class="changed"> 413             this.value = data;</span>
 414             this.isStatic = isStatic;
<a name="28" id="anc28"></a><span class="removed"> 415             this.isOptional = isOptional;</span>
 416             this.name = name;
<a name="29" id="anc29"></a><span class="changed"> 417             this.argumentTypes = argumentTypes;</span>
<span class="changed"> 418         }</span>
<span class="changed"> 419 </span>
<span class="changed"> 420         @Override</span>
<span class="changed"> 421         public boolean equals(Object obj) {</span>
<span class="changed"> 422             if (obj instanceof MethodKey) {</span>
<span class="changed"> 423                 MethodKey that = (MethodKey) obj;</span>
<span class="changed"> 424                 boolean res = this.name.equals(that.name) &amp;&amp; areEqual(this.argumentTypes, that.argumentTypes);</span>
<span class="changed"> 425                 assert !res || this.isStatic == that.isStatic;</span>
<span class="changed"> 426                 return res;</span>
<span class="changed"> 427             }</span>
<span class="changed"> 428             return false;</span>
<span class="changed"> 429         }</span>
<span class="changed"> 430 </span>
<span class="changed"> 431         private static boolean areEqual(Type[] args1, Type[] args2) {</span>
<span class="changed"> 432             if (args1.length == args2.length) {</span>
<span class="changed"> 433                 for (int i = 0; i &lt; args1.length; i++) {</span>
<span class="changed"> 434                     if (!args1[i].getTypeName().equals(args2[i].getTypeName())) {</span>
<span class="changed"> 435                         return false;</span>
<span class="changed"> 436                     }</span>
<span class="changed"> 437                 }</span>
<span class="changed"> 438                 return true;</span>
<span class="changed"> 439             }</span>
<span class="changed"> 440             return false;</span>
<span class="changed"> 441         }</span>
<span class="changed"> 442 </span>
<span class="changed"> 443         public int getDeclaredParameterCount() {</span>
<span class="changed"> 444             return isStatic ? argumentTypes.length : argumentTypes.length - 1;</span>
<span class="changed"> 445         }</span>
<span class="changed"> 446 </span>
<span class="changed"> 447         @Override</span>
<span class="changed"> 448         public int hashCode() {</span>
<span class="changed"> 449             return name.hashCode();</span>
<span class="changed"> 450         }</span>
<span class="changed"> 451 </span>
<span class="changed"> 452         private ResolvedJavaMethod resolve(Class&lt;?&gt; declaringClass) {</span>
<span class="changed"> 453             if (resolved == null) {</span>
<span class="changed"> 454                 Executable method = resolveJava(declaringClass);</span>
<span class="changed"> 455                 if (method == null) {</span>
<span class="changed"> 456                     return null;</span>
<span class="changed"> 457                 }</span>
<span class="changed"> 458                 resolved = metaAccess.lookupJavaMethod(method);</span>
<span class="changed"> 459             }</span>
<span class="changed"> 460             return resolved;</span>
<span class="changed"> 461         }</span>
<span class="changed"> 462 </span>
<span class="changed"> 463         private Executable resolveJava(Class&lt;?&gt; declaringClass) {</span>
<span class="changed"> 464             try {</span>
<span class="changed"> 465                 Executable res;</span>
<span class="changed"> 466                 Class&lt;?&gt;[] parameterTypes = resolveTypes(argumentTypes, isStatic ? 0 : 1, argumentTypes.length);</span>
<span class="changed"> 467                 if (name.equals("&lt;init&gt;")) {</span>
<span class="changed"> 468                     res = declaringClass.getDeclaredConstructor(parameterTypes);</span>
<span class="changed"> 469                 } else {</span>
<span class="changed"> 470                     res = declaringClass.getDeclaredMethod(name, parameterTypes);</span>
<span class="changed"> 471                 }</span>
<span class="changed"> 472                 assert Modifier.isStatic(res.getModifiers()) == isStatic : res;</span>
<span class="changed"> 473                 return res;</span>
<span class="changed"> 474             } catch (NoSuchMethodException | SecurityException e) {</span>
<span class="changed"> 475                 if (isOptional) {</span>
<span class="changed"> 476                     return null;</span>
<span class="changed"> 477                 }</span>
<span class="changed"> 478                 throw new InternalError(e);</span>
<span class="changed"> 479             }</span>
 480         }
 481 
 482         @Override
 483         public String toString() {
<a name="30" id="anc30"></a><span class="changed"> 484             StringBuilder sb = new StringBuilder(name).append('(');</span>
<span class="changed"> 485             for (Type p : argumentTypes) {</span>
<span class="changed"> 486                 if (sb.charAt(sb.length() - 1) != '(') {</span>
<span class="changed"> 487                     sb.append(", ");</span>
<span class="changed"> 488                 }</span>
<span class="changed"> 489                 sb.append(p.getTypeName());</span>
<span class="changed"> 490             }</span>
<span class="changed"> 491             return sb.append(')').toString();</span>
 492         }
 493     }
 494 
<a name="31" id="anc31"></a><span class="changed"> 495     private final MetaAccessProvider metaAccess;</span>




 496 
<a name="32" id="anc32"></a><span class="changed"> 497     private final Map&lt;String, ClassPlugins&gt; registrations = new HashMap&lt;&gt;();</span>





 498 
 499     /**
<a name="33" id="anc33"></a><span class="changed"> 500      * Deferred registrations as well as guard for initialization. The guard uses double-checked</span>
<span class="changed"> 501      * locking which is why this field is {@code volatile}.</span>
 502      */
 503     private volatile List&lt;Runnable&gt; deferredRegistrations = new ArrayList&lt;&gt;();
 504 
 505     /**
 506      * Adds a {@link Runnable} for doing registration deferred until the first time
 507      * {@link #get(ResolvedJavaMethod)} or {@link #closeRegistration()} is called on this object.
 508      */
 509     public void defer(Runnable deferrable) {
 510         assert deferredRegistrations != null : "registration is closed";
 511         deferredRegistrations.add(deferrable);
 512     }
 513 
 514     /**
<a name="34" id="anc34"></a><span class="changed"> 515      * Per-class invocation plugins.</span>
 516      */
<a name="35" id="anc35"></a><span class="changed"> 517     protected static class ClassPlugins {</span>
<span class="changed"> 518         private final Type declaringType;</span>
 519 
<a name="36" id="anc36"></a><span class="changed"> 520         private final List&lt;MethodKey&gt; registrations = new ArrayList&lt;&gt;();</span>



 521 
<a name="37" id="anc37"></a><span class="changed"> 522         public ClassPlugins(Type declaringClass) {</span>
<span class="changed"> 523             this.declaringType = declaringClass;</span>
<span class="changed"> 524         }</span>

 525 
 526         /**
<a name="38" id="anc38"></a><span class="changed"> 527          * Entry map that is initialized upon first call to {@link #get(ResolvedJavaMethod)}.</span>
 528          *
<a name="39" id="anc39"></a><span class="changed"> 529          * Note: this must be volatile as threads may race to initialize it.</span>
 530          */
<a name="40" id="anc40"></a><span class="changed"> 531         private volatile Map&lt;ResolvedJavaMethodKey, InvocationPlugin&gt; entries;</span>
<span class="changed"> 532 </span>
<span class="changed"> 533         void initializeMap() {</span>
<span class="changed"> 534             if (!isClosed()) {</span>
<span class="changed"> 535                 if (registrations.isEmpty()) {</span>
<span class="changed"> 536                     entries = Collections.emptyMap();</span>
<span class="changed"> 537                 } else {</span>
<span class="changed"> 538                     Class&lt;?&gt; declaringClass = resolveType(declaringType, true);</span>
<span class="changed"> 539                     if (declaringClass == null) {</span>
<span class="changed"> 540                         // An optional type that could not be resolved</span>
<span class="changed"> 541                         entries = Collections.emptyMap();</span>
<span class="changed"> 542                     } else {</span>
<span class="changed"> 543                         Map&lt;ResolvedJavaMethodKey, InvocationPlugin&gt; newEntries = new HashMap&lt;&gt;();</span>
<span class="changed"> 544                         for (MethodKey methodKey : registrations) {</span>
<span class="changed"> 545                             ResolvedJavaMethod m = methodKey.resolve(declaringClass);</span>
<span class="changed"> 546                             if (m != null) {</span>
<span class="changed"> 547                                 newEntries.put(new ResolvedJavaMethodKey(m), methodKey.value);</span>
<span class="changed"> 548                                 if (entries != null) {</span>
<span class="changed"> 549                                     // Another thread finished initializing entries first</span>
<span class="changed"> 550                                     return;</span>
 551                                 }
 552                             }
<a name="41" id="anc41"></a>
 553                         }
<a name="42" id="anc42"></a><span class="changed"> 554                         entries = newEntries;</span>
 555                     }
<a name="43" id="anc43"></a>





 556                 }
<a name="44" id="anc44"></a>

 557             }
<a name="45" id="anc45"></a>
 558         }
 559 
<a name="46" id="anc46"></a><span class="changed"> 560         public InvocationPlugin get(ResolvedJavaMethod method) {</span>
<span class="changed"> 561             if (!isClosed()) {</span>
<span class="changed"> 562                 initializeMap();</span>


 563             }
<a name="47" id="anc47"></a><span class="changed"> 564             return entries.get(new ResolvedJavaMethodKey(method));</span>
 565         }
<a name="48" id="anc48"></a><span class="changed"> 566 </span>
<span class="changed"> 567         public void register(MethodKey methodKey, boolean allowOverwrite) {</span>
<span class="changed"> 568             assert !isClosed() : "registration is closed: " + methodKey + " " + Arrays.toString(entries.keySet().toArray());</span>
<span class="changed"> 569             if (allowOverwrite) {</span>
<span class="changed"> 570                 int index = registrations.indexOf(methodKey);</span>
<span class="changed"> 571                 if (index &gt;= 0) {</span>
<span class="changed"> 572                     registrations.set(index, methodKey);</span>
<span class="changed"> 573                     return;</span>
 574                 }
<a name="49" id="anc49"></a><span class="changed"> 575             } else {</span>
<span class="changed"> 576                 assert !registrations.contains(methodKey) : "a value is already registered for " + declaringType + "." + methodKey;</span>







 577             }
<a name="50" id="anc50"></a><span class="removed"> 578             registrations.add(methodKey);</span>
 579         }
 580 
<a name="51" id="anc51"></a><span class="changed"> 581         public boolean isClosed() {</span>
<span class="changed"> 582             return entries != null;</span>







 583         }
 584     }
 585 
 586     /**
<a name="52" id="anc52"></a><span class="changed"> 587      * Adds an entry to this map for a specified method.</span>
 588      *
<a name="53" id="anc53"></a><span class="changed"> 589      * @param value value to be associated with the specified method</span>
 590      * @param isStatic specifies if the method is static
<a name="54" id="anc54"></a><span class="removed"> 591      * @param isOptional specifies if the method is optional</span>
 592      * @param declaringClass the class declaring the method
 593      * @param name the name of the method
 594      * @param argumentTypes the argument types of the method. Element 0 of this array must be
 595      *            {@code declaringClass} iff the method is non-static.
 596      * @return an object representing the method
 597      */
<a name="55" id="anc55"></a><span class="changed"> 598     MethodKey put(InvocationPlugin value, boolean isStatic, boolean isOptional, boolean allowOverwrite, Type declaringClass, String name, Type... argumentTypes) {</span>


 599         assert isStatic || argumentTypes[0] == declaringClass;
<a name="56" id="anc56"></a>
 600 
<a name="57" id="anc57"></a><span class="removed"> 601         String internalName = MetaUtil.toInternalName(declaringClass.getTypeName());</span>
 602         ClassPlugins classPlugins = registrations.get(internalName);
 603         if (classPlugins == null) {
<a name="58" id="anc58"></a><span class="changed"> 604             classPlugins = new ClassPlugins(declaringClass);</span>
 605             registrations.put(internalName, classPlugins);
 606         }
<a name="59" id="anc59"></a><span class="changed"> 607         assert isStatic || argumentTypes[0] == declaringClass;</span>
<span class="changed"> 608         MethodKey methodKey = new MethodKey(metaAccess, value, isStatic, isOptional, name, argumentTypes);</span>
<span class="changed"> 609         classPlugins.register(methodKey, allowOverwrite);</span>
<span class="changed"> 610         return methodKey;</span>
<span class="changed"> 611     }</span>
<span class="changed"> 612 </span>
<span class="changed"> 613     /**</span>
<span class="changed"> 614      * Determines if a method denoted by a given {@link MethodKey} is in this map.</span>
<span class="changed"> 615      */</span>
<span class="changed"> 616     boolean containsKey(Type declaringType, MethodKey key) {</span>
<span class="changed"> 617         String internalName = MetaUtil.toInternalName(declaringType.getTypeName());</span>
<span class="changed"> 618         ClassPlugins classPlugins = registrations.get(internalName);</span>
<span class="changed"> 619         return classPlugins != null &amp;&amp; classPlugins.registrations.contains(key);</span>
 620     }
 621 
 622     InvocationPlugin get(ResolvedJavaMethod method) {
<a name="60" id="anc60"></a>




 623         flushDeferrables();
<a name="61" id="anc61"></a><span class="changed"> 624         String internalName = method.getDeclaringClass().getName();</span>
 625         ClassPlugins classPlugins = registrations.get(internalName);
<a name="62" id="anc62"></a>
 626         if (classPlugins != null) {
<a name="63" id="anc63"></a><span class="changed"> 627             return classPlugins.get(method);</span>



































 628         }
 629         return null;
 630     }
 631 
 632     private void flushDeferrables() {
 633         if (deferredRegistrations != null) {
 634             synchronized (this) {
 635                 if (deferredRegistrations != null) {
 636                     for (Runnable deferrable : deferredRegistrations) {
 637                         deferrable.run();
 638                     }
 639                     deferredRegistrations = null;
 640                 }
 641             }
<a name="64" id="anc64"></a><span class="removed"> 642             for (Map.Entry&lt;String, ClassPlugins&gt; e : registrations.entrySet()) {</span>
<span class="removed"> 643                 e.getValue().initializeMap();</span>
 644             }
 645         }
<a name="65" id="anc65"></a>















 646     }
 647 
 648     /**
<a name="66" id="anc66"></a><span class="changed"> 649      * Disallows new registrations of new plugins, and creates the internal tables for method</span>
<span class="changed"> 650      * lookup.</span>
 651      */
 652     public void closeRegistration() {
<a name="67" id="anc67"></a>
 653         flushDeferrables();
<a name="68" id="anc68"></a><span class="removed"> 654         for (Map.Entry&lt;String, ClassPlugins&gt; e : registrations.entrySet()) {</span>
<span class="removed"> 655             e.getValue().initializeMap();</span>
<span class="removed"> 656         }</span>
 657     }
 658 
<a name="69" id="anc69"></a><span class="changed"> 659     public int size() {</span>
<span class="changed"> 660         return registrations.size();</span>



 661     }
 662 
 663     /**
 664      * The plugins {@linkplain #lookupInvocation(ResolvedJavaMethod) searched} before searching in
 665      * this object.
 666      */
 667     protected final InvocationPlugins parent;
 668 
<a name="70" id="anc70"></a><span class="changed"> 669     private InvocationPlugins(InvocationPlugins parent, MetaAccessProvider metaAccess) {</span>
<span class="changed"> 670         this.metaAccess = metaAccess;</span>
<span class="changed"> 671         InvocationPlugins p = parent;</span>
<span class="changed"> 672         this.parent = p;</span>

 673     }
 674 
 675     /**
<a name="71" id="anc71"></a><span class="changed"> 676      * Creates a set of invocation plugins with a non-null {@linkplain #getParent() parent}.</span>


 677      */
 678     public InvocationPlugins(InvocationPlugins parent) {
<a name="72" id="anc72"></a><span class="changed"> 679         this(parent, parent.getMetaAccess());</span>



 680     }
 681 
<a name="73" id="anc73"></a><span class="changed"> 682     public InvocationPlugins(Map&lt;ResolvedJavaMethod, InvocationPlugin&gt; plugins, InvocationPlugins parent, MetaAccessProvider metaAccess) {</span>
<span class="changed"> 683         this.metaAccess = metaAccess;</span>



 684         this.parent = parent;
<a name="74" id="anc74"></a><span class="changed"> 685 </span>
 686         this.deferredRegistrations = null;
<a name="75" id="anc75"></a>
 687 
 688         for (Map.Entry&lt;ResolvedJavaMethod, InvocationPlugin&gt; entry : plugins.entrySet()) {
<a name="76" id="anc76"></a><span class="changed"> 689             ResolvedJavaMethod method = entry.getKey();</span>
<span class="changed"> 690             InvocationPlugin plugin = entry.getValue();</span>
<span class="changed"> 691 </span>
<span class="changed"> 692             String internalName = method.getDeclaringClass().getName();</span>
<span class="changed"> 693             ClassPlugins classPlugins = registrations.get(internalName);</span>
<span class="changed"> 694             if (classPlugins == null) {</span>
<span class="changed"> 695                 classPlugins = new ClassPlugins(null);</span>
<span class="changed"> 696                 registrations.put(internalName, classPlugins);</span>
<span class="changed"> 697                 classPlugins.entries = new HashMap&lt;&gt;();</span>
<span class="changed"> 698             }</span>
<span class="changed"> 699 </span>
<span class="changed"> 700             classPlugins.entries.put(new ResolvedJavaMethodKey(method), plugin);</span>
<span class="changed"> 701         }</span>
 702     }
<a name="77" id="anc77"></a><span class="changed"> 703 </span>
<span class="changed"> 704     public MetaAccessProvider getMetaAccess() {</span>
<span class="changed"> 705         return metaAccess;</span>
<span class="changed"> 706     }</span>
<span class="changed"> 707 </span>
<span class="changed"> 708     public InvocationPlugins(MetaAccessProvider metaAccess) {</span>
<span class="changed"> 709         this(null, metaAccess);</span>
 710     }
 711 
 712     protected void register(InvocationPlugin plugin, boolean isOptional, boolean allowOverwrite, Type declaringClass, String name, Type... argumentTypes) {
 713         boolean isStatic = argumentTypes.length == 0 || argumentTypes[0] != InvocationPlugin.Receiver.class;
 714         if (!isStatic) {
 715             argumentTypes[0] = declaringClass;
 716         }
<a name="78" id="anc78"></a><span class="changed"> 717         MethodKey methodKey = put(plugin, isStatic, isOptional, allowOverwrite, declaringClass, name, argumentTypes);</span>
<span class="changed"> 718         assert Checker.check(this, declaringClass, methodKey, plugin);</span>

 719     }
 720 
 721     /**
 722      * Registers an invocation plugin for a given method. There must be no plugin currently
 723      * registered for {@code method}.
 724      *
 725      * @param argumentTypes the argument types of the method. Element 0 of this array must be the
 726      *            {@link Class} value for {@link InvocationPlugin.Receiver} iff the method is
 727      *            non-static. Upon returning, element 0 will have been rewritten to
 728      *            {@code declaringClass}
 729      */
 730     public void register(InvocationPlugin plugin, Type declaringClass, String name, Type... argumentTypes) {
 731         register(plugin, false, false, declaringClass, name, argumentTypes);
 732     }
 733 
 734     public void register(InvocationPlugin plugin, String declaringClass, String name, Type... argumentTypes) {
 735         register(plugin, false, false, new OptionalLazySymbol(declaringClass), name, argumentTypes);
 736     }
 737 
 738     /**
 739      * Registers an invocation plugin for a given, optional method. There must be no plugin
 740      * currently registered for {@code method}.
 741      *
 742      * @param argumentTypes the argument types of the method. Element 0 of this array must be the
 743      *            {@link Class} value for {@link InvocationPlugin.Receiver} iff the method is
 744      *            non-static. Upon returning, element 0 will have been rewritten to
 745      *            {@code declaringClass}
 746      */
 747     public void registerOptional(InvocationPlugin plugin, Type declaringClass, String name, Type... argumentTypes) {
 748         register(plugin, true, false, declaringClass, name, argumentTypes);
 749     }
 750 
 751     /**
 752      * Gets the plugin for a given method.
 753      *
 754      * @param method the method to lookup
 755      * @return the plugin associated with {@code method} or {@code null} if none exists
 756      */
 757     public InvocationPlugin lookupInvocation(ResolvedJavaMethod method) {
 758         if (parent != null) {
 759             InvocationPlugin plugin = parent.lookupInvocation(method);
 760             if (plugin != null) {
 761                 return plugin;
 762             }
 763         }
 764         return get(method);
 765     }
 766 
 767     /**
<a name="79" id="anc79"></a><span class="changed"> 768      * Gets the set of methods for which invocation plugins have been registered. Once this method</span>
<span class="changed"> 769      * is called, no further registrations can be made.</span>


 770      */
<a name="80" id="anc80"></a><span class="changed"> 771     public Set&lt;ResolvedJavaMethod&gt; getMethods() {</span>
<span class="changed"> 772         Set&lt;ResolvedJavaMethod&gt; res = new HashSet&lt;&gt;();</span>
<span class="changed"> 773         if (parent != null) {</span>
<span class="changed"> 774             res.addAll(parent.getMethods());</span>










 775         }
<a name="81" id="anc81"></a>


 776         flushDeferrables();
<a name="82" id="anc82"></a><span class="changed"> 777         for (ClassPlugins cp : registrations.values()) {</span>
<span class="changed"> 778             for (ResolvedJavaMethodKey key : cp.entries.keySet()) {</span>
<span class="changed"> 779                 res.add(key.method);</span>





 780             }
 781         }
 782         return res;
 783     }
 784 
<a name="83" id="anc83"></a>












 785     /**
 786      * Gets the invocation plugins {@linkplain #lookupInvocation(ResolvedJavaMethod) searched}
 787      * before searching in this object.
 788      */
 789     public InvocationPlugins getParent() {
 790         return parent;
 791     }
 792 
 793     @Override
 794     public String toString() {
<a name="84" id="anc84"></a>







 795         StringBuilder buf = new StringBuilder();
<a name="85" id="anc85"></a><span class="changed"> 796         registrations.forEach((name, cp) -&gt; buf.append(name).append('.').append(cp).append(", "));</span>
<span class="changed"> 797         String s = buf.toString();</span>






 798         if (buf.length() != 0) {
<a name="86" id="anc86"></a><span class="changed"> 799             s = s.substring(buf.length() - ", ".length());</span>
 800         }
<a name="87" id="anc87"></a><span class="changed"> 801         return s + " / parent: " + this.parent;</span>


 802     }
 803 
<a name="88" id="anc88"></a><span class="changed"> 804     private static class Checker {</span>
<span class="changed"> 805         private static final int MAX_ARITY = 5;</span>



 806         /**
 807          * The set of all {@link InvocationPlugin#apply} method signatures.
 808          */
 809         static final Class&lt;?&gt;[][] SIGS;
 810 
 811         static {
 812             ArrayList&lt;Class&lt;?&gt;[]&gt; sigs = new ArrayList&lt;&gt;(MAX_ARITY);
 813             for (Method method : InvocationPlugin.class.getDeclaredMethods()) {
 814                 if (!Modifier.isStatic(method.getModifiers()) &amp;&amp; method.getName().equals("apply")) {
 815                     Class&lt;?&gt;[] sig = method.getParameterTypes();
 816                     assert sig[0] == GraphBuilderContext.class;
 817                     assert sig[1] == ResolvedJavaMethod.class;
 818                     assert sig[2] == InvocationPlugin.Receiver.class;
 819                     assert Arrays.asList(sig).subList(3, sig.length).stream().allMatch(c -&gt; c == ValueNode.class);
 820                     while (sigs.size() &lt; sig.length - 2) {
 821                         sigs.add(null);
 822                     }
 823                     sigs.set(sig.length - 3, sig);
 824                 }
 825             }
 826             assert sigs.indexOf(null) == -1 : format("need to add an apply() method to %s that takes %d %s arguments ", InvocationPlugin.class.getName(), sigs.indexOf(null),
 827                             ValueNode.class.getSimpleName());
 828             SIGS = sigs.toArray(new Class&lt;?&gt;[sigs.size()][]);
 829         }
 830 
<a name="89" id="anc89"></a><span class="changed"> 831         public static boolean check(InvocationPlugins plugins, Type declaringType, MethodKey method, InvocationPlugin plugin) {</span>







 832             InvocationPlugins p = plugins.parent;
 833             while (p != null) {
<a name="90" id="anc90"></a><span class="changed"> 834                 assert !p.containsKey(declaringType, method) : "a plugin is already registered for " + method;</span>
 835                 p = p.parent;
 836             }
 837             if (plugin instanceof ForeignCallPlugin || plugin instanceof GeneratedInvocationPlugin) {
 838                 return true;
 839             }
 840             if (plugin instanceof MethodSubstitutionPlugin) {
 841                 MethodSubstitutionPlugin msplugin = (MethodSubstitutionPlugin) plugin;
 842                 Method substitute = msplugin.getJavaSubstitute();
 843                 assert substitute.getAnnotation(MethodSubstitution.class) != null : format("Substitute method must be annotated with @%s: %s", MethodSubstitution.class.getSimpleName(), substitute);
 844                 return true;
 845             }
<a name="91" id="anc91"></a><span class="changed"> 846             int arguments = method.getDeclaredParameterCount();</span>
<span class="changed"> 847             assert arguments &lt; SIGS.length : format("need to extend %s to support method with %d arguments: %s", InvocationPlugin.class.getSimpleName(), arguments, method);</span>
 848             for (Method m : plugin.getClass().getDeclaredMethods()) {
 849                 if (m.getName().equals("apply")) {
 850                     Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();
 851                     if (Arrays.equals(SIGS[arguments], parameterTypes)) {
 852                         return true;
 853                     }
 854                 }
 855             }
<a name="92" id="anc92"></a><span class="changed"> 856             throw new AssertionError(format("graph builder plugin for %s not found", method));</span>

















 857         }
 858     }
 859 
 860     /**
 861      * Checks a set of nodes added to the graph by an {@link InvocationPlugin}.
 862      *
 863      * @param b the graph builder that applied the plugin
 864      * @param plugin a plugin that was just applied
 865      * @param newNodes the nodes added to the graph by {@code plugin}
 866      * @throws AssertionError if any check fail
 867      */
 868     public void checkNewNodes(GraphBuilderContext b, InvocationPlugin plugin, NodeIterable&lt;Node&gt; newNodes) {
 869         if (parent != null) {
 870             parent.checkNewNodes(b, plugin, newNodes);
 871         }
 872     }
 873 
 874     /**
 875      * Resolves a name to a class.
 876      *
 877      * @param className the name of the class to resolve
 878      * @param optional if true, resolution failure returns null
 879      * @return the resolved class or null if resolution fails and {@code optional} is true
 880      */
 881     public static Class&lt;?&gt; resolveClass(String className, boolean optional) {
 882         try {
 883             // Need to use the system class loader to handle classes
 884             // loaded by the application class loader which is not
 885             // delegated to by the JVMCI class loader.
 886             ClassLoader cl = ClassLoader.getSystemClassLoader();
 887             return Class.forName(className, false, cl);
 888         } catch (ClassNotFoundException e) {
 889             if (optional) {
 890                 return null;
 891             }
 892             throw new GraalError("Could not resolve type " + className);
 893         }
 894     }
 895 
 896     /**
 897      * Resolves a {@link Type} to a {@link Class}.
 898      *
 899      * @param type the type to resolve
 900      * @param optional if true, resolution failure returns null
 901      * @return the resolved class or null if resolution fails and {@code optional} is true
 902      */
 903     public static Class&lt;?&gt; resolveType(Type type, boolean optional) {
 904         if (type instanceof Class) {
 905             return (Class&lt;?&gt;) type;
 906         }
<a name="93" id="anc93"></a><span class="changed"> 907         if (optional &amp;&amp; type instanceof OptionalLazySymbol) {</span>
 908             return ((OptionalLazySymbol) type).resolve();
 909         }
 910         return resolveClass(type.getTypeName(), optional);
 911     }
 912 
<a name="94" id="anc94"></a><span class="changed"> 913     private static final Class&lt;?&gt;[] NO_CLASSES = {};</span>






 914 
 915     /**
<a name="95" id="anc95"></a><span class="changed"> 916      * Resolves an array of {@link Type}s to an array of {@link Class}es.</span>



 917      *
<a name="96" id="anc96"></a><span class="changed"> 918      * @param types the types to resolve</span>
<span class="changed"> 919      * @param from the initial index of the range to be resolved, inclusive</span>
<span class="changed"> 920      * @param to the final index of the range to be resolved, exclusive</span>
<span class="changed"> 921      * @return the resolved class or null if resolution fails and {@code optional} is true</span>






































 922      */
<a name="97" id="anc97"></a><span class="changed"> 923     public static Class&lt;?&gt;[] resolveTypes(Type[] types, int from, int to) {</span>
<span class="changed"> 924         int length = to - from;</span>
<span class="changed"> 925         if (length &lt;= 0) {</span>
<span class="changed"> 926             return NO_CLASSES;</span>
<span class="changed"> 927         }</span>
<span class="changed"> 928         Class&lt;?&gt;[] classes = new Class&lt;?&gt;[length];</span>
<span class="changed"> 929         for (int i = 0; i &lt; length; i++) {</span>
<span class="changed"> 930             classes[i] = resolveType(types[i + from], false);</span>


 931         }
<a name="98" id="anc98"></a><span class="changed"> 932         return classes;</span>







































 933     }
 934 }
<a name="99" id="anc99"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="99" type="hidden" /></form></body></html>
