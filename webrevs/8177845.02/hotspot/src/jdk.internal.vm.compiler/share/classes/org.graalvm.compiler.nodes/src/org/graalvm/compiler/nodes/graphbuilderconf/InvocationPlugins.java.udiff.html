<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/InvocationPlugins.java</title>

<style type="text/css" media="screen">
span.new {
    color: blue;
    font-weight: normal;
}
</style>

</head>
<body id="SUNWwebrev">
<center><a href='../../../../../../../../../../../src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/InvocationPlugin.java.udiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../../src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.printer/src/org/graalvm/compiler/printer/GraphPrinter.java.udiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/InvocationPlugins.java</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre></pre>
        <pre>
</pre><hr /><pre>
<span class="newmarker">@@ -21,39 +21,50 @@</span>
  * questions.
  */
 package org.graalvm.compiler.nodes.graphbuilderconf;
 
 import static java.lang.String.format;
<span class="new">+import static org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.LateClassPlugins.CLOSED_LATE_CLASS_PLUGIN;</span>
 
<span class="removed">-import java.lang.reflect.Executable;</span>
<span class="new">+import java.lang.reflect.Constructor;</span>
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
<span class="removed">-import java.util.HashSet;</span>
 import java.util.List;
 import java.util.Map;
<span class="removed">-import java.util.Set;</span>
 
 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 import org.graalvm.compiler.api.replacements.MethodSubstitutionRegistry;
 import org.graalvm.compiler.bytecode.BytecodeProvider;
 import org.graalvm.compiler.debug.GraalError;
 import org.graalvm.compiler.graph.Node;
 import org.graalvm.compiler.graph.iterators.NodeIterable;
 import org.graalvm.compiler.nodes.ValueNode;
 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 
<span class="removed">-import jdk.vm.ci.meta.MetaAccessProvider;</span>
 import jdk.vm.ci.meta.MetaUtil;
 import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="new">+import jdk.vm.ci.meta.ResolvedJavaType;</span>
<span class="new">+import jdk.vm.ci.meta.Signature;</span>
 
 /**
  * Manages a set of {@link InvocationPlugin}s.
<span class="new">+ *</span>
<span class="new">+ * Most plugins are registered during initialization (i.e., before</span>
<span class="new">+ * {@link #lookupInvocation(ResolvedJavaMethod)} or {@link #getBindings} is called). These</span>
<span class="new">+ * registrations can be made with {@link Registration},</span>
<span class="new">+ * {@link #register(InvocationPlugin, String, String, Type...)},</span>
<span class="new">+ * {@link #register(InvocationPlugin, Type, String, Type...)} or</span>
<span class="new">+ * {@link #registerOptional(InvocationPlugin, Type, String, Type...)}. Initialization is not</span>
<span class="new">+ * thread-safe and so must only be performed by a single thread.</span>
<span class="new">+ *</span>
<span class="new">+ * Plugins that are not guaranteed to be made during initialization must use</span>
<span class="new">+ * {@link LateRegistration}.</span>
  */
 public class InvocationPlugins {
 
     public static class InvocationPluginReceiver implements InvocationPlugin.Receiver {
         private final GraphBuilderContext parser;
</pre><hr /><pre>
<span class="newmarker">@@ -258,10 +269,30 @@</span>
         public void register5(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, InvocationPlugin plugin) {
             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5);
         }
 
         /**
<span class="new">+         * Registers a plugin for a method with 6 arguments.</span>
<span class="new">+         *</span>
<span class="new">+         * @param name the name of the method</span>
<span class="new">+         * @param plugin the plugin to be registered</span>
<span class="new">+         */</span>
<span class="new">+        public void register6(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, InvocationPlugin plugin) {</span>
<span class="new">+            plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6);</span>
<span class="new">+        }</span>
<span class="new">+</span>
<span class="new">+        /**</span>
<span class="new">+         * Registers a plugin for a method with 7 arguments.</span>
<span class="new">+         *</span>
<span class="new">+         * @param name the name of the method</span>
<span class="new">+         * @param plugin the plugin to be registered</span>
<span class="new">+         */</span>
<span class="new">+        public void register7(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, Type arg7, InvocationPlugin plugin) {</span>
<span class="new">+            plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7);</span>
<span class="new">+        }</span>
<span class="new">+</span>
<span class="new">+        /**</span>
          * Registers a plugin for an optional method with no arguments.
          *
          * @param name the name of the method
          * @param plugin the plugin to be registered
          */
</pre><hr /><pre>
<span class="newmarker">@@ -335,172 +366,155 @@</span>
          *            is non-static. Upon returning, element 0 will have been rewritten to
          *            {@code declaringClass}
          */
         @Override
         public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type... argumentTypes) {
<span class="new">+            MethodSubstitutionPlugin plugin = createMethodSubstitution(substituteDeclaringClass, substituteName, argumentTypes);</span>
<span class="new">+            plugins.register(plugin, false, allowOverwrite, declaringType, name, argumentTypes);</span>
<span class="new">+        }</span>
<span class="new">+</span>
<span class="new">+        public MethodSubstitutionPlugin createMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String substituteName, Type... argumentTypes) {</span>
             assert methodSubstitutionBytecodeProvider != null : "Registration used for method substitutions requires a non-null methodSubstitutionBytecodeProvider";
             MethodSubstitutionPlugin plugin = new MethodSubstitutionPlugin(methodSubstitutionBytecodeProvider, substituteDeclaringClass, substituteName, argumentTypes);
<span class="removed">-            plugins.register(plugin, false, allowOverwrite, declaringType, name, argumentTypes);</span>
<span class="new">+            return plugin;</span>
         }
<span class="new">+</span>
     }
 
     /**
<span class="removed">-     * Key for a {@linkplain ClassPlugins#entries resolved} plugin registration. Due to the</span>
<span class="removed">-     * possibility of class redefinition, we cannot directly use {@link ResolvedJavaMethod}s as</span>
<span class="removed">-     * keys. A {@link ResolvedJavaMethod} implementation might implement {@code equals()} and</span>
<span class="removed">-     * {@code hashCode()} based on internal representation subject to change by class redefinition.</span>
<span class="new">+     * Utility for registering plugins after Graal may have been initialized. Registrations made via</span>
<span class="new">+     * this class are not finalized until {@link #close} is called.</span>
      */
<span class="removed">-    static final class ResolvedJavaMethodKey {</span>
<span class="removed">-        private final ResolvedJavaMethod method;</span>
<span class="new">+    public static class LateRegistration implements AutoCloseable {</span>
 
<span class="removed">-        ResolvedJavaMethodKey(ResolvedJavaMethod method) {</span>
<span class="removed">-            this.method = method;</span>
<span class="removed">-        }</span>
<span class="new">+        private InvocationPlugins plugins;</span>
<span class="new">+        private final List&lt;Binding&gt; bindings = new ArrayList&lt;&gt;();</span>
<span class="new">+        private final Type declaringType;</span>
 
<span class="removed">-        @Override</span>
<span class="removed">-        public boolean equals(Object obj) {</span>
<span class="removed">-            if (obj instanceof ResolvedJavaMethodKey) {</span>
<span class="removed">-                ResolvedJavaMethodKey that = (ResolvedJavaMethodKey) obj;</span>
<span class="removed">-                if (this.method.isStatic() == that.method.isStatic()) {</span>
<span class="removed">-                    if (this.method.getDeclaringClass().equals(that.method.getDeclaringClass())) {</span>
<span class="removed">-                        if (this.method.getName().equals(that.method.getName())) {</span>
<span class="removed">-                            if (this.method.getSignature().equals(that.method.getSignature())) {</span>
<span class="removed">-                                return true;</span>
<span class="removed">-                            }</span>
<span class="removed">-                        }</span>
<span class="removed">-                    }</span>
<span class="removed">-                }</span>
<span class="new">+        /**</span>
<span class="new">+         * Creates an object for registering {@link InvocationPlugin}s for methods declared by a</span>
<span class="new">+         * given class.</span>
<span class="new">+         *</span>
<span class="new">+         * @param plugins where to register the plugins</span>
<span class="new">+         * @param declaringType the class declaring the methods for which plugins will be registered</span>
<span class="new">+         *            via this object</span>
<span class="new">+         */</span>
<span class="new">+        public LateRegistration(InvocationPlugins plugins, Type declaringType) {</span>
<span class="new">+            this.plugins = plugins;</span>
<span class="new">+            this.declaringType = declaringType;</span>
             }
<span class="removed">-            return false;</span>
<span class="new">+</span>
<span class="new">+        /**</span>
<span class="new">+         * Registers an invocation plugin for a given method. There must be no plugin currently</span>
<span class="new">+         * registered for {@code method}.</span>
<span class="new">+         *</span>
<span class="new">+         * @param argumentTypes the argument types of the method. Element 0 of this array must be</span>
<span class="new">+         *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method</span>
<span class="new">+         *            is non-static. Upon returning, element 0 will have been rewritten to</span>
<span class="new">+         *            {@code declaringClass}</span>
<span class="new">+         */</span>
<span class="new">+        public void register(InvocationPlugin plugin, String name, Type... argumentTypes) {</span>
<span class="new">+            boolean isStatic = argumentTypes.length == 0 || argumentTypes[0] != InvocationPlugin.Receiver.class;</span>
<span class="new">+            if (!isStatic) {</span>
<span class="new">+                argumentTypes[0] = declaringType;</span>
         }
 
<span class="removed">-        @Override</span>
<span class="removed">-        public int hashCode() {</span>
<span class="removed">-            return this.method.getName().hashCode();</span>
<span class="new">+            assert isStatic || argumentTypes[0] == declaringType;</span>
<span class="new">+            Binding binding = new Binding(plugin, isStatic, name, argumentTypes);</span>
<span class="new">+            bindings.add(binding);</span>
<span class="new">+</span>
<span class="new">+            assert Checks.check(this.plugins, declaringType, binding);</span>
<span class="new">+            assert Checks.checkResolvable(false, declaringType, binding);</span>
         }
 
         @Override
<span class="removed">-        public String toString() {</span>
<span class="removed">-            return "ResolvedJavaMethodKey&lt;" + method + "&gt;";</span>
<span class="new">+        public void close() {</span>
<span class="new">+            assert plugins != null : String.format("Late registrations of invocation plugins for %s is already closed", declaringType);</span>
<span class="new">+            plugins.registerLate(declaringType, bindings);</span>
<span class="new">+            plugins = null;</span>
         }
     }
 
     /**
<span class="removed">-     * Key for {@linkplain ClassPlugins#registrations registering} an {@link InvocationPlugin} for a</span>
<span class="removed">-     * specific method.</span>
<span class="new">+     * Associates an {@link InvocationPlugin} with the details of a method it substitutes.</span>
      */
<span class="removed">-    static class MethodKey {</span>
<span class="removed">-        final boolean isStatic;</span>
<span class="new">+    public static class Binding {</span>
<span class="new">+        /**</span>
<span class="new">+         * The plugin this binding is for.</span>
<span class="new">+         */</span>
<span class="new">+        public final InvocationPlugin plugin;</span>
 
         /**
<span class="removed">-         * This method is optional. This is used for new API methods not present in previous JDK</span>
<span class="removed">-         * versions.</span>
<span class="new">+         * Specifies if the associated method is static.</span>
          */
<span class="removed">-        final boolean isOptional;</span>
<span class="new">+        public final boolean isStatic;</span>
 
<span class="removed">-        final String name;</span>
<span class="removed">-        final Type[] argumentTypes;</span>
<span class="removed">-        final InvocationPlugin value;</span>
<span class="new">+        /**</span>
<span class="new">+         * The name of the associated method.</span>
<span class="new">+         */</span>
<span class="new">+        public final String name;</span>
 
         /**
<span class="removed">-         * Used to lazily initialize {@link #resolved}.</span>
<span class="new">+         * A partial</span>
<span class="new">+         * &lt;a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.3"&gt;method</span>
<span class="new">+         * descriptor&lt;/a&gt; for the associated method. The descriptor includes enclosing {@code '('}</span>
<span class="new">+         * and {@code ')'} characters but omits the return type suffix.</span>
          */
<span class="removed">-        private final MetaAccessProvider metaAccess;</span>
<span class="new">+        public final String argumentsDescriptor;</span>
 
<span class="removed">-        private volatile ResolvedJavaMethod resolved;</span>
<span class="new">+        /**</span>
<span class="new">+         * Link in a list of bindings.</span>
<span class="new">+         */</span>
<span class="new">+        private Binding next;</span>
 
<span class="removed">-        MethodKey(MetaAccessProvider metaAccess, InvocationPlugin data, boolean isStatic, boolean isOptional, String name, Type... argumentTypes) {</span>
<span class="removed">-            this.metaAccess = metaAccess;</span>
<span class="removed">-            this.value = data;</span>
<span class="new">+        Binding(InvocationPlugin data, boolean isStatic, String name, Type... argumentTypes) {</span>
<span class="new">+            this.plugin = data;</span>
             this.isStatic = isStatic;
<span class="removed">-            this.isOptional = isOptional;</span>
             this.name = name;
<span class="removed">-            this.argumentTypes = argumentTypes;</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        @Override</span>
<span class="removed">-        public boolean equals(Object obj) {</span>
<span class="removed">-            if (obj instanceof MethodKey) {</span>
<span class="removed">-                MethodKey that = (MethodKey) obj;</span>
<span class="removed">-                boolean res = this.name.equals(that.name) &amp;&amp; areEqual(this.argumentTypes, that.argumentTypes);</span>
<span class="removed">-                assert !res || this.isStatic == that.isStatic;</span>
<span class="removed">-                return res;</span>
<span class="removed">-            }</span>
<span class="removed">-            return false;</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        private static boolean areEqual(Type[] args1, Type[] args2) {</span>
<span class="removed">-            if (args1.length == args2.length) {</span>
<span class="removed">-                for (int i = 0; i &lt; args1.length; i++) {</span>
<span class="removed">-                    if (!args1[i].getTypeName().equals(args2[i].getTypeName())) {</span>
<span class="removed">-                        return false;</span>
<span class="removed">-                    }</span>
<span class="removed">-                }</span>
<span class="removed">-                return true;</span>
<span class="removed">-            }</span>
<span class="removed">-            return false;</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        public int getDeclaredParameterCount() {</span>
<span class="removed">-            return isStatic ? argumentTypes.length : argumentTypes.length - 1;</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        @Override</span>
<span class="removed">-        public int hashCode() {</span>
<span class="removed">-            return name.hashCode();</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        private ResolvedJavaMethod resolve(Class&lt;?&gt; declaringClass) {</span>
<span class="removed">-            if (resolved == null) {</span>
<span class="removed">-                Executable method = resolveJava(declaringClass);</span>
<span class="removed">-                if (method == null) {</span>
<span class="removed">-                    return null;</span>
<span class="removed">-                }</span>
<span class="removed">-                resolved = metaAccess.lookupJavaMethod(method);</span>
<span class="removed">-            }</span>
<span class="removed">-            return resolved;</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        private Executable resolveJava(Class&lt;?&gt; declaringClass) {</span>
<span class="removed">-            try {</span>
<span class="removed">-                Executable res;</span>
<span class="removed">-                Class&lt;?&gt;[] parameterTypes = resolveTypes(argumentTypes, isStatic ? 0 : 1, argumentTypes.length);</span>
<span class="removed">-                if (name.equals("&lt;init&gt;")) {</span>
<span class="removed">-                    res = declaringClass.getDeclaredConstructor(parameterTypes);</span>
<span class="removed">-                } else {</span>
<span class="removed">-                    res = declaringClass.getDeclaredMethod(name, parameterTypes);</span>
<span class="removed">-                }</span>
<span class="removed">-                assert Modifier.isStatic(res.getModifiers()) == isStatic : res;</span>
<span class="removed">-                return res;</span>
<span class="removed">-            } catch (NoSuchMethodException | SecurityException e) {</span>
<span class="removed">-                if (isOptional) {</span>
<span class="removed">-                    return null;</span>
<span class="removed">-                }</span>
<span class="removed">-                throw new InternalError(e);</span>
<span class="removed">-            }</span>
<span class="new">+            StringBuilder buf = new StringBuilder();</span>
<span class="new">+            buf.append('(');</span>
<span class="new">+            for (int i = isStatic ? 0 : 1; i &lt; argumentTypes.length; i++) {</span>
<span class="new">+                buf.append(MetaUtil.toInternalName(argumentTypes[i].getTypeName()));</span>
<span class="new">+            }</span>
<span class="new">+            buf.append(')');</span>
<span class="new">+            this.argumentsDescriptor = buf.toString();</span>
<span class="new">+            assert !name.equals("&lt;init&gt;") || !isStatic : this;</span>
<span class="new">+        }</span>
<span class="new">+</span>
<span class="new">+        Binding(ResolvedJavaMethod resolved, InvocationPlugin data) {</span>
<span class="new">+            this.plugin = data;</span>
<span class="new">+            this.isStatic = resolved.isStatic();</span>
<span class="new">+            this.name = resolved.getName();</span>
<span class="new">+            Signature sig = resolved.getSignature();</span>
<span class="new">+            String desc = sig.toMethodDescriptor();</span>
<span class="new">+            assert desc.indexOf(')') != -1 : desc;</span>
<span class="new">+            this.argumentsDescriptor = desc.substring(0, desc.indexOf(')') + 1);</span>
<span class="new">+            assert !name.equals("&lt;init&gt;") || !isStatic : this;</span>
         }
 
         @Override
         public String toString() {
<span class="removed">-            StringBuilder sb = new StringBuilder(name).append('(');</span>
<span class="removed">-            for (Type p : argumentTypes) {</span>
<span class="removed">-                if (sb.charAt(sb.length() - 1) != '(') {</span>
<span class="removed">-                    sb.append(", ");</span>
<span class="removed">-                }</span>
<span class="removed">-                sb.append(p.getTypeName());</span>
<span class="removed">-            }</span>
<span class="removed">-            return sb.append(')').toString();</span>
<span class="new">+            return name + argumentsDescriptor;</span>
         }
     }
 
<span class="removed">-    private final MetaAccessProvider metaAccess;</span>
<span class="new">+    /**</span>
<span class="new">+     * Plugin registrations for already resolved methods. If non-null, then {@link #registrations}</span>
<span class="new">+     * is null and no further registrations can be made.</span>
<span class="new">+     */</span>
<span class="new">+    private final Map&lt;ResolvedJavaMethod, InvocationPlugin&gt; resolvedRegistrations;</span>
 
<span class="removed">-    private final Map&lt;String, ClassPlugins&gt; registrations = new HashMap&lt;&gt;();</span>
<span class="new">+    /**</span>
<span class="new">+     * Map from class names in {@linkplain MetaUtil#toInternalName(String) internal} form to the</span>
<span class="new">+     * invocation plugin bindings for the class. Tf non-null, then {@link #resolvedRegistrations}</span>
<span class="new">+     * will be null.</span>
<span class="new">+     */</span>
<span class="new">+    private final Map&lt;String, ClassPlugins&gt; registrations;</span>
 
     /**
<span class="removed">-     * Deferred registrations as well as guard for initialization. The guard uses double-checked</span>
<span class="removed">-     * locking which is why this field is {@code volatile}.</span>
<span class="new">+     * Deferred registrations as well as the guard for delimiting the initial registration phase.</span>
<span class="new">+     * The guard uses double-checked locking which is why this field is {@code volatile}.</span>
      */
     private volatile List&lt;Runnable&gt; deferredRegistrations = new ArrayList&lt;&gt;();
 
     /**
      * Adds a {@link Runnable} for doing registration deferred until the first time
</pre><hr /><pre>
<span class="newmarker">@@ -510,123 +524,163 @@</span>
         assert deferredRegistrations != null : "registration is closed";
         deferredRegistrations.add(deferrable);
     }
 
     /**
<span class="removed">-     * Per-class invocation plugins.</span>
<span class="new">+     * Support for registering plugins once this object may be accessed by multiple threads.</span>
      */
<span class="removed">-    protected static class ClassPlugins {</span>
<span class="removed">-        private final Type declaringType;</span>
<span class="new">+    private volatile LateClassPlugins lateRegistrations;</span>
 
<span class="removed">-        private final List&lt;MethodKey&gt; registrations = new ArrayList&lt;&gt;();</span>
<span class="new">+    /**</span>
<span class="new">+     * Per-class bindings.</span>
<span class="new">+     */</span>
<span class="new">+    static class ClassPlugins {</span>
 
<span class="removed">-        public ClassPlugins(Type declaringClass) {</span>
<span class="removed">-            this.declaringType = declaringClass;</span>
<span class="removed">-        }</span>
<span class="new">+        /**</span>
<span class="new">+         * Maps method names to binding lists.</span>
<span class="new">+         */</span>
<span class="new">+        private final Map&lt;String, Binding&gt; bindings = new HashMap&lt;&gt;();</span>
 
         /**
<span class="removed">-         * Entry map that is initialized upon first call to {@link #get(ResolvedJavaMethod)}.</span>
<span class="new">+         * Gets the invocation plugin for a given method.</span>
          *
<span class="removed">-         * Note: this must be volatile as threads may race to initialize it.</span>
<span class="new">+         * @return the invocation plugin for {@code method} or {@code null}</span>
          */
<span class="removed">-        private volatile Map&lt;ResolvedJavaMethodKey, InvocationPlugin&gt; entries;</span>
<span class="removed">-</span>
<span class="removed">-        void initializeMap() {</span>
<span class="removed">-            if (!isClosed()) {</span>
<span class="removed">-                if (registrations.isEmpty()) {</span>
<span class="removed">-                    entries = Collections.emptyMap();</span>
<span class="removed">-                } else {</span>
<span class="removed">-                    Class&lt;?&gt; declaringClass = resolveType(declaringType, true);</span>
<span class="removed">-                    if (declaringClass == null) {</span>
<span class="removed">-                        // An optional type that could not be resolved</span>
<span class="removed">-                        entries = Collections.emptyMap();</span>
<span class="removed">-                    } else {</span>
<span class="removed">-                        Map&lt;ResolvedJavaMethodKey, InvocationPlugin&gt; newEntries = new HashMap&lt;&gt;();</span>
<span class="removed">-                        for (MethodKey methodKey : registrations) {</span>
<span class="removed">-                            ResolvedJavaMethod m = methodKey.resolve(declaringClass);</span>
<span class="removed">-                            if (m != null) {</span>
<span class="removed">-                                newEntries.put(new ResolvedJavaMethodKey(m), methodKey.value);</span>
<span class="removed">-                                if (entries != null) {</span>
<span class="removed">-                                    // Another thread finished initializing entries first</span>
<span class="removed">-                                    return;</span>
<span class="new">+        InvocationPlugin get(ResolvedJavaMethod method) {</span>
<span class="new">+            assert !method.isBridge();</span>
<span class="new">+            Binding binding = bindings.get(method.getName());</span>
<span class="new">+            while (binding != null) {</span>
<span class="new">+                if (method.isStatic() == binding.isStatic) {</span>
<span class="new">+                    if (method.getSignature().toMethodDescriptor().startsWith(binding.argumentsDescriptor)) {</span>
<span class="new">+                        return binding.plugin;</span>
                                 }
                             }
<span class="new">+                binding = binding.next;</span>
                         }
<span class="removed">-                        entries = newEntries;</span>
<span class="new">+            return null;</span>
                     }
<span class="new">+</span>
<span class="new">+        public void register(Binding binding, boolean allowOverwrite) {</span>
<span class="new">+            if (allowOverwrite) {</span>
<span class="new">+                if (lookup(binding) != null) {</span>
<span class="new">+                    register(binding);</span>
<span class="new">+                    return;</span>
                 }
<span class="new">+            } else {</span>
<span class="new">+                assert lookup(binding) == null : "a value is already registered for " + binding;</span>
             }
<span class="new">+            register(binding);</span>
         }
 
<span class="removed">-        public InvocationPlugin get(ResolvedJavaMethod method) {</span>
<span class="removed">-            if (!isClosed()) {</span>
<span class="removed">-                initializeMap();</span>
<span class="new">+        InvocationPlugin lookup(Binding binding) {</span>
<span class="new">+            Binding b = bindings.get(binding.name);</span>
<span class="new">+            while (b != null) {</span>
<span class="new">+                if (b.isStatic == binding.isStatic &amp;&amp; b.argumentsDescriptor.equals(binding.argumentsDescriptor)) {</span>
<span class="new">+                    return b.plugin;</span>
             }
<span class="removed">-            return entries.get(new ResolvedJavaMethodKey(method));</span>
<span class="new">+                b = b.next;</span>
         }
<span class="removed">-</span>
<span class="removed">-        public void register(MethodKey methodKey, boolean allowOverwrite) {</span>
<span class="removed">-            assert !isClosed() : "registration is closed: " + methodKey + " " + Arrays.toString(entries.keySet().toArray());</span>
<span class="removed">-            if (allowOverwrite) {</span>
<span class="removed">-                int index = registrations.indexOf(methodKey);</span>
<span class="removed">-                if (index &gt;= 0) {</span>
<span class="removed">-                    registrations.set(index, methodKey);</span>
<span class="removed">-                    return;</span>
<span class="new">+            return null;</span>
                 }
<span class="removed">-            } else {</span>
<span class="removed">-                assert !registrations.contains(methodKey) : "a value is already registered for " + declaringType + "." + methodKey;</span>
<span class="new">+</span>
<span class="new">+        /**</span>
<span class="new">+         * Registers {@code binding}.</span>
<span class="new">+         */</span>
<span class="new">+        void register(Binding binding) {</span>
<span class="new">+            Binding head = bindings.get(binding.name);</span>
<span class="new">+            assert binding.next == null;</span>
<span class="new">+            binding.next = head;</span>
<span class="new">+            bindings.put(binding.name, binding);</span>
             }
<span class="removed">-            registrations.add(methodKey);</span>
         }
 
<span class="removed">-        public boolean isClosed() {</span>
<span class="removed">-            return entries != null;</span>
<span class="new">+    static class LateClassPlugins extends ClassPlugins {</span>
<span class="new">+        static final String CLOSED_LATE_CLASS_PLUGIN = "-----";</span>
<span class="new">+        private final String className;</span>
<span class="new">+        private final LateClassPlugins next;</span>
<span class="new">+</span>
<span class="new">+        LateClassPlugins(LateClassPlugins next, String className) {</span>
<span class="new">+            assert next == null || next.className != CLOSED_LATE_CLASS_PLUGIN : "Late registration of invocation plugins is closed";</span>
<span class="new">+            this.next = next;</span>
<span class="new">+            this.className = className;</span>
         }
     }
 
     /**
<span class="removed">-     * Adds an entry to this map for a specified method.</span>
<span class="new">+     * Registers a binding of a method to an invocation plugin.</span>
      *
<span class="removed">-     * @param value value to be associated with the specified method</span>
<span class="new">+     * @param plugin invocation plugin to be associated with the specified method</span>
      * @param isStatic specifies if the method is static
<span class="removed">-     * @param isOptional specifies if the method is optional</span>
      * @param declaringClass the class declaring the method
      * @param name the name of the method
      * @param argumentTypes the argument types of the method. Element 0 of this array must be
      *            {@code declaringClass} iff the method is non-static.
      * @return an object representing the method
      */
<span class="removed">-    MethodKey put(InvocationPlugin value, boolean isStatic, boolean isOptional, boolean allowOverwrite, Type declaringClass, String name, Type... argumentTypes) {</span>
<span class="new">+    Binding put(InvocationPlugin plugin, boolean isStatic, boolean allowOverwrite, Type declaringClass, String name, Type... argumentTypes) {</span>
<span class="new">+        assert resolvedRegistrations == null : "registration is closed";</span>
<span class="new">+        String internalName = MetaUtil.toInternalName(declaringClass.getTypeName());</span>
         assert isStatic || argumentTypes[0] == declaringClass;
<span class="new">+        assert deferredRegistrations != null : "initial registration is closed - use " + LateRegistration.class.getName() + " for late registrations";</span>
 
<span class="removed">-        String internalName = MetaUtil.toInternalName(declaringClass.getTypeName());</span>
         ClassPlugins classPlugins = registrations.get(internalName);
         if (classPlugins == null) {
<span class="removed">-            classPlugins = new ClassPlugins(declaringClass);</span>
<span class="new">+            classPlugins = new ClassPlugins();</span>
             registrations.put(internalName, classPlugins);
         }
<span class="removed">-        assert isStatic || argumentTypes[0] == declaringClass;</span>
<span class="removed">-        MethodKey methodKey = new MethodKey(metaAccess, value, isStatic, isOptional, name, argumentTypes);</span>
<span class="removed">-        classPlugins.register(methodKey, allowOverwrite);</span>
<span class="removed">-        return methodKey;</span>
<span class="removed">-    }</span>
<span class="removed">-</span>
<span class="removed">-    /**</span>
<span class="removed">-     * Determines if a method denoted by a given {@link MethodKey} is in this map.</span>
<span class="removed">-     */</span>
<span class="removed">-    boolean containsKey(Type declaringType, MethodKey key) {</span>
<span class="removed">-        String internalName = MetaUtil.toInternalName(declaringType.getTypeName());</span>
<span class="removed">-        ClassPlugins classPlugins = registrations.get(internalName);</span>
<span class="removed">-        return classPlugins != null &amp;&amp; classPlugins.registrations.contains(key);</span>
<span class="new">+        Binding binding = new Binding(plugin, isStatic, name, argumentTypes);</span>
<span class="new">+        classPlugins.register(binding, allowOverwrite);</span>
<span class="new">+        return binding;</span>
     }
 
     InvocationPlugin get(ResolvedJavaMethod method) {
<span class="new">+        if (resolvedRegistrations != null) {</span>
<span class="new">+            return resolvedRegistrations.get(method);</span>
<span class="new">+        } else {</span>
<span class="new">+            if (!method.isBridge()) {</span>
<span class="new">+                ResolvedJavaType declaringClass = method.getDeclaringClass();</span>
         flushDeferrables();
<span class="removed">-        String internalName = method.getDeclaringClass().getName();</span>
<span class="new">+                String internalName = declaringClass.getName();</span>
         ClassPlugins classPlugins = registrations.get(internalName);
<span class="new">+                InvocationPlugin res = null;</span>
         if (classPlugins != null) {
<span class="removed">-            return classPlugins.get(method);</span>
<span class="new">+                    res = classPlugins.get(method);</span>
<span class="new">+                }</span>
<span class="new">+                if (res == null) {</span>
<span class="new">+                    LateClassPlugins lcp = findLateClassPlugins(internalName);</span>
<span class="new">+                    if (lcp != null) {</span>
<span class="new">+                        res = lcp.get(method);</span>
<span class="new">+                    }</span>
<span class="new">+                }</span>
<span class="new">+                if (res != null) {</span>
<span class="new">+                    if (canBeIntrinsified(declaringClass)) {</span>
<span class="new">+                        return res;</span>
<span class="new">+                    }</span>
<span class="new">+                }</span>
<span class="new">+            } else {</span>
<span class="new">+                // Supporting plugins for bridge methods would require including</span>
<span class="new">+                // the return type in the registered signature. Until needed,</span>
<span class="new">+                // this extra complexity is best avoided.</span>
<span class="new">+            }</span>
<span class="new">+        }</span>
<span class="new">+        return null;</span>
<span class="new">+    }</span>
<span class="new">+</span>
<span class="new">+    /**</span>
<span class="new">+     * Determines if methods in a given class can have invocation plugins.</span>
<span class="new">+     *</span>
<span class="new">+     * @param declaringClass the class to test</span>
<span class="new">+     */</span>
<span class="new">+    protected boolean canBeIntrinsified(ResolvedJavaType declaringClass) {</span>
<span class="new">+        return true;</span>
<span class="new">+    }</span>
<span class="new">+</span>
<span class="new">+    LateClassPlugins findLateClassPlugins(String internalClassName) {</span>
<span class="new">+        for (LateClassPlugins lcp = lateRegistrations; lcp != null; lcp = lcp.next) {</span>
<span class="new">+            if (lcp.className.equals(internalClassName)) {</span>
<span class="new">+                return lcp;</span>
<span class="new">+            }</span>
         }
         return null;
     }
 
     private void flushDeferrables() {
</pre><hr /><pre>
<span class="newmarker">@@ -637,87 +691,94 @@</span>
                         deferrable.run();
                     }
                     deferredRegistrations = null;
                 }
             }
<span class="removed">-            for (Map.Entry&lt;String, ClassPlugins&gt; e : registrations.entrySet()) {</span>
<span class="removed">-                e.getValue().initializeMap();</span>
             }
         }
<span class="new">+</span>
<span class="new">+    synchronized void registerLate(Type declaringType, List&lt;Binding&gt; bindings) {</span>
<span class="new">+        String internalName = MetaUtil.toInternalName(declaringType.getTypeName());</span>
<span class="new">+        assert findLateClassPlugins(internalName) == null : "Cannot have more than one late registration of invocation plugins for " + internalName;</span>
<span class="new">+        LateClassPlugins lateClassPlugins = new LateClassPlugins(lateRegistrations, internalName);</span>
<span class="new">+        for (Binding b : bindings) {</span>
<span class="new">+            lateClassPlugins.register(b);</span>
<span class="new">+        }</span>
<span class="new">+        lateRegistrations = lateClassPlugins;</span>
<span class="new">+    }</span>
<span class="new">+</span>
<span class="new">+    private synchronized boolean closeLateRegistrations() {</span>
<span class="new">+        if (lateRegistrations == null || lateRegistrations.className != CLOSED_LATE_CLASS_PLUGIN) {</span>
<span class="new">+            lateRegistrations = new LateClassPlugins(lateRegistrations, CLOSED_LATE_CLASS_PLUGIN);</span>
<span class="new">+        }</span>
<span class="new">+        return true;</span>
     }
 
     /**
<span class="removed">-     * Disallows new registrations of new plugins, and creates the internal tables for method</span>
<span class="removed">-     * lookup.</span>
<span class="new">+     * Processes deferred registrations and then closes this object for future registration.</span>
      */
     public void closeRegistration() {
<span class="new">+        assert closeLateRegistrations();</span>
         flushDeferrables();
<span class="removed">-        for (Map.Entry&lt;String, ClassPlugins&gt; e : registrations.entrySet()) {</span>
<span class="removed">-            e.getValue().initializeMap();</span>
<span class="removed">-        }</span>
     }
 
<span class="removed">-    public int size() {</span>
<span class="removed">-        return registrations.size();</span>
<span class="new">+    public boolean isEmpty() {</span>
<span class="new">+        if (resolvedRegistrations != null) {</span>
<span class="new">+            return resolvedRegistrations.isEmpty();</span>
<span class="new">+        }</span>
<span class="new">+        return registrations.size() == 0 &amp;&amp; lateRegistrations == null;</span>
     }
 
     /**
      * The plugins {@linkplain #lookupInvocation(ResolvedJavaMethod) searched} before searching in
      * this object.
      */
     protected final InvocationPlugins parent;
 
<span class="removed">-    private InvocationPlugins(InvocationPlugins parent, MetaAccessProvider metaAccess) {</span>
<span class="removed">-        this.metaAccess = metaAccess;</span>
<span class="removed">-        InvocationPlugins p = parent;</span>
<span class="removed">-        this.parent = p;</span>
<span class="new">+    /**</span>
<span class="new">+     * Creates a set of invocation plugins with no parent.</span>
<span class="new">+     */</span>
<span class="new">+    public InvocationPlugins() {</span>
<span class="new">+        this(null);</span>
     }
 
     /**
<span class="removed">-     * Creates a set of invocation plugins with a non-null {@linkplain #getParent() parent}.</span>
<span class="new">+     * Creates a set of invocation plugins.</span>
<span class="new">+     *</span>
<span class="new">+     * @param parent if non-null, this object will be searched first when looking up plugins</span>
      */
     public InvocationPlugins(InvocationPlugins parent) {
<span class="removed">-        this(parent, parent.getMetaAccess());</span>
<span class="new">+        InvocationPlugins p = parent;</span>
<span class="new">+        this.parent = p;</span>
<span class="new">+        this.registrations = new HashMap&lt;&gt;();</span>
<span class="new">+        this.resolvedRegistrations = null;</span>
     }
 
<span class="removed">-    public InvocationPlugins(Map&lt;ResolvedJavaMethod, InvocationPlugin&gt; plugins, InvocationPlugins parent, MetaAccessProvider metaAccess) {</span>
<span class="removed">-        this.metaAccess = metaAccess;</span>
<span class="new">+    /**</span>
<span class="new">+     * Creates a closed set of invocation plugins for a set of resolved methods. Such an object</span>
<span class="new">+     * cannot have further plugins registered.</span>
<span class="new">+     */</span>
<span class="new">+    public InvocationPlugins(Map&lt;ResolvedJavaMethod, InvocationPlugin&gt; plugins, InvocationPlugins parent) {</span>
         this.parent = parent;
<span class="removed">-</span>
<span class="new">+        this.registrations = null;</span>
         this.deferredRegistrations = null;
<span class="new">+        Map&lt;ResolvedJavaMethod, InvocationPlugin&gt; map = new HashMap&lt;&gt;(plugins.size());</span>
 
         for (Map.Entry&lt;ResolvedJavaMethod, InvocationPlugin&gt; entry : plugins.entrySet()) {
<span class="removed">-            ResolvedJavaMethod method = entry.getKey();</span>
<span class="removed">-            InvocationPlugin plugin = entry.getValue();</span>
<span class="removed">-</span>
<span class="removed">-            String internalName = method.getDeclaringClass().getName();</span>
<span class="removed">-            ClassPlugins classPlugins = registrations.get(internalName);</span>
<span class="removed">-            if (classPlugins == null) {</span>
<span class="removed">-                classPlugins = new ClassPlugins(null);</span>
<span class="removed">-                registrations.put(internalName, classPlugins);</span>
<span class="removed">-                classPlugins.entries = new HashMap&lt;&gt;();</span>
<span class="removed">-            }</span>
<span class="removed">-</span>
<span class="removed">-            classPlugins.entries.put(new ResolvedJavaMethodKey(method), plugin);</span>
<span class="removed">-        }</span>
<span class="new">+            map.put(entry.getKey(), entry.getValue());</span>
     }
<span class="removed">-</span>
<span class="removed">-    public MetaAccessProvider getMetaAccess() {</span>
<span class="removed">-        return metaAccess;</span>
<span class="removed">-    }</span>
<span class="removed">-</span>
<span class="removed">-    public InvocationPlugins(MetaAccessProvider metaAccess) {</span>
<span class="removed">-        this(null, metaAccess);</span>
<span class="new">+        this.resolvedRegistrations = map;</span>
     }
 
     protected void register(InvocationPlugin plugin, boolean isOptional, boolean allowOverwrite, Type declaringClass, String name, Type... argumentTypes) {
         boolean isStatic = argumentTypes.length == 0 || argumentTypes[0] != InvocationPlugin.Receiver.class;
         if (!isStatic) {
             argumentTypes[0] = declaringClass;
         }
<span class="removed">-        MethodKey methodKey = put(plugin, isStatic, isOptional, allowOverwrite, declaringClass, name, argumentTypes);</span>
<span class="removed">-        assert Checker.check(this, declaringClass, methodKey, plugin);</span>
<span class="new">+        Binding binding = put(plugin, isStatic, allowOverwrite, declaringClass, name, argumentTypes);</span>
<span class="new">+        assert Checks.check(this, declaringClass, binding);</span>
<span class="new">+        assert Checks.checkResolvable(isOptional, declaringClass, binding);</span>
     }
 
     /**
      * Registers an invocation plugin for a given method. There must be no plugin currently
      * registered for {@code method}.
</pre><hr /><pre>
<span class="newmarker">@@ -763,48 +824,100 @@</span>
         }
         return get(method);
     }
 
     /**
<span class="removed">-     * Gets the set of methods for which invocation plugins have been registered. Once this method</span>
<span class="removed">-     * is called, no further registrations can be made.</span>
<span class="new">+     * Gets the set of registered invocation plugins.</span>
<span class="new">+     *</span>
<span class="new">+     * @return a map from class names in {@linkplain MetaUtil#toInternalName(String) internal} form</span>
<span class="new">+     *         to the invocation plugin bindings for methods in the class</span>
      */
<span class="removed">-    public Set&lt;ResolvedJavaMethod&gt; getMethods() {</span>
<span class="removed">-        Set&lt;ResolvedJavaMethod&gt; res = new HashSet&lt;&gt;();</span>
<span class="removed">-        if (parent != null) {</span>
<span class="removed">-            res.addAll(parent.getMethods());</span>
<span class="new">+    public Map&lt;String, List&lt;Binding&gt;&gt; getBindings(boolean includeParents) {</span>
<span class="new">+        Map&lt;String, List&lt;Binding&gt;&gt; res = new HashMap&lt;&gt;();</span>
<span class="new">+        if (parent != null &amp;&amp; includeParents) {</span>
<span class="new">+            res.putAll(parent.getBindings(true));</span>
<span class="new">+        }</span>
<span class="new">+        if (resolvedRegistrations != null) {</span>
<span class="new">+            for (Map.Entry&lt;ResolvedJavaMethod, InvocationPlugin&gt; e : resolvedRegistrations.entrySet()) {</span>
<span class="new">+                ResolvedJavaMethod method = e.getKey();</span>
<span class="new">+                InvocationPlugin plugin = e.getValue();</span>
<span class="new">+                String type = method.getDeclaringClass().getName();</span>
<span class="new">+                List&lt;Binding&gt; bindings = res.get(type);</span>
<span class="new">+                if (bindings == null) {</span>
<span class="new">+                    bindings = new ArrayList&lt;&gt;();</span>
<span class="new">+                    res.put(type, bindings);</span>
         }
<span class="new">+                bindings.add(new Binding(method, plugin));</span>
<span class="new">+            }</span>
<span class="new">+        } else {</span>
         flushDeferrables();
<span class="removed">-        for (ClassPlugins cp : registrations.values()) {</span>
<span class="removed">-            for (ResolvedJavaMethodKey key : cp.entries.keySet()) {</span>
<span class="removed">-                res.add(key.method);</span>
<span class="new">+            for (Map.Entry&lt;String, ClassPlugins&gt; e : registrations.entrySet()) {</span>
<span class="new">+                String type = e.getKey();</span>
<span class="new">+                ClassPlugins cp = e.getValue();</span>
<span class="new">+                collectBindingsTo(res, type, cp);</span>
<span class="new">+            }</span>
<span class="new">+            for (LateClassPlugins lcp = lateRegistrations; lcp != null; lcp = lcp.next) {</span>
<span class="new">+                String type = lcp.className;</span>
<span class="new">+                collectBindingsTo(res, type, lcp);</span>
             }
         }
         return res;
     }
 
<span class="new">+    private static void collectBindingsTo(Map&lt;String, List&lt;Binding&gt;&gt; res, String type, ClassPlugins cp) {</span>
<span class="new">+        for (Map.Entry&lt;String, Binding&gt; e : cp.bindings.entrySet()) {</span>
<span class="new">+            List&lt;Binding&gt; bindings = res.get(type);</span>
<span class="new">+            if (bindings == null) {</span>
<span class="new">+                bindings = new ArrayList&lt;&gt;();</span>
<span class="new">+                res.put(type, bindings);</span>
<span class="new">+            }</span>
<span class="new">+            for (Binding b = e.getValue(); b != null; b = b.next) {</span>
<span class="new">+                bindings.add(b);</span>
<span class="new">+            }</span>
<span class="new">+        }</span>
<span class="new">+    }</span>
<span class="new">+</span>
     /**
      * Gets the invocation plugins {@linkplain #lookupInvocation(ResolvedJavaMethod) searched}
      * before searching in this object.
      */
     public InvocationPlugins getParent() {
         return parent;
     }
 
     @Override
     public String toString() {
<span class="new">+        List&lt;String&gt; all = new ArrayList&lt;&gt;();</span>
<span class="new">+        for (Map.Entry&lt;String, List&lt;Binding&gt;&gt; e : getBindings(false).entrySet()) {</span>
<span class="new">+            String c = MetaUtil.internalNameToJava(e.getKey(), true, false);</span>
<span class="new">+            for (Binding b : e.getValue()) {</span>
<span class="new">+                all.add(c + '.' + b);</span>
<span class="new">+            }</span>
<span class="new">+        }</span>
<span class="new">+        Collections.sort(all);</span>
         StringBuilder buf = new StringBuilder();
<span class="removed">-        registrations.forEach((name, cp) -&gt; buf.append(name).append('.').append(cp).append(", "));</span>
<span class="removed">-        String s = buf.toString();</span>
<span class="new">+        String nl = String.format("%n");</span>
<span class="new">+        for (String s : all) {</span>
<span class="new">+            if (buf.length() != 0) {</span>
<span class="new">+                buf.append(nl);</span>
<span class="new">+            }</span>
<span class="new">+            buf.append(s);</span>
<span class="new">+        }</span>
<span class="new">+        if (parent != null) {</span>
         if (buf.length() != 0) {
<span class="removed">-            s = s.substring(buf.length() - ", ".length());</span>
<span class="new">+                buf.append(nl);</span>
         }
<span class="removed">-        return s + " / parent: " + this.parent;</span>
<span class="new">+            buf.append("// parent").append(nl).append(parent);</span>
<span class="new">+        }</span>
<span class="new">+        return buf.toString();</span>
     }
 
<span class="removed">-    private static class Checker {</span>
<span class="removed">-        private static final int MAX_ARITY = 5;</span>
<span class="new">+    /**</span>
<span class="new">+     * Code only used in assertions. Putting this in a separate class reduces class load time.</span>
<span class="new">+     */</span>
<span class="new">+    private static class Checks {</span>
<span class="new">+        private static final int MAX_ARITY = 7;</span>
         /**
          * The set of all {@link InvocationPlugin#apply} method signatures.
          */
         static final Class&lt;?&gt;[][] SIGS;
 
</pre><hr /><pre>
<span class="newmarker">@@ -826,14 +939,21 @@</span>
             assert sigs.indexOf(null) == -1 : format("need to add an apply() method to %s that takes %d %s arguments ", InvocationPlugin.class.getName(), sigs.indexOf(null),
                             ValueNode.class.getSimpleName());
             SIGS = sigs.toArray(new Class&lt;?&gt;[sigs.size()][]);
         }
 
<span class="removed">-        public static boolean check(InvocationPlugins plugins, Type declaringType, MethodKey method, InvocationPlugin plugin) {</span>
<span class="new">+        static boolean containsBinding(InvocationPlugins p, Type declaringType, Binding key) {</span>
<span class="new">+            String internalName = MetaUtil.toInternalName(declaringType.getTypeName());</span>
<span class="new">+            ClassPlugins classPlugins = p.registrations.get(internalName);</span>
<span class="new">+            return classPlugins != null &amp;&amp; classPlugins.lookup(key) != null;</span>
<span class="new">+        }</span>
<span class="new">+</span>
<span class="new">+        public static boolean check(InvocationPlugins plugins, Type declaringType, Binding binding) {</span>
<span class="new">+            InvocationPlugin plugin = binding.plugin;</span>
             InvocationPlugins p = plugins.parent;
             while (p != null) {
<span class="removed">-                assert !p.containsKey(declaringType, method) : "a plugin is already registered for " + method;</span>
<span class="new">+                assert !containsBinding(p, declaringType, binding) : "a plugin is already registered for " + binding;</span>
                 p = p.parent;
             }
             if (plugin instanceof ForeignCallPlugin || plugin instanceof GeneratedInvocationPlugin) {
                 return true;
             }
</pre><hr /><pre>
<span class="newmarker">@@ -841,21 +961,38 @@</span>
                 MethodSubstitutionPlugin msplugin = (MethodSubstitutionPlugin) plugin;
                 Method substitute = msplugin.getJavaSubstitute();
                 assert substitute.getAnnotation(MethodSubstitution.class) != null : format("Substitute method must be annotated with @%s: %s", MethodSubstitution.class.getSimpleName(), substitute);
                 return true;
             }
<span class="removed">-            int arguments = method.getDeclaredParameterCount();</span>
<span class="removed">-            assert arguments &lt; SIGS.length : format("need to extend %s to support method with %d arguments: %s", InvocationPlugin.class.getSimpleName(), arguments, method);</span>
<span class="new">+            int arguments = parseParameters(binding.argumentsDescriptor).size();</span>
<span class="new">+            assert arguments &lt; SIGS.length : format("need to extend %s to support method with %d arguments: %s", InvocationPlugin.class.getSimpleName(), arguments, binding);</span>
             for (Method m : plugin.getClass().getDeclaredMethods()) {
                 if (m.getName().equals("apply")) {
                     Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();
                     if (Arrays.equals(SIGS[arguments], parameterTypes)) {
                         return true;
                     }
                 }
             }
<span class="removed">-            throw new AssertionError(format("graph builder plugin for %s not found", method));</span>
<span class="new">+            throw new AssertionError(format("graph builder plugin for %s not found", binding));</span>
<span class="new">+        }</span>
<span class="new">+</span>
<span class="new">+        static boolean checkResolvable(boolean isOptional, Type declaringType, Binding binding) {</span>
<span class="new">+            Class&lt;?&gt; declaringClass = InvocationPlugins.resolveType(declaringType, isOptional);</span>
<span class="new">+            if (declaringClass == null) {</span>
<span class="new">+                return true;</span>
<span class="new">+            }</span>
<span class="new">+            if (binding.name.equals("&lt;init&gt;")) {</span>
<span class="new">+                if (resolveConstructor(declaringClass, binding) == null &amp;&amp; !isOptional) {</span>
<span class="new">+                    throw new AssertionError(String.format("Constructor not found: %s%s", declaringClass.getName(), binding.argumentsDescriptor));</span>
<span class="new">+                }</span>
<span class="new">+            } else {</span>
<span class="new">+                if (resolveMethod(declaringClass, binding) == null &amp;&amp; !isOptional) {</span>
<span class="new">+                    throw new AssertionError(String.format("Method not found: %s.%s%s", declaringClass.getName(), binding.name, binding.argumentsDescriptor));</span>
<span class="new">+                }</span>
<span class="new">+            }</span>
<span class="new">+            return true;</span>
         }
     }
 
     /**
      * Checks a set of nodes added to the graph by an {@link InvocationPlugin}.
</pre><hr /><pre>
<span class="newmarker">@@ -902,33 +1039,121 @@</span>
      */
     public static Class&lt;?&gt; resolveType(Type type, boolean optional) {
         if (type instanceof Class) {
             return (Class&lt;?&gt;) type;
         }
<span class="removed">-        if (optional &amp;&amp; type instanceof OptionalLazySymbol) {</span>
<span class="new">+        if (type instanceof OptionalLazySymbol) {</span>
             return ((OptionalLazySymbol) type).resolve();
         }
         return resolveClass(type.getTypeName(), optional);
     }
 
<span class="removed">-    private static final Class&lt;?&gt;[] NO_CLASSES = {};</span>
<span class="new">+    private static List&lt;String&gt; toInternalTypeNames(Class&lt;?&gt;[] types) {</span>
<span class="new">+        String[] res = new String[types.length];</span>
<span class="new">+        for (int i = 0; i &lt; types.length; i++) {</span>
<span class="new">+            res[i] = MetaUtil.toInternalName(types[i].getTypeName());</span>
<span class="new">+        }</span>
<span class="new">+        return Arrays.asList(res);</span>
<span class="new">+    }</span>
 
     /**
<span class="removed">-     * Resolves an array of {@link Type}s to an array of {@link Class}es.</span>
<span class="new">+     * Resolves a given binding to a method in a given class. If more than one method with the</span>
<span class="new">+     * parameter types matching {@code binding} is found and the return types of all the matching</span>
<span class="new">+     * methods form an inheritance chain, the one with the most specific type is returned; otherwise</span>
<span class="new">+     * {@link NoSuchMethodError} is thrown.</span>
      *
<span class="removed">-     * @param types the types to resolve</span>
<span class="removed">-     * @param from the initial index of the range to be resolved, inclusive</span>
<span class="removed">-     * @param to the final index of the range to be resolved, exclusive</span>
<span class="removed">-     * @return the resolved class or null if resolution fails and {@code optional} is true</span>
<span class="new">+     * @param declaringClass the class to search for a method matching {@code binding}</span>
<span class="new">+     * @return the method (if any) in {@code declaringClass} matching binding</span>
<span class="new">+     */</span>
<span class="new">+    public static Method resolveMethod(Class&lt;?&gt; declaringClass, Binding binding) {</span>
<span class="new">+        if (binding.name.equals("&lt;init&gt;")) {</span>
<span class="new">+            return null;</span>
<span class="new">+        }</span>
<span class="new">+        Method[] methods = declaringClass.getDeclaredMethods();</span>
<span class="new">+        List&lt;String&gt; parameterTypeNames = parseParameters(binding.argumentsDescriptor);</span>
<span class="new">+        for (int i = 0; i &lt; methods.length; ++i) {</span>
<span class="new">+            Method m = methods[i];</span>
<span class="new">+            if (binding.isStatic == Modifier.isStatic(m.getModifiers()) &amp;&amp; m.getName().equals(binding.name)) {</span>
<span class="new">+                if (parameterTypeNames.equals(toInternalTypeNames(m.getParameterTypes()))) {</span>
<span class="new">+                    for (int j = i + 1; j &lt; methods.length; ++j) {</span>
<span class="new">+                        Method other = methods[j];</span>
<span class="new">+                        if (binding.isStatic == Modifier.isStatic(other.getModifiers()) &amp;&amp; other.getName().equals(binding.name)) {</span>
<span class="new">+                            if (parameterTypeNames.equals(toInternalTypeNames(other.getParameterTypes()))) {</span>
<span class="new">+                                if (m.getReturnType().isAssignableFrom(other.getReturnType())) {</span>
<span class="new">+                                    // `other` has a more specific return type - choose it</span>
<span class="new">+                                    // (m is most likely a bridge method)</span>
<span class="new">+                                    m = other;</span>
<span class="new">+                                } else {</span>
<span class="new">+                                    if (!other.getReturnType().isAssignableFrom(m.getReturnType())) {</span>
<span class="new">+                                        throw new NoSuchMethodError(String.format(</span>
<span class="new">+                                                        "Found 2 methods with same name and parameter types but unrelated return types:%n %s%n %s", m, other));</span>
<span class="new">+                                    }</span>
<span class="new">+                                }</span>
<span class="new">+                            }</span>
<span class="new">+                        }</span>
<span class="new">+                    }</span>
<span class="new">+                    return m;</span>
<span class="new">+                }</span>
<span class="new">+            }</span>
<span class="new">+        }</span>
<span class="new">+        return null;</span>
<span class="new">+    }</span>
<span class="new">+</span>
<span class="new">+    /**</span>
<span class="new">+     * Resolves a given binding to a constructor in a given class.</span>
<span class="new">+     *</span>
<span class="new">+     * @param declaringClass the class to search for a constructor matching {@code binding}</span>
<span class="new">+     * @return the constructor (if any) in {@code declaringClass} matching binding</span>
      */
<span class="removed">-    public static Class&lt;?&gt;[] resolveTypes(Type[] types, int from, int to) {</span>
<span class="removed">-        int length = to - from;</span>
<span class="removed">-        if (length &lt;= 0) {</span>
<span class="removed">-            return NO_CLASSES;</span>
<span class="removed">-        }</span>
<span class="removed">-        Class&lt;?&gt;[] classes = new Class&lt;?&gt;[length];</span>
<span class="removed">-        for (int i = 0; i &lt; length; i++) {</span>
<span class="removed">-            classes[i] = resolveType(types[i + from], false);</span>
<span class="new">+    public static Constructor&lt;?&gt; resolveConstructor(Class&lt;?&gt; declaringClass, Binding binding) {</span>
<span class="new">+        if (!binding.name.equals("&lt;init&gt;")) {</span>
<span class="new">+            return null;</span>
<span class="new">+        }</span>
<span class="new">+        Constructor&lt;?&gt;[] constructors = declaringClass.getDeclaredConstructors();</span>
<span class="new">+        List&lt;String&gt; parameterTypeNames = parseParameters(binding.argumentsDescriptor);</span>
<span class="new">+        for (int i = 0; i &lt; constructors.length; ++i) {</span>
<span class="new">+            Constructor&lt;?&gt; c = constructors[i];</span>
<span class="new">+            if (parameterTypeNames.equals(toInternalTypeNames(c.getParameterTypes()))) {</span>
<span class="new">+                return c;</span>
         }
<span class="removed">-        return classes;</span>
<span class="new">+        }</span>
<span class="new">+        return null;</span>
<span class="new">+    }</span>
<span class="new">+</span>
<span class="new">+    private static List&lt;String&gt; parseParameters(String argumentsDescriptor) {</span>
<span class="new">+        assert argumentsDescriptor.startsWith("(") &amp;&amp; argumentsDescriptor.endsWith(")") : argumentsDescriptor;</span>
<span class="new">+        List&lt;String&gt; res = new ArrayList&lt;&gt;();</span>
<span class="new">+        int cur = 1;</span>
<span class="new">+        int end = argumentsDescriptor.length() - 1;</span>
<span class="new">+        while (cur != end) {</span>
<span class="new">+            char first;</span>
<span class="new">+            int start = cur;</span>
<span class="new">+            do {</span>
<span class="new">+                first = argumentsDescriptor.charAt(cur++);</span>
<span class="new">+            } while (first == '[');</span>
<span class="new">+</span>
<span class="new">+            switch (first) {</span>
<span class="new">+                case 'L':</span>
<span class="new">+                    int endObject = argumentsDescriptor.indexOf(';', cur);</span>
<span class="new">+                    if (endObject == -1) {</span>
<span class="new">+                        throw new GraalError("Invalid object type at index %d in signature: %s", cur, argumentsDescriptor);</span>
<span class="new">+                    }</span>
<span class="new">+                    cur = endObject + 1;</span>
<span class="new">+                    break;</span>
<span class="new">+                case 'V':</span>
<span class="new">+                case 'I':</span>
<span class="new">+                case 'B':</span>
<span class="new">+                case 'C':</span>
<span class="new">+                case 'D':</span>
<span class="new">+                case 'F':</span>
<span class="new">+                case 'J':</span>
<span class="new">+                case 'S':</span>
<span class="new">+                case 'Z':</span>
<span class="new">+                    break;</span>
<span class="new">+                default:</span>
<span class="new">+                    throw new GraalError("Invalid character at index %d in signature: %s", cur, argumentsDescriptor);</span>
<span class="new">+            }</span>
<span class="new">+            res.add(argumentsDescriptor.substring(start, cur));</span>
<span class="new">+        }</span>
<span class="new">+        return res;</span>
     }
 }
</pre>
<center><a href='../../../../../../../../../../../src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/InvocationPlugin.java.udiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../../src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.printer/src/org/graalvm/compiler/printer/GraphPrinter.java.udiff.html' target='_top'>next &gt</a></center>
</body></html>

