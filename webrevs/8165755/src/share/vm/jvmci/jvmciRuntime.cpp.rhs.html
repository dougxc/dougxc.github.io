<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "asm/codeBuffer.hpp"
  26 #include "classfile/javaClasses.inline.hpp"
  27 #include "code/codeCache.hpp"
  28 #include "compiler/compileBroker.hpp"
  29 #include "compiler/disassembler.hpp"
  30 #include "jvmci/jvmciRuntime.hpp"
  31 #include "jvmci/jvmciCompilerToVM.hpp"
  32 #include "jvmci/jvmciCompiler.hpp"
  33 #include "jvmci/jvmciJavaClasses.hpp"
  34 #include "jvmci/jvmciEnv.hpp"
  35 #include "logging/log.hpp"
  36 #include "memory/oopFactory.hpp"
  37 #include "memory/resourceArea.hpp"
  38 #include "oops/oop.inline.hpp"
  39 #include "oops/objArrayOop.inline.hpp"
  40 #include "prims/jvm.h"
  41 #include "runtime/biasedLocking.hpp"
  42 #include "runtime/interfaceSupport.hpp"
  43 #include "runtime/reflection.hpp"
  44 #include "runtime/sharedRuntime.hpp"
  45 #include "utilities/debug.hpp"
  46 #include "utilities/defaultStream.hpp"
  47 #include "utilities/macros.hpp"
  48 
  49 #if defined(_MSC_VER)
  50 #define strtoll _strtoi64
  51 #endif
  52 
  53 jobject JVMCIRuntime::_HotSpotJVMCIRuntime_instance = NULL;
  54 bool JVMCIRuntime::_HotSpotJVMCIRuntime_initialized = false;
  55 bool JVMCIRuntime::_well_known_classes_initialized = false;
  56 int JVMCIRuntime::_trivial_prefixes_count = 0;
  57 char** JVMCIRuntime::_trivial_prefixes = NULL;
  58 JVMCIRuntime::CompLevelAdjustment JVMCIRuntime::_comp_level_adjustment = JVMCIRuntime::none;
  59 bool JVMCIRuntime::_shutdown_called = false;
  60 
  61 BasicType JVMCIRuntime::kindToBasicType(Handle kind, TRAPS) {
  62   if (kind.is_null()) {
  63     THROW_(vmSymbols::java_lang_NullPointerException(), T_ILLEGAL);
  64   }
  65   jchar ch = JavaKind::typeChar(kind);
  66   switch(ch) {
  67     case 'Z': return T_BOOLEAN;
  68     case 'B': return T_BYTE;
  69     case 'S': return T_SHORT;
  70     case 'C': return T_CHAR;
  71     case 'I': return T_INT;
  72     case 'F': return T_FLOAT;
  73     case 'J': return T_LONG;
  74     case 'D': return T_DOUBLE;
  75     case 'A': return T_OBJECT;
  76     case '-': return T_ILLEGAL;
  77     default:
  78       JVMCI_ERROR_(T_ILLEGAL, "unexpected Kind: %c", ch);
  79   }
  80 }
  81 
  82 // Simple helper to see if the caller of a runtime stub which
  83 // entered the VM has been deoptimized
  84 
  85 static bool caller_is_deopted() {
  86   JavaThread* thread = JavaThread::current();
  87   RegisterMap reg_map(thread, false);
  88   frame runtime_frame = thread-&gt;last_frame();
  89   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  90   assert(caller_frame.is_compiled_frame(), "must be compiled");
  91   return caller_frame.is_deoptimized_frame();
  92 }
  93 
  94 // Stress deoptimization
  95 static void deopt_caller() {
  96   if ( !caller_is_deopted()) {
  97     JavaThread* thread = JavaThread::current();
  98     RegisterMap reg_map(thread, false);
  99     frame runtime_frame = thread-&gt;last_frame();
 100     frame caller_frame = runtime_frame.sender(&amp;reg_map);
 101     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
 102     assert(caller_is_deopted(), "Must be deoptimized");
 103   }
 104 }
 105 
 106 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance(JavaThread* thread, Klass* klass))
 107   JRT_BLOCK;
 108   assert(klass-&gt;is_klass(), "not a class");
 109   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 110   instanceKlassHandle h(thread, klass);
 111   h-&gt;check_valid_for_instantiation(true, CHECK);
 112   // make sure klass is initialized
 113   h-&gt;initialize(CHECK);
 114   // allocate instance and return via TLS
 115   oop obj = h-&gt;allocate_instance(CHECK);
 116   thread-&gt;set_vm_result(obj);
 117   JRT_BLOCK_END;
 118 
 119   if (ReduceInitialCardMarks) {
 120     new_store_pre_barrier(thread);
 121   }
 122 JRT_END
 123 
 124 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array(JavaThread* thread, Klass* array_klass, jint length))
 125   JRT_BLOCK;
 126   // Note: no handle for klass needed since they are not used
 127   //       anymore after new_objArray() and no GC can happen before.
 128   //       (This may have to change if this code changes!)
 129   assert(array_klass-&gt;is_klass(), "not a class");
 130   oop obj;
 131   if (array_klass-&gt;is_typeArray_klass()) {
 132     BasicType elt_type = TypeArrayKlass::cast(array_klass)-&gt;element_type();
 133     obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 134   } else {
 135     Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
 136     Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();
 137     obj = oopFactory::new_objArray(elem_klass, length, CHECK);
 138   }
 139   thread-&gt;set_vm_result(obj);
 140   // This is pretty rare but this runtime patch is stressful to deoptimization
 141   // if we deoptimize here so force a deopt to stress the path.
 142   if (DeoptimizeALot) {
 143     static int deopts = 0;
 144     // Alternate between deoptimizing and raising an error (which will also cause a deopt)
 145     if (deopts++ % 2 == 0) {
 146       ResourceMark rm(THREAD);
 147       THROW(vmSymbols::java_lang_OutOfMemoryError());
 148     } else {
 149       deopt_caller();
 150     }
 151   }
 152   JRT_BLOCK_END;
 153 
 154   if (ReduceInitialCardMarks) {
 155     new_store_pre_barrier(thread);
 156   }
 157 JRT_END
 158 
 159 void JVMCIRuntime::new_store_pre_barrier(JavaThread* thread) {
 160   // After any safepoint, just before going back to compiled code,
 161   // we inform the GC that we will be doing initializing writes to
 162   // this object in the future without emitting card-marks, so
 163   // GC may take any compensating steps.
 164   // NOTE: Keep this code consistent with GraphKit::store_barrier.
 165 
 166   oop new_obj = thread-&gt;vm_result();
 167   if (new_obj == NULL)  return;
 168 
 169   assert(Universe::heap()-&gt;can_elide_tlab_store_barriers(),
 170          "compiler must check this first");
 171   // GC may decide to give back a safer copy of new_obj.
 172   new_obj = Universe::heap()-&gt;new_store_pre_barrier(thread, new_obj);
 173   thread-&gt;set_vm_result(new_obj);
 174 }
 175 
 176 JRT_ENTRY(void, JVMCIRuntime::new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims))
 177   assert(klass-&gt;is_klass(), "not a class");
 178   assert(rank &gt;= 1, "rank must be nonzero");
 179   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 180   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
 181   thread-&gt;set_vm_result(obj);
 182 JRT_END
 183 
 184 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array(JavaThread* thread, oopDesc* element_mirror, jint length))
 185   oop obj = Reflection::reflect_new_array(element_mirror, length, CHECK);
 186   thread-&gt;set_vm_result(obj);
 187 JRT_END
 188 
 189 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance(JavaThread* thread, oopDesc* type_mirror))
 190   instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(type_mirror));
 191 
 192   if (klass == NULL) {
 193     ResourceMark rm(THREAD);
 194     THROW(vmSymbols::java_lang_InstantiationException());
 195   }
 196 
 197   // Create new instance (the receiver)
 198   klass-&gt;check_valid_for_instantiation(false, CHECK);
 199 
 200   // Make sure klass gets initialized
 201   klass-&gt;initialize(CHECK);
 202 
 203   oop obj = klass-&gt;allocate_instance(CHECK);
 204   thread-&gt;set_vm_result(obj);
 205 JRT_END
 206 
 207 extern void vm_exit(int code);
 208 
 209 // Enter this method from compiled code handler below. This is where we transition
 210 // to VM mode. This is done as a helper routine so that the method called directly
 211 // from compiled code does not have to transition to VM. This allows the entry
 212 // method to see if the nmethod that we have just looked up a handler for has
 213 // been deoptimized while we were in the vm. This simplifies the assembly code
 214 // cpu directories.
 215 //
 216 // We are entering here from exception stub (via the entry method below)
 217 // If there is a compiled exception handler in this method, we will continue there;
 218 // otherwise we will unwind the stack and continue at the caller of top frame method
 219 // Note: we enter in Java using a special JRT wrapper. This wrapper allows us to
 220 // control the area where we can allow a safepoint. After we exit the safepoint area we can
 221 // check to see if the handler we are going to return is now in a nmethod that has
 222 // been deoptimized. If that is the case we return the deopt blob
 223 // unpack_with_exception entry instead. This makes life for the exception blob easier
 224 // because making that same check and diverting is painful from assembly language.
 225 JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, CompiledMethod*&amp; cm))
 226   // Reset method handle flag.
 227   thread-&gt;set_is_method_handle_return(false);
 228 
 229   Handle exception(thread, ex);
 230   cm = CodeCache::find_compiled(pc);
 231   assert(cm != NULL, "this is not a compiled method");
 232   // Adjust the pc as needed/
 233   if (cm-&gt;is_deopt_pc(pc)) {
 234     RegisterMap map(thread, false);
 235     frame exception_frame = thread-&gt;last_frame().sender(&amp;map);
 236     // if the frame isn't deopted then pc must not correspond to the caller of last_frame
 237     assert(exception_frame.is_deoptimized_frame(), "must be deopted");
 238     pc = exception_frame.pc();
 239   }
 240 #ifdef ASSERT
 241   assert(exception.not_null(), "NULL exceptions should be handled by throw_exception");
 242   assert(exception-&gt;is_oop(), "just checking");
 243   // Check that exception is a subclass of Throwable, otherwise we have a VerifyError
 244   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
 245     if (ExitVMOnVerifyError) vm_exit(-1);
 246     ShouldNotReachHere();
 247   }
 248 #endif
 249 
 250   // Check the stack guard pages and reenable them if necessary and there is
 251   // enough space on the stack to do so.  Use fast exceptions only if the guard
 252   // pages are enabled.
 253   bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
 254   if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
 255 
 256   if (JvmtiExport::can_post_on_exceptions()) {
 257     // To ensure correct notification of exception catches and throws
 258     // we have to deoptimize here.  If we attempted to notify the
 259     // catches and throws during this exception lookup it's possible
 260     // we could deoptimize on the way out of the VM and end back in
 261     // the interpreter at the throw site.  This would result in double
 262     // notifications since the interpreter would also notify about
 263     // these same catches and throws as it unwound the frame.
 264 
 265     RegisterMap reg_map(thread);
 266     frame stub_frame = thread-&gt;last_frame();
 267     frame caller_frame = stub_frame.sender(&amp;reg_map);
 268 
 269     // We don't really want to deoptimize the nmethod itself since we
 270     // can actually continue in the exception handler ourselves but I
 271     // don't see an easy way to have the desired effect.
 272     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
 273     assert(caller_is_deopted(), "Must be deoptimized");
 274 
 275     return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 276   }
 277 
 278   // ExceptionCache is used only for exceptions at call sites and not for implicit exceptions
 279   if (guard_pages_enabled) {
 280     address fast_continuation = cm-&gt;handler_for_exception_and_pc(exception, pc);
 281     if (fast_continuation != NULL) {
 282       // Set flag if return address is a method handle call site.
 283       thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 284       return fast_continuation;
 285     }
 286   }
 287 
 288   // If the stack guard pages are enabled, check whether there is a handler in
 289   // the current method.  Otherwise (guard pages disabled), force an unwind and
 290   // skip the exception cache update (i.e., just leave continuation==NULL).
 291   address continuation = NULL;
 292   if (guard_pages_enabled) {
 293 
 294     // New exception handling mechanism can support inlined methods
 295     // with exception handlers since the mappings are from PC to PC
 296 
 297     // debugging support
 298     // tracing
 299     if (log_is_enabled(Info, exceptions)) {
 300       ResourceMark rm;
 301       stringStream tempst;
 302       tempst.print("compiled method &lt;%s&gt;\n"
 303                    " at PC" INTPTR_FORMAT " for thread " INTPTR_FORMAT,
 304                    cm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
 305       Exceptions::log_exception(exception, tempst);
 306     }
 307     // for AbortVMOnException flag
 308     NOT_PRODUCT(Exceptions::debug_check_abort(exception));
 309 
 310     // Clear out the exception oop and pc since looking up an
 311     // exception handler can cause class loading, which might throw an
 312     // exception and those fields are expected to be clear during
 313     // normal bytecode execution.
 314     thread-&gt;clear_exception_oop_and_pc();
 315 
 316     bool recursive_exception = false;
 317     continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);
 318     // If an exception was thrown during exception dispatch, the exception oop may have changed
 319     thread-&gt;set_exception_oop(exception());
 320     thread-&gt;set_exception_pc(pc);
 321 
 322     // the exception cache is used only by non-implicit exceptions
 323     // Update the exception cache only when there didn't happen
 324     // another exception during the computation of the compiled
 325     // exception handler. Checking for exception oop equality is not
 326     // sufficient because some exceptions are pre-allocated and reused.
 327     if (continuation != NULL &amp;&amp; !recursive_exception &amp;&amp; !SharedRuntime::deopt_blob()-&gt;contains(continuation)) {
 328       cm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
 329     }
 330   }
 331 
 332   // Set flag if return address is a method handle call site.
 333   thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 334 
 335   if (log_is_enabled(Info, exceptions)) {
 336     ResourceMark rm;
 337     log_info(exceptions)("Thread " PTR_FORMAT " continuing at PC " PTR_FORMAT
 338                          " for exception thrown at PC " PTR_FORMAT,
 339                          p2i(thread), p2i(continuation), p2i(pc));
 340   }
 341 
 342   return continuation;
 343 JRT_END
 344 
 345 // Enter this method from compiled code only if there is a Java exception handler
 346 // in the method handling the exception.
 347 // We are entering here from exception stub. We don't do a normal VM transition here.
 348 // We do it in a helper. This is so we can check to see if the nmethod we have just
 349 // searched for an exception handler has been deoptimized in the meantime.
 350 address JVMCIRuntime::exception_handler_for_pc(JavaThread* thread) {
 351   oop exception = thread-&gt;exception_oop();
 352   address pc = thread-&gt;exception_pc();
 353   // Still in Java mode
 354   DEBUG_ONLY(ResetNoHandleMark rnhm);
 355   CompiledMethod* cm = NULL;
 356   address continuation = NULL;
 357   {
 358     // Enter VM mode by calling the helper
 359     ResetNoHandleMark rnhm;
 360     continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);
 361   }
 362   // Back in JAVA, use no oops DON'T safepoint
 363 
 364   // Now check to see if the compiled method we were called from is now deoptimized.
 365   // If so we must return to the deopt blob and deoptimize the nmethod
 366   if (cm != NULL &amp;&amp; caller_is_deopted()) {
 367     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 368   }
 369 
 370   assert(continuation != NULL, "no handler found");
 371   return continuation;
 372 }
 373 
 374 JRT_ENTRY_NO_ASYNC(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 375   IF_TRACE_jvmci_3 {
 376     char type[O_BUFLEN];
 377     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
 378     markOop mark = obj-&gt;mark();
 379     TRACE_jvmci_3("%s: entered locking slow case with obj=" INTPTR_FORMAT ", type=%s, mark=" INTPTR_FORMAT ", lock=" INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, p2i(mark), p2i(lock));
 380     tty-&gt;flush();
 381   }
 382 #ifdef ASSERT
 383   if (PrintBiasedLockingStatistics) {
 384     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
 385   }
 386 #endif
 387   Handle h_obj(thread, obj);
 388   assert(h_obj()-&gt;is_oop(), "must be NULL or an object");
 389   if (UseBiasedLocking) {
 390     // Retry fast entry if bias is revoked to avoid unnecessary inflation
 391     ObjectSynchronizer::fast_enter(h_obj, lock, true, CHECK);
 392   } else {
 393     if (JVMCIUseFastLocking) {
 394       // When using fast locking, the compiled code has already tried the fast case
 395       ObjectSynchronizer::slow_enter(h_obj, lock, THREAD);
 396     } else {
 397       ObjectSynchronizer::fast_enter(h_obj, lock, false, THREAD);
 398     }
 399   }
 400   TRACE_jvmci_3("%s: exiting locking slow with obj=" INTPTR_FORMAT, thread-&gt;name(), p2i(obj));
 401 JRT_END
 402 
 403 JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 404   assert(thread == JavaThread::current(), "threads must correspond");
 405   assert(thread-&gt;last_Java_sp(), "last_Java_sp must be set");
 406   // monitorexit is non-blocking (leaf routine) =&gt; no exceptions can be thrown
 407   EXCEPTION_MARK;
 408 
 409 #ifdef DEBUG
 410   if (!obj-&gt;is_oop()) {
 411     ResetNoHandleMark rhm;
 412     nmethod* method = thread-&gt;last_frame().cb()-&gt;as_nmethod_or_null();
 413     if (method != NULL) {
 414       tty-&gt;print_cr("ERROR in monitorexit in method %s wrong obj " INTPTR_FORMAT, method-&gt;name(), p2i(obj));
 415     }
 416     thread-&gt;print_stack_on(tty);
 417     assert(false, "invalid lock object pointer dected");
 418   }
 419 #endif
 420 
 421   if (JVMCIUseFastLocking) {
 422     // When using fast locking, the compiled code has already tried the fast case
 423     ObjectSynchronizer::slow_exit(obj, lock, THREAD);
 424   } else {
 425     ObjectSynchronizer::fast_exit(obj, lock, THREAD);
 426   }
 427   IF_TRACE_jvmci_3 {
 428     char type[O_BUFLEN];
 429     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
 430     TRACE_jvmci_3("%s: exited locking slow case with obj=" INTPTR_FORMAT ", type=%s, mark=" INTPTR_FORMAT ", lock=" INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, p2i(obj-&gt;mark()), p2i(lock));
 431     tty-&gt;flush();
 432   }
 433 JRT_END
 434 
 435 JRT_ENTRY(void, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))
 436   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);
 437   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 438 JRT_END
 439 
 440 JRT_ENTRY(void, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))
 441   ResourceMark rm(thread);
 442   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);
 443   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass-&gt;external_name());
 444 JRT_END
 445 
 446 JRT_ENTRY(void, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))
 447   ResourceMark rm(thread);
 448   const char* message = SharedRuntime::generate_class_cast_message(caster_klass, target_klass);
 449   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);
 450   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 451 JRT_END
 452 
 453 JRT_LEAF(void, JVMCIRuntime::log_object(JavaThread* thread, oopDesc* obj, bool as_string, bool newline))
 454   ttyLocker ttyl;
 455 
 456   if (obj == NULL) {
 457     tty-&gt;print("NULL");
 458   } else if (obj-&gt;is_oop_or_null(true) &amp;&amp; (!as_string || !java_lang_String::is_instance(obj))) {
 459     if (obj-&gt;is_oop_or_null(true)) {
 460       char buf[O_BUFLEN];
 461       tty-&gt;print("%s@" INTPTR_FORMAT, obj-&gt;klass()-&gt;name()-&gt;as_C_string(buf, O_BUFLEN), p2i(obj));
 462     } else {
 463       tty-&gt;print(INTPTR_FORMAT, p2i(obj));
 464     }
 465   } else {
 466     ResourceMark rm;
 467     assert(obj != NULL &amp;&amp; java_lang_String::is_instance(obj), "must be");
 468     char *buf = java_lang_String::as_utf8_string(obj);
 469     tty-&gt;print_raw(buf);
 470   }
 471   if (newline) {
 472     tty-&gt;cr();
 473   }
 474 JRT_END
 475 
 476 JRT_LEAF(void, JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj))
 477   thread-&gt;satb_mark_queue().enqueue(obj);
 478 JRT_END
 479 
 480 JRT_LEAF(void, JVMCIRuntime::write_barrier_post(JavaThread* thread, void* card_addr))
 481   thread-&gt;dirty_card_queue().enqueue(card_addr);
 482 JRT_END
 483 
 484 JRT_LEAF(jboolean, JVMCIRuntime::validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child))
 485   bool ret = true;
 486   if(!Universe::heap()-&gt;is_in_closed_subset(parent)) {
 487     tty-&gt;print_cr("Parent Object " INTPTR_FORMAT " not in heap", p2i(parent));
 488     parent-&gt;print();
 489     ret=false;
 490   }
 491   if(!Universe::heap()-&gt;is_in_closed_subset(child)) {
 492     tty-&gt;print_cr("Child Object " INTPTR_FORMAT " not in heap", p2i(child));
 493     child-&gt;print();
 494     ret=false;
 495   }
 496   return (jint)ret;
 497 JRT_END
 498 
 499 JRT_ENTRY(void, JVMCIRuntime::vm_error(JavaThread* thread, jlong where, jlong format, jlong value))
 500   ResourceMark rm;
 501   const char *error_msg = where == 0L ? "&lt;internal JVMCI error&gt;" : (char*) (address) where;
 502   char *detail_msg = NULL;
 503   if (format != 0L) {
 504     const char* buf = (char*) (address) format;
 505     size_t detail_msg_length = strlen(buf) * 2;
 506     detail_msg = (char *) NEW_RESOURCE_ARRAY(u_char, detail_msg_length);
 507     jio_snprintf(detail_msg, detail_msg_length, buf, value);
 508     report_vm_error(__FILE__, __LINE__, error_msg, "%s", detail_msg);
 509   } else {
 510     report_vm_error(__FILE__, __LINE__, error_msg);
 511   }
 512 JRT_END
 513 
 514 JRT_LEAF(oopDesc*, JVMCIRuntime::load_and_clear_exception(JavaThread* thread))
 515   oop exception = thread-&gt;exception_oop();
 516   assert(exception != NULL, "npe");
 517   thread-&gt;set_exception_oop(NULL);
 518   thread-&gt;set_exception_pc(0);
 519   return exception;
 520 JRT_END
 521 
 522 PRAGMA_DIAG_PUSH
 523 PRAGMA_FORMAT_NONLITERAL_IGNORED
 524 JRT_LEAF(void, JVMCIRuntime::log_printf(JavaThread* thread, oopDesc* format, jlong v1, jlong v2, jlong v3))
 525   ResourceMark rm;
 526   assert(format != NULL &amp;&amp; java_lang_String::is_instance(format), "must be");
 527   char *buf = java_lang_String::as_utf8_string(format);
 528   tty-&gt;print((const char*)buf, v1, v2, v3);
 529 JRT_END
 530 PRAGMA_DIAG_POP
 531 
 532 static void decipher(jlong v, bool ignoreZero) {
 533   if (v != 0 || !ignoreZero) {
 534     void* p = (void *)(address) v;
 535     CodeBlob* cb = CodeCache::find_blob(p);
 536     if (cb) {
 537       if (cb-&gt;is_nmethod()) {
 538         char buf[O_BUFLEN];
 539         tty-&gt;print("%s [" INTPTR_FORMAT "+" JLONG_FORMAT "]", cb-&gt;as_nmethod_or_null()-&gt;method()-&gt;name_and_sig_as_C_string(buf, O_BUFLEN), p2i(cb-&gt;code_begin()), (jlong)((address)v - cb-&gt;code_begin()));
 540         return;
 541       }
 542       cb-&gt;print_value_on(tty);
 543       return;
 544     }
 545     if (Universe::heap()-&gt;is_in(p)) {
 546       oop obj = oop(p);
 547       obj-&gt;print_value_on(tty);
 548       return;
 549     }
 550     tty-&gt;print(INTPTR_FORMAT " [long: " JLONG_FORMAT ", double %lf, char %c]",p2i((void *)v), (jlong)v, (jdouble)v, (char)v);
 551   }
 552 }
 553 
 554 PRAGMA_DIAG_PUSH
 555 PRAGMA_FORMAT_NONLITERAL_IGNORED
 556 JRT_LEAF(void, JVMCIRuntime::vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3))
 557   ResourceMark rm;
 558   const char *buf = (const char*) (address) format;
 559   if (vmError) {
 560     if (buf != NULL) {
 561       fatal(buf, v1, v2, v3);
 562     } else {
 563       fatal("&lt;anonymous error&gt;");
 564     }
 565   } else if (buf != NULL) {
 566     tty-&gt;print(buf, v1, v2, v3);
 567   } else {
 568     assert(v2 == 0, "v2 != 0");
 569     assert(v3 == 0, "v3 != 0");
 570     decipher(v1, false);
 571   }
 572 JRT_END
 573 PRAGMA_DIAG_POP
 574 
 575 JRT_LEAF(void, JVMCIRuntime::log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline))
 576   union {
 577       jlong l;
 578       jdouble d;
 579       jfloat f;
 580   } uu;
 581   uu.l = value;
 582   switch (typeChar) {
 583     case 'Z': tty-&gt;print(value == 0 ? "false" : "true"); break;
 584     case 'B': tty-&gt;print("%d", (jbyte) value); break;
 585     case 'C': tty-&gt;print("%c", (jchar) value); break;
 586     case 'S': tty-&gt;print("%d", (jshort) value); break;
 587     case 'I': tty-&gt;print("%d", (jint) value); break;
 588     case 'F': tty-&gt;print("%f", uu.f); break;
 589     case 'J': tty-&gt;print(JLONG_FORMAT, value); break;
 590     case 'D': tty-&gt;print("%lf", uu.d); break;
 591     default: assert(false, "unknown typeChar"); break;
 592   }
 593   if (newline) {
 594     tty-&gt;cr();
 595   }
 596 JRT_END
 597 
 598 JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))
 599   return (jint) obj-&gt;identity_hash();
 600 JRT_END
 601 
 602 JRT_ENTRY(jboolean, JVMCIRuntime::thread_is_interrupted(JavaThread* thread, oopDesc* receiver, jboolean clear_interrupted))
 603   // Ensure that the C++ Thread and OSThread structures aren't freed before we operate.
 604   // This locking requires thread_in_vm which is why this method cannot be JRT_LEAF.
 605   Handle receiverHandle(thread, receiver);
 606   MutexLockerEx ml(thread-&gt;threadObj() == (void*)receiver ? NULL : Threads_lock);
 607   JavaThread* receiverThread = java_lang_Thread::thread(receiverHandle());
 608   if (receiverThread == NULL) {
 609     // The other thread may exit during this process, which is ok so return false.
 610     return JNI_FALSE;
 611   } else {
 612     return (jint) Thread::is_interrupted(receiverThread, clear_interrupted != 0);
 613   }
 614 JRT_END
 615 
 616 JRT_ENTRY(jint, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))
 617   deopt_caller();
 618   return value;
 619 JRT_END
 620 
 621 void JVMCIRuntime::force_initialization(TRAPS) {
 622   JVMCIRuntime::initialize_well_known_classes(CHECK);
 623 
 624   ResourceMark rm;
 625   TempNewSymbol getCompiler = SymbolTable::new_symbol("getCompiler", CHECK);
 626   TempNewSymbol sig = SymbolTable::new_symbol("()Ljdk/vm/ci/runtime/JVMCICompiler;", CHECK);
 627   Handle jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(CHECK);
 628   JavaValue result(T_OBJECT);
 629   JavaCalls::call_virtual(&amp;result, jvmciRuntime, HotSpotJVMCIRuntime::klass(), getCompiler, sig, CHECK);
 630 }
 631 
 632 // private static JVMCIRuntime JVMCI.initializeRuntime()
 633 JVM_ENTRY(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))
 634   if (!EnableJVMCI) {
 635     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), "JVMCI is not enabled")
 636   }
 637   JVMCIRuntime::initialize_HotSpotJVMCIRuntime(CHECK_NULL);
 638   jobject ret = JVMCIRuntime::get_HotSpotJVMCIRuntime_jobject(CHECK_NULL);
 639   return ret;
 640 JVM_END
 641 
 642 Handle JVMCIRuntime::callStatic(const char* className, const char* methodName, const char* signature, JavaCallArguments* args, TRAPS) {
 643   guarantee(!_HotSpotJVMCIRuntime_initialized, "cannot reinitialize HotSpotJVMCIRuntime");
 644 
 645   TempNewSymbol name = SymbolTable::new_symbol(className, CHECK_(Handle()));
 646   KlassHandle klass = SystemDictionary::resolve_or_fail(name, true, CHECK_(Handle()));
 647   TempNewSymbol runtime = SymbolTable::new_symbol(methodName, CHECK_(Handle()));
 648   TempNewSymbol sig = SymbolTable::new_symbol(signature, CHECK_(Handle()));
 649   JavaValue result(T_OBJECT);
 650   if (args == NULL) {
 651     JavaCalls::call_static(&amp;result, klass, runtime, sig, CHECK_(Handle()));
 652   } else {
 653     JavaCalls::call_static(&amp;result, klass, runtime, sig, args, CHECK_(Handle()));
 654   }
 655   return Handle((oop)result.get_jobject());
 656 }
 657 
 658 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(TRAPS) {
 659   if (JNIHandles::resolve(_HotSpotJVMCIRuntime_instance) == NULL) {
 660     ResourceMark rm;
 661 #ifdef ASSERT
 662     // This should only be called in the context of the JVMCI class being initialized
 663     TempNewSymbol name = SymbolTable::new_symbol("jdk/vm/ci/runtime/JVMCI", CHECK);
 664     Klass* k = SystemDictionary::resolve_or_null(name, CHECK);
 665     instanceKlassHandle klass = InstanceKlass::cast(k);
 666     assert(klass-&gt;is_being_initialized() &amp;&amp; klass-&gt;is_reentrant_initialization(THREAD),
 667            "HotSpotJVMCIRuntime initialization should only be triggered through JVMCI initialization");
 668 #endif
 669 
 670     Handle result = callStatic("jdk/vm/ci/hotspot/HotSpotJVMCIRuntime",
 671                                "runtime",
 672                                "()Ljdk/vm/ci/hotspot/HotSpotJVMCIRuntime;", NULL, CHECK);
 673     objArrayOop trivial_prefixes = HotSpotJVMCIRuntime::trivialPrefixes(result);
 674     if (trivial_prefixes != NULL) {
 675       char** prefixes = NEW_C_HEAP_ARRAY(char*, trivial_prefixes-&gt;length(), mtCompiler);
 676       for (int i = 0; i &lt; trivial_prefixes-&gt;length(); i++) {
 677         oop str = trivial_prefixes-&gt;obj_at(i);
 678         if (str == NULL) {
 679           THROW(vmSymbols::java_lang_NullPointerException());
 680         } else {
 681           prefixes[i] = strdup(java_lang_String::as_utf8_string(str));
 682         }
 683       }
 684       _trivial_prefixes = prefixes;
 685       _trivial_prefixes_count = trivial_prefixes-&gt;length();
 686     }
 687     int adjustment = HotSpotJVMCIRuntime::compilationLevelAdjustment(result);
 688     assert(adjustment &gt;= JVMCIRuntime::none &amp;&amp;
 689            adjustment &lt;= JVMCIRuntime::by_full_signature,
 690            "compilation level adjustment out of bounds");
 691     _comp_level_adjustment = (CompLevelAdjustment) adjustment;
 692     _HotSpotJVMCIRuntime_initialized = true;
 693     _HotSpotJVMCIRuntime_instance = JNIHandles::make_global(result());
 694   }
 695 }
 696 
 697 void JVMCIRuntime::initialize_JVMCI(TRAPS) {
 698   if (JNIHandles::resolve(_HotSpotJVMCIRuntime_instance) == NULL) {
 699     callStatic("jdk/vm/ci/runtime/JVMCI",
 700                "getRuntime",
 701                "()Ljdk/vm/ci/runtime/JVMCIRuntime;", NULL, CHECK);
 702   }
 703   assert(_HotSpotJVMCIRuntime_initialized == true, "what?");
 704 }
 705 
 706 bool JVMCIRuntime::can_initialize_JVMCI() {
 707   // Initializing JVMCI requires the module system to be initialized past phase 3.
 708   // The JVMCI API itself isn't available until phase 2 and ServiceLoader (which
 709   // JVMCI initialization requires) isn't usable until after phase 3. Testing
 710   // whether the system loader is initialized satisfies all these invariants.
 711   if (SystemDictionary::java_system_loader() == NULL) {
 712     return false;
 713   }
 714   assert(Universe::is_module_initialized(), "must be");
 715   return true;
 716 }
 717 
 718 void JVMCIRuntime::initialize_well_known_classes(TRAPS) {
 719   if (JVMCIRuntime::_well_known_classes_initialized == false) {
 720     guarantee(can_initialize_JVMCI(), "VM is not yet sufficiently booted to initialize JVMCI");
 721     SystemDictionary::WKID scan = SystemDictionary::FIRST_JVMCI_WKID;
 722     SystemDictionary::initialize_wk_klasses_through(SystemDictionary::LAST_JVMCI_WKID, scan, CHECK);
 723     JVMCIJavaClasses::compute_offsets(CHECK);
 724     JVMCIRuntime::_well_known_classes_initialized = true;
 725   }
 726 }
 727 
 728 void JVMCIRuntime::metadata_do(void f(Metadata*)) {
 729   // For simplicity, the existence of HotSpotJVMCIMetaAccessContext in
 730   // the SystemDictionary well known classes should ensure the other
 731   // classes have already been loaded, so make sure their order in the
 732   // table enforces that.
 733   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotResolvedJavaMethodImpl) &lt;
 734          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), "must be loaded earlier");
 735   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotConstantPool) &lt;
 736          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), "must be loaded earlier");
 737   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotResolvedObjectTypeImpl) &lt;
 738          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), "must be loaded earlier");
 739 
 740   if (HotSpotJVMCIMetaAccessContext::klass() == NULL ||
 741       !HotSpotJVMCIMetaAccessContext::klass()-&gt;is_linked()) {
 742     // Nothing could be registered yet
 743     return;
 744   }
 745 
 746   // WeakReference&lt;HotSpotJVMCIMetaAccessContext&gt;[]
 747   objArrayOop allContexts = HotSpotJVMCIMetaAccessContext::allContexts();
 748   if (allContexts == NULL) {
 749     return;
 750   }
 751 
 752   // These must be loaded at this point but the linking state doesn't matter.
 753   assert(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass() != NULL, "must be loaded");
 754   assert(SystemDictionary::HotSpotConstantPool_klass() != NULL, "must be loaded");
 755   assert(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass() != NULL, "must be loaded");
 756 
 757   for (int i = 0; i &lt; allContexts-&gt;length(); i++) {
 758     oop ref = allContexts-&gt;obj_at(i);
 759     if (ref != NULL) {
 760       oop referent = java_lang_ref_Reference::referent(ref);
 761       if (referent != NULL) {
 762         // Chunked Object[] with last element pointing to next chunk
 763         objArrayOop metadataRoots = HotSpotJVMCIMetaAccessContext::metadataRoots(referent);
 764         while (metadataRoots != NULL) {
 765           for (int typeIndex = 0; typeIndex &lt; metadataRoots-&gt;length() - 1; typeIndex++) {
 766             oop reference = metadataRoots-&gt;obj_at(typeIndex);
 767             if (reference == NULL) {
 768               continue;
 769             }
 770             oop metadataRoot = java_lang_ref_Reference::referent(reference);
 771             if (metadataRoot == NULL) {
 772               continue;
 773             }
 774             if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 775               Method* method = CompilerToVM::asMethod(metadataRoot);
 776               f(method);
 777             } else if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 778               ConstantPool* constantPool = CompilerToVM::asConstantPool(metadataRoot);
 779               f(constantPool);
 780             } else if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 781               Klass* klass = CompilerToVM::asKlass(metadataRoot);
 782               f(klass);
 783             } else {
 784               metadataRoot-&gt;print();
 785               ShouldNotReachHere();
 786             }
 787           }
 788           metadataRoots = (objArrayOop)metadataRoots-&gt;obj_at(metadataRoots-&gt;length() - 1);
 789           assert(metadataRoots == NULL || metadataRoots-&gt;is_objArray(), "wrong type");
 790         }
 791       }
 792     }
 793   }
 794 }
 795 
 796 // private static void CompilerToVM.registerNatives()
 797 JVM_ENTRY(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
 798   if (!EnableJVMCI) {
 799     THROW_MSG(vmSymbols::java_lang_InternalError(), "JVMCI is not enabled");
 800   }
 801 
 802 #ifdef _LP64
 803 #ifndef SPARC
 804   uintptr_t heap_end = (uintptr_t) Universe::heap()-&gt;reserved_region().end();
 805   uintptr_t allocation_end = heap_end + ((uintptr_t)16) * 1024 * 1024 * 1024;
 806   guarantee(heap_end &lt; allocation_end, "heap end too close to end of address space (might lead to erroneous TLAB allocations)");
 807 #endif // !SPARC
 808 #else
 809   fatal("check TLAB allocation code for address space conflicts");
 810 #endif // _LP64
 811 
 812   JVMCIRuntime::initialize_well_known_classes(CHECK);
 813 
 814   {
 815     ThreadToNativeFromVM trans(thread);
 816     env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count());
 817   }
 818 JVM_END
 819 
<a name="1" id="anc1"></a>









 820 void JVMCIRuntime::shutdown(TRAPS) {
 821   if (_HotSpotJVMCIRuntime_instance != NULL) {
 822     _shutdown_called = true;
 823     HandleMark hm(THREAD);
 824     Handle receiver = get_HotSpotJVMCIRuntime(CHECK);
 825     JavaValue result(T_VOID);
 826     JavaCallArguments args;
 827     args.push_oop(receiver);
 828     JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::shutdown_method_name(), vmSymbols::void_method_signature(), &amp;args, CHECK);
 829   }
 830 }
 831 
 832 CompLevel JVMCIRuntime::adjust_comp_level_inner(methodHandle method, bool is_osr, CompLevel level, JavaThread* thread) {
 833   JVMCICompiler* compiler = JVMCICompiler::instance(thread);
 834   if (compiler != NULL &amp;&amp; compiler-&gt;is_bootstrapping()) {
 835     return level;
 836   }
 837   if (!is_HotSpotJVMCIRuntime_initialized() || !_comp_level_adjustment) {
 838     // JVMCI cannot participate in compilation scheduling until
 839     // JVMCI is initialized and indicates it wants to participate.
 840     return level;
 841   }
 842 
 843 #define CHECK_RETURN THREAD); \
 844 if (HAS_PENDING_EXCEPTION) { \
 845   Handle exception(THREAD, PENDING_EXCEPTION); \
 846   CLEAR_PENDING_EXCEPTION; \
 847 \
 848   java_lang_Throwable::java_printStackTrace(exception, THREAD); \
 849   if (HAS_PENDING_EXCEPTION) { \
 850     CLEAR_PENDING_EXCEPTION; \
 851   } \
 852   return level; \
 853 } \
 854 (void)(0
 855 
 856 
 857   Thread* THREAD = thread;
 858   HandleMark hm;
 859   Handle receiver = JVMCIRuntime::get_HotSpotJVMCIRuntime(CHECK_RETURN);
 860   Handle name;
 861   Handle sig;
 862   if (_comp_level_adjustment == JVMCIRuntime::by_full_signature) {
 863     name = java_lang_String::create_from_symbol(method-&gt;name(), CHECK_RETURN);
 864     sig = java_lang_String::create_from_symbol(method-&gt;signature(), CHECK_RETURN);
 865   } else {
 866     name = Handle();
 867     sig = Handle();
 868   }
 869 
 870   JavaValue result(T_INT);
 871   JavaCallArguments args;
 872   args.push_oop(receiver);
 873   args.push_oop(method-&gt;method_holder()-&gt;java_mirror());
 874   args.push_oop(name());
 875   args.push_oop(sig());
 876   args.push_int(is_osr);
 877   args.push_int(level);
 878   JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::adjustCompilationLevel_name(),
 879                           vmSymbols::adjustCompilationLevel_signature(), &amp;args, CHECK_RETURN);
 880 
 881   int comp_level = result.get_jint();
 882   if (comp_level &lt; CompLevel_none || comp_level &gt; CompLevel_full_optimization) {
 883     assert(false, "compilation level out of bounds");
 884     return level;
 885   }
 886   return (CompLevel) comp_level;
 887 #undef CHECK_RETURN
 888 }
 889 
 890 void JVMCIRuntime::bootstrap_finished(TRAPS) {
 891   HandleMark hm(THREAD);
 892   Handle receiver = get_HotSpotJVMCIRuntime(CHECK);
 893   JavaValue result(T_VOID);
 894   JavaCallArguments args;
 895   args.push_oop(receiver);
 896   JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::bootstrapFinished_method_name(), vmSymbols::void_method_signature(), &amp;args, CHECK);
 897 }
 898 
 899 bool JVMCIRuntime::treat_as_trivial(Method* method) {
 900   if (_HotSpotJVMCIRuntime_initialized) {
 901     for (int i = 0; i &lt; _trivial_prefixes_count; i++) {
 902       if (method-&gt;method_holder()-&gt;name()-&gt;starts_with(_trivial_prefixes[i])) {
 903         return true;
 904       }
 905     }
 906   }
 907   return false;
 908 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
