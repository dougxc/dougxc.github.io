<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12604">12604</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8173912">8173912</a>: [JVMCI] fix memory overhead of JVMCI</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "code/codeCache.hpp"
  27 #include "code/scopeDesc.hpp"
  28 #include "interpreter/linkResolver.hpp"
  29 #include "memory/oopFactory.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "oops/generateOopMap.hpp"
  32 #include "oops/fieldStreams.hpp"
  33 #include "oops/oop.inline.hpp"
  34 #include "oops/objArrayOop.inline.hpp"
  35 #include "runtime/fieldDescriptor.hpp"
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"
<a name="1" id="anc1"></a><span class="new">  56 #include "utilities/resourceHash.hpp"</span>
  57 
  58 
  59 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  60 #define C2V_VMENTRY(result_type, name, signature) \
  61   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  62   TRACE_jvmci_1("CompilerToVM::" #name); \
  63   TRACE_CALL(result_type, jvmci_ ## name signature) \
  64   JVMCI_VM_ENTRY_MARK; \
  65 
  66 #define C2V_END }
  67 
  68 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  69   if (method() != NULL) {
  70     JavaValue result(T_OBJECT);
  71     JavaCallArguments args;
  72     args.push_long((jlong) (address) method());
  73     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  74 
  75     return (oop)result.get_jobject();
  76   }
  77   return NULL;
  78 }
  79 
  80 oop CompilerToVM::get_jvmci_type(KlassHandle klass, TRAPS) {
  81   if (klass() != NULL) {
  82     JavaValue result(T_OBJECT);
  83     JavaCallArguments args;
  84     args.push_oop(klass-&gt;java_mirror());
  85     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  86 
  87     return (oop)result.get_jobject();
  88   }
  89   return NULL;
  90 }
  91 
  92 int CompilerToVM::Data::Klass_vtable_start_offset;
  93 int CompilerToVM::Data::Klass_vtable_length_offset;
  94 
  95 int CompilerToVM::Data::Method_extra_stack_entries;
  96 
  97 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
  98 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
  99 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
 100 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 101 
 102 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 103 
 104 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 105 int CompilerToVM::Data::Universe_base_vtable_size;
 106 address CompilerToVM::Data::Universe_narrow_oop_base;
 107 int CompilerToVM::Data::Universe_narrow_oop_shift;
 108 address CompilerToVM::Data::Universe_narrow_klass_base;
 109 int CompilerToVM::Data::Universe_narrow_klass_shift;
 110 void* CompilerToVM::Data::Universe_non_oop_bits;
 111 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 112 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 113 
 114 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 115 HeapWord** CompilerToVM::Data::_heap_end_addr;
 116 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
 117 int CompilerToVM::Data::_max_oop_map_stack_offset;
 118 
 119 jbyte* CompilerToVM::Data::cardtable_start_address;
 120 int CompilerToVM::Data::cardtable_shift;
 121 
 122 int CompilerToVM::Data::vm_page_size;
 123 
<a name="2" id="anc2"></a><span class="new"> 124 int CompilerToVM::Data::sizeof_vtableEntry = sizeof(vtableEntry);</span>
<span class="new"> 125 int CompilerToVM::Data::sizeof_ExceptionTableElement = sizeof(ExceptionTableElement);</span>
<span class="new"> 126 int CompilerToVM::Data::sizeof_LocalVariableTableElement = sizeof(LocalVariableTableElement);</span>
<span class="new"> 127 int CompilerToVM::Data::sizeof_ConstantPool = sizeof(ConstantPool);</span>
<span class="new"> 128 int CompilerToVM::Data::sizeof_SymbolPointer = sizeof(Symbol*);</span>
<span class="new"> 129 int CompilerToVM::Data::sizeof_narrowKlass = sizeof(narrowKlass);</span>
<span class="new"> 130 int CompilerToVM::Data::sizeof_arrayOopDesc = sizeof(arrayOopDesc);</span>
<span class="new"> 131 int CompilerToVM::Data::sizeof_BasicLock = sizeof(BasicLock);</span>
<span class="new"> 132 </span>
 133 address CompilerToVM::Data::dsin;
 134 address CompilerToVM::Data::dcos;
 135 address CompilerToVM::Data::dtan;
 136 address CompilerToVM::Data::dexp;
 137 address CompilerToVM::Data::dlog;
 138 address CompilerToVM::Data::dlog10;
 139 address CompilerToVM::Data::dpow;
 140 
<a name="3" id="anc3"></a><span class="changed"> 141 address CompilerToVM::Data::symbol_init;</span>
<span class="changed"> 142 address CompilerToVM::Data::symbol_clinit;</span>
<span class="changed"> 143 </span>
<span class="changed"> 144 void CompilerToVM::Data::initialize(TRAPS) {</span>
 145   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 146   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 147 
 148   Method_extra_stack_entries = Method::extra_stack_entries();
 149 
 150   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 151   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 152   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 153   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 154 
 155   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 156 
 157   Universe_collectedHeap = Universe::heap();
 158   Universe_base_vtable_size = Universe::base_vtable_size();
 159   Universe_narrow_oop_base = Universe::narrow_oop_base();
 160   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 161   Universe_narrow_klass_base = Universe::narrow_klass_base();
 162   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 163   Universe_non_oop_bits = Universe::non_oop_word();
 164   Universe_verify_oop_mask = Universe::verify_oop_mask();
 165   Universe_verify_oop_bits = Universe::verify_oop_bits();
 166 
 167   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 168   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 169   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
 170 
 171   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 172   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 173   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 174   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 175 
<a name="4" id="anc4"></a><span class="new"> 176   symbol_init = (address) vmSymbols::object_initializer_name();</span>
<span class="new"> 177   symbol_clinit = (address) vmSymbols::class_initializer_name();</span>
<span class="new"> 178 </span>
 179   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 180   switch (bs-&gt;kind()) {
 181   case BarrierSet::CardTableModRef:
 182   case BarrierSet::CardTableForRS:
 183   case BarrierSet::CardTableExtension:
 184   case BarrierSet::G1SATBCT:
 185   case BarrierSet::G1SATBCTLogging: {
 186     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 187     assert(base != 0, "unexpected byte_map_base");
 188     cardtable_start_address = base;
 189     cardtable_shift = CardTableModRefBS::card_shift;
 190     break;
 191   }
 192   case BarrierSet::ModRef:
 193     cardtable_start_address = 0;
 194     cardtable_shift = 0;
 195     // No post barriers
 196     break;
 197   default:
<a name="5" id="anc5"></a><span class="changed"> 198     JVMCI_ERROR("Unsupported BarrierSet kind %d", bs-&gt;kind());</span>
 199     break;
 200   }
 201 
 202   vm_page_size = os::vm_page_size();
 203 
 204 #define SET_TRIGFUNC(name)                                      \
 205   if (StubRoutines::name() != NULL) {                           \
 206     name = StubRoutines::name();                                \
 207   } else {                                                      \
 208     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 209   }
 210 
 211   SET_TRIGFUNC(dsin);
 212   SET_TRIGFUNC(dcos);
 213   SET_TRIGFUNC(dtan);
 214   SET_TRIGFUNC(dexp);
 215   SET_TRIGFUNC(dlog10);
 216   SET_TRIGFUNC(dlog);
 217   SET_TRIGFUNC(dpow);
 218 
 219 #undef SET_TRIGFUNC
 220 }
 221 
 222 objArrayHandle CompilerToVM::initialize_intrinsics(TRAPS) {
 223   objArrayHandle vmIntrinsics = oopFactory::new_objArray(VMIntrinsicMethod::klass(), (vmIntrinsics::ID_LIMIT - 1), CHECK_(objArrayHandle()));
 224   int index = 0;
 225   // The intrinsics for a class are usually adjacent to each other.
 226   // When they are, the string for the class name can be reused.
 227   vmSymbols::SID kls_sid = vmSymbols::NO_SID;
 228   Handle kls_str;
 229 #define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)
 230 #define VM_SYMBOL_TO_STRING(s) \
 231   java_lang_String::create_from_symbol(vmSymbols::symbol_at(SID_ENUM(s)), CHECK_(objArrayHandle()))
 232 #define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \
 233     instanceHandle vmIntrinsicMethod = InstanceKlass::cast(VMIntrinsicMethod::klass())-&gt;allocate_instance_handle(CHECK_(objArrayHandle())); \
 234     if (kls_sid != SID_ENUM(kls)) {                                       \
 235       kls_str = VM_SYMBOL_TO_STRING(kls);                                 \
 236       kls_sid = SID_ENUM(kls);                                            \
 237     }                                                                     \
 238     Handle name_str = VM_SYMBOL_TO_STRING(name);                          \
 239     Handle sig_str = VM_SYMBOL_TO_STRING(sig);                            \
 240     VMIntrinsicMethod::set_declaringClass(vmIntrinsicMethod, kls_str());  \
 241     VMIntrinsicMethod::set_name(vmIntrinsicMethod, name_str());           \
 242     VMIntrinsicMethod::set_descriptor(vmIntrinsicMethod, sig_str());      \
 243     VMIntrinsicMethod::set_id(vmIntrinsicMethod, vmIntrinsics::id);       \
 244       vmIntrinsics-&gt;obj_at_put(index++, vmIntrinsicMethod());             \
 245   }
 246 
 247   VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
 248 #undef SID_ENUM
 249 #undef VM_SYMBOL_TO_STRING
 250 #undef VM_INTRINSIC_INFO
 251   assert(index == vmIntrinsics::ID_LIMIT - 1, "must be");
 252 
 253   return vmIntrinsics;
 254 }
 255 
<a name="6" id="anc6"></a><span class="changed"> 256 /**</span>
<span class="changed"> 257  * The set of VM flags known to be used.</span>
<span class="changed"> 258  */</span>
<span class="changed"> 259 #define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_intx_flag, do_uintx_flag) \</span>
<span class="changed"> 260   do_intx_flag(AllocateInstancePrefetchLines)                              \</span>
<span class="changed"> 261   do_intx_flag(AllocatePrefetchDistance)                                   \</span>
<span class="changed"> 262   do_intx_flag(AllocatePrefetchInstr)                                      \</span>
<span class="changed"> 263   do_intx_flag(AllocatePrefetchLines)                                      \</span>
<span class="changed"> 264   do_intx_flag(AllocatePrefetchStepSize)                                   \</span>
<span class="changed"> 265   do_intx_flag(AllocatePrefetchStyle)                                      \</span>
<span class="changed"> 266   do_intx_flag(BciProfileWidth)                                            \</span>
<span class="changed"> 267   do_bool_flag(BootstrapJVMCI)                                             \</span>
<span class="changed"> 268   do_bool_flag(CITime)                                                     \</span>
<span class="changed"> 269   do_bool_flag(CITimeEach)                                                 \</span>
<span class="changed"> 270   do_uintx_flag(CodeCacheSegmentSize)                                      \</span>
<span class="changed"> 271   do_intx_flag(CodeEntryAlignment)                                         \</span>
<span class="changed"> 272   do_bool_flag(CompactFields)                                              \</span>
<span class="changed"> 273   NOT_PRODUCT(do_intx_flag(CompileTheWorldStartAt))                        \</span>
<span class="changed"> 274   NOT_PRODUCT(do_intx_flag(CompileTheWorldStopAt))                         \</span>
<span class="changed"> 275   do_intx_flag(ContendedPaddingWidth)                                      \</span>
<span class="changed"> 276   do_bool_flag(DontCompileHugeMethods)                                     \</span>
<span class="changed"> 277   do_bool_flag(EnableContended)                                            \</span>
<span class="changed"> 278   do_intx_flag(FieldsAllocationStyle)                                      \</span>
<span class="changed"> 279   do_bool_flag(FoldStableValues)                                           \</span>
<span class="changed"> 280   do_bool_flag(ForceUnreachable)                                           \</span>
<span class="changed"> 281   do_intx_flag(HugeMethodLimit)                                            \</span>
<span class="changed"> 282   do_bool_flag(Inline)                                                     \</span>
<span class="changed"> 283   do_intx_flag(JVMCICounterSize)                                           \</span>
<span class="changed"> 284   do_bool_flag(JVMCIPrintProperties)                                       \</span>
<span class="changed"> 285   do_bool_flag(JVMCIUseFastLocking)                                        \</span>
<span class="changed"> 286   do_intx_flag(MethodProfileWidth)                                         \</span>
<span class="changed"> 287   do_intx_flag(ObjectAlignmentInBytes)                                     \</span>
<span class="changed"> 288   do_bool_flag(PrintInlining)                                              \</span>
<span class="changed"> 289   do_bool_flag(ReduceInitialCardMarks)                                     \</span>
<span class="changed"> 290   do_bool_flag(RestrictContended)                                          \</span>
<span class="changed"> 291   do_intx_flag(StackReservedPages)                                         \</span>
<span class="changed"> 292   do_intx_flag(StackShadowPages)                                           \</span>
<span class="changed"> 293   do_bool_flag(TLABStats)                                                  \</span>
<span class="changed"> 294   do_uintx_flag(TLABWasteIncrement)                                        \</span>
<span class="changed"> 295   do_intx_flag(TypeProfileWidth)                                           \</span>
<span class="changed"> 296   do_bool_flag(UseAESIntrinsics)                                           \</span>
<span class="changed"> 297   X86_ONLY(do_intx_flag(UseAVX))                                           \</span>
<span class="changed"> 298   do_bool_flag(UseBiasedLocking)                                           \</span>
<span class="changed"> 299   do_bool_flag(UseCRC32Intrinsics)                                         \</span>
<span class="changed"> 300   do_bool_flag(UseCompressedClassPointers)                                 \</span>
<span class="changed"> 301   do_bool_flag(UseCompressedOops)                                          \</span>
<span class="changed"> 302   do_bool_flag(UseConcMarkSweepGC)                                         \</span>
<span class="changed"> 303   X86_ONLY(do_bool_flag(UseCountLeadingZerosInstruction))                  \</span>
<span class="changed"> 304   X86_ONLY(do_bool_flag(UseCountTrailingZerosInstruction))                 \</span>
<span class="changed"> 305   do_bool_flag(UseG1GC)                                                    \</span>
<span class="changed"> 306   COMPILER2_PRESENT(do_bool_flag(UseMontgomeryMultiplyIntrinsic))          \</span>
<span class="changed"> 307   COMPILER2_PRESENT(do_bool_flag(UseMontgomerySquareIntrinsic))            \</span>
<span class="changed"> 308   COMPILER2_PRESENT(do_bool_flag(UseMulAddIntrinsic))                      \</span>
<span class="changed"> 309   COMPILER2_PRESENT(do_bool_flag(UseMultiplyToLenIntrinsic))               \</span>
<span class="changed"> 310   do_bool_flag(UsePopCountInstruction)                                     \</span>
<span class="changed"> 311   do_bool_flag(UseSHA1Intrinsics)                                          \</span>
<span class="changed"> 312   do_bool_flag(UseSHA256Intrinsics)                                        \</span>
<span class="changed"> 313   do_bool_flag(UseSHA512Intrinsics)                                        \</span>
<span class="changed"> 314   do_intx_flag(UseSSE)                                                     \</span>
<span class="changed"> 315   COMPILER2_PRESENT(do_bool_flag(UseSquareToLenIntrinsic))                 \</span>
<span class="changed"> 316   do_bool_flag(UseStackBanging)                                            \</span>
<span class="changed"> 317   do_bool_flag(UseTLAB)                                                    \</span>
<span class="changed"> 318   do_bool_flag(VerifyOops)                                                 \</span>
<span class="changed"> 319 </span>
<span class="changed"> 320 #define BOXED_BOOLEAN(name, value) oop name = ((jboolean)(value) ? boxedTrue() : boxedFalse())</span>
 321 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)
<a name="7" id="anc7"></a><span class="new"> 322 #define BOXED_LONG(name, value) \</span>
<span class="new"> 323   oop name; \</span>
<span class="new"> 324   do { \</span>
<span class="new"> 325     jvalue p; p.j = (jlong) (value); \</span>
<span class="new"> 326     Handle* e = longs.get(p.j); \</span>
<span class="new"> 327     if (e == NULL) { \</span>
<span class="new"> 328       Handle h = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); \</span>
<span class="new"> 329       longs.put(p.j, h); \</span>
<span class="new"> 330       name = h(); \</span>
<span class="new"> 331     } else { \</span>
<span class="new"> 332       name = (*e)(); \</span>
<span class="new"> 333     } \</span>
<span class="new"> 334   } while (0)</span>
<span class="new"> 335 </span>
<span class="new"> 336 #define CSTRING_TO_JSTRING(name, value) \</span>
<span class="new"> 337   Handle name; \</span>
<span class="new"> 338   do { \</span>
<span class="new"> 339     if (value != NULL) { \</span>
<span class="new"> 340       Handle* e = strings.get(value); \</span>
<span class="new"> 341       if (e == NULL) { \</span>
<span class="new"> 342         Handle h = java_lang_String::create_from_str(value, CHECK_NULL); \</span>
<span class="new"> 343         strings.put(value, h); \</span>
<span class="new"> 344         name = h(); \</span>
<span class="new"> 345       } else { \</span>
<span class="new"> 346         name = (*e)(); \</span>
<span class="new"> 347       } \</span>
<span class="new"> 348     } \</span>
<span class="new"> 349   } while (0)</span>
<span class="new"> 350 </span>
<span class="new"> 351 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))</span>
 352   ResourceMark rm;
 353   HandleMark hm;
 354 
<a name="8" id="anc8"></a><span class="changed"> 355   // Used to canonicalize Long and String values.</span>
<span class="changed"> 356   ResourceHashtable&lt;jlong, Handle&gt; longs;</span>
<span class="changed"> 357   ResourceHashtable&lt;const char*, Handle, &amp;CompilerToVM::cstring_hash, &amp;CompilerToVM::cstring_equals&gt; strings;</span>
<span class="changed"> 358 </span>
<span class="changed"> 359   jvalue prim;</span>
<span class="changed"> 360   prim.z = true;  Handle boxedTrue =  java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="changed"> 361   prim.z = false; Handle boxedFalse = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="changed"> 362 </span>
<span class="changed"> 363   CompilerToVM::Data::initialize(CHECK_NULL);</span>
 364 
 365   VMField::klass()-&gt;initialize(CHECK_NULL);
 366   VMFlag::klass()-&gt;initialize(CHECK_NULL);
 367   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);
 368 
 369   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
 370   objArrayHandle vmFields = oopFactory::new_objArray(VMField::klass(), len, CHECK_NULL);
 371   for (int i = 0; i &lt; len ; i++) {
 372     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
 373     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 374     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* "::" */;
 375     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
 376     sprintf(name_buf, "%s::%s", vmField.typeName, vmField.fieldName);
<a name="9" id="anc9"></a><span class="changed"> 377     CSTRING_TO_JSTRING(name, name_buf);</span>
<span class="changed"> 378     CSTRING_TO_JSTRING(type, vmField.typeString);</span>
 379     VMField::set_name(vmFieldObj, name());
 380     VMField::set_type(vmFieldObj, type());
 381     VMField::set_offset(vmFieldObj, vmField.offset);
 382     VMField::set_address(vmFieldObj, (jlong) vmField.address);
<a name="10" id="anc10"></a><span class="changed"> 383     if (vmField.isStatic &amp;&amp; vmField.typeString != NULL) {</span>
 384       if (strcmp(vmField.typeString, "bool") == 0) {
<a name="11" id="anc11"></a><span class="changed"> 385         BOXED_BOOLEAN(box, *(jbyte*) vmField.address);</span>
<span class="changed"> 386         VMField::set_value(vmFieldObj, box);</span>
 387       } else if (strcmp(vmField.typeString, "int") == 0 ||
 388                  strcmp(vmField.typeString, "jint") == 0) {
<a name="12" id="anc12"></a><span class="changed"> 389         BOXED_LONG(box, *(jint*) vmField.address);</span>
<span class="changed"> 390         VMField::set_value(vmFieldObj, box);</span>
 391       } else if (strcmp(vmField.typeString, "uint64_t") == 0) {
<a name="13" id="anc13"></a><span class="changed"> 392         BOXED_LONG(box, *(uint64_t*) vmField.address);</span>
<span class="changed"> 393         VMField::set_value(vmFieldObj, box);</span>
 394       } else if (strcmp(vmField.typeString, "address") == 0 ||
 395                  strcmp(vmField.typeString, "intptr_t") == 0 ||
 396                  strcmp(vmField.typeString, "uintptr_t") == 0 ||
 397                  strcmp(vmField.typeString, "size_t") == 0 ||
 398                  // All foo* types are addresses.
 399                  vmField.typeString[strlen(vmField.typeString) - 1] == '*') {
<a name="14" id="anc14"></a><span class="changed"> 400         BOXED_LONG(box, *((address*) vmField.address));</span>
<span class="changed"> 401         VMField::set_value(vmFieldObj, box);</span>
 402       } else {
 403         JVMCI_ERROR_NULL("VM field %s has unsupported type %s", name_buf, vmField.typeString);
 404       }
 405     }
 406     vmFields-&gt;obj_at_put(i, vmFieldObj());
 407   }
 408 
<a name="15" id="anc15"></a>









 409   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
 410   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
 411   len = ints_len + longs_len;
 412   objArrayHandle vmConstants = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 413   int insert = 0;
 414   for (int i = 0; i &lt; ints_len ; i++) {
 415     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
<a name="16" id="anc16"></a><span class="changed"> 416     CSTRING_TO_JSTRING(name, c.name);</span>
 417     BOXED_LONG(value, c.value);
 418     vmConstants-&gt;obj_at_put(insert++, name());
 419     vmConstants-&gt;obj_at_put(insert++, value);
 420   }
 421   for (int i = 0; i &lt; longs_len ; i++) {
 422     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
<a name="17" id="anc17"></a><span class="changed"> 423     CSTRING_TO_JSTRING(name, c.name);</span>
 424     BOXED_LONG(value, c.value);
 425     vmConstants-&gt;obj_at_put(insert++, name());
 426     vmConstants-&gt;obj_at_put(insert++, value);
 427   }
 428   assert(insert == len * 2, "must be");
 429 
 430   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
 431   objArrayHandle vmAddresses = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 432   for (int i = 0; i &lt; len ; i++) {
 433     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
<a name="18" id="anc18"></a><span class="changed"> 434     CSTRING_TO_JSTRING(name, a.name);</span>
 435     BOXED_LONG(value, a.value);
 436     vmAddresses-&gt;obj_at_put(i * 2, name());
 437     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);
 438   }
 439 
<a name="19" id="anc19"></a><span class="changed"> 440 #define COUNT_FLAG(ignore) +1</span>
<span class="changed"> 441 #ifdef ASSERT</span>
<span class="changed"> 442 #define CHECK_FLAG(type, name) { \</span>
<span class="changed"> 443   Flag* flag = Flag::find_flag(#name, strlen(#name), /*allow_locked*/ true, /* return_flag */ true); \</span>
<span class="changed"> 444   assert(flag != NULL, "No such flag named " #name); \</span>
<span class="changed"> 445   assert(flag-&gt;is_##type(), "Flag " #name " is not of type " #type); \</span>
<span class="changed"> 446 }</span>
<span class="changed"> 447 #else</span>
<span class="changed"> 448 #define CHECK_FLAG(type, name)</span>
<span class="changed"> 449 #endif</span>
<span class="changed"> 450 </span>
<span class="changed"> 451 #define ADD_FLAG(type, name, convert) { \</span>
<span class="changed"> 452   CHECK_FLAG(type, name) \</span>
<span class="changed"> 453   instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL); \</span>
<span class="changed"> 454   CSTRING_TO_JSTRING(fname, #name); \</span>
<span class="changed"> 455   CSTRING_TO_JSTRING(ftype, #type); \</span>
<span class="changed"> 456   VMFlag::set_name(vmFlagObj, fname()); \</span>
<span class="changed"> 457   VMFlag::set_type(vmFlagObj, ftype()); \</span>
<span class="changed"> 458   convert(value, name); \</span>
<span class="changed"> 459   VMFlag::set_value(vmFlagObj, value); \</span>
<span class="changed"> 460   vmFlags-&gt;obj_at_put(i++, vmFlagObj()); \</span>
<span class="changed"> 461 }</span>
<span class="changed"> 462 #define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)</span>
<span class="changed"> 463 #define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)</span>
<span class="changed"> 464 #define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)</span>
<span class="changed"> 465 </span>
<span class="changed"> 466   len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);</span>
 467   objArrayHandle vmFlags = oopFactory::new_objArray(VMFlag::klass(), len, CHECK_NULL);
<a name="20" id="anc20"></a><span class="changed"> 468   int i = 0;</span>
<span class="changed"> 469   PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)</span>
<span class="changed"> 470 </span>
<span class="changed"> 471   objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);</span>
<span class="changed"> 472 </span>
<span class="changed"> 473   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 5, CHECK_NULL);</span>
<span class="changed"> 474   data-&gt;obj_at_put(0, vmFields());</span>
<span class="changed"> 475   data-&gt;obj_at_put(1, vmConstants());</span>
<span class="changed"> 476   data-&gt;obj_at_put(2, vmAddresses());</span>
<span class="changed"> 477   data-&gt;obj_at_put(3, vmFlags());</span>
<span class="changed"> 478   data-&gt;obj_at_put(4, vmIntrinsics());</span>
<span class="changed"> 479 </span>
<span class="changed"> 480   return (jobjectArray) JNIHandles::make_local(THREAD, data);</span>
<span class="changed"> 481 #undef COUNT_FLAG</span>
<span class="changed"> 482 #undef ADD_FLAG</span>
<span class="changed"> 483 #undef ADD_BOOL_FLAG</span>
<span class="changed"> 484 #undef ADD_INTX_FLAG</span>
<span class="changed"> 485 #undef ADD_UINTX_FLAG</span>
<span class="changed"> 486 #undef CHECK_FLAG</span>
<span class="changed"> 487 C2V_END</span>
<span class="changed"> 488 </span>
<span class="changed"> 489 C2V_VMENTRY(jobject, getFlagValue, (JNIEnv *, jobject c2vm, jobject name_handle))</span>
<span class="changed"> 490 #define RETURN_BOXED_LONG(value) oop box; jvalue p; p.j = (jlong) (value); box = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);</span>
<span class="changed"> 491 #define RETURN_BOXED_DOUBLE(value) oop box; jvalue p; p.d = (jdouble) (value); box = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);</span>
<span class="changed"> 492   Handle name = JNIHandles::resolve(name_handle);</span>
<span class="changed"> 493   if (name.is_null()) {</span>
<span class="changed"> 494     THROW_0(vmSymbols::java_lang_NullPointerException());</span>
<span class="changed"> 495   }</span>
<span class="changed"> 496   ResourceMark rm;</span>
<span class="changed"> 497   const char* cstring = java_lang_String::as_utf8_string(name());</span>
<span class="changed"> 498   Flag* flag = Flag::find_flag(cstring, strlen(cstring), /* allow_locked */ true, /* return_flag */ true);</span>
<span class="changed"> 499   if (flag == NULL) {</span>
<span class="changed"> 500     return c2vm;</span>
<span class="changed"> 501   }</span>
 502   if (flag-&gt;is_bool()) {
<a name="21" id="anc21"></a><span class="changed"> 503     jvalue prim;</span>
<span class="changed"> 504     prim.z = flag-&gt;get_bool();</span>
<span class="changed"> 505     oop box = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="changed"> 506     return JNIHandles::make_local(THREAD, box);</span>
 507   } else if (flag-&gt;is_ccstr()) {
 508     Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
<a name="22" id="anc22"></a><span class="changed"> 509     return JNIHandles::make_local(THREAD, value());</span>



 510   } else if (flag-&gt;is_intx()) {
<a name="23" id="anc23"></a><span class="changed"> 511     RETURN_BOXED_LONG(flag-&gt;get_intx());</span>
<span class="changed"> 512   } else if (flag-&gt;is_int()) {</span>
<span class="changed"> 513     RETURN_BOXED_LONG(flag-&gt;get_int());</span>
 514   } else if (flag-&gt;is_uint()) {
<a name="24" id="anc24"></a><span class="changed"> 515     RETURN_BOXED_LONG(flag-&gt;get_uint());</span>

 516   } else if (flag-&gt;is_uint64_t()) {
<a name="25" id="anc25"></a><span class="changed"> 517     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());</span>
<span class="changed"> 518   } else if (flag-&gt;is_size_t()) {</span>
<span class="changed"> 519     RETURN_BOXED_LONG(flag-&gt;get_size_t());</span>
 520   } else if (flag-&gt;is_uintx()) {
<a name="26" id="anc26"></a><span class="changed"> 521     RETURN_BOXED_LONG(flag-&gt;get_uintx());</span>

 522   } else if (flag-&gt;is_double()) {
<a name="27" id="anc27"></a><span class="changed"> 523     RETURN_BOXED_DOUBLE(flag-&gt;get_double());</span>




 524   } else {
 525     JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
 526   }
<a name="28" id="anc28"></a><span class="changed"> 527 C2V_END</span>











 528 
<a name="29" id="anc29"></a>
 529 #undef BOXED_LONG
 530 #undef BOXED_DOUBLE
<a name="30" id="anc30"></a><span class="changed"> 531 #undef CSTRING_TO_JSTRING</span>
 532 
 533 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 534   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 535   ResourceMark rm;
 536 
 537   int code_size = method-&gt;code_size();
 538   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 539 
 540   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 541   // iterate over all bytecodes and replace non-Java bytecodes
 542 
 543   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 544     Bytecodes::Code code = s.code();
 545     Bytecodes::Code raw_code = s.raw_code();
 546     int bci = s.bci();
 547     int len = s.instruction_size();
 548 
 549     // Restore original byte code.
 550     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 551     if (len &gt; 1) {
 552       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);
 553     }
 554 
 555     if (len &gt; 1) {
 556       // Restore the big-endian constant pool indexes.
 557       // Cf. Rewriter::scan_method
 558       switch (code) {
 559         case Bytecodes::_getstatic:
 560         case Bytecodes::_putstatic:
 561         case Bytecodes::_getfield:
 562         case Bytecodes::_putfield:
 563         case Bytecodes::_invokevirtual:
 564         case Bytecodes::_invokespecial:
 565         case Bytecodes::_invokestatic:
 566         case Bytecodes::_invokeinterface:
 567         case Bytecodes::_invokehandle: {
 568           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 569           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 570           break;
 571         }
 572 
 573         case Bytecodes::_invokedynamic:
 574           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 575           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);
 576           break;
 577       }
 578 
 579       // Not all ldc byte code are rewritten.
 580       switch (raw_code) {
 581         case Bytecodes::_fast_aldc: {
 582           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;
 583           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 584           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 585           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);
 586           break;
 587         }
 588 
 589         case Bytecodes::_fast_aldc_w: {
 590           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 591           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 592           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 593           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 594           break;
 595         }
 596       }
 597     }
 598   }
 599 
 600   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);
 601 C2V_END
 602 
 603 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 604   ResourceMark rm;
 605   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 606   return method-&gt;exception_table_length();
 607 C2V_END
 608 
 609 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 610   ResourceMark rm;
 611   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 612   if (method-&gt;exception_table_length() == 0) {
 613     return 0L;
 614   }
 615   return (jlong) (address) method-&gt;exception_table_start();
 616 C2V_END
 617 
 618 C2V_VMENTRY(jobject, asResolvedJavaMethod, (JNIEnv *, jobject, jobject executable_handle))
 619   oop executable = JNIHandles::resolve(executable_handle);
 620   oop mirror = NULL;
 621   int slot = 0;
 622 
 623   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 624     mirror = java_lang_reflect_Constructor::clazz(executable);
 625     slot = java_lang_reflect_Constructor::slot(executable);
 626   } else {
 627     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), "wrong type");
 628     mirror = java_lang_reflect_Method::clazz(executable);
 629     slot = java_lang_reflect_Method::slot(executable);
 630   }
 631   Klass* holder = java_lang_Class::as_Klass(mirror);
 632   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 633   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 634   return JNIHandles::make_local(THREAD, result);
 635 }
 636 
 637 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))
 638   methodHandle method;
 639   oop base_object = JNIHandles::resolve(base);
 640   if (base_object == NULL) {
 641     method = *((Method**)(offset));
 642   } else if (base_object-&gt;is_a(SystemDictionary::MemberName_klass())) {
 643     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);
 644   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 645     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));
 646   } else {
 647     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 648                 err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 649   }
 650   assert (method.is_null() || method-&gt;is_method(), "invalid read");
 651   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 652   return JNIHandles::make_local(THREAD, result);
 653 }
 654 
 655 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject object_handle))
 656   constantPoolHandle cp;
 657   oop object = JNIHandles::resolve(object_handle);
 658   if (object == NULL) {
 659     THROW_0(vmSymbols::java_lang_NullPointerException());
 660   }
 661   if (object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 662     cp = CompilerToVM::asMethod(object)-&gt;constMethod()-&gt;constants();
 663   } else if (object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 664     cp = InstanceKlass::cast(CompilerToVM::asKlass(object))-&gt;constants();
 665   } else {
 666     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 667                 err_msg("Unexpected type: %s", object-&gt;klass()-&gt;external_name()));
 668   }
 669   assert(!cp.is_null(), "npe");
 670   JavaValue method_result(T_OBJECT);
 671   JavaCallArguments args;
 672   args.push_long((jlong) (address) cp());
 673   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 674   return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());
 675 }
 676 
 677 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))
 678   KlassHandle klass;
 679   oop base_object = JNIHandles::resolve(base);
 680   jlong base_address = 0;
 681   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 682     klass = base_object-&gt;klass();
 683   } else if (!compressed) {
 684     if (base_object != NULL) {
 685       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 686         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 687       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 688         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 689       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 690         base_address = (jlong) CompilerToVM::asKlass(base_object);
 691       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {
 692         base_address = (jlong) (address) base_object;
 693       } else {
 694         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 695                     err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 696       }
 697     }
 698     klass = *((Klass**) (intptr_t) (base_address + offset));
 699   } else {
 700     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 701                 err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 702   }
 703   assert (klass.is_null() || klass-&gt;is_klass(), "invalid read");
 704   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 705   return JNIHandles::make_local(THREAD, result);
 706 }
 707 
 708 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 709   ResourceMark rm;
 710   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 711   KlassHandle holder = CompilerToVM::asKlass(jvmci_type);
 712   if (holder-&gt;is_interface()) {
 713     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", holder-&gt;external_name()));
 714   }
 715 
 716   methodHandle ucm;
 717   {
 718     MutexLocker locker(Compile_lock);
 719     ucm = Dependencies::find_unique_concrete_method(holder(), method());
 720   }
 721   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);
 722   return JNIHandles::make_local(THREAD, result);
 723 C2V_END
 724 
 725 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))
 726   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 727   oop implementor = CompilerToVM::get_jvmci_type(klass-&gt;implementor(), CHECK_NULL);
 728   return JNIHandles::make_local(THREAD, implementor);
 729 C2V_END
 730 
 731 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))
 732   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 733   return method-&gt;is_ignored_by_security_stack_walk();
 734 C2V_END
 735 
 736 C2V_VMENTRY(jboolean, isCompilable,(JNIEnv *, jobject, jobject jvmci_method))
 737   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 738   // Ignore the not_compilable flags in hosted mode since they are never set by
 739   // the JVMCI compiler.
 740   return UseJVMCICompiler || !method-&gt;is_not_compilable(CompLevel_full_optimization);
 741 C2V_END
 742 
 743 C2V_VMENTRY(jboolean, hasNeverInlineDirective,(JNIEnv *, jobject, jobject jvmci_method))
 744   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 745   return CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 746 C2V_END
 747 
 748 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 749   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 750   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 751 C2V_END
 752 
 753 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 754   ResourceMark rm;
 755   Handle name = JNIHandles::resolve(jname);
 756   Symbol* class_name = java_lang_String::as_symbol(name, CHECK_0);
 757   if (java_lang_String::length(name()) &lt;= 1) {
 758     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Primitive type %s should be handled in Java code", class_name-&gt;as_C_string()));
 759   }
 760 
 761   Klass* resolved_klass = NULL;
 762   Handle class_loader;
 763   Handle protection_domain;
 764   if (JNIHandles::resolve(accessing_class) == NULL) {
 765     THROW_0(vmSymbols::java_lang_NullPointerException());
 766   }
 767   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));
 768   class_loader = accessing_klass-&gt;class_loader();
 769   protection_domain = accessing_klass-&gt;protection_domain();
 770 
 771   if (resolve) {
 772     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 773   } else {
 774     if (class_name-&gt;byte_at(0) == 'L' &amp;&amp;
 775       class_name-&gt;byte_at(class_name-&gt;utf8_length()-1) == ';') {
 776       // This is a name from a signature.  Strip off the trimmings.
 777       // Call recursive to keep scope of strippedsym.
 778       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 779                                                           class_name-&gt;utf8_length()-2,
 780                                                           CHECK_0);
 781       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 782     } else if (FieldType::is_array(class_name)) {
 783       FieldArrayInfo fd;
 784       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 785       // of this call
 786       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 787       if (t == T_OBJECT) {
 788         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 789                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 790                                                             CHECK_0);
 791         // naked oop "k" is OK here -- we assign back into it
 792         resolved_klass = SystemDictionary::find(strippedsym,
 793                                                              class_loader,
 794                                                              protection_domain,
 795                                                              CHECK_0);
 796         if (resolved_klass != NULL) {
 797           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 798         }
 799       } else {
 800         resolved_klass = Universe::typeArrayKlassObj(t);
 801         resolved_klass = TypeArrayKlass::cast(resolved_klass)-&gt;array_klass(fd.dimension(), CHECK_0);
 802       }
 803     }
 804   }
 805   Handle result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 806   return JNIHandles::make_local(THREAD, result());
 807 C2V_END
 808 
 809 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 810   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 811   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);
 812   return JNIHandles::make_local(THREAD, result);
 813 C2V_END
 814 
 815 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 816   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 817   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 818   return JNIHandles::make_local(THREAD, result);
 819 C2V_END
 820 
 821 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 822   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 823   return cp-&gt;name_and_type_ref_index_at(index);
 824 C2V_END
 825 
 826 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 827   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 828   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);
 829   return JNIHandles::make_local(THREAD, sym());
 830 C2V_END
 831 
 832 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 833   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 834   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);
 835   return JNIHandles::make_local(THREAD, sym());
 836 C2V_END
 837 
 838 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 839   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 840   return cp-&gt;klass_ref_index_at(index);
 841 C2V_END
 842 
 843 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 844   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 845   Klass* resolved_klass = cp-&gt;klass_at(index, CHECK_NULL);
 846   Handle klass = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 847   return JNIHandles::make_local(THREAD, klass());
 848 C2V_END
 849 
 850 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 851   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 852   KlassHandle loading_klass(cp-&gt;pool_holder());
 853   bool is_accessible = false;
 854   KlassHandle klass = JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass);
 855   Symbol* symbol = NULL;
 856   if (klass.is_null()) {
 857     symbol = cp-&gt;klass_name_at(index);
 858   }
 859   Handle result;
 860   if (!klass.is_null()) {
 861     result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 862   } else {
 863     result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
 864   }
 865   return JNIHandles::make_local(THREAD, result());
 866 C2V_END
 867 
 868 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 869   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 870   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 871   return JNIHandles::make_local(THREAD, appendix_oop);
 872 C2V_END
 873 
 874 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 875   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 876   instanceKlassHandle pool_holder(cp-&gt;pool_holder());
 877   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 878   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 879   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 880   return JNIHandles::make_local(THREAD, result);
 881 C2V_END
 882 
 883 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 884   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 885   return cp-&gt;remap_instruction_operand_from_cache(index);
 886 C2V_END
 887 
<a name="31" id="anc31"></a><span class="changed"> 888 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))</span>
 889   ResourceMark rm;
 890   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 891   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 892   fieldDescriptor fd;
 893   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
 894   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 895   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
<a name="32" id="anc32"></a><span class="changed"> 896   if (info == NULL || info-&gt;length() != 3) {</span>
<span class="changed"> 897     JVMCI_ERROR_NULL("info must not be null and have a length of 3");</span>
<span class="changed"> 898   }</span>
<span class="changed"> 899   info-&gt;int_at_put(0, fd.access_flags().as_int());</span>
<span class="changed"> 900   info-&gt;int_at_put(1, fd.offset());</span>
<span class="changed"> 901   info-&gt;int_at_put(2, fd.index());</span>
 902   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 903   return JNIHandles::make_local(THREAD, field_holder);
 904 C2V_END
 905 
 906 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 907   ResourceMark rm;
 908   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 909   Method* method = CompilerToVM::asMethod(jvmci_method);
 910   if (klass-&gt;is_interface()) {
 911     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 912   }
 913   if (!method-&gt;method_holder()-&gt;is_interface()) {
 914     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 915   }
 916   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 917     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 918   }
 919   return LinkResolver::vtable_index_of_interface_method(klass, method);
 920 C2V_END
 921 
 922 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 923   KlassHandle recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);
 924   KlassHandle caller_klass = CompilerToVM::asKlass(caller_jvmci_type);
 925   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 926 
 927   KlassHandle h_resolved   (THREAD, method-&gt;method_holder());
 928   Symbol* h_name      = method-&gt;name();
 929   Symbol* h_signature = method-&gt;signature();
 930 
 931   if (MethodHandles::is_signature_polymorphic_method(method())) {
 932       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 933       return NULL;
 934   }
 935 
 936   LinkInfo link_info(h_resolved, h_name, h_signature, caller_klass);
 937   methodHandle m;
 938   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 939   // the vtable has not been setup, and the LinkResolver will fail.
 940   if (recv_klass-&gt;is_array_klass() ||
 941       InstanceKlass::cast(recv_klass())-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface()) {
 942     if (h_resolved-&gt;is_interface()) {
 943       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 944     } else {
 945       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 946     }
 947   }
 948 
 949   if (m.is_null()) {
 950     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 951     return NULL;
 952   }
 953 
 954   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);
 955   return JNIHandles::make_local(THREAD, result);
 956 C2V_END
 957 
 958 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))
 959   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 960   assert(klass != NULL, "method must not be called for primitive types");
 961   return Dependencies::find_finalizable_subclass(klass) != NULL;
 962 C2V_END
 963 
 964 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))
 965   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 966   oop result = CompilerToVM::get_jvmci_method(klass-&gt;class_initializer(), CHECK_NULL);
 967   return JNIHandles::make_local(THREAD, result);
 968 C2V_END
 969 
 970 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))
 971   address target_addr = (address) addr;
 972   if (target_addr != 0x0) {
 973     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 974     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 975     return MAX2(ABS(off_low), ABS(off_high));
 976   }
 977   return -1;
 978 C2V_END
 979 
 980 C2V_VMENTRY(void, doNotInlineOrCompile,(JNIEnv *, jobject,  jobject jvmci_method))
 981   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 982   method-&gt;set_not_c1_compilable();
 983   method-&gt;set_not_c2_compilable();
 984   method-&gt;set_dont_inline(true);
 985 C2V_END
 986 
 987 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))
 988   ResourceMark rm;
 989   HandleMark hm;
 990   Handle target_handle = JNIHandles::resolve(target);
 991   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 992   CodeBlob* cb = NULL;
 993   Handle installed_code_handle = JNIHandles::resolve(installed_code);
 994   Handle speculation_log_handle = JNIHandles::resolve(speculation_log);
 995 
 996   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK_JNI_ERR);
 997 
 998   TraceTime install_time("installCode", JVMCICompiler::codeInstallTimer());
 999   bool is_immutable_PIC = HotSpotCompiledCode::isImmutablePIC(compiled_code_handle) &gt; 0;
1000   CodeInstaller installer(is_immutable_PIC);
1001   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);
1002 
1003   if (PrintCodeCacheOnCompilation) {
1004     stringStream s;
1005     // Dump code cache  into a buffer before locking the tty,
1006     {
1007       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1008       CodeCache::print_summary(&amp;s, false);
1009     }
1010     ttyLocker ttyl;
1011     tty-&gt;print_raw_cr(s.as_string());
1012   }
1013 
1014   if (result != JVMCIEnv::ok) {
1015     assert(cb == NULL, "should be");
1016   } else {
1017     if (!installed_code_handle.is_null()) {
1018       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), "wrong type");
1019       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);
1020       {
1021         // Ensure that all updates to the InstalledCode fields are consistent.
1022         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
1023         InstalledCode::set_address(installed_code_handle, (jlong) cb);
1024         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);
1025         if (cb-&gt;is_nmethod()) {
1026           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());
1027         } else {
1028           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());
1029         }
1030         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {
1031           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());
1032           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());
1033           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());
1034         }
1035       }
1036       nmethod* nm = cb-&gt;as_nmethod_or_null();
1037       if (nm != NULL &amp;&amp; installed_code_handle-&gt;is_scavengable()) {
1038         assert(nm-&gt;detect_scavenge_root_oops(), "nm should be scavengable if installed_code is scavengable");
1039         if (!UseG1GC) {
1040           assert(nm-&gt;on_scavenge_root_list(), "nm should be on scavengable list");
1041         }
1042       }
1043     }
1044   }
1045   return result;
1046 C2V_END
1047 
1048 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))
1049   ResourceMark rm;
1050   HandleMark hm;
1051 
1052   Handle target_handle = JNIHandles::resolve(target);
1053   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
1054   Handle metadata_handle = JNIHandles::resolve(metadata);
1055 
1056   CodeMetadata code_metadata;
1057   CodeBlob *cb = NULL;
1058   CodeInstaller installer(true /* immutable PIC compilation */);
1059 
1060   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);
1061   if (result != JVMCIEnv::ok) {
1062     return result;
1063   }
1064 
1065   if (code_metadata.get_nr_pc_desc() &gt; 0) {
1066     typeArrayHandle pcArrayOop = oopFactory::new_byteArray(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));
1067     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());
1068     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());
1069   }
1070 
1071   if (code_metadata.get_scopes_size() &gt; 0) {
1072     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));
1073     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());
1074     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());
1075   }
1076 
1077   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
1078   typeArrayHandle relocArrayOop = oopFactory::new_byteArray((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));
1079   if (reloc_buffer-&gt;size() &gt; 0) {
1080     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());
1081   }
1082   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());
1083 
1084   const OopMapSet* oopMapSet = installer.oopMapSet();
1085   {
1086     ResourceMark mark;
1087     ImmutableOopMapBuilder builder(oopMapSet);
1088     int oopmap_size = builder.heap_size();
1089     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray(oopmap_size, CHECK_(JVMCIEnv::cache_full));
1090     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));
1091     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());
1092   }
1093 
1094   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
1095 
1096   int nr_meta_strings = recorder-&gt;nr_meta_strings();
1097   objArrayHandle metadataArrayHandle = oopFactory::new_objectArray(nr_meta_strings, CHECK_(JVMCIEnv::cache_full));
1098   for (int i = 0; i &lt; nr_meta_strings; ++i) {
1099     const char* element = recorder-&gt;meta_element(i);
1100     Handle java_string = java_lang_String::create_from_str(element, CHECK_(JVMCIEnv::cache_full));
1101     metadataArrayHandle-&gt;obj_at_put(i, java_string());
1102   }
1103   HotSpotMetaData::set_metadata(metadata_handle, metadataArrayHandle());
1104 
1105   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
1106   int table_size = handler-&gt;size_in_bytes();
1107   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray(table_size, CHECK_(JVMCIEnv::cache_full));
1108 
1109   if (table_size &gt; 0) {
1110     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));
1111   }
1112   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());
1113 
1114   return result;
1115 C2V_END
1116 
1117 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))
1118   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK);
1119   CompilerStatistics* stats = compiler-&gt;stats();
1120   stats-&gt;_standard.reset();
1121   stats-&gt;_osr.reset();
1122 C2V_END
1123 
1124 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))
1125   ResourceMark rm;
1126   HandleMark hm;
1127 
1128   if (installedCode == NULL) {
1129     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), "installedCode is null");
1130   }
1131 
1132   jlong codeBlob = InstalledCode::address(installedCode);
1133   if (codeBlob == 0L) {
1134     return NULL;
1135   }
1136 
1137   CodeBlob* cb = (CodeBlob*) (address) codeBlob;
1138   if (cb == NULL) {
1139     return NULL;
1140   }
1141 
1142   // We don't want the stringStream buffer to resize during disassembly as it
1143   // uses scoped resource memory. If a nested function called during disassembly uses
1144   // a ResourceMark and the buffer expands within the scope of the mark,
1145   // the buffer becomes garbage when that scope is exited. Experience shows that
1146   // the disassembled code is typically about 10x the code size so a fixed buffer
1147   // sized to 20x code size plus a fixed amount for header info should be sufficient.
1148   int bufferSize = cb-&gt;code_size() * 20 + 1024;
1149   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
1150   stringStream st(buffer, bufferSize);
1151   if (cb-&gt;is_nmethod()) {
1152     nmethod* nm = (nmethod*) cb;
1153     if (!nm-&gt;is_alive()) {
1154       return NULL;
1155     }
1156   }
1157   Disassembler::decode(cb, &amp;st);
1158   if (st.size() &lt;= 0) {
1159     return NULL;
1160   }
1161 
1162   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);
1163   return JNIHandles::make_local(THREAD, result());
1164 C2V_END
1165 
1166 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))
1167   ResourceMark rm;
1168   HandleMark hm;
1169 
1170   methodHandle method = CompilerToVM::asMethod(jvmci_method);
1171   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);
1172   return JNIHandles::make_local(THREAD, element);
1173 C2V_END
1174 
1175 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))
1176   ResourceMark rm;
1177   HandleMark hm;
1178 
1179   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);
1180   if (nmethodValue == 0L) {
1181     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
1182   }
1183   nmethod* nm = (nmethod*) (address) nmethodValue;
1184   methodHandle mh = nm-&gt;method();
1185   Symbol* signature = mh-&gt;signature();
1186   JavaCallArguments jca(mh-&gt;size_of_parameters());
1187 
1188   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1189   JavaValue result(jap.get_ret_type());
1190   jca.set_alternative_target(nm);
1191   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1192 
1193   if (jap.get_ret_type() == T_VOID) {
1194     return NULL;
1195   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
1196     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
1197   } else {
1198     jvalue *value = (jvalue *) result.get_value_addr();
1199     // Narrow the value down if required (Important on big endian machines)
1200     switch (jap.get_ret_type()) {
1201       case T_BOOLEAN:
1202        value-&gt;z = (jboolean) value-&gt;i;
1203        break;
1204       case T_BYTE:
1205        value-&gt;b = (jbyte) value-&gt;i;
1206        break;
1207       case T_CHAR:
1208        value-&gt;c = (jchar) value-&gt;i;
1209        break;
1210       case T_SHORT:
1211        value-&gt;s = (jshort) value-&gt;i;
1212        break;
1213      }
1214     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);
1215     return JNIHandles::make_local(THREAD, o);
1216   }
1217 C2V_END
1218 
1219 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))
1220   Method* method = CompilerToVM::asMethod(jvmci_method);
1221   if (!method-&gt;has_linenumber_table()) {
1222     return NULL;
1223   }
1224   u2 num_entries = 0;
1225   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1226   while (streamForSize.read_pair()) {
1227     num_entries++;
1228   }
1229 
1230   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1231   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);
1232 
1233   int i = 0;
1234   jlong value;
1235   while (stream.read_pair()) {
1236     value = ((long) stream.bci());
1237     result-&gt;long_at_put(i, value);
1238     value = ((long) stream.line());
1239     result-&gt;long_at_put(i + 1, value);
1240     i += 2;
1241   }
1242 
1243   return (jlongArray) JNIHandles::make_local(THREAD, result);
1244 C2V_END
1245 
1246 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))
1247   ResourceMark rm;
1248   Method* method = CompilerToVM::asMethod(jvmci_method);
1249   if (!method-&gt;has_localvariable_table()) {
1250     return 0;
1251   }
1252   return (jlong) (address) method-&gt;localvariable_table_start();
1253 C2V_END
1254 
1255 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))
1256   ResourceMark rm;
1257   Method* method = CompilerToVM::asMethod(jvmci_method);
1258   return method-&gt;localvariable_table_length();
1259 C2V_END
1260 
1261 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))
1262   Method* method = CompilerToVM::asMethod(jvmci_method);
1263   MethodCounters* mcs = method-&gt;method_counters();
1264   if (mcs != NULL) {
1265     mcs-&gt;clear_counters();
1266   }
1267   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1268 
1269   CompiledMethod* code = method-&gt;code();
1270   if (code != NULL) {
1271     code-&gt;make_not_entrant();
1272   }
1273 
1274   MethodData* method_data = method-&gt;method_data();
1275   if (method_data == NULL) {
1276     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1277     method_data = MethodData::allocate(loader_data, method, CHECK);
1278     method-&gt;set_method_data(method_data);
1279   } else {
1280     method_data-&gt;initialize();
1281   }
1282 C2V_END
1283 
1284 
1285 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))
1286   Handle installed_code_handle = JNIHandles::resolve(installed_code);
1287   nmethod::invalidate_installed_code(installed_code_handle, CHECK);
1288 C2V_END
1289 
1290 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))
1291   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);
1292   JavaThread::collect_counters(arrayOop);
1293   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);
1294 C2V_END
1295 
1296 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))
1297   HandleMark hm;
1298   ResourceMark rm;
1299   if (JNIHandles::resolve(jvmci_method) == NULL) {
1300     THROW_0(vmSymbols::java_lang_NullPointerException());
1301   }
1302   Method* method = CompilerToVM::asMethod(jvmci_method);
1303   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1304     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Unexpected bci %d", entry_bci));
1305   }
1306   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1307 C2V_END
1308 
1309 
1310 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))
1311   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1312   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1313 C2V_END
1314 
1315 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1316   Method* method = CompilerToVM::asMethod(jvmci_method);
1317   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1318 C2V_END
1319 
1320 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))
1321   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);
1322   return JNIHandles::make_local(THREAD, sym());
1323 C2V_END
1324 
1325 bool matches(jobjectArray methods, Method* method) {
1326   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1327 
1328   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1329     oop resolved = methods_oop-&gt;obj_at(i);
1330     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {
1331       return true;
1332     }
1333   }
1334   return false;
1335 }
1336 
1337 C2V_VMENTRY(jobject, getNextStackFrame, (JNIEnv*, jobject compilerToVM, jobject hs_frame, jobjectArray methods, jint initialSkip))
1338   ResourceMark rm;
1339 
1340   if (!thread-&gt;has_last_Java_frame()) return NULL;
1341   Handle result = HotSpotStackFrameReference::klass()-&gt;allocate_instance(thread);
1342   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1343 
1344   StackFrameStream fst(thread);
1345   if (hs_frame != NULL) {
1346     // look for the correct stack frame if one is given
1347     intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1348     while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1349       fst.next();
1350     }
1351     if (fst.current()-&gt;sp() != stack_pointer) {
1352       THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1353     }
1354   }
1355 
1356   int frame_number = 0;
1357   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1358   if (hs_frame != NULL) {
1359     // look for the correct vframe within the stack frame if one is given
1360     int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1361     while (frame_number &lt; last_frame_number) {
1362       if (vf-&gt;is_top()) {
1363         THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1364       }
1365       vf = vf-&gt;sender();
1366       frame_number ++;
1367     }
1368     // move one frame forward
1369     if (vf-&gt;is_top()) {
1370       if (fst.is_done()) {
1371         return NULL;
1372       }
1373       fst.next();
1374       vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1375       frame_number = 0;
1376     } else {
1377       vf = vf-&gt;sender();
1378       frame_number++;
1379     }
1380   }
1381 
1382   while (true) {
1383     // look for the given method
1384     while (true) {
1385       StackValueCollection* locals = NULL;
1386       if (vf-&gt;is_compiled_frame()) {
1387         // compiled method frame
1388         compiledVFrame* cvf = compiledVFrame::cast(vf);
1389         if (methods == NULL || matches(methods, cvf-&gt;method())) {
1390           if (initialSkip &gt; 0) {
1391             initialSkip --;
1392           } else {
1393             ScopeDesc* scope = cvf-&gt;scope();
1394             // native wrapper do not have a scope
1395             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1396               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), scope-&gt;objects(), THREAD);
1397               Deoptimization::reassign_fields(fst.current(), fst.register_map(), scope-&gt;objects(), realloc_failures, false);
1398 
1399               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1400               typeArrayHandle array = oopFactory::new_boolArray(local_values-&gt;length(), thread);
1401               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1402                 ScopeValue* value = local_values-&gt;at(i);
1403                 if (value-&gt;is_object()) {
1404                   array-&gt;bool_at_put(i, true);
1405                 }
1406               }
1407               HotSpotStackFrameReference::set_localIsVirtual(result, array());
1408             } else {
1409               HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1410             }
1411 
1412             locals = cvf-&gt;locals();
1413             HotSpotStackFrameReference::set_bci(result, cvf-&gt;bci());
1414             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);
1415             HotSpotStackFrameReference::set_method(result, method);
1416           }
1417         }
1418       } else if (vf-&gt;is_interpreted_frame()) {
1419         // interpreted method frame
1420         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1421         if (methods == NULL || matches(methods, ivf-&gt;method())) {
1422           if (initialSkip &gt; 0) {
1423             initialSkip --;
1424           } else {
1425             locals = ivf-&gt;locals();
1426             HotSpotStackFrameReference::set_bci(result, ivf-&gt;bci());
1427             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);
1428             HotSpotStackFrameReference::set_method(result, method);
1429             HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1430           }
1431         }
1432       }
1433 
1434       // locals != NULL means that we found a matching frame and result is already partially initialized
1435       if (locals != NULL) {
1436         HotSpotStackFrameReference::set_compilerToVM(result, JNIHandles::resolve(compilerToVM));
1437         HotSpotStackFrameReference::set_stackPointer(result, (jlong) fst.current()-&gt;sp());
1438         HotSpotStackFrameReference::set_frameNumber(result, frame_number);
1439 
1440         // initialize the locals array
1441         objArrayHandle array = oopFactory::new_objectArray(locals-&gt;size(), thread);
1442         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1443           StackValue* var = locals-&gt;at(i);
1444           if (var-&gt;type() == T_OBJECT) {
1445             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1446           }
1447         }
1448         HotSpotStackFrameReference::set_locals(result, array());
1449 
1450         return JNIHandles::make_local(thread, result());
1451       }
1452 
1453       if (vf-&gt;is_top()) {
1454         break;
1455       }
1456       frame_number++;
1457       vf = vf-&gt;sender();
1458     } // end of vframe loop
1459 
1460     if (fst.is_done()) {
1461       break;
1462     }
1463     fst.next();
1464     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1465     frame_number = 0;
1466   } // end of frame loop
1467 
1468   // the end was reached without finding a matching method
1469   return NULL;
1470 C2V_END
1471 
1472 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1473   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1474   CallInfo callInfo;
1475   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1476   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1477   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1478 C2V_END
1479 
1480 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1481   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1482   KlassHandle holder = cp-&gt;klass_ref_at(index, CHECK);
1483   Symbol* name = cp-&gt;name_ref_at(index);
1484   if (MethodHandles::is_signature_polymorphic_name(holder(), name)) {
1485     CallInfo callInfo;
1486     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1487     ConstantPoolCacheEntry* cp_cache_entry = cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1488     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1489   }
1490 C2V_END
1491 
1492 C2V_VMENTRY(jobject, getSignaturePolymorphicHolders, (JNIEnv*, jobject))
1493   objArrayHandle holders = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
1494   Handle mh = java_lang_String::create_from_str("Ljava/lang/invoke/MethodHandle;", CHECK_NULL);
1495   Handle vh = java_lang_String::create_from_str("Ljava/lang/invoke/VarHandle;", CHECK_NULL);
1496   holders-&gt;obj_at_put(0, mh());
1497   holders-&gt;obj_at_put(1, vh());
1498   return JNIHandles::make_local(THREAD, holders());
1499 C2V_END
1500 
1501 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))
1502   //see compute_recording_non_safepoints in debugInfroRec.cpp
1503   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1504     return true;
1505   }
1506   return DebugNonSafepoints;
1507 C2V_END
1508 
1509 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1510 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))
1511   ResourceMark rm;
1512 
1513   if (hs_frame == NULL) {
1514     THROW_MSG(vmSymbols::java_lang_NullPointerException(), "stack frame is null")
1515   }
1516 
1517   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1518 
1519   // look for the given stack frame
1520   StackFrameStream fst(thread);
1521   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1522   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1523     fst.next();
1524   }
1525   if (fst.current()-&gt;sp() != stack_pointer) {
1526     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1527   }
1528 
1529   if (invalidate) {
1530     if (!fst.current()-&gt;is_compiled_frame()) {
1531       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1532     }
1533     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), "nmethod expected");
1534     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1535   }
1536   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1537   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1538   StackFrameStream fstAfterDeopt(thread);
1539   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1540     fstAfterDeopt.next();
1541   }
1542   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1543     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found after deopt")
1544   }
1545 
1546   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1547   if (!vf-&gt;is_compiled_frame()) {
1548     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1549   }
1550 
1551   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1552   while (true) {
1553     assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1554     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1555     if (vf-&gt;is_top()) {
1556       break;
1557     }
1558     vf = vf-&gt;sender();
1559   }
1560 
1561   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1562   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1563     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1564   }
1565 
1566   // Reallocate the non-escaping objects and restore their fields.
1567   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,"invalid scope");
1568   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1569 
1570   if (objects == NULL) {
1571     // no objects to materialize
1572     return;
1573   }
1574 
1575   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, THREAD);
1576   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1577 
1578   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1579     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1580 
1581     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1582     StackValueCollection* locals = cvf-&gt;locals();
1583 
1584     if (locals != NULL) {
1585       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1586         StackValue* var = locals-&gt;at(i2);
1587         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1588           jvalue val;
1589           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1590           cvf-&gt;update_local(T_OBJECT, i2, val);
1591         }
1592       }
1593     }
1594   }
1595 
1596   // all locals are materialized by now
1597   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);
1598 
1599   // update the locals array
1600   objArrayHandle array = HotSpotStackFrameReference::locals(hs_frame);
1601   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1602   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1603     StackValue* var = locals-&gt;at(i);
1604     if (var-&gt;type() == T_OBJECT) {
1605       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1606     }
1607   }
1608 C2V_END
1609 
1610 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))
1611   if (bytes == NULL) {
1612     THROW(vmSymbols::java_lang_NullPointerException());
1613   }
1614   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);
1615 
1616   // Check if offset and length are non negative.
1617   if (offset &lt; 0 || length &lt; 0) {
1618     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1619   }
1620   // Check if the range is valid.
1621   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {
1622     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1623   }
1624   while (length &gt; 0) {
1625     jbyte* start = array-&gt;byte_at_addr(offset);
1626     tty-&gt;write((char*) start, MIN2(length, O_BUFLEN));
1627     length -= O_BUFLEN;
1628     offset += O_BUFLEN;
1629   }
1630 C2V_END
1631 
1632 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))
1633   tty-&gt;flush();
1634 C2V_END
1635 
1636 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))
1637   ResourceMark rm;
1638   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1639   ProfileData* profile_data = mdo-&gt;data_at(position);
1640   if (mdo-&gt;is_valid(profile_data)) {
1641     return profile_data-&gt;size_in_bytes();
1642   }
1643   DataLayout* data    = mdo-&gt;extra_data_base();
1644   DataLayout* end   = mdo-&gt;extra_data_limit();
1645   for (;; data = mdo-&gt;next_extra(data)) {
1646     assert(data &lt; end, "moved past end of extra data");
1647     profile_data = data-&gt;data_in();
1648     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1649       return profile_data-&gt;size_in_bytes();
1650     }
1651   }
1652   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Invalid profile data position %d", position));
1653 C2V_END
1654 
1655 C2V_VMENTRY(jlong, getFingerprint, (JNIEnv*, jobject, jlong metaspace_klass))
1656   Klass *k = CompilerToVM::asKlass(metaspace_klass);
1657   if (k-&gt;is_instance_klass()) {
1658     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1659   } else {
1660     return 0;
1661   }
1662 C2V_END
1663 
1664 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))
1665   if (bytecode_frame_handle == NULL) {
1666     THROW_0(vmSymbols::java_lang_NullPointerException());
1667   }
1668 
1669   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);
1670   oop bytecode_frame = top_bytecode_frame;
1671   int size = 0;
1672   int callee_parameters = 0;
1673   int callee_locals = 0;
1674   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1675   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);
1676 
1677   while (bytecode_frame != NULL) {
1678     int locks = BytecodeFrame::numLocks(bytecode_frame);
1679     int temps = BytecodeFrame::numStack(bytecode_frame);
1680     bool is_top_frame = (bytecode_frame == top_bytecode_frame);
1681     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1682 
1683     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1684                                                                  temps + callee_parameters,
1685                                                                  extra_args,
1686                                                                  locks,
1687                                                                  callee_parameters,
1688                                                                  callee_locals,
1689                                                                  is_top_frame);
1690     size += frame_size;
1691 
1692     callee_parameters = method-&gt;size_of_parameters();
1693     callee_locals = method-&gt;max_locals();
1694     extra_args = 0;
1695     bytecode_frame = BytecodePosition::caller(bytecode_frame);
1696   }
1697   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1698 C2V_END
1699 
1700 C2V_VMENTRY(void, compileToBytecode, (JNIEnv*, jobject, jobject lambda_form_handle))
1701   Handle lambda_form = JNIHandles::resolve_non_null(lambda_form_handle);
1702   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1703     TempNewSymbol compileToBytecode = SymbolTable::new_symbol("compileToBytecode", CHECK);
1704     JavaValue result(T_VOID);
1705     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1706   } else {
1707     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1708                 err_msg("Unexpected type: %s", lambda_form-&gt;klass()-&gt;external_name()));
1709   }
1710 C2V_END
1711 
1712 #define CC (char*)  /*cast a literal from (const char*)*/
1713 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1714 
1715 #define STRING                "Ljava/lang/String;"
1716 #define OBJECT                "Ljava/lang/Object;"
1717 #define CLASS                 "Ljava/lang/Class;"
1718 #define EXECUTABLE            "Ljava/lang/reflect/Executable;"
1719 #define STACK_TRACE_ELEMENT   "Ljava/lang/StackTraceElement;"
1720 #define INSTALLED_CODE        "Ljdk/vm/ci/code/InstalledCode;"
1721 #define TARGET_DESCRIPTION    "Ljdk/vm/ci/code/TargetDescription;"
1722 #define BYTECODE_FRAME        "Ljdk/vm/ci/code/BytecodeFrame;"
1723 #define RESOLVED_METHOD       "Ljdk/vm/ci/meta/ResolvedJavaMethod;"
1724 #define HS_RESOLVED_METHOD    "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;"
1725 #define HS_RESOLVED_KLASS     "Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;"
1726 #define HS_CONSTANT_POOL      "Ljdk/vm/ci/hotspot/HotSpotConstantPool;"
1727 #define HS_COMPILED_CODE      "Ljdk/vm/ci/hotspot/HotSpotCompiledCode;"
1728 #define HS_CONFIG             "Ljdk/vm/ci/hotspot/HotSpotVMConfig;"
1729 #define HS_METADATA           "Ljdk/vm/ci/hotspot/HotSpotMetaData;"
1730 #define HS_STACK_FRAME_REF    "Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;"
1731 #define HS_SPECULATION_LOG    "Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;"
1732 #define METASPACE_METHOD_DATA "J"
1733 
1734 JNINativeMethod CompilerToVM::methods[] = {
1735   {CC "getBytecode",                                  CC "(" HS_RESOLVED_METHOD ")[B",                                                      FN_PTR(getBytecode)},
1736   {CC "getExceptionTableStart",                       CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getExceptionTableStart)},
1737   {CC "getExceptionTableLength",                      CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getExceptionTableLength)},
1738   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1739   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1740   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1741   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1742   {CC "doNotInlineOrCompile",                         CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(doNotInlineOrCompile)},
1743   {CC "isCompilable",                                 CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(isCompilable)},
1744   {CC "hasNeverInlineDirective",                      CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(hasNeverInlineDirective)},
1745   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1746   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1747   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1748   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1749   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1750   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1751   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1752   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1753   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1754   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1755   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1756   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1757   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
<a name="33" id="anc33"></a><span class="changed">1758   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[I)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},</span>
1759   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1760   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1761   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1762   {CC "getSignaturePolymorphicHolders",               CC "()[" STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
1763   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1764   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1765   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1766   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1767   {CC "asResolvedJavaMethod",                         CC "(" EXECUTABLE ")" HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
1768   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1769   {CC "getConstantPool",                              CC "(Ljava/lang/Object;)" HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},
1770   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1771   {CC "readConfiguration",                            CC "()[" OBJECT,                                                                      FN_PTR(readConfiguration)},
1772   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1773   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1774   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1775   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1776   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1777   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1778   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1779   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1780   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1781   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1782   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1783   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1784   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1785   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1786   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1787   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1788   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1789   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1790   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1791   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1792   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1793   {CC "getFingerprint",                               CC "(J)J",                                                                            FN_PTR(getFingerprint)},
1794   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1795   {CC "compileToBytecode",                            CC "(" OBJECT ")V",                                                                   FN_PTR(compileToBytecode)},
<a name="34" id="anc34"></a><span class="new">1796   {CC "getFlagValue",                                 CC "(" STRING ")" OBJECT,                                                             FN_PTR(getFlagValue)},</span>
1797 };
1798 
1799 int CompilerToVM::methods_count() {
1800   return sizeof(methods) / sizeof(JNINativeMethod);
1801 }
<a name="35" id="anc35"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="35" type="hidden" /></form></body></html>
