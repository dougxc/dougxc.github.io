<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Udiff src/share/vm/jvmci/jvmciCompilerToVM.cpp</title>

<style type="text/css" media="screen">
span.new {
    color: blue;
    font-weight: normal;
}
</style>

</head>
<body id="SUNWwebrev">
<center><a href='../../../../src/jdk.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java.udiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/share/vm/jvmci/jvmciCompilerToVM.hpp.udiff.html' target='_top'>next &gt</a></center>
<h2>src/share/vm/jvmci/jvmciCompilerToVM.cpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12604">12604</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8173912">8173912</a>: [JVMCI] fix memory overhead of JVMCI</pre>
        <pre>
</pre><hr /><pre>
<span class="newmarker">@@ -51,10 +51,11 @@</span>
 #include "runtime/deoptimization.hpp"
 #include "runtime/timerTrace.hpp"
 #include "runtime/vframe.hpp"
 #include "runtime/vframe_hp.hpp"
 #include "runtime/vmStructs.hpp"
<span class="new">+#include "utilities/resourceHash.hpp"</span>
 
 
 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
 #define C2V_VMENTRY(result_type, name, signature) \
   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
</pre><hr /><pre>
<span class="newmarker">@@ -118,19 +119,31 @@</span>
 jbyte* CompilerToVM::Data::cardtable_start_address;
 int CompilerToVM::Data::cardtable_shift;
 
 int CompilerToVM::Data::vm_page_size;
 
<span class="new">+int CompilerToVM::Data::sizeof_vtableEntry = sizeof(vtableEntry);</span>
<span class="new">+int CompilerToVM::Data::sizeof_ExceptionTableElement = sizeof(ExceptionTableElement);</span>
<span class="new">+int CompilerToVM::Data::sizeof_LocalVariableTableElement = sizeof(LocalVariableTableElement);</span>
<span class="new">+int CompilerToVM::Data::sizeof_ConstantPool = sizeof(ConstantPool);</span>
<span class="new">+int CompilerToVM::Data::sizeof_SymbolPointer = sizeof(Symbol*);</span>
<span class="new">+int CompilerToVM::Data::sizeof_narrowKlass = sizeof(narrowKlass);</span>
<span class="new">+int CompilerToVM::Data::sizeof_arrayOopDesc = sizeof(arrayOopDesc);</span>
<span class="new">+int CompilerToVM::Data::sizeof_BasicLock = sizeof(BasicLock);</span>
<span class="new">+</span>
 address CompilerToVM::Data::dsin;
 address CompilerToVM::Data::dcos;
 address CompilerToVM::Data::dtan;
 address CompilerToVM::Data::dexp;
 address CompilerToVM::Data::dlog;
 address CompilerToVM::Data::dlog10;
 address CompilerToVM::Data::dpow;
 
<span class="removed">-void CompilerToVM::Data::initialize() {</span>
<span class="new">+address CompilerToVM::Data::symbol_init;</span>
<span class="new">+address CompilerToVM::Data::symbol_clinit;</span>
<span class="new">+</span>
<span class="new">+void CompilerToVM::Data::initialize(TRAPS) {</span>
   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 
   Method_extra_stack_entries = Method::extra_stack_entries();
 
</pre><hr /><pre>
<span class="newmarker">@@ -158,10 +171,13 @@</span>
   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 
<span class="new">+  symbol_init = (address) vmSymbols::object_initializer_name();</span>
<span class="new">+  symbol_clinit = (address) vmSymbols::class_initializer_name();</span>
<span class="new">+</span>
   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
   switch (bs-&gt;kind()) {
   case BarrierSet::CardTableModRef:
   case BarrierSet::CardTableForRS:
   case BarrierSet::CardTableExtension:
</pre><hr /><pre>
<span class="newmarker">@@ -177,11 +193,11 @@</span>
     cardtable_start_address = 0;
     cardtable_shift = 0;
     // No post barriers
     break;
   default:
<span class="removed">-    ShouldNotReachHere();</span>
<span class="new">+    JVMCI_ERROR("Unsupported BarrierSet kind %d", bs-&gt;kind());</span>
     break;
   }
 
   vm_page_size = os::vm_page_size();
 
</pre><hr /><pre>
<span class="newmarker">@@ -235,17 +251,118 @@</span>
   assert(index == vmIntrinsics::ID_LIMIT - 1, "must be");
 
   return vmIntrinsics;
 }
 
<span class="removed">-C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))</span>
<span class="removed">-#define BOXED_LONG(name, value) oop name; do { jvalue p; p.j = (jlong) (value); name = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL);} while(0)</span>
<span class="new">+/**</span>
<span class="new">+ * The set of VM flags known to be used.</span>
<span class="new">+ */</span>
<span class="new">+#define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_intx_flag, do_uintx_flag) \</span>
<span class="new">+  do_intx_flag(AllocateInstancePrefetchLines)                              \</span>
<span class="new">+  do_intx_flag(AllocatePrefetchDistance)                                   \</span>
<span class="new">+  do_intx_flag(AllocatePrefetchInstr)                                      \</span>
<span class="new">+  do_intx_flag(AllocatePrefetchLines)                                      \</span>
<span class="new">+  do_intx_flag(AllocatePrefetchStepSize)                                   \</span>
<span class="new">+  do_intx_flag(AllocatePrefetchStyle)                                      \</span>
<span class="new">+  do_intx_flag(BciProfileWidth)                                            \</span>
<span class="new">+  do_bool_flag(BootstrapJVMCI)                                             \</span>
<span class="new">+  do_bool_flag(CITime)                                                     \</span>
<span class="new">+  do_bool_flag(CITimeEach)                                                 \</span>
<span class="new">+  do_uintx_flag(CodeCacheSegmentSize)                                      \</span>
<span class="new">+  do_intx_flag(CodeEntryAlignment)                                         \</span>
<span class="new">+  do_bool_flag(CompactFields)                                              \</span>
<span class="new">+  NOT_PRODUCT(do_intx_flag(CompileTheWorldStartAt))                        \</span>
<span class="new">+  NOT_PRODUCT(do_intx_flag(CompileTheWorldStopAt))                         \</span>
<span class="new">+  do_intx_flag(ContendedPaddingWidth)                                      \</span>
<span class="new">+  do_bool_flag(DontCompileHugeMethods)                                     \</span>
<span class="new">+  do_bool_flag(EnableContended)                                            \</span>
<span class="new">+  do_intx_flag(FieldsAllocationStyle)                                      \</span>
<span class="new">+  do_bool_flag(FoldStableValues)                                           \</span>
<span class="new">+  do_bool_flag(ForceUnreachable)                                           \</span>
<span class="new">+  do_intx_flag(HugeMethodLimit)                                            \</span>
<span class="new">+  do_bool_flag(Inline)                                                     \</span>
<span class="new">+  do_intx_flag(JVMCICounterSize)                                           \</span>
<span class="new">+  do_bool_flag(JVMCIPrintProperties)                                       \</span>
<span class="new">+  do_bool_flag(JVMCIUseFastLocking)                                        \</span>
<span class="new">+  do_intx_flag(MethodProfileWidth)                                         \</span>
<span class="new">+  do_intx_flag(ObjectAlignmentInBytes)                                     \</span>
<span class="new">+  do_bool_flag(PrintInlining)                                              \</span>
<span class="new">+  do_bool_flag(ReduceInitialCardMarks)                                     \</span>
<span class="new">+  do_bool_flag(RestrictContended)                                          \</span>
<span class="new">+  do_intx_flag(StackReservedPages)                                         \</span>
<span class="new">+  do_intx_flag(StackShadowPages)                                           \</span>
<span class="new">+  do_bool_flag(TLABStats)                                                  \</span>
<span class="new">+  do_uintx_flag(TLABWasteIncrement)                                        \</span>
<span class="new">+  do_intx_flag(TypeProfileWidth)                                           \</span>
<span class="new">+  do_bool_flag(UseAESIntrinsics)                                           \</span>
<span class="new">+  X86_ONLY(do_intx_flag(UseAVX))                                           \</span>
<span class="new">+  do_bool_flag(UseBiasedLocking)                                           \</span>
<span class="new">+  do_bool_flag(UseCRC32Intrinsics)                                         \</span>
<span class="new">+  do_bool_flag(UseCompressedClassPointers)                                 \</span>
<span class="new">+  do_bool_flag(UseCompressedOops)                                          \</span>
<span class="new">+  do_bool_flag(UseConcMarkSweepGC)                                         \</span>
<span class="new">+  X86_ONLY(do_bool_flag(UseCountLeadingZerosInstruction))                  \</span>
<span class="new">+  X86_ONLY(do_bool_flag(UseCountTrailingZerosInstruction))                 \</span>
<span class="new">+  do_bool_flag(UseG1GC)                                                    \</span>
<span class="new">+  COMPILER2_PRESENT(do_bool_flag(UseMontgomeryMultiplyIntrinsic))          \</span>
<span class="new">+  COMPILER2_PRESENT(do_bool_flag(UseMontgomerySquareIntrinsic))            \</span>
<span class="new">+  COMPILER2_PRESENT(do_bool_flag(UseMulAddIntrinsic))                      \</span>
<span class="new">+  COMPILER2_PRESENT(do_bool_flag(UseMultiplyToLenIntrinsic))               \</span>
<span class="new">+  do_bool_flag(UsePopCountInstruction)                                     \</span>
<span class="new">+  do_bool_flag(UseSHA1Intrinsics)                                          \</span>
<span class="new">+  do_bool_flag(UseSHA256Intrinsics)                                        \</span>
<span class="new">+  do_bool_flag(UseSHA512Intrinsics)                                        \</span>
<span class="new">+  do_intx_flag(UseSSE)                                                     \</span>
<span class="new">+  COMPILER2_PRESENT(do_bool_flag(UseSquareToLenIntrinsic))                 \</span>
<span class="new">+  do_bool_flag(UseStackBanging)                                            \</span>
<span class="new">+  do_bool_flag(UseTLAB)                                                    \</span>
<span class="new">+  do_bool_flag(VerifyOops)                                                 \</span>
<span class="new">+</span>
<span class="new">+#define BOXED_BOOLEAN(name, value) oop name = ((jboolean)(value) ? boxedTrue() : boxedFalse())</span>
 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)
<span class="new">+#define BOXED_LONG(name, value) \</span>
<span class="new">+  oop name; \</span>
<span class="new">+  do { \</span>
<span class="new">+    jvalue p; p.j = (jlong) (value); \</span>
<span class="new">+    Handle* e = longs.get(p.j); \</span>
<span class="new">+    if (e == NULL) { \</span>
<span class="new">+      Handle h = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); \</span>
<span class="new">+      longs.put(p.j, h); \</span>
<span class="new">+      name = h(); \</span>
<span class="new">+    } else { \</span>
<span class="new">+      name = (*e)(); \</span>
<span class="new">+    } \</span>
<span class="new">+  } while (0)</span>
<span class="new">+</span>
<span class="new">+#define CSTRING_TO_JSTRING(name, value) \</span>
<span class="new">+  Handle name; \</span>
<span class="new">+  do { \</span>
<span class="new">+    if (value != NULL) { \</span>
<span class="new">+      Handle* e = strings.get(value); \</span>
<span class="new">+      if (e == NULL) { \</span>
<span class="new">+        Handle h = java_lang_String::create_from_str(value, CHECK_NULL); \</span>
<span class="new">+        strings.put(value, h); \</span>
<span class="new">+        name = h(); \</span>
<span class="new">+      } else { \</span>
<span class="new">+        name = (*e)(); \</span>
<span class="new">+      } \</span>
<span class="new">+    } \</span>
<span class="new">+  } while (0)</span>
<span class="new">+</span>
<span class="new">+C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))</span>
   ResourceMark rm;
   HandleMark hm;
 
<span class="removed">-  CompilerToVM::Data::initialize();</span>
<span class="new">+  // Used to canonicalize Long and String values.</span>
<span class="new">+  ResourceHashtable&lt;jlong, Handle&gt; longs;</span>
<span class="new">+  ResourceHashtable&lt;const char*, Handle, &amp;CompilerToVM::cstring_hash, &amp;CompilerToVM::cstring_equals&gt; strings;</span>
<span class="new">+</span>
<span class="new">+  jvalue prim;</span>
<span class="new">+  prim.z = true;  Handle boxedTrue =  java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="new">+  prim.z = false; Handle boxedFalse = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="new">+</span>
<span class="new">+  CompilerToVM::Data::initialize(CHECK_NULL);</span>
 
   VMField::klass()-&gt;initialize(CHECK_NULL);
   VMFlag::klass()-&gt;initialize(CHECK_NULL);
   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);
 
</pre><hr /><pre>
<span class="newmarker">@@ -255,140 +372,165 @@</span>
     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);
     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* "::" */;
     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
     sprintf(name_buf, "%s::%s", vmField.typeName, vmField.fieldName);
<span class="removed">-    Handle name = java_lang_String::create_from_str(name_buf, CHECK_NULL);</span>
<span class="removed">-    Handle type = java_lang_String::create_from_str(vmField.typeString, CHECK_NULL);</span>
<span class="new">+    CSTRING_TO_JSTRING(name, name_buf);</span>
<span class="new">+    CSTRING_TO_JSTRING(type, vmField.typeString);</span>
     VMField::set_name(vmFieldObj, name());
     VMField::set_type(vmFieldObj, type());
     VMField::set_offset(vmFieldObj, vmField.offset);
     VMField::set_address(vmFieldObj, (jlong) vmField.address);
<span class="removed">-    if (vmField.isStatic) {</span>
<span class="new">+    if (vmField.isStatic &amp;&amp; vmField.typeString != NULL) {</span>
       if (strcmp(vmField.typeString, "bool") == 0) {
<span class="removed">-        BOXED_LONG(value, *(jbyte*) vmField.address);</span>
<span class="removed">-        VMField::set_value(vmFieldObj, value);</span>
<span class="new">+        BOXED_BOOLEAN(box, *(jbyte*) vmField.address);</span>
<span class="new">+        VMField::set_value(vmFieldObj, box);</span>
       } else if (strcmp(vmField.typeString, "int") == 0 ||
                  strcmp(vmField.typeString, "jint") == 0) {
<span class="removed">-        BOXED_LONG(value, *(jint*) vmField.address);</span>
<span class="removed">-        VMField::set_value(vmFieldObj, value);</span>
<span class="new">+        BOXED_LONG(box, *(jint*) vmField.address);</span>
<span class="new">+        VMField::set_value(vmFieldObj, box);</span>
       } else if (strcmp(vmField.typeString, "uint64_t") == 0) {
<span class="removed">-        BOXED_LONG(value, *(uint64_t*) vmField.address);</span>
<span class="removed">-        VMField::set_value(vmFieldObj, value);</span>
<span class="new">+        BOXED_LONG(box, *(uint64_t*) vmField.address);</span>
<span class="new">+        VMField::set_value(vmFieldObj, box);</span>
       } else if (strcmp(vmField.typeString, "address") == 0 ||
                  strcmp(vmField.typeString, "intptr_t") == 0 ||
                  strcmp(vmField.typeString, "uintptr_t") == 0 ||
                  strcmp(vmField.typeString, "size_t") == 0 ||
                  // All foo* types are addresses.
                  vmField.typeString[strlen(vmField.typeString) - 1] == '*') {
<span class="removed">-        BOXED_LONG(value, *((address*) vmField.address));</span>
<span class="removed">-        VMField::set_value(vmFieldObj, value);</span>
<span class="new">+        BOXED_LONG(box, *((address*) vmField.address));</span>
<span class="new">+        VMField::set_value(vmFieldObj, box);</span>
       } else {
         JVMCI_ERROR_NULL("VM field %s has unsupported type %s", name_buf, vmField.typeString);
       }
     }
     vmFields-&gt;obj_at_put(i, vmFieldObj());
   }
 
<span class="removed">-  len = JVMCIVMStructs::localHotSpotVMTypes_count();</span>
<span class="removed">-  objArrayHandle vmTypes = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);</span>
<span class="removed">-  for (int i = 0; i &lt; len ; i++) {</span>
<span class="removed">-    VMTypeEntry vmType = JVMCIVMStructs::localHotSpotVMTypes[i];</span>
<span class="removed">-    Handle name = java_lang_String::create_from_str(vmType.typeName, CHECK_NULL);</span>
<span class="removed">-    BOXED_LONG(size, vmType.size);</span>
<span class="removed">-    vmTypes-&gt;obj_at_put(i * 2, name());</span>
<span class="removed">-    vmTypes-&gt;obj_at_put(i * 2 + 1, size);</span>
<span class="removed">-  }</span>
<span class="removed">-</span>
   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
   len = ints_len + longs_len;
   objArrayHandle vmConstants = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
   int insert = 0;
   for (int i = 0; i &lt; ints_len ; i++) {
     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
<span class="removed">-    Handle name = java_lang_String::create_from_str(c.name, CHECK_NULL);</span>
<span class="new">+    CSTRING_TO_JSTRING(name, c.name);</span>
     BOXED_LONG(value, c.value);
     vmConstants-&gt;obj_at_put(insert++, name());
     vmConstants-&gt;obj_at_put(insert++, value);
   }
   for (int i = 0; i &lt; longs_len ; i++) {
     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
<span class="removed">-    Handle name = java_lang_String::create_from_str(c.name, CHECK_NULL);</span>
<span class="new">+    CSTRING_TO_JSTRING(name, c.name);</span>
     BOXED_LONG(value, c.value);
     vmConstants-&gt;obj_at_put(insert++, name());
     vmConstants-&gt;obj_at_put(insert++, value);
   }
   assert(insert == len * 2, "must be");
 
   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
   objArrayHandle vmAddresses = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
   for (int i = 0; i &lt; len ; i++) {
     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
<span class="removed">-    Handle name = java_lang_String::create_from_str(a.name, CHECK_NULL);</span>
<span class="new">+    CSTRING_TO_JSTRING(name, a.name);</span>
     BOXED_LONG(value, a.value);
     vmAddresses-&gt;obj_at_put(i * 2, name());
     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);
   }
 
<span class="removed">-  // The last entry is the null entry.</span>
<span class="removed">-  len = (int) Flag::numFlags - 1;</span>
<span class="new">+#define COUNT_FLAG(ignore) +1</span>
<span class="new">+#ifdef ASSERT</span>
<span class="new">+#define CHECK_FLAG(type, name) { \</span>
<span class="new">+  Flag* flag = Flag::find_flag(#name, strlen(#name), /*allow_locked*/ true, /* return_flag */ true); \</span>
<span class="new">+  assert(flag != NULL, "No such flag named " #name); \</span>
<span class="new">+  assert(flag-&gt;is_##type(), "Flag " #name " is not of type " #type); \</span>
<span class="new">+}</span>
<span class="new">+#else</span>
<span class="new">+#define CHECK_FLAG(type, name)</span>
<span class="new">+#endif</span>
<span class="new">+</span>
<span class="new">+#define ADD_FLAG(type, name, convert) { \</span>
<span class="new">+  CHECK_FLAG(type, name) \</span>
<span class="new">+  instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL); \</span>
<span class="new">+  CSTRING_TO_JSTRING(fname, #name); \</span>
<span class="new">+  CSTRING_TO_JSTRING(ftype, #type); \</span>
<span class="new">+  VMFlag::set_name(vmFlagObj, fname()); \</span>
<span class="new">+  VMFlag::set_type(vmFlagObj, ftype()); \</span>
<span class="new">+  convert(value, name); \</span>
<span class="new">+  VMFlag::set_value(vmFlagObj, value); \</span>
<span class="new">+  vmFlags-&gt;obj_at_put(i++, vmFlagObj()); \</span>
<span class="new">+}</span>
<span class="new">+#define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)</span>
<span class="new">+#define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)</span>
<span class="new">+#define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)</span>
<span class="new">+</span>
<span class="new">+  len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);</span>
   objArrayHandle vmFlags = oopFactory::new_objArray(VMFlag::klass(), len, CHECK_NULL);
<span class="removed">-  for (int i = 0; i &lt; len; i++) {</span>
<span class="removed">-    Flag* flag = &amp;Flag::flags[i];</span>
<span class="removed">-    instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL);</span>
<span class="removed">-    Handle name = java_lang_String::create_from_str(flag-&gt;_name, CHECK_NULL);</span>
<span class="removed">-    Handle type = java_lang_String::create_from_str(flag-&gt;_type, CHECK_NULL);</span>
<span class="removed">-    VMFlag::set_name(vmFlagObj, name());</span>
<span class="removed">-    VMFlag::set_type(vmFlagObj, type());</span>
<span class="new">+  int i = 0;</span>
<span class="new">+  PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)</span>
<span class="new">+</span>
<span class="new">+  objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);</span>
<span class="new">+</span>
<span class="new">+  objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 5, CHECK_NULL);</span>
<span class="new">+  data-&gt;obj_at_put(0, vmFields());</span>
<span class="new">+  data-&gt;obj_at_put(1, vmConstants());</span>
<span class="new">+  data-&gt;obj_at_put(2, vmAddresses());</span>
<span class="new">+  data-&gt;obj_at_put(3, vmFlags());</span>
<span class="new">+  data-&gt;obj_at_put(4, vmIntrinsics());</span>
<span class="new">+</span>
<span class="new">+  return (jobjectArray) JNIHandles::make_local(THREAD, data);</span>
<span class="new">+#undef COUNT_FLAG</span>
<span class="new">+#undef ADD_FLAG</span>
<span class="new">+#undef ADD_BOOL_FLAG</span>
<span class="new">+#undef ADD_INTX_FLAG</span>
<span class="new">+#undef ADD_UINTX_FLAG</span>
<span class="new">+#undef CHECK_FLAG</span>
<span class="new">+C2V_END</span>
<span class="new">+</span>
<span class="new">+C2V_VMENTRY(jobject, getFlagValue, (JNIEnv *, jobject c2vm, jobject name_handle))</span>
<span class="new">+#define RETURN_BOXED_LONG(value) oop box; jvalue p; p.j = (jlong) (value); box = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);</span>
<span class="new">+#define RETURN_BOXED_DOUBLE(value) oop box; jvalue p; p.d = (jdouble) (value); box = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);</span>
<span class="new">+  Handle name = JNIHandles::resolve(name_handle);</span>
<span class="new">+  if (name.is_null()) {</span>
<span class="new">+    THROW_0(vmSymbols::java_lang_NullPointerException());</span>
<span class="new">+  }</span>
<span class="new">+  ResourceMark rm;</span>
<span class="new">+  const char* cstring = java_lang_String::as_utf8_string(name());</span>
<span class="new">+  Flag* flag = Flag::find_flag(cstring, strlen(cstring), /* allow_locked */ true, /* return_flag */ true);</span>
<span class="new">+  if (flag == NULL) {</span>
<span class="new">+    return c2vm;</span>
<span class="new">+  }</span>
     if (flag-&gt;is_bool()) {
<span class="removed">-      BOXED_LONG(value, flag-&gt;get_bool());</span>
<span class="removed">-      VMFlag::set_value(vmFlagObj, value);</span>
<span class="new">+    jvalue prim;</span>
<span class="new">+    prim.z = flag-&gt;get_bool();</span>
<span class="new">+    oop box = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="new">+    return JNIHandles::make_local(THREAD, box);</span>
     } else if (flag-&gt;is_ccstr()) {
       Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
<span class="removed">-      VMFlag::set_value(vmFlagObj, value());</span>
<span class="removed">-    } else if (flag-&gt;is_int()) {</span>
<span class="removed">-      BOXED_LONG(value, flag-&gt;get_int());</span>
<span class="removed">-      VMFlag::set_value(vmFlagObj, value);</span>
<span class="new">+    return JNIHandles::make_local(THREAD, value());</span>
     } else if (flag-&gt;is_intx()) {
<span class="removed">-      BOXED_LONG(value, flag-&gt;get_intx());</span>
<span class="removed">-      VMFlag::set_value(vmFlagObj, value);</span>
<span class="new">+    RETURN_BOXED_LONG(flag-&gt;get_intx());</span>
<span class="new">+  } else if (flag-&gt;is_int()) {</span>
<span class="new">+    RETURN_BOXED_LONG(flag-&gt;get_int());</span>
     } else if (flag-&gt;is_uint()) {
<span class="removed">-      BOXED_LONG(value, flag-&gt;get_uint());</span>
<span class="removed">-      VMFlag::set_value(vmFlagObj, value);</span>
<span class="new">+    RETURN_BOXED_LONG(flag-&gt;get_uint());</span>
     } else if (flag-&gt;is_uint64_t()) {
<span class="removed">-      BOXED_LONG(value, flag-&gt;get_uint64_t());</span>
<span class="removed">-      VMFlag::set_value(vmFlagObj, value);</span>
<span class="new">+    RETURN_BOXED_LONG(flag-&gt;get_uint64_t());</span>
<span class="new">+  } else if (flag-&gt;is_size_t()) {</span>
<span class="new">+    RETURN_BOXED_LONG(flag-&gt;get_size_t());</span>
     } else if (flag-&gt;is_uintx()) {
<span class="removed">-      BOXED_LONG(value, flag-&gt;get_uintx());</span>
<span class="removed">-      VMFlag::set_value(vmFlagObj, value);</span>
<span class="new">+    RETURN_BOXED_LONG(flag-&gt;get_uintx());</span>
     } else if (flag-&gt;is_double()) {
<span class="removed">-      BOXED_DOUBLE(value, flag-&gt;get_double());</span>
<span class="removed">-      VMFlag::set_value(vmFlagObj, value);</span>
<span class="removed">-    } else if (flag-&gt;is_size_t()) {</span>
<span class="removed">-      BOXED_LONG(value, flag-&gt;get_size_t());</span>
<span class="removed">-      VMFlag::set_value(vmFlagObj, value);</span>
<span class="new">+    RETURN_BOXED_DOUBLE(flag-&gt;get_double());</span>
     } else {
       JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
     }
<span class="removed">-    vmFlags-&gt;obj_at_put(i, vmFlagObj());</span>
<span class="removed">-  }</span>
<span class="removed">-</span>
<span class="removed">-  objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);</span>
<span class="removed">-</span>
<span class="removed">-  objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 6, CHECK_NULL);</span>
<span class="removed">-  data-&gt;obj_at_put(0, vmFields());</span>
<span class="removed">-  data-&gt;obj_at_put(1, vmTypes());</span>
<span class="removed">-  data-&gt;obj_at_put(2, vmConstants());</span>
<span class="removed">-  data-&gt;obj_at_put(3, vmAddresses());</span>
<span class="removed">-  data-&gt;obj_at_put(4, vmFlags());</span>
<span class="removed">-  data-&gt;obj_at_put(5, vmIntrinsics());</span>
<span class="new">+C2V_END</span>
 
<span class="removed">-  return (jobjectArray) JNIHandles::make_local(THREAD, data);</span>
 #undef BOXED_LONG
 #undef BOXED_DOUBLE
<span class="removed">-C2V_END</span>
<span class="new">+#undef CSTRING_TO_JSTRING</span>
 
 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
   methodHandle method = CompilerToVM::asMethod(jvmci_method);
   ResourceMark rm;
 
</pre><hr /><pre>
<span class="newmarker">@@ -741,21 +883,24 @@</span>
 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
   return cp-&gt;remap_instruction_operand_from_cache(index);
 C2V_END
 
<span class="removed">-C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jlongArray info_handle))</span>
<span class="new">+C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))</span>
   ResourceMark rm;
   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
   fieldDescriptor fd;
   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
<span class="removed">-  assert(info != NULL &amp;&amp; info-&gt;length() == 2, "must be");</span>
<span class="removed">-  info-&gt;long_at_put(0, (jlong) fd.access_flags().as_int());</span>
<span class="removed">-  info-&gt;long_at_put(1, (jlong) fd.offset());</span>
<span class="new">+  if (info == NULL || info-&gt;length() != 3) {</span>
<span class="new">+    JVMCI_ERROR_NULL("info must not be null and have a length of 3");</span>
<span class="new">+  }</span>
<span class="new">+  info-&gt;int_at_put(0, fd.access_flags().as_int());</span>
<span class="new">+  info-&gt;int_at_put(1, fd.offset());</span>
<span class="new">+  info-&gt;int_at_put(2, fd.index());</span>
   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
   return JNIHandles::make_local(THREAD, field_holder);
 C2V_END
 
 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
</pre><hr /><pre>
<span class="newmarker">@@ -1608,11 +1753,11 @@</span>
   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
<span class="removed">-  {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[J)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},</span>
<span class="new">+  {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[I)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},</span>
   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
   {CC "getSignaturePolymorphicHolders",               CC "()[" STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
</pre><hr /><pre>
<span class="newmarker">@@ -1646,10 +1791,11 @@</span>
   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
   {CC "getFingerprint",                               CC "(J)J",                                                                            FN_PTR(getFingerprint)},
   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
   {CC "compileToBytecode",                            CC "(" OBJECT ")V",                                                                   FN_PTR(compileToBytecode)},
<span class="new">+  {CC "getFlagValue",                                 CC "(" STRING ")" OBJECT,                                                             FN_PTR(getFlagValue)},</span>
 };
 
 int CompilerToVM::methods_count() {
   return sizeof(methods) / sizeof(JNINativeMethod);
 }
</pre>
<center><a href='../../../../src/jdk.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java.udiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/share/vm/jvmci/jvmciCompilerToVM.hpp.udiff.html' target='_top'>next &gt</a></center>
</body></html>

