<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/share/vm/jvmci/jvmciCompilerToVM.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "code/codeCache.hpp"
  27 #include "code/scopeDesc.hpp"
  28 #include "interpreter/linkResolver.hpp"
  29 #include "memory/oopFactory.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "oops/generateOopMap.hpp"
  32 #include "oops/fieldStreams.hpp"
  33 #include "oops/oop.inline.hpp"
  34 #include "oops/objArrayOop.inline.hpp"
  35 #include "runtime/fieldDescriptor.hpp"
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"
  56 
  57 
  58 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  59 #define C2V_VMENTRY(result_type, name, signature) \
  60   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  61   TRACE_jvmci_1("CompilerToVM::" #name); \
  62   TRACE_CALL(result_type, jvmci_ ## name signature) \
  63   JVMCI_VM_ENTRY_MARK; \
  64 
  65 #define C2V_END }
  66 
  67 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  68   if (method() != NULL) {
  69     JavaValue result(T_OBJECT);
  70     JavaCallArguments args;
  71     args.push_long((jlong) (address) method());
  72     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  73 
  74     return (oop)result.get_jobject();
  75   }
  76   return NULL;
  77 }
  78 
  79 oop CompilerToVM::get_jvmci_type(KlassHandle klass, TRAPS) {
  80   if (klass() != NULL) {
  81     JavaValue result(T_OBJECT);
  82     JavaCallArguments args;
  83     args.push_oop(klass-&gt;java_mirror());
  84     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  85 
  86     return (oop)result.get_jobject();
  87   }
  88   return NULL;
  89 }
  90 
  91 int CompilerToVM::Data::Klass_vtable_start_offset;
  92 int CompilerToVM::Data::Klass_vtable_length_offset;
  93 
  94 int CompilerToVM::Data::Method_extra_stack_entries;
  95 
  96 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
  97 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
  98 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
  99 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 100 
 101 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 102 
 103 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 104 int CompilerToVM::Data::Universe_base_vtable_size;
 105 address CompilerToVM::Data::Universe_narrow_oop_base;
 106 int CompilerToVM::Data::Universe_narrow_oop_shift;
 107 address CompilerToVM::Data::Universe_narrow_klass_base;
 108 int CompilerToVM::Data::Universe_narrow_klass_shift;
 109 void* CompilerToVM::Data::Universe_non_oop_bits;
 110 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 111 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 112 
 113 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 114 HeapWord** CompilerToVM::Data::_heap_end_addr;
 115 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
 116 int CompilerToVM::Data::_max_oop_map_stack_offset;
 117 
 118 jbyte* CompilerToVM::Data::cardtable_start_address;
 119 int CompilerToVM::Data::cardtable_shift;
 120 
 121 int CompilerToVM::Data::vm_page_size;
 122 
 123 address CompilerToVM::Data::dsin;
 124 address CompilerToVM::Data::dcos;
 125 address CompilerToVM::Data::dtan;
 126 address CompilerToVM::Data::dexp;
 127 address CompilerToVM::Data::dlog;
 128 address CompilerToVM::Data::dlog10;
 129 address CompilerToVM::Data::dpow;
 130 
 131 void CompilerToVM::Data::initialize() {
 132   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 133   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 134 
 135   Method_extra_stack_entries = Method::extra_stack_entries();
 136 
 137   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 138   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 139   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 140   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 141 
 142   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 143 
 144   Universe_collectedHeap = Universe::heap();
 145   Universe_base_vtable_size = Universe::base_vtable_size();
 146   Universe_narrow_oop_base = Universe::narrow_oop_base();
 147   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 148   Universe_narrow_klass_base = Universe::narrow_klass_base();
 149   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 150   Universe_non_oop_bits = Universe::non_oop_word();
 151   Universe_verify_oop_mask = Universe::verify_oop_mask();
 152   Universe_verify_oop_bits = Universe::verify_oop_bits();
 153 
 154   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 155   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 156   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
 157 
 158   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 159   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 160   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 161   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 162 
 163   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 164   switch (bs-&gt;kind()) {
 165   case BarrierSet::CardTableModRef:
 166   case BarrierSet::CardTableForRS:
 167   case BarrierSet::CardTableExtension:
 168   case BarrierSet::G1SATBCT:
 169   case BarrierSet::G1SATBCTLogging: {
 170     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 171     assert(base != 0, "unexpected byte_map_base");
 172     cardtable_start_address = base;
 173     cardtable_shift = CardTableModRefBS::card_shift;
 174     break;
 175   }
 176   case BarrierSet::ModRef:
 177     cardtable_start_address = 0;
 178     cardtable_shift = 0;
 179     // No post barriers
 180     break;
 181   default:
 182     ShouldNotReachHere();
 183     break;
 184   }
 185 
 186   vm_page_size = os::vm_page_size();
 187 
 188 #define SET_TRIGFUNC(name)                                      \
 189   if (StubRoutines::name() != NULL) {                           \
 190     name = StubRoutines::name();                                \
 191   } else {                                                      \
 192     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 193   }
 194 
 195   SET_TRIGFUNC(dsin);
 196   SET_TRIGFUNC(dcos);
 197   SET_TRIGFUNC(dtan);
 198   SET_TRIGFUNC(dexp);
 199   SET_TRIGFUNC(dlog10);
 200   SET_TRIGFUNC(dlog);
 201   SET_TRIGFUNC(dpow);
 202 
 203 #undef SET_TRIGFUNC
 204 }
 205 
 206 objArrayHandle CompilerToVM::initialize_intrinsics(TRAPS) {
 207   objArrayHandle vmIntrinsics = oopFactory::new_objArray(VMIntrinsicMethod::klass(), (vmIntrinsics::ID_LIMIT - 1), CHECK_(objArrayHandle()));
 208   int index = 0;
 209   // The intrinsics for a class are usually adjacent to each other.
 210   // When they are, the string for the class name can be reused.
 211   vmSymbols::SID kls_sid = vmSymbols::NO_SID;
 212   Handle kls_str;
 213 #define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)
 214 #define VM_SYMBOL_TO_STRING(s) \
 215   java_lang_String::create_from_symbol(vmSymbols::symbol_at(SID_ENUM(s)), CHECK_(objArrayHandle()))
 216 #define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \
 217     instanceHandle vmIntrinsicMethod = InstanceKlass::cast(VMIntrinsicMethod::klass())-&gt;allocate_instance_handle(CHECK_(objArrayHandle())); \
 218     if (kls_sid != SID_ENUM(kls)) {                                       \
 219       kls_str = VM_SYMBOL_TO_STRING(kls);                                 \
 220       kls_sid = SID_ENUM(kls);                                            \
 221     }                                                                     \
 222     Handle name_str = VM_SYMBOL_TO_STRING(name);                          \
 223     Handle sig_str = VM_SYMBOL_TO_STRING(sig);                            \
 224     VMIntrinsicMethod::set_declaringClass(vmIntrinsicMethod, kls_str());  \
 225     VMIntrinsicMethod::set_name(vmIntrinsicMethod, name_str());           \
 226     VMIntrinsicMethod::set_descriptor(vmIntrinsicMethod, sig_str());      \
 227     VMIntrinsicMethod::set_id(vmIntrinsicMethod, vmIntrinsics::id);       \
 228       vmIntrinsics-&gt;obj_at_put(index++, vmIntrinsicMethod());             \
 229   }
 230 
 231   VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
 232 #undef SID_ENUM
 233 #undef VM_SYMBOL_TO_STRING
 234 #undef VM_INTRINSIC_INFO
 235   assert(index == vmIntrinsics::ID_LIMIT - 1, "must be");
 236 
 237   return vmIntrinsics;
 238 }
 239 
 240 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))
 241 #define BOXED_LONG(name, value) oop name; do { jvalue p; p.j = (jlong) (value); name = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL);} while(0)
 242 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)
 243   ResourceMark rm;
 244   HandleMark hm;
 245 
 246   CompilerToVM::Data::initialize();
 247 
 248   VMField::klass()-&gt;initialize(CHECK_NULL);
 249   VMFlag::klass()-&gt;initialize(CHECK_NULL);
 250   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);
 251 
 252   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
 253   objArrayHandle vmFields = oopFactory::new_objArray(VMField::klass(), len, CHECK_NULL);
 254   for (int i = 0; i &lt; len ; i++) {
 255     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
 256     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 257     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* "::" */;
 258     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
 259     sprintf(name_buf, "%s::%s", vmField.typeName, vmField.fieldName);
 260     Handle name = java_lang_String::create_from_str(name_buf, CHECK_NULL);
 261     Handle type = java_lang_String::create_from_str(vmField.typeString, CHECK_NULL);
 262     VMField::set_name(vmFieldObj, name());
 263     VMField::set_type(vmFieldObj, type());
 264     VMField::set_offset(vmFieldObj, vmField.offset);
 265     VMField::set_address(vmFieldObj, (jlong) vmField.address);
 266     if (vmField.isStatic) {
 267       if (strcmp(vmField.typeString, "bool") == 0) {
 268         BOXED_LONG(value, *(jbyte*) vmField.address);
 269         VMField::set_value(vmFieldObj, value);
 270       } else if (strcmp(vmField.typeString, "int") == 0 ||
 271                  strcmp(vmField.typeString, "jint") == 0) {
 272         BOXED_LONG(value, *(jint*) vmField.address);
 273         VMField::set_value(vmFieldObj, value);
 274       } else if (strcmp(vmField.typeString, "uint64_t") == 0) {
 275         BOXED_LONG(value, *(uint64_t*) vmField.address);
 276         VMField::set_value(vmFieldObj, value);
 277       } else if (strcmp(vmField.typeString, "address") == 0 ||
 278                  strcmp(vmField.typeString, "intptr_t") == 0 ||
 279                  strcmp(vmField.typeString, "uintptr_t") == 0 ||
 280                  strcmp(vmField.typeString, "size_t") == 0 ||
 281                  // All foo* types are addresses.
 282                  vmField.typeString[strlen(vmField.typeString) - 1] == '*') {
 283         BOXED_LONG(value, *((address*) vmField.address));
 284         VMField::set_value(vmFieldObj, value);
 285       } else {
 286         JVMCI_ERROR_NULL("VM field %s has unsupported type %s", name_buf, vmField.typeString);
 287       }
 288     }
 289     vmFields-&gt;obj_at_put(i, vmFieldObj());
 290   }
 291 
 292   len = JVMCIVMStructs::localHotSpotVMTypes_count();
 293   objArrayHandle vmTypes = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 294   for (int i = 0; i &lt; len ; i++) {
 295     VMTypeEntry vmType = JVMCIVMStructs::localHotSpotVMTypes[i];
 296     Handle name = java_lang_String::create_from_str(vmType.typeName, CHECK_NULL);
 297     BOXED_LONG(size, vmType.size);
 298     vmTypes-&gt;obj_at_put(i * 2, name());
 299     vmTypes-&gt;obj_at_put(i * 2 + 1, size);
 300   }
 301 
 302   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
 303   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
 304   len = ints_len + longs_len;
 305   objArrayHandle vmConstants = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 306   int insert = 0;
 307   for (int i = 0; i &lt; ints_len ; i++) {
 308     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
 309     Handle name = java_lang_String::create_from_str(c.name, CHECK_NULL);
 310     BOXED_LONG(value, c.value);
 311     vmConstants-&gt;obj_at_put(insert++, name());
 312     vmConstants-&gt;obj_at_put(insert++, value);
 313   }
 314   for (int i = 0; i &lt; longs_len ; i++) {
 315     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
 316     Handle name = java_lang_String::create_from_str(c.name, CHECK_NULL);
 317     BOXED_LONG(value, c.value);
 318     vmConstants-&gt;obj_at_put(insert++, name());
 319     vmConstants-&gt;obj_at_put(insert++, value);
 320   }
 321   assert(insert == len * 2, "must be");
 322 
 323   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
 324   objArrayHandle vmAddresses = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 325   for (int i = 0; i &lt; len ; i++) {
 326     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
 327     Handle name = java_lang_String::create_from_str(a.name, CHECK_NULL);
 328     BOXED_LONG(value, a.value);
 329     vmAddresses-&gt;obj_at_put(i * 2, name());
 330     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);
 331   }
 332 
 333   // The last entry is the null entry.
 334   len = (int) Flag::numFlags - 1;
 335   objArrayHandle vmFlags = oopFactory::new_objArray(VMFlag::klass(), len, CHECK_NULL);
 336   for (int i = 0; i &lt; len; i++) {
 337     Flag* flag = &amp;Flag::flags[i];
 338     instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 339     Handle name = java_lang_String::create_from_str(flag-&gt;_name, CHECK_NULL);
 340     Handle type = java_lang_String::create_from_str(flag-&gt;_type, CHECK_NULL);
 341     VMFlag::set_name(vmFlagObj, name());
 342     VMFlag::set_type(vmFlagObj, type());
 343     if (flag-&gt;is_bool()) {
 344       BOXED_LONG(value, flag-&gt;get_bool());
 345       VMFlag::set_value(vmFlagObj, value);
 346     } else if (flag-&gt;is_ccstr()) {
 347       Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
 348       VMFlag::set_value(vmFlagObj, value());
 349     } else if (flag-&gt;is_int()) {
 350       BOXED_LONG(value, flag-&gt;get_int());
 351       VMFlag::set_value(vmFlagObj, value);
 352     } else if (flag-&gt;is_intx()) {
 353       BOXED_LONG(value, flag-&gt;get_intx());
 354       VMFlag::set_value(vmFlagObj, value);
 355     } else if (flag-&gt;is_uint()) {
 356       BOXED_LONG(value, flag-&gt;get_uint());
 357       VMFlag::set_value(vmFlagObj, value);
 358     } else if (flag-&gt;is_uint64_t()) {
 359       BOXED_LONG(value, flag-&gt;get_uint64_t());
 360       VMFlag::set_value(vmFlagObj, value);
 361     } else if (flag-&gt;is_uintx()) {
 362       BOXED_LONG(value, flag-&gt;get_uintx());
 363       VMFlag::set_value(vmFlagObj, value);
 364     } else if (flag-&gt;is_double()) {
 365       BOXED_DOUBLE(value, flag-&gt;get_double());
 366       VMFlag::set_value(vmFlagObj, value);
 367     } else if (flag-&gt;is_size_t()) {
 368       BOXED_LONG(value, flag-&gt;get_size_t());
 369       VMFlag::set_value(vmFlagObj, value);
 370     } else {
 371       JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
 372     }
 373     vmFlags-&gt;obj_at_put(i, vmFlagObj());
 374   }
 375 
 376   objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);
 377 
 378   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 6, CHECK_NULL);
 379   data-&gt;obj_at_put(0, vmFields());
 380   data-&gt;obj_at_put(1, vmTypes());
 381   data-&gt;obj_at_put(2, vmConstants());
 382   data-&gt;obj_at_put(3, vmAddresses());
 383   data-&gt;obj_at_put(4, vmFlags());
 384   data-&gt;obj_at_put(5, vmIntrinsics());
 385 
 386   return (jobjectArray) JNIHandles::make_local(THREAD, data);
 387 #undef BOXED_LONG
 388 #undef BOXED_DOUBLE
 389 C2V_END
 390 
 391 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 392   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 393   ResourceMark rm;
 394 
 395   int code_size = method-&gt;code_size();
 396   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 397 
 398   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 399   // iterate over all bytecodes and replace non-Java bytecodes
 400 
 401   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 402     Bytecodes::Code code = s.code();
 403     Bytecodes::Code raw_code = s.raw_code();
 404     int bci = s.bci();
 405     int len = s.instruction_size();
 406 
 407     // Restore original byte code.
 408     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 409     if (len &gt; 1) {
 410       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);
 411     }
 412 
 413     if (len &gt; 1) {
 414       // Restore the big-endian constant pool indexes.
 415       // Cf. Rewriter::scan_method
 416       switch (code) {
 417         case Bytecodes::_getstatic:
 418         case Bytecodes::_putstatic:
 419         case Bytecodes::_getfield:
 420         case Bytecodes::_putfield:
 421         case Bytecodes::_invokevirtual:
 422         case Bytecodes::_invokespecial:
 423         case Bytecodes::_invokestatic:
 424         case Bytecodes::_invokeinterface:
 425         case Bytecodes::_invokehandle: {
 426           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 427           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 428           break;
 429         }
 430 
 431         case Bytecodes::_invokedynamic:
 432           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 433           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);
 434           break;
 435       }
 436 
 437       // Not all ldc byte code are rewritten.
 438       switch (raw_code) {
 439         case Bytecodes::_fast_aldc: {
 440           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;
 441           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 442           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 443           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);
 444           break;
 445         }
 446 
 447         case Bytecodes::_fast_aldc_w: {
 448           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 449           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 450           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 451           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 452           break;
 453         }
 454       }
 455     }
 456   }
 457 
 458   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);
 459 C2V_END
 460 
 461 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 462   ResourceMark rm;
 463   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 464   return method-&gt;exception_table_length();
 465 C2V_END
 466 
 467 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 468   ResourceMark rm;
 469   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 470   if (method-&gt;exception_table_length() == 0) {
 471     return 0L;
 472   }
 473   return (jlong) (address) method-&gt;exception_table_start();
 474 C2V_END
 475 
 476 C2V_VMENTRY(jobject, asResolvedJavaMethod, (JNIEnv *, jobject, jobject executable_handle))
 477   oop executable = JNIHandles::resolve(executable_handle);
 478   oop mirror = NULL;
 479   int slot = 0;
 480 
 481   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 482     mirror = java_lang_reflect_Constructor::clazz(executable);
 483     slot = java_lang_reflect_Constructor::slot(executable);
 484   } else {
 485     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), "wrong type");
 486     mirror = java_lang_reflect_Method::clazz(executable);
 487     slot = java_lang_reflect_Method::slot(executable);
 488   }
 489   Klass* holder = java_lang_Class::as_Klass(mirror);
 490   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 491   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 492   return JNIHandles::make_local(THREAD, result);
 493 }
 494 
 495 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))
 496   methodHandle method;
 497   oop base_object = JNIHandles::resolve(base);
 498   if (base_object == NULL) {
 499     method = *((Method**)(offset));
 500   } else if (base_object-&gt;is_a(SystemDictionary::MemberName_klass())) {
 501     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);
 502   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 503     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));
 504   } else {
 505     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 506                 err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 507   }
 508   assert (method.is_null() || method-&gt;is_method(), "invalid read");
 509   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 510   return JNIHandles::make_local(THREAD, result);
 511 }
 512 
 513 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject object_handle))
 514   constantPoolHandle cp;
 515   oop object = JNIHandles::resolve(object_handle);
 516   if (object == NULL) {
 517     THROW_0(vmSymbols::java_lang_NullPointerException());
 518   }
 519   if (object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 520     cp = CompilerToVM::asMethod(object)-&gt;constMethod()-&gt;constants();
 521   } else if (object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 522     cp = InstanceKlass::cast(CompilerToVM::asKlass(object))-&gt;constants();
 523   } else {
 524     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 525                 err_msg("Unexpected type: %s", object-&gt;klass()-&gt;external_name()));
 526   }
 527   assert(!cp.is_null(), "npe");
 528   JavaValue method_result(T_OBJECT);
 529   JavaCallArguments args;
 530   args.push_long((jlong) (address) cp());
 531   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 532   return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());
 533 }
 534 
 535 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))
 536   KlassHandle klass;
 537   oop base_object = JNIHandles::resolve(base);
 538   jlong base_address = 0;
 539   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 540     klass = base_object-&gt;klass();
 541   } else if (!compressed) {
 542     if (base_object != NULL) {
 543       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 544         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 545       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 546         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 547       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 548         base_address = (jlong) CompilerToVM::asKlass(base_object);
 549       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {
 550         base_address = (jlong) (address) base_object;
 551       } else {
 552         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 553                     err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 554       }
 555     }
 556     klass = *((Klass**) (intptr_t) (base_address + offset));
 557   } else {
 558     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 559                 err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 560   }
 561   assert (klass.is_null() || klass-&gt;is_klass(), "invalid read");
 562   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 563   return JNIHandles::make_local(THREAD, result);
 564 }
 565 
 566 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 567   ResourceMark rm;
 568   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 569   KlassHandle holder = CompilerToVM::asKlass(jvmci_type);
 570   if (holder-&gt;is_interface()) {
 571     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", holder-&gt;external_name()));
 572   }
 573 
 574   methodHandle ucm;
 575   {
 576     MutexLocker locker(Compile_lock);
 577     ucm = Dependencies::find_unique_concrete_method(holder(), method());
 578   }
 579   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);
 580   return JNIHandles::make_local(THREAD, result);
 581 C2V_END
 582 
 583 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))
 584   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 585   oop implementor = CompilerToVM::get_jvmci_type(klass-&gt;implementor(), CHECK_NULL);
 586   return JNIHandles::make_local(THREAD, implementor);
 587 C2V_END
 588 
 589 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))
 590   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 591   return method-&gt;is_ignored_by_security_stack_walk();
 592 C2V_END
 593 
 594 C2V_VMENTRY(jboolean, isCompilable,(JNIEnv *, jobject, jobject jvmci_method))
 595   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 596   // Ignore the not_compilable flags in hosted mode since they are never set by
 597   // the JVMCI compiler.
 598   return UseJVMCICompiler || !method-&gt;is_not_compilable(CompLevel_full_optimization);
 599 C2V_END
 600 
 601 C2V_VMENTRY(jboolean, hasNeverInlineDirective,(JNIEnv *, jobject, jobject jvmci_method))
 602   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 603   return CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 604 C2V_END
 605 
 606 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 607   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 608   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 609 C2V_END
 610 
 611 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 612   ResourceMark rm;
 613   Handle name = JNIHandles::resolve(jname);
 614   Symbol* class_name = java_lang_String::as_symbol(name, CHECK_0);
 615   if (java_lang_String::length(name()) &lt;= 1) {
 616     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Primitive type %s should be handled in Java code", class_name-&gt;as_C_string()));
 617   }
 618 
 619   Klass* resolved_klass = NULL;
 620   Handle class_loader;
 621   Handle protection_domain;
 622   if (JNIHandles::resolve(accessing_class) == NULL) {
 623     THROW_0(vmSymbols::java_lang_NullPointerException());
 624   }
 625   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));
 626   class_loader = accessing_klass-&gt;class_loader();
 627   protection_domain = accessing_klass-&gt;protection_domain();
 628 
 629   if (resolve) {
 630     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 631   } else {
 632     if (class_name-&gt;byte_at(0) == 'L' &amp;&amp;
 633       class_name-&gt;byte_at(class_name-&gt;utf8_length()-1) == ';') {
 634       // This is a name from a signature.  Strip off the trimmings.
 635       // Call recursive to keep scope of strippedsym.
 636       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 637                                                           class_name-&gt;utf8_length()-2,
 638                                                           CHECK_0);
 639       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 640     } else if (FieldType::is_array(class_name)) {
 641       FieldArrayInfo fd;
 642       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 643       // of this call
 644       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 645       if (t == T_OBJECT) {
 646         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 647                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 648                                                             CHECK_0);
 649         // naked oop "k" is OK here -- we assign back into it
 650         resolved_klass = SystemDictionary::find(strippedsym,
 651                                                              class_loader,
 652                                                              protection_domain,
 653                                                              CHECK_0);
 654         if (resolved_klass != NULL) {
 655           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 656         }
 657       } else {
 658         resolved_klass = Universe::typeArrayKlassObj(t);
 659         resolved_klass = TypeArrayKlass::cast(resolved_klass)-&gt;array_klass(fd.dimension(), CHECK_0);
 660       }
 661     }
 662   }
 663   Handle result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 664   return JNIHandles::make_local(THREAD, result());
 665 C2V_END
 666 
 667 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 668   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 669   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);
 670   return JNIHandles::make_local(THREAD, result);
 671 C2V_END
 672 
 673 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 674   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 675   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 676   return JNIHandles::make_local(THREAD, result);
 677 C2V_END
 678 
 679 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 680   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 681   return cp-&gt;name_and_type_ref_index_at(index);
 682 C2V_END
 683 
 684 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 685   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 686   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);
 687   return JNIHandles::make_local(THREAD, sym());
 688 C2V_END
 689 
 690 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 691   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 692   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);
 693   return JNIHandles::make_local(THREAD, sym());
 694 C2V_END
 695 
 696 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 697   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 698   return cp-&gt;klass_ref_index_at(index);
 699 C2V_END
 700 
 701 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 702   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 703   Klass* resolved_klass = cp-&gt;klass_at(index, CHECK_NULL);
 704   Handle klass = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 705   return JNIHandles::make_local(THREAD, klass());
 706 C2V_END
 707 
 708 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 709   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 710   KlassHandle loading_klass(cp-&gt;pool_holder());
 711   bool is_accessible = false;
 712   KlassHandle klass = JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass);
 713   Symbol* symbol = NULL;
 714   if (klass.is_null()) {
 715     symbol = cp-&gt;klass_name_at(index);
 716   }
 717   Handle result;
 718   if (!klass.is_null()) {
 719     result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 720   } else {
 721     result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
 722   }
 723   return JNIHandles::make_local(THREAD, result());
 724 C2V_END
 725 
 726 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 727   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 728   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 729   return JNIHandles::make_local(THREAD, appendix_oop);
 730 C2V_END
 731 
 732 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 733   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 734   instanceKlassHandle pool_holder(cp-&gt;pool_holder());
 735   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 736   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 737   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 738   return JNIHandles::make_local(THREAD, result);
 739 C2V_END
 740 
 741 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 742   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 743   return cp-&gt;remap_instruction_operand_from_cache(index);
 744 C2V_END
 745 
 746 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jlongArray info_handle))
 747   ResourceMark rm;
 748   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 749   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 750   fieldDescriptor fd;
 751   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
 752   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 753   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
 754   assert(info != NULL &amp;&amp; info-&gt;length() == 2, "must be");
 755   info-&gt;long_at_put(0, (jlong) fd.access_flags().as_int());
 756   info-&gt;long_at_put(1, (jlong) fd.offset());
 757   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 758   return JNIHandles::make_local(THREAD, field_holder);
 759 C2V_END
 760 
 761 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 762   ResourceMark rm;
 763   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 764   Method* method = CompilerToVM::asMethod(jvmci_method);
 765   if (klass-&gt;is_interface()) {
 766     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 767   }
 768   if (!method-&gt;method_holder()-&gt;is_interface()) {
 769     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 770   }
 771   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 772     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 773   }
 774   return LinkResolver::vtable_index_of_interface_method(klass, method);
 775 C2V_END
 776 
 777 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 778   KlassHandle recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);
 779   KlassHandle caller_klass = CompilerToVM::asKlass(caller_jvmci_type);
 780   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 781 
 782   KlassHandle h_resolved   (THREAD, method-&gt;method_holder());
 783   Symbol* h_name      = method-&gt;name();
 784   Symbol* h_signature = method-&gt;signature();
 785 
 786   if (MethodHandles::is_signature_polymorphic_method(method())) {
 787       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 788       return NULL;
 789   }
 790 
 791   LinkInfo link_info(h_resolved, h_name, h_signature, caller_klass);
 792   methodHandle m;
 793   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 794   // the vtable has not been setup, and the LinkResolver will fail.
 795   if (recv_klass-&gt;is_array_klass() ||
 796       InstanceKlass::cast(recv_klass())-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface()) {
 797     if (h_resolved-&gt;is_interface()) {
 798       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 799     } else {
 800       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 801     }
 802   }
 803 
 804   if (m.is_null()) {
 805     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 806     return NULL;
 807   }
 808 
 809   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);
 810   return JNIHandles::make_local(THREAD, result);
 811 C2V_END
 812 
 813 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))
 814   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 815   assert(klass != NULL, "method must not be called for primitive types");
 816   return Dependencies::find_finalizable_subclass(klass) != NULL;
 817 C2V_END
 818 
 819 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))
 820   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 821   oop result = CompilerToVM::get_jvmci_method(klass-&gt;class_initializer(), CHECK_NULL);
 822   return JNIHandles::make_local(THREAD, result);
 823 C2V_END
 824 
 825 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))
 826   address target_addr = (address) addr;
 827   if (target_addr != 0x0) {
 828     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 829     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 830     return MAX2(ABS(off_low), ABS(off_high));
 831   }
 832   return -1;
 833 C2V_END
 834 
 835 C2V_VMENTRY(void, doNotInlineOrCompile,(JNIEnv *, jobject,  jobject jvmci_method))
 836   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 837   method-&gt;set_not_c1_compilable();
 838   method-&gt;set_not_c2_compilable();
 839   method-&gt;set_dont_inline(true);
 840 C2V_END
 841 
 842 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))
 843   ResourceMark rm;
 844   HandleMark hm;
 845   Handle target_handle = JNIHandles::resolve(target);
 846   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 847   CodeBlob* cb = NULL;
 848   Handle installed_code_handle = JNIHandles::resolve(installed_code);
 849   Handle speculation_log_handle = JNIHandles::resolve(speculation_log);
 850 
 851   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK_JNI_ERR);
 852 
 853   TraceTime install_time("installCode", JVMCICompiler::codeInstallTimer());
 854   bool is_immutable_PIC = HotSpotCompiledCode::isImmutablePIC(compiled_code_handle) &gt; 0;
 855   CodeInstaller installer(is_immutable_PIC);
 856   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);
 857 
 858   if (PrintCodeCacheOnCompilation) {
 859     stringStream s;
 860     // Dump code cache  into a buffer before locking the tty,
 861     {
 862       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 863       CodeCache::print_summary(&amp;s, false);
 864     }
 865     ttyLocker ttyl;
 866     tty-&gt;print_raw_cr(s.as_string());
 867   }
 868 
 869   if (result != JVMCIEnv::ok) {
 870     assert(cb == NULL, "should be");
 871   } else {
 872     if (!installed_code_handle.is_null()) {
 873       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), "wrong type");
 874       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);
 875       {
 876         // Ensure that all updates to the InstalledCode fields are consistent.
 877         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
 878         InstalledCode::set_address(installed_code_handle, (jlong) cb);
 879         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);
 880         if (cb-&gt;is_nmethod()) {
 881           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());
 882         } else {
 883           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());
 884         }
 885         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {
 886           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());
 887           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());
 888           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());
 889         }
 890       }
 891       nmethod* nm = cb-&gt;as_nmethod_or_null();
 892       if (nm != NULL &amp;&amp; installed_code_handle-&gt;is_scavengable()) {
 893         assert(nm-&gt;detect_scavenge_root_oops(), "nm should be scavengable if installed_code is scavengable");
 894         if (!UseG1GC) {
 895           assert(nm-&gt;on_scavenge_root_list(), "nm should be on scavengable list");
 896         }
 897       }
 898     }
 899   }
 900   return result;
 901 C2V_END
 902 
 903 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))
 904   ResourceMark rm;
 905   HandleMark hm;
 906 
 907   Handle target_handle = JNIHandles::resolve(target);
 908   Handle compiled_code_handle = JNIHandles::resolve(compiled_code);
 909   Handle metadata_handle = JNIHandles::resolve(metadata);
 910 
 911   CodeMetadata code_metadata;
 912   CodeBlob *cb = NULL;
 913   CodeInstaller installer(true /* immutable PIC compilation */);
 914 
 915   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);
 916   if (result != JVMCIEnv::ok) {
 917     return result;
 918   }
 919 
 920   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 921     typeArrayHandle pcArrayOop = oopFactory::new_byteArray(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));
 922     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());
 923     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());
 924   }
 925 
 926   if (code_metadata.get_scopes_size() &gt; 0) {
 927     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));
 928     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());
 929     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());
 930   }
 931 
 932   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
 933   typeArrayHandle relocArrayOop = oopFactory::new_byteArray((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));
 934   if (reloc_buffer-&gt;size() &gt; 0) {
 935     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());
 936   }
 937   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());
 938 
 939   const OopMapSet* oopMapSet = installer.oopMapSet();
 940   {
 941     ResourceMark mark;
 942     ImmutableOopMapBuilder builder(oopMapSet);
 943     int oopmap_size = builder.heap_size();
 944     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray(oopmap_size, CHECK_(JVMCIEnv::cache_full));
 945     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));
 946     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());
 947   }
 948 
 949   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
 950 
 951   int nr_meta_strings = recorder-&gt;nr_meta_strings();
 952   objArrayHandle metadataArrayHandle = oopFactory::new_objectArray(nr_meta_strings, CHECK_(JVMCIEnv::cache_full));
 953   for (int i = 0; i &lt; nr_meta_strings; ++i) {
 954     const char* element = recorder-&gt;meta_element(i);
 955     Handle java_string = java_lang_String::create_from_str(element, CHECK_(JVMCIEnv::cache_full));
 956     metadataArrayHandle-&gt;obj_at_put(i, java_string());
 957   }
 958   HotSpotMetaData::set_metadata(metadata_handle, metadataArrayHandle());
 959 
 960   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 961   int table_size = handler-&gt;size_in_bytes();
 962   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray(table_size, CHECK_(JVMCIEnv::cache_full));
 963 
 964   if (table_size &gt; 0) {
 965     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));
 966   }
 967   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());
 968 
 969   return result;
 970 C2V_END
 971 
 972 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))
 973   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK);
 974   CompilerStatistics* stats = compiler-&gt;stats();
 975   stats-&gt;_standard.reset();
 976   stats-&gt;_osr.reset();
 977 C2V_END
 978 
 979 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))
 980   ResourceMark rm;
 981   HandleMark hm;
 982 
 983   if (installedCode == NULL) {
 984     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), "installedCode is null");
 985   }
 986 
 987   jlong codeBlob = InstalledCode::address(installedCode);
 988   if (codeBlob == 0L) {
 989     return NULL;
 990   }
 991 
 992   CodeBlob* cb = (CodeBlob*) (address) codeBlob;
 993   if (cb == NULL) {
 994     return NULL;
 995   }
 996 
 997   // We don't want the stringStream buffer to resize during disassembly as it
 998   // uses scoped resource memory. If a nested function called during disassembly uses
 999   // a ResourceMark and the buffer expands within the scope of the mark,
1000   // the buffer becomes garbage when that scope is exited. Experience shows that
1001   // the disassembled code is typically about 10x the code size so a fixed buffer
1002   // sized to 20x code size plus a fixed amount for header info should be sufficient.
1003   int bufferSize = cb-&gt;code_size() * 20 + 1024;
1004   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
1005   stringStream st(buffer, bufferSize);
1006   if (cb-&gt;is_nmethod()) {
1007     nmethod* nm = (nmethod*) cb;
1008     if (!nm-&gt;is_alive()) {
1009       return NULL;
1010     }
1011   }
1012   Disassembler::decode(cb, &amp;st);
1013   if (st.size() &lt;= 0) {
1014     return NULL;
1015   }
1016 
1017   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);
1018   return JNIHandles::make_local(THREAD, result());
1019 C2V_END
1020 
1021 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))
1022   ResourceMark rm;
1023   HandleMark hm;
1024 
1025   methodHandle method = CompilerToVM::asMethod(jvmci_method);
1026   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);
1027   return JNIHandles::make_local(THREAD, element);
1028 C2V_END
1029 
1030 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))
1031   ResourceMark rm;
1032   HandleMark hm;
1033 
1034   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);
1035   if (nmethodValue == 0L) {
1036     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
1037   }
1038   nmethod* nm = (nmethod*) (address) nmethodValue;
1039   methodHandle mh = nm-&gt;method();
1040   Symbol* signature = mh-&gt;signature();
1041   JavaCallArguments jca(mh-&gt;size_of_parameters());
1042 
1043   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1044   JavaValue result(jap.get_ret_type());
1045   jca.set_alternative_target(nm);
1046   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1047 
1048   if (jap.get_ret_type() == T_VOID) {
1049     return NULL;
1050   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
1051     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
1052   } else {
1053     jvalue *value = (jvalue *) result.get_value_addr();
1054     // Narrow the value down if required (Important on big endian machines)
1055     switch (jap.get_ret_type()) {
1056       case T_BOOLEAN:
1057        value-&gt;z = (jboolean) value-&gt;i;
1058        break;
1059       case T_BYTE:
1060        value-&gt;b = (jbyte) value-&gt;i;
1061        break;
1062       case T_CHAR:
1063        value-&gt;c = (jchar) value-&gt;i;
1064        break;
1065       case T_SHORT:
1066        value-&gt;s = (jshort) value-&gt;i;
1067        break;
1068      }
1069     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);
1070     return JNIHandles::make_local(THREAD, o);
1071   }
1072 C2V_END
1073 
1074 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))
1075   Method* method = CompilerToVM::asMethod(jvmci_method);
1076   if (!method-&gt;has_linenumber_table()) {
1077     return NULL;
1078   }
1079   u2 num_entries = 0;
1080   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1081   while (streamForSize.read_pair()) {
1082     num_entries++;
1083   }
1084 
1085   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1086   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);
1087 
1088   int i = 0;
1089   jlong value;
1090   while (stream.read_pair()) {
1091     value = ((long) stream.bci());
1092     result-&gt;long_at_put(i, value);
1093     value = ((long) stream.line());
1094     result-&gt;long_at_put(i + 1, value);
1095     i += 2;
1096   }
1097 
1098   return (jlongArray) JNIHandles::make_local(THREAD, result);
1099 C2V_END
1100 
1101 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))
1102   ResourceMark rm;
1103   Method* method = CompilerToVM::asMethod(jvmci_method);
1104   if (!method-&gt;has_localvariable_table()) {
1105     return 0;
1106   }
1107   return (jlong) (address) method-&gt;localvariable_table_start();
1108 C2V_END
1109 
1110 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))
1111   ResourceMark rm;
1112   Method* method = CompilerToVM::asMethod(jvmci_method);
1113   return method-&gt;localvariable_table_length();
1114 C2V_END
1115 
1116 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))
1117   Method* method = CompilerToVM::asMethod(jvmci_method);
1118   MethodCounters* mcs = method-&gt;method_counters();
1119   if (mcs != NULL) {
1120     mcs-&gt;clear_counters();
1121   }
1122   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1123 
1124   CompiledMethod* code = method-&gt;code();
1125   if (code != NULL) {
1126     code-&gt;make_not_entrant();
1127   }
1128 
1129   MethodData* method_data = method-&gt;method_data();
1130   if (method_data == NULL) {
1131     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1132     method_data = MethodData::allocate(loader_data, method, CHECK);
1133     method-&gt;set_method_data(method_data);
1134   } else {
1135     method_data-&gt;initialize();
1136   }
1137 C2V_END
1138 
1139 
1140 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))
1141   Handle installed_code_handle = JNIHandles::resolve(installed_code);
1142   nmethod::invalidate_installed_code(installed_code_handle, CHECK);
1143 C2V_END
1144 
1145 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))
1146   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);
1147   JavaThread::collect_counters(arrayOop);
1148   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);
1149 C2V_END
1150 
1151 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))
1152   HandleMark hm;
1153   ResourceMark rm;
1154   if (JNIHandles::resolve(jvmci_method) == NULL) {
1155     THROW_0(vmSymbols::java_lang_NullPointerException());
1156   }
1157   Method* method = CompilerToVM::asMethod(jvmci_method);
1158   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1159     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Unexpected bci %d", entry_bci));
1160   }
1161   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1162 C2V_END
1163 
1164 
1165 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))
1166   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1167   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1168 C2V_END
1169 
1170 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1171   Method* method = CompilerToVM::asMethod(jvmci_method);
1172   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1173 C2V_END
1174 
1175 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))
1176   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);
1177   return JNIHandles::make_local(THREAD, sym());
1178 C2V_END
1179 
1180 bool matches(jobjectArray methods, Method* method) {
1181   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1182 
1183   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1184     oop resolved = methods_oop-&gt;obj_at(i);
1185     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {
1186       return true;
1187     }
1188   }
1189   return false;
1190 }
1191 
1192 C2V_VMENTRY(jobject, getNextStackFrame, (JNIEnv*, jobject compilerToVM, jobject hs_frame, jobjectArray methods, jint initialSkip))
1193   ResourceMark rm;
1194 
1195   if (!thread-&gt;has_last_Java_frame()) return NULL;
1196   Handle result = HotSpotStackFrameReference::klass()-&gt;allocate_instance(thread);
1197   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1198 
1199   StackFrameStream fst(thread);
1200   if (hs_frame != NULL) {
1201     // look for the correct stack frame if one is given
1202     intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1203     while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1204       fst.next();
1205     }
1206     if (fst.current()-&gt;sp() != stack_pointer) {
1207       THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1208     }
1209   }
1210 
1211   int frame_number = 0;
1212   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1213   if (hs_frame != NULL) {
1214     // look for the correct vframe within the stack frame if one is given
1215     int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1216     while (frame_number &lt; last_frame_number) {
1217       if (vf-&gt;is_top()) {
1218         THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1219       }
1220       vf = vf-&gt;sender();
1221       frame_number ++;
1222     }
1223     // move one frame forward
1224     if (vf-&gt;is_top()) {
1225       if (fst.is_done()) {
1226         return NULL;
1227       }
1228       fst.next();
1229       vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1230       frame_number = 0;
1231     } else {
1232       vf = vf-&gt;sender();
1233       frame_number++;
1234     }
1235   }
1236 
1237   while (true) {
1238     // look for the given method
1239     while (true) {
1240       StackValueCollection* locals = NULL;
1241       if (vf-&gt;is_compiled_frame()) {
1242         // compiled method frame
1243         compiledVFrame* cvf = compiledVFrame::cast(vf);
1244         if (methods == NULL || matches(methods, cvf-&gt;method())) {
1245           if (initialSkip &gt; 0) {
1246             initialSkip --;
1247           } else {
1248             ScopeDesc* scope = cvf-&gt;scope();
1249             // native wrapper do not have a scope
1250             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1251               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), scope-&gt;objects(), THREAD);
1252               Deoptimization::reassign_fields(fst.current(), fst.register_map(), scope-&gt;objects(), realloc_failures, false);
1253 
1254               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1255               typeArrayHandle array = oopFactory::new_boolArray(local_values-&gt;length(), thread);
1256               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1257                 ScopeValue* value = local_values-&gt;at(i);
1258                 if (value-&gt;is_object()) {
1259                   array-&gt;bool_at_put(i, true);
1260                 }
1261               }
1262               HotSpotStackFrameReference::set_localIsVirtual(result, array());
1263             } else {
1264               HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1265             }
1266 
1267             locals = cvf-&gt;locals();
1268             HotSpotStackFrameReference::set_bci(result, cvf-&gt;bci());
1269             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);
1270             HotSpotStackFrameReference::set_method(result, method);
1271           }
1272         }
1273       } else if (vf-&gt;is_interpreted_frame()) {
1274         // interpreted method frame
1275         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1276         if (methods == NULL || matches(methods, ivf-&gt;method())) {
1277           if (initialSkip &gt; 0) {
1278             initialSkip --;
1279           } else {
1280             locals = ivf-&gt;locals();
1281             HotSpotStackFrameReference::set_bci(result, ivf-&gt;bci());
1282             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);
1283             HotSpotStackFrameReference::set_method(result, method);
1284             HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1285           }
1286         }
1287       }
1288 
1289       // locals != NULL means that we found a matching frame and result is already partially initialized
1290       if (locals != NULL) {
1291         HotSpotStackFrameReference::set_compilerToVM(result, JNIHandles::resolve(compilerToVM));
1292         HotSpotStackFrameReference::set_stackPointer(result, (jlong) fst.current()-&gt;sp());
1293         HotSpotStackFrameReference::set_frameNumber(result, frame_number);
1294 
1295         // initialize the locals array
1296         objArrayHandle array = oopFactory::new_objectArray(locals-&gt;size(), thread);
1297         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1298           StackValue* var = locals-&gt;at(i);
1299           if (var-&gt;type() == T_OBJECT) {
1300             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1301           }
1302         }
1303         HotSpotStackFrameReference::set_locals(result, array());
1304 
1305         return JNIHandles::make_local(thread, result());
1306       }
1307 
1308       if (vf-&gt;is_top()) {
1309         break;
1310       }
1311       frame_number++;
1312       vf = vf-&gt;sender();
1313     } // end of vframe loop
1314 
1315     if (fst.is_done()) {
1316       break;
1317     }
1318     fst.next();
1319     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1320     frame_number = 0;
1321   } // end of frame loop
1322 
1323   // the end was reached without finding a matching method
1324   return NULL;
1325 C2V_END
1326 
1327 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1328   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1329   CallInfo callInfo;
1330   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1331   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1332   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1333 C2V_END
1334 
1335 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1336   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1337   KlassHandle holder = cp-&gt;klass_ref_at(index, CHECK);
1338   Symbol* name = cp-&gt;name_ref_at(index);
1339   if (MethodHandles::is_signature_polymorphic_name(holder(), name)) {
1340     CallInfo callInfo;
1341     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1342     ConstantPoolCacheEntry* cp_cache_entry = cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1343     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1344   }
1345 C2V_END
1346 
1347 C2V_VMENTRY(jobject, getSignaturePolymorphicHolders, (JNIEnv*, jobject))
1348   objArrayHandle holders = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
1349   Handle mh = java_lang_String::create_from_str("Ljava/lang/invoke/MethodHandle;", CHECK_NULL);
1350   Handle vh = java_lang_String::create_from_str("Ljava/lang/invoke/VarHandle;", CHECK_NULL);
1351   holders-&gt;obj_at_put(0, mh());
1352   holders-&gt;obj_at_put(1, vh());
1353   return JNIHandles::make_local(THREAD, holders());
1354 C2V_END
1355 
1356 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))
1357   //see compute_recording_non_safepoints in debugInfroRec.cpp
1358   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1359     return true;
1360   }
1361   return DebugNonSafepoints;
1362 C2V_END
1363 
1364 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1365 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))
1366   ResourceMark rm;
1367 
1368   if (hs_frame == NULL) {
1369     THROW_MSG(vmSymbols::java_lang_NullPointerException(), "stack frame is null")
1370   }
1371 
1372   HotSpotStackFrameReference::klass()-&gt;initialize(thread);
1373 
1374   // look for the given stack frame
1375   StackFrameStream fst(thread);
1376   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1377   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1378     fst.next();
1379   }
1380   if (fst.current()-&gt;sp() != stack_pointer) {
1381     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1382   }
1383 
1384   if (invalidate) {
1385     if (!fst.current()-&gt;is_compiled_frame()) {
1386       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1387     }
1388     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), "nmethod expected");
1389     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1390   }
1391   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1392   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1393   StackFrameStream fstAfterDeopt(thread);
1394   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1395     fstAfterDeopt.next();
1396   }
1397   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1398     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found after deopt")
1399   }
1400 
1401   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1402   if (!vf-&gt;is_compiled_frame()) {
1403     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1404   }
1405 
1406   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1407   while (true) {
1408     assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1409     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1410     if (vf-&gt;is_top()) {
1411       break;
1412     }
1413     vf = vf-&gt;sender();
1414   }
1415 
1416   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1417   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1418     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1419   }
1420 
1421   // Reallocate the non-escaping objects and restore their fields.
1422   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,"invalid scope");
1423   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1424 
1425   if (objects == NULL) {
1426     // no objects to materialize
1427     return;
1428   }
1429 
1430   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, THREAD);
1431   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1432 
1433   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1434     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1435 
1436     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1437     StackValueCollection* locals = cvf-&gt;locals();
1438 
1439     if (locals != NULL) {
1440       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1441         StackValue* var = locals-&gt;at(i2);
1442         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1443           jvalue val;
1444           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1445           cvf-&gt;update_local(T_OBJECT, i2, val);
1446         }
1447       }
1448     }
1449   }
1450 
1451   // all locals are materialized by now
1452   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);
1453 
1454   // update the locals array
1455   objArrayHandle array = HotSpotStackFrameReference::locals(hs_frame);
1456   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1457   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1458     StackValue* var = locals-&gt;at(i);
1459     if (var-&gt;type() == T_OBJECT) {
1460       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1461     }
1462   }
1463 C2V_END
1464 
1465 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))
1466   if (bytes == NULL) {
1467     THROW(vmSymbols::java_lang_NullPointerException());
1468   }
1469   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);
1470 
1471   // Check if offset and length are non negative.
1472   if (offset &lt; 0 || length &lt; 0) {
1473     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1474   }
1475   // Check if the range is valid.
1476   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {
1477     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1478   }
1479   while (length &gt; 0) {
1480     jbyte* start = array-&gt;byte_at_addr(offset);
1481     tty-&gt;write((char*) start, MIN2(length, O_BUFLEN));
1482     length -= O_BUFLEN;
1483     offset += O_BUFLEN;
1484   }
1485 C2V_END
1486 
1487 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))
1488   tty-&gt;flush();
1489 C2V_END
1490 
1491 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))
1492   ResourceMark rm;
1493   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1494   ProfileData* profile_data = mdo-&gt;data_at(position);
1495   if (mdo-&gt;is_valid(profile_data)) {
1496     return profile_data-&gt;size_in_bytes();
1497   }
1498   DataLayout* data    = mdo-&gt;extra_data_base();
1499   DataLayout* end   = mdo-&gt;extra_data_limit();
1500   for (;; data = mdo-&gt;next_extra(data)) {
1501     assert(data &lt; end, "moved past end of extra data");
1502     profile_data = data-&gt;data_in();
1503     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1504       return profile_data-&gt;size_in_bytes();
1505     }
1506   }
1507   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Invalid profile data position %d", position));
1508 C2V_END
1509 
1510 C2V_VMENTRY(jlong, getFingerprint, (JNIEnv*, jobject, jlong metaspace_klass))
1511   Klass *k = CompilerToVM::asKlass(metaspace_klass);
1512   if (k-&gt;is_instance_klass()) {
1513     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1514   } else {
1515     return 0;
1516   }
1517 C2V_END
1518 
1519 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))
1520   if (bytecode_frame_handle == NULL) {
1521     THROW_0(vmSymbols::java_lang_NullPointerException());
1522   }
1523 
1524   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);
1525   oop bytecode_frame = top_bytecode_frame;
1526   int size = 0;
1527   int callee_parameters = 0;
1528   int callee_locals = 0;
1529   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1530   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);
1531 
1532   while (bytecode_frame != NULL) {
1533     int locks = BytecodeFrame::numLocks(bytecode_frame);
1534     int temps = BytecodeFrame::numStack(bytecode_frame);
1535     bool is_top_frame = (bytecode_frame == top_bytecode_frame);
1536     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1537 
1538     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1539                                                                  temps + callee_parameters,
1540                                                                  extra_args,
1541                                                                  locks,
1542                                                                  callee_parameters,
1543                                                                  callee_locals,
1544                                                                  is_top_frame);
1545     size += frame_size;
1546 
1547     callee_parameters = method-&gt;size_of_parameters();
1548     callee_locals = method-&gt;max_locals();
1549     extra_args = 0;
1550     bytecode_frame = BytecodePosition::caller(bytecode_frame);
1551   }
1552   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1553 C2V_END
1554 
1555 C2V_VMENTRY(void, compileToBytecode, (JNIEnv*, jobject, jobject lambda_form_handle))
1556   Handle lambda_form = JNIHandles::resolve_non_null(lambda_form_handle);
1557   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1558     TempNewSymbol compileToBytecode = SymbolTable::new_symbol("compileToBytecode", CHECK);
1559     JavaValue result(T_VOID);
1560     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1561   } else {
1562     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1563                 err_msg("Unexpected type: %s", lambda_form-&gt;klass()-&gt;external_name()));
1564   }
1565 C2V_END
1566 
1567 #define CC (char*)  /*cast a literal from (const char*)*/
1568 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1569 
1570 #define STRING                "Ljava/lang/String;"
1571 #define OBJECT                "Ljava/lang/Object;"
1572 #define CLASS                 "Ljava/lang/Class;"
1573 #define EXECUTABLE            "Ljava/lang/reflect/Executable;"
1574 #define STACK_TRACE_ELEMENT   "Ljava/lang/StackTraceElement;"
1575 #define INSTALLED_CODE        "Ljdk/vm/ci/code/InstalledCode;"
1576 #define TARGET_DESCRIPTION    "Ljdk/vm/ci/code/TargetDescription;"
1577 #define BYTECODE_FRAME        "Ljdk/vm/ci/code/BytecodeFrame;"
1578 #define RESOLVED_METHOD       "Ljdk/vm/ci/meta/ResolvedJavaMethod;"
1579 #define HS_RESOLVED_METHOD    "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;"
1580 #define HS_RESOLVED_KLASS     "Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;"
1581 #define HS_CONSTANT_POOL      "Ljdk/vm/ci/hotspot/HotSpotConstantPool;"
1582 #define HS_COMPILED_CODE      "Ljdk/vm/ci/hotspot/HotSpotCompiledCode;"
1583 #define HS_CONFIG             "Ljdk/vm/ci/hotspot/HotSpotVMConfig;"
1584 #define HS_METADATA           "Ljdk/vm/ci/hotspot/HotSpotMetaData;"
1585 #define HS_STACK_FRAME_REF    "Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;"
1586 #define HS_SPECULATION_LOG    "Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;"
1587 #define METASPACE_METHOD_DATA "J"
1588 
1589 JNINativeMethod CompilerToVM::methods[] = {
1590   {CC "getBytecode",                                  CC "(" HS_RESOLVED_METHOD ")[B",                                                      FN_PTR(getBytecode)},
1591   {CC "getExceptionTableStart",                       CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getExceptionTableStart)},
1592   {CC "getExceptionTableLength",                      CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getExceptionTableLength)},
1593   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1594   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1595   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1596   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1597   {CC "doNotInlineOrCompile",                         CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(doNotInlineOrCompile)},
1598   {CC "isCompilable",                                 CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(isCompilable)},
1599   {CC "hasNeverInlineDirective",                      CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(hasNeverInlineDirective)},
1600   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1601   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1602   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1603   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1604   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1605   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1606   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1607   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1608   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1609   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1610   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1611   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1612   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
1613   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[J)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
1614   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1615   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1616   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1617   {CC "getSignaturePolymorphicHolders",               CC "()[" STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
1618   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1619   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1620   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1621   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1622   {CC "asResolvedJavaMethod",                         CC "(" EXECUTABLE ")" HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
1623   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1624   {CC "getConstantPool",                              CC "(Ljava/lang/Object;)" HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},
1625   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1626   {CC "readConfiguration",                            CC "()[" OBJECT,                                                                      FN_PTR(readConfiguration)},
1627   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1628   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1629   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1630   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1631   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1632   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1633   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1634   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1635   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1636   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1637   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1638   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1639   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1640   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1641   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1642   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1643   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1644   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1645   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1646   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1647   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1648   {CC "getFingerprint",                               CC "(J)J",                                                                            FN_PTR(getFingerprint)},
1649   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1650   {CC "compileToBytecode",                            CC "(" OBJECT ")V",                                                                   FN_PTR(compileToBytecode)},
1651 };
1652 
1653 int CompilerToVM::methods_count() {
1654   return sizeof(methods) / sizeof(JNINativeMethod);
1655 }
</pre></body></html>
