<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/share/vm/jvmci </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/jdk.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/share/vm/jvmci/jvmciCompilerToVM.hpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/share/vm/jvmci/jvmciCompilerToVM.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12604">12604</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8173912">8173912</a>: [JVMCI] fix memory overhead of JVMCI</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"

  56 
  57 
  58 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  59 #define C2V_VMENTRY(result_type, name, signature) \
  60   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  61   TRACE_jvmci_1("CompilerToVM::" #name); \
  62   TRACE_CALL(result_type, jvmci_ ## name signature) \
  63   JVMCI_VM_ENTRY_MARK; \
  64 
  65 #define C2V_END }
  66 
  67 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  68   if (method() != NULL) {
  69     JavaValue result(T_OBJECT);
  70     JavaCallArguments args;
  71     args.push_long((jlong) (address) method());
  72     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  73 
  74     return (oop)result.get_jobject();
  75   }

</pre><hr></hr><pre>
 103 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 104 int CompilerToVM::Data::Universe_base_vtable_size;
 105 address CompilerToVM::Data::Universe_narrow_oop_base;
 106 int CompilerToVM::Data::Universe_narrow_oop_shift;
 107 address CompilerToVM::Data::Universe_narrow_klass_base;
 108 int CompilerToVM::Data::Universe_narrow_klass_shift;
 109 void* CompilerToVM::Data::Universe_non_oop_bits;
 110 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 111 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 112 
 113 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 114 HeapWord** CompilerToVM::Data::_heap_end_addr;
 115 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
 116 int CompilerToVM::Data::_max_oop_map_stack_offset;
 117 
 118 jbyte* CompilerToVM::Data::cardtable_start_address;
 119 int CompilerToVM::Data::cardtable_shift;
 120 
 121 int CompilerToVM::Data::vm_page_size;
 122 









 123 address CompilerToVM::Data::dsin;
 124 address CompilerToVM::Data::dcos;
 125 address CompilerToVM::Data::dtan;
 126 address CompilerToVM::Data::dexp;
 127 address CompilerToVM::Data::dlog;
 128 address CompilerToVM::Data::dlog10;
 129 address CompilerToVM::Data::dpow;
 130 
<span class="changed"> 131 void CompilerToVM::Data::initialize() {</span>



 132   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 133   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 134 
 135   Method_extra_stack_entries = Method::extra_stack_entries();
 136 
 137   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 138   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 139   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 140   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 141 
 142   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 143 
 144   Universe_collectedHeap = Universe::heap();
 145   Universe_base_vtable_size = Universe::base_vtable_size();
 146   Universe_narrow_oop_base = Universe::narrow_oop_base();
 147   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 148   Universe_narrow_klass_base = Universe::narrow_klass_base();
 149   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 150   Universe_non_oop_bits = Universe::non_oop_word();
 151   Universe_verify_oop_mask = Universe::verify_oop_mask();
 152   Universe_verify_oop_bits = Universe::verify_oop_bits();
 153 
 154   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 155   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 156   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
 157 
 158   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 159   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 160   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 161   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 162 



 163   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 164   switch (bs-&gt;kind()) {
 165   case BarrierSet::CardTableModRef:
 166   case BarrierSet::CardTableForRS:
 167   case BarrierSet::CardTableExtension:
 168   case BarrierSet::G1SATBCT:
 169   case BarrierSet::G1SATBCTLogging: {
 170     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 171     assert(base != 0, "unexpected byte_map_base");
 172     cardtable_start_address = base;
 173     cardtable_shift = CardTableModRefBS::card_shift;
 174     break;
 175   }
 176   case BarrierSet::ModRef:
 177     cardtable_start_address = 0;
 178     cardtable_shift = 0;
 179     // No post barriers
 180     break;
 181   default:
<span class="changed"> 182     ShouldNotReachHere();</span>
 183     break;
 184   }
 185 
 186   vm_page_size = os::vm_page_size();
 187 
 188 #define SET_TRIGFUNC(name)                                      \
 189   if (StubRoutines::name() != NULL) {                           \
 190     name = StubRoutines::name();                                \
 191   } else {                                                      \
 192     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 193   }
 194 
 195   SET_TRIGFUNC(dsin);
 196   SET_TRIGFUNC(dcos);
 197   SET_TRIGFUNC(dtan);
 198   SET_TRIGFUNC(dexp);
 199   SET_TRIGFUNC(dlog10);
 200   SET_TRIGFUNC(dlog);
 201   SET_TRIGFUNC(dpow);
 202 

</pre><hr></hr><pre>
 220       kls_sid = SID_ENUM(kls);                                            \
 221     }                                                                     \
 222     Handle name_str = VM_SYMBOL_TO_STRING(name);                          \
 223     Handle sig_str = VM_SYMBOL_TO_STRING(sig);                            \
 224     VMIntrinsicMethod::set_declaringClass(vmIntrinsicMethod, kls_str());  \
 225     VMIntrinsicMethod::set_name(vmIntrinsicMethod, name_str());           \
 226     VMIntrinsicMethod::set_descriptor(vmIntrinsicMethod, sig_str());      \
 227     VMIntrinsicMethod::set_id(vmIntrinsicMethod, vmIntrinsics::id);       \
 228       vmIntrinsics-&gt;obj_at_put(index++, vmIntrinsicMethod());             \
 229   }
 230 
 231   VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
 232 #undef SID_ENUM
 233 #undef VM_SYMBOL_TO_STRING
 234 #undef VM_INTRINSIC_INFO
 235   assert(index == vmIntrinsics::ID_LIMIT - 1, "must be");
 236 
 237   return vmIntrinsics;
 238 }
 239 
<span class="changed"> 240 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))</span>
<span class="changed"> 241 #define BOXED_LONG(name, value) oop name; do { jvalue p; p.j = (jlong) (value); name = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL);} while(0)</span>































































 242 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)






























 243   ResourceMark rm;
 244   HandleMark hm;
 245 
<span class="changed"> 246   CompilerToVM::Data::initialize();</span>








 247 
 248   VMField::klass()-&gt;initialize(CHECK_NULL);
 249   VMFlag::klass()-&gt;initialize(CHECK_NULL);
 250   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);
 251 
 252   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
 253   objArrayHandle vmFields = oopFactory::new_objArray(VMField::klass(), len, CHECK_NULL);
 254   for (int i = 0; i &lt; len ; i++) {
 255     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
 256     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 257     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* "::" */;
 258     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
 259     sprintf(name_buf, "%s::%s", vmField.typeName, vmField.fieldName);
<span class="changed"> 260     Handle name = java_lang_String::create_from_str(name_buf, CHECK_NULL);</span>
<span class="changed"> 261     Handle type = java_lang_String::create_from_str(vmField.typeString, CHECK_NULL);</span>
 262     VMField::set_name(vmFieldObj, name());
 263     VMField::set_type(vmFieldObj, type());
 264     VMField::set_offset(vmFieldObj, vmField.offset);
 265     VMField::set_address(vmFieldObj, (jlong) vmField.address);
<span class="changed"> 266     if (vmField.isStatic) {</span>
 267       if (strcmp(vmField.typeString, "bool") == 0) {
<span class="changed"> 268         BOXED_LONG(value, *(jbyte*) vmField.address);</span>
<span class="changed"> 269         VMField::set_value(vmFieldObj, value);</span>
 270       } else if (strcmp(vmField.typeString, "int") == 0 ||
 271                  strcmp(vmField.typeString, "jint") == 0) {
<span class="changed"> 272         BOXED_LONG(value, *(jint*) vmField.address);</span>
<span class="changed"> 273         VMField::set_value(vmFieldObj, value);</span>
 274       } else if (strcmp(vmField.typeString, "uint64_t") == 0) {
<span class="changed"> 275         BOXED_LONG(value, *(uint64_t*) vmField.address);</span>
<span class="changed"> 276         VMField::set_value(vmFieldObj, value);</span>
 277       } else if (strcmp(vmField.typeString, "address") == 0 ||
 278                  strcmp(vmField.typeString, "intptr_t") == 0 ||
 279                  strcmp(vmField.typeString, "uintptr_t") == 0 ||
 280                  strcmp(vmField.typeString, "size_t") == 0 ||
 281                  // All foo* types are addresses.
 282                  vmField.typeString[strlen(vmField.typeString) - 1] == '*') {
<span class="changed"> 283         BOXED_LONG(value, *((address*) vmField.address));</span>
<span class="changed"> 284         VMField::set_value(vmFieldObj, value);</span>
 285       } else {
 286         JVMCI_ERROR_NULL("VM field %s has unsupported type %s", name_buf, vmField.typeString);
 287       }
 288     }
 289     vmFields-&gt;obj_at_put(i, vmFieldObj());
 290   }
 291 
<span class="removed"> 292   len = JVMCIVMStructs::localHotSpotVMTypes_count();</span>
<span class="removed"> 293   objArrayHandle vmTypes = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);</span>
<span class="removed"> 294   for (int i = 0; i &lt; len ; i++) {</span>
<span class="removed"> 295     VMTypeEntry vmType = JVMCIVMStructs::localHotSpotVMTypes[i];</span>
<span class="removed"> 296     Handle name = java_lang_String::create_from_str(vmType.typeName, CHECK_NULL);</span>
<span class="removed"> 297     BOXED_LONG(size, vmType.size);</span>
<span class="removed"> 298     vmTypes-&gt;obj_at_put(i * 2, name());</span>
<span class="removed"> 299     vmTypes-&gt;obj_at_put(i * 2 + 1, size);</span>
<span class="removed"> 300   }</span>
<span class="removed"> 301 </span>
 302   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
 303   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
 304   len = ints_len + longs_len;
 305   objArrayHandle vmConstants = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 306   int insert = 0;
 307   for (int i = 0; i &lt; ints_len ; i++) {
 308     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
<span class="changed"> 309     Handle name = java_lang_String::create_from_str(c.name, CHECK_NULL);</span>
 310     BOXED_LONG(value, c.value);
 311     vmConstants-&gt;obj_at_put(insert++, name());
 312     vmConstants-&gt;obj_at_put(insert++, value);
 313   }
 314   for (int i = 0; i &lt; longs_len ; i++) {
 315     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
<span class="changed"> 316     Handle name = java_lang_String::create_from_str(c.name, CHECK_NULL);</span>
 317     BOXED_LONG(value, c.value);
 318     vmConstants-&gt;obj_at_put(insert++, name());
 319     vmConstants-&gt;obj_at_put(insert++, value);
 320   }
 321   assert(insert == len * 2, "must be");
 322 
 323   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
 324   objArrayHandle vmAddresses = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 325   for (int i = 0; i &lt; len ; i++) {
 326     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
<span class="changed"> 327     Handle name = java_lang_String::create_from_str(a.name, CHECK_NULL);</span>
 328     BOXED_LONG(value, a.value);
 329     vmAddresses-&gt;obj_at_put(i * 2, name());
 330     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);
 331   }
 332 
<span class="changed"> 333   // The last entry is the null entry.</span>
<span class="changed"> 334   len = (int) Flag::numFlags - 1;</span>

























 335   objArrayHandle vmFlags = oopFactory::new_objArray(VMFlag::klass(), len, CHECK_NULL);
<span class="changed"> 336   for (int i = 0; i &lt; len; i++) {</span>
<span class="changed"> 337     Flag* flag = &amp;Flag::flags[i];</span>
<span class="changed"> 338     instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL);</span>
<span class="changed"> 339     Handle name = java_lang_String::create_from_str(flag-&gt;_name, CHECK_NULL);</span>
<span class="changed"> 340     Handle type = java_lang_String::create_from_str(flag-&gt;_type, CHECK_NULL);</span>
<span class="changed"> 341     VMFlag::set_name(vmFlagObj, name());</span>
<span class="changed"> 342     VMFlag::set_type(vmFlagObj, type());</span>



























 343     if (flag-&gt;is_bool()) {
<span class="changed"> 344       BOXED_LONG(value, flag-&gt;get_bool());</span>
<span class="changed"> 345       VMFlag::set_value(vmFlagObj, value);</span>


 346     } else if (flag-&gt;is_ccstr()) {
 347       Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
<span class="changed"> 348       VMFlag::set_value(vmFlagObj, value());</span>
<span class="changed"> 349     } else if (flag-&gt;is_int()) {</span>
<span class="changed"> 350       BOXED_LONG(value, flag-&gt;get_int());</span>
<span class="changed"> 351       VMFlag::set_value(vmFlagObj, value);</span>
 352     } else if (flag-&gt;is_intx()) {
<span class="changed"> 353       BOXED_LONG(value, flag-&gt;get_intx());</span>
<span class="changed"> 354       VMFlag::set_value(vmFlagObj, value);</span>

 355     } else if (flag-&gt;is_uint()) {
<span class="changed"> 356       BOXED_LONG(value, flag-&gt;get_uint());</span>
<span class="changed"> 357       VMFlag::set_value(vmFlagObj, value);</span>
 358     } else if (flag-&gt;is_uint64_t()) {
<span class="changed"> 359       BOXED_LONG(value, flag-&gt;get_uint64_t());</span>
<span class="changed"> 360       VMFlag::set_value(vmFlagObj, value);</span>

 361     } else if (flag-&gt;is_uintx()) {
<span class="changed"> 362       BOXED_LONG(value, flag-&gt;get_uintx());</span>
<span class="changed"> 363       VMFlag::set_value(vmFlagObj, value);</span>
 364     } else if (flag-&gt;is_double()) {
<span class="changed"> 365       BOXED_DOUBLE(value, flag-&gt;get_double());</span>
<span class="changed"> 366       VMFlag::set_value(vmFlagObj, value);</span>
<span class="changed"> 367     } else if (flag-&gt;is_size_t()) {</span>
<span class="changed"> 368       BOXED_LONG(value, flag-&gt;get_size_t());</span>
<span class="changed"> 369       VMFlag::set_value(vmFlagObj, value);</span>
 370     } else {
 371       JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
 372     }
<span class="changed"> 373     vmFlags-&gt;obj_at_put(i, vmFlagObj());</span>
<span class="changed"> 374   }</span>
<span class="changed"> 375 </span>
<span class="changed"> 376   objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);</span>
<span class="changed"> 377 </span>
<span class="changed"> 378   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 6, CHECK_NULL);</span>
<span class="changed"> 379   data-&gt;obj_at_put(0, vmFields());</span>
<span class="changed"> 380   data-&gt;obj_at_put(1, vmTypes());</span>
<span class="changed"> 381   data-&gt;obj_at_put(2, vmConstants());</span>
<span class="changed"> 382   data-&gt;obj_at_put(3, vmAddresses());</span>
<span class="changed"> 383   data-&gt;obj_at_put(4, vmFlags());</span>
<span class="changed"> 384   data-&gt;obj_at_put(5, vmIntrinsics());</span>
 385 
<span class="removed"> 386   return (jobjectArray) JNIHandles::make_local(THREAD, data);</span>
 387 #undef BOXED_LONG
 388 #undef BOXED_DOUBLE
<span class="changed"> 389 C2V_END</span>
 390 
 391 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 392   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 393   ResourceMark rm;
 394 
 395   int code_size = method-&gt;code_size();
 396   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 397 
 398   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 399   // iterate over all bytecodes and replace non-Java bytecodes
 400 
 401   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 402     Bytecodes::Code code = s.code();
 403     Bytecodes::Code raw_code = s.raw_code();
 404     int bci = s.bci();
 405     int len = s.instruction_size();
 406 
 407     // Restore original byte code.
 408     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 409     if (len &gt; 1) {

</pre><hr></hr><pre>
 726 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 727   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 728   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 729   return JNIHandles::make_local(THREAD, appendix_oop);
 730 C2V_END
 731 
 732 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 733   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 734   instanceKlassHandle pool_holder(cp-&gt;pool_holder());
 735   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 736   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 737   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 738   return JNIHandles::make_local(THREAD, result);
 739 C2V_END
 740 
 741 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 742   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 743   return cp-&gt;remap_instruction_operand_from_cache(index);
 744 C2V_END
 745 
<span class="changed"> 746 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jlongArray info_handle))</span>
 747   ResourceMark rm;
 748   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 749   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 750   fieldDescriptor fd;
 751   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
 752   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 753   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
<span class="changed"> 754   assert(info != NULL &amp;&amp; info-&gt;length() == 2, "must be");</span>
<span class="changed"> 755   info-&gt;long_at_put(0, (jlong) fd.access_flags().as_int());</span>
<span class="changed"> 756   info-&gt;long_at_put(1, (jlong) fd.offset());</span>



 757   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 758   return JNIHandles::make_local(THREAD, field_holder);
 759 C2V_END
 760 
 761 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 762   ResourceMark rm;
 763   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 764   Method* method = CompilerToVM::asMethod(jvmci_method);
 765   if (klass-&gt;is_interface()) {
 766     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 767   }
 768   if (!method-&gt;method_holder()-&gt;is_interface()) {
 769     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 770   }
 771   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 772     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 773   }
 774   return LinkResolver::vtable_index_of_interface_method(klass, method);
 775 C2V_END
 776 

</pre><hr></hr><pre>
1593   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1594   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1595   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1596   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1597   {CC "doNotInlineOrCompile",                         CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(doNotInlineOrCompile)},
1598   {CC "isCompilable",                                 CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(isCompilable)},
1599   {CC "hasNeverInlineDirective",                      CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(hasNeverInlineDirective)},
1600   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1601   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1602   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1603   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1604   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1605   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1606   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1607   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1608   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1609   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1610   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1611   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1612   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
<span class="changed">1613   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[J)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},</span>
1614   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1615   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1616   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1617   {CC "getSignaturePolymorphicHolders",               CC "()[" STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
1618   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1619   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1620   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1621   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1622   {CC "asResolvedJavaMethod",                         CC "(" EXECUTABLE ")" HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
1623   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1624   {CC "getConstantPool",                              CC "(Ljava/lang/Object;)" HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},
1625   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1626   {CC "readConfiguration",                            CC "()[" OBJECT,                                                                      FN_PTR(readConfiguration)},
1627   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1628   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1629   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1630   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1631   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1632   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1633   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1634   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1635   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1636   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1637   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1638   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1639   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1640   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1641   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1642   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1643   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1644   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1645   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1646   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1647   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1648   {CC "getFingerprint",                               CC "(J)J",                                                                            FN_PTR(getFingerprint)},
1649   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1650   {CC "compileToBytecode",                            CC "(" OBJECT ")V",                                                                   FN_PTR(compileToBytecode)},

1651 };
1652 
1653 int CompilerToVM::methods_count() {
1654   return sizeof(methods) / sizeof(JNINativeMethod);
1655 }
</pre></td><td><pre>

</pre><hr></hr><pre>
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"
<span class="new">  56 #include "utilities/resourceHash.hpp"</span>
  57 
  58 
  59 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  60 #define C2V_VMENTRY(result_type, name, signature) \
  61   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  62   TRACE_jvmci_1("CompilerToVM::" #name); \
  63   TRACE_CALL(result_type, jvmci_ ## name signature) \
  64   JVMCI_VM_ENTRY_MARK; \
  65 
  66 #define C2V_END }
  67 
  68 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  69   if (method() != NULL) {
  70     JavaValue result(T_OBJECT);
  71     JavaCallArguments args;
  72     args.push_long((jlong) (address) method());
  73     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  74 
  75     return (oop)result.get_jobject();
  76   }

</pre><hr></hr><pre>
 104 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 105 int CompilerToVM::Data::Universe_base_vtable_size;
 106 address CompilerToVM::Data::Universe_narrow_oop_base;
 107 int CompilerToVM::Data::Universe_narrow_oop_shift;
 108 address CompilerToVM::Data::Universe_narrow_klass_base;
 109 int CompilerToVM::Data::Universe_narrow_klass_shift;
 110 void* CompilerToVM::Data::Universe_non_oop_bits;
 111 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 112 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 113 
 114 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 115 HeapWord** CompilerToVM::Data::_heap_end_addr;
 116 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
 117 int CompilerToVM::Data::_max_oop_map_stack_offset;
 118 
 119 jbyte* CompilerToVM::Data::cardtable_start_address;
 120 int CompilerToVM::Data::cardtable_shift;
 121 
 122 int CompilerToVM::Data::vm_page_size;
 123 
<span class="new"> 124 int CompilerToVM::Data::sizeof_vtableEntry = sizeof(vtableEntry);</span>
<span class="new"> 125 int CompilerToVM::Data::sizeof_ExceptionTableElement = sizeof(ExceptionTableElement);</span>
<span class="new"> 126 int CompilerToVM::Data::sizeof_LocalVariableTableElement = sizeof(LocalVariableTableElement);</span>
<span class="new"> 127 int CompilerToVM::Data::sizeof_ConstantPool = sizeof(ConstantPool);</span>
<span class="new"> 128 int CompilerToVM::Data::sizeof_SymbolPointer = sizeof(Symbol*);</span>
<span class="new"> 129 int CompilerToVM::Data::sizeof_narrowKlass = sizeof(narrowKlass);</span>
<span class="new"> 130 int CompilerToVM::Data::sizeof_arrayOopDesc = sizeof(arrayOopDesc);</span>
<span class="new"> 131 int CompilerToVM::Data::sizeof_BasicLock = sizeof(BasicLock);</span>
<span class="new"> 132 </span>
 133 address CompilerToVM::Data::dsin;
 134 address CompilerToVM::Data::dcos;
 135 address CompilerToVM::Data::dtan;
 136 address CompilerToVM::Data::dexp;
 137 address CompilerToVM::Data::dlog;
 138 address CompilerToVM::Data::dlog10;
 139 address CompilerToVM::Data::dpow;
 140 
<span class="changed"> 141 address CompilerToVM::Data::symbol_init;</span>
<span class="changed"> 142 address CompilerToVM::Data::symbol_clinit;</span>
<span class="changed"> 143 </span>
<span class="changed"> 144 void CompilerToVM::Data::initialize(TRAPS) {</span>
 145   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 146   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 147 
 148   Method_extra_stack_entries = Method::extra_stack_entries();
 149 
 150   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 151   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 152   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 153   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 154 
 155   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 156 
 157   Universe_collectedHeap = Universe::heap();
 158   Universe_base_vtable_size = Universe::base_vtable_size();
 159   Universe_narrow_oop_base = Universe::narrow_oop_base();
 160   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 161   Universe_narrow_klass_base = Universe::narrow_klass_base();
 162   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 163   Universe_non_oop_bits = Universe::non_oop_word();
 164   Universe_verify_oop_mask = Universe::verify_oop_mask();
 165   Universe_verify_oop_bits = Universe::verify_oop_bits();
 166 
 167   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 168   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 169   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
 170 
 171   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 172   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 173   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 174   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 175 
<span class="new"> 176   symbol_init = (address) vmSymbols::object_initializer_name();</span>
<span class="new"> 177   symbol_clinit = (address) vmSymbols::class_initializer_name();</span>
<span class="new"> 178 </span>
 179   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 180   switch (bs-&gt;kind()) {
 181   case BarrierSet::CardTableModRef:
 182   case BarrierSet::CardTableForRS:
 183   case BarrierSet::CardTableExtension:
 184   case BarrierSet::G1SATBCT:
 185   case BarrierSet::G1SATBCTLogging: {
 186     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 187     assert(base != 0, "unexpected byte_map_base");
 188     cardtable_start_address = base;
 189     cardtable_shift = CardTableModRefBS::card_shift;
 190     break;
 191   }
 192   case BarrierSet::ModRef:
 193     cardtable_start_address = 0;
 194     cardtable_shift = 0;
 195     // No post barriers
 196     break;
 197   default:
<span class="changed"> 198     JVMCI_ERROR("Unsupported BarrierSet kind %d", bs-&gt;kind());</span>
 199     break;
 200   }
 201 
 202   vm_page_size = os::vm_page_size();
 203 
 204 #define SET_TRIGFUNC(name)                                      \
 205   if (StubRoutines::name() != NULL) {                           \
 206     name = StubRoutines::name();                                \
 207   } else {                                                      \
 208     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 209   }
 210 
 211   SET_TRIGFUNC(dsin);
 212   SET_TRIGFUNC(dcos);
 213   SET_TRIGFUNC(dtan);
 214   SET_TRIGFUNC(dexp);
 215   SET_TRIGFUNC(dlog10);
 216   SET_TRIGFUNC(dlog);
 217   SET_TRIGFUNC(dpow);
 218 

</pre><hr></hr><pre>
 236       kls_sid = SID_ENUM(kls);                                            \
 237     }                                                                     \
 238     Handle name_str = VM_SYMBOL_TO_STRING(name);                          \
 239     Handle sig_str = VM_SYMBOL_TO_STRING(sig);                            \
 240     VMIntrinsicMethod::set_declaringClass(vmIntrinsicMethod, kls_str());  \
 241     VMIntrinsicMethod::set_name(vmIntrinsicMethod, name_str());           \
 242     VMIntrinsicMethod::set_descriptor(vmIntrinsicMethod, sig_str());      \
 243     VMIntrinsicMethod::set_id(vmIntrinsicMethod, vmIntrinsics::id);       \
 244       vmIntrinsics-&gt;obj_at_put(index++, vmIntrinsicMethod());             \
 245   }
 246 
 247   VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
 248 #undef SID_ENUM
 249 #undef VM_SYMBOL_TO_STRING
 250 #undef VM_INTRINSIC_INFO
 251   assert(index == vmIntrinsics::ID_LIMIT - 1, "must be");
 252 
 253   return vmIntrinsics;
 254 }
 255 
<span class="changed"> 256 /**</span>
<span class="changed"> 257  * The set of VM flags known to be used.</span>
<span class="changed"> 258  */</span>
<span class="changed"> 259 #define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_intx_flag, do_uintx_flag) \</span>
<span class="changed"> 260   do_intx_flag(AllocateInstancePrefetchLines)                              \</span>
<span class="changed"> 261   do_intx_flag(AllocatePrefetchDistance)                                   \</span>
<span class="changed"> 262   do_intx_flag(AllocatePrefetchInstr)                                      \</span>
<span class="changed"> 263   do_intx_flag(AllocatePrefetchLines)                                      \</span>
<span class="changed"> 264   do_intx_flag(AllocatePrefetchStepSize)                                   \</span>
<span class="changed"> 265   do_intx_flag(AllocatePrefetchStyle)                                      \</span>
<span class="changed"> 266   do_intx_flag(BciProfileWidth)                                            \</span>
<span class="changed"> 267   do_bool_flag(BootstrapJVMCI)                                             \</span>
<span class="changed"> 268   do_bool_flag(CITime)                                                     \</span>
<span class="changed"> 269   do_bool_flag(CITimeEach)                                                 \</span>
<span class="changed"> 270   do_uintx_flag(CodeCacheSegmentSize)                                      \</span>
<span class="changed"> 271   do_intx_flag(CodeEntryAlignment)                                         \</span>
<span class="changed"> 272   do_bool_flag(CompactFields)                                              \</span>
<span class="changed"> 273   NOT_PRODUCT(do_intx_flag(CompileTheWorldStartAt))                        \</span>
<span class="changed"> 274   NOT_PRODUCT(do_intx_flag(CompileTheWorldStopAt))                         \</span>
<span class="changed"> 275   do_intx_flag(ContendedPaddingWidth)                                      \</span>
<span class="changed"> 276   do_bool_flag(DontCompileHugeMethods)                                     \</span>
<span class="changed"> 277   do_bool_flag(EnableContended)                                            \</span>
<span class="changed"> 278   do_intx_flag(FieldsAllocationStyle)                                      \</span>
<span class="changed"> 279   do_bool_flag(FoldStableValues)                                           \</span>
<span class="changed"> 280   do_bool_flag(ForceUnreachable)                                           \</span>
<span class="changed"> 281   do_intx_flag(HugeMethodLimit)                                            \</span>
<span class="changed"> 282   do_bool_flag(Inline)                                                     \</span>
<span class="changed"> 283   do_intx_flag(JVMCICounterSize)                                           \</span>
<span class="changed"> 284   do_bool_flag(JVMCIPrintProperties)                                       \</span>
<span class="changed"> 285   do_bool_flag(JVMCIUseFastLocking)                                        \</span>
<span class="changed"> 286   do_intx_flag(MethodProfileWidth)                                         \</span>
<span class="changed"> 287   do_intx_flag(ObjectAlignmentInBytes)                                     \</span>
<span class="changed"> 288   do_bool_flag(PrintInlining)                                              \</span>
<span class="changed"> 289   do_bool_flag(ReduceInitialCardMarks)                                     \</span>
<span class="changed"> 290   do_bool_flag(RestrictContended)                                          \</span>
<span class="changed"> 291   do_intx_flag(StackReservedPages)                                         \</span>
<span class="changed"> 292   do_intx_flag(StackShadowPages)                                           \</span>
<span class="changed"> 293   do_bool_flag(TLABStats)                                                  \</span>
<span class="changed"> 294   do_uintx_flag(TLABWasteIncrement)                                        \</span>
<span class="changed"> 295   do_intx_flag(TypeProfileWidth)                                           \</span>
<span class="changed"> 296   do_bool_flag(UseAESIntrinsics)                                           \</span>
<span class="changed"> 297   X86_ONLY(do_intx_flag(UseAVX))                                           \</span>
<span class="changed"> 298   do_bool_flag(UseBiasedLocking)                                           \</span>
<span class="changed"> 299   do_bool_flag(UseCRC32Intrinsics)                                         \</span>
<span class="changed"> 300   do_bool_flag(UseCompressedClassPointers)                                 \</span>
<span class="changed"> 301   do_bool_flag(UseCompressedOops)                                          \</span>
<span class="changed"> 302   do_bool_flag(UseConcMarkSweepGC)                                         \</span>
<span class="changed"> 303   X86_ONLY(do_bool_flag(UseCountLeadingZerosInstruction))                  \</span>
<span class="changed"> 304   X86_ONLY(do_bool_flag(UseCountTrailingZerosInstruction))                 \</span>
<span class="changed"> 305   do_bool_flag(UseG1GC)                                                    \</span>
<span class="changed"> 306   COMPILER2_PRESENT(do_bool_flag(UseMontgomeryMultiplyIntrinsic))          \</span>
<span class="changed"> 307   COMPILER2_PRESENT(do_bool_flag(UseMontgomerySquareIntrinsic))            \</span>
<span class="changed"> 308   COMPILER2_PRESENT(do_bool_flag(UseMulAddIntrinsic))                      \</span>
<span class="changed"> 309   COMPILER2_PRESENT(do_bool_flag(UseMultiplyToLenIntrinsic))               \</span>
<span class="changed"> 310   do_bool_flag(UsePopCountInstruction)                                     \</span>
<span class="changed"> 311   do_bool_flag(UseSHA1Intrinsics)                                          \</span>
<span class="changed"> 312   do_bool_flag(UseSHA256Intrinsics)                                        \</span>
<span class="changed"> 313   do_bool_flag(UseSHA512Intrinsics)                                        \</span>
<span class="changed"> 314   do_intx_flag(UseSSE)                                                     \</span>
<span class="changed"> 315   COMPILER2_PRESENT(do_bool_flag(UseSquareToLenIntrinsic))                 \</span>
<span class="changed"> 316   do_bool_flag(UseStackBanging)                                            \</span>
<span class="changed"> 317   do_bool_flag(UseTLAB)                                                    \</span>
<span class="changed"> 318   do_bool_flag(VerifyOops)                                                 \</span>
<span class="changed"> 319 </span>
<span class="changed"> 320 #define BOXED_BOOLEAN(name, value) oop name = ((jboolean)(value) ? boxedTrue() : boxedFalse())</span>
 321 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)
<span class="new"> 322 #define BOXED_LONG(name, value) \</span>
<span class="new"> 323   oop name; \</span>
<span class="new"> 324   do { \</span>
<span class="new"> 325     jvalue p; p.j = (jlong) (value); \</span>
<span class="new"> 326     Handle* e = longs.get(p.j); \</span>
<span class="new"> 327     if (e == NULL) { \</span>
<span class="new"> 328       Handle h = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); \</span>
<span class="new"> 329       longs.put(p.j, h); \</span>
<span class="new"> 330       name = h(); \</span>
<span class="new"> 331     } else { \</span>
<span class="new"> 332       name = (*e)(); \</span>
<span class="new"> 333     } \</span>
<span class="new"> 334   } while (0)</span>
<span class="new"> 335 </span>
<span class="new"> 336 #define CSTRING_TO_JSTRING(name, value) \</span>
<span class="new"> 337   Handle name; \</span>
<span class="new"> 338   do { \</span>
<span class="new"> 339     if (value != NULL) { \</span>
<span class="new"> 340       Handle* e = strings.get(value); \</span>
<span class="new"> 341       if (e == NULL) { \</span>
<span class="new"> 342         Handle h = java_lang_String::create_from_str(value, CHECK_NULL); \</span>
<span class="new"> 343         strings.put(value, h); \</span>
<span class="new"> 344         name = h(); \</span>
<span class="new"> 345       } else { \</span>
<span class="new"> 346         name = (*e)(); \</span>
<span class="new"> 347       } \</span>
<span class="new"> 348     } \</span>
<span class="new"> 349   } while (0)</span>
<span class="new"> 350 </span>
<span class="new"> 351 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))</span>
 352   ResourceMark rm;
 353   HandleMark hm;
 354 
<span class="changed"> 355   // Used to canonicalize Long and String values.</span>
<span class="changed"> 356   ResourceHashtable&lt;jlong, Handle&gt; longs;</span>
<span class="changed"> 357   ResourceHashtable&lt;const char*, Handle, &amp;CompilerToVM::cstring_hash, &amp;CompilerToVM::cstring_equals&gt; strings;</span>
<span class="changed"> 358 </span>
<span class="changed"> 359   jvalue prim;</span>
<span class="changed"> 360   prim.z = true;  Handle boxedTrue =  java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="changed"> 361   prim.z = false; Handle boxedFalse = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="changed"> 362 </span>
<span class="changed"> 363   CompilerToVM::Data::initialize(CHECK_NULL);</span>
 364 
 365   VMField::klass()-&gt;initialize(CHECK_NULL);
 366   VMFlag::klass()-&gt;initialize(CHECK_NULL);
 367   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);
 368 
 369   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
 370   objArrayHandle vmFields = oopFactory::new_objArray(VMField::klass(), len, CHECK_NULL);
 371   for (int i = 0; i &lt; len ; i++) {
 372     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
 373     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 374     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* "::" */;
 375     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
 376     sprintf(name_buf, "%s::%s", vmField.typeName, vmField.fieldName);
<span class="changed"> 377     CSTRING_TO_JSTRING(name, name_buf);</span>
<span class="changed"> 378     CSTRING_TO_JSTRING(type, vmField.typeString);</span>
 379     VMField::set_name(vmFieldObj, name());
 380     VMField::set_type(vmFieldObj, type());
 381     VMField::set_offset(vmFieldObj, vmField.offset);
 382     VMField::set_address(vmFieldObj, (jlong) vmField.address);
<span class="changed"> 383     if (vmField.isStatic &amp;&amp; vmField.typeString != NULL) {</span>
 384       if (strcmp(vmField.typeString, "bool") == 0) {
<span class="changed"> 385         BOXED_BOOLEAN(box, *(jbyte*) vmField.address);</span>
<span class="changed"> 386         VMField::set_value(vmFieldObj, box);</span>
 387       } else if (strcmp(vmField.typeString, "int") == 0 ||
 388                  strcmp(vmField.typeString, "jint") == 0) {
<span class="changed"> 389         BOXED_LONG(box, *(jint*) vmField.address);</span>
<span class="changed"> 390         VMField::set_value(vmFieldObj, box);</span>
 391       } else if (strcmp(vmField.typeString, "uint64_t") == 0) {
<span class="changed"> 392         BOXED_LONG(box, *(uint64_t*) vmField.address);</span>
<span class="changed"> 393         VMField::set_value(vmFieldObj, box);</span>
 394       } else if (strcmp(vmField.typeString, "address") == 0 ||
 395                  strcmp(vmField.typeString, "intptr_t") == 0 ||
 396                  strcmp(vmField.typeString, "uintptr_t") == 0 ||
 397                  strcmp(vmField.typeString, "size_t") == 0 ||
 398                  // All foo* types are addresses.
 399                  vmField.typeString[strlen(vmField.typeString) - 1] == '*') {
<span class="changed"> 400         BOXED_LONG(box, *((address*) vmField.address));</span>
<span class="changed"> 401         VMField::set_value(vmFieldObj, box);</span>
 402       } else {
 403         JVMCI_ERROR_NULL("VM field %s has unsupported type %s", name_buf, vmField.typeString);
 404       }
 405     }
 406     vmFields-&gt;obj_at_put(i, vmFieldObj());
 407   }
 408 










 409   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
 410   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
 411   len = ints_len + longs_len;
 412   objArrayHandle vmConstants = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 413   int insert = 0;
 414   for (int i = 0; i &lt; ints_len ; i++) {
 415     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
<span class="changed"> 416     CSTRING_TO_JSTRING(name, c.name);</span>
 417     BOXED_LONG(value, c.value);
 418     vmConstants-&gt;obj_at_put(insert++, name());
 419     vmConstants-&gt;obj_at_put(insert++, value);
 420   }
 421   for (int i = 0; i &lt; longs_len ; i++) {
 422     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
<span class="changed"> 423     CSTRING_TO_JSTRING(name, c.name);</span>
 424     BOXED_LONG(value, c.value);
 425     vmConstants-&gt;obj_at_put(insert++, name());
 426     vmConstants-&gt;obj_at_put(insert++, value);
 427   }
 428   assert(insert == len * 2, "must be");
 429 
 430   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
 431   objArrayHandle vmAddresses = oopFactory::new_objArray(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 432   for (int i = 0; i &lt; len ; i++) {
 433     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
<span class="changed"> 434     CSTRING_TO_JSTRING(name, a.name);</span>
 435     BOXED_LONG(value, a.value);
 436     vmAddresses-&gt;obj_at_put(i * 2, name());
 437     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);
 438   }
 439 
<span class="changed"> 440 #define COUNT_FLAG(ignore) +1</span>
<span class="changed"> 441 #ifdef ASSERT</span>
<span class="changed"> 442 #define CHECK_FLAG(type, name) { \</span>
<span class="changed"> 443   Flag* flag = Flag::find_flag(#name, strlen(#name), /*allow_locked*/ true, /* return_flag */ true); \</span>
<span class="changed"> 444   assert(flag != NULL, "No such flag named " #name); \</span>
<span class="changed"> 445   assert(flag-&gt;is_##type(), "Flag " #name " is not of type " #type); \</span>
<span class="changed"> 446 }</span>
<span class="changed"> 447 #else</span>
<span class="changed"> 448 #define CHECK_FLAG(type, name)</span>
<span class="changed"> 449 #endif</span>
<span class="changed"> 450 </span>
<span class="changed"> 451 #define ADD_FLAG(type, name, convert) { \</span>
<span class="changed"> 452   CHECK_FLAG(type, name) \</span>
<span class="changed"> 453   instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL); \</span>
<span class="changed"> 454   CSTRING_TO_JSTRING(fname, #name); \</span>
<span class="changed"> 455   CSTRING_TO_JSTRING(ftype, #type); \</span>
<span class="changed"> 456   VMFlag::set_name(vmFlagObj, fname()); \</span>
<span class="changed"> 457   VMFlag::set_type(vmFlagObj, ftype()); \</span>
<span class="changed"> 458   convert(value, name); \</span>
<span class="changed"> 459   VMFlag::set_value(vmFlagObj, value); \</span>
<span class="changed"> 460   vmFlags-&gt;obj_at_put(i++, vmFlagObj()); \</span>
<span class="changed"> 461 }</span>
<span class="changed"> 462 #define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)</span>
<span class="changed"> 463 #define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)</span>
<span class="changed"> 464 #define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)</span>
<span class="changed"> 465 </span>
<span class="changed"> 466   len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);</span>
 467   objArrayHandle vmFlags = oopFactory::new_objArray(VMFlag::klass(), len, CHECK_NULL);
<span class="changed"> 468   int i = 0;</span>
<span class="changed"> 469   PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)</span>
<span class="changed"> 470 </span>
<span class="changed"> 471   objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);</span>
<span class="changed"> 472 </span>
<span class="changed"> 473   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 5, CHECK_NULL);</span>
<span class="changed"> 474   data-&gt;obj_at_put(0, vmFields());</span>
<span class="changed"> 475   data-&gt;obj_at_put(1, vmConstants());</span>
<span class="changed"> 476   data-&gt;obj_at_put(2, vmAddresses());</span>
<span class="changed"> 477   data-&gt;obj_at_put(3, vmFlags());</span>
<span class="changed"> 478   data-&gt;obj_at_put(4, vmIntrinsics());</span>
<span class="changed"> 479 </span>
<span class="changed"> 480   return (jobjectArray) JNIHandles::make_local(THREAD, data);</span>
<span class="changed"> 481 #undef COUNT_FLAG</span>
<span class="changed"> 482 #undef ADD_FLAG</span>
<span class="changed"> 483 #undef ADD_BOOL_FLAG</span>
<span class="changed"> 484 #undef ADD_INTX_FLAG</span>
<span class="changed"> 485 #undef ADD_UINTX_FLAG</span>
<span class="changed"> 486 #undef CHECK_FLAG</span>
<span class="changed"> 487 C2V_END</span>
<span class="changed"> 488 </span>
<span class="changed"> 489 C2V_VMENTRY(jobject, getFlagValue, (JNIEnv *, jobject c2vm, jobject name_handle))</span>
<span class="changed"> 490 #define RETURN_BOXED_LONG(value) oop box; jvalue p; p.j = (jlong) (value); box = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);</span>
<span class="changed"> 491 #define RETURN_BOXED_DOUBLE(value) oop box; jvalue p; p.d = (jdouble) (value); box = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);</span>
<span class="changed"> 492   Handle name = JNIHandles::resolve(name_handle);</span>
<span class="changed"> 493   if (name.is_null()) {</span>
<span class="changed"> 494     THROW_0(vmSymbols::java_lang_NullPointerException());</span>
<span class="changed"> 495   }</span>
<span class="changed"> 496   ResourceMark rm;</span>
<span class="changed"> 497   const char* cstring = java_lang_String::as_utf8_string(name());</span>
<span class="changed"> 498   Flag* flag = Flag::find_flag(cstring, strlen(cstring), /* allow_locked */ true, /* return_flag */ true);</span>
<span class="changed"> 499   if (flag == NULL) {</span>
<span class="changed"> 500     return c2vm;</span>
<span class="changed"> 501   }</span>
 502   if (flag-&gt;is_bool()) {
<span class="changed"> 503     jvalue prim;</span>
<span class="changed"> 504     prim.z = flag-&gt;get_bool();</span>
<span class="changed"> 505     oop box = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="changed"> 506     return JNIHandles::make_local(THREAD, box);</span>
 507   } else if (flag-&gt;is_ccstr()) {
 508     Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
<span class="changed"> 509     return JNIHandles::make_local(THREAD, value());</span>



 510   } else if (flag-&gt;is_intx()) {
<span class="changed"> 511     RETURN_BOXED_LONG(flag-&gt;get_intx());</span>
<span class="changed"> 512   } else if (flag-&gt;is_int()) {</span>
<span class="changed"> 513     RETURN_BOXED_LONG(flag-&gt;get_int());</span>
 514   } else if (flag-&gt;is_uint()) {
<span class="changed"> 515     RETURN_BOXED_LONG(flag-&gt;get_uint());</span>

 516   } else if (flag-&gt;is_uint64_t()) {
<span class="changed"> 517     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());</span>
<span class="changed"> 518   } else if (flag-&gt;is_size_t()) {</span>
<span class="changed"> 519     RETURN_BOXED_LONG(flag-&gt;get_size_t());</span>
 520   } else if (flag-&gt;is_uintx()) {
<span class="changed"> 521     RETURN_BOXED_LONG(flag-&gt;get_uintx());</span>

 522   } else if (flag-&gt;is_double()) {
<span class="changed"> 523     RETURN_BOXED_DOUBLE(flag-&gt;get_double());</span>




 524   } else {
 525     JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
 526   }
<span class="changed"> 527 C2V_END</span>











 528 

 529 #undef BOXED_LONG
 530 #undef BOXED_DOUBLE
<span class="changed"> 531 #undef CSTRING_TO_JSTRING</span>
 532 
 533 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 534   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 535   ResourceMark rm;
 536 
 537   int code_size = method-&gt;code_size();
 538   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 539 
 540   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 541   // iterate over all bytecodes and replace non-Java bytecodes
 542 
 543   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 544     Bytecodes::Code code = s.code();
 545     Bytecodes::Code raw_code = s.raw_code();
 546     int bci = s.bci();
 547     int len = s.instruction_size();
 548 
 549     // Restore original byte code.
 550     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 551     if (len &gt; 1) {

</pre><hr></hr><pre>
 868 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 869   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 870   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 871   return JNIHandles::make_local(THREAD, appendix_oop);
 872 C2V_END
 873 
 874 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 875   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 876   instanceKlassHandle pool_holder(cp-&gt;pool_holder());
 877   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 878   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 879   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 880   return JNIHandles::make_local(THREAD, result);
 881 C2V_END
 882 
 883 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 884   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 885   return cp-&gt;remap_instruction_operand_from_cache(index);
 886 C2V_END
 887 
<span class="changed"> 888 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))</span>
 889   ResourceMark rm;
 890   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 891   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 892   fieldDescriptor fd;
 893   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
 894   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 895   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
<span class="changed"> 896   if (info == NULL || info-&gt;length() != 3) {</span>
<span class="changed"> 897     JVMCI_ERROR_NULL("info must not be null and have a length of 3");</span>
<span class="changed"> 898   }</span>
<span class="changed"> 899   info-&gt;int_at_put(0, fd.access_flags().as_int());</span>
<span class="changed"> 900   info-&gt;int_at_put(1, fd.offset());</span>
<span class="changed"> 901   info-&gt;int_at_put(2, fd.index());</span>
 902   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 903   return JNIHandles::make_local(THREAD, field_holder);
 904 C2V_END
 905 
 906 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 907   ResourceMark rm;
 908   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 909   Method* method = CompilerToVM::asMethod(jvmci_method);
 910   if (klass-&gt;is_interface()) {
 911     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 912   }
 913   if (!method-&gt;method_holder()-&gt;is_interface()) {
 914     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 915   }
 916   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 917     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 918   }
 919   return LinkResolver::vtable_index_of_interface_method(klass, method);
 920 C2V_END
 921 

</pre><hr></hr><pre>
1738   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1739   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1740   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1741   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1742   {CC "doNotInlineOrCompile",                         CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(doNotInlineOrCompile)},
1743   {CC "isCompilable",                                 CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(isCompilable)},
1744   {CC "hasNeverInlineDirective",                      CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(hasNeverInlineDirective)},
1745   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1746   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1747   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1748   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1749   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1750   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1751   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1752   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1753   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1754   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1755   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1756   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1757   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
<span class="changed">1758   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[I)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},</span>
1759   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1760   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1761   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1762   {CC "getSignaturePolymorphicHolders",               CC "()[" STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
1763   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1764   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1765   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1766   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1767   {CC "asResolvedJavaMethod",                         CC "(" EXECUTABLE ")" HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
1768   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1769   {CC "getConstantPool",                              CC "(Ljava/lang/Object;)" HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},
1770   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1771   {CC "readConfiguration",                            CC "()[" OBJECT,                                                                      FN_PTR(readConfiguration)},
1772   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1773   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1774   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1775   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1776   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1777   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1778   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1779   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1780   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1781   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1782   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1783   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1784   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1785   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1786   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1787   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1788   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1789   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1790   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1791   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1792   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1793   {CC "getFingerprint",                               CC "(J)J",                                                                            FN_PTR(getFingerprint)},
1794   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1795   {CC "compileToBytecode",                            CC "(" OBJECT ")V",                                                                   FN_PTR(compileToBytecode)},
<span class="new">1796   {CC "getFlagValue",                                 CC "(" STRING ")" OBJECT,                                                             FN_PTR(getFlagValue)},</span>
1797 };
1798 
1799 int CompilerToVM::methods_count() {
1800   return sizeof(methods) / sizeof(JNINativeMethod);
1801 }
</pre></td>
</tr></table>
<center><a href='../../../../src/jdk.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/share/vm/jvmci/jvmciCompilerToVM.hpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
