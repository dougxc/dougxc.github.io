<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfig.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12604">12604</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8173912">8173912</a>: [JVMCI] fix memory overhead of JVMCI</pre>

<table><tr valign="top">
<td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotConstantPool.isSignaturePolymorphicHolder;
  28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  29 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  30 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  31 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  32 
  33 import java.lang.annotation.Annotation;
  34 import java.lang.reflect.Array;
  35 import java.lang.reflect.Constructor;
  36 import java.lang.reflect.Method;
  37 import java.lang.reflect.Modifier;
  38 import java.nio.ByteOrder;
<span class="removed">  39 import java.util.ArrayList;</span>
<span class="removed">  40 import java.util.Arrays;</span>
  41 import java.util.HashMap;
  42 
  43 import jdk.vm.ci.common.JVMCIError;
  44 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  45 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  46 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  47 import jdk.vm.ci.meta.Assumptions.LeafType;
  48 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  49 import jdk.vm.ci.meta.Constant;
  50 import jdk.vm.ci.meta.JavaConstant;
  51 import jdk.vm.ci.meta.JavaKind;
  52 import jdk.vm.ci.meta.JavaType;
  53 import jdk.vm.ci.meta.ResolvedJavaField;
  54 import jdk.vm.ci.meta.ResolvedJavaMethod;
  55 import jdk.vm.ci.meta.ResolvedJavaType;
  56 
  57 /**
  58  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.
  59  */
  60 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceWrapperObject {
  61 



  62     /**
  63      * The Java class this type represents.
  64      */
  65     private final Class&lt;?&gt; javaClass;
<span class="changed">  66     private HashMap&lt;Long, HotSpotResolvedJavaField&gt; fieldCache;</span>
<span class="changed">  67     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCache;</span>
  68     private HotSpotResolvedJavaField[] instanceFields;
  69     private HotSpotResolvedObjectTypeImpl[] interfaces;
  70     private HotSpotConstantPool constantPool;
  71     final HotSpotJVMCIMetaAccessContext context;
  72     private HotSpotResolvedObjectType arrayOfType;
  73 
  74     /**
  75      * Gets the JVMCI mirror for a {@link Class} object.
  76      *
  77      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}
  78      */
  79     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {
  80         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);
  81     }
  82 
  83     /**
  84      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the
  85      * underlying Klass*, it is used instead of the raw Klass*.
  86      *
  87      * Called from the VM.

</pre><hr></hr><pre>
 238                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 239             }
 240         }
 241     }
 242 
 243     private AssumptionResult&lt;ResolvedJavaType&gt; concreteSubtype(HotSpotResolvedObjectTypeImpl type) {
 244         if (type.isLeaf()) {
 245             return new AssumptionResult&lt;&gt;(type, new ConcreteSubtype(this, type));
 246         } else {
 247             return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 248         }
 249     }
 250 
 251     /**
 252      * Returns if type {@code type} is a leaf class. This is the case if the
 253      * {@code Klass::_subklass} field of the underlying class is zero.
 254      *
 255      * @return true if the type is a leaf class
 256      */
 257     private boolean isLeafClass() {
<span class="changed"> 258         return getSubklass() == null;</span>
 259     }
 260 
 261     /**
 262      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 263      * type {@code type}.
 264      *
 265      * @return value of the subklass field as metaspace klass pointer
 266      */
 267     private HotSpotResolvedObjectTypeImpl getSubklass() {
 268         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 269     }
 270 
 271     @Override
 272     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 273         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();
 274         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);
 275     }
 276 
 277     @Override
 278     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {

</pre><hr></hr><pre>
 467         // See: Klass::layout_helper_size_in_bytes
 468         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 469 
 470         // See: Klass::layout_helper_needs_slow_path
 471         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 472 
 473         return needsSlowPath ? -size : size;
 474     }
 475 
 476     public int layoutHelper() {
 477         HotSpotVMConfig config = config();
 478         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 479     }
 480 
 481     @Override
 482     public long getFingerprint() {
 483         return compilerToVM().getFingerprint(getMetaspaceKlass());
 484     }
 485 
 486     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {
<span class="changed"> 487         HotSpotResolvedJavaMethodImpl method = null;</span>
<span class="changed"> 488         if (methodCache == null) {</span>
<span class="changed"> 489             methodCache = new HashMap&lt;&gt;(8);</span>
<span class="changed"> 490         } else {</span>
<span class="changed"> 491             method = methodCache.get(metaspaceMethod);</span>
 492         }
<span class="changed"> 493         if (method == null) {</span>
<span class="changed"> 494             method = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);</span>
<span class="changed"> 495             methodCache.put(metaspaceMethod, method);</span>
<span class="changed"> 496             context.add(method);</span>























 497         }
<span class="removed"> 498         return method;</span>
 499     }
 500 
 501     public int getVtableLength() {
 502         HotSpotVMConfig config = config();
 503         if (isInterface() || isArray()) {
 504             /* Everything has the core vtable of java.lang.Object */
 505             return config.baseVtableLength();
 506         }
 507         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 508         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + " " + config.vtableEntrySize;
 509         return result;
 510     }
 511 
<span class="changed"> 512     synchronized HotSpotResolvedJavaField createField(String fieldName, JavaType type, long offset, int rawFlags) {</span>
<span class="changed"> 513         HotSpotResolvedJavaField result = null;</span>
<span class="changed"> 514 </span>
<span class="changed"> 515         final int flags = rawFlags &amp; HotSpotModifiers.jvmFieldModifiers();</span>
<span class="changed"> 516 </span>
<span class="changed"> 517         final long id = offset + ((long) flags &lt;&lt; 32);</span>
<span class="changed"> 518 </span>
<span class="changed"> 519         // Must cache the fields, because the local load elimination only works if the</span>
<span class="changed"> 520         // objects from two field lookups are identical.</span>
<span class="changed"> 521         if (fieldCache == null) {</span>
<span class="changed"> 522             fieldCache = new HashMap&lt;&gt;(8);</span>
<span class="changed"> 523         } else {</span>
<span class="changed"> 524             result = fieldCache.get(id);</span>
<span class="changed"> 525         }</span>
<span class="changed"> 526 </span>
<span class="changed"> 527         if (result == null) {</span>
<span class="changed"> 528             result = new HotSpotResolvedJavaFieldImpl(this, fieldName, type, offset, rawFlags);</span>
<span class="changed"> 529             fieldCache.put(id, result);</span>
<span class="changed"> 530         } else {</span>
<span class="changed"> 531             assert result.getName().equals(fieldName);</span>
<span class="changed"> 532             /*</span>
<span class="changed"> 533              * Comparing the types directly is too strict, because the type in the cache could be</span>
<span class="changed"> 534              * resolved while the incoming type is unresolved. The name comparison is sufficient</span>
<span class="changed"> 535              * because the type will always be resolved in the context of the holder.</span>
<span class="changed"> 536              */</span>
<span class="changed"> 537             assert result.getType().getName().equals(type.getName());</span>
<span class="changed"> 538             assert result.offset() == offset;</span>
<span class="changed"> 539             assert result.getModifiers() == flags;</span>
<span class="changed"> 540         }</span>
<span class="changed"> 541 </span>
<span class="changed"> 542         return result;</span>
 543     }
 544 
 545     @Override
 546     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 547         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 548         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 549         /*
 550          * Sometimes the receiver type in the graph hasn't stabilized to a subtype of declared
 551          * holder, usually because of phis, so make sure that the type is related to the declared
 552          * type before using it for lookup. Unlinked types should also be ignored because we can't
 553          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 554          * a deopt instead since they can't really be used if they aren't linked yet.
 555          */
 556         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 557             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 558             if (result != null) {
 559                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 560             }
 561             return null;
 562         }
 563         /*
 564          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 565          * the correct method for the subtype.
 566          */
 567         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 568         if (resolvedMethod == null) {
 569             // The type isn't known to implement the method.
 570             return null;
 571         }
 572 
 573         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 574         if (result != null) {
 575             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 576         }
 577         return null;
 578     }
 579 




 580     /**
 581      * This class represents the field information for one field contained in the fields array of an
 582      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 583      */
<span class="changed"> 584     private class FieldInfo {</span>
 585         /**
 586          * Native pointer into the array of Java shorts.
 587          */
 588         private final long metaspaceData;
 589 
 590         /**
 591          * Creates a field info for the field in the fields array at index {@code index}.
 592          *
 593          * @param index index to the fields array
 594          */
 595         FieldInfo(int index) {
 596             HotSpotVMConfig config = config();
 597             // Get Klass::_fields
 598             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 599             assert config.fieldInfoFieldSlots == 6 : "revisit the field parsing code";
 600             int offset = config.fieldInfoFieldSlots * Short.BYTES * index;
 601             metaspaceData = metaspaceFields + config.arrayU2DataOffset + offset;
 602         }
 603 
 604         private int getAccessFlags() {

</pre><hr></hr><pre>
 649         }
 650 
 651         public JavaType getType() {
 652             String signature = getSignature();
 653             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 654         }
 655 
 656         private boolean isInternal() {
 657             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 658         }
 659 
 660         public boolean isStatic() {
 661             return Modifier.isStatic(getAccessFlags());
 662         }
 663 
 664         public boolean hasGenericSignature() {
 665             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 666         }
 667     }
 668 
<span class="removed"> 669     @SuppressFBWarnings(value = "SE_COMPARATOR_SHOULD_BE_SERIALIZABLE", justification = "comparator is only used transiently")</span>
<span class="removed"> 670     private static class OffsetComparator implements java.util.Comparator&lt;HotSpotResolvedJavaField&gt; {</span>
<span class="removed"> 671         @Override</span>
<span class="removed"> 672         public int compare(HotSpotResolvedJavaField o1, HotSpotResolvedJavaField o2) {</span>
<span class="removed"> 673             return o1.offset() - o2.offset();</span>
<span class="removed"> 674         }</span>
<span class="removed"> 675     }</span>
<span class="removed"> 676 </span>
 677     @Override
 678     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 679         if (instanceFields == null) {
 680             if (isArray() || isInterface()) {
<span class="changed"> 681                 instanceFields = new HotSpotResolvedJavaField[0];</span>
 682             } else {
<span class="changed"> 683                 final int fieldCount = getFieldCount();</span>
<span class="changed"> 684                 ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);</span>
<span class="changed"> 685 </span>
<span class="changed"> 686                 for (int i = 0; i &lt; fieldCount; i++) {</span>
<span class="changed"> 687                     FieldInfo field = new FieldInfo(i);</span>
<span class="changed"> 688 </span>
<span class="changed"> 689                     // We are only interested in instance fields.</span>
<span class="changed"> 690                     if (!field.isStatic()) {</span>
<span class="changed"> 691                         HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());</span>
<span class="changed"> 692                         fieldsArray.add(resolvedJavaField);</span>
<span class="changed"> 693                     }</span>
<span class="changed"> 694                 }</span>
<span class="changed"> 695 </span>
<span class="changed"> 696                 fieldsArray.sort(new OffsetComparator());</span>
<span class="changed"> 697 </span>
<span class="changed"> 698                 HotSpotResolvedJavaField[] myFields = fieldsArray.toArray(new HotSpotResolvedJavaField[0]);</span>
<span class="changed"> 699 </span>
<span class="changed"> 700                 if (mirror() != Object.class) {</span>
<span class="changed"> 701                     HotSpotResolvedJavaField[] superFields = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);</span>
<span class="changed"> 702                     HotSpotResolvedJavaField[] fields = Arrays.copyOf(superFields, superFields.length + myFields.length);</span>
<span class="changed"> 703                     System.arraycopy(myFields, 0, fields, superFields.length, myFields.length);</span>
<span class="changed"> 704                     instanceFields = fields;</span>
 705                 } else {
<span class="changed"> 706                     assert myFields.length == 0 : "java.lang.Object has fields!";</span>
<span class="changed"> 707                     instanceFields = myFields;</span>
<span class="changed"> 708                 }</span>
<span class="changed"> 709 </span>
 710             }
 711         }
<span class="removed"> 712         if (!includeSuperclasses) {</span>
<span class="removed"> 713             int myFieldsStart = 0;</span>
<span class="removed"> 714             while (myFieldsStart &lt; instanceFields.length &amp;&amp; !instanceFields[myFieldsStart].getDeclaringClass().equals(this)) {</span>
<span class="removed"> 715                 myFieldsStart++;</span>
<span class="removed"> 716             }</span>
<span class="removed"> 717             if (myFieldsStart == 0) {</span>
<span class="removed"> 718                 return instanceFields;</span>
<span class="removed"> 719             }</span>
<span class="removed"> 720             if (myFieldsStart == instanceFields.length) {</span>
<span class="removed"> 721                 return new HotSpotResolvedJavaField[0];</span>
<span class="removed"> 722             }</span>
<span class="removed"> 723             return Arrays.copyOfRange(instanceFields, myFieldsStart, instanceFields.length);</span>
<span class="removed"> 724         }</span>
 725         return instanceFields;
 726     }
 727 
 728     @Override
 729     public ResolvedJavaField[] getStaticFields() {
 730         if (isArray()) {
 731             return new HotSpotResolvedJavaField[0];
 732         } else {
<span class="changed"> 733             final int fieldCount = getFieldCount();</span>
<span class="changed"> 734             ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);</span>
<span class="changed"> 735 </span>
<span class="changed"> 736             for (int i = 0; i &lt; fieldCount; i++) {</span>
<span class="changed"> 737                 FieldInfo field = new FieldInfo(i);</span>
<span class="changed"> 738 </span>
<span class="changed"> 739                 // We are only interested in static fields.</span>
<span class="changed"> 740                 if (field.isStatic()) {</span>
<span class="changed"> 741                     HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());</span>
<span class="changed"> 742                     fieldsArray.add(resolvedJavaField);</span>
<span class="changed"> 743                 }</span>
<span class="changed"> 744             }</span>
<span class="changed"> 745 </span>
<span class="changed"> 746             fieldsArray.sort(new OffsetComparator());</span>
<span class="changed"> 747             return fieldsArray.toArray(new HotSpotResolvedJavaField[fieldsArray.size()]);</span>
 748         }
 749     }
 750 
 751     /**
<span class="changed"> 752      * Returns the actual field count of this class's internal {@code InstanceKlass::_fields} array</span>
<span class="changed"> 753      * by walking the array and discounting the generic signature slots at the end of the array.</span>
 754      *
<span class="changed"> 755      * &lt;p&gt;</span>
<span class="changed"> 756      * See {@code FieldStreamBase::init_generic_signature_start_slot}</span>
 757      */
<span class="changed"> 758     private int getFieldCount() {</span>
 759         HotSpotVMConfig config = config();
 760         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 761         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
<span class="changed"> 762         int fieldCount = 0;</span>
<span class="changed"> 763 </span>
<span class="changed"> 764         for (int i = 0, index = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {</span>
 765             FieldInfo field = new FieldInfo(index);
 766             if (field.hasGenericSignature()) {
 767                 metaspaceFieldsLength--;
 768             }
<span class="changed"> 769             fieldCount++;</span>
































 770         }
<span class="changed"> 771         return fieldCount;</span>

 772     }
 773 
 774     @Override
 775     public Class&lt;?&gt; mirror() {
 776         return javaClass;
 777     }
 778 
 779     @Override
 780     public String getSourceFileName() {
 781         HotSpotVMConfig config = config();
 782         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
 783         if (sourceFileNameIndex == 0) {
 784             return null;
 785         }
 786         return getConstantPool().lookupUtf8(sourceFileNameIndex);
 787     }
 788 
 789     @Override
 790     public Annotation[] getAnnotations() {
 791         return mirror().getAnnotations();

</pre><hr></hr>
</pre></td><td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotConstantPool.isSignaturePolymorphicHolder;
  28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  29 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  30 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  31 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  32 
  33 import java.lang.annotation.Annotation;
  34 import java.lang.reflect.Array;
  35 import java.lang.reflect.Constructor;
  36 import java.lang.reflect.Method;
  37 import java.lang.reflect.Modifier;
  38 import java.nio.ByteOrder;


  39 import java.util.HashMap;
  40 
  41 import jdk.vm.ci.common.JVMCIError;
  42 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  43 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  45 import jdk.vm.ci.meta.Assumptions.LeafType;
  46 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  47 import jdk.vm.ci.meta.Constant;
  48 import jdk.vm.ci.meta.JavaConstant;
  49 import jdk.vm.ci.meta.JavaKind;
  50 import jdk.vm.ci.meta.JavaType;
  51 import jdk.vm.ci.meta.ResolvedJavaField;
  52 import jdk.vm.ci.meta.ResolvedJavaMethod;
  53 import jdk.vm.ci.meta.ResolvedJavaType;
  54 
  55 /**
  56  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.
  57  */
  58 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceWrapperObject {
  59 
<span class="new">  60     private static final HotSpotResolvedJavaField[] NO_FIELDS = new HotSpotResolvedJavaField[0];</span>
<span class="new">  61     private static final int METHOD_CACHE_ARRAY_CAPACITY = 8;</span>
<span class="new">  62 </span>
  63     /**
  64      * The Java class this type represents.
  65      */
  66     private final Class&lt;?&gt; javaClass;
<span class="changed">  67     private HotSpotResolvedJavaMethodImpl[] methodCacheArray;</span>
<span class="changed">  68     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCacheHashMap;</span>
  69     private HotSpotResolvedJavaField[] instanceFields;
  70     private HotSpotResolvedObjectTypeImpl[] interfaces;
  71     private HotSpotConstantPool constantPool;
  72     final HotSpotJVMCIMetaAccessContext context;
  73     private HotSpotResolvedObjectType arrayOfType;
  74 
  75     /**
  76      * Gets the JVMCI mirror for a {@link Class} object.
  77      *
  78      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}
  79      */
  80     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {
  81         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);
  82     }
  83 
  84     /**
  85      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the
  86      * underlying Klass*, it is used instead of the raw Klass*.
  87      *
  88      * Called from the VM.

</pre><hr></hr><pre>
 239                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 240             }
 241         }
 242     }
 243 
 244     private AssumptionResult&lt;ResolvedJavaType&gt; concreteSubtype(HotSpotResolvedObjectTypeImpl type) {
 245         if (type.isLeaf()) {
 246             return new AssumptionResult&lt;&gt;(type, new ConcreteSubtype(this, type));
 247         } else {
 248             return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 249         }
 250     }
 251 
 252     /**
 253      * Returns if type {@code type} is a leaf class. This is the case if the
 254      * {@code Klass::_subklass} field of the underlying class is zero.
 255      *
 256      * @return true if the type is a leaf class
 257      */
 258     private boolean isLeafClass() {
<span class="changed"> 259         return UNSAFE.getLong(this.getMetaspaceKlass() + config().subklassOffset) == 0;</span>
 260     }
 261 
 262     /**
 263      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 264      * type {@code type}.
 265      *
 266      * @return value of the subklass field as metaspace klass pointer
 267      */
 268     private HotSpotResolvedObjectTypeImpl getSubklass() {
 269         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 270     }
 271 
 272     @Override
 273     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 274         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();
 275         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);
 276     }
 277 
 278     @Override
 279     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {

</pre><hr></hr><pre>
 468         // See: Klass::layout_helper_size_in_bytes
 469         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 470 
 471         // See: Klass::layout_helper_needs_slow_path
 472         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 473 
 474         return needsSlowPath ? -size : size;
 475     }
 476 
 477     public int layoutHelper() {
 478         HotSpotVMConfig config = config();
 479         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 480     }
 481 
 482     @Override
 483     public long getFingerprint() {
 484         return compilerToVM().getFingerprint(getMetaspaceKlass());
 485     }
 486 
 487     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {
<span class="changed"> 488         // Maintain cache as array.</span>
<span class="changed"> 489         if (methodCacheArray == null) {</span>
<span class="changed"> 490             methodCacheArray = new HotSpotResolvedJavaMethodImpl[METHOD_CACHE_ARRAY_CAPACITY];</span>


 491         }
<span class="changed"> 492 </span>
<span class="changed"> 493         int i = 0;</span>
<span class="changed"> 494         for (; i &lt; methodCacheArray.length; ++i) {</span>
<span class="changed"> 495             HotSpotResolvedJavaMethodImpl curMethod = methodCacheArray[i];</span>
<span class="changed"> 496             if (curMethod == null) {</span>
<span class="changed"> 497                 HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);</span>
<span class="changed"> 498                 methodCacheArray[i] = newMethod;</span>
<span class="changed"> 499                 context.add(newMethod);</span>
<span class="changed"> 500                 return newMethod;</span>
<span class="changed"> 501             } else if (curMethod.getMetaspacePointer() == metaspaceMethod) {</span>
<span class="changed"> 502                 return curMethod;</span>
<span class="changed"> 503             }</span>
<span class="changed"> 504         }</span>
<span class="changed"> 505 </span>
<span class="changed"> 506         // Fall-back to hash table.</span>
<span class="changed"> 507         if (methodCacheHashMap == null) {</span>
<span class="changed"> 508             methodCacheHashMap = new HashMap&lt;&gt;();</span>
<span class="changed"> 509         }</span>
<span class="changed"> 510 </span>
<span class="changed"> 511         HotSpotResolvedJavaMethodImpl lookupResult = methodCacheHashMap.get(metaspaceMethod);</span>
<span class="changed"> 512         if (lookupResult == null) {</span>
<span class="changed"> 513             HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);</span>
<span class="changed"> 514             methodCacheHashMap.put(metaspaceMethod, newMethod);</span>
<span class="changed"> 515             context.add(lookupResult);</span>
<span class="changed"> 516             return newMethod;</span>
<span class="changed"> 517         } else {</span>
<span class="changed"> 518             return lookupResult;</span>
 519         }

 520     }
 521 
 522     public int getVtableLength() {
 523         HotSpotVMConfig config = config();
 524         if (isInterface() || isArray()) {
 525             /* Everything has the core vtable of java.lang.Object */
 526             return config.baseVtableLength();
 527         }
 528         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 529         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + " " + config.vtableEntrySize;
 530         return result;
 531     }
 532 
<span class="changed"> 533     synchronized HotSpotResolvedJavaField createField(JavaType type, long offset, int rawFlags, int index) {</span>
<span class="changed"> 534         return new HotSpotResolvedJavaFieldImpl(this, type, offset, rawFlags, index);</span>





























 535     }
 536 
 537     @Override
 538     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 539         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 540         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 541         /*
 542          * Sometimes the receiver type in the graph hasn't stabilized to a subtype of declared
 543          * holder, usually because of phis, so make sure that the type is related to the declared
 544          * type before using it for lookup. Unlinked types should also be ignored because we can't
 545          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 546          * a deopt instead since they can't really be used if they aren't linked yet.
 547          */
 548         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 549             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 550             if (result != null) {
 551                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 552             }
 553             return null;
 554         }
 555         /*
 556          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 557          * the correct method for the subtype.
 558          */
 559         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 560         if (resolvedMethod == null) {
 561             // The type isn't known to implement the method.
 562             return null;
 563         }
 564 
 565         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 566         if (result != null) {
 567             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 568         }
 569         return null;
 570     }
 571 
<span class="new"> 572     FieldInfo createFieldInfo(int index) {</span>
<span class="new"> 573         return new FieldInfo(index);</span>
<span class="new"> 574     }</span>
<span class="new"> 575 </span>
 576     /**
 577      * This class represents the field information for one field contained in the fields array of an
 578      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 579      */
<span class="changed"> 580     class FieldInfo {</span>
 581         /**
 582          * Native pointer into the array of Java shorts.
 583          */
 584         private final long metaspaceData;
 585 
 586         /**
 587          * Creates a field info for the field in the fields array at index {@code index}.
 588          *
 589          * @param index index to the fields array
 590          */
 591         FieldInfo(int index) {
 592             HotSpotVMConfig config = config();
 593             // Get Klass::_fields
 594             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 595             assert config.fieldInfoFieldSlots == 6 : "revisit the field parsing code";
 596             int offset = config.fieldInfoFieldSlots * Short.BYTES * index;
 597             metaspaceData = metaspaceFields + config.arrayU2DataOffset + offset;
 598         }
 599 
 600         private int getAccessFlags() {

</pre><hr></hr><pre>
 645         }
 646 
 647         public JavaType getType() {
 648             String signature = getSignature();
 649             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 650         }
 651 
 652         private boolean isInternal() {
 653             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 654         }
 655 
 656         public boolean isStatic() {
 657             return Modifier.isStatic(getAccessFlags());
 658         }
 659 
 660         public boolean hasGenericSignature() {
 661             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 662         }
 663     }
 664 








 665     @Override
 666     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 667         if (instanceFields == null) {
 668             if (isArray() || isInterface()) {
<span class="changed"> 669                 instanceFields = NO_FIELDS;</span>
 670             } else {
<span class="changed"> 671                 HotSpotResolvedJavaField[] prepend = NO_FIELDS;</span>
<span class="changed"> 672                 if (getSuperclass() != null) {</span>
<span class="changed"> 673                     prepend = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);</span>
<span class="changed"> 674                 }</span>
<span class="changed"> 675                 instanceFields = getFields(false, prepend);</span>
<span class="changed"> 676             }</span>
<span class="changed"> 677         }</span>
<span class="changed"> 678         if (!includeSuperclasses &amp;&amp; getSuperclass() != null) {</span>
<span class="changed"> 679             int superClassFieldCount = getSuperclass().getInstanceFields(true).length;</span>
<span class="changed"> 680             if (superClassFieldCount == instanceFields.length) {</span>
<span class="changed"> 681                 // This class does not have any instance fields of its own.</span>
<span class="changed"> 682                 return NO_FIELDS;</span>
<span class="changed"> 683             } else if (superClassFieldCount != 0) {</span>
<span class="changed"> 684                 HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[instanceFields.length - superClassFieldCount];</span>
<span class="changed"> 685                 System.arraycopy(instanceFields, superClassFieldCount, result, 0, result.length);</span>
<span class="changed"> 686                 return result;</span>






 687             } else {
<span class="changed"> 688                 // The super classes of this class do not have any instance fields.</span>



 689             }
 690         }













 691         return instanceFields;
 692     }
 693 
 694     @Override
 695     public ResolvedJavaField[] getStaticFields() {
 696         if (isArray()) {
 697             return new HotSpotResolvedJavaField[0];
 698         } else {
<span class="changed"> 699             return getFields(true, NO_FIELDS);</span>














 700         }
 701     }
 702 
 703     /**
<span class="changed"> 704      * Gets the instance or static fields of this class.</span>

 705      *
<span class="changed"> 706      * @param retrieveStaticFields specifies whether to return instance or static fields</span>
<span class="changed"> 707      * @param prepend an array to be prepended to the returned result</span>
 708      */
<span class="changed"> 709     private HotSpotResolvedJavaField[] getFields(boolean retrieveStaticFields, HotSpotResolvedJavaField[] prepend) {</span>
 710         HotSpotVMConfig config = config();
 711         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 712         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
<span class="changed"> 713         int resultCount = 0;</span>
<span class="changed"> 714         int index = 0;</span>
<span class="changed"> 715         for (int i = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {</span>
 716             FieldInfo field = new FieldInfo(index);
 717             if (field.hasGenericSignature()) {
 718                 metaspaceFieldsLength--;
 719             }
<span class="changed"> 720 </span>
<span class="changed"> 721             if (field.isStatic() == retrieveStaticFields) {</span>
<span class="changed"> 722                 resultCount++;</span>
<span class="changed"> 723             }</span>
<span class="changed"> 724         }</span>
<span class="changed"> 725 </span>
<span class="changed"> 726         if (resultCount == 0) {</span>
<span class="changed"> 727             return prepend;</span>
<span class="changed"> 728         }</span>
<span class="changed"> 729 </span>
<span class="changed"> 730         int prependLength = prepend.length;</span>
<span class="changed"> 731         resultCount += prependLength;</span>
<span class="changed"> 732 </span>
<span class="changed"> 733         HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[resultCount];</span>
<span class="changed"> 734         if (prependLength != 0) {</span>
<span class="changed"> 735             System.arraycopy(prepend, 0, result, 0, prependLength);</span>
<span class="changed"> 736         }</span>
<span class="changed"> 737 </span>
<span class="changed"> 738         int resultIndex = prependLength;</span>
<span class="changed"> 739         for (int i = 0; i &lt; index; ++i) {</span>
<span class="changed"> 740             FieldInfo field = new FieldInfo(i);</span>
<span class="changed"> 741             if (field.isStatic() == retrieveStaticFields) {</span>
<span class="changed"> 742                 int offset = field.getOffset();</span>
<span class="changed"> 743                 HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);</span>
<span class="changed"> 744 </span>
<span class="changed"> 745                 // Make sure the result is sorted by offset.</span>
<span class="changed"> 746                 int j;</span>
<span class="changed"> 747                 for (j = resultIndex - 1; j &gt;= prependLength &amp;&amp; result[j].offset() &gt; offset; j--) {</span>
<span class="changed"> 748                     result[j + 1] = result[j];</span>
<span class="changed"> 749                 }</span>
<span class="changed"> 750                 result[j + 1] = resolvedJavaField;</span>
<span class="changed"> 751                 resultIndex++;</span>
<span class="changed"> 752             }</span>
 753         }
<span class="changed"> 754 </span>
<span class="changed"> 755         return result;</span>
 756     }
 757 
 758     @Override
 759     public Class&lt;?&gt; mirror() {
 760         return javaClass;
 761     }
 762 
 763     @Override
 764     public String getSourceFileName() {
 765         HotSpotVMConfig config = config();
 766         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
 767         if (sourceFileNameIndex == 0) {
 768             return null;
 769         }
 770         return getConstantPool().lookupUtf8(sourceFileNameIndex);
 771     }
 772 
 773     @Override
 774     public Annotation[] getAnnotations() {
 775         return mirror().getAnnotations();

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfig.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
