<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12604">12604</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8173912">8173912</a>: [JVMCI] fix memory overhead of JVMCI</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.graalvm.compiler.hotspot;
  24 
  25 import java.lang.reflect.Field;
  26 import java.lang.reflect.Modifier;
  27 
  28 import org.graalvm.compiler.api.replacements.Fold;
  29 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
  30 import org.graalvm.compiler.hotspot.nodes.GraalHotSpotVMConfigNode;
  31 
  32 import jdk.vm.ci.common.JVMCIError;
  33 import jdk.vm.ci.hotspot.HotSpotVMConfigAccess;
  34 import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
  35 
  36 /**
  37  * Used to access native configuration details.
  38  */
  39 public class GraalHotSpotVMConfig extends HotSpotVMConfigAccess {
  40 
  41     /**
  42      * Sentinel value to use for an {@linkplain InjectedParameter injected}
  43      * {@link GraalHotSpotVMConfig} parameter to a {@linkplain Fold foldable} method.
  44      */
  45     public static final GraalHotSpotVMConfig INJECTED_VMCONFIG = null;
  46 
  47     private final boolean isJDK8 = System.getProperty("java.specification.version").compareTo("1.9") &lt; 0;
  48     public final String osName = getHostOSName();
  49     public final String osArch = getHostArchitectureName();
  50     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
  51     public final boolean linuxOs = System.getProperty("os.name", "").startsWith("Linux");
  52 
  53     GraalHotSpotVMConfig(HotSpotVMConfigStore store) {
  54         super(store);
  55 
  56         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift, logMinObjAlignment());
  57         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift, logKlassAlignment);
  58 
  59         assert check();
  60     }
  61 
  62     /**
  63      * Gets the value of a static C++ field under two possible names. {@code name} is the preferred
  64      * name and will be checked first.
  65      *
  66      * @param name fully qualified name of the field
  67      * @param alternateName fully qualified alternate name of the field
  68      * @param type the boxed type to which the constant value will be converted
  69      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code "HeapWord*"})
  70      * @return the value of the requested field
  71      * @throws JVMCIError if the field is not static or not present
  72      */
  73     public &lt;T&gt; T getFieldValueWithAlternate(String name, String alternateName, Class&lt;T&gt; type, String cppType) {
  74         try {
  75             return getFieldValue(name, type, cppType);
  76         } catch (JVMCIError e) {
  77             try {
  78                 return getFieldValue(alternateName, type, cppType);
  79             } catch (JVMCIError e2) {
  80                 throw new JVMCIError("expected VM field not found: " + name + " or " + alternateName);
  81             }
  82         }
  83     }
  84 
  85     private final CompressEncoding oopEncoding;
  86     private final CompressEncoding klassEncoding;
  87 
  88     public CompressEncoding getOopEncoding() {
  89         return oopEncoding;
  90     }
  91 
  92     public CompressEncoding getKlassEncoding() {
  93         return klassEncoding;
  94     }
  95 
  96     /**
  97      * Gets the host operating system name.
  98      */
  99     private static String getHostOSName() {
 100         String osName = System.getProperty("os.name");
 101         switch (osName) {
 102             case "Linux":
 103                 osName = "linux";
 104                 break;
 105             case "SunOS":
 106                 osName = "solaris";
 107                 break;
 108             case "Mac OS X":
 109                 osName = "bsd";
 110                 break;
 111             default:
 112                 // Of course Windows is different...
 113                 if (osName.startsWith("Windows")) {
 114                     osName = "windows";
 115                 } else {
 116                     throw new JVMCIError("Unexpected OS name: " + osName);
 117                 }
 118         }
 119         return osName;
 120     }
 121 
 122     private static String getHostArchitectureName() {
 123         String arch = System.getProperty("os.arch");
 124         switch (arch) {
 125             case "x86_64":
 126                 arch = "amd64";
 127                 break;
 128             case "sparcv9":
 129                 arch = "sparc";
 130                 break;
 131         }
 132         return arch;
 133     }
 134 
 135     private final Integer intRequiredOnAMD64 = osArch.equals("amd64") ? null : 0;
 136     private final Integer intNotPresentInJDK8 = isJDK8 ? 0 : null;
 137     private final Long longNotPresentInJDK8 = isJDK8 ? 0L : null;
 138 
 139     public final boolean cAssertions = getConstant("ASSERT", Boolean.class);
 140 
 141     public final int codeEntryAlignment = getFlag("CodeEntryAlignment", Integer.class);
 142     public final boolean enableContended = getFlag("EnableContended", Boolean.class);
 143     public final boolean restrictContended = getFlag("RestrictContended", Boolean.class);
 144     public final int contendedPaddingWidth = getFlag("ContendedPaddingWidth", Integer.class);
 145     public final int fieldsAllocationStyle = getFlag("FieldsAllocationStyle", Integer.class);
 146     public final boolean compactFields = getFlag("CompactFields", Boolean.class);
 147     public final boolean verifyOops = getFlag("VerifyOops", Boolean.class);
 148     public final boolean ciTime = getFlag("CITime", Boolean.class);
 149     public final boolean ciTimeEach = getFlag("CITimeEach", Boolean.class);
 150     public final int compileTheWorldStartAt = getFlag("CompileTheWorldStartAt", Integer.class, 1);
 151     public final int compileTheWorldStopAt = getFlag("CompileTheWorldStopAt", Integer.class, Integer.MAX_VALUE);
 152     public final boolean dontCompileHugeMethods = getFlag("DontCompileHugeMethods", Boolean.class);
 153     public final int hugeMethodLimit = getFlag("HugeMethodLimit", Integer.class);
 154     public final boolean printInlining = getFlag("PrintInlining", Boolean.class);
 155     public final boolean inline = getFlag("Inline", Boolean.class);
 156     public final boolean useFastLocking = getFlag("JVMCIUseFastLocking", Boolean.class);
 157     public final boolean forceUnreachable = getFlag("ForceUnreachable", Boolean.class);
 158     public final int codeSegmentSize = getFlag("CodeCacheSegmentSize", Integer.class);
 159     public final boolean foldStableValues = getFlag("FoldStableValues", Boolean.class);
 160 
 161     public final boolean useTLAB = getFlag("UseTLAB", Boolean.class);
 162     public final boolean useBiasedLocking = getFlag("UseBiasedLocking", Boolean.class);
 163     public final boolean usePopCountInstruction = getFlag("UsePopCountInstruction", Boolean.class);
 164     public final boolean useAESIntrinsics = getFlag("UseAESIntrinsics", Boolean.class);
 165     public final boolean useCRC32Intrinsics = getFlag("UseCRC32Intrinsics", Boolean.class);
 166 
 167     private final boolean useMultiplyToLenIntrinsic = getFlag("UseMultiplyToLenIntrinsic", Boolean.class);
 168     private final boolean useSHA1Intrinsics = getFlag("UseSHA1Intrinsics", Boolean.class);
 169     private final boolean useSHA256Intrinsics = getFlag("UseSHA256Intrinsics", Boolean.class);
 170     private final boolean useSHA512Intrinsics = getFlag("UseSHA512Intrinsics", Boolean.class);
 171     private final boolean useMontgomeryMultiplyIntrinsic = getFlag("UseMontgomeryMultiplyIntrinsic", Boolean.class, false);
 172     private final boolean useMontgomerySquareIntrinsic = getFlag("UseMontgomerySquareIntrinsic", Boolean.class, false);
 173     private final boolean useMulAddIntrinsic = getFlag("UseMulAddIntrinsic", Boolean.class, false);
 174     private final boolean useSquareToLenIntrinsic = getFlag("UseSquareToLenIntrinsic", Boolean.class, false);
 175 
 176     /*
 177      * These are methods because in some JDKs the flags are visible but the stubs themselves haven't
 178      * been exported so we have to check both if the flag is on and if we have the stub.
 179      */
 180     public boolean useMultiplyToLenIntrinsic() {
 181         return useMultiplyToLenIntrinsic &amp;&amp; multiplyToLen != 0;
 182     }
 183 
 184     public boolean useSHA1Intrinsics() {
 185         return useSHA1Intrinsics &amp;&amp; sha1ImplCompress != 0;
 186     }
 187 
 188     public boolean useSHA256Intrinsics() {
 189         return useSHA256Intrinsics &amp;&amp; sha256ImplCompress != 0;
 190     }
 191 
 192     public boolean useSHA512Intrinsics() {
 193         return useSHA512Intrinsics &amp;&amp; sha512ImplCompress != 0;
 194     }
 195 
 196     public boolean useMontgomeryMultiplyIntrinsic() {
 197         return useMontgomeryMultiplyIntrinsic &amp;&amp; montgomeryMultiply != 0;
 198     }
 199 
 200     public boolean useMontgomerySquareIntrinsic() {
 201         return useMontgomerySquareIntrinsic &amp;&amp; montgomerySquare != 0;
 202     }
 203 
 204     public boolean useMulAddIntrinsic() {
 205         return useMulAddIntrinsic &amp;&amp; mulAdd != 0;
 206     }
 207 
 208     public boolean useSquareToLenIntrinsic() {
 209         return useSquareToLenIntrinsic &amp;&amp; squareToLen != 0;
 210     }
 211 
 212     public final boolean useG1GC = getFlag("UseG1GC", Boolean.class);
 213     public final boolean useCMSGC = getFlag("UseConcMarkSweepGC", Boolean.class);
 214 
 215     public final int allocatePrefetchStyle = getFlag("AllocatePrefetchStyle", Integer.class);
 216     public final int allocatePrefetchInstr = getFlag("AllocatePrefetchInstr", Integer.class);
 217     public final int allocatePrefetchLines = getFlag("AllocatePrefetchLines", Integer.class);
 218     public final int allocateInstancePrefetchLines = getFlag("AllocateInstancePrefetchLines", Integer.class);
 219     public final int allocatePrefetchStepSize = getFlag("AllocatePrefetchStepSize", Integer.class);
 220     public final int allocatePrefetchDistance = getFlag("AllocatePrefetchDistance", Integer.class);
 221 
 222     private final long universeCollectedHeap = getFieldValue("CompilerToVM::Data::Universe_collectedHeap", Long.class, "CollectedHeap*");
 223     private final int collectedHeapTotalCollectionsOffset = getFieldOffset("CollectedHeap::_total_collections", Integer.class, "unsigned int");
 224 
 225     public long gcTotalCollectionsAddress() {
 226         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
 227     }
 228 
 229     public final boolean useDeferredInitBarriers = getFlag("ReduceInitialCardMarks", Boolean.class);
 230 
 231     // Compressed Oops related values.
 232     public final boolean useCompressedOops = getFlag("UseCompressedOops", Boolean.class);
 233     public final boolean useCompressedClassPointers = getFlag("UseCompressedClassPointers", Boolean.class);
 234 
 235     public final long narrowOopBase = getFieldValue("CompilerToVM::Data::Universe_narrow_oop_base", Long.class, "address");
 236     public final int narrowOopShift = getFieldValue("CompilerToVM::Data::Universe_narrow_oop_shift", Integer.class, "int");
 237     public final int objectAlignment = getFlag("ObjectAlignmentInBytes", Integer.class);
 238 
 239     public final int minObjAlignment() {
 240         return objectAlignment / heapWordSize;
 241     }
 242 
 243     public final int logMinObjAlignment() {
 244         return (int) (Math.log(objectAlignment) / Math.log(2));
 245     }
 246 
<a name="1" id="anc1"></a><span class="changed"> 247     public final int narrowKlassSize = getTypeSize("narrowKlass");</span>
 248     public final long narrowKlassBase = getFieldValue("CompilerToVM::Data::Universe_narrow_klass_base", Long.class, "address");
 249     public final int narrowKlassShift = getFieldValue("CompilerToVM::Data::Universe_narrow_klass_shift", Integer.class, "int");
 250     public final int logKlassAlignment = getConstant("LogKlassAlignmentInBytes", Integer.class);
 251 
 252     public final int stackShadowPages = getFlag("StackShadowPages", Integer.class);
 253     public final int stackReservedPages = getFlag("StackReservedPages", Integer.class, 0);
 254     public final boolean useStackBanging = getFlag("UseStackBanging", Boolean.class);
 255     public final int stackBias = getConstant("STACK_BIAS", Integer.class);
 256     public final int vmPageSize = getFieldValue("CompilerToVM::Data::vm_page_size", Integer.class, "int");
 257 
 258     public final int markOffset = getFieldOffset("oopDesc::_mark", Integer.class, "markOop");
 259     public final int hubOffset = getFieldOffset("oopDesc::_metadata._klass", Integer.class, "Klass*");
 260 
 261     public final int prototypeMarkWordOffset = getFieldOffset("Klass::_prototype_header", Integer.class, "markOop");
 262     public final int subklassOffset = getFieldOffset("Klass::_subklass", Integer.class, "Klass*");
 263     public final int nextSiblingOffset = getFieldOffset("Klass::_next_sibling", Integer.class, "Klass*");
 264     public final int superCheckOffsetOffset = getFieldOffset("Klass::_super_check_offset", Integer.class, "juint");
 265     public final int secondarySuperCacheOffset = getFieldOffset("Klass::_secondary_super_cache", Integer.class, "Klass*");
 266     public final int secondarySupersOffset = getFieldOffset("Klass::_secondary_supers", Integer.class, "Array&lt;Klass*&gt;*");
 267 
 268     public final int classMirrorOffset = getFieldOffset("Klass::_java_mirror", Integer.class, "oop");
 269 
 270     public final int klassSuperKlassOffset = getFieldOffset("Klass::_super", Integer.class, "Klass*");
 271     public final int klassModifierFlagsOffset = getFieldOffset("Klass::_modifier_flags", Integer.class, "jint");
 272     public final int klassAccessFlagsOffset = getFieldOffset("Klass::_access_flags", Integer.class, "AccessFlags");
 273     public final int klassLayoutHelperOffset = getFieldOffset("Klass::_layout_helper", Integer.class, "jint");
 274 
 275     public final int klassLayoutHelperNeutralValue = getConstant("Klass::_lh_neutral_value", Integer.class);
 276     public final int layoutHelperLog2ElementSizeShift = getConstant("Klass::_lh_log2_element_size_shift", Integer.class);
 277     public final int layoutHelperLog2ElementSizeMask = getConstant("Klass::_lh_log2_element_size_mask", Integer.class);
 278     public final int layoutHelperElementTypeShift = getConstant("Klass::_lh_element_type_shift", Integer.class);
 279     public final int layoutHelperElementTypeMask = getConstant("Klass::_lh_element_type_mask", Integer.class);
 280     public final int layoutHelperHeaderSizeShift = getConstant("Klass::_lh_header_size_shift", Integer.class);
 281     public final int layoutHelperHeaderSizeMask = getConstant("Klass::_lh_header_size_mask", Integer.class);
 282     public final int layoutHelperArrayTagShift = getConstant("Klass::_lh_array_tag_shift", Integer.class);
 283     public final int layoutHelperArrayTagTypeValue = getConstant("Klass::_lh_array_tag_type_value", Integer.class);
 284     public final int layoutHelperArrayTagObjectValue = getConstant("Klass::_lh_array_tag_obj_value", Integer.class);
 285 
 286     /**
 287      * This filters out the bit that differentiates a type array from an object array.
 288      */
 289     public int layoutHelperElementTypePrimitiveInPlace() {
 290         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
 291     }
 292 
<a name="2" id="anc2"></a><span class="changed"> 293     public final int vtableEntrySize = getTypeSize("vtableEntry");</span>
 294     public final int vtableEntryMethodOffset = getFieldOffset("vtableEntry::_method", Integer.class, "Method*");
 295 
 296     public final int instanceKlassInitStateOffset = getFieldOffset("InstanceKlass::_init_state", Integer.class, "u1");
 297     public final int instanceKlassConstantsOffset = getFieldOffset("InstanceKlass::_constants", Integer.class, "ConstantPool*");
 298     public final int instanceKlassFieldsOffset = getFieldOffset("InstanceKlass::_fields", Integer.class, "Array&lt;u2&gt;*");
 299     public final int klassVtableStartOffset = getFieldValue("CompilerToVM::Data::Klass_vtable_start_offset", Integer.class, "int");
 300     public final int klassVtableLengthOffset = getFieldValue("CompilerToVM::Data::Klass_vtable_length_offset", Integer.class, "int");
 301 
 302     public final int instanceKlassStateLinked = getConstant("InstanceKlass::linked", Integer.class);
 303     public final int instanceKlassStateFullyInitialized = getConstant("InstanceKlass::fully_initialized", Integer.class);
 304 
<a name="3" id="anc3"></a><span class="changed"> 305     public final int arrayOopDescSize = getTypeSize("arrayOopDesc");</span>
 306 
 307     /**
 308      * The offset of the array length word in an array object's header.
 309      *
 310      * See {@code arrayOopDesc::length_offset_in_bytes()}.
 311      */
 312     public final int arrayOopDescLengthOffset() {
 313         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
 314     }
 315 
 316     public final int arrayU1LengthOffset = getFieldOffset("Array&lt;int&gt;::_length", Integer.class, "int");
 317     public final int arrayU1DataOffset = getFieldOffset("Array&lt;u1&gt;::_data", Integer.class);
 318     public final int arrayU2DataOffset = getFieldOffset("Array&lt;u2&gt;::_data", Integer.class);
 319     public final int metaspaceArrayLengthOffset = getFieldOffset("Array&lt;Klass*&gt;::_length", Integer.class, "int");
 320     public final int metaspaceArrayBaseOffset = getFieldOffset("Array&lt;Klass*&gt;::_data[0]", Integer.class, "Klass*");
 321 
 322     public final int arrayClassElementOffset = getFieldOffset("ObjArrayKlass::_element_klass", Integer.class, "Klass*");
 323 
 324     public final int fieldInfoAccessFlagsOffset = getConstant("FieldInfo::access_flags_offset", Integer.class);
 325     public final int fieldInfoNameIndexOffset = getConstant("FieldInfo::name_index_offset", Integer.class);
 326     public final int fieldInfoSignatureIndexOffset = getConstant("FieldInfo::signature_index_offset", Integer.class);
 327     public final int fieldInfoInitvalIndexOffset = getConstant("FieldInfo::initval_index_offset", Integer.class);
 328     public final int fieldInfoLowPackedOffset = getConstant("FieldInfo::low_packed_offset", Integer.class);
 329     public final int fieldInfoHighPackedOffset = getConstant("FieldInfo::high_packed_offset", Integer.class);
 330     public final int fieldInfoFieldSlots = getConstant("FieldInfo::field_slots", Integer.class);
 331 
 332     public final int fieldInfoTagSize = getConstant("FIELDINFO_TAG_SIZE", Integer.class);
 333 
 334     public final int jvmAccMonitorMatch = getConstant("JVM_ACC_MONITOR_MATCH", Integer.class);
 335     public final int jvmAccHasMonitorBytecodes = getConstant("JVM_ACC_HAS_MONITOR_BYTECODES", Integer.class);
 336     public final int jvmAccHasFinalizer = getConstant("JVM_ACC_HAS_FINALIZER", Integer.class);
 337     public final int jvmAccFieldInternal = getConstant("JVM_ACC_FIELD_INTERNAL", Integer.class);
 338     public final int jvmAccFieldStable = getConstant("JVM_ACC_FIELD_STABLE", Integer.class);
 339     public final int jvmAccFieldHasGenericSignature = getConstant("JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE", Integer.class);
 340     public final int jvmAccWrittenFlags = getConstant("JVM_ACC_WRITTEN_FLAGS", Integer.class);
 341     public final int jvmAccSynthetic = getConstant("JVM_ACC_SYNTHETIC", Integer.class);
 342 
 343     public final int threadTlabOffset = getFieldOffset("Thread::_tlab", Integer.class, "ThreadLocalAllocBuffer");
 344     public final int javaThreadAnchorOffset = getFieldOffset("JavaThread::_anchor", Integer.class, "JavaFrameAnchor");
 345     public final int threadObjectOffset = getFieldOffset("JavaThread::_threadObj", Integer.class, "oop");
 346     public final int osThreadOffset = getFieldOffset("JavaThread::_osthread", Integer.class, "OSThread*");
 347     public final int javaThreadDirtyCardQueueOffset = getFieldOffset("JavaThread::_dirty_card_queue", Integer.class, "DirtyCardQueue");
 348     public final int threadIsMethodHandleReturnOffset = getFieldOffset("JavaThread::_is_method_handle_return", Integer.class, "int");
 349     public final int javaThreadSatbMarkQueueOffset = getFieldOffset("JavaThread::_satb_mark_queue", Integer.class);
 350     public final int threadObjectResultOffset = getFieldOffset("JavaThread::_vm_result", Integer.class, "oop");
 351     public final int jvmciCountersThreadOffset = getFieldOffset("JavaThread::_jvmci_counters", Integer.class, "jlong*");
 352     public final int javaThreadReservedStackActivationOffset = getFieldOffset("JavaThread::_reserved_stack_activation", Integer.class, "address", intNotPresentInJDK8);
 353 
 354     /**
 355      * An invalid value for {@link #rtldDefault}.
 356      */
 357     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
 358 
 359     /**
 360      * Address of the library lookup routine. The C signature of this routine is:
 361      *
 362      * &lt;pre&gt;
 363      *     void* (const char *filename, char *ebuf, int ebuflen)
 364      * &lt;/pre&gt;
 365      */
 366     public final long dllLoad = getAddress("os::dll_load");
 367 
 368     /**
 369      * Address of the library lookup routine. The C signature of this routine is:
 370      *
 371      * &lt;pre&gt;
 372      *     void* (void* handle, const char* name)
 373      * &lt;/pre&gt;
 374      */
 375     public final long dllLookup = getAddress("os::dll_lookup");
 376 
 377     /**
 378      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
 379      * return the first occurrence of the desired symbol using the default library search order. If
 380      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
 381      * the current platform.
 382      */
 383     public final long rtldDefault = getAddress("RTLD_DEFAULT", osName.equals("bsd") || osName.equals("linux") ? null : INVALID_RTLD_DEFAULT_HANDLE);
 384 
 385     /**
 386      * This field is used to pass exception objects into and out of the runtime system during
 387      * exception handling for compiled code.
 388      */
 389     public final int threadExceptionOopOffset = getFieldOffset("JavaThread::_exception_oop", Integer.class, "oop");
 390     public final int threadExceptionPcOffset = getFieldOffset("JavaThread::_exception_pc", Integer.class, "address");
 391     public final int pendingExceptionOffset = getFieldOffset("ThreadShadow::_pending_exception", Integer.class, "oop");
 392 
 393     public final int pendingDeoptimizationOffset = getFieldOffset("JavaThread::_pending_deoptimization", Integer.class, "int");
 394     public final int pendingFailedSpeculationOffset = getFieldOffset("JavaThread::_pending_failed_speculation", Integer.class, "oop");
 395     public final int pendingTransferToInterpreterOffset = getFieldOffset("JavaThread::_pending_transfer_to_interpreter", Integer.class, "bool");
 396 
 397     private final int javaFrameAnchorLastJavaSpOffset = getFieldOffset("JavaFrameAnchor::_last_Java_sp", Integer.class, "intptr_t*");
 398     private final int javaFrameAnchorLastJavaPcOffset = getFieldOffset("JavaFrameAnchor::_last_Java_pc", Integer.class, "address");
 399 
 400     public int threadLastJavaSpOffset() {
 401         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
 402     }
 403 
 404     public int threadLastJavaPcOffset() {
 405         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
 406     }
 407 
 408     public int threadLastJavaFpOffset() {
 409         assert osArch.equals("aarch64") || osArch.equals("amd64");
 410         return javaThreadAnchorOffset + getFieldOffset("JavaFrameAnchor::_last_Java_fp", Integer.class, "intptr_t*");
 411     }
 412 
 413     public int threadJavaFrameAnchorFlagsOffset() {
 414         assert osArch.equals("sparc");
 415         return javaThreadAnchorOffset + getFieldOffset("JavaFrameAnchor::_flags", Integer.class, "int");
 416     }
 417 
 418     public final int runtimeCallStackSize = getConstant("frame::arg_reg_save_area_bytes", Integer.class, intRequiredOnAMD64);
 419     public final int frameInterpreterFrameSenderSpOffset = getConstant("frame::interpreter_frame_sender_sp_offset", Integer.class, intRequiredOnAMD64);
 420     public final int frameInterpreterFrameLastSpOffset = getConstant("frame::interpreter_frame_last_sp_offset", Integer.class, intRequiredOnAMD64);
 421 
 422     private final int dirtyCardQueueBufferOffset = isJDK8 ? getFieldOffset("PtrQueue::_buf", Integer.class, "void**") : getConstant("dirtyCardQueueBufferOffset", Integer.class);
 423     private final int dirtyCardQueueIndexOffset = isJDK8 ? getFieldOffset("PtrQueue::_index", Integer.class, "size_t") : getConstant("dirtyCardQueueIndexOffset", Integer.class);
 424 
 425     private final int satbMarkQueueBufferOffset = getConstant("satbMarkQueueBufferOffset", Integer.class, intNotPresentInJDK8);
 426     private final int satbMarkQueueIndexOffset = getConstant("satbMarkQueueIndexOffset", Integer.class, intNotPresentInJDK8);
 427     private final int satbMarkQueueActiveOffset = isJDK8 ? getFieldOffset("PtrQueue::_active", Integer.class, "bool") : getConstant("satbMarkQueueActiveOffset", Integer.class, intNotPresentInJDK8);
 428 
 429     public final int osThreadInterruptedOffset = getFieldOffset("OSThread::_interrupted", Integer.class, "jint");
 430 
 431     public final long markOopDescHashShift = getConstant("markOopDesc::hash_shift", Long.class);
 432 
 433     public final int biasedLockMaskInPlace = getConstant("markOopDesc::biased_lock_mask_in_place", Integer.class);
 434     public final int ageMaskInPlace = getConstant("markOopDesc::age_mask_in_place", Integer.class);
 435     public final int epochMaskInPlace = getConstant("markOopDesc::epoch_mask_in_place", Integer.class);
 436     public final long markOopDescHashMask = getConstant("markOopDesc::hash_mask", Long.class);
 437     public final long markOopDescHashMaskInPlace = getConstant("markOopDesc::hash_mask_in_place", Long.class);
 438 
 439     public final int unlockedMask = getConstant("markOopDesc::unlocked_value", Integer.class);
 440     public final int biasedLockPattern = getConstant("markOopDesc::biased_lock_pattern", Integer.class);
 441 
 442     public final int markWordNoHashInPlace = getConstant("markOopDesc::no_hash_in_place", Integer.class);
 443     public final int markWordNoLockInPlace = getConstant("markOopDesc::no_lock_in_place", Integer.class);
 444 
 445     /**
 446      * See {@code markOopDesc::prototype()}.
 447      */
 448     public long arrayPrototypeMarkWord() {
 449         return markWordNoHashInPlace | markWordNoLockInPlace;
 450     }
 451 
 452     /**
 453      * See {@code markOopDesc::copy_set_hash()}.
 454      */
 455     public long tlabIntArrayMarkWord() {
 456         long tmp = arrayPrototypeMarkWord() &amp; (~markOopDescHashMaskInPlace);
 457         tmp |= ((0x2 &amp; markOopDescHashMask) &lt;&lt; markOopDescHashShift);
 458         return tmp;
 459     }
 460 
 461     /**
 462      * Mark word right shift to get identity hash code.
 463      */
 464     public final int identityHashCodeShift = getConstant("markOopDesc::hash_shift", Integer.class);
 465 
 466     /**
 467      * Identity hash code value when uninitialized.
 468      */
 469     public final int uninitializedIdentityHashCodeValue = getConstant("markOopDesc::no_hash", Integer.class);
 470 
 471     public final int methodAccessFlagsOffset = getFieldOffset("Method::_access_flags", Integer.class, "AccessFlags");
 472     public final int methodConstMethodOffset = getFieldOffset("Method::_constMethod", Integer.class, "ConstMethod*");
 473     public final int methodIntrinsicIdOffset = getFieldOffset("Method::_intrinsic_id", Integer.class, isJDK8 ? "u1" : "u2");
 474     public final int methodFlagsOffset = getFieldOffset("Method::_flags", Integer.class, isJDK8 ? "u1" : "u2");
 475     public final int methodVtableIndexOffset = getFieldOffset("Method::_vtable_index", Integer.class, "int");
 476 
 477     public final int methodCountersOffset = getFieldOffset("Method::_method_counters", Integer.class, "MethodCounters*");
 478     public final int methodDataOffset = getFieldOffset("Method::_method_data", Integer.class, "MethodData*");
 479     public final int methodCompiledEntryOffset = getFieldOffset("Method::_from_compiled_entry", Integer.class, "address");
 480     public final int methodCodeOffset = getFieldOffset("Method::_code", Integer.class, isJDK8 ? "nmethod*" : "CompiledMethod*");
 481 
 482     public final int methodFlagsCallerSensitive = getConstant("Method::_caller_sensitive", Integer.class);
 483     public final int methodFlagsForceInline = getConstant("Method::_force_inline", Integer.class);
 484     public final int methodFlagsDontInline = getConstant("Method::_dont_inline", Integer.class);
 485     public final int methodFlagsHidden = getConstant("Method::_hidden", Integer.class);
 486     public final int nonvirtualVtableIndex = getConstant("Method::nonvirtual_vtable_index", Integer.class);
 487     public final int invalidVtableIndex = getConstant("Method::invalid_vtable_index", Integer.class);
 488 
 489     public final int invocationCounterOffset = getFieldOffset("MethodCounters::_invocation_counter", Integer.class, "InvocationCounter");
 490     public final int backedgeCounterOffset = getFieldOffset("MethodCounters::_backedge_counter", Integer.class, "InvocationCounter");
 491     public final int invocationCounterIncrement = getConstant("InvocationCounter::count_increment", Integer.class, intNotPresentInJDK8);
 492     public final int invocationCounterShift = getConstant("InvocationCounter::count_shift", Integer.class, intNotPresentInJDK8);
 493 
 494     public final int nmethodEntryOffset = getFieldOffset("nmethod::_verified_entry_point",
 495                     Integer.class, "address");
 496     public final int compilationLevelFullOptimization = getConstant("CompLevel_full_optimization",
 497                     Integer.class);
 498 
<a name="4" id="anc4"></a><span class="changed"> 499     public final int constantPoolSize = getTypeSize("ConstantPool");</span>
 500     public final int constantPoolLengthOffset = getFieldOffset("ConstantPool::_length",
 501                     Integer.class, "int");
 502 
 503     public final int heapWordSize = getConstant("HeapWordSize", Integer.class);
 504 
 505     /**
 506      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
 507      * are allowed to look like (respectively) the high or low bits of a real oop.
 508      */
 509     public final long nonOopBits = getFieldValue("CompilerToVM::Data::Universe_non_oop_bits", Long.class, "void*");
 510 
 511     public final long verifyOopCounterAddress = getFieldAddress("StubRoutines::_verify_oop_count", "jint");
 512     public final long verifyOopMask = getFieldValue("CompilerToVM::Data::Universe_verify_oop_mask", Long.class, "uintptr_t");
 513     public final long verifyOopBits = getFieldValue("CompilerToVM::Data::Universe_verify_oop_bits", Long.class, "uintptr_t");
 514 
 515     public final int logOfHRGrainBytes = getFieldValue("HeapRegion::LogOfHRGrainBytes", Integer.class, "int");
 516 
 517     public final byte dirtyCardValue = isJDK8 ? getFieldValue("CompilerToVM::Data::dirty_card", Byte.class, "int") : getConstant("CardTableModRefBS::dirty_card", Byte.class);
 518     public final byte g1YoungCardValue = isJDK8 ? getFieldValue("CompilerToVM::Data::g1_young_card", Byte.class, "int") : getConstant("G1SATBCardTableModRefBS::g1_young_gen", Byte.class);
 519 
 520     public final long cardtableStartAddress = getFieldValue("CompilerToVM::Data::cardtable_start_address", Long.class, "jbyte*");
 521     public final int cardtableShift = getFieldValue("CompilerToVM::Data::cardtable_shift", Integer.class, "int");
 522 
 523     /**
 524      * This is the largest stack offset encodeable in an OopMapValue. Offsets larger than this will
 525      * throw an exception during code installation.
 526      */
 527     public final int maxOopMapStackOffset = getFieldValueWithAlternate("CompilerToVM::Data::_max_oop_map_stack_offset", "JVMCIRuntime::max_oop_map_stack_offset", Integer.class, "int");
 528 
 529     public final long safepointPollingAddress = getFieldValue("os::_polling_page", Long.class, "address");
 530 
 531     // G1 Collector Related Values.
 532 
 533     public int g1CardQueueIndexOffset() {
 534         return javaThreadDirtyCardQueueOffset + dirtyCardQueueIndexOffset;
 535     }
 536 
 537     public int g1CardQueueBufferOffset() {
 538         return javaThreadDirtyCardQueueOffset + dirtyCardQueueBufferOffset;
 539     }
 540 
 541     public int g1SATBQueueMarkingOffset() {
 542         return javaThreadSatbMarkQueueOffset + satbMarkQueueActiveOffset;
 543     }
 544 
 545     public int g1SATBQueueIndexOffset() {
 546         return javaThreadSatbMarkQueueOffset + (isJDK8 ? dirtyCardQueueIndexOffset : satbMarkQueueIndexOffset);
 547     }
 548 
 549     public int g1SATBQueueBufferOffset() {
 550         return javaThreadSatbMarkQueueOffset + (isJDK8 ? dirtyCardQueueBufferOffset : satbMarkQueueBufferOffset);
 551     }
 552 
 553     public final int klassOffset = getFieldValue("java_lang_Class::_klass_offset", Integer.class, "int");
 554     public final int arrayKlassOffset = getFieldValue("java_lang_Class::_array_klass_offset", Integer.class, "int");
 555 
<a name="5" id="anc5"></a><span class="changed"> 556     public final int basicLockSize = getTypeSize("BasicLock");</span>
 557     public final int basicLockDisplacedHeaderOffset = getFieldOffset("BasicLock::_displaced_header", Integer.class, "markOop");
 558 
 559     public final int threadAllocatedBytesOffset = getFieldOffset("Thread::_allocated_bytes", Integer.class, "jlong");
 560 
 561     public final int tlabRefillWasteIncrement = getFlag("TLABWasteIncrement", Integer.class);
 562 
 563     private final int threadLocalAllocBufferStartOffset = getFieldOffset("ThreadLocalAllocBuffer::_start", Integer.class, "HeapWord*");
 564     private final int threadLocalAllocBufferEndOffset = getFieldOffset("ThreadLocalAllocBuffer::_end", Integer.class, "HeapWord*");
 565     private final int threadLocalAllocBufferTopOffset = getFieldOffset("ThreadLocalAllocBuffer::_top", Integer.class, "HeapWord*");
 566     private final int threadLocalAllocBufferPfTopOffset = getFieldOffset("ThreadLocalAllocBuffer::_pf_top", Integer.class, "HeapWord*");
 567     private final int threadLocalAllocBufferSlowAllocationsOffset = getFieldOffset("ThreadLocalAllocBuffer::_slow_allocations", Integer.class, "unsigned");
 568     private final int threadLocalAllocBufferFastRefillWasteOffset = getFieldOffset("ThreadLocalAllocBuffer::_fast_refill_waste", Integer.class, "unsigned");
 569     private final int threadLocalAllocBufferNumberOfRefillsOffset = getFieldOffset("ThreadLocalAllocBuffer::_number_of_refills", Integer.class, "unsigned");
 570     private final int threadLocalAllocBufferRefillWasteLimitOffset = getFieldOffset("ThreadLocalAllocBuffer::_refill_waste_limit", Integer.class, "size_t");
 571     private final int threadLocalAllocBufferDesiredSizeOffset = getFieldOffset("ThreadLocalAllocBuffer::_desired_size", Integer.class, "size_t");
 572 
 573     public int tlabSlowAllocationsOffset() {
 574         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
 575     }
 576 
 577     public int tlabFastRefillWasteOffset() {
 578         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
 579     }
 580 
 581     public int tlabNumberOfRefillsOffset() {
 582         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
 583     }
 584 
 585     public int tlabRefillWasteLimitOffset() {
 586         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
 587     }
 588 
 589     public int threadTlabSizeOffset() {
 590         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
 591     }
 592 
 593     public int threadTlabStartOffset() {
 594         return threadTlabOffset + threadLocalAllocBufferStartOffset;
 595     }
 596 
 597     public int threadTlabEndOffset() {
 598         return threadTlabOffset + threadLocalAllocBufferEndOffset;
 599     }
 600 
 601     public int threadTlabTopOffset() {
 602         return threadTlabOffset + threadLocalAllocBufferTopOffset;
 603     }
 604 
 605     public int threadTlabPfTopOffset() {
 606         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
 607     }
 608 
 609     public final int tlabAlignmentReserve = getFieldValue("CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve", Integer.class, "size_t");
 610 
 611     public final boolean tlabStats = getFlag("TLABStats", Boolean.class);
 612 
 613     // FIXME This is only temporary until the GC code is changed.
 614     public final boolean inlineContiguousAllocationSupported = getFieldValue("CompilerToVM::Data::_supports_inline_contig_alloc", Boolean.class);
 615     public final long heapEndAddress = getFieldValue("CompilerToVM::Data::_heap_end_addr", Long.class, "HeapWord**");
 616     public final long heapTopAddress = getFieldValue("CompilerToVM::Data::_heap_top_addr", Long.class, isJDK8 ? "HeapWord**" : "HeapWord* volatile*");
 617 
 618     public final long inlineCacheMissStub = getFieldValue("CompilerToVM::Data::SharedRuntime_ic_miss_stub", Long.class, "address");
 619     public final long handleWrongMethodStub = getFieldValue("CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub", Long.class, "address");
 620 
 621     public final long handleDeoptStub = getFieldValue("CompilerToVM::Data::SharedRuntime_deopt_blob_unpack", Long.class, "address");
 622     public final long uncommonTrapStub = getFieldValue("CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap", Long.class, "address");
 623 
 624     public final long codeCacheLowBound = getFieldValue(isJDK8 ? "CompilerToVM::Data::CodeCache_low_bound" : "CodeCache::_low_bound", Long.class, "address");
 625     public final long codeCacheHighBound = getFieldValue(isJDK8 ? "CompilerToVM::Data::CodeCache_high_bound" : "CodeCache::_high_bound", Long.class, "address");
 626 
 627     public final long aescryptEncryptBlockStub = getFieldValue("StubRoutines::_aescrypt_encryptBlock", Long.class, "address");
 628     public final long aescryptDecryptBlockStub = getFieldValue("StubRoutines::_aescrypt_decryptBlock", Long.class, "address");
 629     public final long cipherBlockChainingEncryptAESCryptStub = getFieldValue("StubRoutines::_cipherBlockChaining_encryptAESCrypt", Long.class, "address");
 630     public final long cipherBlockChainingDecryptAESCryptStub = getFieldValue("StubRoutines::_cipherBlockChaining_decryptAESCrypt", Long.class, "address");
 631     public final long updateBytesCRC32Stub = getFieldValue("StubRoutines::_updateBytesCRC32", Long.class, "address");
 632     public final long crcTableAddress = getFieldValue("StubRoutines::_crc_table_adr", Long.class, "address");
 633 
 634     public final long sha1ImplCompress = getFieldValue("StubRoutines::_sha1_implCompress", Long.class, "address", 0L);
 635     public final long sha1ImplCompressMB = getFieldValue("StubRoutines::_sha1_implCompressMB", Long.class, "address", 0L);
 636     public final long sha256ImplCompress = getFieldValue("StubRoutines::_sha256_implCompress", Long.class, "address", 0L);
 637     public final long sha256ImplCompressMB = getFieldValue("StubRoutines::_sha256_implCompressMB", Long.class, "address", 0L);
 638     public final long sha512ImplCompress = getFieldValue("StubRoutines::_sha512_implCompress", Long.class, "address", 0L);
 639     public final long sha512ImplCompressMB = getFieldValue("StubRoutines::_sha512_implCompressMB", Long.class, "address", 0L);
 640     public final long multiplyToLen = getFieldValue("StubRoutines::_multiplyToLen", Long.class, "address", 0L);
 641 
 642     public final long counterModeAESCrypt = getFieldValue("StubRoutines::_counterMode_AESCrypt", Long.class, "address", 0L);
 643     public final long ghashProcessBlocks = getFieldValue("StubRoutines::_ghash_processBlocks", Long.class, "address", 0L);
 644     public final long crc32cTableTddr = getFieldValue("StubRoutines::_crc32c_table_addr", Long.class, "address", 0L);
 645     public final long updateBytesCRC32C = getFieldValue("StubRoutines::_updateBytesCRC32C", Long.class, "address", 0L);
 646     public final long updateBytesAdler32 = getFieldValue("StubRoutines::_updateBytesAdler32", Long.class, "address", 0L);
 647     public final long squareToLen = getFieldValue("StubRoutines::_squareToLen", Long.class, "address", 0L);
 648     public final long mulAdd = getFieldValue("StubRoutines::_mulAdd", Long.class, "address", 0L);
 649     public final long montgomeryMultiply = getFieldValue("StubRoutines::_montgomeryMultiply", Long.class, "address", 0L);
 650     public final long montgomerySquare = getFieldValue("StubRoutines::_montgomerySquare", Long.class, "address", 0L);
 651     public final long vectorizedMismatch = getFieldValue("StubRoutines::_vectorizedMismatch", Long.class, "address", 0L);
 652 
 653     public final long throwDelayedStackOverflowErrorEntry = getFieldValue("StubRoutines::_throw_delayed_StackOverflowError_entry", Long.class, "address", longNotPresentInJDK8);
 654 
 655     public final long jbyteArraycopy = getFieldValue("StubRoutines::_jbyte_arraycopy", Long.class, "address");
 656     public final long jshortArraycopy = getFieldValue("StubRoutines::_jshort_arraycopy", Long.class, "address");
 657     public final long jintArraycopy = getFieldValue("StubRoutines::_jint_arraycopy", Long.class, "address");
 658     public final long jlongArraycopy = getFieldValue("StubRoutines::_jlong_arraycopy", Long.class, "address");
 659     public final long oopArraycopy = getFieldValue("StubRoutines::_oop_arraycopy", Long.class, "address");
 660     public final long oopArraycopyUninit = getFieldValue("StubRoutines::_oop_arraycopy_uninit", Long.class, "address");
 661     public final long jbyteDisjointArraycopy = getFieldValue("StubRoutines::_jbyte_disjoint_arraycopy", Long.class, "address");
 662     public final long jshortDisjointArraycopy = getFieldValue("StubRoutines::_jshort_disjoint_arraycopy", Long.class, "address");
 663     public final long jintDisjointArraycopy = getFieldValue("StubRoutines::_jint_disjoint_arraycopy", Long.class, "address");
 664     public final long jlongDisjointArraycopy = getFieldValue("StubRoutines::_jlong_disjoint_arraycopy", Long.class, "address");
 665     public final long oopDisjointArraycopy = getFieldValue("StubRoutines::_oop_disjoint_arraycopy", Long.class, "address");
 666     public final long oopDisjointArraycopyUninit = getFieldValue("StubRoutines::_oop_disjoint_arraycopy_uninit", Long.class, "address");
 667     public final long jbyteAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jbyte_arraycopy", Long.class, "address");
 668     public final long jshortAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jshort_arraycopy", Long.class, "address");
 669     public final long jintAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jint_arraycopy", Long.class, "address");
 670     public final long jlongAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_jlong_arraycopy", Long.class, "address");
 671     public final long oopAlignedArraycopy = getFieldValue("StubRoutines::_arrayof_oop_arraycopy", Long.class, "address");
 672     public final long oopAlignedArraycopyUninit = getFieldValue("StubRoutines::_arrayof_oop_arraycopy_uninit", Long.class, "address");
 673     public final long jbyteAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jbyte_disjoint_arraycopy", Long.class, "address");
 674     public final long jshortAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jshort_disjoint_arraycopy", Long.class, "address");
 675     public final long jintAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jint_disjoint_arraycopy", Long.class, "address");
 676     public final long jlongAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_jlong_disjoint_arraycopy", Long.class, "address");
 677     public final long oopAlignedDisjointArraycopy = getFieldValue("StubRoutines::_arrayof_oop_disjoint_arraycopy", Long.class, "address");
 678     public final long oopAlignedDisjointArraycopyUninit = getFieldValue("StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit", Long.class, "address");
 679     public final long checkcastArraycopy = getFieldValue("StubRoutines::_checkcast_arraycopy", Long.class, "address");
 680     public final long checkcastArraycopyUninit = getFieldValue("StubRoutines::_checkcast_arraycopy_uninit", Long.class, "address");
 681     public final long unsafeArraycopy = getFieldValue("StubRoutines::_unsafe_arraycopy", Long.class, "address");
 682     public final long genericArraycopy = getFieldValue("StubRoutines::_generic_arraycopy", Long.class, "address");
 683 
 684     public final long newInstanceAddress = getAddress("JVMCIRuntime::new_instance");
 685     public final long newArrayAddress = getAddress("JVMCIRuntime::new_array");
 686     public final long newMultiArrayAddress = getAddress("JVMCIRuntime::new_multi_array");
 687     public final long dynamicNewArrayAddress = getAddress("JVMCIRuntime::dynamic_new_array");
 688     public final long dynamicNewInstanceAddress = getAddress("JVMCIRuntime::dynamic_new_instance");
 689 
 690     public final long threadIsInterruptedAddress = getAddress("JVMCIRuntime::thread_is_interrupted");
 691     public final long vmMessageAddress = getAddress("JVMCIRuntime::vm_message");
 692     public final long identityHashCodeAddress = getAddress("JVMCIRuntime::identity_hash_code");
 693     public final long exceptionHandlerForPcAddress = getAddress("JVMCIRuntime::exception_handler_for_pc");
 694     public final long monitorenterAddress = getAddress("JVMCIRuntime::monitorenter");
 695     public final long monitorexitAddress = getAddress("JVMCIRuntime::monitorexit");
 696     public final long throwAndPostJvmtiExceptionAddress = getAddress("JVMCIRuntime::throw_and_post_jvmti_exception");
 697     public final long throwKlassExternalNameExceptionAddress = getAddress("JVMCIRuntime::throw_klass_external_name_exception");
 698     public final long throwClassCastExceptionAddress = getAddress("JVMCIRuntime::throw_class_cast_exception");
 699     public final long logPrimitiveAddress = getAddress("JVMCIRuntime::log_primitive");
 700     public final long logObjectAddress = getAddress("JVMCIRuntime::log_object");
 701     public final long logPrintfAddress = getAddress("JVMCIRuntime::log_printf");
 702     public final long vmErrorAddress = getAddress("JVMCIRuntime::vm_error");
 703     public final long loadAndClearExceptionAddress = getAddress("JVMCIRuntime::load_and_clear_exception");
 704     public final long writeBarrierPreAddress = getAddress("JVMCIRuntime::write_barrier_pre");
 705     public final long writeBarrierPostAddress = getAddress("JVMCIRuntime::write_barrier_post");
 706     public final long validateObject = getAddress("JVMCIRuntime::validate_object");
 707 
 708     public final long testDeoptimizeCallInt = getAddress("JVMCIRuntime::test_deoptimize_call_int");
 709 
 710     public final long registerFinalizerAddress = getAddress("SharedRuntime::register_finalizer");
 711     public final long exceptionHandlerForReturnAddressAddress = getAddress("SharedRuntime::exception_handler_for_return_address");
 712     public final long osrMigrationEndAddress = getAddress("SharedRuntime::OSR_migration_end");
 713     public final long enableStackReservedZoneAddress = getAddress("SharedRuntime::enable_stack_reserved_zone", longNotPresentInJDK8);
 714 
 715     public final long javaTimeMillisAddress = getAddress("os::javaTimeMillis");
 716     public final long javaTimeNanosAddress = getAddress("os::javaTimeNanos");
 717     public final long arithmeticSinAddress = getFieldValue("CompilerToVM::Data::dsin", Long.class, "address");
 718     public final long arithmeticCosAddress = getFieldValue("CompilerToVM::Data::dcos", Long.class, "address");
 719     public final long arithmeticTanAddress = getFieldValue("CompilerToVM::Data::dtan", Long.class, "address");
 720     public final long arithmeticExpAddress = getFieldValue("CompilerToVM::Data::dexp", Long.class, "address");
 721     public final long arithmeticLogAddress = getFieldValue("CompilerToVM::Data::dlog", Long.class, "address");
 722     public final long arithmeticLog10Address = getFieldValue("CompilerToVM::Data::dlog10", Long.class, "address");
 723     public final long arithmeticPowAddress = getFieldValue("CompilerToVM::Data::dpow", Long.class, "address");
 724 
 725     public final long fremAddress = getAddress("SharedRuntime::frem");
 726     public final long dremAddress = getAddress("SharedRuntime::drem");
 727 
 728     public final int jvmciCountersSize = getFlag("JVMCICounterSize", Integer.class);
 729 
 730     public final long deoptimizationFetchUnrollInfo = getAddress("Deoptimization::fetch_unroll_info");
 731     public final long deoptimizationUncommonTrap = getAddress("Deoptimization::uncommon_trap");
 732     public final long deoptimizationUnpackFrames = getAddress("Deoptimization::unpack_frames");
 733 
 734     public final int deoptimizationUnpackDeopt = getConstant("Deoptimization::Unpack_deopt", Integer.class);
 735     public final int deoptimizationUnpackException = getConstant("Deoptimization::Unpack_exception", Integer.class);
 736     public final int deoptimizationUnpackUncommonTrap = getConstant("Deoptimization::Unpack_uncommon_trap", Integer.class);
 737     public final int deoptimizationUnpackReexecute = getConstant("Deoptimization::Unpack_reexecute", Integer.class);
 738 
 739     public final int deoptimizationUnrollBlockSizeOfDeoptimizedFrameOffset = getFieldOffset("Deoptimization::UnrollBlock::_size_of_deoptimized_frame", Integer.class, "int");
 740     public final int deoptimizationUnrollBlockCallerAdjustmentOffset = getFieldOffset("Deoptimization::UnrollBlock::_caller_adjustment", Integer.class, "int");
 741     public final int deoptimizationUnrollBlockNumberOfFramesOffset = getFieldOffset("Deoptimization::UnrollBlock::_number_of_frames", Integer.class, "int");
 742     public final int deoptimizationUnrollBlockTotalFrameSizesOffset = getFieldOffset("Deoptimization::UnrollBlock::_total_frame_sizes", Integer.class, "int");
 743     public final int deoptimizationUnrollBlockUnpackKindOffset = getFieldOffset("Deoptimization::UnrollBlock::_unpack_kind", Integer.class, "int");
 744     public final int deoptimizationUnrollBlockFrameSizesOffset = getFieldOffset("Deoptimization::UnrollBlock::_frame_sizes", Integer.class, "intptr_t*");
 745     public final int deoptimizationUnrollBlockFramePcsOffset = getFieldOffset("Deoptimization::UnrollBlock::_frame_pcs", Integer.class, "address*");
 746     public final int deoptimizationUnrollBlockInitialInfoOffset = getFieldOffset("Deoptimization::UnrollBlock::_initial_info", Integer.class, "intptr_t");
 747 
 748     // Checkstyle: stop
 749     public final int MARKID_VERIFIED_ENTRY = getConstant("CodeInstaller::VERIFIED_ENTRY", Integer.class);
 750     public final int MARKID_UNVERIFIED_ENTRY = getConstant("CodeInstaller::UNVERIFIED_ENTRY", Integer.class);
 751     public final int MARKID_OSR_ENTRY = getConstant("CodeInstaller::OSR_ENTRY", Integer.class);
 752     public final int MARKID_EXCEPTION_HANDLER_ENTRY = getConstant("CodeInstaller::EXCEPTION_HANDLER_ENTRY", Integer.class);
 753     public final int MARKID_DEOPT_HANDLER_ENTRY = getConstant("CodeInstaller::DEOPT_HANDLER_ENTRY", Integer.class);
 754     public final int MARKID_INVOKEINTERFACE = getConstant("CodeInstaller::INVOKEINTERFACE", Integer.class);
 755     public final int MARKID_INVOKEVIRTUAL = getConstant("CodeInstaller::INVOKEVIRTUAL", Integer.class);
 756     public final int MARKID_INVOKESTATIC = getConstant("CodeInstaller::INVOKESTATIC", Integer.class);
 757     public final int MARKID_INVOKESPECIAL = getConstant("CodeInstaller::INVOKESPECIAL", Integer.class);
 758     public final int MARKID_INLINE_INVOKE = getConstant("CodeInstaller::INLINE_INVOKE", Integer.class);
 759     public final int MARKID_POLL_NEAR = getConstant("CodeInstaller::POLL_NEAR", Integer.class);
 760     public final int MARKID_POLL_RETURN_NEAR = getConstant("CodeInstaller::POLL_RETURN_NEAR", Integer.class);
 761     public final int MARKID_POLL_FAR = getConstant("CodeInstaller::POLL_FAR", Integer.class);
 762     public final int MARKID_POLL_RETURN_FAR = getConstant("CodeInstaller::POLL_RETURN_FAR", Integer.class);
 763     public final int MARKID_CARD_TABLE_SHIFT = getConstant("CodeInstaller::CARD_TABLE_SHIFT", Integer.class);
 764     public final int MARKID_CARD_TABLE_ADDRESS = getConstant("CodeInstaller::CARD_TABLE_ADDRESS", Integer.class);
 765     public final int MARKID_INVOKE_INVALID = getConstant("CodeInstaller::INVOKE_INVALID", Integer.class);
 766 
 767     /**
 768      * The following constants are given default values here since they are missing in the native
 769      * JVMCI-8 code but are still required for {@link GraalHotSpotVMConfigNode#canonical} to work in
 770      * a JDK8 environment.
 771      */
 772     public final int MARKID_HEAP_TOP_ADDRESS = getConstant("CodeInstaller::HEAP_TOP_ADDRESS", Integer.class, 17);
 773     public final int MARKID_HEAP_END_ADDRESS = getConstant("CodeInstaller::HEAP_END_ADDRESS", Integer.class, 18);
 774     public final int MARKID_NARROW_KLASS_BASE_ADDRESS = getConstant("CodeInstaller::NARROW_KLASS_BASE_ADDRESS", Integer.class, 19);
 775     public final int MARKID_NARROW_OOP_BASE_ADDRESS = getConstant("CodeInstaller::NARROW_OOP_BASE_ADDRESS", Integer.class, 20);
 776     public final int MARKID_CRC_TABLE_ADDRESS = getConstant("CodeInstaller::CRC_TABLE_ADDRESS", Integer.class, 21);
 777     public final int MARKID_LOG_OF_HEAP_REGION_GRAIN_BYTES = getConstant("CodeInstaller::LOG_OF_HEAP_REGION_GRAIN_BYTES", Integer.class, 22);
 778     public final int MARKID_INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED = getConstant("CodeInstaller::INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED", Integer.class, 23);
 779 
 780     // Checkstyle: resume
 781 
 782     protected boolean check() {
 783         for (Field f : getClass().getDeclaredFields()) {
 784             int modifiers = f.getModifiers();
 785             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
 786                 assert Modifier.isFinal(modifiers) : "field should be final: " + f;
 787             }
 788         }
 789 
 790         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
 791         return true;
 792     }
 793 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="6" type="hidden" /></form></body></html>
