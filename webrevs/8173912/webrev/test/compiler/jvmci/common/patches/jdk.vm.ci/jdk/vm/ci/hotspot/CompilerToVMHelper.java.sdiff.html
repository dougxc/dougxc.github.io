<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff test/compiler/jvmci/common/patches/jdk.vm.ci/jdk/vm/ci/hotspot </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../src/share/vm/jvmci/vmStructs_jvmci.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../test/compiler/jvmci/compilerToVM/ConstantPoolTestCase.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>test/compiler/jvmci/common/patches/jdk.vm.ci/jdk/vm/ci/hotspot/CompilerToVMHelper.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12604">12604</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8173912">8173912</a>: [JVMCI] fix memory overhead of JVMCI</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  31 import java.lang.reflect.Executable;
  32 
  33 /**
  34  * A simple "proxy" class to get test access to CompilerToVM package-private methods
  35  */
  36 public class CompilerToVMHelper {
  37     public static final CompilerToVM CTVM = new CompilerToVM();
  38 
  39     public static byte[] getBytecode(HotSpotResolvedJavaMethod method) {
  40         return CTVM.getBytecode((HotSpotResolvedJavaMethodImpl)method);
  41     }
  42 
  43     public static int getExceptionTableLength(HotSpotResolvedJavaMethod method) {
  44         return CTVM.getExceptionTableLength((HotSpotResolvedJavaMethodImpl)method);
  45     }
  46 
  47     public static long getExceptionTableStart(HotSpotResolvedJavaMethod method) {
  48         return CTVM.getExceptionTableStart((HotSpotResolvedJavaMethodImpl)method);
  49     }
  50 




  51     public static boolean isCompilable(HotSpotResolvedJavaMethod method) {
  52         return CTVM.isCompilable((HotSpotResolvedJavaMethodImpl)method);
  53     }
  54 
  55     public static boolean hasNeverInlineDirective(HotSpotResolvedJavaMethod method) {
  56         return CTVM.hasNeverInlineDirective((HotSpotResolvedJavaMethodImpl)method);
  57     }
  58 
  59     public static boolean shouldInlineMethod(HotSpotResolvedJavaMethod method) {
  60         return CTVM.shouldInlineMethod((HotSpotResolvedJavaMethodImpl)method);
  61     }
  62 
  63     public static HotSpotResolvedJavaMethod findUniqueConcreteMethod(
  64             HotSpotResolvedObjectType actualHolderType,
  65             HotSpotResolvedJavaMethod method) {
  66         return CTVM.findUniqueConcreteMethod((HotSpotResolvedObjectTypeImpl) actualHolderType, (HotSpotResolvedJavaMethodImpl)method);
  67     }
  68 
  69     public static HotSpotResolvedObjectType getImplementor(HotSpotResolvedObjectType type) {
  70         return CTVM.getImplementor((HotSpotResolvedObjectTypeImpl) type);

</pre><hr></hr><pre>
 111             ConstantPool constantPool, int cpi, byte opcode) {
 112         return CTVM.lookupMethodInPool((HotSpotConstantPool) constantPool, cpi, opcode);
 113     }
 114 
 115     public static void resolveInvokeDynamicInPool(
 116             ConstantPool constantPool, int cpi) {
 117         CTVM.resolveInvokeDynamicInPool((HotSpotConstantPool) constantPool, cpi);
 118     }
 119 
 120     public static void resolveInvokeHandleInPool(
 121             ConstantPool constantPool, int cpi) {
 122         CTVM.resolveInvokeHandleInPool((HotSpotConstantPool) constantPool, cpi);
 123     }
 124 
 125     public static HotSpotResolvedObjectType resolveTypeInPool(
 126             ConstantPool constantPool, int cpi) {
 127         return CTVM.resolveTypeInPool((HotSpotConstantPool) constantPool, cpi);
 128     }
 129 
 130     public static HotSpotResolvedObjectType resolveFieldInPool(
<span class="changed"> 131             ConstantPool constantPool, int cpi, ResolvedJavaMethod method, byte opcode, long[] info) {</span>
 132         return CTVM.resolveFieldInPool((HotSpotConstantPool) constantPool, cpi, (HotSpotResolvedJavaMethodImpl) method, opcode, info);
 133     }
 134 
 135     public static int constantPoolRemapInstructionOperandFromCache(
 136             ConstantPool constantPool, int cpci) {
 137         return CTVM.constantPoolRemapInstructionOperandFromCache((HotSpotConstantPool) constantPool, cpci);
 138     }
 139 
 140     public static Object lookupAppendixInPool(
 141             ConstantPool constantPool, int cpi) {
 142         return CTVM.lookupAppendixInPool((HotSpotConstantPool) constantPool, cpi);
 143     }
 144 
 145     public static int installCode(TargetDescription target,
 146             HotSpotCompiledCode compiledCode, InstalledCode code, HotSpotSpeculationLog speculationLog) {
 147         return CTVM.installCode(target, compiledCode, code, speculationLog);
 148     }
 149 
 150     public static int getMetadata(TargetDescription target,
 151             HotSpotCompiledCode compiledCode, HotSpotMetaData metaData) {

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
  31 import java.lang.reflect.Executable;
  32 
  33 /**
  34  * A simple "proxy" class to get test access to CompilerToVM package-private methods
  35  */
  36 public class CompilerToVMHelper {
  37     public static final CompilerToVM CTVM = new CompilerToVM();
  38 
  39     public static byte[] getBytecode(HotSpotResolvedJavaMethod method) {
  40         return CTVM.getBytecode((HotSpotResolvedJavaMethodImpl)method);
  41     }
  42 
  43     public static int getExceptionTableLength(HotSpotResolvedJavaMethod method) {
  44         return CTVM.getExceptionTableLength((HotSpotResolvedJavaMethodImpl)method);
  45     }
  46 
  47     public static long getExceptionTableStart(HotSpotResolvedJavaMethod method) {
  48         return CTVM.getExceptionTableStart((HotSpotResolvedJavaMethodImpl)method);
  49     }
  50 
<span class="new">  51     public static Object getFlagValue(String name) {</span>
<span class="new">  52         return CTVM.getFlagValue(name);</span>
<span class="new">  53     }</span>
<span class="new">  54 </span>
  55     public static boolean isCompilable(HotSpotResolvedJavaMethod method) {
  56         return CTVM.isCompilable((HotSpotResolvedJavaMethodImpl)method);
  57     }
  58 
  59     public static boolean hasNeverInlineDirective(HotSpotResolvedJavaMethod method) {
  60         return CTVM.hasNeverInlineDirective((HotSpotResolvedJavaMethodImpl)method);
  61     }
  62 
  63     public static boolean shouldInlineMethod(HotSpotResolvedJavaMethod method) {
  64         return CTVM.shouldInlineMethod((HotSpotResolvedJavaMethodImpl)method);
  65     }
  66 
  67     public static HotSpotResolvedJavaMethod findUniqueConcreteMethod(
  68             HotSpotResolvedObjectType actualHolderType,
  69             HotSpotResolvedJavaMethod method) {
  70         return CTVM.findUniqueConcreteMethod((HotSpotResolvedObjectTypeImpl) actualHolderType, (HotSpotResolvedJavaMethodImpl)method);
  71     }
  72 
  73     public static HotSpotResolvedObjectType getImplementor(HotSpotResolvedObjectType type) {
  74         return CTVM.getImplementor((HotSpotResolvedObjectTypeImpl) type);

</pre><hr></hr><pre>
 115             ConstantPool constantPool, int cpi, byte opcode) {
 116         return CTVM.lookupMethodInPool((HotSpotConstantPool) constantPool, cpi, opcode);
 117     }
 118 
 119     public static void resolveInvokeDynamicInPool(
 120             ConstantPool constantPool, int cpi) {
 121         CTVM.resolveInvokeDynamicInPool((HotSpotConstantPool) constantPool, cpi);
 122     }
 123 
 124     public static void resolveInvokeHandleInPool(
 125             ConstantPool constantPool, int cpi) {
 126         CTVM.resolveInvokeHandleInPool((HotSpotConstantPool) constantPool, cpi);
 127     }
 128 
 129     public static HotSpotResolvedObjectType resolveTypeInPool(
 130             ConstantPool constantPool, int cpi) {
 131         return CTVM.resolveTypeInPool((HotSpotConstantPool) constantPool, cpi);
 132     }
 133 
 134     public static HotSpotResolvedObjectType resolveFieldInPool(
<span class="changed"> 135             ConstantPool constantPool, int cpi, ResolvedJavaMethod method, byte opcode, int[] info) {</span>
 136         return CTVM.resolveFieldInPool((HotSpotConstantPool) constantPool, cpi, (HotSpotResolvedJavaMethodImpl) method, opcode, info);
 137     }
 138 
 139     public static int constantPoolRemapInstructionOperandFromCache(
 140             ConstantPool constantPool, int cpci) {
 141         return CTVM.constantPoolRemapInstructionOperandFromCache((HotSpotConstantPool) constantPool, cpci);
 142     }
 143 
 144     public static Object lookupAppendixInPool(
 145             ConstantPool constantPool, int cpi) {
 146         return CTVM.lookupAppendixInPool((HotSpotConstantPool) constantPool, cpi);
 147     }
 148 
 149     public static int installCode(TargetDescription target,
 150             HotSpotCompiledCode compiledCode, InstalledCode code, HotSpotSpeculationLog speculationLog) {
 151         return CTVM.installCode(target, compiledCode, code, speculationLog);
 152     }
 153 
 154     public static int getMetadata(TargetDescription target,
 155             HotSpotCompiledCode compiledCode, HotSpotMetaData metaData) {

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../src/share/vm/jvmci/vmStructs_jvmci.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../test/compiler/jvmci/compilerToVM/ConstantPoolTestCase.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
