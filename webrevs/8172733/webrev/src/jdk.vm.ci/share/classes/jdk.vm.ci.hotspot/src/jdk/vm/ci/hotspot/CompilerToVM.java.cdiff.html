<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Cdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java</title>
</head>
<body id="SUNWwebrev">
<center>&lt prev <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethod.java.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre></pre>
        <pre>
<hr /><span class="oldmarker">*** 98,116 ****</span>
       *         {@code getExceptionTableLength(method) == 0})
       */
      native long getExceptionTableStart(HotSpotResolvedJavaMethodImpl method);
  
      /**
<span class="changed">!      * Determines if {@code method} can be inlined. A method may not be inlinable for a number of</span>
<span class="changed">!      * reasons such as:</span>
<span class="changed">!      * &lt;ul&gt;</span>
<span class="changed">!      * &lt;li&gt;a CompileOracle directive may prevent inlining or compilation of methods&lt;/li&gt;</span>
<span class="changed">!      * &lt;li&gt;the method may have a bytecode breakpoint set&lt;/li&gt;</span>
<span class="changed">!      * &lt;li&gt;the method may have other bytecode features that require special handling by the VM&lt;/li&gt;</span>
<span class="changed">!      * &lt;/ul&gt;</span>
       */
<span class="changed">!     native boolean canInlineMethod(HotSpotResolvedJavaMethodImpl method);</span>
  
      /**
       * Determines if {@code method} should be inlined at any cost. This could be because:
       * &lt;ul&gt;
       * &lt;li&gt;a CompileOracle directive may forces inlining of this methods&lt;/li&gt;
<span class="newmarker">--- 98,120 ----</span>
       *         {@code getExceptionTableLength(method) == 0})
       */
      native long getExceptionTableStart(HotSpotResolvedJavaMethodImpl method);
  
      /**
<span class="changed">!      * Determines whether {@code method} is currently compilable by the JVMCI compiler being used by</span>
<span class="changed">!      * the VM. This can return false if JVMCI compilation failed earlier for {@code method}, a</span>
<span class="changed">!      * breakpoint is currently set in {@code method} or {@code method} contains other bytecode</span>
<span class="changed">!      * features that require special handling by the VM.</span>
<span class="changed">!      */</span>
<span class="changed">!     native boolean isCompilable(HotSpotResolvedJavaMethodImpl method);</span>
<span class="changed">! </span>
<span class="changed">!     /**</span>
<span class="changed">!      * Determines if {@code method} is targeted by a VM directive (e.g.,</span>
<span class="changed">!      * {@code -XX:CompileCommand=dontinline,&lt;pattern&gt;}) or annotation (e.g.,</span>
<span class="changed">!      * {@code jdk.internal.vm.annotation.DontInline}) that specifies it should not be inlined.</span>
       */
<span class="changed">!     native boolean hasNeverInlineDirective(HotSpotResolvedJavaMethodImpl method);</span>
  
      /**
       * Determines if {@code method} should be inlined at any cost. This could be because:
       * &lt;ul&gt;
       * &lt;li&gt;a CompileOracle directive may forces inlining of this methods&lt;/li&gt;
</pre>
<center>&lt prev <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethod.java.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

