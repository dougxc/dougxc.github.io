<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot </title>
</head><body id="SUNWwebrev">
<center>&lt prev <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethod.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  83 
  84     /**
  85      * Gets the address of the first entry in {@code method}'s exception handler table.
  86      *
  87      * Each entry is a native object described by these fields:
  88      *
  89      * &lt;ul&gt;
  90      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementSize}&lt;/li&gt;
  91      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementStartPcOffset}&lt;/li&gt;
  92      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementEndPcOffset}&lt;/li&gt;
  93      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementHandlerPcOffset}&lt;/li&gt;
  94      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementCatchTypeIndexOffset}
  95      * &lt;/ul&gt;
  96      *
  97      * @return 0 if {@code method} has no exception handlers (i.e.
  98      *         {@code getExceptionTableLength(method) == 0})
  99      */
 100     native long getExceptionTableStart(HotSpotResolvedJavaMethodImpl method);
 101 
 102     /**
<span class="changed"> 103      * Determines if {@code method} can be inlined. A method may not be inlinable for a number of</span>
<span class="changed"> 104      * reasons such as:</span>
<span class="changed"> 105      * &lt;ul&gt;</span>
<span class="changed"> 106      * &lt;li&gt;a CompileOracle directive may prevent inlining or compilation of methods&lt;/li&gt;</span>
<span class="changed"> 107      * &lt;li&gt;the method may have a bytecode breakpoint set&lt;/li&gt;</span>
<span class="changed"> 108      * &lt;li&gt;the method may have other bytecode features that require special handling by the VM&lt;/li&gt;</span>
<span class="changed"> 109      * &lt;/ul&gt;</span>




 110      */
<span class="changed"> 111     native boolean canInlineMethod(HotSpotResolvedJavaMethodImpl method);</span>
 112 
 113     /**
 114      * Determines if {@code method} should be inlined at any cost. This could be because:
 115      * &lt;ul&gt;
 116      * &lt;li&gt;a CompileOracle directive may forces inlining of this methods&lt;/li&gt;
 117      * &lt;li&gt;an annotation forces inlining of this method&lt;/li&gt;
 118      * &lt;/ul&gt;
 119      */
 120     native boolean shouldInlineMethod(HotSpotResolvedJavaMethodImpl method);
 121 
 122     /**
 123      * Used to implement {@link ResolvedJavaType#findUniqueConcreteMethod(ResolvedJavaMethod)}.
 124      *
 125      * @param method the method on which to base the search
 126      * @param actualHolderType the best known type of receiver
 127      * @return the method result or 0 is there is no unique concrete method for {@code method}
 128      */
 129     native HotSpotResolvedJavaMethodImpl findUniqueConcreteMethod(HotSpotResolvedObjectTypeImpl actualHolderType, HotSpotResolvedJavaMethodImpl method);
 130 
 131     /**

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
  83 
  84     /**
  85      * Gets the address of the first entry in {@code method}'s exception handler table.
  86      *
  87      * Each entry is a native object described by these fields:
  88      *
  89      * &lt;ul&gt;
  90      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementSize}&lt;/li&gt;
  91      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementStartPcOffset}&lt;/li&gt;
  92      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementEndPcOffset}&lt;/li&gt;
  93      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementHandlerPcOffset}&lt;/li&gt;
  94      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementCatchTypeIndexOffset}
  95      * &lt;/ul&gt;
  96      *
  97      * @return 0 if {@code method} has no exception handlers (i.e.
  98      *         {@code getExceptionTableLength(method) == 0})
  99      */
 100     native long getExceptionTableStart(HotSpotResolvedJavaMethodImpl method);
 101 
 102     /**
<span class="changed"> 103      * Determines whether {@code method} is currently compilable by the JVMCI compiler being used by</span>
<span class="changed"> 104      * the VM. This can return false if JVMCI compilation failed earlier for {@code method}, a</span>
<span class="changed"> 105      * breakpoint is currently set in {@code method} or {@code method} contains other bytecode</span>
<span class="changed"> 106      * features that require special handling by the VM.</span>
<span class="changed"> 107      */</span>
<span class="changed"> 108     native boolean isCompilable(HotSpotResolvedJavaMethodImpl method);</span>
<span class="changed"> 109 </span>
<span class="changed"> 110     /**</span>
<span class="changed"> 111      * Determines if {@code method} is targeted by a VM directive (e.g.,</span>
<span class="changed"> 112      * {@code -XX:CompileCommand=dontinline,&lt;pattern&gt;}) or annotation (e.g.,</span>
<span class="changed"> 113      * {@code jdk.internal.vm.annotation.DontInline}) that specifies it should not be inlined.</span>
 114      */
<span class="changed"> 115     native boolean hasNeverInlineDirective(HotSpotResolvedJavaMethodImpl method);</span>
 116 
 117     /**
 118      * Determines if {@code method} should be inlined at any cost. This could be because:
 119      * &lt;ul&gt;
 120      * &lt;li&gt;a CompileOracle directive may forces inlining of this methods&lt;/li&gt;
 121      * &lt;li&gt;an annotation forces inlining of this method&lt;/li&gt;
 122      * &lt;/ul&gt;
 123      */
 124     native boolean shouldInlineMethod(HotSpotResolvedJavaMethodImpl method);
 125 
 126     /**
 127      * Used to implement {@link ResolvedJavaType#findUniqueConcreteMethod(ResolvedJavaMethod)}.
 128      *
 129      * @param method the method on which to base the search
 130      * @param actualHolderType the best known type of receiver
 131      * @return the method result or 0 is there is no unique concrete method for {@code method}
 132      */
 133     native HotSpotResolvedJavaMethodImpl findUniqueConcreteMethod(HotSpotResolvedObjectTypeImpl actualHolderType, HotSpotResolvedJavaMethodImpl method);
 134 
 135     /**

</pre><hr></hr>
</pre></td>
</tr></table>
<center>&lt prev <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethod.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
