<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  30 
  31 import java.lang.annotation.Annotation;
  32 import java.lang.reflect.Array;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.Method;
  35 import java.lang.reflect.Modifier;
  36 import java.net.URL;
  37 import java.nio.ByteOrder;
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.HashMap;
  41 
  42 import jdk.vm.ci.common.JVMCIError;
  43 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  45 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  46 import jdk.vm.ci.meta.Assumptions.LeafType;
  47 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  48 import jdk.vm.ci.meta.Constant;
  49 import jdk.vm.ci.meta.JavaConstant;
  50 import jdk.vm.ci.meta.JavaKind;
  51 import jdk.vm.ci.meta.JavaType;
  52 import jdk.vm.ci.meta.MetaUtil;
  53 import jdk.vm.ci.meta.ModifiersProvider;
  54 import jdk.vm.ci.meta.ResolvedJavaField;
  55 import jdk.vm.ci.meta.ResolvedJavaMethod;
  56 import jdk.vm.ci.meta.ResolvedJavaType;
  57 import jdk.vm.ci.meta.TrustedInterface;
  58 
  59 /**
  60  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.
  61  */
  62 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, HotSpotProxified, MetaspaceWrapperObject {
  63 
  64     /**
  65      * The Java class this type represents.
  66      */
  67     private final Class&lt;?&gt; javaClass;
  68     private HashMap&lt;Long, HotSpotResolvedJavaField&gt; fieldCache;
  69     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCache;
  70     private HotSpotResolvedJavaField[] instanceFields;
  71     private HotSpotResolvedObjectTypeImpl[] interfaces;
  72     private HotSpotConstantPool constantPool;
  73     final HotSpotJVMCIMetaAccessContext context;
  74     private HotSpotResolvedObjectType arrayOfType;
  75 
  76     /**
  77      * Gets the JVMCI mirror for a {@link Class} object.
  78      *
  79      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}
  80      */
  81     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {
  82         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);
  83     }
  84 
  85     /**
  86      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the
  87      * underlying Klass*, it is used instead of the raw Klass*.
  88      *
  89      * Called from the VM.
  90      *
  91      * @param javaClass a {@link Class} object
  92      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
  93      */
  94     @SuppressWarnings("unused")
  95     private static HotSpotResolvedObjectTypeImpl fromMetaspace(Class&lt;?&gt; javaClass) {
  96         return fromObjectClass(javaClass);
  97     }
  98 
  99     /**
 100      * Creates the JVMCI mirror for a {@link Class} object.
 101      *
 102      * &lt;p&gt;
 103      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
 104      * {@link Class} type. Use {@link #fromObjectClass(Class)} or {@link #fromMetaspace(Class)}
 105      * instead.
 106      * &lt;/p&gt;
 107      *
 108      * @param javaClass the Class to create the mirror for
 109      * @param context
 110      */
 111     HotSpotResolvedObjectTypeImpl(Class&lt;?&gt; javaClass, HotSpotJVMCIMetaAccessContext context) {
 112         super(getSignatureName(javaClass));
 113         this.javaClass = javaClass;
 114         this.context = context;
 115         assert getName().charAt(0) != '[' || isArray() : getName();
 116     }
 117 
 118     /**
 119      * Returns the name of this type as it would appear in a signature.
 120      */
 121     private static String getSignatureName(Class&lt;?&gt; javaClass) {
 122         if (javaClass.isArray()) {
 123             return javaClass.getName().replace('.', '/');
 124         }
 125         return "L" + javaClass.getName().replace('.', '/') + ";";
 126     }
 127 
 128     /**
 129      * Gets the metaspace Klass for this type.
 130      */
 131     long getMetaspaceKlass() {
 132         if (HotSpotJVMCIRuntime.getHostWordKind() == JavaKind.Long) {
 133             return UNSAFE.getLong(javaClass, (long) config().klassOffset);
 134         }
 135         return UNSAFE.getInt(javaClass, (long) config().klassOffset) &amp; 0xFFFFFFFFL;
 136     }
 137 
 138     public long getMetaspacePointer() {
 139         return getMetaspaceKlass();
 140     }
 141 
 142     @Override
 143     public int getModifiers() {
 144         if (isArray()) {
 145             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 146         } else {
 147             return getAccessFlags() &amp; ModifiersProvider.jvmClassModifiers();
 148         }
 149     }
 150 
 151     public int getAccessFlags() {
 152         HotSpotVMConfig config = config();
 153         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 154     }
 155 
 156     @Override
 157     public HotSpotResolvedObjectType getArrayClass() {
 158         if (arrayOfType == null) {
 159             arrayOfType = fromObjectClass(Array.newInstance(mirror(), 0).getClass());
 160         }
 161         return arrayOfType;
 162     }
 163 
 164     @Override
 165     public ResolvedJavaType getComponentType() {
 166         Class&lt;?&gt; javaComponentType = mirror().getComponentType();
 167         return javaComponentType == null ? null : runtime().fromClass(javaComponentType);
 168     }
 169 
 170     @Override
 171     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 172         HotSpotVMConfig config = config();
 173         if (isArray()) {
 174             return getElementalType().isLeaf() ? new AssumptionResult&lt;&gt;(this) : null;
 175         } else if (isInterface()) {
 176             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
 177             /*
 178              * If the implementor field contains itself that indicates that the interface has more
 179              * than one implementors (see: InstanceKlass::add_implementor).
 180              */
 181             if (implementor == null || implementor.equals(this)) {
 182                 return null;
 183             }
 184 
 185             assert !implementor.isInterface();
 186             if (implementor.isAbstract() || !implementor.isLeafClass()) {
 187                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
 188                 if (leafConcreteSubtype != null) {
 189                     assert !leafConcreteSubtype.getResult().equals(implementor);
 190                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
 191                     // Accumulate leaf assumptions and return the combined result.
 192                     newResult.add(leafConcreteSubtype);
 193                     return newResult;
 194                 }
 195                 return null;
 196             }
 197 
 198             return new AssumptionResult&lt;&gt;(implementor, new LeafType(implementor), new ConcreteSubtype(this, implementor));
 199         } else {
 200             HotSpotResolvedObjectTypeImpl type = this;
 201             while (type.isAbstract()) {
 202                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
 203                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
 204                     return null;
 205                 }
 206                 type = subklass;
 207             }
 208             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
 209                 return null;
 210             }
 211             if (this.isAbstract()) {
 212                 return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 213             } else {
 214                 assert this.equals(type);
 215                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 216             }
 217         }
 218     }
 219 
 220     /**
 221      * Returns if type {@code type} is a leaf class. This is the case if the
 222      * {@code Klass::_subklass} field of the underlying class is zero.
 223      *
 224      * @return true if the type is a leaf class
 225      */
 226     private boolean isLeafClass() {
 227         return getSubklass() == null;
 228     }
 229 
 230     /**
 231      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 232      * type {@code type}.
 233      *
 234      * @return value of the subklass field as metaspace klass pointer
 235      */
 236     private HotSpotResolvedObjectTypeImpl getSubklass() {
 237         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 238     }
 239 
 240     @Override
 241     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 242         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();
 243         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);
 244     }
 245 
 246     @Override
 247     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 248         if (interfaces == null) {
 249             Class&lt;?&gt;[] javaInterfaces = mirror().getInterfaces();
 250             HotSpotResolvedObjectTypeImpl[] result = new HotSpotResolvedObjectTypeImpl[javaInterfaces.length];
 251             for (int i = 0; i &lt; javaInterfaces.length; i++) {
 252                 result[i] = fromObjectClass(javaInterfaces[i]);
 253             }
 254             interfaces = result;
 255         }
 256         return interfaces;
 257     }
 258 
 259     @Override
 260     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 261         if (!isInterface()) {
 262             throw new JVMCIError("Cannot call getSingleImplementor() on a non-interface type: %s", this);
 263         }
 264         return compilerToVM().getImplementor(this);
 265     }
 266 
 267     public HotSpotResolvedObjectTypeImpl getSupertype() {
 268         if (isArray()) {
 269             ResolvedJavaType componentType = getComponentType();
 270             if (mirror() == Object[].class || componentType.isPrimitive()) {
 271                 return fromObjectClass(Object.class);
 272             }
 273             return (HotSpotResolvedObjectTypeImpl) ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype().getArrayClass();
 274         }
 275         if (isInterface()) {
 276             return fromObjectClass(Object.class);
 277         }
 278         return getSuperclass();
 279     }
 280 
 281     @Override
 282     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 283         if (otherType.isPrimitive()) {
 284             return null;
 285         } else {
 286             HotSpotResolvedObjectTypeImpl t1 = this;
 287             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 288             while (true) {
 289                 if (t1.isAssignableFrom(t2)) {
 290                     return t1;
 291                 }
 292                 if (t2.isAssignableFrom(t1)) {
 293                     return t2;
 294                 }
 295                 t1 = t1.getSupertype();
 296                 t2 = t2.getSupertype();
 297             }
 298         }
 299     }
 300 
 301     @Override
 302     public HotSpotResolvedObjectType asExactType() {
 303         return isLeaf() ? this : null;
 304     }
 305 
 306     @Override
 307     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 308         assert !isArray();
 309         if (!compilerToVM().hasFinalizableSubclass(this)) {
 310             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 311         }
 312         return new AssumptionResult&lt;&gt;(true);
 313     }
 314 
 315     @Override
 316     public boolean hasFinalizer() {
 317         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 318     }
 319 
 320     @Override
 321     public boolean isPrimitive() {
 322         return false;
 323     }
 324 
 325     @Override
 326     public boolean isArray() {
 327         return mirror().isArray();
 328     }
 329 
 330     @Override
 331     public boolean isInitialized() {
 332         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 333     }
 334 
 335     @Override
 336     public boolean isLinked() {
 337         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 338     }
 339 
 340     /**
 341      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 342      * klass.
 343      *
 344      * @return state field value of this type
 345      */
 346     private int getInitState() {
 347         assert !isArray() : "_init_state only exists in InstanceKlass";
 348         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 349     }
 350 
 351     @Override
 352     public void initialize() {
 353         if (!isInitialized()) {
 354             UNSAFE.ensureClassInitialized(mirror());
 355             assert isInitialized();
 356         }
 357     }
 358 
 359     @Override
 360     public boolean isInstance(JavaConstant obj) {
 361         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
 362             return mirror().isInstance(((HotSpotObjectConstantImpl) obj).object());
 363         }
 364         return false;
 365     }
 366 
 367     @Override
 368     public boolean isInstanceClass() {
 369         return !isArray() &amp;&amp; !isInterface();
 370     }
 371 
 372     @Override
 373     public boolean isInterface() {
 374         return mirror().isInterface();
 375     }
 376 
 377     @Override
 378     public boolean isAssignableFrom(ResolvedJavaType other) {
 379         assert other != null;
 380         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 381             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
 382             return mirror().isAssignableFrom(otherType.mirror());
 383         }
 384         return false;
 385     }
 386 
 387     @Override
 388     public boolean isJavaLangObject() {
 389         return javaClass.equals(Object.class);
 390     }
 391 
 392     @Override
 393     public JavaKind getJavaKind() {
 394         return JavaKind.Object;
 395     }
 396 
 397     @Override
 398     public ResolvedJavaMethod resolveConcreteMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 399         ResolvedJavaMethod resolvedMethod = resolveMethod(method, callerType);
 400         if (resolvedMethod == null || resolvedMethod.isAbstract()) {
 401             return null;
 402         }
 403         return resolvedMethod;
 404     }
 405 
 406     @Override
 407     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 408         assert !callerType.isArray();
 409         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic()) {
 410             return method;
 411         }
 412         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 413             return null;
 414         }
 415         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
 416         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
 417         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
 418     }
 419 
 420     public HotSpotConstantPool getConstantPool() {
 421         if (constantPool == null) {
 422             constantPool = compilerToVM().getConstantPool(this, config().instanceKlassConstantsOffset);
 423         }
 424         return constantPool;
 425     }
 426 
 427     /**
 428      * Gets the instance size of this type. If an instance of this type cannot be fast path
 429      * allocated, then the returned value is negative (its absolute value gives the size). Must not
 430      * be called if this is an array or interface type.
 431      */
 432     public int instanceSize() {
 433         assert !isArray();
 434         assert !isInterface();
 435 
 436         HotSpotVMConfig config = config();
 437         final int layoutHelper = layoutHelper();
 438         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : "must be instance";
 439 
 440         // See: Klass::layout_helper_size_in_bytes
 441         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 442 
 443         // See: Klass::layout_helper_needs_slow_path
 444         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 445 
 446         return needsSlowPath ? -size : size;
 447     }
 448 
 449     public int layoutHelper() {
 450         HotSpotVMConfig config = config();
 451         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 452     }
 453 
 454     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {
 455         HotSpotResolvedJavaMethodImpl method = null;
 456         if (methodCache == null) {
 457             methodCache = new HashMap&lt;&gt;(8);
 458         } else {
 459             method = methodCache.get(metaspaceMethod);
 460         }
 461         if (method == null) {
 462             method = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);
 463             methodCache.put(metaspaceMethod, method);
 464             context.add(method);
 465         }
 466         return method;
 467     }
 468 
 469     public int getVtableLength() {
 470         HotSpotVMConfig config = config();
 471         if (isInterface() || isArray()) {
 472             /* Everything has the core vtable of java.lang.Object */
 473             return config.baseVtableLength();
 474         }
 475         int result = UNSAFE.getInt(getMetaspaceKlass() + config.instanceKlassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 476         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.instanceKlassVtableLengthOffset) + " " + config.vtableEntrySize;
 477         return result;
 478     }
 479 
 480     public synchronized HotSpotResolvedJavaField createField(String fieldName, JavaType type, long offset, int rawFlags) {
 481         HotSpotResolvedJavaField result = null;
 482 
 483         final int flags = rawFlags &amp; ModifiersProvider.jvmFieldModifiers();
 484 
 485         final long id = offset + ((long) flags &lt;&lt; 32);
 486 
 487         // Must cache the fields, because the local load elimination only works if the
 488         // objects from two field lookups are identical.
 489         if (fieldCache == null) {
 490             fieldCache = new HashMap&lt;&gt;(8);
 491         } else {
 492             result = fieldCache.get(id);
 493         }
 494 
 495         if (result == null) {
 496             result = new HotSpotResolvedJavaFieldImpl(this, fieldName, type, offset, rawFlags);
 497             fieldCache.put(id, result);
 498         } else {
 499             assert result.getName().equals(fieldName);
 500             // assert result.getType().equals(type);
 501             assert result.offset() == offset;
 502             assert result.getModifiers() == flags;
 503         }
 504 
 505         return result;
 506     }
 507 
 508     @Override
 509     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 510         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 511         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 512         /*
 513          * Sometimes the receiver type in the graph hasn't stabilized to a subtype of declared
 514          * holder, usually because of phis, so make sure that the type is related to the declared
 515          * type before using it for lookup. Unlinked types should also be ignored because we can't
 516          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 517          * a deopt instead since they can't really be used if they aren't linked yet.
 518          */
 519         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 520             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 521             if (result != null) {
 522                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 523             }
 524             return null;
 525         }
 526         /*
 527          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 528          * the correct method for the subtype.
 529          */
 530         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 531         if (resolvedMethod == null) {
 532             // The type isn't known to implement the method.
 533             return null;
 534         }
 535 
 536         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 537         if (result != null) {
 538             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 539         }
 540         return null;
 541     }
 542 
 543     /**
 544      * This class represents the field information for one field contained in the fields array of an
 545      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 546      */
 547     private class FieldInfo {
 548         /**
 549          * Native pointer into the array of Java shorts.
 550          */
 551         private final long metaspaceData;
 552 
 553         /**
 554          * Creates a field info for the field in the fields array at index {@code index}.
 555          *
 556          * @param index index to the fields array
 557          */
 558         public FieldInfo(int index) {
 559             HotSpotVMConfig config = config();
 560             // Get Klass::_fields
 561             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 562             assert config.fieldInfoFieldSlots == 6 : "revisit the field parsing code";
 563             metaspaceData = metaspaceFields + config.arrayU2DataOffset + config.fieldInfoFieldSlots * Short.BYTES * index;
 564         }
 565 
 566         private int getAccessFlags() {
 567             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
 568         }
 569 
 570         private int getNameIndex() {
 571             return readFieldSlot(config().fieldInfoNameIndexOffset);
 572         }
 573 
 574         private int getSignatureIndex() {
 575             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
 576         }
 577 
 578         public int getOffset() {
 579             HotSpotVMConfig config = config();
 580             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
 581             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
 582             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
 583             return offset;
 584         }
 585 
 586         /**
 587          * Helper method to read an entry (slot) from the field array. Currently field info is laid
 588          * on top an array of Java shorts.
 589          */
 590         private int readFieldSlot(int index) {
 591             return UNSAFE.getChar(metaspaceData + Short.BYTES * index);
 592         }
 593 
 594         /**
 595          * Returns the name of this field as a {@link String}. If the field is an internal field the
 596          * name index is pointing into the vmSymbols table.
 597          */
 598         public String getName() {
 599             final int nameIndex = getNameIndex();
 600             return isInternal() ? HotSpotVmSymbols.symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
 601         }
 602 
 603         /**
 604          * Returns the signature of this field as {@link String}. If the field is an internal field
 605          * the signature index is pointing into the vmSymbols table.
 606          */
 607         public String getSignature() {
 608             final int signatureIndex = getSignatureIndex();
 609             return isInternal() ? HotSpotVmSymbols.symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
 610         }
 611 
 612         public JavaType getType() {
 613             String signature = getSignature();
 614             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 615         }
 616 
 617         private boolean isInternal() {
 618             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 619         }
 620 
 621         public boolean isStatic() {
 622             return Modifier.isStatic(getAccessFlags());
 623         }
 624 
 625         public boolean hasGenericSignature() {
 626             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 627         }
 628     }
 629 
 630     private static class OffsetComparator implements java.util.Comparator&lt;HotSpotResolvedJavaField&gt; {
 631         @Override
 632         public int compare(HotSpotResolvedJavaField o1, HotSpotResolvedJavaField o2) {
 633             return o1.offset() - o2.offset();
 634         }
 635     }
 636 
 637     @Override
 638     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 639         if (instanceFields == null) {
 640             if (isArray() || isInterface()) {
 641                 instanceFields = new HotSpotResolvedJavaField[0];
 642             } else {
 643                 final int fieldCount = getFieldCount();
 644                 ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 645 
 646                 for (int i = 0; i &lt; fieldCount; i++) {
 647                     FieldInfo field = new FieldInfo(i);
 648 
 649                     // We are only interested in instance fields.
 650                     if (!field.isStatic()) {
 651                         HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 652                         fieldsArray.add(resolvedJavaField);
 653                     }
 654                 }
 655 
 656                 fieldsArray.sort(new OffsetComparator());
 657 
 658                 HotSpotResolvedJavaField[] myFields = fieldsArray.toArray(new HotSpotResolvedJavaField[0]);
 659 
 660                 if (mirror() != Object.class) {
 661                     HotSpotResolvedJavaField[] superFields = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 662                     HotSpotResolvedJavaField[] fields = Arrays.copyOf(superFields, superFields.length + myFields.length);
 663                     System.arraycopy(myFields, 0, fields, superFields.length, myFields.length);
 664                     instanceFields = fields;
 665                 } else {
 666                     assert myFields.length == 0 : "java.lang.Object has fields!";
 667                     instanceFields = myFields;
 668                 }
 669 
 670             }
 671         }
 672         if (!includeSuperclasses) {
 673             int myFieldsStart = 0;
 674             while (myFieldsStart &lt; instanceFields.length &amp;&amp; !instanceFields[myFieldsStart].getDeclaringClass().equals(this)) {
 675                 myFieldsStart++;
 676             }
 677             if (myFieldsStart == 0) {
 678                 return instanceFields;
 679             }
 680             if (myFieldsStart == instanceFields.length) {
 681                 return new HotSpotResolvedJavaField[0];
 682             }
 683             return Arrays.copyOfRange(instanceFields, myFieldsStart, instanceFields.length);
 684         }
 685         return instanceFields;
 686     }
 687 
 688     @Override
 689     public ResolvedJavaField[] getStaticFields() {
 690         if (isArray()) {
 691             return new HotSpotResolvedJavaField[0];
 692         } else {
 693             final int fieldCount = getFieldCount();
 694             ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 695 
 696             for (int i = 0; i &lt; fieldCount; i++) {
 697                 FieldInfo field = new FieldInfo(i);
 698 
 699                 // We are only interested in static fields.
 700                 if (field.isStatic()) {
 701                     HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 702                     fieldsArray.add(resolvedJavaField);
 703                 }
 704             }
 705 
 706             fieldsArray.sort(new OffsetComparator());
 707             return fieldsArray.toArray(new HotSpotResolvedJavaField[fieldsArray.size()]);
 708         }
 709     }
 710 
 711     /**
 712      * Returns the actual field count of this class's internal {@code InstanceKlass::_fields} array
 713      * by walking the array and discounting the generic signature slots at the end of the array.
 714      *
 715      * &lt;p&gt;
 716      * See {@code FieldStreamBase::init_generic_signature_start_slot}
 717      */
 718     private int getFieldCount() {
 719         HotSpotVMConfig config = config();
 720         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 721         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
 722         int fieldCount = 0;
 723 
 724         for (int i = 0, index = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
 725             FieldInfo field = new FieldInfo(index);
 726             if (field.hasGenericSignature()) {
 727                 metaspaceFieldsLength--;
 728             }
 729             fieldCount++;
 730         }
 731         return fieldCount;
 732     }
 733 
 734     @Override
 735     public Class&lt;?&gt; mirror() {
 736         return javaClass;
 737     }
 738 
 739     @Override
 740     public String getSourceFileName() {
 741         HotSpotVMConfig config = config();
 742         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
 743         if (sourceFileNameIndex == 0) {
 744             return null;
 745         }
 746         return getConstantPool().lookupUtf8(sourceFileNameIndex);
 747     }
 748 
 749     @Override
 750     public Annotation[] getAnnotations() {
 751         return mirror().getAnnotations();
 752     }
 753 
 754     @Override
 755     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 756         return mirror().getAnnotation(annotationClass);
 757     }
 758 
 759     /**
 760      * Performs a fast-path check that this type is resolved in the context of a given accessing
 761      * class. A negative result does not mean this type is not resolved with respect to
 762      * {@code accessingClass}. That can only be determined by
 763      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 764      * re-resolving} the type.
 765      */
 766     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 767         assert accessingClass != null;
 768         ResolvedJavaType elementType = getElementalType();
 769         if (elementType.isPrimitive()) {
 770             // Primitive type resolution is context free.
 771             return true;
 772         }
 773         if (elementType.getName().startsWith("Ljava/")) {
 774             // Classes in a java.* package can only be defined by the
 775             // boot class loader. This is enforced by ClassLoader.preDefineClass()
 776             assert mirror().getClassLoader() == null;
 777             return true;
 778         }
 779         ClassLoader thisCl = mirror().getClassLoader();
 780         ClassLoader accessingClassCl = ((HotSpotResolvedObjectTypeImpl) accessingClass).mirror().getClassLoader();
 781         return thisCl == accessingClassCl;
 782     }
 783 
 784     @Override
 785     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 786         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 787             return this;
 788         }
 789         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 790         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 791     }
 792 
 793     /**
 794      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 795      */
 796     public Constant klass() {
 797         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 798     }
 799 
 800     public boolean isPrimaryType() {
 801         return config().secondarySuperCacheOffset != superCheckOffset();
 802     }
 803 
 804     public int superCheckOffset() {
 805         HotSpotVMConfig config = config();
 806         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
 807     }
 808 
 809     public long prototypeMarkWord() {
 810         HotSpotVMConfig config = config();
 811         if (isArray()) {
 812             return config.arrayPrototypeMarkWord();
 813         } else {
 814             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 815         }
 816     }
 817 
 818     @Override
 819     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 820         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 821         for (ResolvedJavaField field : declaredFields) {
 822             HotSpotResolvedJavaField resolvedField = (HotSpotResolvedJavaField) field;
 823             long resolvedFieldOffset = resolvedField.offset();
 824             // @formatter:off
 825             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN  &amp;&amp;
 826                             expectedEntryKind.isPrimitive() &amp;&amp;
 827                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;
 828                             resolvedField.getJavaKind().isPrimitive()) {
 829                 resolvedFieldOffset +=
 830                                 resolvedField.getJavaKind().getByteCount() -
 831                                 Math.min(resolvedField.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());
 832             }
 833             if (resolvedFieldOffset == offset) {
 834                 return field;
 835             }
 836             // @formatter:on
 837         }
 838         return null;
 839     }
 840 
 841     @Override
 842     public URL getClassFilePath() {
 843         Class&lt;?&gt; cls = mirror();
 844         return cls.getResource(MetaUtil.getSimpleName(cls, true).replace('.', '$') + ".class");
 845     }
 846 
 847     @Override
 848     public boolean isLocal() {
 849         return mirror().isLocalClass();
 850     }
 851 
 852     @Override
 853     public boolean isMember() {
 854         return mirror().isMemberClass();
 855     }
 856 
 857     @Override
 858     public HotSpotResolvedObjectTypeImpl getEnclosingType() {
 859         final Class&lt;?&gt; encl = mirror().getEnclosingClass();
 860         return encl == null ? null : fromObjectClass(encl);
 861     }
 862 
 863     @Override
 864     public ResolvedJavaMethod[] getDeclaredConstructors() {
 865         Constructor&lt;?&gt;[] constructors = mirror().getDeclaredConstructors();
 866         ResolvedJavaMethod[] result = new ResolvedJavaMethod[constructors.length];
 867         for (int i = 0; i &lt; constructors.length; i++) {
 868             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(constructors[i]);
 869             assert result[i].isConstructor();
 870         }
 871         return result;
 872     }
 873 
 874     @Override
 875     public ResolvedJavaMethod[] getDeclaredMethods() {
 876         Method[] methods = mirror().getDeclaredMethods();
 877         ResolvedJavaMethod[] result = new ResolvedJavaMethod[methods.length];
 878         for (int i = 0; i &lt; methods.length; i++) {
 879             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(methods[i]);
 880             assert !result[i].isConstructor();
 881         }
 882         return result;
 883     }
 884 
 885     public ResolvedJavaMethod getClassInitializer() {
 886         return compilerToVM().getClassInitializer(this);
 887     }
 888 
 889     @Override
 890     public String toString() {
 891         return "HotSpotType&lt;" + getName() + ", resolved&gt;";
 892     }
 893 
 894     @Override
 895     public boolean isTrustedInterfaceType() {
 896         return TrustedInterface.class.isAssignableFrom(mirror());
 897     }
 898 }
</pre></body></html>
