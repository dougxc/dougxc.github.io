<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_VM_RUNTIME_GLOBALS_HPP
  26 #define SHARE_VM_RUNTIME_GLOBALS_HPP
  27 
  28 #include "utilities/debug.hpp"
  29 #include "utilities/macros.hpp"
  30 
  31 #include &lt;float.h&gt; // for DBL_MAX
  32 
  33 // use this for flags that are true per default in the tiered build
  34 // but false in non-tiered builds, and vice versa
  35 #ifdef TIERED
  36 #define  trueInTiered true
  37 #define falseInTiered false
  38 #else
  39 #define  trueInTiered false
  40 #define falseInTiered true
  41 #endif
  42 
  43 #include CPU_HEADER(globals)
  44 #include OS_HEADER(globals)
  45 #include OS_CPU_HEADER(globals)
  46 #ifdef COMPILER1
  47 #include CPU_HEADER(c1_globals)
  48 #include OS_HEADER(c1_globals)
  49 #endif
  50 #ifdef COMPILER2
  51 #include CPU_HEADER(c2_globals)
  52 #include OS_HEADER(c2_globals)
  53 #endif
  54 #ifdef SHARK
  55 #ifdef ZERO
  56 # include "shark_globals_zero.hpp"
  57 #endif
  58 #endif
  59 
  60 #if !defined(COMPILER1) &amp;&amp; !defined(COMPILER2) &amp;&amp; !defined(SHARK) &amp;&amp; !INCLUDE_JVMCI
  61 define_pd_global(bool, BackgroundCompilation,        false);
  62 define_pd_global(bool, UseTLAB,                      false);
  63 define_pd_global(bool, CICompileOSR,                 false);
  64 define_pd_global(bool, UseTypeProfile,               false);
  65 define_pd_global(bool, UseOnStackReplacement,        false);
  66 define_pd_global(bool, InlineIntrinsics,             false);
  67 define_pd_global(bool, PreferInterpreterNativeStubs, true);
  68 define_pd_global(bool, ProfileInterpreter,           false);
  69 define_pd_global(bool, ProfileTraps,                 false);
  70 define_pd_global(bool, TieredCompilation,            false);
  71 
  72 define_pd_global(intx, CompileThreshold,             0);
  73 
  74 define_pd_global(intx, OnStackReplacePercentage,     0);
  75 define_pd_global(bool, ResizeTLAB,                   false);
  76 define_pd_global(intx, FreqInlineSize,               0);
  77 define_pd_global(size_t, NewSizeThreadIncrease,      4*K);
  78 define_pd_global(intx, InlineClassNatives,           true);
  79 define_pd_global(intx, InlineUnsafeOps,              true);
  80 define_pd_global(intx, InitialCodeCacheSize,         160*K);
  81 define_pd_global(intx, ReservedCodeCacheSize,        32*M);
  82 define_pd_global(intx, NonProfiledCodeHeapSize,      0);
  83 define_pd_global(intx, ProfiledCodeHeapSize,         0);
  84 define_pd_global(intx, NonNMethodCodeHeapSize,       32*M);
  85 
  86 define_pd_global(intx, CodeCacheExpansionSize,       32*K);
  87 define_pd_global(intx, CodeCacheMinBlockLength,      1);
  88 define_pd_global(intx, CodeCacheMinimumUseSpace,     200*K);
  89 define_pd_global(size_t, MetaspaceSize,              ScaleForWordSize(4*M));
  90 define_pd_global(bool, NeverActAsServerClassMachine, true);
  91 define_pd_global(uint64_t,MaxRAM,                    1ULL*G);
  92 #define CI_COMPILER_COUNT 0
  93 #else
  94 
  95 #if defined(COMPILER2) || INCLUDE_JVMCI
  96 #define CI_COMPILER_COUNT 2
  97 #else
  98 #define CI_COMPILER_COUNT 1
  99 #endif // COMPILER2 || INCLUDE_JVMCI
 100 
 101 #endif // no compilers
 102 
 103 // string type aliases used only in this file
 104 typedef const char* ccstr;
 105 typedef const char* ccstrlist;   // represents string arguments which accumulate
 106 
 107 // function type that will construct default range string
 108 typedef const char* (*RangeStrFunc)(void);
 109 
 110 struct Flag {
 111   enum Flags {
 112     // latest value origin
 113     DEFAULT          = 0,
 114     COMMAND_LINE     = 1,
 115     ENVIRON_VAR      = 2,
 116     CONFIG_FILE      = 3,
 117     MANAGEMENT       = 4,
 118     ERGONOMIC        = 5,
 119     ATTACH_ON_DEMAND = 6,
 120     INTERNAL         = 7,
 121 
 122     LAST_VALUE_ORIGIN = INTERNAL,
 123     VALUE_ORIGIN_BITS = 4,
 124     VALUE_ORIGIN_MASK = right_n_bits(VALUE_ORIGIN_BITS),
 125 
 126     // flag kind
 127     KIND_PRODUCT            = 1 &lt;&lt; 4,
 128     KIND_MANAGEABLE         = 1 &lt;&lt; 5,
 129     KIND_DIAGNOSTIC         = 1 &lt;&lt; 6,
 130     KIND_EXPERIMENTAL       = 1 &lt;&lt; 7,
 131     KIND_NOT_PRODUCT        = 1 &lt;&lt; 8,
 132     KIND_DEVELOP            = 1 &lt;&lt; 9,
 133     KIND_PLATFORM_DEPENDENT = 1 &lt;&lt; 10,
 134     KIND_READ_WRITE         = 1 &lt;&lt; 11,
 135     KIND_C1                 = 1 &lt;&lt; 12,
 136     KIND_C2                 = 1 &lt;&lt; 13,
 137     KIND_ARCH               = 1 &lt;&lt; 14,
 138     KIND_SHARK              = 1 &lt;&lt; 15,
 139     KIND_LP64_PRODUCT       = 1 &lt;&lt; 16,
 140     KIND_COMMERCIAL         = 1 &lt;&lt; 17,
 141     KIND_JVMCI              = 1 &lt;&lt; 18,
 142 
 143     // set this bit if the flag was set on the command line
 144     ORIG_COMMAND_LINE       = 1 &lt;&lt; 19,
 145 
 146     KIND_MASK = ~(VALUE_ORIGIN_MASK | ORIG_COMMAND_LINE)
 147   };
 148 
 149   enum Error {
 150     // no error
 151     SUCCESS = 0,
 152     // flag name is missing
 153     MISSING_NAME,
 154     // flag value is missing
 155     MISSING_VALUE,
 156     // error parsing the textual form of the value
 157     WRONG_FORMAT,
 158     // flag is not writable
 159     NON_WRITABLE,
 160     // flag value is outside of its bounds
 161     OUT_OF_BOUNDS,
 162     // flag value violates its constraint
 163     VIOLATES_CONSTRAINT,
 164     // there is no flag with the given name
 165     INVALID_FLAG,
 166     // the flag can only be set only on command line during invocation of the VM
 167     COMMAND_LINE_ONLY,
 168     // the flag may only be set once
 169     SET_ONLY_ONCE,
 170     // the flag is not writable in this combination of product/debug build
 171     CONSTANT,
 172     // other, unspecified error related to setting the flag
 173     ERR_OTHER
 174   };
 175 
 176   enum MsgType {
 177     NONE = 0,
 178     DIAGNOSTIC_FLAG_BUT_LOCKED,
 179     EXPERIMENTAL_FLAG_BUT_LOCKED,
 180     DEVELOPER_FLAG_BUT_PRODUCT_BUILD,
 181     NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD
 182   };
 183 
 184   const char* _type;
 185   const char* _name;
 186   void* _addr;
 187   NOT_PRODUCT(const char* _doc;)
 188   Flags _flags;
 189 
 190   // points to all Flags static array
 191   static Flag* flags;
 192 
 193   // number of flags
 194   static size_t numFlags;
 195 
 196   static Flag* find_flag(const char* name) { return find_flag(name, strlen(name), true, true); };
 197   static Flag* find_flag(const char* name, size_t length, bool allow_locked = false, bool return_flag = false);
 198   static Flag* fuzzy_match(const char* name, size_t length, bool allow_locked = false);
 199 
 200   static const char* get_int_default_range_str();
 201   static const char* get_uint_default_range_str();
 202   static const char* get_intx_default_range_str();
 203   static const char* get_uintx_default_range_str();
 204   static const char* get_uint64_t_default_range_str();
 205   static const char* get_size_t_default_range_str();
 206   static const char* get_double_default_range_str();
 207 
 208   Flag::Error check_writable(bool changed);
 209 
 210   bool is_bool() const;
 211   bool get_bool() const;
 212   Flag::Error set_bool(bool value);
 213 
 214   bool is_int() const;
 215   int get_int() const;
 216   Flag::Error set_int(int value);
 217 
 218   bool is_uint() const;
 219   uint get_uint() const;
 220   Flag::Error set_uint(uint value);
 221 
 222   bool is_intx() const;
 223   intx get_intx() const;
 224   Flag::Error set_intx(intx value);
 225 
 226   bool is_uintx() const;
 227   uintx get_uintx() const;
 228   Flag::Error set_uintx(uintx value);
 229 
 230   bool is_uint64_t() const;
 231   uint64_t get_uint64_t() const;
 232   Flag::Error set_uint64_t(uint64_t value);
 233 
 234   bool is_size_t() const;
 235   size_t get_size_t() const;
 236   Flag::Error set_size_t(size_t value);
 237 
 238   bool is_double() const;
 239   double get_double() const;
 240   Flag::Error set_double(double value);
 241 
 242   bool is_ccstr() const;
 243   bool ccstr_accumulates() const;
 244   ccstr get_ccstr() const;
 245   Flag::Error set_ccstr(ccstr value);
 246 
 247   Flags get_origin();
 248   void set_origin(Flags origin);
 249 
 250   bool is_default();
 251   bool is_ergonomic();
 252   bool is_command_line();
 253   void set_command_line();
 254 
 255   bool is_product() const;
 256   bool is_manageable() const;
 257   bool is_diagnostic() const;
 258   bool is_experimental() const;
 259   bool is_notproduct() const;
 260   bool is_develop() const;
 261   bool is_read_write() const;
 262   bool is_commercial() const;
 263 
 264   bool is_constant_in_binary() const;
 265 
 266   bool is_unlocker() const;
 267   bool is_unlocked() const;
 268   bool is_writeable() const;
 269   bool is_external() const;
 270 
 271   bool is_unlocker_ext() const;
 272   bool is_unlocked_ext() const;
 273   bool is_writeable_ext() const;
 274   bool is_external_ext() const;
 275 
 276   void unlock_diagnostic();
 277 
 278   Flag::MsgType get_locked_message(char*, int) const;
 279   void get_locked_message_ext(char*, int) const;
 280 
 281   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
 282   void print_on(outputStream* st, bool withComments = false, bool printRanges = false);
 283   void print_kind_and_origin(outputStream* st);
 284   void print_as_flag(outputStream* st);
 285 
 286   static const char* flag_error_str(Flag::Error error);
 287 };
 288 
 289 // debug flags control various aspects of the VM and are global accessible
 290 
 291 // use FlagSetting to temporarily change some debug flag
 292 // e.g. FlagSetting fs(DebugThisAndThat, true);
 293 // restored to previous value upon leaving scope
 294 class FlagSetting {
 295   bool val;
 296   bool* flag;
 297  public:
 298   FlagSetting(bool&amp; fl, bool newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 299   ~FlagSetting()                       { *flag = val; }
 300 };
 301 
 302 
 303 class CounterSetting {
 304   intx* counter;
 305  public:
 306   CounterSetting(intx* cnt) { counter = cnt; (*counter)++; }
 307   ~CounterSetting()         { (*counter)--; }
 308 };
 309 
 310 class IntFlagSetting {
 311   int val;
 312   int* flag;
 313  public:
 314   IntFlagSetting(int&amp; fl, int newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 315   ~IntFlagSetting()                     { *flag = val; }
 316 };
 317 
 318 class UIntFlagSetting {
 319   uint val;
 320   uint* flag;
 321  public:
 322   UIntFlagSetting(uint&amp; fl, uint newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 323   ~UIntFlagSetting()                       { *flag = val; }
 324 };
 325 
 326 class UIntXFlagSetting {
 327   uintx val;
 328   uintx* flag;
 329  public:
 330   UIntXFlagSetting(uintx&amp; fl, uintx newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 331   ~UIntXFlagSetting()                         { *flag = val; }
 332 };
 333 
 334 class DoubleFlagSetting {
 335   double val;
 336   double* flag;
 337  public:
 338   DoubleFlagSetting(double&amp; fl, double newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 339   ~DoubleFlagSetting()                           { *flag = val; }
 340 };
 341 
 342 class SizeTFlagSetting {
 343   size_t val;
 344   size_t* flag;
 345  public:
 346   SizeTFlagSetting(size_t&amp; fl, size_t newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 347   ~SizeTFlagSetting()                           { *flag = val; }
 348 };
 349 
 350 // Helper class for temporarily saving the value of a flag during a scope.
 351 template &lt;size_t SIZE&gt;
 352 class FlagGuard {
 353   unsigned char _value[SIZE];
 354   void* const _addr;
 355 
 356   // Hide operator new, this class should only be allocated on the stack.
 357   // NOTE: Cannot include memory/allocation.hpp here due to circular
 358   //       dependencies.
 359   void* operator new(size_t size) throw();
 360   void* operator new [](size_t size) throw();
 361 
 362  public:
 363   FlagGuard(void* flag_addr) : _addr(flag_addr) {
 364     memcpy(_value, _addr, SIZE);
 365   }
 366 
 367   ~FlagGuard() {
 368     memcpy(_addr, _value, SIZE);
 369   }
 370 };
 371 
 372 #define FLAG_GUARD(f) FlagGuard&lt;sizeof(f)&gt; f ## _guard(&amp;f)
 373 
 374 class CommandLineFlags {
 375 public:
 376   static Flag::Error boolAt(const char* name, size_t len, bool* value, bool allow_locked = false, bool return_flag = false);
 377   static Flag::Error boolAt(const char* name, bool* value, bool allow_locked = false, bool return_flag = false)      { return boolAt(name, strlen(name), value, allow_locked, return_flag); }
 378   static Flag::Error boolAtPut(Flag* flag, bool* value, Flag::Flags origin);
 379   static Flag::Error boolAtPut(const char* name, size_t len, bool* value, Flag::Flags origin);
 380   static Flag::Error boolAtPut(const char* name, bool* value, Flag::Flags origin)   { return boolAtPut(name, strlen(name), value, origin); }
 381 
 382   static Flag::Error intAt(const char* name, size_t len, int* value, bool allow_locked = false, bool return_flag = false);
 383   static Flag::Error intAt(const char* name, int* value, bool allow_locked = false, bool return_flag = false)      { return intAt(name, strlen(name), value, allow_locked, return_flag); }
 384   static Flag::Error intAtPut(Flag* flag, int* value, Flag::Flags origin);
 385   static Flag::Error intAtPut(const char* name, size_t len, int* value, Flag::Flags origin);
 386   static Flag::Error intAtPut(const char* name, int* value, Flag::Flags origin)   { return intAtPut(name, strlen(name), value, origin); }
 387 
 388   static Flag::Error uintAt(const char* name, size_t len, uint* value, bool allow_locked = false, bool return_flag = false);
 389   static Flag::Error uintAt(const char* name, uint* value, bool allow_locked = false, bool return_flag = false)      { return uintAt(name, strlen(name), value, allow_locked, return_flag); }
 390   static Flag::Error uintAtPut(Flag* flag, uint* value, Flag::Flags origin);
 391   static Flag::Error uintAtPut(const char* name, size_t len, uint* value, Flag::Flags origin);
 392   static Flag::Error uintAtPut(const char* name, uint* value, Flag::Flags origin)   { return uintAtPut(name, strlen(name), value, origin); }
 393 
 394   static Flag::Error intxAt(const char* name, size_t len, intx* value, bool allow_locked = false, bool return_flag = false);
 395   static Flag::Error intxAt(const char* name, intx* value, bool allow_locked = false, bool return_flag = false)      { return intxAt(name, strlen(name), value, allow_locked, return_flag); }
 396   static Flag::Error intxAtPut(Flag* flag, intx* value, Flag::Flags origin);
 397   static Flag::Error intxAtPut(const char* name, size_t len, intx* value, Flag::Flags origin);
 398   static Flag::Error intxAtPut(const char* name, intx* value, Flag::Flags origin)   { return intxAtPut(name, strlen(name), value, origin); }
 399 
 400   static Flag::Error uintxAt(const char* name, size_t len, uintx* value, bool allow_locked = false, bool return_flag = false);
 401   static Flag::Error uintxAt(const char* name, uintx* value, bool allow_locked = false, bool return_flag = false)    { return uintxAt(name, strlen(name), value, allow_locked, return_flag); }
 402   static Flag::Error uintxAtPut(Flag* flag, uintx* value, Flag::Flags origin);
 403   static Flag::Error uintxAtPut(const char* name, size_t len, uintx* value, Flag::Flags origin);
 404   static Flag::Error uintxAtPut(const char* name, uintx* value, Flag::Flags origin) { return uintxAtPut(name, strlen(name), value, origin); }
 405 
 406   static Flag::Error size_tAt(const char* name, size_t len, size_t* value, bool allow_locked = false, bool return_flag = false);
 407   static Flag::Error size_tAt(const char* name, size_t* value, bool allow_locked = false, bool return_flag = false)    { return size_tAt(name, strlen(name), value, allow_locked, return_flag); }
 408   static Flag::Error size_tAtPut(Flag* flag, size_t* value, Flag::Flags origin);
 409   static Flag::Error size_tAtPut(const char* name, size_t len, size_t* value, Flag::Flags origin);
 410   static Flag::Error size_tAtPut(const char* name, size_t* value, Flag::Flags origin) { return size_tAtPut(name, strlen(name), value, origin); }
 411 
 412   static Flag::Error uint64_tAt(const char* name, size_t len, uint64_t* value, bool allow_locked = false, bool return_flag = false);
 413   static Flag::Error uint64_tAt(const char* name, uint64_t* value, bool allow_locked = false, bool return_flag = false) { return uint64_tAt(name, strlen(name), value, allow_locked, return_flag); }
 414   static Flag::Error uint64_tAtPut(Flag* flag, uint64_t* value, Flag::Flags origin);
 415   static Flag::Error uint64_tAtPut(const char* name, size_t len, uint64_t* value, Flag::Flags origin);
 416   static Flag::Error uint64_tAtPut(const char* name, uint64_t* value, Flag::Flags origin) { return uint64_tAtPut(name, strlen(name), value, origin); }
 417 
 418   static Flag::Error doubleAt(const char* name, size_t len, double* value, bool allow_locked = false, bool return_flag = false);
 419   static Flag::Error doubleAt(const char* name, double* value, bool allow_locked = false, bool return_flag = false)    { return doubleAt(name, strlen(name), value, allow_locked, return_flag); }
 420   static Flag::Error doubleAtPut(Flag* flag, double* value, Flag::Flags origin);
 421   static Flag::Error doubleAtPut(const char* name, size_t len, double* value, Flag::Flags origin);
 422   static Flag::Error doubleAtPut(const char* name, double* value, Flag::Flags origin) { return doubleAtPut(name, strlen(name), value, origin); }
 423 
 424   static Flag::Error ccstrAt(const char* name, size_t len, ccstr* value, bool allow_locked = false, bool return_flag = false);
 425   static Flag::Error ccstrAt(const char* name, ccstr* value, bool allow_locked = false, bool return_flag = false)    { return ccstrAt(name, strlen(name), value, allow_locked, return_flag); }
 426   // Contract:  Flag will make private copy of the incoming value.
 427   // Outgoing value is always malloc-ed, and caller MUST call free.
 428   static Flag::Error ccstrAtPut(const char* name, size_t len, ccstr* value, Flag::Flags origin);
 429   static Flag::Error ccstrAtPut(const char* name, ccstr* value, Flag::Flags origin) { return ccstrAtPut(name, strlen(name), value, origin); }
 430 
 431   // Returns false if name is not a command line flag.
 432   static bool wasSetOnCmdline(const char* name, bool* value);
 433   static void printSetFlags(outputStream* out);
 434 
 435   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
 436   static void printFlags(outputStream* out, bool withComments, bool printRanges = false);
 437 
 438   static void verify() PRODUCT_RETURN;
 439 };
 440 
 441 // use this for flags that are true by default in the debug version but
 442 // false in the optimized version, and vice versa
 443 #ifdef ASSERT
 444 #define trueInDebug  true
 445 #define falseInDebug false
 446 #else
 447 #define trueInDebug  false
 448 #define falseInDebug true
 449 #endif
 450 
 451 // use this for flags that are true per default in the product build
 452 // but false in development builds, and vice versa
 453 #ifdef PRODUCT
 454 #define trueInProduct  true
 455 #define falseInProduct false
 456 #else
 457 #define trueInProduct  false
 458 #define falseInProduct true
 459 #endif
 460 
 461 // develop flags are settable / visible only during development and are constant in the PRODUCT version
 462 // product flags are always settable / visible
 463 // notproduct flags are settable / visible only during development and are not declared in the PRODUCT version
 464 
 465 // A flag must be declared with one of the following types:
 466 // bool, int, uint, intx, uintx, size_t, ccstr, double, or uint64_t.
 467 // The type "ccstr" is an alias for "const char*" and is used
 468 // only in this file, because the macrology requires single-token type names.
 469 
 470 // Note: Diagnostic options not meant for VM tuning or for product modes.
 471 // They are to be used for VM quality assurance or field diagnosis
 472 // of VM bugs.  They are hidden so that users will not be encouraged to
 473 // try them as if they were VM ordinary execution options.  However, they
 474 // are available in the product version of the VM.  Under instruction
 475 // from support engineers, VM customers can turn them on to collect
 476 // diagnostic information about VM problems.  To use a VM diagnostic
 477 // option, you must first specify +UnlockDiagnosticVMOptions.
 478 // (This master switch also affects the behavior of -Xprintflags.)
 479 //
 480 // experimental flags are in support of features that are not
 481 //    part of the officially supported product, but are available
 482 //    for experimenting with. They could, for example, be performance
 483 //    features that may not have undergone full or rigorous QA, but which may
 484 //    help performance in some cases and released for experimentation
 485 //    by the community of users and developers. This flag also allows one to
 486 //    be able to build a fully supported product that nonetheless also
 487 //    ships with some unsupported, lightly tested, experimental features.
 488 //    Like the UnlockDiagnosticVMOptions flag above, there is a corresponding
 489 //    UnlockExperimentalVMOptions flag, which allows the control and
 490 //    modification of the experimental flags.
 491 //
 492 // Nota bene: neither diagnostic nor experimental options should be used casually,
 493 //    and they are not supported on production loads, except under explicit
 494 //    direction from support engineers.
 495 //
 496 // manageable flags are writeable external product flags.
 497 //    They are dynamically writeable through the JDK management interface
 498 //    (com.sun.management.HotSpotDiagnosticMXBean API) and also through JConsole.
 499 //    These flags are external exported interface (see CCC).  The list of
 500 //    manageable flags can be queried programmatically through the management
 501 //    interface.
 502 //
 503 //    A flag can be made as "manageable" only if
 504 //    - the flag is defined in a CCC as an external exported interface.
 505 //    - the VM implementation supports dynamic setting of the flag.
 506 //      This implies that the VM must *always* query the flag variable
 507 //      and not reuse state related to the flag state at any given time.
 508 //    - you want the flag to be queried programmatically by the customers.
 509 //
 510 // product_rw flags are writeable internal product flags.
 511 //    They are like "manageable" flags but for internal/private use.
 512 //    The list of product_rw flags are internal/private flags which
 513 //    may be changed/removed in a future release.  It can be set
 514 //    through the management interface to get/set value
 515 //    when the name of flag is supplied.
 516 //
 517 //    A flag can be made as "product_rw" only if
 518 //    - the VM implementation supports dynamic setting of the flag.
 519 //      This implies that the VM must *always* query the flag variable
 520 //      and not reuse state related to the flag state at any given time.
 521 //
 522 // Note that when there is a need to support develop flags to be writeable,
 523 // it can be done in the same way as product_rw.
 524 //
 525 // range is a macro that will expand to min and max arguments for range
 526 //    checking code if provided - see commandLineFlagRangeList.hpp
 527 //
 528 // constraint is a macro that will expand to custom function call
 529 //    for constraint checking if provided - see commandLineFlagConstraintList.hpp
 530 //
 531 // writeable is a macro that controls if and how the value can change during the runtime
 532 //
 533 // writeable(Always) is optional and allows the flag to have its value changed
 534 //    without any limitations at any time
 535 //
 536 // writeable(Once) flag value's can be only set once during the lifetime of VM
 537 //
 538 // writeable(CommandLineOnly) flag value's can be only set from command line
 539 //    (multiple times allowed)
 540 //
 541 
 542 
 543 #define RUNTIME_FLAGS(develop, \
 544                       develop_pd, \
 545                       product, \
 546                       product_pd, \
 547                       diagnostic, \
 548                       diagnostic_pd, \
 549                       experimental, \
 550                       notproduct, \
 551                       manageable, \
 552                       product_rw, \
 553                       lp64_product, \
 554                       range, \
 555                       constraint, \
 556                       writeable) \
 557                                                                             \
 558   lp64_product(bool, UseCompressedOops, false,                              \
 559           "Use 32-bit object references in 64-bit VM. "                     \
 560           "lp64_product means flag is always constant in 32 bit VM")        \
 561                                                                             \
 562   lp64_product(bool, UseCompressedClassPointers, false,                     \
 563           "Use 32-bit class pointers in 64-bit VM. "                        \
 564           "lp64_product means flag is always constant in 32 bit VM")        \
 565                                                                             \
 566   notproduct(bool, CheckCompressedOops, true,                               \
 567           "Generate checks in encoding/decoding code in debug VM")          \
 568                                                                             \
 569   product(uintx, HeapSearchSteps, 3 PPC64_ONLY(+17),                        \
 570           "Heap allocation steps through preferred address regions to find" \
 571           " where it can allocate the heap. Number of steps to take per "   \
 572           "region.")                                                        \
 573           range(1, max_uintx)                                               \
 574                                                                             \
 575   lp64_product(intx, ObjectAlignmentInBytes, 8,                             \
 576           "Default object alignment in bytes, 8 is minimum")                \
 577           range(8, 256)                                                     \
 578           constraint(ObjectAlignmentInBytesConstraintFunc,AtParse)          \
 579                                                                             \
 580   product(bool, AssumeMP, false,                                            \
 581           "Instruct the VM to assume multiple processors are available")    \
 582                                                                             \
 583   /* UseMembar is theoretically a temp flag used for memory barrier      */ \
 584   /* removal testing.  It was supposed to be removed before FCS but has  */ \
 585   /* been re-added (see 6401008)                                         */ \
 586   product_pd(bool, UseMembar,                                               \
 587           "(Unstable) Issues membars on thread state transitions")          \
 588                                                                             \
 589   develop(bool, CleanChunkPoolAsync, true,                                  \
 590           "Clean the chunk pool asynchronously")                            \
 591                                                                             \
 592   experimental(bool, AlwaysSafeConstructors, false,                         \
 593           "Force safe construction, as if all fields are final.")           \
 594                                                                             \
 595   diagnostic(bool, UnlockDiagnosticVMOptions, trueInDebug,                  \
 596           "Enable normal processing of flags relating to field diagnostics")\
 597                                                                             \
 598   experimental(bool, UnlockExperimentalVMOptions, false,                    \
 599           "Enable normal processing of flags relating to experimental "     \
 600           "features")                                                       \
 601                                                                             \
 602   product(bool, JavaMonitorsInStackTrace, true,                             \
 603           "Print information about Java monitor locks when the stacks are"  \
 604           "dumped")                                                         \
 605                                                                             \
 606   product_pd(bool, UseLargePages,                                           \
 607           "Use large page memory")                                          \
 608                                                                             \
 609   product_pd(bool, UseLargePagesIndividualAllocation,                       \
 610           "Allocate large pages individually for better affinity")          \
 611                                                                             \
 612   develop(bool, LargePagesIndividualAllocationInjectError, false,           \
 613           "Fail large pages individual allocation")                         \
 614                                                                             \
 615   product(bool, UseLargePagesInMetaspace, false,                            \
 616           "Use large page memory in metaspace. "                            \
 617           "Only used if UseLargePages is enabled.")                         \
 618                                                                             \
 619   product(bool, UseNUMA, false,                                             \
 620           "Use NUMA if available")                                          \
 621                                                                             \
 622   product(bool, UseNUMAInterleaving, false,                                 \
 623           "Interleave memory across NUMA nodes if available")               \
 624                                                                             \
 625   product(size_t, NUMAInterleaveGranularity, 2*M,                           \
 626           "Granularity to use for NUMA interleaving on Windows OS")         \
 627           range(os::vm_allocation_granularity(), NOT_LP64(2*G) LP64_ONLY(8192*G)) \
 628                                                                             \
 629   product(bool, ForceNUMA, false,                                           \
 630           "Force NUMA optimizations on single-node/UMA systems")            \
 631                                                                             \
 632   product(uintx, NUMAChunkResizeWeight, 20,                                 \
 633           "Percentage (0-100) used to weight the current sample when "      \
 634           "computing exponentially decaying average for "                   \
 635           "AdaptiveNUMAChunkSizing")                                        \
 636           range(0, 100)                                                     \
 637                                                                             \
 638   product(size_t, NUMASpaceResizeRate, 1*G,                                 \
 639           "Do not reallocate more than this amount per collection")         \
 640           range(0, max_uintx)                                               \
 641                                                                             \
 642   product(bool, UseAdaptiveNUMAChunkSizing, true,                           \
 643           "Enable adaptive chunk sizing for NUMA")                          \
 644                                                                             \
 645   product(bool, NUMAStats, false,                                           \
 646           "Print NUMA stats in detailed heap information")                  \
 647                                                                             \
 648   product(uintx, NUMAPageScanRate, 256,                                     \
 649           "Maximum number of pages to include in the page scan procedure")  \
 650           range(0, max_uintx)                                               \
 651                                                                             \
 652   product_pd(bool, NeedsDeoptSuspend,                                       \
 653           "True for register window machines (sparc/ia64)")                 \
 654                                                                             \
 655   product(intx, UseSSE, 99,                                                 \
 656           "Highest supported SSE instructions set on x86/x64")              \
 657           range(0, 99)                                                      \
 658                                                                             \
 659   product(bool, UseAES, false,                                              \
 660           "Control whether AES instructions can be used on x86/x64")        \
 661                                                                             \
 662   product(bool, UseSHA, false,                                              \
 663           "Control whether SHA instructions can be used "                   \
 664           "on SPARC, on ARM and on x86")                                    \
 665                                                                             \
 666   diagnostic(bool, UseGHASHIntrinsics, false,                               \
 667           "Use intrinsics for GHASH versions of crypto")                    \
 668                                                                             \
 669   product(size_t, LargePageSizeInBytes, 0,                                  \
 670           "Large page size (0 to let VM choose the page size)")             \
 671           range(0, max_uintx)                                               \
 672                                                                             \
 673   product(size_t, LargePageHeapSizeThreshold, 128*M,                        \
 674           "Use large pages if maximum heap is at least this big")           \
 675           range(0, max_uintx)                                               \
 676                                                                             \
 677   product(bool, ForceTimeHighResolution, false,                             \
 678           "Using high time resolution (for Win32 only)")                    \
 679                                                                             \
 680   develop(bool, TracePcPatching, false,                                     \
 681           "Trace usage of frame::patch_pc")                                 \
 682                                                                             \
 683   develop(bool, TraceRelocator, false,                                      \
 684           "Trace the bytecode relocator")                                   \
 685                                                                             \
 686   develop(bool, TraceLongCompiles, false,                                   \
 687           "Print out every time compilation is longer than "                \
 688           "a given threshold")                                              \
 689                                                                             \
 690   develop(bool, SafepointALot, false,                                       \
 691           "Generate a lot of safepoints. This works with "                  \
 692           "GuaranteedSafepointInterval")                                    \
 693                                                                             \
 694   product_pd(bool, BackgroundCompilation,                                   \
 695           "A thread requesting compilation is not blocked during "          \
 696           "compilation")                                                    \
 697                                                                             \
 698   product(bool, PrintVMQWaitTime, false,                                    \
 699           "Print out the waiting time in VM operation queue")               \
 700                                                                             \
 701   develop(bool, TraceOopMapGeneration, false,                               \
 702           "Show OopMapGeneration")                                          \
 703                                                                             \
 704   product(bool, MethodFlushing, true,                                       \
 705           "Reclamation of zombie and not-entrant methods")                  \
 706                                                                             \
 707   develop(bool, VerifyStack, false,                                         \
 708           "Verify stack of each thread when it is entering a runtime call") \
 709                                                                             \
 710   diagnostic(bool, ForceUnreachable, false,                                 \
 711           "Make all non code cache addresses to be unreachable by "         \
 712           "forcing use of 64bit literal fixups")                            \
 713                                                                             \
 714   notproduct(bool, StressDerivedPointers, false,                            \
 715           "Force scavenge when a derived pointer is detected on stack "     \
 716           "after rtm call")                                                 \
 717                                                                             \
 718   develop(bool, TraceDerivedPointers, false,                                \
 719           "Trace traversal of derived pointers on stack")                   \
 720                                                                             \
 721   notproduct(bool, TraceCodeBlobStacks, false,                              \
 722           "Trace stack-walk of codeblobs")                                  \
 723                                                                             \
 724   product(bool, PrintJNIResolving, false,                                   \
 725           "Used to implement -v:jni")                                       \
 726                                                                             \
 727   notproduct(bool, PrintRewrites, false,                                    \
 728           "Print methods that are being rewritten")                         \
 729                                                                             \
 730   product(bool, UseInlineCaches, true,                                      \
 731           "Use Inline Caches for virtual calls ")                           \
 732                                                                             \
 733   diagnostic(bool, InlineArrayCopy, true,                                   \
 734           "Inline arraycopy native that is known to be part of "            \
 735           "base library DLL")                                               \
 736                                                                             \
 737   diagnostic(bool, InlineObjectHash, true,                                  \
 738           "Inline Object::hashCode() native that is known to be part "      \
 739           "of base library DLL")                                            \
 740                                                                             \
 741   diagnostic(bool, InlineNatives, true,                                     \
 742           "Inline natives that are known to be part of base library DLL")   \
 743                                                                             \
 744   diagnostic(bool, InlineMathNatives, true,                                 \
 745           "Inline SinD, CosD, etc.")                                        \
 746                                                                             \
 747   diagnostic(bool, InlineClassNatives, true,                                \
 748           "Inline Class.isInstance, etc")                                   \
 749                                                                             \
 750   diagnostic(bool, InlineThreadNatives, true,                               \
 751           "Inline Thread.currentThread, etc")                               \
 752                                                                             \
 753   diagnostic(bool, InlineUnsafeOps, true,                                   \
 754           "Inline memory ops (native methods) from Unsafe")                 \
 755                                                                             \
 756   product(bool, CriticalJNINatives, true,                                   \
 757           "Check for critical JNI entry points")                            \
 758                                                                             \
 759   notproduct(bool, StressCriticalJNINatives, false,                         \
 760           "Exercise register saving code in critical natives")              \
 761                                                                             \
 762   diagnostic(bool, UseAESIntrinsics, false,                                 \
 763           "Use intrinsics for AES versions of crypto")                      \
 764                                                                             \
 765   diagnostic(bool, UseAESCTRIntrinsics, false,                              \
 766           "Use intrinsics for the paralleled version of AES/CTR crypto")    \
 767                                                                             \
 768   diagnostic(bool, UseSHA1Intrinsics, false,                                \
 769           "Use intrinsics for SHA-1 crypto hash function. "                 \
 770           "Requires that UseSHA is enabled.")                               \
 771                                                                             \
 772   diagnostic(bool, UseSHA256Intrinsics, false,                              \
 773           "Use intrinsics for SHA-224 and SHA-256 crypto hash functions. "  \
 774           "Requires that UseSHA is enabled.")                               \
 775                                                                             \
 776   diagnostic(bool, UseSHA512Intrinsics, false,                              \
 777           "Use intrinsics for SHA-384 and SHA-512 crypto hash functions. "  \
 778           "Requires that UseSHA is enabled.")                               \
 779                                                                             \
 780   diagnostic(bool, UseCRC32Intrinsics, false,                               \
 781           "use intrinsics for java.util.zip.CRC32")                         \
 782                                                                             \
 783   diagnostic(bool, UseCRC32CIntrinsics, false,                              \
 784           "use intrinsics for java.util.zip.CRC32C")                        \
 785                                                                             \
 786   diagnostic(bool, UseAdler32Intrinsics, false,                             \
 787           "use intrinsics for java.util.zip.Adler32")                       \
 788                                                                             \
 789   diagnostic(bool, UseVectorizedMismatchIntrinsic, false,                   \
 790           "Enables intrinsification of ArraysSupport.vectorizedMismatch()") \
 791                                                                             \
 792   diagnostic(ccstrlist, DisableIntrinsic, "",                               \
 793          "do not expand intrinsics whose (internal) names appear here")     \
 794                                                                             \
 795   develop(bool, TraceCallFixup, false,                                      \
 796           "Trace all call fixups")                                          \
 797                                                                             \
 798   develop(bool, DeoptimizeALot, false,                                      \
 799           "Deoptimize at every exit from the runtime system")               \
 800                                                                             \
 801   notproduct(ccstrlist, DeoptimizeOnlyAt, "",                               \
 802           "A comma separated list of bcis to deoptimize at")                \
 803                                                                             \
 804   product(bool, DeoptimizeRandom, false,                                    \
 805           "Deoptimize random frames on random exit from the runtime system")\
 806                                                                             \
 807   notproduct(bool, ZombieALot, false,                                       \
 808           "Create zombies (non-entrant) at exit from the runtime system")   \
 809                                                                             \
 810   product(bool, UnlinkSymbolsALot, false,                                   \
 811           "Unlink unreferenced symbols from the symbol table at safepoints")\
 812                                                                             \
 813   notproduct(bool, WalkStackALot, false,                                    \
 814           "Trace stack (no print) at every exit from the runtime system")   \
 815                                                                             \
 816   product(bool, Debugging, false,                                           \
 817           "Set when executing debug methods in debug.cpp "                  \
 818           "(to prevent triggering assertions)")                             \
 819                                                                             \
 820   notproduct(bool, StrictSafepointChecks, trueInDebug,                      \
 821           "Enable strict checks that safepoints cannot happen for threads " \
 822           "that use NoSafepointVerifier")                                   \
 823                                                                             \
 824   notproduct(bool, VerifyLastFrame, false,                                  \
 825           "Verify oops on last frame on entry to VM")                       \
 826                                                                             \
 827   product(bool, FailOverToOldVerifier, true,                                \
 828           "Fail over to old verifier when split verifier fails")            \
 829                                                                             \
 830   develop(bool, ShowSafepointMsgs, false,                                   \
 831           "Show message about safepoint synchronization")                   \
 832                                                                             \
 833   product(bool, SafepointTimeout, false,                                    \
 834           "Time out and warn or fail after SafepointTimeoutDelay "          \
 835           "milliseconds if failed to reach safepoint")                      \
 836                                                                             \
 837   develop(bool, DieOnSafepointTimeout, false,                               \
 838           "Die upon failure to reach safepoint (see SafepointTimeout)")     \
 839                                                                             \
 840   /* 50 retries * (5 * current_retry_count) millis = ~6.375 seconds */      \
 841   /* typically, at most a few retries are needed                    */      \
 842   product(intx, SuspendRetryCount, 50,                                      \
 843           "Maximum retry count for an external suspend request")            \
 844           range(0, max_intx)                                                \
 845                                                                             \
 846   product(intx, SuspendRetryDelay, 5,                                       \
 847           "Milliseconds to delay per retry (* current_retry_count)")        \
 848           range(0, max_intx)                                                \
 849                                                                             \
 850   product(bool, AssertOnSuspendWaitFailure, false,                          \
 851           "Assert/Guarantee on external suspend wait failure")              \
 852                                                                             \
 853   product(bool, TraceSuspendWaitFailures, false,                            \
 854           "Trace external suspend wait failures")                           \
 855                                                                             \
 856   product(bool, MaxFDLimit, true,                                           \
 857           "Bump the number of file descriptors to maximum in Solaris")      \
 858                                                                             \
 859   diagnostic(bool, LogEvents, true,                                         \
 860           "Enable the various ring buffer event logs")                      \
 861                                                                             \
 862   diagnostic(uintx, LogEventsBufferEntries, 10,                             \
 863           "Number of ring buffer event logs")                               \
 864           range(1, NOT_LP64(1*K) LP64_ONLY(1*M))                            \
 865                                                                             \
 866   product(bool, BytecodeVerificationRemote, true,                           \
 867           "Enable the Java bytecode verifier for remote classes")           \
 868                                                                             \
 869   product(bool, BytecodeVerificationLocal, false,                           \
 870           "Enable the Java bytecode verifier for local classes")            \
 871                                                                             \
 872   develop(bool, ForceFloatExceptions, trueInDebug,                          \
 873           "Force exceptions on FP stack under/overflow")                    \
 874                                                                             \
 875   develop(bool, VerifyStackAtCalls, false,                                  \
 876           "Verify that the stack pointer is unchanged after calls")         \
 877                                                                             \
 878   develop(bool, TraceJavaAssertions, false,                                 \
 879           "Trace java language assertions")                                 \
 880                                                                             \
 881   notproduct(bool, CheckAssertionStatusDirectives, false,                   \
 882           "Temporary - see javaClasses.cpp")                                \
 883                                                                             \
 884   notproduct(bool, PrintMallocFree, false,                                  \
 885           "Trace calls to C heap malloc/free allocation")                   \
 886                                                                             \
 887   notproduct(bool, VerifyCodeCache, false,                                  \
 888           "Verify code cache on memory allocation/deallocation")            \
 889                                                                             \
 890   develop(bool, UseMallocOnly, false,                                       \
 891           "Use only malloc/free for allocation (no resource area/arena)")   \
 892                                                                             \
 893   develop(bool, PrintMalloc, false,                                         \
 894           "Print all malloc/free calls")                                    \
 895                                                                             \
 896   develop(bool, PrintMallocStatistics, false,                               \
 897           "Print malloc/free statistics")                                   \
 898                                                                             \
 899   develop(bool, ZapResourceArea, trueInDebug,                               \
 900           "Zap freed resource/arena space with 0xABABABAB")                 \
 901                                                                             \
 902   notproduct(bool, ZapVMHandleArea, trueInDebug,                            \
 903           "Zap freed VM handle space with 0xBCBCBCBC")                      \
 904                                                                             \
 905   develop(bool, ZapJNIHandleArea, trueInDebug,                              \
 906           "Zap freed JNI handle space with 0xFEFEFEFE")                     \
 907                                                                             \
 908   notproduct(bool, ZapStackSegments, trueInDebug,                           \
 909           "Zap allocated/freed stack segments with 0xFADFADED")             \
 910                                                                             \
 911   develop(bool, ZapUnusedHeapArea, trueInDebug,                             \
 912           "Zap unused heap space with 0xBAADBABE")                          \
 913                                                                             \
 914   develop(bool, CheckZapUnusedHeapArea, false,                              \
 915           "Check zapping of unused heap space")                             \
 916                                                                             \
 917   develop(bool, ZapFillerObjects, trueInDebug,                              \
 918           "Zap filler objects with 0xDEAFBABE")                             \
 919                                                                             \
 920   develop(bool, PrintVMMessages, true,                                      \
 921           "Print VM messages on console")                                   \
 922                                                                             \
 923   notproduct(uintx, ErrorHandlerTest, 0,                                    \
 924           "If &gt; 0, provokes an error after VM initialization; the value "   \
 925           "determines which error to provoke. See test_error_handler() "    \
 926           "in debug.cpp.")                                                  \
 927                                                                             \
 928   notproduct(uintx, TestCrashInErrorHandler, 0,                             \
 929           "If &gt; 0, provokes an error inside VM error handler (a secondary " \
 930           "crash). see test_error_handler() in debug.cpp.")                 \
 931                                                                             \
 932   notproduct(bool, TestSafeFetchInErrorHandler, false,                      \
 933           "If true, tests SafeFetch inside error handler.")                 \
 934                                                                             \
 935   develop(bool, Verbose, false,                                             \
 936           "Print additional debugging information from other modes")        \
 937                                                                             \
 938   develop(bool, PrintMiscellaneous, false,                                  \
 939           "Print uncategorized debugging information (requires +Verbose)")  \
 940                                                                             \
 941   develop(bool, WizardMode, false,                                          \
 942           "Print much more debugging information")                          \
 943                                                                             \
 944   product(bool, ShowMessageBoxOnError, false,                               \
 945           "Keep process alive on VM fatal error")                           \
 946                                                                             \
 947   product(bool, CreateCoredumpOnCrash, true,                                \
 948           "Create core/mini dump on VM fatal error")                        \
 949                                                                             \
 950   product(uint64_t, ErrorLogTimeout, 2 * 60,                                \
 951           "Timeout, in seconds, to limit the time spent on writing an "     \
 952           "error log in case of a crash.")                                  \
 953           range(0, (uint64_t)max_jlong/1000)                                \
 954                                                                             \
 955   product_pd(bool, UseOSErrorReporting,                                     \
 956           "Let VM fatal error propagate to the OS (ie. WER on Windows)")    \
 957                                                                             \
 958   product(bool, SuppressFatalErrorMessage, false,                           \
 959           "Report NO fatal error message (avoid deadlock)")                 \
 960                                                                             \
 961   product(ccstrlist, OnError, "",                                           \
 962           "Run user-defined commands on fatal error; see VMError.cpp "      \
 963           "for examples")                                                   \
 964                                                                             \
 965   product(ccstrlist, OnOutOfMemoryError, "",                                \
 966           "Run user-defined commands on first java.lang.OutOfMemoryError")  \
 967                                                                             \
 968   manageable(bool, HeapDumpBeforeFullGC, false,                             \
 969           "Dump heap to file before any major stop-the-world GC")           \
 970                                                                             \
 971   manageable(bool, HeapDumpAfterFullGC, false,                              \
 972           "Dump heap to file after any major stop-the-world GC")            \
 973                                                                             \
 974   manageable(bool, HeapDumpOnOutOfMemoryError, false,                       \
 975           "Dump heap to file when java.lang.OutOfMemoryError is thrown")    \
 976                                                                             \
 977   manageable(ccstr, HeapDumpPath, NULL,                                     \
 978           "When HeapDumpOnOutOfMemoryError is on, the path (filename or "   \
 979           "directory) of the dump file (defaults to java_pid&lt;pid&gt;.hprof "   \
 980           "in the working directory)")                                      \
 981                                                                             \
 982   develop(bool, BreakAtWarning, false,                                      \
 983           "Execute breakpoint upon encountering VM warning")                \
 984                                                                             \
 985   develop(bool, UseFakeTimers, false,                                       \
 986           "Tell whether the VM should use system time or a fake timer")     \
 987                                                                             \
 988   product(ccstr, NativeMemoryTracking, "off",                               \
 989           "Native memory tracking options")                                 \
 990                                                                             \
 991   diagnostic(bool, PrintNMTStatistics, false,                               \
 992           "Print native memory tracking summary data if it is on")          \
 993                                                                             \
 994   diagnostic(bool, LogCompilation, false,                                   \
 995           "Log compilation activity in detail to LogFile")                  \
 996                                                                             \
 997   product(bool, PrintCompilation, false,                                    \
 998           "Print compilations")                                             \
 999                                                                             \
1000   diagnostic(bool, TraceNMethodInstalls, false,                             \
1001           "Trace nmethod installation")                                     \
1002                                                                             \
1003   diagnostic(intx, ScavengeRootsInCode, 2,                                  \
1004           "0: do not allow scavengable oops in the code cache; "            \
1005           "1: allow scavenging from the code cache; "                       \
1006           "2: emit as many constants as the compiler can see")              \
1007           range(0, 2)                                                       \
1008                                                                             \
1009   product(bool, AlwaysRestoreFPU, false,                                    \
1010           "Restore the FPU control word after every JNI call (expensive)")  \
1011                                                                             \
1012   diagnostic(bool, PrintCompilation2, false,                                \
1013           "Print additional statistics per compilation")                    \
1014                                                                             \
1015   diagnostic(bool, PrintAdapterHandlers, false,                             \
1016           "Print code generated for i2c/c2i adapters")                      \
1017                                                                             \
1018   diagnostic(bool, VerifyAdapterCalls, trueInDebug,                         \
1019           "Verify that i2c/c2i adapters are called properly")               \
1020                                                                             \
1021   develop(bool, VerifyAdapterSharing, false,                                \
1022           "Verify that the code for shared adapters is the equivalent")     \
1023                                                                             \
1024   diagnostic(bool, PrintAssembly, false,                                    \
1025           "Print assembly code (using external disassembler.so)")           \
1026                                                                             \
1027   diagnostic(ccstr, PrintAssemblyOptions, NULL,                             \
1028           "Print options string passed to disassembler.so")                 \
1029                                                                             \
1030   notproduct(bool, PrintNMethodStatistics, false,                           \
1031           "Print a summary statistic for the generated nmethods")           \
1032                                                                             \
1033   diagnostic(bool, PrintNMethods, false,                                    \
1034           "Print assembly code for nmethods when generated")                \
1035                                                                             \
1036   diagnostic(bool, PrintNativeNMethods, false,                              \
1037           "Print assembly code for native nmethods when generated")         \
1038                                                                             \
1039   develop(bool, PrintDebugInfo, false,                                      \
1040           "Print debug information for all nmethods when generated")        \
1041                                                                             \
1042   develop(bool, PrintRelocations, false,                                    \
1043           "Print relocation information for all nmethods when generated")   \
1044                                                                             \
1045   develop(bool, PrintDependencies, false,                                   \
1046           "Print dependency information for all nmethods when generated")   \
1047                                                                             \
1048   develop(bool, PrintExceptionHandlers, false,                              \
1049           "Print exception handler tables for all nmethods when generated") \
1050                                                                             \
1051   develop(bool, StressCompiledExceptionHandlers, false,                     \
1052           "Exercise compiled exception handlers")                           \
1053                                                                             \
1054   develop(bool, InterceptOSException, false,                                \
1055           "Start debugger when an implicit OS (e.g. NULL) "                 \
1056           "exception happens")                                              \
1057                                                                             \
1058   product(bool, PrintCodeCache, false,                                      \
1059           "Print the code cache memory usage when exiting")                 \
1060                                                                             \
1061   develop(bool, PrintCodeCache2, false,                                     \
1062           "Print detailed usage information on the code cache when exiting")\
1063                                                                             \
1064   product(bool, PrintCodeCacheOnCompilation, false,                         \
1065           "Print the code cache memory usage each time a method is "        \
1066           "compiled")                                                       \
1067                                                                             \
1068   diagnostic(bool, PrintStubCode, false,                                    \
1069           "Print generated stub code")                                      \
1070                                                                             \
1071   product(bool, StackTraceInThrowable, true,                                \
1072           "Collect backtrace in throwable when exception happens")          \
1073                                                                             \
1074   product(bool, OmitStackTraceInFastThrow, true,                            \
1075           "Omit backtraces for some 'hot' exceptions in optimized code")    \
1076                                                                             \
1077   product(bool, ProfilerPrintByteCodeStatistics, false,                     \
1078           "Print bytecode statistics when dumping profiler output")         \
1079                                                                             \
1080   product(bool, ProfilerRecordPC, false,                                    \
1081           "Collect ticks for each 16 byte interval of compiled code")       \
1082                                                                             \
1083   product(bool, ProfileVM, false,                                           \
1084           "Profile ticks that fall within VM (either in the VM Thread "     \
1085           "or VM code called through stubs)")                               \
1086                                                                             \
1087   product(bool, ProfileIntervals, false,                                    \
1088           "Print profiles for each interval (see ProfileIntervalsTicks)")   \
1089                                                                             \
1090   notproduct(bool, ProfilerCheckIntervals, false,                           \
1091           "Collect and print information on spacing of profiler ticks")     \
1092                                                                             \
1093   product(bool, PrintWarnings, true,                                        \
1094           "Print JVM warnings to output stream")                            \
1095                                                                             \
1096   notproduct(uintx, WarnOnStalledSpinLock, 0,                               \
1097           "Print warnings for stalled SpinLocks")                           \
1098                                                                             \
1099   product(bool, RegisterFinalizersAtInit, true,                             \
1100           "Register finalizable objects at end of Object.&lt;init&gt; or "        \
1101           "after allocation")                                               \
1102                                                                             \
1103   develop(bool, RegisterReferences, true,                                   \
1104           "Tell whether the VM should register soft/weak/final/phantom "    \
1105           "references")                                                     \
1106                                                                             \
1107   develop(bool, IgnoreRewrites, false,                                      \
1108           "Suppress rewrites of bytecodes in the oopmap generator. "        \
1109           "This is unsafe!")                                                \
1110                                                                             \
1111   develop(bool, PrintCodeCacheExtension, false,                             \
1112           "Print extension of code cache")                                  \
1113                                                                             \
1114   develop(bool, UsePrivilegedStack, true,                                   \
1115           "Enable the security JVM functions")                              \
1116                                                                             \
1117   develop(bool, ProtectionDomainVerification, true,                         \
1118           "Verify protection domain before resolution in system dictionary")\
1119                                                                             \
1120   product(bool, ClassUnloading, true,                                       \
1121           "Do unloading of classes")                                        \
1122                                                                             \
1123   product(bool, ClassUnloadingWithConcurrentMark, true,                     \
1124           "Do unloading of classes with a concurrent marking cycle")        \
1125                                                                             \
1126   develop(bool, DisableStartThread, false,                                  \
1127           "Disable starting of additional Java threads "                    \
1128           "(for debugging only)")                                           \
1129                                                                             \
1130   develop(bool, MemProfiling, false,                                        \
1131           "Write memory usage profiling to log file")                       \
1132                                                                             \
1133   notproduct(bool, PrintSystemDictionaryAtExit, false,                      \
1134           "Print the system dictionary at exit")                            \
1135                                                                             \
1136   experimental(intx, PredictedLoadedClassCount, 0,                          \
1137           "Experimental: Tune loaded class cache starting size")            \
1138                                                                             \
1139   diagnostic(bool, UnsyncloadClass, false,                                  \
1140           "Unstable: VM calls loadClass unsynchronized. Custom "            \
1141           "class loader must call VM synchronized for findClass "           \
1142           "and defineClass.")                                               \
1143                                                                             \
1144   product(bool, AlwaysLockClassLoader, false,                               \
1145           "Require the VM to acquire the class loader lock before calling " \
1146           "loadClass() even for class loaders registering "                 \
1147           "as parallel capable")                                            \
1148                                                                             \
1149   product(bool, AllowParallelDefineClass, false,                            \
1150           "Allow parallel defineClass requests for class loaders "          \
1151           "registering as parallel capable")                                \
1152                                                                             \
1153   product(bool, MustCallLoadClassInternal, false,                           \
1154           "Call loadClassInternal() rather than loadClass()")               \
1155                                                                             \
1156   product_pd(bool, DontYieldALot,                                           \
1157           "Throw away obvious excess yield calls")                          \
1158                                                                             \
1159   product(bool, ConvertSleepToYield, true,                                  \
1160           "Convert sleep(0) to thread yield ")                              \
1161                                                                             \
1162   product(bool, ConvertYieldToSleep, false,                                 \
1163           "Convert yield to a sleep of MinSleepInterval to simulate Win32 " \
1164           "behavior")                                                       \
1165                                                                             \
1166   develop(bool, UseDetachedThreads, true,                                   \
1167           "Use detached threads that are recycled upon termination "        \
1168           "(for Solaris only)")                                             \
1169                                                                             \
1170   product(bool, UseLWPSynchronization, true,                                \
1171           "Use LWP-based instead of libthread-based synchronization "       \
1172           "(SPARC only)")                                                   \
1173                                                                             \
1174   experimental(ccstr, SyncKnobs, NULL,                                      \
1175                "(Unstable) Various monitor synchronization tunables")       \
1176                                                                             \
1177   experimental(intx, EmitSync, 0,                                           \
1178                "(Unsafe, Unstable) "                                        \
1179                "Control emission of inline sync fast-path code")            \
1180                                                                             \
1181   product(intx, MonitorBound, 0, "Bound Monitor population")                \
1182           range(0, max_jint)                                                \
1183                                                                             \
1184   product(bool, MonitorInUseLists, true, "Track Monitors for Deflation")    \
1185                                                                             \
1186   experimental(intx, SyncFlags, 0, "(Unsafe, Unstable) "                    \
1187                "Experimental Sync flags")                                   \
1188                                                                             \
1189   experimental(intx, SyncVerbose, 0, "(Unstable)")                          \
1190                                                                             \
1191   diagnostic(bool, InlineNotify, true, "intrinsify subset of notify")       \
1192                                                                             \
1193   experimental(intx, ClearFPUAtPark, 0, "(Unsafe, Unstable)")               \
1194                                                                             \
1195   experimental(intx, hashCode, 5,                                           \
1196                "(Unstable) select hashCode generation algorithm")           \
1197                                                                             \
1198   product(bool, FilterSpuriousWakeups, true,                                \
1199           "When true prevents OS-level spurious, or premature, wakeups "    \
1200           "from Object.wait (Ignored for Windows)")                         \
1201                                                                             \
1202   experimental(intx, NativeMonitorTimeout, -1, "(Unstable)")                \
1203                                                                             \
1204   experimental(intx, NativeMonitorFlags, 0, "(Unstable)")                   \
1205                                                                             \
1206   experimental(intx, NativeMonitorSpinLimit, 20, "(Unstable)")              \
1207                                                                             \
1208   develop(bool, UsePthreads, false,                                         \
1209           "Use pthread-based instead of libthread-based synchronization "   \
1210           "(SPARC only)")                                                   \
1211                                                                             \
1212   product(bool, ReduceSignalUsage, false,                                   \
1213           "Reduce the use of OS signals in Java and/or the VM")             \
1214                                                                             \
1215   develop_pd(bool, ShareVtableStubs,                                        \
1216           "Share vtable stubs (smaller code but worse branch prediction")   \
1217                                                                             \
1218   develop(bool, LoadLineNumberTables, true,                                 \
1219           "Tell whether the class file parser loads line number tables")    \
1220                                                                             \
1221   develop(bool, LoadLocalVariableTables, true,                              \
1222           "Tell whether the class file parser loads local variable tables") \
1223                                                                             \
1224   develop(bool, LoadLocalVariableTypeTables, true,                          \
1225           "Tell whether the class file parser loads local variable type"    \
1226           "tables")                                                         \
1227                                                                             \
1228   product(bool, AllowUserSignalHandlers, false,                             \
1229           "Do not complain if the application installs signal handlers "    \
1230           "(Solaris &amp; Linux only)")                                         \
1231                                                                             \
1232   product(bool, UseSignalChaining, true,                                    \
1233           "Use signal-chaining to invoke signal handlers installed "        \
1234           "by the application (Solaris &amp; Linux only)")                      \
1235                                                                             \
1236   product(bool, AllowJNIEnvProxy, false,                                    \
1237           "Allow JNIEnv proxies for jdbx")                                  \
1238                                                                             \
1239   product(bool, RestoreMXCSROnJNICalls, false,                              \
1240           "Restore MXCSR when returning from JNI calls")                    \
1241                                                                             \
1242   product(bool, CheckJNICalls, false,                                       \
1243           "Verify all arguments to JNI calls")                              \
1244                                                                             \
1245   product(bool, CheckEndorsedAndExtDirs, false,                             \
1246           "Verify the endorsed and extension directories are not used")     \
1247                                                                             \
1248   product(bool, UseFastJNIAccessors, true,                                  \
1249           "Use optimized versions of Get&lt;Primitive&gt;Field")                  \
1250                                                                             \
1251   product(intx, MaxJNILocalCapacity, 65536,                                 \
1252           "Maximum allowable local JNI handle capacity to "                 \
1253           "EnsureLocalCapacity() and PushLocalFrame(), "                    \
1254           "where &lt;= 0 is unlimited, default: 65536")                        \
1255           range(min_intx, max_intx)                                         \
1256                                                                             \
1257   product(bool, EagerXrunInit, false,                                       \
1258           "Eagerly initialize -Xrun libraries; allows startup profiling, "  \
1259           "but not all -Xrun libraries may support the state of the VM "    \
1260           "at this time")                                                   \
1261                                                                             \
1262   product(bool, PreserveAllAnnotations, false,                              \
1263           "Preserve RuntimeInvisibleAnnotations as well "                   \
1264           "as RuntimeVisibleAnnotations")                                   \
1265                                                                             \
1266   develop(uintx, PreallocatedOutOfMemoryErrorCount, 4,                      \
1267           "Number of OutOfMemoryErrors preallocated with backtrace")        \
1268                                                                             \
1269   product(bool, UseXMMForArrayCopy, false,                                  \
1270           "Use SSE2 MOVQ instruction for Arraycopy")                        \
1271                                                                             \
1272   product(intx, FieldsAllocationStyle, 1,                                   \
1273           "0 - type based with oops first, "                                \
1274           "1 - with oops last, "                                            \
1275           "2 - oops in super and sub classes are together")                 \
1276           range(0, 2)                                                       \
1277                                                                             \
1278   product(bool, CompactFields, true,                                        \
1279           "Allocate nonstatic fields in gaps between previous fields")      \
1280                                                                             \
1281   notproduct(bool, PrintFieldLayout, false,                                 \
1282           "Print field layout for each class")                              \
1283                                                                             \
1284   /* Need to limit the extent of the padding to reasonable size.          */\
1285   /* 8K is well beyond the reasonable HW cache line size, even with       */\
1286   /* aggressive prefetching, while still leaving the room for segregating */\
1287   /* among the distinct pages.                                            */\
1288   product(intx, ContendedPaddingWidth, 128,                                 \
1289           "How many bytes to pad the fields/classes marked @Contended with")\
1290           range(0, 8192)                                                    \
1291           constraint(ContendedPaddingWidthConstraintFunc,AfterErgo)         \
1292                                                                             \
1293   product(bool, EnableContended, true,                                      \
1294           "Enable @Contended annotation support")                           \
1295                                                                             \
1296   product(bool, RestrictContended, true,                                    \
1297           "Restrict @Contended to trusted classes")                         \
1298                                                                             \
1299   product(bool, UseBiasedLocking, true,                                     \
1300           "Enable biased locking in JVM")                                   \
1301                                                                             \
1302   product(intx, BiasedLockingStartupDelay, 4000,                            \
1303           "Number of milliseconds to wait before enabling biased locking")  \
1304           range(0, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) \
1305           constraint(BiasedLockingStartupDelayFunc,AfterErgo)               \
1306                                                                             \
1307   diagnostic(bool, PrintBiasedLockingStatistics, false,                     \
1308           "Print statistics of biased locking in JVM")                      \
1309                                                                             \
1310   product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \
1311           "Threshold of number of revocations per type to try to "          \
1312           "rebias all objects in the heap of that type")                    \
1313           range(0, max_intx)                                                \
1314           constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \
1315                                                                             \
1316   product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \
1317           "Threshold of number of revocations per type to permanently "     \
1318           "revoke biases of all objects in the heap of that type")          \
1319           range(0, max_intx)                                                \
1320           constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)        \
1321                                                                             \
1322   product(intx, BiasedLockingDecayTime, 25000,                              \
1323           "Decay time (in milliseconds) to re-enable bulk rebiasing of a "  \
1324           "type after previous bulk rebias")                                \
1325           range(500, max_intx)                                              \
1326           constraint(BiasedLockingDecayTimeFunc,AfterErgo)                  \
1327                                                                             \
1328   product(bool, ExitOnOutOfMemoryError, false,                              \
1329           "JVM exits on the first occurrence of an out-of-memory error")    \
1330                                                                             \
1331   product(bool, CrashOnOutOfMemoryError, false,                             \
1332           "JVM aborts, producing an error log and core/mini dump, on the "  \
1333           "first occurrence of an out-of-memory error")                     \
1334                                                                             \
1335   /* tracing */                                                             \
1336                                                                             \
1337   develop(bool, StressRewriter, false,                                      \
1338           "Stress linktime bytecode rewriting")                             \
1339                                                                             \
1340   product(ccstr, TraceJVMTI, NULL,                                          \
1341           "Trace flags for JVMTI functions and events")                     \
1342                                                                             \
1343   /* This option can change an EMCP method into an obsolete method. */      \
1344   /* This can affect tests that except specific methods to be EMCP. */      \
1345   /* This option should be used with caution.                       */      \
1346   product(bool, StressLdcRewrite, false,                                    \
1347           "Force ldc -&gt; ldc_w rewrite during RedefineClasses")              \
1348                                                                             \
1349   /* change to false by default sometime after Mustang */                   \
1350   product(bool, VerifyMergedCPBytecodes, true,                              \
1351           "Verify bytecodes after RedefineClasses constant pool merging")   \
1352                                                                             \
1353   develop(bool, TraceBytecodes, false,                                      \
1354           "Trace bytecode execution")                                       \
1355                                                                             \
1356   develop(bool, TraceICs, false,                                            \
1357           "Trace inline cache changes")                                     \
1358                                                                             \
1359   notproduct(bool, TraceInvocationCounterOverflow, false,                   \
1360           "Trace method invocation counter overflow")                       \
1361                                                                             \
1362   develop(bool, TraceInlineCacheClearing, false,                            \
1363           "Trace clearing of inline caches in nmethods")                    \
1364                                                                             \
1365   develop(bool, TraceDependencies, false,                                   \
1366           "Trace dependencies")                                             \
1367                                                                             \
1368   develop(bool, VerifyDependencies, trueInDebug,                            \
1369           "Exercise and verify the compilation dependency mechanism")       \
1370                                                                             \
1371   develop(bool, TraceNewOopMapGeneration, false,                            \
1372           "Trace OopMapGeneration")                                         \
1373                                                                             \
1374   develop(bool, TraceNewOopMapGenerationDetailed, false,                    \
1375           "Trace OopMapGeneration: print detailed cell states")             \
1376                                                                             \
1377   develop(bool, TimeOopMap, false,                                          \
1378           "Time calls to GenerateOopMap::compute_map() in sum")             \
1379                                                                             \
1380   develop(bool, TimeOopMap2, false,                                         \
1381           "Time calls to GenerateOopMap::compute_map() individually")       \
1382                                                                             \
1383   develop(bool, TraceOopMapRewrites, false,                                 \
1384           "Trace rewriting of method oops during oop map generation")       \
1385                                                                             \
1386   develop(bool, TraceICBuffer, false,                                       \
1387           "Trace usage of IC buffer")                                       \
1388                                                                             \
1389   develop(bool, TraceCompiledIC, false,                                     \
1390           "Trace changes of compiled IC")                                   \
1391                                                                             \
1392   /* gc */                                                                  \
1393                                                                             \
1394   product(bool, UseSerialGC, false,                                         \
1395           "Use the Serial garbage collector")                               \
1396                                                                             \
1397   product(bool, UseG1GC, false,                                             \
1398           "Use the Garbage-First garbage collector")                        \
1399                                                                             \
1400   product(bool, UseParallelGC, false,                                       \
1401           "Use the Parallel Scavenge garbage collector")                    \
1402                                                                             \
1403   product(bool, UseParallelOldGC, false,                                    \
1404           "Use the Parallel Old garbage collector")                         \
1405                                                                             \
1406   product(uintx, HeapMaximumCompactionInterval, 20,                         \
1407           "How often should we maximally compact the heap (not allowing "   \
1408           "any dead space)")                                                \
1409           range(0, max_uintx)                                               \
1410                                                                             \
1411   product(uintx, HeapFirstMaximumCompactionCount, 3,                        \
1412           "The collection count for the first maximum compaction")          \
1413           range(0, max_uintx)                                               \
1414                                                                             \
1415   product(bool, UseMaximumCompactionOnSystemGC, true,                       \
1416           "Use maximum compaction in the Parallel Old garbage collector "   \
1417           "for a system GC")                                                \
1418                                                                             \
1419   product(uintx, ParallelOldDeadWoodLimiterMean, 50,                        \
1420           "The mean used by the parallel compact dead wood "                \
1421           "limiter (a number between 0-100)")                               \
1422           range(0, 100)                                                     \
1423                                                                             \
1424   product(uintx, ParallelOldDeadWoodLimiterStdDev, 80,                      \
1425           "The standard deviation used by the parallel compact dead wood "  \
1426           "limiter (a number between 0-100)")                               \
1427           range(0, 100)                                                     \
1428                                                                             \
1429   product(uint, ParallelGCThreads, 0,                                       \
1430           "Number of parallel threads parallel gc will use")                \
1431           constraint(ParallelGCThreadsConstraintFunc,AfterErgo)             \
1432                                                                             \
1433   diagnostic(bool, UseSemaphoreGCThreadsSynchronization, true,              \
1434             "Use semaphore synchronization for the GC Threads, "            \
1435             "instead of synchronization based on mutexes")                  \
1436                                                                             \
1437   product(bool, UseDynamicNumberOfGCThreads, false,                         \
1438           "Dynamically choose the number of parallel threads "              \
1439           "parallel gc will use")                                           \
1440                                                                             \
1441   diagnostic(bool, InjectGCWorkerCreationFailure, false,                    \
1442              "Inject thread creation failures for "                         \
1443              "UseDynamicNumberOfGCThreads")                                 \
1444                                                                             \
1445   diagnostic(bool, ForceDynamicNumberOfGCThreads, false,                    \
1446           "Force dynamic selection of the number of "                       \
1447           "parallel threads parallel gc will use to aid debugging")         \
1448                                                                             \
1449   product(size_t, HeapSizePerGCThread, ScaleForWordSize(64*M),              \
1450           "Size of heap (bytes) per GC thread used in calculating the "     \
1451           "number of GC threads")                                           \
1452           range((size_t)os::vm_page_size(), (size_t)max_uintx)              \
1453                                                                             \
1454   product(uint, ConcGCThreads, 0,                                           \
1455           "Number of threads concurrent gc will use")                       \
1456           constraint(ConcGCThreadsConstraintFunc,AfterErgo)                 \
1457                                                                             \
1458   product(uintx, GCTaskTimeStampEntries, 200,                               \
1459           "Number of time stamp entries per gc worker thread")              \
1460           range(1, max_uintx)                                               \
1461                                                                             \
1462   product(bool, AlwaysTenure, false,                                        \
1463           "Always tenure objects in eden (ParallelGC only)")                \
1464                                                                             \
1465   product(bool, NeverTenure, false,                                         \
1466           "Never tenure objects in eden, may tenure on overflow "           \
1467           "(ParallelGC only)")                                              \
1468                                                                             \
1469   product(bool, ScavengeBeforeFullGC, true,                                 \
1470           "Scavenge youngest generation before each full GC.")              \
1471                                                                             \
1472   product(bool, UseConcMarkSweepGC, false,                                  \
1473           "Use Concurrent Mark-Sweep GC in the old generation")             \
1474                                                                             \
1475   product(bool, ExplicitGCInvokesConcurrent, false,                         \
1476           "A System.gc() request invokes a concurrent collection; "         \
1477           "(effective only when using concurrent collectors)")              \
1478                                                                             \
1479   product(bool, ExplicitGCInvokesConcurrentAndUnloadsClasses, false,        \
1480           "A System.gc() request invokes a concurrent collection and "      \
1481           "also unloads classes during such a concurrent gc cycle "         \
1482           "(effective only when UseConcMarkSweepGC)")                       \
1483                                                                             \
1484   product(bool, GCLockerInvokesConcurrent, false,                           \
1485           "The exit of a JNI critical section necessitating a scavenge, "   \
1486           "also kicks off a background concurrent collection")              \
1487                                                                             \
1488   product(uintx, GCLockerEdenExpansionPercent, 5,                           \
1489           "How much the GC can expand the eden by while the GC locker "     \
1490           "is active (as a percentage)")                                    \
1491           range(0, 100)                                                     \
1492                                                                             \
1493   diagnostic(uintx, GCLockerRetryAllocationCount, 2,                        \
1494           "Number of times to retry allocations when "                      \
1495           "blocked by the GC locker")                                       \
1496           range(0, max_uintx)                                               \
1497                                                                             \
1498   product(bool, UseCMSBestFit, true,                                        \
1499           "Use CMS best fit allocation strategy")                           \
1500                                                                             \
1501   product(bool, UseParNewGC, false,                                         \
1502           "Use parallel threads in the new generation")                     \
1503                                                                             \
1504   product(uintx, ParallelGCBufferWastePct, 10,                              \
1505           "Wasted fraction of parallel allocation buffer")                  \
1506           range(0, 100)                                                     \
1507                                                                             \
1508   product(uintx, TargetPLABWastePct, 10,                                    \
1509           "Target wasted space in last buffer as percent of overall "       \
1510           "allocation")                                                     \
1511           range(1, 100)                                                     \
1512                                                                             \
1513   product(uintx, PLABWeight, 75,                                            \
1514           "Percentage (0-100) used to weight the current sample when "      \
1515           "computing exponentially decaying average for ResizePLAB")        \
1516           range(0, 100)                                                     \
1517                                                                             \
1518   product(bool, ResizePLAB, true,                                           \
1519           "Dynamically resize (survivor space) promotion LAB's")            \
1520                                                                             \
1521   product(int, ParGCArrayScanChunk, 50,                                     \
1522           "Scan a subset of object array and push remainder, if array is "  \
1523           "bigger than this")                                               \
1524           range(1, max_jint/3)                                              \
1525                                                                             \
1526   product(bool, ParGCUseLocalOverflow, false,                               \
1527           "Instead of a global overflow list, use local overflow stacks")   \
1528                                                                             \
1529   product(bool, ParGCTrimOverflow, true,                                    \
1530           "Eagerly trim the local overflow lists "                          \
1531           "(when ParGCUseLocalOverflow)")                                   \
1532                                                                             \
1533   notproduct(bool, ParGCWorkQueueOverflowALot, false,                       \
1534           "Simulate work queue overflow in ParNew")                         \
1535                                                                             \
1536   notproduct(uintx, ParGCWorkQueueOverflowInterval, 1000,                   \
1537           "An `interval' counter that determines how frequently "           \
1538           "we simulate overflow; a smaller number increases frequency")     \
1539                                                                             \
1540   product(uintx, ParGCDesiredObjsFromOverflowList, 20,                      \
1541           "The desired number of objects to claim from the overflow list")  \
1542           range(0, max_uintx)                                               \
1543                                                                             \
1544   diagnostic(uintx, ParGCStridesPerThread, 2,                               \
1545           "The number of strides per worker thread that we divide up the "  \
1546           "card table scanning work into")                                  \
1547           range(1, max_uintx)                                               \
1548           constraint(ParGCStridesPerThreadConstraintFunc,AfterErgo)         \
1549                                                                             \
1550   diagnostic(intx, ParGCCardsPerStrideChunk, 256,                           \
1551           "The number of cards in each chunk of the parallel chunks used "  \
1552           "during card table scanning")                                     \
1553           range(1, max_intx)                                                \
1554           constraint(ParGCCardsPerStrideChunkConstraintFunc,AfterMemoryInit)\
1555                                                                             \
1556   product(uintx, OldPLABWeight, 50,                                         \
1557           "Percentage (0-100) used to weight the current sample when "      \
1558           "computing exponentially decaying average for resizing "          \
1559           "OldPLABSize")                                                    \
1560           range(0, 100)                                                     \
1561                                                                             \
1562   product(bool, ResizeOldPLAB, true,                                        \
1563           "Dynamically resize (old gen) promotion LAB's")                   \
1564                                                                             \
1565   product(size_t, CMSOldPLABMax, 1024,                                      \
1566           "Maximum size of CMS gen promotion LAB caches per worker "        \
1567           "per block size")                                                 \
1568           range(1, max_uintx)                                               \
1569           constraint(CMSOldPLABMaxConstraintFunc,AfterMemoryInit)           \
1570                                                                             \
1571   product(size_t, CMSOldPLABMin, 16,                                        \
1572           "Minimum size of CMS gen promotion LAB caches per worker "        \
1573           "per block size")                                                 \
1574           range(1, max_uintx)                                               \
1575           constraint(CMSOldPLABMinConstraintFunc,AfterMemoryInit)           \
1576                                                                             \
1577   product(uintx, CMSOldPLABNumRefills, 4,                                   \
1578           "Nominal number of refills of CMS gen promotion LAB cache "       \
1579           "per worker per block size")                                      \
1580           range(1, max_uintx)                                               \
1581                                                                             \
1582   product(bool, CMSOldPLABResizeQuicker, false,                             \
1583           "React on-the-fly during a scavenge to a sudden "                 \
1584           "change in block demand rate")                                    \
1585                                                                             \
1586   product(uintx, CMSOldPLABToleranceFactor, 4,                              \
1587           "The tolerance of the phase-change detector for on-the-fly "      \
1588           "PLAB resizing during a scavenge")                                \
1589           range(1, max_uintx)                                               \
1590                                                                             \
1591   product(uintx, CMSOldPLABReactivityFactor, 2,                             \
1592           "The gain in the feedback loop for on-the-fly PLAB resizing "     \
1593           "during a scavenge")                                              \
1594           range(1, max_uintx)                                               \
1595                                                                             \
1596   product(bool, AlwaysPreTouch, false,                                      \
1597           "Force all freshly committed pages to be pre-touched")            \
1598                                                                             \
1599   product_pd(size_t, CMSYoungGenPerWorker,                                  \
1600           "The maximum size of young gen chosen by default per GC worker "  \
1601           "thread available")                                               \
1602           range(1, max_uintx)                                               \
1603                                                                             \
1604   product(uintx, CMSIncrementalSafetyFactor, 10,                            \
1605           "Percentage (0-100) used to add conservatism when computing the " \
1606           "duty cycle")                                                     \
1607           range(0, 100)                                                     \
1608                                                                             \
1609   product(uintx, CMSExpAvgFactor, 50,                                       \
1610           "Percentage (0-100) used to weight the current sample when "      \
1611           "computing exponential averages for CMS statistics")              \
1612           range(0, 100)                                                     \
1613                                                                             \
1614   product(uintx, CMS_FLSWeight, 75,                                         \
1615           "Percentage (0-100) used to weight the current sample when "      \
1616           "computing exponentially decaying averages for CMS FLS "          \
1617           "statistics")                                                     \
1618           range(0, 100)                                                     \
1619                                                                             \
1620   product(uintx, CMS_FLSPadding, 1,                                         \
1621           "The multiple of deviation from mean to use for buffering "       \
1622           "against volatility in free list demand")                         \
1623           range(0, max_juint)                                               \
1624                                                                             \
1625   product(uintx, FLSCoalescePolicy, 2,                                      \
1626           "CMS: aggressiveness level for coalescing, increasing "           \
1627           "from 0 to 4")                                                    \
1628           range(0, 4)                                                       \
1629                                                                             \
1630   product(bool, FLSAlwaysCoalesceLarge, false,                              \
1631           "CMS: larger free blocks are always available for coalescing")    \
1632                                                                             \
1633   product(double, FLSLargestBlockCoalesceProximity, 0.99,                   \
1634           "CMS: the smaller the percentage the greater the coalescing "     \
1635           "force")                                                          \
1636           range(0.0, 1.0)                                                   \
1637                                                                             \
1638   product(double, CMSSmallCoalSurplusPercent, 1.05,                         \
1639           "CMS: the factor by which to inflate estimated demand of small "  \
1640           "block sizes to prevent coalescing with an adjoining block")      \
1641           range(0.0, DBL_MAX)                                               \
1642                                                                             \
1643   product(double, CMSLargeCoalSurplusPercent, 0.95,                         \
1644           "CMS: the factor by which to inflate estimated demand of large "  \
1645           "block sizes to prevent coalescing with an adjoining block")      \
1646           range(0.0, DBL_MAX)                                               \
1647                                                                             \
1648   product(double, CMSSmallSplitSurplusPercent, 1.10,                        \
1649           "CMS: the factor by which to inflate estimated demand of small "  \
1650           "block sizes to prevent splitting to supply demand for smaller "  \
1651           "blocks")                                                         \
1652           range(0.0, DBL_MAX)                                               \
1653                                                                             \
1654   product(double, CMSLargeSplitSurplusPercent, 1.00,                        \
1655           "CMS: the factor by which to inflate estimated demand of large "  \
1656           "block sizes to prevent splitting to supply demand for smaller "  \
1657           "blocks")                                                         \
1658           range(0.0, DBL_MAX)                                               \
1659                                                                             \
1660   product(bool, CMSExtrapolateSweep, false,                                 \
1661           "CMS: cushion for block demand during sweep")                     \
1662                                                                             \
1663   product(uintx, CMS_SweepWeight, 75,                                       \
1664           "Percentage (0-100) used to weight the current sample when "      \
1665           "computing exponentially decaying average for inter-sweep "       \
1666           "duration")                                                       \
1667           range(0, 100)                                                     \
1668                                                                             \
1669   product(uintx, CMS_SweepPadding, 1,                                       \
1670           "The multiple of deviation from mean to use for buffering "       \
1671           "against volatility in inter-sweep duration")                     \
1672           range(0, max_juint)                                               \
1673                                                                             \
1674   product(uintx, CMS_SweepTimerThresholdMillis, 10,                         \
1675           "Skip block flux-rate sampling for an epoch unless inter-sweep "  \
1676           "duration exceeds this threshold in milliseconds")                \
1677           range(0, max_uintx)                                               \
1678                                                                             \
1679   product(bool, CMSClassUnloadingEnabled, true,                             \
1680           "Whether class unloading enabled when using CMS GC")              \
1681                                                                             \
1682   product(uintx, CMSClassUnloadingMaxInterval, 0,                           \
1683           "When CMS class unloading is enabled, the maximum CMS cycle "     \
1684           "count for which classes may not be unloaded")                    \
1685           range(0, max_uintx)                                               \
1686                                                                             \
1687   product(uintx, CMSIndexedFreeListReplenish, 4,                            \
1688           "Replenish an indexed free list with this number of chunks")      \
1689           range(1, max_uintx)                                               \
1690                                                                             \
1691   product(bool, CMSReplenishIntermediate, true,                             \
1692           "Replenish all intermediate free-list caches")                    \
1693                                                                             \
1694   product(bool, CMSSplitIndexedFreeListBlocks, true,                        \
1695           "When satisfying batched demand, split blocks from the "          \
1696           "IndexedFreeList whose size is a multiple of requested size")     \
1697                                                                             \
1698   product(bool, CMSLoopWarn, false,                                         \
1699           "Warn in case of excessive CMS looping")                          \
1700                                                                             \
1701   /* where does the range max value of (max_jint - 1) come from? */         \
1702   product(size_t, MarkStackSizeMax, NOT_LP64(4*M) LP64_ONLY(512*M),         \
1703           "Maximum size of marking stack")                                  \
1704           range(1, (max_jint - 1))                                          \
1705                                                                             \
1706   product(size_t, MarkStackSize, NOT_LP64(32*K) LP64_ONLY(4*M),             \
1707           "Size of marking stack")                                          \
1708           constraint(MarkStackSizeConstraintFunc,AfterErgo)                 \
1709                                                                             \
1710   notproduct(bool, CMSMarkStackOverflowALot, false,                         \
1711           "Simulate frequent marking stack / work queue overflow")          \
1712                                                                             \
1713   notproduct(uintx, CMSMarkStackOverflowInterval, 1000,                     \
1714           "An \"interval\" counter that determines how frequently "         \
1715           "to simulate overflow; a smaller number increases frequency")     \
1716                                                                             \
1717   product(uintx, CMSMaxAbortablePrecleanLoops, 0,                           \
1718           "Maximum number of abortable preclean iterations, if &gt; 0")        \
1719           range(0, max_uintx)                                               \
1720                                                                             \
1721   product(intx, CMSMaxAbortablePrecleanTime, 5000,                          \
1722           "Maximum time in abortable preclean (in milliseconds)")           \
1723           range(0, max_intx)                                                \
1724                                                                             \
1725   product(uintx, CMSAbortablePrecleanMinWorkPerIteration, 100,              \
1726           "Nominal minimum work per abortable preclean iteration")          \
1727           range(0, max_uintx)                                               \
1728                                                                             \
1729   manageable(intx, CMSAbortablePrecleanWaitMillis, 100,                     \
1730           "Time that we sleep between iterations when not given "           \
1731           "enough work per iteration")                                      \
1732           range(0, max_intx)                                                \
1733                                                                             \
1734   /* 4096 = CardTableModRefBS::card_size_in_words * BitsPerWord */          \
1735   product(size_t, CMSRescanMultiple, 32,                                    \
1736           "Size (in cards) of CMS parallel rescan task")                    \
1737           range(1, SIZE_MAX / 4096)                                         \
1738           constraint(CMSRescanMultipleConstraintFunc,AfterMemoryInit)       \
1739                                                                             \
1740   /* 4096 = CardTableModRefBS::card_size_in_words * BitsPerWord */          \
1741   product(size_t, CMSConcMarkMultiple, 32,                                  \
1742           "Size (in cards) of CMS concurrent MT marking task")              \
1743           range(1, SIZE_MAX / 4096)                                         \
1744           constraint(CMSConcMarkMultipleConstraintFunc,AfterMemoryInit)     \
1745                                                                             \
1746   product(bool, CMSAbortSemantics, false,                                   \
1747           "Whether abort-on-overflow semantics is implemented")             \
1748                                                                             \
1749   product(bool, CMSParallelInitialMarkEnabled, true,                        \
1750           "Use the parallel initial mark.")                                 \
1751                                                                             \
1752   product(bool, CMSParallelRemarkEnabled, true,                             \
1753           "Whether parallel remark enabled (only if ParNewGC)")             \
1754                                                                             \
1755   product(bool, CMSParallelSurvivorRemarkEnabled, true,                     \
1756           "Whether parallel remark of survivor space "                      \
1757           "enabled (effective only if CMSParallelRemarkEnabled)")           \
1758                                                                             \
1759   product(bool, CMSPLABRecordAlways, true,                                  \
1760           "Always record survivor space PLAB boundaries (effective only "   \
1761           "if CMSParallelSurvivorRemarkEnabled)")                           \
1762                                                                             \
1763   product(bool, CMSEdenChunksRecordAlways, true,                            \
1764           "Always record eden chunks used for the parallel initial mark "   \
1765           "or remark of eden")                                              \
1766                                                                             \
1767   product(bool, CMSConcurrentMTEnabled, true,                               \
1768           "Whether multi-threaded concurrent work enabled "                 \
1769           "(effective only if ParNewGC)")                                   \
1770                                                                             \
1771   product(bool, CMSPrecleaningEnabled, true,                                \
1772           "Whether concurrent precleaning enabled")                         \
1773                                                                             \
1774   product(uintx, CMSPrecleanIter, 3,                                        \
1775           "Maximum number of precleaning iteration passes")                 \
1776           range(0, 9)                                                       \
1777                                                                             \
1778   product(uintx, CMSPrecleanDenominator, 3,                                 \
1779           "CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence " \
1780           "ratio")                                                          \
1781           range(1, max_uintx)                                               \
1782           constraint(CMSPrecleanDenominatorConstraintFunc,AfterErgo)        \
1783                                                                             \
1784   product(uintx, CMSPrecleanNumerator, 2,                                   \
1785           "CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence " \
1786           "ratio")                                                          \
1787           range(0, max_uintx-1)                                             \
1788           constraint(CMSPrecleanNumeratorConstraintFunc,AfterErgo)          \
1789                                                                             \
1790   product(bool, CMSPrecleanRefLists1, true,                                 \
1791           "Preclean ref lists during (initial) preclean phase")             \
1792                                                                             \
1793   product(bool, CMSPrecleanRefLists2, false,                                \
1794           "Preclean ref lists during abortable preclean phase")             \
1795                                                                             \
1796   product(bool, CMSPrecleanSurvivors1, false,                               \
1797           "Preclean survivors during (initial) preclean phase")             \
1798                                                                             \
1799   product(bool, CMSPrecleanSurvivors2, true,                                \
1800           "Preclean survivors during abortable preclean phase")             \
1801                                                                             \
1802   product(uintx, CMSPrecleanThreshold, 1000,                                \
1803           "Do not iterate again if number of dirty cards is less than this")\
1804           range(100, max_uintx)                                             \
1805                                                                             \
1806   product(bool, CMSCleanOnEnter, true,                                      \
1807           "Clean-on-enter optimization for reducing number of dirty cards") \
1808                                                                             \
1809   product(uintx, CMSRemarkVerifyVariant, 1,                                 \
1810           "Choose variant (1,2) of verification following remark")          \
1811           range(1, 2)                                                       \
1812                                                                             \
1813   product(size_t, CMSScheduleRemarkEdenSizeThreshold, 2*M,                  \
1814           "If Eden size is below this, do not try to schedule remark")      \
1815           range(0, max_uintx)                                               \
1816                                                                             \
1817   product(uintx, CMSScheduleRemarkEdenPenetration, 50,                      \
1818           "The Eden occupancy percentage (0-100) at which "                 \
1819           "to try and schedule remark pause")                               \
1820           range(0, 100)                                                     \
1821                                                                             \
1822   product(uintx, CMSScheduleRemarkSamplingRatio, 5,                         \
1823           "Start sampling eden top at least before young gen "              \
1824           "occupancy reaches 1/&lt;ratio&gt; of the size at which "               \
1825           "we plan to schedule remark")                                     \
1826           range(1, max_uintx)                                               \
1827                                                                             \
1828   product(uintx, CMSSamplingGrain, 16*K,                                    \
1829           "The minimum distance between eden samples for CMS (see above)")  \
1830           range(ObjectAlignmentInBytes, max_uintx)                          \
1831           constraint(CMSSamplingGrainConstraintFunc,AfterMemoryInit)        \
1832                                                                             \
1833   product(bool, CMSScavengeBeforeRemark, false,                             \
1834           "Attempt scavenge before the CMS remark step")                    \
1835                                                                             \
1836   product(uintx, CMSWorkQueueDrainThreshold, 10,                            \
1837           "Don't drain below this size per parallel worker/thief")          \
1838           range(1, max_juint)                                               \
1839           constraint(CMSWorkQueueDrainThresholdConstraintFunc,AfterErgo)    \
1840                                                                             \
1841   manageable(intx, CMSWaitDuration, 2000,                                   \
1842           "Time in milliseconds that CMS thread waits for young GC")        \
1843           range(min_jint, max_jint)                                         \
1844                                                                             \
1845   develop(uintx, CMSCheckInterval, 1000,                                    \
1846           "Interval in milliseconds that CMS thread checks if it "          \
1847           "should start a collection cycle")                                \
1848                                                                             \
1849   product(bool, CMSYield, true,                                             \
1850           "Yield between steps of CMS")                                     \
1851                                                                             \
1852   product(size_t, CMSBitMapYieldQuantum, 10*M,                              \
1853           "Bitmap operations should process at most this many bits "        \
1854           "between yields")                                                 \
1855           range(1, max_uintx)                                               \
1856           constraint(CMSBitMapYieldQuantumConstraintFunc,AfterMemoryInit)   \
1857                                                                             \
1858   product(bool, CMSPrintChunksInDump, false,                                \
1859           "If logging for the \"gc\" and \"promotion\" tags is enabled on"  \
1860           "trace level include more detailed information about the"         \
1861           "free chunks")                \
1862                                                                             \
1863   product(bool, CMSPrintObjectsInDump, false,                               \
1864           "If logging for the \"gc\" and \"promotion\" tags is enabled on"  \
1865           "trace level include more detailed information about the"         \
1866           "allocated objects")                                              \
1867                                                                             \
1868   diagnostic(bool, FLSVerifyAllHeapReferences, false,                       \
1869           "Verify that all references across the FLS boundary "             \
1870           "are to valid objects")                                           \
1871                                                                             \
1872   diagnostic(bool, FLSVerifyLists, false,                                   \
1873           "Do lots of (expensive) FreeListSpace verification")              \
1874                                                                             \
1875   diagnostic(bool, FLSVerifyIndexTable, false,                              \
1876           "Do lots of (expensive) FLS index table verification")            \
1877                                                                             \
1878   develop(bool, FLSVerifyDictionary, false,                                 \
1879           "Do lots of (expensive) FLS dictionary verification")             \
1880                                                                             \
1881   develop(bool, VerifyBlockOffsetArray, false,                              \
1882           "Do (expensive) block offset array verification")                 \
1883                                                                             \
1884   diagnostic(bool, BlockOffsetArrayUseUnallocatedBlock, false,              \
1885           "Maintain _unallocated_block in BlockOffsetArray "                \
1886           "(currently applicable only to CMS collector)")                   \
1887                                                                             \
1888   product(intx, RefDiscoveryPolicy, 0,                                      \
1889           "Select type of reference discovery policy: "                     \
1890           "reference-based(0) or referent-based(1)")                        \
1891           range(ReferenceProcessor::DiscoveryPolicyMin,                     \
1892                 ReferenceProcessor::DiscoveryPolicyMax)                     \
1893                                                                             \
1894   product(bool, ParallelRefProcEnabled, false,                              \
1895           "Enable parallel reference processing whenever possible")         \
1896                                                                             \
1897   product(bool, ParallelRefProcBalancingEnabled, true,                      \
1898           "Enable balancing of reference processing queues")                \
1899                                                                             \
1900   product(uintx, CMSTriggerRatio, 80,                                       \
1901           "Percentage of MinHeapFreeRatio in CMS generation that is "       \
1902           "allocated before a CMS collection cycle commences")              \
1903           range(0, 100)                                                     \
1904                                                                             \
1905   product(uintx, CMSBootstrapOccupancy, 50,                                 \
1906           "Percentage CMS generation occupancy at which to "                \
1907           "initiate CMS collection for bootstrapping collection stats")     \
1908           range(0, 100)                                                     \
1909                                                                             \
1910   product(intx, CMSInitiatingOccupancyFraction, -1,                         \
1911           "Percentage CMS generation occupancy to start a CMS collection "  \
1912           "cycle. A negative value means that CMSTriggerRatio is used")     \
1913           range(min_intx, 100)                                              \
1914                                                                             \
1915   product(uintx, InitiatingHeapOccupancyPercent, 45,                        \
1916           "The percent occupancy (IHOP) of the current old generation "     \
1917           "capacity above which a concurrent mark cycle will be initiated " \
1918           "Its value may change over time if adaptive IHOP is enabled, "    \
1919           "otherwise the value remains constant. "                          \
1920           "In the latter case a value of 0 will result as frequent as "     \
1921           "possible concurrent marking cycles. A value of 100 disables "    \
1922           "concurrent marking. "                                            \
1923           "Fragmentation waste in the old generation is not considered "    \
1924           "free space in this calculation. (G1 collector only)")            \
1925           range(0, 100)                                                     \
1926                                                                             \
1927   manageable(intx, CMSTriggerInterval, -1,                                  \
1928           "Commence a CMS collection cycle (at least) every so many "       \
1929           "milliseconds (0 permanently, -1 disabled)")                      \
1930           range(-1, max_intx)                                               \
1931                                                                             \
1932   product(bool, UseCMSInitiatingOccupancyOnly, false,                       \
1933           "Only use occupancy as a criterion for starting a CMS collection")\
1934                                                                             \
1935   product(uintx, CMSIsTooFullPercentage, 98,                                \
1936           "An absolute ceiling above which CMS will always consider the "   \
1937           "unloading of classes when class unloading is enabled")           \
1938           range(0, 100)                                                     \
1939                                                                             \
1940   develop(bool, CMSTestInFreeList, false,                                   \
1941           "Check if the coalesced range is already in the "                 \
1942           "free lists as claimed")                                          \
1943                                                                             \
1944   notproduct(bool, CMSVerifyReturnedBytes, false,                           \
1945           "Check that all the garbage collected was returned to the "       \
1946           "free lists")                                                     \
1947                                                                             \
1948   notproduct(bool, ScavengeALot, false,                                     \
1949           "Force scavenge at every Nth exit from the runtime system "       \
1950           "(N=ScavengeALotInterval)")                                       \
1951                                                                             \
1952   develop(bool, FullGCALot, false,                                          \
1953           "Force full gc at every Nth exit from the runtime system "        \
1954           "(N=FullGCALotInterval)")                                         \
1955                                                                             \
1956   notproduct(bool, GCALotAtAllSafepoints, false,                            \
1957           "Enforce ScavengeALot/GCALot at all potential safepoints")        \
1958                                                                             \
1959   notproduct(bool, PromotionFailureALot, false,                             \
1960           "Use promotion failure handling on every youngest generation "    \
1961           "collection")                                                     \
1962                                                                             \
1963   develop(uintx, PromotionFailureALotCount, 1000,                           \
1964           "Number of promotion failures occurring at PLAB "                 \
1965           "refill attempts (ParNew) or promotion attempts "                 \
1966           "(other young collectors)")                                       \
1967                                                                             \
1968   develop(uintx, PromotionFailureALotInterval, 5,                           \
1969           "Total collections between promotion failures a lot")             \
1970                                                                             \
1971   experimental(uintx, WorkStealingSleepMillis, 1,                           \
1972           "Sleep time when sleep is used for yields")                       \
1973                                                                             \
1974   experimental(uintx, WorkStealingYieldsBeforeSleep, 5000,                  \
1975           "Number of yields before a sleep is done during work stealing")   \
1976                                                                             \
1977   experimental(uintx, WorkStealingHardSpins, 4096,                          \
1978           "Number of iterations in a spin loop between checks on "          \
1979           "time out of hard spin")                                          \
1980                                                                             \
1981   experimental(uintx, WorkStealingSpinToYieldRatio, 10,                     \
1982           "Ratio of hard spins to calls to yield")                          \
1983                                                                             \
1984   develop(uintx, ObjArrayMarkingStride, 512,                                \
1985           "Number of object array elements to push onto the marking stack " \
1986           "before pushing a continuation entry")                            \
1987                                                                             \
1988   develop(bool, MetadataAllocationFailALot, false,                          \
1989           "Fail metadata allocations at intervals controlled by "           \
1990           "MetadataAllocationFailALotInterval")                             \
1991                                                                             \
1992   develop(uintx, MetadataAllocationFailALotInterval, 1000,                  \
1993           "Metadata allocation failure a lot interval")                     \
1994                                                                             \
1995   notproduct(bool, ExecuteInternalVMTests, false,                           \
1996           "Enable execution of internal VM tests")                          \
1997                                                                             \
1998   notproduct(bool, VerboseInternalVMTests, false,                           \
1999           "Turn on logging for internal VM tests.")                         \
2000                                                                             \
2001   product(bool, ExecutingUnitTests, false,                                  \
2002           "Whether the JVM is running unit tests or not")                   \
2003                                                                             \
2004   product_pd(bool, UseTLAB, "Use thread-local object allocation")           \
2005                                                                             \
2006   product_pd(bool, ResizeTLAB,                                              \
2007           "Dynamically resize TLAB size for threads")                       \
2008                                                                             \
2009   product(bool, ZeroTLAB, false,                                            \
2010           "Zero out the newly created TLAB")                                \
2011                                                                             \
2012   product(bool, FastTLABRefill, true,                                       \
2013           "Use fast TLAB refill code")                                      \
2014                                                                             \
2015   product(bool, TLABStats, true,                                            \
2016           "Provide more detailed and expensive TLAB statistics.")           \
2017                                                                             \
2018   product_pd(bool, NeverActAsServerClassMachine,                            \
2019           "Never act like a server-class machine")                          \
2020                                                                             \
2021   product(bool, AlwaysActAsServerClassMachine, false,                       \
2022           "Always act like a server-class machine")                         \
2023                                                                             \
2024   product_pd(uint64_t, MaxRAM,                                              \
2025           "Real memory size (in bytes) used to set maximum heap size")      \
2026           range(0, 0XFFFFFFFFFFFFFFFF)                                      \
2027                                                                             \
2028   product(size_t, ErgoHeapSizeLimit, 0,                                     \
2029           "Maximum ergonomically set heap size (in bytes); zero means use " \
2030           "MaxRAM / MaxRAMFraction")                                        \
2031           range(0, max_uintx)                                               \
2032                                                                             \
2033   product(uintx, MaxRAMFraction, 4,                                         \
2034           "Maximum fraction (1/n) of real memory used for maximum heap "    \
2035           "size")                                                           \
2036           range(1, max_uintx)                                               \
2037                                                                             \
2038   product(uintx, MinRAMFraction, 2,                                         \
2039           "Minimum fraction (1/n) of real memory used for maximum heap "    \
2040           "size on systems with small physical memory size")                \
2041           range(1, max_uintx)                                               \
2042                                                                             \
2043   product(uintx, InitialRAMFraction, 64,                                    \
2044           "Fraction (1/n) of real memory used for initial heap size")       \
2045           range(1, max_uintx)                                               \
2046                                                                             \
2047   develop(uintx, MaxVirtMemFraction, 2,                                     \
2048           "Maximum fraction (1/n) of virtual memory used for ergonomically "\
2049           "determining maximum heap size")                                  \
2050                                                                             \
2051   product(bool, UseAutoGCSelectPolicy, false,                               \
2052           "Use automatic collection selection policy")                      \
2053                                                                             \
2054   product(uintx, AutoGCSelectPauseMillis, 5000,                             \
2055           "Automatic GC selection pause threshold in milliseconds")         \
2056           range(0, max_uintx)                                               \
2057                                                                             \
2058   product(bool, UseAdaptiveSizePolicy, true,                                \
2059           "Use adaptive generation sizing policies")                        \
2060                                                                             \
2061   product(bool, UsePSAdaptiveSurvivorSizePolicy, true,                      \
2062           "Use adaptive survivor sizing policies")                          \
2063                                                                             \
2064   product(bool, UseAdaptiveGenerationSizePolicyAtMinorCollection, true,     \
2065           "Use adaptive young-old sizing policies at minor collections")    \
2066                                                                             \
2067   product(bool, UseAdaptiveGenerationSizePolicyAtMajorCollection, true,     \
2068           "Use adaptive young-old sizing policies at major collections")    \
2069                                                                             \
2070   product(bool, UseAdaptiveSizePolicyWithSystemGC, false,                   \
2071           "Include statistics from System.gc() for adaptive size policy")   \
2072                                                                             \
2073   product(bool, UseAdaptiveGCBoundary, false,                               \
2074           "Allow young-old boundary to move")                               \
2075                                                                             \
2076   develop(intx, PSAdaptiveSizePolicyResizeVirtualSpaceAlot, -1,             \
2077           "Resize the virtual spaces of the young or old generations")      \
2078           range(-1, 1)                                                      \
2079                                                                             \
2080   product(uintx, AdaptiveSizeThroughPutPolicy, 0,                           \
2081           "Policy for changing generation size for throughput goals")       \
2082           range(0, 1)                                                       \
2083                                                                             \
2084   product(uintx, AdaptiveSizePolicyInitializingSteps, 20,                   \
2085           "Number of steps where heuristics is used before data is used")   \
2086           range(0, max_uintx)                                               \
2087                                                                             \
2088   develop(uintx, AdaptiveSizePolicyReadyThreshold, 5,                       \
2089           "Number of collections before the adaptive sizing is started")    \
2090                                                                             \
2091   product(uintx, AdaptiveSizePolicyOutputInterval, 0,                       \
2092           "Collection interval for printing information; zero means never") \
2093           range(0, max_uintx)                                               \
2094                                                                             \
2095   product(bool, UseAdaptiveSizePolicyFootprintGoal, true,                   \
2096           "Use adaptive minimum footprint as a goal")                       \
2097                                                                             \
2098   product(uintx, AdaptiveSizePolicyWeight, 10,                              \
2099           "Weight given to exponential resizing, between 0 and 100")        \
2100           range(0, 100)                                                     \
2101                                                                             \
2102   product(uintx, AdaptiveTimeWeight,       25,                              \
2103           "Weight given to time in adaptive policy, between 0 and 100")     \
2104           range(0, 100)                                                     \
2105                                                                             \
2106   product(uintx, PausePadding, 1,                                           \
2107           "How much buffer to keep for pause time")                         \
2108           range(0, max_juint)                                               \
2109                                                                             \
2110   product(uintx, PromotedPadding, 3,                                        \
2111           "How much buffer to keep for promotion failure")                  \
2112           range(0, max_juint)                                               \
2113                                                                             \
2114   product(uintx, SurvivorPadding, 3,                                        \
2115           "How much buffer to keep for survivor overflow")                  \
2116           range(0, max_juint)                                               \
2117                                                                             \
2118   product(uintx, ThresholdTolerance, 10,                                    \
2119           "Allowed collection cost difference between generations")         \
2120           range(0, 100)                                                     \
2121                                                                             \
2122   product(uintx, AdaptiveSizePolicyCollectionCostMargin, 50,                \
2123           "If collection costs are within margin, reduce both by full "     \
2124           "delta")                                                          \
2125           range(0, 100)                                                     \
2126                                                                             \
2127   product(uintx, YoungGenerationSizeIncrement, 20,                          \
2128           "Adaptive size percentage change in young generation")            \
2129           range(0, 100)                                                     \
2130                                                                             \
2131   product(uintx, YoungGenerationSizeSupplement, 80,                         \
2132           "Supplement to YoungedGenerationSizeIncrement used at startup")   \
2133           range(0, 100)                                                     \
2134                                                                             \
2135   product(uintx, YoungGenerationSizeSupplementDecay, 8,                     \
2136           "Decay factor to YoungedGenerationSizeSupplement")                \
2137           range(1, max_uintx)                                               \
2138                                                                             \
2139   product(uintx, TenuredGenerationSizeIncrement, 20,                        \
2140           "Adaptive size percentage change in tenured generation")          \
2141           range(0, 100)                                                     \
2142                                                                             \
2143   product(uintx, TenuredGenerationSizeSupplement, 80,                       \
2144           "Supplement to TenuredGenerationSizeIncrement used at startup")   \
2145           range(0, 100)                                                     \
2146                                                                             \
2147   product(uintx, TenuredGenerationSizeSupplementDecay, 2,                   \
2148           "Decay factor to TenuredGenerationSizeIncrement")                 \
2149           range(1, max_uintx)                                               \
2150                                                                             \
2151   product(uintx, MaxGCPauseMillis, max_uintx - 1,                           \
2152           "Adaptive size policy maximum GC pause time goal in millisecond, "\
2153           "or (G1 Only) the maximum GC time per MMU time slice")            \
2154           range(1, max_uintx - 1)                                           \
2155           constraint(MaxGCPauseMillisConstraintFunc,AfterErgo)              \
2156                                                                             \
2157   product(uintx, GCPauseIntervalMillis, 0,                                  \
2158           "Time slice for MMU specification")                               \
2159           constraint(GCPauseIntervalMillisConstraintFunc,AfterErgo)         \
2160                                                                             \
2161   product(uintx, MaxGCMinorPauseMillis, max_uintx,                          \
2162           "Adaptive size policy maximum GC minor pause time goal "          \
2163           "in millisecond")                                                 \
2164           range(0, max_uintx)                                               \
2165                                                                             \
2166   product(uintx, GCTimeRatio, 99,                                           \
2167           "Adaptive size policy application time to GC time ratio")         \
2168           range(0, max_juint)                                               \
2169                                                                             \
2170   product(uintx, AdaptiveSizeDecrementScaleFactor, 4,                       \
2171           "Adaptive size scale down factor for shrinking")                  \
2172           range(1, max_uintx)                                               \
2173                                                                             \
2174   product(bool, UseAdaptiveSizeDecayMajorGCCost, true,                      \
2175           "Adaptive size decays the major cost for long major intervals")   \
2176                                                                             \
2177   product(uintx, AdaptiveSizeMajorGCDecayTimeScale, 10,                     \
2178           "Time scale over which major costs decay")                        \
2179           range(0, max_uintx)                                               \
2180                                                                             \
2181   product(uintx, MinSurvivorRatio, 3,                                       \
2182           "Minimum ratio of young generation/survivor space size")          \
2183           range(3, max_uintx)                                               \
2184                                                                             \
2185   product(uintx, InitialSurvivorRatio, 8,                                   \
2186           "Initial ratio of young generation/survivor space size")          \
2187           range(0, max_uintx)                                               \
2188                                                                             \
2189   product(size_t, BaseFootPrintEstimate, 256*M,                             \
2190           "Estimate of footprint other than Java Heap")                     \
2191           range(0, max_uintx)                                               \
2192                                                                             \
2193   product(bool, UseGCOverheadLimit, true,                                   \
2194           "Use policy to limit of proportion of time spent in GC "          \
2195           "before an OutOfMemory error is thrown")                          \
2196                                                                             \
2197   product(uintx, GCTimeLimit, 98,                                           \
2198           "Limit of the proportion of time spent in GC before "             \
2199           "an OutOfMemoryError is thrown (used with GCHeapFreeLimit)")      \
2200           range(0, 100)                                                     \
2201                                                                             \
2202   product(uintx, GCHeapFreeLimit, 2,                                        \
2203           "Minimum percentage of free space after a full GC before an "     \
2204           "OutOfMemoryError is thrown (used with GCTimeLimit)")             \
2205           range(0, 100)                                                     \
2206                                                                             \
2207   develop(uintx, AdaptiveSizePolicyGCTimeLimitThreshold, 5,                 \
2208           "Number of consecutive collections before gc time limit fires")   \
2209           range(1, max_uintx)                                               \
2210                                                                             \
2211   product(intx, PrefetchCopyIntervalInBytes, -1,                            \
2212           "How far ahead to prefetch destination area (&lt;= 0 means off)")    \
2213           range(-1, max_jint)                                               \
2214                                                                             \
2215   product(intx, PrefetchScanIntervalInBytes, -1,                            \
2216           "How far ahead to prefetch scan area (&lt;= 0 means off)")           \
2217           range(-1, max_jint)                                               \
2218                                                                             \
2219   product(intx, PrefetchFieldsAhead, -1,                                    \
2220           "How many fields ahead to prefetch in oop scan (&lt;= 0 means off)") \
2221           range(-1, max_jint)                                               \
2222                                                                             \
2223   diagnostic(bool, VerifyDuringStartup, false,                              \
2224           "Verify memory system before executing any Java code "            \
2225           "during VM initialization")                                       \
2226                                                                             \
2227   diagnostic(bool, VerifyBeforeExit, trueInDebug,                           \
2228           "Verify system before exiting")                                   \
2229                                                                             \
2230   diagnostic(bool, VerifyBeforeGC, false,                                   \
2231           "Verify memory system before GC")                                 \
2232                                                                             \
2233   diagnostic(bool, VerifyAfterGC, false,                                    \
2234           "Verify memory system after GC")                                  \
2235                                                                             \
2236   diagnostic(bool, VerifyDuringGC, false,                                   \
2237           "Verify memory system during GC (between phases)")                \
2238                                                                             \
2239   diagnostic(ccstrlist, VerifySubSet, "",                                   \
2240           "Memory sub-systems to verify when Verify*GC flag(s) "            \
2241           "are enabled. One or more sub-systems can be specified "          \
2242           "in a comma separated string. Sub-systems are: "                  \
2243           "threads, heap, symbol_table, string_table, codecache, "          \
2244           "dictionary, classloader_data_graph, metaspace, jni_handles, "    \
2245           "c-heap, codecache_oops")                                         \
2246                                                                             \
2247   diagnostic(bool, GCParallelVerificationEnabled, true,                     \
2248           "Enable parallel memory system verification")                     \
2249                                                                             \
2250   diagnostic(bool, DeferInitialCardMark, false,                             \
2251           "When +ReduceInitialCardMarks, explicitly defer any that "        \
2252           "may arise from new_pre_store_barrier")                           \
2253                                                                             \
2254   product(bool, UseCondCardMark, false,                                     \
2255           "Check for already marked card before updating card table")       \
2256                                                                             \
2257   diagnostic(bool, VerifyRememberedSets, false,                             \
2258           "Verify GC remembered sets")                                      \
2259                                                                             \
2260   diagnostic(bool, VerifyObjectStartArray, true,                            \
2261           "Verify GC object start array if verify before/after")            \
2262                                                                             \
2263   product(bool, DisableExplicitGC, false,                                   \
2264           "Ignore calls to System.gc()")                                    \
2265                                                                             \
2266   notproduct(bool, CheckMemoryInitialization, false,                        \
2267           "Check memory initialization")                                    \
2268                                                                             \
2269   diagnostic(bool, BindCMSThreadToCPU, false,                               \
2270           "Bind CMS Thread to CPU if possible")                             \
2271                                                                             \
2272   diagnostic(uintx, CPUForCMSThread, 0,                                     \
2273           "When BindCMSThreadToCPU is true, the CPU to bind CMS thread to") \
2274           range(0, max_juint)                                               \
2275                                                                             \
2276   product(bool, BindGCTaskThreadsToCPUs, false,                             \
2277           "Bind GCTaskThreads to CPUs if possible")                         \
2278                                                                             \
2279   product(bool, UseGCTaskAffinity, false,                                   \
2280           "Use worker affinity when asking for GCTasks")                    \
2281                                                                             \
2282   product(uintx, ProcessDistributionStride, 4,                              \
2283           "Stride through processors when distributing processes")          \
2284           range(0, max_juint)                                               \
2285                                                                             \
2286   product(uintx, CMSCoordinatorYieldSleepCount, 10,                         \
2287           "Number of times the coordinator GC thread will sleep while "     \
2288           "yielding before giving up and resuming GC")                      \
2289           range(0, max_juint)                                               \
2290                                                                             \
2291   product(uintx, CMSYieldSleepCount, 0,                                     \
2292           "Number of times a GC thread (minus the coordinator) "            \
2293           "will sleep while yielding before giving up and resuming GC")     \
2294           range(0, max_juint)                                               \
2295                                                                             \
2296   product(bool, PrintGC, false,                                             \
2297           "Print message at garbage collection. "                           \
2298           "Deprecated, use -Xlog:gc instead.")                              \
2299                                                                             \
2300   product(bool, PrintGCDetails, false,                                      \
2301           "Print more details at garbage collection. "                      \
2302           "Deprecated, use -Xlog:gc* instead.")                             \
2303                                                                             \
2304   develop(intx, ConcGCYieldTimeout, 0,                                      \
2305           "If non-zero, assert that GC threads yield within this "          \
2306           "number of milliseconds")                                         \
2307           range(0, max_intx)                                                \
2308                                                                             \
2309   develop(bool, TraceFinalizerRegistration, false,                          \
2310           "Trace registration of final references")                         \
2311                                                                             \
2312   notproduct(bool, TraceScavenge, false,                                    \
2313           "Trace scavenge")                                                 \
2314                                                                             \
2315   product(bool, IgnoreEmptyClassPaths, false,                               \
2316           "Ignore empty path elements in -classpath")                       \
2317                                                                             \
2318   product(size_t, InitialBootClassLoaderMetaspaceSize,                      \
2319           NOT_LP64(2200*K) LP64_ONLY(4*M),                                  \
2320           "Initial size of the boot class loader data metaspace")           \
2321           range(30*K, max_uintx/BytesPerWord)                               \
2322           constraint(InitialBootClassLoaderMetaspaceSizeConstraintFunc, AfterErgo)\
2323                                                                             \
2324   product(bool, TraceYoungGenTime, false,                                   \
2325           "Trace accumulated time for young collection")                    \
2326                                                                             \
2327   product(bool, TraceOldGenTime, false,                                     \
2328           "Trace accumulated time for old collection")                      \
2329                                                                             \
2330   product(bool, PrintHeapAtSIGBREAK, true,                                  \
2331           "Print heap layout in response to SIGBREAK")                      \
2332                                                                             \
2333   manageable(bool, PrintClassHistogram, false,                              \
2334           "Print a histogram of class instances")                           \
2335                                                                             \
2336   develop(bool, TraceGCTaskManager, false,                                  \
2337           "Trace actions of the GC task manager")                           \
2338                                                                             \
2339   develop(bool, TraceGCTaskQueue, false,                                    \
2340           "Trace actions of the GC task queues")                            \
2341                                                                             \
2342   develop(bool, TraceParallelOldGCMarkingPhase, false,                      \
2343           "Trace marking phase in ParallelOldGC")                           \
2344                                                                             \
2345   develop(bool, TraceParallelOldGCDensePrefix, false,                       \
2346           "Trace dense prefix computation for ParallelOldGC")               \
2347                                                                             \
2348   develop(bool, IgnoreLibthreadGPFault, false,                              \
2349           "Suppress workaround for libthread GP fault")                     \
2350                                                                             \
2351   experimental(double, ObjectCountCutOffPercent, 0.5,                       \
2352           "The percentage of the used heap that the instances of a class "  \
2353           "must occupy for the class to generate a trace event")            \
2354           range(0.0, 100.0)                                                 \
2355                                                                             \
2356   /* JVMTI heap profiling */                                                \
2357                                                                             \
2358   diagnostic(bool, TraceJVMTIObjectTagging, false,                          \
2359           "Trace JVMTI object tagging calls")                               \
2360                                                                             \
2361   diagnostic(bool, VerifyBeforeIteration, false,                            \
2362           "Verify memory system before JVMTI iteration")                    \
2363                                                                             \
2364   /* compiler interface */                                                  \
2365                                                                             \
2366   develop(bool, CIPrintCompilerName, false,                                 \
2367           "when CIPrint is active, print the name of the active compiler")  \
2368                                                                             \
2369   diagnostic(bool, CIPrintCompileQueue, false,                              \
2370           "display the contents of the compile queue whenever a "           \
2371           "compilation is enqueued")                                        \
2372                                                                             \
2373   develop(bool, CIPrintRequests, false,                                     \
2374           "display every request for compilation")                          \
2375                                                                             \
2376   product(bool, CITime, false,                                              \
2377           "collect timing information for compilation")                     \
2378                                                                             \
2379   develop(bool, CITimeVerbose, false,                                       \
2380           "be more verbose in compilation timings")                         \
2381                                                                             \
2382   develop(bool, CITimeEach, false,                                          \
2383           "display timing information after each successful compilation")   \
2384                                                                             \
2385   develop(bool, CICountOSR, false,                                          \
2386           "use a separate counter when assigning ids to osr compilations")  \
2387                                                                             \
2388   develop(bool, CICompileNatives, true,                                     \
2389           "compile native methods if supported by the compiler")            \
2390                                                                             \
2391   develop_pd(bool, CICompileOSR,                                            \
2392           "compile on stack replacement methods if supported by the "       \
2393           "compiler")                                                       \
2394                                                                             \
2395   develop(bool, CIPrintMethodCodes, false,                                  \
2396           "print method bytecodes of the compiled code")                    \
2397                                                                             \
2398   develop(bool, CIPrintTypeFlow, false,                                     \
2399           "print the results of ciTypeFlow analysis")                       \
2400                                                                             \
2401   develop(bool, CITraceTypeFlow, false,                                     \
2402           "detailed per-bytecode tracing of ciTypeFlow analysis")           \
2403                                                                             \
2404   develop(intx, OSROnlyBCI, -1,                                             \
2405           "OSR only at this bci.  Negative values mean exclude that bci")   \
2406                                                                             \
2407   /* compiler */                                                            \
2408                                                                             \
2409   /* notice: the max range value here is max_jint, not max_intx  */         \
2410   /* because of overflow issue                                   */         \
2411   product(intx, CICompilerCount, CI_COMPILER_COUNT,                         \
2412           "Number of compiler threads to run")                              \
2413           range(0, max_jint)                                                \
2414           constraint(CICompilerCountConstraintFunc, AfterErgo)              \
2415                                                                             \
2416   product(intx, CompilationPolicyChoice, 0,                                 \
2417           "which compilation policy (0-3)")                                 \
2418           range(0, 3)                                                       \
2419                                                                             \
2420   develop(bool, UseStackBanging, true,                                      \
2421           "use stack banging for stack overflow checks (required for "      \
2422           "proper StackOverflow handling; disable only to measure cost "    \
2423           "of stackbanging)")                                               \
2424                                                                             \
2425   develop(bool, UseStrictFP, true,                                          \
2426           "use strict fp if modifier strictfp is set")                      \
2427                                                                             \
2428   develop(bool, GenerateSynchronizationCode, true,                          \
2429           "generate locking/unlocking code for synchronized methods and "   \
2430           "monitors")                                                       \
2431                                                                             \
2432   develop(bool, GenerateRangeChecks, true,                                  \
2433           "Generate range checks for array accesses")                       \
2434                                                                             \
2435   diagnostic_pd(bool, ImplicitNullChecks,                                   \
2436           "Generate code for implicit null checks")                         \
2437                                                                             \
2438   product_pd(bool, TrapBasedNullChecks,                                     \
2439           "Generate code for null checks that uses a cmp and trap "         \
2440           "instruction raising SIGTRAP.  This is only used if an access to" \
2441           "null (+offset) will not raise a SIGSEGV, i.e.,"                  \
2442           "ImplicitNullChecks don't work (PPC64).")                         \
2443                                                                             \
2444   product(bool, PrintSafepointStatistics, false,                            \
2445           "Print statistics about safepoint synchronization")               \
2446                                                                             \
2447   product(intx, PrintSafepointStatisticsCount, 300,                         \
2448           "Total number of safepoint statistics collected "                 \
2449           "before printing them out")                                       \
2450           range(1, max_intx)                                                \
2451                                                                             \
2452   product(intx, PrintSafepointStatisticsTimeout,  -1,                       \
2453           "Print safepoint statistics only when safepoint takes "           \
2454           "more than PrintSafepointSatisticsTimeout in millis")             \
2455   LP64_ONLY(range(-1, max_intx/MICROUNITS))                                 \
2456   NOT_LP64(range(-1, max_intx))                                             \
2457                                                                             \
2458   product(bool, Inline, true,                                               \
2459           "Enable inlining")                                                \
2460                                                                             \
2461   product(bool, ClipInlining, true,                                         \
2462           "Clip inlining if aggregate method exceeds DesiredMethodLimit")   \
2463                                                                             \
2464   develop(bool, UseCHA, true,                                               \
2465           "Enable CHA")                                                     \
2466                                                                             \
2467   product(bool, UseTypeProfile, true,                                       \
2468           "Check interpreter profile for historically monomorphic calls")   \
2469                                                                             \
2470   diagnostic(bool, PrintInlining, false,                                    \
2471           "Print inlining optimizations")                                   \
2472                                                                             \
2473   product(bool, UsePopCountInstruction, false,                              \
2474           "Use population count instruction")                               \
2475                                                                             \
2476   develop(bool, EagerInitialization, false,                                 \
2477           "Eagerly initialize classes if possible")                         \
2478                                                                             \
2479   diagnostic(bool, LogTouchedMethods, false,                                \
2480           "Log methods which have been ever touched in runtime")            \
2481                                                                             \
2482   diagnostic(bool, PrintTouchedMethodsAtExit, false,                        \
2483           "Print all methods that have been ever touched in runtime")       \
2484                                                                             \
2485   develop(bool, TraceMethodReplacement, false,                              \
2486           "Print when methods are replaced do to recompilation")            \
2487                                                                             \
2488   develop(bool, PrintMethodFlushing, false,                                 \
2489           "Print the nmethods being flushed")                               \
2490                                                                             \
2491   diagnostic(bool, PrintMethodFlushingStatistics, false,                    \
2492           "print statistics about method flushing")                         \
2493                                                                             \
2494   diagnostic(intx, HotMethodDetectionLimit, 100000,                         \
2495           "Number of compiled code invocations after which "                \
2496           "the method is considered as hot by the flusher")                 \
2497           range(1, max_jint)                                                \
2498                                                                             \
2499   diagnostic(intx, MinPassesBeforeFlush, 10,                                \
2500           "Minimum number of sweeper passes before an nmethod "             \
2501           "can be flushed")                                                 \
2502           range(0, max_intx)                                                \
2503                                                                             \
2504   product(bool, UseCodeAging, true,                                         \
2505           "Insert counter to detect warm methods")                          \
2506                                                                             \
2507   diagnostic(bool, StressCodeAging, false,                                  \
2508           "Start with counters compiled in")                                \
2509                                                                             \
2510   develop(bool, UseRelocIndex, false,                                       \
2511           "Use an index to speed random access to relocations")             \
2512                                                                             \
2513   develop(bool, StressCodeBuffers, false,                                   \
2514           "Exercise code buffer expansion and other rare state changes")    \
2515                                                                             \
2516   diagnostic(bool, DebugNonSafepoints, trueInDebug,                         \
2517           "Generate extra debugging information for non-safepoints in "     \
2518           "nmethods")                                                       \
2519                                                                             \
2520   product(bool, PrintVMOptions, false,                                      \
2521           "Print flags that appeared on the command line")                  \
2522                                                                             \
2523   product(bool, IgnoreUnrecognizedVMOptions, false,                         \
2524           "Ignore unrecognized VM options")                                 \
2525                                                                             \
2526   product(bool, PrintCommandLineFlags, false,                               \
2527           "Print flags specified on command line or set by ergonomics")     \
2528                                                                             \
2529   product(bool, PrintFlagsInitial, false,                                   \
2530           "Print all VM flags before argument processing and exit VM")      \
2531                                                                             \
2532   product(bool, PrintFlagsFinal, false,                                     \
2533           "Print all VM flags after argument and ergonomic processing")     \
2534                                                                             \
2535   notproduct(bool, PrintFlagsWithComments, false,                           \
2536           "Print all VM flags with default values and descriptions and "    \
2537           "exit")                                                           \
2538                                                                             \
2539   product(bool, PrintFlagsRanges, false,                                    \
2540           "Print VM flags and their ranges and exit VM")                    \
2541                                                                             \
2542   diagnostic(bool, SerializeVMOutput, true,                                 \
2543           "Use a mutex to serialize output to tty and LogFile")             \
2544                                                                             \
2545   diagnostic(bool, DisplayVMOutput, true,                                   \
2546           "Display all VM output on the tty, independently of LogVMOutput") \
2547                                                                             \
2548   diagnostic(bool, LogVMOutput, false,                                      \
2549           "Save VM output to LogFile")                                      \
2550                                                                             \
2551   diagnostic(ccstr, LogFile, NULL,                                          \
2552           "If LogVMOutput or LogCompilation is on, save VM output to "      \
2553           "this file [default: ./hotspot_pid%p.log] (%p replaced with pid)")\
2554                                                                             \
2555   product(ccstr, ErrorFile, NULL,                                           \
2556           "If an error occurs, save the error data to this file "           \
2557           "[default: ./hs_err_pid%p.log] (%p replaced with pid)")           \
2558                                                                             \
2559   product(bool, DisplayVMOutputToStderr, false,                             \
2560           "If DisplayVMOutput is true, display all VM output to stderr")    \
2561                                                                             \
2562   product(bool, DisplayVMOutputToStdout, false,                             \
2563           "If DisplayVMOutput is true, display all VM output to stdout")    \
2564                                                                             \
2565   product(bool, UseHeavyMonitors, false,                                    \
2566           "use heavyweight instead of lightweight Java monitors")           \
2567                                                                             \
2568   product(bool, PrintStringTableStatistics, false,                          \
2569           "print statistics about the StringTable and SymbolTable")         \
2570                                                                             \
2571   diagnostic(bool, VerifyStringTableAtExit, false,                          \
2572           "verify StringTable contents at exit")                            \
2573                                                                             \
2574   notproduct(bool, PrintSymbolTableSizeHistogram, false,                    \
2575           "print histogram of the symbol table")                            \
2576                                                                             \
2577   notproduct(bool, ExitVMOnVerifyError, false,                              \
2578           "standard exit from VM if bytecode verify error "                 \
2579           "(only in debug mode)")                                           \
2580                                                                             \
2581   diagnostic(ccstr, AbortVMOnException, NULL,                               \
2582           "Call fatal if this exception is thrown.  Example: "              \
2583           "java -XX:AbortVMOnException=java.lang.NullPointerException Foo") \
2584                                                                             \
2585   diagnostic(ccstr, AbortVMOnExceptionMessage, NULL,                        \
2586           "Call fatal if the exception pointed by AbortVMOnException "      \
2587           "has this message")                                               \
2588                                                                             \
2589   develop(bool, DebugVtables, false,                                        \
2590           "add debugging code to vtable dispatch")                          \
2591                                                                             \
2592   notproduct(bool, PrintVtableStats, false,                                 \
2593           "print vtables stats at end of run")                              \
2594                                                                             \
2595   develop(bool, TraceCreateZombies, false,                                  \
2596           "trace creation of zombie nmethods")                              \
2597                                                                             \
2598   notproduct(bool, IgnoreLockingAssertions, false,                          \
2599           "disable locking assertions (for speed)")                         \
2600                                                                             \
2601   product(bool, RangeCheckElimination, true,                                \
2602           "Eliminate range checks")                                         \
2603                                                                             \
2604   develop_pd(bool, UncommonNullCast,                                        \
2605           "track occurrences of null in casts; adjust compiler tactics")    \
2606                                                                             \
2607   develop(bool, TypeProfileCasts,  true,                                    \
2608           "treat casts like calls for purposes of type profiling")          \
2609                                                                             \
2610   develop(bool, DelayCompilationDuringStartup, true,                        \
2611           "Delay invoking the compiler until main application class is "    \
2612           "loaded")                                                         \
2613                                                                             \
2614   develop(bool, CompileTheWorld, false,                                     \
2615           "Compile all methods in all classes in bootstrap class path "     \
2616             "(stress test)")                                                \
2617                                                                             \
2618   develop(bool, CompileTheWorldPreloadClasses, true,                        \
2619           "Preload all classes used by a class before start loading")       \
2620                                                                             \
2621   notproduct(intx, CompileTheWorldSafepointInterval, 100,                   \
2622           "Force a safepoint every n compiles so sweeper can keep up")      \
2623                                                                             \
2624   develop(bool, FillDelaySlots, true,                                       \
2625           "Fill delay slots (on SPARC only)")                               \
2626                                                                             \
2627   develop(bool, TimeLivenessAnalysis, false,                                \
2628           "Time computation of bytecode liveness analysis")                 \
2629                                                                             \
2630   develop(bool, TraceLivenessGen, false,                                    \
2631           "Trace the generation of liveness analysis information")          \
2632                                                                             \
2633   notproduct(bool, TraceLivenessQuery, false,                               \
2634           "Trace queries of liveness analysis information")                 \
2635                                                                             \
2636   notproduct(bool, CollectIndexSetStatistics, false,                        \
2637           "Collect information about IndexSets")                            \
2638                                                                             \
2639   develop(bool, UseLoopSafepoints, true,                                    \
2640           "Generate Safepoint nodes in every loop")                         \
2641                                                                             \
2642   develop(intx, FastAllocateSizeLimit, 128*K,                               \
2643           /* Note:  This value is zero mod 1&lt;&lt;13 for a cheap sparc set. */  \
2644           "Inline allocations larger than this in doublewords must go slow")\
2645                                                                             \
2646   product(bool, AggressiveOpts, false,                                      \
2647           "Enable aggressive optimizations - see arguments.cpp")            \
2648                                                                             \
2649   product_pd(bool, CompactStrings,                                          \
2650           "Enable Strings to use single byte chars in backing store")       \
2651                                                                             \
2652   product_pd(uintx, TypeProfileLevel,                                       \
2653           "=XYZ, with Z: Type profiling of arguments at call; "             \
2654                      "Y: Type profiling of return value at call; "          \
2655                      "X: Type profiling of parameters to methods; "         \
2656           "X, Y and Z in 0=off ; 1=jsr292 only; 2=all methods")             \
2657           constraint(TypeProfileLevelConstraintFunc, AfterErgo)             \
2658                                                                             \
2659   product(intx, TypeProfileArgsLimit,     2,                                \
2660           "max number of call arguments to consider for type profiling")    \
2661           range(0, 16)                                                      \
2662                                                                             \
2663   product(intx, TypeProfileParmsLimit,    2,                                \
2664           "max number of incoming parameters to consider for type profiling"\
2665           ", -1 for all")                                                   \
2666           range(-1, 64)                                                     \
2667                                                                             \
2668   /* statistics */                                                          \
2669   develop(bool, CountCompiledCalls, false,                                  \
2670           "Count method invocations")                                       \
2671                                                                             \
2672   notproduct(bool, CountRuntimeCalls, false,                                \
2673           "Count VM runtime calls")                                         \
2674                                                                             \
2675   develop(bool, CountJNICalls, false,                                       \
2676           "Count jni method invocations")                                   \
2677                                                                             \
2678   notproduct(bool, CountJVMCalls, false,                                    \
2679           "Count jvm method invocations")                                   \
2680                                                                             \
2681   notproduct(bool, CountRemovableExceptions, false,                         \
2682           "Count exceptions that could be replaced by branches due to "     \
2683           "inlining")                                                       \
2684                                                                             \
2685   notproduct(bool, ICMissHistogram, false,                                  \
2686           "Produce histogram of IC misses")                                 \
2687                                                                             \
2688   /* interpreter */                                                         \
2689   product_pd(bool, RewriteBytecodes,                                        \
2690           "Allow rewriting of bytecodes (bytecodes are not immutable)")     \
2691                                                                             \
2692   product_pd(bool, RewriteFrequentPairs,                                    \
2693           "Rewrite frequently used bytecode pairs into a single bytecode")  \
2694                                                                             \
2695   diagnostic(bool, PrintInterpreter, false,                                 \
2696           "Print the generated interpreter code")                           \
2697                                                                             \
2698   product(bool, UseInterpreter, true,                                       \
2699           "Use interpreter for non-compiled methods")                       \
2700                                                                             \
2701   develop(bool, UseFastSignatureHandlers, true,                             \
2702           "Use fast signature handlers for native calls")                   \
2703                                                                             \
2704   product(bool, UseLoopCounter, true,                                       \
2705           "Increment invocation counter on backward branch")                \
2706                                                                             \
2707   product_pd(bool, UseOnStackReplacement,                                   \
2708           "Use on stack replacement, calls runtime if invoc. counter "      \
2709           "overflows in loop")                                              \
2710                                                                             \
2711   notproduct(bool, TraceOnStackReplacement, false,                          \
2712           "Trace on stack replacement")                                     \
2713                                                                             \
2714   product_pd(bool, PreferInterpreterNativeStubs,                            \
2715           "Use always interpreter stubs for native methods invoked via "    \
2716           "interpreter")                                                    \
2717                                                                             \
2718   develop(bool, CountBytecodes, false,                                      \
2719           "Count number of bytecodes executed")                             \
2720                                                                             \
2721   develop(bool, PrintBytecodeHistogram, false,                              \
2722           "Print histogram of the executed bytecodes")                      \
2723                                                                             \
2724   develop(bool, PrintBytecodePairHistogram, false,                          \
2725           "Print histogram of the executed bytecode pairs")                 \
2726                                                                             \
2727   diagnostic(bool, PrintSignatureHandlers, false,                           \
2728           "Print code generated for native method signature handlers")      \
2729                                                                             \
2730   develop(bool, VerifyOops, false,                                          \
2731           "Do plausibility checks for oops")                                \
2732                                                                             \
2733   develop(bool, CheckUnhandledOops, false,                                  \
2734           "Check for unhandled oops in VM code")                            \
2735                                                                             \
2736   develop(bool, VerifyJNIFields, trueInDebug,                               \
2737           "Verify jfieldIDs for instance fields")                           \
2738                                                                             \
2739   notproduct(bool, VerifyJNIEnvThread, false,                               \
2740           "Verify JNIEnv.thread == Thread::current() when entering VM "     \
2741           "from JNI")                                                       \
2742                                                                             \
2743   develop(bool, VerifyFPU, false,                                           \
2744           "Verify FPU state (check for NaN's, etc.)")                       \
2745                                                                             \
2746   develop(bool, VerifyThread, false,                                        \
2747           "Watch the thread register for corruption (SPARC only)")          \
2748                                                                             \
2749   develop(bool, VerifyActivationFrameSize, false,                           \
2750           "Verify that activation frame didn't become smaller than its "    \
2751           "minimal size")                                                   \
2752                                                                             \
2753   develop(bool, TraceFrequencyInlining, false,                              \
2754           "Trace frequency based inlining")                                 \
2755                                                                             \
2756   develop_pd(bool, InlineIntrinsics,                                        \
2757           "Inline intrinsics that can be statically resolved")              \
2758                                                                             \
2759   product_pd(bool, ProfileInterpreter,                                      \
2760           "Profile at the bytecode level during interpretation")            \
2761                                                                             \
2762   develop(bool, TraceProfileInterpreter, false,                             \
2763           "Trace profiling at the bytecode level during interpretation. "   \
2764           "This outputs the profiling information collected to improve "    \
2765           "jit compilation.")                                               \
2766                                                                             \
2767   develop_pd(bool, ProfileTraps,                                            \
2768           "Profile deoptimization traps at the bytecode level")             \
2769                                                                             \
2770   product(intx, ProfileMaturityPercentage, 20,                              \
2771           "number of method invocations/branches (expressed as % of "       \
2772           "CompileThreshold) before using the method's profile")            \
2773           range(0, 100)                                                     \
2774                                                                             \
2775   diagnostic(bool, PrintMethodData, false,                                  \
2776           "Print the results of +ProfileInterpreter at end of run")         \
2777                                                                             \
2778   develop(bool, VerifyDataPointer, trueInDebug,                             \
2779           "Verify the method data pointer during interpreter profiling")    \
2780                                                                             \
2781   develop(bool, VerifyCompiledCode, false,                                  \
2782           "Include miscellaneous runtime verifications in nmethod code; "   \
2783           "default off because it disturbs nmethod size heuristics")        \
2784                                                                             \
2785   notproduct(bool, CrashGCForDumpingJavaThread, false,                      \
2786           "Manually make GC thread crash then dump java stack trace;  "     \
2787           "Test only")                                                      \
2788                                                                             \
2789   /* compilation */                                                         \
2790   product(bool, UseCompiler, true,                                          \
2791           "Use Just-In-Time compilation")                                   \
2792                                                                             \
2793   develop(bool, TraceCompilationPolicy, false,                              \
2794           "Trace compilation policy")                                       \
2795                                                                             \
2796   develop(bool, TimeCompilationPolicy, false,                               \
2797           "Time the compilation policy")                                    \
2798                                                                             \
2799   product(bool, UseCounterDecay, true,                                      \
2800           "Adjust recompilation counters")                                  \
2801                                                                             \
2802   develop(intx, CounterHalfLifeTime,    30,                                 \
2803           "Half-life time of invocation counters (in seconds)")             \
2804                                                                             \
2805   develop(intx, CounterDecayMinIntervalLength,   500,                       \
2806           "The minimum interval (in milliseconds) between invocation of "   \
2807           "CounterDecay")                                                   \
2808                                                                             \
2809   product(bool, AlwaysCompileLoopMethods, false,                            \
2810           "When using recompilation, never interpret methods "              \
2811           "containing loops")                                               \
2812                                                                             \
2813   product(bool, DontCompileHugeMethods, true,                               \
2814           "Do not compile methods &gt; HugeMethodLimit")                       \
2815                                                                             \
2816   /* Bytecode escape analysis estimation. */                                \
2817   product(bool, EstimateArgEscape, true,                                    \
2818           "Analyze bytecodes to estimate escape state of arguments")        \
2819                                                                             \
2820   product(intx, BCEATraceLevel, 0,                                          \
2821           "How much tracing to do of bytecode escape analysis estimates "   \
2822           "(0-3)")                                                          \
2823           range(0, 3)                                                       \
2824                                                                             \
2825   product(intx, MaxBCEAEstimateLevel, 5,                                    \
2826           "Maximum number of nested calls that are analyzed by BC EA")      \
2827           range(0, max_jint)                                                \
2828                                                                             \
2829   product(intx, MaxBCEAEstimateSize, 150,                                   \
2830           "Maximum bytecode size of a method to be analyzed by BC EA")      \
2831           range(0, max_jint)                                                \
2832                                                                             \
2833   product(intx,  AllocatePrefetchStyle, 1,                                  \
2834           "0 = no prefetch, "                                               \
2835           "1 = generate prefetch instructions for each allocation, "        \
2836           "2 = use TLAB watermark to gate allocation prefetch, "            \
2837           "3 = generate one prefetch instruction per cache line")           \
2838           range(0, 3)                                                       \
2839                                                                             \
2840   product(intx,  AllocatePrefetchDistance, -1,                              \
2841           "Distance to prefetch ahead of allocation pointer. "              \
2842           "-1: use system-specific value (automatically determined")        \
2843           constraint(AllocatePrefetchDistanceConstraintFunc, AfterMemoryInit)\
2844                                                                             \
2845   product(intx,  AllocatePrefetchLines, 3,                                  \
2846           "Number of lines to prefetch ahead of array allocation pointer")  \
2847           range(1, 64)                                                      \
2848                                                                             \
2849   product(intx,  AllocateInstancePrefetchLines, 1,                          \
2850           "Number of lines to prefetch ahead of instance allocation "       \
2851           "pointer")                                                        \
2852           range(1, 64)                                                      \
2853                                                                             \
2854   product(intx,  AllocatePrefetchStepSize, 16,                              \
2855           "Step size in bytes of sequential prefetch instructions")         \
2856           range(1, 512)                                                     \
2857           constraint(AllocatePrefetchStepSizeConstraintFunc,AfterMemoryInit)\
2858                                                                             \
2859   product(intx,  AllocatePrefetchInstr, 0,                                  \
2860           "Select instruction to prefetch ahead of allocation pointer")     \
2861           constraint(AllocatePrefetchInstrConstraintFunc, AfterMemoryInit)  \
2862                                                                             \
2863   /* deoptimization */                                                      \
2864   develop(bool, TraceDeoptimization, false,                                 \
2865           "Trace deoptimization")                                           \
2866                                                                             \
2867   develop(bool, PrintDeoptimizationDetails, false,                          \
2868           "Print more information about deoptimization")                    \
2869                                                                             \
2870   develop(bool, DebugDeoptimization, false,                                 \
2871           "Tracing various information while debugging deoptimization")     \
2872                                                                             \
2873   product(intx, SelfDestructTimer, 0,                                       \
2874           "Will cause VM to terminate after a given time (in minutes) "     \
2875           "(0 means off)")                                                  \
2876           range(0, max_intx)                                                \
2877                                                                             \
2878   product(intx, MaxJavaStackTraceDepth, 1024,                               \
2879           "The maximum number of lines in the stack trace for Java "        \
2880           "exceptions (0 means all)")                                       \
2881           range(0, max_jint/2)                                              \
2882                                                                             \
2883   develop(bool, TraceStackWalk, false,                                      \
2884           "Trace stack walking")                                            \
2885                                                                             \
2886   /* notice: the max range value here is max_jint, not max_intx  */         \
2887   /* because of overflow issue                                   */         \
2888   diagnostic(intx, GuaranteedSafepointInterval, 1000,                       \
2889           "Guarantee a safepoint (at least) every so many milliseconds "    \
2890           "(0 means none)")                                                 \
2891           range(0, max_jint)                                                \
2892                                                                             \
2893   product(intx, SafepointTimeoutDelay, 10000,                               \
2894           "Delay in milliseconds for option SafepointTimeout")              \
2895   LP64_ONLY(range(0, max_intx/MICROUNITS))                                  \
2896   NOT_LP64(range(0, max_intx))                                              \
2897                                                                             \
2898   product(intx, NmethodSweepActivity, 10,                                   \
2899           "Removes cold nmethods from code cache if &gt; 0. Higher values "    \
2900           "result in more aggressive sweeping")                             \
2901           range(0, 2000)                                                    \
2902                                                                             \
2903   notproduct(bool, LogSweeper, false,                                       \
2904           "Keep a ring buffer of sweeper activity")                         \
2905                                                                             \
2906   notproduct(intx, SweeperLogEntries, 1024,                                 \
2907           "Number of records in the ring buffer of sweeper activity")       \
2908                                                                             \
2909   notproduct(intx, MemProfilingInterval, 500,                               \
2910           "Time between each invocation of the MemProfiler")                \
2911                                                                             \
2912   develop(intx, MallocCatchPtr, -1,                                         \
2913           "Hit breakpoint when mallocing/freeing this pointer")             \
2914                                                                             \
2915   notproduct(ccstrlist, SuppressErrorAt, "",                                \
2916           "List of assertions (file:line) to muzzle")                       \
2917                                                                             \
2918   develop(intx, StackPrintLimit, 100,                                       \
2919           "number of stack frames to print in VM-level stack dump")         \
2920                                                                             \
2921   notproduct(intx, MaxElementPrintSize, 256,                                \
2922           "maximum number of elements to print")                            \
2923                                                                             \
2924   notproduct(intx, MaxSubklassPrintSize, 4,                                 \
2925           "maximum number of subklasses to print when printing klass")      \
2926                                                                             \
2927   product(intx, MaxInlineLevel, 9,                                          \
2928           "maximum number of nested calls that are inlined")                \
2929           range(0, max_jint)                                                \
2930                                                                             \
2931   product(intx, MaxRecursiveInlineLevel, 1,                                 \
2932           "maximum number of nested recursive calls that are inlined")      \
2933           range(0, max_jint)                                                \
2934                                                                             \
2935   develop(intx, MaxForceInlineLevel, 100,                                   \
2936           "maximum number of nested calls that are forced for inlining "    \
2937           "(using CompileCommand or marked w/ @ForceInline)")               \
2938           range(0, max_jint)                                                \
2939                                                                             \
2940   product_pd(intx, InlineSmallCode,                                         \
2941           "Only inline already compiled methods if their code size is "     \
2942           "less than this")                                                 \
2943           range(0, max_jint)                                                \
2944                                                                             \
2945   product(intx, MaxInlineSize, 35,                                          \
2946           "The maximum bytecode size of a method to be inlined")            \
2947           range(0, max_jint)                                                \
2948                                                                             \
2949   product_pd(intx, FreqInlineSize,                                          \
2950           "The maximum bytecode size of a frequent method to be inlined")   \
2951           range(0, max_jint)                                                \
2952                                                                             \
2953   product(intx, MaxTrivialSize, 6,                                          \
2954           "The maximum bytecode size of a trivial method to be inlined")    \
2955           range(0, max_jint)                                                \
2956                                                                             \
2957   product(intx, MinInliningThreshold, 250,                                  \
2958           "The minimum invocation count a method needs to have to be "      \
2959           "inlined")                                                        \
2960           range(0, max_jint)                                                \
2961                                                                             \
2962   develop(intx, MethodHistogramCutoff, 100,                                 \
2963           "The cutoff value for method invocation histogram (+CountCalls)") \
2964                                                                             \
2965   diagnostic(intx, ProfilerNumberOfInterpretedMethods, 25,                  \
2966           "Number of interpreted methods to show in profile")               \
2967                                                                             \
2968   diagnostic(intx, ProfilerNumberOfCompiledMethods, 25,                     \
2969           "Number of compiled methods to show in profile")                  \
2970                                                                             \
2971   diagnostic(intx, ProfilerNumberOfStubMethods, 25,                         \
2972           "Number of stub methods to show in profile")                      \
2973                                                                             \
2974   diagnostic(intx, ProfilerNumberOfRuntimeStubNodes, 25,                    \
2975           "Number of runtime stub nodes to show in profile")                \
2976                                                                             \
2977   product(intx, ProfileIntervalsTicks, 100,                                 \
2978           "Number of ticks between printing of interval profile "           \
2979           "(+ProfileIntervals)")                                            \
2980           range(0, max_intx)                                                \
2981                                                                             \
2982   notproduct(intx, ScavengeALotInterval,     1,                             \
2983           "Interval between which scavenge will occur with +ScavengeALot")  \
2984                                                                             \
2985   notproduct(intx, FullGCALotInterval,     1,                               \
2986           "Interval between which full gc will occur with +FullGCALot")     \
2987                                                                             \
2988   notproduct(intx, FullGCALotStart,     0,                                  \
2989           "For which invocation to start FullGCAlot")                       \
2990                                                                             \
2991   notproduct(intx, FullGCALotDummies,  32*K,                                \
2992           "Dummy object allocated with +FullGCALot, forcing all objects "   \
2993           "to move")                                                        \
2994                                                                             \
2995   develop(intx, DontYieldALotInterval,    10,                               \
2996           "Interval between which yields will be dropped (milliseconds)")   \
2997                                                                             \
2998   develop(intx, MinSleepInterval,     1,                                    \
2999           "Minimum sleep() interval (milliseconds) when "                   \
3000           "ConvertSleepToYield is off (used for Solaris)")                  \
3001                                                                             \
3002   develop(intx, ProfilerPCTickThreshold,    15,                             \
3003           "Number of ticks in a PC buckets to be a hotspot")                \
3004                                                                             \
3005   notproduct(intx, DeoptimizeALotInterval,     5,                           \
3006           "Number of exits until DeoptimizeALot kicks in")                  \
3007                                                                             \
3008   notproduct(intx, ZombieALotInterval,     5,                               \
3009           "Number of exits until ZombieALot kicks in")                      \
3010                                                                             \
3011   diagnostic(intx, MallocVerifyInterval,     0,                             \
3012           "If non-zero, verify C heap after every N calls to "              \
3013           "malloc/realloc/free")                                            \
3014           range(0, max_intx)                                                \
3015                                                                             \
3016   diagnostic(intx, MallocVerifyStart,     0,                                \
3017           "If non-zero, start verifying C heap after Nth call to "          \
3018           "malloc/realloc/free")                                            \
3019           range(0, max_intx)                                                \
3020                                                                             \
3021   diagnostic(uintx, MallocMaxTestWords,     0,                              \
3022           "If non-zero, maximum number of words that malloc/realloc can "   \
3023           "allocate (for testing only)")                                    \
3024           range(0, max_uintx)                                               \
3025                                                                             \
3026   product(intx, TypeProfileWidth, 2,                                        \
3027           "Number of receiver types to record in call/cast profile")        \
3028           range(0, 8)                                                       \
3029                                                                             \
<a name="1" id="anc1"></a>


3030   develop(intx, BciProfileWidth,      2,                                    \
3031           "Number of return bci's to record in ret profile")                \
3032                                                                             \
3033   product(intx, PerMethodRecompilationCutoff, 400,                          \
3034           "After recompiling N times, stay in the interpreter (-1=&gt;'Inf')") \
3035           range(-1, max_intx)                                               \
3036                                                                             \
3037   product(intx, PerBytecodeRecompilationCutoff, 200,                        \
3038           "Per-BCI limit on repeated recompilation (-1=&gt;'Inf')")            \
3039           range(-1, max_intx)                                               \
3040                                                                             \
3041   product(intx, PerMethodTrapLimit,  100,                                   \
3042           "Limit on traps (of one kind) in a method (includes inlines)")    \
3043           range(0, max_jint)                                                \
3044                                                                             \
3045   experimental(intx, PerMethodSpecTrapLimit,  5000,                         \
3046           "Limit on speculative traps (of one kind) in a method "           \
3047           "(includes inlines)")                                             \
3048           range(0, max_jint)                                                \
3049                                                                             \
3050   product(intx, PerBytecodeTrapLimit,  4,                                   \
3051           "Limit on traps (of one kind) at a particular BCI")               \
3052           range(0, max_jint)                                                \
3053                                                                             \
3054   experimental(intx, SpecTrapLimitExtraEntries,  3,                         \
3055           "Extra method data trap entries for speculation")                 \
3056                                                                             \
3057   develop(intx, InlineFrequencyRatio,    20,                                \
3058           "Ratio of call site execution to caller method invocation")       \
3059           range(0, max_jint)                                                \
3060                                                                             \
3061   diagnostic_pd(intx, InlineFrequencyCount,                                 \
3062           "Count of call site execution necessary to trigger frequent "     \
3063           "inlining")                                                       \
3064           range(0, max_jint)                                                \
3065                                                                             \
3066   develop(intx, InlineThrowCount,    50,                                    \
3067           "Force inlining of interpreted methods that throw this often")    \
3068           range(0, max_jint)                                                \
3069                                                                             \
3070   develop(intx, InlineThrowMaxSize,   200,                                  \
3071           "Force inlining of throwing methods smaller than this")           \
3072           range(0, max_jint)                                                \
3073                                                                             \
3074   develop(intx, ProfilerNodeSize,  1024,                                    \
3075           "Size in K to allocate for the Profile Nodes of each thread")     \
3076           range(0, 1024)                                                    \
3077                                                                             \
3078   /* gc parameters */                                                       \
3079   product(size_t, InitialHeapSize, 0,                                       \
3080           "Initial heap size (in bytes); zero means use ergonomics")        \
3081           constraint(InitialHeapSizeConstraintFunc,AfterErgo)               \
3082                                                                             \
3083   product(size_t, MaxHeapSize, ScaleForWordSize(96*M),                      \
3084           "Maximum heap size (in bytes)")                                   \
3085           constraint(MaxHeapSizeConstraintFunc,AfterErgo)                   \
3086                                                                             \
3087   product(size_t, OldSize, ScaleForWordSize(4*M),                           \
3088           "Initial tenured generation size (in bytes)")                     \
3089           range(0, max_uintx)                                               \
3090                                                                             \
3091   product(size_t, NewSize, ScaleForWordSize(1*M),                           \
3092           "Initial new generation size (in bytes)")                         \
3093           constraint(NewSizeConstraintFunc,AfterErgo)                       \
3094                                                                             \
3095   product(size_t, MaxNewSize, max_uintx,                                    \
3096           "Maximum new generation size (in bytes), max_uintx means set "    \
3097           "ergonomically")                                                  \
3098           range(0, max_uintx)                                               \
3099                                                                             \
3100   product_pd(size_t, HeapBaseMinAddress,                                    \
3101           "OS specific low limit for heap base address")                    \
3102           constraint(HeapBaseMinAddressConstraintFunc,AfterErgo)            \
3103                                                                             \
3104   product(size_t, PretenureSizeThreshold, 0,                                \
3105           "Maximum size in bytes of objects allocated in DefNew "           \
3106           "generation; zero means no maximum")                              \
3107           range(0, max_uintx)                                               \
3108                                                                             \
3109   product(size_t, MinTLABSize, 2*K,                                         \
3110           "Minimum allowed TLAB size (in bytes)")                           \
3111           range(1, max_uintx/2)                                             \
3112           constraint(MinTLABSizeConstraintFunc,AfterMemoryInit)             \
3113                                                                             \
3114   product(size_t, TLABSize, 0,                                              \
3115           "Starting TLAB size (in bytes); zero means set ergonomically")    \
3116           constraint(TLABSizeConstraintFunc,AfterMemoryInit)                \
3117                                                                             \
3118   product(size_t, YoungPLABSize, 4096,                                      \
3119           "Size of young gen promotion LAB's (in HeapWords)")               \
3120           constraint(YoungPLABSizeConstraintFunc,AfterMemoryInit)           \
3121                                                                             \
3122   product(size_t, OldPLABSize, 1024,                                        \
3123           "Size of old gen promotion LAB's (in HeapWords), or Number "      \
3124           "of blocks to attempt to claim when refilling CMS LAB's")         \
3125           constraint(OldPLABSizeConstraintFunc,AfterMemoryInit)             \
3126                                                                             \
3127   product(uintx, TLABAllocationWeight, 35,                                  \
3128           "Allocation averaging weight")                                    \
3129           range(0, 100)                                                     \
3130                                                                             \
3131   /* Limit the lower bound of this flag to 1 as it is used  */              \
3132   /* in a division expression.                              */              \
3133   product(uintx, TLABWasteTargetPercent, 1,                                 \
3134           "Percentage of Eden that can be wasted")                          \
3135           range(1, 100)                                                     \
3136                                                                             \
3137   product(uintx, TLABRefillWasteFraction,    64,                            \
3138           "Maximum TLAB waste at a refill (internal fragmentation)")        \
3139           range(1, max_juint)                                               \
3140                                                                             \
3141   product(uintx, TLABWasteIncrement,    4,                                  \
3142           "Increment allowed waste at slow allocation")                     \
3143           range(0, max_jint)                                                \
3144           constraint(TLABWasteIncrementConstraintFunc,AfterMemoryInit)      \
3145                                                                             \
3146   product(uintx, SurvivorRatio, 8,                                          \
3147           "Ratio of eden/survivor space size")                              \
3148           range(1, max_uintx-2)                                             \
3149           constraint(SurvivorRatioConstraintFunc,AfterMemoryInit)           \
3150                                                                             \
3151   product(uintx, NewRatio, 2,                                               \
3152           "Ratio of old/new generation sizes")                              \
3153           range(0, max_uintx-1)                                             \
3154                                                                             \
3155   product_pd(size_t, NewSizeThreadIncrease,                                 \
3156           "Additional size added to desired new generation size per "       \
3157           "non-daemon thread (in bytes)")                                   \
3158           range(0, max_uintx)                                               \
3159                                                                             \
3160   product_pd(size_t, MetaspaceSize,                                         \
3161           "Initial threshold (in bytes) at which a garbage collection "     \
3162           "is done to reduce Metaspace usage")                              \
3163           constraint(MetaspaceSizeConstraintFunc,AfterErgo)                 \
3164                                                                             \
3165   product(size_t, MaxMetaspaceSize, max_uintx,                              \
3166           "Maximum size of Metaspaces (in bytes)")                          \
3167           constraint(MaxMetaspaceSizeConstraintFunc,AfterErgo)              \
3168                                                                             \
3169   product(size_t, CompressedClassSpaceSize, 1*G,                            \
3170           "Maximum size of class area in Metaspace when compressed "        \
3171           "class pointers are used")                                        \
3172           range(1*M, 3*G)                                                   \
3173                                                                             \
3174   manageable(uintx, MinHeapFreeRatio, 40,                                   \
3175           "The minimum percentage of heap free after GC to avoid expansion."\
3176           " For most GCs this applies to the old generation. In G1 and"     \
3177           " ParallelGC it applies to the whole heap.")                      \
3178           range(0, 100)                                                     \
3179           constraint(MinHeapFreeRatioConstraintFunc,AfterErgo)              \
3180                                                                             \
3181   manageable(uintx, MaxHeapFreeRatio, 70,                                   \
3182           "The maximum percentage of heap free after GC to avoid shrinking."\
3183           " For most GCs this applies to the old generation. In G1 and"     \
3184           " ParallelGC it applies to the whole heap.")                      \
3185           range(0, 100)                                                     \
3186           constraint(MaxHeapFreeRatioConstraintFunc,AfterErgo)              \
3187                                                                             \
3188   product(bool, ShrinkHeapInSteps, true,                                    \
3189           "When disabled, informs the GC to shrink the java heap directly"  \
3190           " to the target size at the next full GC rather than requiring"   \
3191           " smaller steps during multiple full GCs.")                       \
3192                                                                             \
3193   product(intx, SoftRefLRUPolicyMSPerMB, 1000,                              \
3194           "Number of milliseconds per MB of free space in the heap")        \
3195           range(0, max_intx)                                                \
3196           constraint(SoftRefLRUPolicyMSPerMBConstraintFunc,AfterMemoryInit) \
3197                                                                             \
3198   product(size_t, MinHeapDeltaBytes, ScaleForWordSize(128*K),               \
3199           "The minimum change in heap space due to GC (in bytes)")          \
3200           range(0, max_uintx)                                               \
3201                                                                             \
3202   product(size_t, MinMetaspaceExpansion, ScaleForWordSize(256*K),           \
3203           "The minimum expansion of Metaspace (in bytes)")                  \
3204           range(0, max_uintx)                                               \
3205                                                                             \
3206   product(uintx, MaxMetaspaceFreeRatio,    70,                              \
3207           "The maximum percentage of Metaspace free after GC to avoid "     \
3208           "shrinking")                                                      \
3209           range(0, 100)                                                     \
3210           constraint(MaxMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
3211                                                                             \
3212   product(uintx, MinMetaspaceFreeRatio,    40,                              \
3213           "The minimum percentage of Metaspace free after GC to avoid "     \
3214           "expansion")                                                      \
3215           range(0, 99)                                                      \
3216           constraint(MinMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
3217                                                                             \
3218   product(size_t, MaxMetaspaceExpansion, ScaleForWordSize(4*M),             \
3219           "The maximum expansion of Metaspace without full GC (in bytes)")  \
3220           range(0, max_uintx)                                               \
3221                                                                             \
3222   product(uintx, QueuedAllocationWarningCount, 0,                           \
3223           "Number of times an allocation that queues behind a GC "          \
3224           "will retry before printing a warning")                           \
3225           range(0, max_uintx)                                               \
3226                                                                             \
3227   diagnostic(uintx, VerifyGCStartAt,   0,                                   \
3228           "GC invoke count where +VerifyBefore/AfterGC kicks in")           \
3229           range(0, max_uintx)                                               \
3230                                                                             \
3231   diagnostic(intx, VerifyGCLevel,     0,                                    \
3232           "Generation level at which to start +VerifyBefore/AfterGC")       \
3233           range(0, 1)                                                       \
3234                                                                             \
3235   product(uintx, MaxTenuringThreshold,    15,                               \
3236           "Maximum value for tenuring threshold")                           \
3237           range(0, markOopDesc::max_age + 1)                                \
3238           constraint(MaxTenuringThresholdConstraintFunc,AfterErgo)          \
3239                                                                             \
3240   product(uintx, InitialTenuringThreshold,    7,                            \
3241           "Initial value for tenuring threshold")                           \
3242           range(0, markOopDesc::max_age + 1)                                \
3243           constraint(InitialTenuringThresholdConstraintFunc,AfterErgo)      \
3244                                                                             \
3245   product(uintx, TargetSurvivorRatio,    50,                                \
3246           "Desired percentage of survivor space used after scavenge")       \
3247           range(0, 100)                                                     \
3248                                                                             \
3249   product(uintx, MarkSweepDeadRatio,     5,                                 \
3250           "Percentage (0-100) of the old gen allowed as dead wood. "        \
3251           "Serial mark sweep treats this as both the minimum and maximum "  \
3252           "value. "                                                         \
3253           "CMS uses this value only if it falls back to mark sweep. "       \
3254           "Par compact uses a variable scale based on the density of the "  \
3255           "generation and treats this as the maximum value when the heap "  \
3256           "is either completely full or completely empty.  Par compact "    \
3257           "also has a smaller default value; see arguments.cpp.")           \
3258           range(0, 100)                                                     \
3259                                                                             \
3260   product(uint, MarkSweepAlwaysCompactCount,     4,                         \
3261           "How often should we fully compact the heap (ignoring the dead "  \
3262           "space parameters)")                                              \
3263           range(1, max_juint)                                               \
3264                                                                             \
3265   develop(uintx, GCExpandToAllocateDelayMillis, 0,                          \
3266           "Delay between expansion and allocation (in milliseconds)")       \
3267                                                                             \
3268   develop(uintx, GCWorkerDelayMillis, 0,                                    \
3269           "Delay in scheduling GC workers (in milliseconds)")               \
3270                                                                             \
3271   product(intx, DeferThrSuspendLoopCount,     4000,                         \
3272           "(Unstable) Number of times to iterate in safepoint loop "        \
3273           "before blocking VM threads ")                                    \
3274           range(-1, max_jint-1)                                             \
3275                                                                             \
3276   product(intx, DeferPollingPageLoopCount,     -1,                          \
3277           "(Unsafe,Unstable) Number of iterations in safepoint loop "       \
3278           "before changing safepoint polling page to RO ")                  \
3279           range(-1, max_jint-1)                                             \
3280                                                                             \
3281   product(intx, SafepointSpinBeforeYield, 2000, "(Unstable)")               \
3282           range(0, max_intx)                                                \
3283                                                                             \
3284   product(bool, PSChunkLargeArrays, true,                                   \
3285           "Process large arrays in chunks")                                 \
3286                                                                             \
3287   product(uintx, GCDrainStackTargetSize, 64,                                \
3288           "Number of entries we will try to leave on the stack "            \
3289           "during parallel gc")                                             \
3290           range(0, max_juint)                                               \
3291                                                                             \
3292   /* stack parameters */                                                    \
3293   product_pd(intx, StackYellowPages,                                        \
3294           "Number of yellow zone (recoverable overflows) pages of size "    \
3295           "4KB. If pages are bigger yellow zone is aligned up.")            \
3296           range(MIN_STACK_YELLOW_PAGES, (DEFAULT_STACK_YELLOW_PAGES+5))     \
3297                                                                             \
3298   product_pd(intx, StackRedPages,                                           \
3299           "Number of red zone (unrecoverable overflows) pages of size "     \
3300           "4KB. If pages are bigger red zone is aligned up.")               \
3301           range(MIN_STACK_RED_PAGES, (DEFAULT_STACK_RED_PAGES+2))           \
3302                                                                             \
3303   product_pd(intx, StackReservedPages,                                      \
3304           "Number of reserved zone (reserved to annotated methods) pages"   \
3305           " of size 4KB. If pages are bigger reserved zone is aligned up.") \
3306           range(MIN_STACK_RESERVED_PAGES, (DEFAULT_STACK_RESERVED_PAGES+10))\
3307                                                                             \
3308   product(bool, RestrictReservedStack, true,                                \
3309           "Restrict @ReservedStackAccess to trusted classes")               \
3310                                                                             \
3311   /* greater stack shadow pages can't generate instruction to bang stack */ \
3312   product_pd(intx, StackShadowPages,                                        \
3313           "Number of shadow zone (for overflow checking) pages of size "    \
3314           "4KB. If pages are bigger shadow zone is aligned up. "            \
3315           "This should exceed the depth of the VM and native call stack.")  \
3316           range(MIN_STACK_SHADOW_PAGES, (DEFAULT_STACK_SHADOW_PAGES+30))    \
3317                                                                             \
3318   product_pd(intx, ThreadStackSize,                                         \
3319           "Thread Stack Size (in Kbytes)")                                  \
3320           range(0, (max_intx-os::vm_page_size())/(1 * K))                   \
3321                                                                             \
3322   product_pd(intx, VMThreadStackSize,                                       \
3323           "Non-Java Thread Stack Size (in Kbytes)")                         \
3324           range(0, max_intx/(1 * K))                                        \
3325                                                                             \
3326   product_pd(intx, CompilerThreadStackSize,                                 \
3327           "Compiler Thread Stack Size (in Kbytes)")                         \
3328           range(0, max_intx/(1 * K))                                        \
3329                                                                             \
3330   develop_pd(size_t, JVMInvokeMethodSlack,                                  \
3331           "Stack space (bytes) required for JVM_InvokeMethod to complete")  \
3332                                                                             \
3333   /* code cache parameters                                    */            \
3334   /* ppc64/tiered compilation has large code-entry alignment. */            \
3335   develop(uintx, CodeCacheSegmentSize,                                      \
3336           64 PPC64_ONLY(+64) NOT_PPC64(TIERED_ONLY(+64)),                   \
3337           "Code cache segment size (in bytes) - smallest unit of "          \
3338           "allocation")                                                     \
3339           range(1, 1024)                                                    \
3340           constraint(CodeCacheSegmentSizeConstraintFunc, AfterErgo)         \
3341                                                                             \
3342   develop_pd(intx, CodeEntryAlignment,                                      \
3343           "Code entry alignment for generated code (in bytes)")             \
3344           constraint(CodeEntryAlignmentConstraintFunc, AfterErgo)           \
3345                                                                             \
3346   product_pd(intx, OptoLoopAlignment,                                       \
3347           "Align inner loops to zero relative to this modulus")             \
3348           range(1, 16)                                                      \
3349           constraint(OptoLoopAlignmentConstraintFunc, AfterErgo)            \
3350                                                                             \
3351   product_pd(uintx, InitialCodeCacheSize,                                   \
3352           "Initial code cache size (in bytes)")                             \
3353           range(0, max_uintx)                                               \
3354                                                                             \
3355   develop_pd(uintx, CodeCacheMinimumUseSpace,                               \
3356           "Minimum code cache size (in bytes) required to start VM.")       \
3357           range(0, max_uintx)                                               \
3358                                                                             \
3359   product(bool, SegmentedCodeCache, false,                                  \
3360           "Use a segmented code cache")                                     \
3361                                                                             \
3362   product_pd(uintx, ReservedCodeCacheSize,                                  \
3363           "Reserved code cache size (in bytes) - maximum code cache size")  \
3364           range(0, max_uintx)                                               \
3365                                                                             \
3366   product_pd(uintx, NonProfiledCodeHeapSize,                                \
3367           "Size of code heap with non-profiled methods (in bytes)")         \
3368           range(0, max_uintx)                                               \
3369                                                                             \
3370   product_pd(uintx, ProfiledCodeHeapSize,                                   \
3371           "Size of code heap with profiled methods (in bytes)")             \
3372           range(0, max_uintx)                                               \
3373                                                                             \
3374   product_pd(uintx, NonNMethodCodeHeapSize,                                 \
3375           "Size of code heap with non-nmethods (in bytes)")                 \
3376           range(0, max_uintx)                                               \
3377                                                                             \
3378   product_pd(uintx, CodeCacheExpansionSize,                                 \
3379           "Code cache expansion size (in bytes)")                           \
3380           range(0, max_uintx)                                               \
3381                                                                             \
3382   develop_pd(uintx, CodeCacheMinBlockLength,                                \
3383           "Minimum number of segments in a code cache block")               \
3384           range(1, 100)                                                     \
3385                                                                             \
3386   notproduct(bool, ExitOnFullCodeCache, false,                              \
3387           "Exit the VM if we fill the code cache")                          \
3388                                                                             \
3389   product(bool, UseCodeCacheFlushing, true,                                 \
3390           "Remove cold/old nmethods from the code cache")                   \
3391                                                                             \
3392   product(uintx, StartAggressiveSweepingAt, 10,                             \
3393           "Start aggressive sweeping if X[%] of the code cache is free."    \
3394           "Segmented code cache: X[%] of the non-profiled heap."            \
3395           "Non-segmented code cache: X[%] of the total code cache")         \
3396           range(0, 100)                                                     \
3397                                                                             \
3398   /* interpreter debugging */                                               \
3399   develop(intx, BinarySwitchThreshold, 5,                                   \
3400           "Minimal number of lookupswitch entries for rewriting to binary " \
3401           "switch")                                                         \
3402                                                                             \
3403   develop(intx, StopInterpreterAt, 0,                                       \
3404           "Stop interpreter execution at specified bytecode number")        \
3405                                                                             \
3406   develop(intx, TraceBytecodesAt, 0,                                        \
3407           "Trace bytecodes starting with specified bytecode number")        \
3408                                                                             \
3409   /* compiler interface */                                                  \
3410   develop(intx, CIStart, 0,                                                 \
3411           "The id of the first compilation to permit")                      \
3412                                                                             \
3413   develop(intx, CIStop, max_jint,                                           \
3414           "The id of the last compilation to permit")                       \
3415                                                                             \
3416   develop(intx, CIStartOSR, 0,                                              \
3417           "The id of the first osr compilation to permit "                  \
3418           "(CICountOSR must be on)")                                        \
3419                                                                             \
3420   develop(intx, CIStopOSR, max_jint,                                        \
3421           "The id of the last osr compilation to permit "                   \
3422           "(CICountOSR must be on)")                                        \
3423                                                                             \
3424   develop(intx, CIBreakAtOSR, -1,                                           \
3425           "The id of osr compilation to break at")                          \
3426                                                                             \
3427   develop(intx, CIBreakAt, -1,                                              \
3428           "The id of compilation to break at")                              \
3429                                                                             \
3430   product(ccstrlist, CompileOnly, "",                                       \
3431           "List of methods (pkg/class.name) to restrict compilation to")    \
3432                                                                             \
3433   product(ccstr, CompileCommandFile, NULL,                                  \
3434           "Read compiler commands from this file [.hotspot_compiler]")      \
3435                                                                             \
3436   diagnostic(ccstr, CompilerDirectivesFile, NULL,                           \
3437           "Read compiler directives from this file")                        \
3438                                                                             \
3439   product(ccstrlist, CompileCommand, "",                                    \
3440           "Prepend to .hotspot_compiler; e.g. log,java/lang/String.&lt;init&gt;") \
3441                                                                             \
3442   develop(bool, ReplayCompiles, false,                                      \
3443           "Enable replay of compilations from ReplayDataFile")              \
3444                                                                             \
3445   product(ccstr, ReplayDataFile, NULL,                                      \
3446           "File containing compilation replay information"                  \
3447           "[default: ./replay_pid%p.log] (%p replaced with pid)")           \
3448                                                                             \
3449    product(ccstr, InlineDataFile, NULL,                                     \
3450           "File containing inlining replay information"                     \
3451           "[default: ./inline_pid%p.log] (%p replaced with pid)")           \
3452                                                                             \
3453   develop(intx, ReplaySuppressInitializers, 2,                              \
3454           "Control handling of class initialization during replay: "        \
3455           "0 - don't do anything special; "                                 \
3456           "1 - treat all class initializers as empty; "                     \
3457           "2 - treat class initializers for application classes as empty; " \
3458           "3 - allow all class initializers to run during bootstrap but "   \
3459           "    pretend they are empty after starting replay")               \
3460           range(0, 3)                                                       \
3461                                                                             \
3462   develop(bool, ReplayIgnoreInitErrors, false,                              \
3463           "Ignore exceptions thrown during initialization for replay")      \
3464                                                                             \
3465   product(bool, DumpReplayDataOnError, true,                                \
3466           "Record replay data for crashing compiler threads")               \
3467                                                                             \
3468   product(bool, CICompilerCountPerCPU, false,                               \
3469           "1 compiler thread for log(N CPUs)")                              \
3470                                                                             \
3471   develop(intx, CIFireOOMAt,    -1,                                         \
3472           "Fire OutOfMemoryErrors throughout CI for testing the compiler "  \
3473           "(non-negative value throws OOM after this many CI accesses "     \
3474           "in each compile)")                                               \
3475   notproduct(intx, CICrashAt, -1,                                           \
3476           "id of compilation to trigger assert in compiler thread for "     \
3477           "the purpose of testing, e.g. generation of replay data")         \
3478   notproduct(bool, CIObjectFactoryVerify, false,                            \
3479           "enable potentially expensive verification in ciObjectFactory")   \
3480                                                                             \
3481   /* Priorities */                                                          \
3482   product_pd(bool, UseThreadPriorities,  "Use native thread priorities")    \
3483                                                                             \
3484   product(intx, ThreadPriorityPolicy, 0,                                    \
3485           "0 : Normal.                                                     "\
3486           "    VM chooses priorities that are appropriate for normal       "\
3487           "    applications. On Solaris NORM_PRIORITY and above are mapped "\
3488           "    to normal native priority. Java priorities below "           \
3489           "    NORM_PRIORITY map to lower native priority values. On       "\
3490           "    Windows applications are allowed to use higher native       "\
3491           "    priorities. However, with ThreadPriorityPolicy=0, VM will   "\
3492           "    not use the highest possible native priority,               "\
3493           "    THREAD_PRIORITY_TIME_CRITICAL, as it may interfere with     "\
3494           "    system threads. On Linux thread priorities are ignored      "\
3495           "    because the OS does not support static priority in          "\
3496           "    SCHED_OTHER scheduling class which is the only choice for   "\
3497           "    non-root, non-realtime applications.                        "\
3498           "1 : Aggressive.                                                 "\
3499           "    Java thread priorities map over to the entire range of      "\
3500           "    native thread priorities. Higher Java thread priorities map "\
3501           "    to higher native thread priorities. This policy should be   "\
3502           "    used with care, as sometimes it can cause performance       "\
3503           "    degradation in the application and/or the entire system. On "\
3504           "    Linux this policy requires root privilege.")                 \
3505           range(0, 1)                                                       \
3506                                                                             \
3507   product(bool, ThreadPriorityVerbose, false,                               \
3508           "Print priority changes")                                         \
3509                                                                             \
3510   product(intx, CompilerThreadPriority, -1,                                 \
3511           "The native priority at which compiler threads should run "       \
3512           "(-1 means no change)")                                           \
3513           range(min_jint, max_jint)                                         \
3514           constraint(CompilerThreadPriorityConstraintFunc, AfterErgo)       \
3515                                                                             \
3516   product(intx, VMThreadPriority, -1,                                       \
3517           "The native priority at which the VM thread should run "          \
3518           "(-1 means no change)")                                           \
3519           range(-1, 127)                                                    \
3520                                                                             \
3521   product(bool, CompilerThreadHintNoPreempt, true,                          \
3522           "(Solaris only) Give compiler threads an extra quanta")           \
3523                                                                             \
3524   product(bool, VMThreadHintNoPreempt, false,                               \
3525           "(Solaris only) Give VM thread an extra quanta")                  \
3526                                                                             \
3527   product(intx, JavaPriority1_To_OSPriority, -1,                            \
3528           "Map Java priorities to OS priorities")                           \
3529           range(-1, 127)                                                    \
3530                                                                             \
3531   product(intx, JavaPriority2_To_OSPriority, -1,                            \
3532           "Map Java priorities to OS priorities")                           \
3533           range(-1, 127)                                                    \
3534                                                                             \
3535   product(intx, JavaPriority3_To_OSPriority, -1,                            \
3536           "Map Java priorities to OS priorities")                           \
3537           range(-1, 127)                                                    \
3538                                                                             \
3539   product(intx, JavaPriority4_To_OSPriority, -1,                            \
3540           "Map Java priorities to OS priorities")                           \
3541           range(-1, 127)                                                    \
3542                                                                             \
3543   product(intx, JavaPriority5_To_OSPriority, -1,                            \
3544           "Map Java priorities to OS priorities")                           \
3545           range(-1, 127)                                                    \
3546                                                                             \
3547   product(intx, JavaPriority6_To_OSPriority, -1,                            \
3548           "Map Java priorities to OS priorities")                           \
3549           range(-1, 127)                                                    \
3550                                                                             \
3551   product(intx, JavaPriority7_To_OSPriority, -1,                            \
3552           "Map Java priorities to OS priorities")                           \
3553           range(-1, 127)                                                    \
3554                                                                             \
3555   product(intx, JavaPriority8_To_OSPriority, -1,                            \
3556           "Map Java priorities to OS priorities")                           \
3557           range(-1, 127)                                                    \
3558                                                                             \
3559   product(intx, JavaPriority9_To_OSPriority, -1,                            \
3560           "Map Java priorities to OS priorities")                           \
3561           range(-1, 127)                                                    \
3562                                                                             \
3563   product(intx, JavaPriority10_To_OSPriority,-1,                            \
3564           "Map Java priorities to OS priorities")                           \
3565           range(-1, 127)                                                    \
3566                                                                             \
3567   experimental(bool, UseCriticalJavaThreadPriority, false,                  \
3568           "Java thread priority 10 maps to critical scheduling priority")   \
3569                                                                             \
3570   experimental(bool, UseCriticalCompilerThreadPriority, false,              \
3571           "Compiler thread(s) run at critical scheduling priority")         \
3572                                                                             \
3573   experimental(bool, UseCriticalCMSThreadPriority, false,                   \
3574           "ConcurrentMarkSweep thread runs at critical scheduling priority")\
3575                                                                             \
3576   /* compiler debugging */                                                  \
3577   notproduct(intx, CompileTheWorldStartAt,     1,                           \
3578           "First class to consider when using +CompileTheWorld")            \
3579                                                                             \
3580   notproduct(intx, CompileTheWorldStopAt, max_jint,                         \
3581           "Last class to consider when using +CompileTheWorld")             \
3582                                                                             \
3583   develop(intx, NewCodeParameter,      0,                                   \
3584           "Testing Only: Create a dedicated integer parameter before "      \
3585           "putback")                                                        \
3586                                                                             \
3587   /* new oopmap storage allocation */                                       \
3588   develop(intx, MinOopMapAllocation,     8,                                 \
3589           "Minimum number of OopMap entries in an OopMapSet")               \
3590                                                                             \
3591   /* Background Compilation */                                              \
3592   develop(intx, LongCompileThreshold,     50,                               \
3593           "Used with +TraceLongCompiles")                                   \
3594                                                                             \
3595   /* recompilation */                                                       \
3596   product_pd(intx, CompileThreshold,                                        \
3597           "number of interpreted method invocations before (re-)compiling") \
3598           constraint(CompileThresholdConstraintFunc, AfterErgo)             \
3599                                                                             \
3600   product(double, CompileThresholdScaling, 1.0,                             \
3601           "Factor to control when first compilation happens "               \
3602           "(both with and without tiered compilation): "                    \
3603           "values greater than 1.0 delay counter overflow, "                \
3604           "values between 0 and 1.0 rush counter overflow, "                \
3605           "value of 1.0 leaves compilation thresholds unchanged "           \
3606           "value of 0.0 is equivalent to -Xint. "                           \
3607           ""                                                                \
3608           "Flag can be set as per-method option. "                          \
3609           "If a value is specified for a method, compilation thresholds "   \
3610           "for that method are scaled by both the value of the global flag "\
3611           "and the value of the per-method flag.")                          \
3612           range(0.0, DBL_MAX)                                               \
3613                                                                             \
3614   product(intx, Tier0InvokeNotifyFreqLog, 7,                                \
3615           "Interpreter (tier 0) invocation notification frequency")         \
3616           range(0, 30)                                                      \
3617                                                                             \
3618   product(intx, Tier2InvokeNotifyFreqLog, 11,                               \
3619           "C1 without MDO (tier 2) invocation notification frequency")      \
3620           range(0, 30)                                                      \
3621                                                                             \
3622   product(intx, Tier3InvokeNotifyFreqLog, 10,                               \
3623           "C1 with MDO profiling (tier 3) invocation notification "         \
3624           "frequency")                                                      \
3625           range(0, 30)                                                      \
3626                                                                             \
3627   product(intx, Tier23InlineeNotifyFreqLog, 20,                             \
3628           "Inlinee invocation (tiers 2 and 3) notification frequency")      \
3629           range(0, 30)                                                      \
3630                                                                             \
3631   product(intx, Tier0BackedgeNotifyFreqLog, 10,                             \
3632           "Interpreter (tier 0) invocation notification frequency")         \
3633           range(0, 30)                                                      \
3634                                                                             \
3635   product(intx, Tier2BackedgeNotifyFreqLog, 14,                             \
3636           "C1 without MDO (tier 2) invocation notification frequency")      \
3637           range(0, 30)                                                      \
3638                                                                             \
3639   product(intx, Tier3BackedgeNotifyFreqLog, 13,                             \
3640           "C1 with MDO profiling (tier 3) invocation notification "         \
3641           "frequency")                                                      \
3642           range(0, 30)                                                      \
3643                                                                             \
3644   product(intx, Tier2CompileThreshold, 0,                                   \
3645           "threshold at which tier 2 compilation is invoked")               \
3646           range(0, max_jint)                                                \
3647                                                                             \
3648   product(intx, Tier2BackEdgeThreshold, 0,                                  \
3649           "Back edge threshold at which tier 2 compilation is invoked")     \
3650           range(0, max_jint)                                                \
3651                                                                             \
3652   product(intx, Tier3InvocationThreshold, 200,                              \
3653           "Compile if number of method invocations crosses this "           \
3654           "threshold")                                                      \
3655           range(0, max_jint)                                                \
3656                                                                             \
3657   product(intx, Tier3MinInvocationThreshold, 100,                           \
3658           "Minimum invocation to compile at tier 3")                        \
3659           range(0, max_jint)                                                \
3660                                                                             \
3661   product(intx, Tier3CompileThreshold, 2000,                                \
3662           "Threshold at which tier 3 compilation is invoked (invocation "   \
3663           "minimum must be satisfied)")                                     \
3664           range(0, max_jint)                                                \
3665                                                                             \
3666   product(intx, Tier3BackEdgeThreshold,  60000,                             \
3667           "Back edge threshold at which tier 3 OSR compilation is invoked") \
3668           range(0, max_jint)                                                \
3669                                                                             \
3670   product(intx, Tier4InvocationThreshold, 5000,                             \
3671           "Compile if number of method invocations crosses this "           \
3672           "threshold")                                                      \
3673           range(0, max_jint)                                                \
3674                                                                             \
3675   product(intx, Tier4MinInvocationThreshold, 600,                           \
3676           "Minimum invocation to compile at tier 4")                        \
3677           range(0, max_jint)                                                \
3678                                                                             \
3679   product(intx, Tier4CompileThreshold, 15000,                               \
3680           "Threshold at which tier 4 compilation is invoked (invocation "   \
3681           "minimum must be satisfied")                                      \
3682           range(0, max_jint)                                                \
3683                                                                             \
3684   product(intx, Tier4BackEdgeThreshold, 40000,                              \
3685           "Back edge threshold at which tier 4 OSR compilation is invoked") \
3686           range(0, max_jint)                                                \
3687                                                                             \
3688   product(intx, Tier3DelayOn, 5,                                            \
3689           "If C2 queue size grows over this amount per compiler thread "    \
3690           "stop compiling at tier 3 and start compiling at tier 2")         \
3691           range(0, max_jint)                                                \
3692                                                                             \
3693   product(intx, Tier3DelayOff, 2,                                           \
3694           "If C2 queue size is less than this amount per compiler thread "  \
3695           "allow methods compiled at tier 2 transition to tier 3")          \
3696           range(0, max_jint)                                                \
3697                                                                             \
3698   product(intx, Tier3LoadFeedback, 5,                                       \
3699           "Tier 3 thresholds will increase twofold when C1 queue size "     \
3700           "reaches this amount per compiler thread")                        \
3701           range(0, max_jint)                                                \
3702                                                                             \
3703   product(intx, Tier4LoadFeedback, 3,                                       \
3704           "Tier 4 thresholds will increase twofold when C2 queue size "     \
3705           "reaches this amount per compiler thread")                        \
3706           range(0, max_jint)                                                \
3707                                                                             \
3708   product(intx, TieredCompileTaskTimeout, 50,                               \
3709           "Kill compile task if method was not used within "                \
3710           "given timeout in milliseconds")                                  \
3711           range(0, max_intx)                                                \
3712                                                                             \
3713   product(intx, TieredStopAtLevel, 4,                                       \
3714           "Stop at given compilation level")                                \
3715           range(0, 4)                                                       \
3716                                                                             \
3717   product(intx, Tier0ProfilingStartPercentage, 200,                         \
3718           "Start profiling in interpreter if the counters exceed tier 3 "   \
3719           "thresholds by the specified percentage")                         \
3720           range(0, max_jint)                                                \
3721                                                                             \
3722   product(uintx, IncreaseFirstTierCompileThresholdAt, 50,                   \
3723           "Increase the compile threshold for C1 compilation if the code "  \
3724           "cache is filled by the specified percentage")                    \
3725           range(0, 99)                                                      \
3726                                                                             \
3727   product(intx, TieredRateUpdateMinTime, 1,                                 \
3728           "Minimum rate sampling interval (in milliseconds)")               \
3729           range(0, max_intx)                                                \
3730                                                                             \
3731   product(intx, TieredRateUpdateMaxTime, 25,                                \
3732           "Maximum rate sampling interval (in milliseconds)")               \
3733           range(0, max_intx)                                                \
3734                                                                             \
3735   product_pd(bool, TieredCompilation,                                       \
3736           "Enable tiered compilation")                                      \
3737                                                                             \
3738   product(bool, PrintTieredEvents, false,                                   \
3739           "Print tiered events notifications")                              \
3740                                                                             \
3741   product_pd(intx, OnStackReplacePercentage,                                \
3742           "NON_TIERED number of method invocations/branches (expressed as " \
3743           "% of CompileThreshold) before (re-)compiling OSR code")          \
3744           constraint(OnStackReplacePercentageConstraintFunc, AfterErgo)     \
3745                                                                             \
3746   product(intx, InterpreterProfilePercentage, 33,                           \
3747           "NON_TIERED number of method invocations/branches (expressed as " \
3748           "% of CompileThreshold) before profiling in the interpreter")     \
3749           range(0, 100)                                                     \
3750                                                                             \
3751   develop(intx, MaxRecompilationSearchLength,    10,                        \
3752           "The maximum number of frames to inspect when searching for "     \
3753           "recompilee")                                                     \
3754                                                                             \
3755   develop(intx, MaxInterpretedSearchLength,     3,                          \
3756           "The maximum number of interpreted frames to skip when searching "\
3757           "for recompilee")                                                 \
3758                                                                             \
3759   develop(intx, DesiredMethodLimit,  8000,                                  \
3760           "The desired maximum method size (in bytecodes) after inlining")  \
3761                                                                             \
3762   develop(intx, HugeMethodLimit,  8000,                                     \
3763           "Don't compile methods larger than this if "                      \
3764           "+DontCompileHugeMethods")                                        \
3765                                                                             \
3766   /* New JDK 1.4 reflection implementation */                               \
3767                                                                             \
3768   develop(intx, FastSuperclassLimit, 8,                                     \
3769           "Depth of hardwired instanceof accelerator array")                \
3770                                                                             \
3771   /* Properties for Java libraries  */                                      \
3772                                                                             \
3773   product(uint64_t, MaxDirectMemorySize, 0,                                 \
3774           "Maximum total size of NIO direct-buffer allocations")            \
3775           range(0, max_jlong)                                               \
3776                                                                             \
3777   /* Flags used for temporary code during development  */                   \
3778                                                                             \
3779   diagnostic(bool, UseNewCode, false,                                       \
3780           "Testing Only: Use the new version while testing")                \
3781                                                                             \
3782   diagnostic(bool, UseNewCode2, false,                                      \
3783           "Testing Only: Use the new version while testing")                \
3784                                                                             \
3785   diagnostic(bool, UseNewCode3, false,                                      \
3786           "Testing Only: Use the new version while testing")                \
3787                                                                             \
3788   /* flags for performance data collection */                               \
3789                                                                             \
3790   product(bool, UsePerfData, true,                                          \
3791           "Flag to disable jvmstat instrumentation for performance testing "\
3792           "and problem isolation purposes")                                 \
3793                                                                             \
3794   product(bool, PerfDataSaveToFile, false,                                  \
3795           "Save PerfData memory to hsperfdata_&lt;pid&gt; file on exit")          \
3796                                                                             \
3797   product(ccstr, PerfDataSaveFile, NULL,                                    \
3798           "Save PerfData memory to the specified absolute pathname. "       \
3799           "The string %p in the file name (if present) "                    \
3800           "will be replaced by pid")                                        \
3801                                                                             \
3802   product(intx, PerfDataSamplingInterval, 50,                               \
3803           "Data sampling interval (in milliseconds)")                       \
3804           range(PeriodicTask::min_interval, max_jint)                       \
3805           constraint(PerfDataSamplingIntervalFunc, AfterErgo)               \
3806                                                                             \
3807   develop(bool, PerfTraceDataCreation, false,                               \
3808           "Trace creation of Performance Data Entries")                     \
3809                                                                             \
3810   develop(bool, PerfTraceMemOps, false,                                     \
3811           "Trace PerfMemory create/attach/detach calls")                    \
3812                                                                             \
3813   product(bool, PerfDisableSharedMem, false,                                \
3814           "Store performance data in standard memory")                      \
3815                                                                             \
3816   product(intx, PerfDataMemorySize, 32*K,                                   \
3817           "Size of performance data memory region. Will be rounded "        \
3818           "up to a multiple of the native os page size.")                   \
3819           range(128, 32*64*K)                                               \
3820                                                                             \
3821   product(intx, PerfMaxStringConstLength, 1024,                             \
3822           "Maximum PerfStringConstant string length before truncation")     \
3823           range(32, 32*K)                                                   \
3824                                                                             \
3825   product(bool, PerfAllowAtExitRegistration, false,                         \
3826           "Allow registration of atexit() methods")                         \
3827                                                                             \
3828   product(bool, PerfBypassFileSystemCheck, false,                           \
3829           "Bypass Win32 file system criteria checks (Windows Only)")        \
3830                                                                             \
3831   product(intx, UnguardOnExecutionViolation, 0,                             \
3832           "Unguard page and retry on no-execute fault (Win32 only) "        \
3833           "0=off, 1=conservative, 2=aggressive")                            \
3834           range(0, 2)                                                       \
3835                                                                             \
3836   /* Serviceability Support */                                              \
3837                                                                             \
3838   product(bool, ManagementServer, false,                                    \
3839           "Create JMX Management Server")                                   \
3840                                                                             \
3841   product(bool, DisableAttachMechanism, false,                              \
3842           "Disable mechanism that allows tools to attach to this VM")       \
3843                                                                             \
3844   product(bool, StartAttachListener, false,                                 \
3845           "Always start Attach Listener at VM startup")                     \
3846                                                                             \
3847   manageable(bool, PrintConcurrentLocks, false,                             \
3848           "Print java.util.concurrent locks in thread dump")                \
3849                                                                             \
3850   product(bool, TransmitErrorReport, false,                                 \
3851           "Enable error report transmission on erroneous termination")      \
3852                                                                             \
3853   product(ccstr, ErrorReportServer, NULL,                                   \
3854           "Override built-in error report server address")                  \
3855                                                                             \
3856   /* Shared spaces */                                                       \
3857                                                                             \
3858   product(bool, UseSharedSpaces, true,                                      \
3859           "Use shared spaces for metadata")                                 \
3860                                                                             \
3861   product(bool, VerifySharedSpaces, false,                                  \
3862           "Verify shared spaces (false for default archive, true for "      \
3863           "archive specified by -XX:SharedArchiveFile)")                    \
3864                                                                             \
3865   product(bool, RequireSharedSpaces, false,                                 \
3866           "Require shared spaces for metadata")                             \
3867                                                                             \
3868   product(bool, DumpSharedSpaces, false,                                    \
3869           "Special mode: JVM reads a class list, loads classes, builds "    \
3870           "shared spaces, and dumps the shared spaces to a file to be "     \
3871           "used in future JVM runs")                                        \
3872                                                                             \
3873   product(bool, PrintSharedSpaces, false,                                   \
3874           "Print usage of shared spaces")                                   \
3875                                                                             \
3876   product(bool, PrintSharedArchiveAndExit, false,                           \
3877           "Print shared archive file contents")                             \
3878                                                                             \
3879   product(bool, PrintSharedDictionary, false,                               \
3880           "If PrintSharedArchiveAndExit is true, also print the shared "    \
3881           "dictionary")                                                     \
3882                                                                             \
3883   product(size_t, SharedReadWriteSize, DEFAULT_SHARED_READ_WRITE_SIZE,      \
3884           "Size of read-write space for metadata (in bytes)")               \
3885           range(MIN_SHARED_READ_WRITE_SIZE, MAX_SHARED_READ_WRITE_SIZE)     \
3886           constraint(SharedReadWriteSizeConstraintFunc,AfterErgo)           \
3887                                                                             \
3888   product(size_t, SharedReadOnlySize, DEFAULT_SHARED_READ_ONLY_SIZE,        \
3889           "Size of read-only space for metadata (in bytes)")                \
3890           range(MIN_SHARED_READ_ONLY_SIZE, MAX_SHARED_READ_ONLY_SIZE)       \
3891           constraint(SharedReadOnlySizeConstraintFunc,AfterErgo)            \
3892                                                                             \
3893   product(size_t, SharedMiscDataSize, DEFAULT_SHARED_MISC_DATA_SIZE,        \
3894           "Size of the shared miscellaneous data area (in bytes)")          \
3895           range(MIN_SHARED_MISC_DATA_SIZE, MAX_SHARED_MISC_DATA_SIZE)       \
3896           constraint(SharedMiscDataSizeConstraintFunc,AfterErgo)            \
3897                                                                             \
3898   product(size_t, SharedMiscCodeSize, DEFAULT_SHARED_MISC_CODE_SIZE,        \
3899           "Size of the shared miscellaneous code area (in bytes)")          \
3900           range(MIN_SHARED_MISC_CODE_SIZE, MAX_SHARED_MISC_CODE_SIZE)       \
3901           constraint(SharedMiscCodeSizeConstraintFunc,AfterErgo)            \
3902                                                                             \
3903   product(size_t, SharedBaseAddress, LP64_ONLY(32*G)                        \
3904           NOT_LP64(LINUX_ONLY(2*G) NOT_LINUX(0)),                           \
3905           "Address to allocate shared memory region for class data")        \
3906           range(0, SIZE_MAX)                                                \
3907                                                                             \
3908   product(uintx, SharedSymbolTableBucketSize, 4,                            \
3909           "Average number of symbols per bucket in shared table")           \
3910           range(2, 246)                                                     \
3911                                                                             \
3912   diagnostic(bool, IgnoreUnverifiableClassesDuringDump, false,              \
3913           "Do not quit -Xshare:dump even if we encounter unverifiable "     \
3914           "classes. Just exclude them from the shared dictionary.")         \
3915                                                                             \
3916   diagnostic(bool, PrintMethodHandleStubs, false,                           \
3917           "Print generated stub code for method handles")                   \
3918                                                                             \
3919   develop(bool, TraceMethodHandles, false,                                  \
3920           "trace internal method handle operations")                        \
3921                                                                             \
3922   diagnostic(bool, VerifyMethodHandles, trueInDebug,                        \
3923           "perform extra checks when constructing method handles")          \
3924                                                                             \
3925   diagnostic(bool, ShowHiddenFrames, false,                                 \
3926           "show method handle implementation frames (usually hidden)")      \
3927                                                                             \
3928   experimental(bool, TrustFinalNonStaticFields, false,                      \
3929           "trust final non-static declarations for constant folding")       \
3930                                                                             \
3931   diagnostic(bool, FoldStableValues, true,                                  \
3932           "Optimize loads from stable fields (marked w/ @Stable)")          \
3933                                                                             \
3934   develop(bool, TraceInvokeDynamic, false,                                  \
3935           "trace internal invoke dynamic operations")                       \
3936                                                                             \
3937   diagnostic(bool, PauseAtStartup,      false,                              \
3938           "Causes the VM to pause at startup time and wait for the pause "  \
3939           "file to be removed (default: ./vm.paused.&lt;pid&gt;)")                \
3940                                                                             \
3941   diagnostic(ccstr, PauseAtStartupFile, NULL,                               \
3942           "The file to create and for whose removal to await when pausing " \
3943           "at startup. (default: ./vm.paused.&lt;pid&gt;)")                       \
3944                                                                             \
3945   diagnostic(bool, PauseAtExit, false,                                      \
3946           "Pause and wait for keypress on exit if a debugger is attached")  \
3947                                                                             \
3948   product(bool, ExtendedDTraceProbes,    false,                             \
3949           "Enable performance-impacting dtrace probes")                     \
3950                                                                             \
3951   product(bool, DTraceMethodProbes, false,                                  \
3952           "Enable dtrace probes for method-entry and method-exit")          \
3953                                                                             \
3954   product(bool, DTraceAllocProbes, false,                                   \
3955           "Enable dtrace probes for object allocation")                     \
3956                                                                             \
3957   product(bool, DTraceMonitorProbes, false,                                 \
3958           "Enable dtrace probes for monitor events")                        \
3959                                                                             \
3960   product(bool, RelaxAccessControlCheck, false,                             \
3961           "Relax the access control checks in the verifier")                \
3962                                                                             \
3963   product(uintx, StringTableSize, defaultStringTableSize,                   \
3964           "Number of buckets in the interned String table")                 \
3965           range(minimumStringTableSize, 111*defaultStringTableSize)         \
3966                                                                             \
3967   experimental(uintx, SymbolTableSize, defaultSymbolTableSize,              \
3968           "Number of buckets in the JVM internal Symbol table")             \
3969           range(minimumSymbolTableSize, 111*defaultSymbolTableSize)         \
3970                                                                             \
3971   product(bool, UseStringDeduplication, false,                              \
3972           "Use string deduplication")                                       \
3973                                                                             \
3974   product(uintx, StringDeduplicationAgeThreshold, 3,                        \
3975           "A string must reach this age (or be promoted to an old region) " \
3976           "to be considered for deduplication")                             \
3977           range(1, markOopDesc::max_age)                                    \
3978                                                                             \
3979   diagnostic(bool, StringDeduplicationResizeALot, false,                    \
3980           "Force table resize every time the table is scanned")             \
3981                                                                             \
3982   diagnostic(bool, StringDeduplicationRehashALot, false,                    \
3983           "Force table rehash every time the table is scanned")             \
3984                                                                             \
3985   diagnostic(bool, WhiteBoxAPI, false,                                      \
3986           "Enable internal testing APIs")                                   \
3987                                                                             \
3988   experimental(intx, SurvivorAlignmentInBytes, 0,                           \
3989            "Default survivor space alignment in bytes")                     \
3990            constraint(SurvivorAlignmentInBytesConstraintFunc,AfterErgo)     \
3991                                                                             \
3992   product(bool , AllowNonVirtualCalls, false,                               \
3993           "Obey the ACC_SUPER flag and allow invokenonvirtual calls")       \
3994                                                                             \
3995   product(ccstr, DumpLoadedClassList, NULL,                                 \
3996           "Dump the names all loaded classes, that could be stored into "   \
3997           "the CDS archive, in the specified file")                         \
3998                                                                             \
3999   product(ccstr, SharedClassListFile, NULL,                                 \
4000           "Override the default CDS class list")                            \
4001                                                                             \
4002   diagnostic(ccstr, SharedArchiveFile, NULL,                                \
4003           "Override the default location of the CDS archive file")          \
4004                                                                             \
4005   product(ccstr, ExtraSharedClassListFile, NULL,                            \
4006           "Extra classlist for building the CDS archive file")              \
4007                                                                             \
4008   experimental(size_t, ArrayAllocatorMallocLimit,                           \
4009           SOLARIS_ONLY(64*K) NOT_SOLARIS((size_t)-1),                       \
4010           "Allocation less than this value will be allocated "              \
4011           "using malloc. Larger allocations will use mmap.")                \
4012                                                                             \
4013   experimental(bool, AlwaysAtomicAccesses, false,                           \
4014           "Accesses to all variables should always be atomic")              \
4015                                                                             \
4016   product(bool, EnableTracing, false,                                       \
4017           "Enable event-based tracing")                                     \
4018                                                                             \
4019   product(bool, UseLockedTracing, false,                                    \
4020           "Use locked-tracing when doing event-based tracing")              \
4021                                                                             \
4022   diagnostic(bool, UseUnalignedAccesses, false,                             \
4023           "Use unaligned memory accesses in Unsafe")                        \
4024                                                                             \
4025   product_pd(bool, PreserveFramePointer,                                    \
4026              "Use the FP register for holding the frame pointer "           \
4027              "and not as a general purpose register.")                      \
4028                                                                             \
4029   diagnostic(bool, CheckIntrinsics, true,                                   \
4030              "When a class C is loaded, check that "                        \
4031              "(1) all intrinsics defined by the VM for class C are present "\
4032              "in the loaded class file and are marked with the "            \
4033              "@HotSpotIntrinsicCandidate annotation, that "                 \
4034              "(2) there is an intrinsic registered for all loaded methods " \
4035              "that are annotated with the @HotSpotIntrinsicCandidate "      \
4036              "annotation, and that "                                        \
4037              "(3) no orphan methods exist for class C (i.e., methods for "  \
4038              "which the VM declares an intrinsic but that are not declared "\
4039              "in the loaded class C. "                                      \
4040              "Check (3) is available only in debug builds.")                \
4041                                                                             \
4042   diagnostic_pd(intx, InitArrayShortSize,                                   \
4043           "Threshold small size (in bytes) for clearing arrays. "           \
4044           "Anything this size or smaller may get converted to discrete "    \
4045           "scalar stores.")                                                 \
4046           range(0, max_intx)                                                \
4047           constraint(InitArrayShortSizeConstraintFunc, AfterErgo)           \
4048                                                                             \
4049   diagnostic(bool, CompilerDirectivesIgnoreCompileCommands, false,          \
4050              "Disable backwards compatibility for compile commands.")       \
4051                                                                             \
4052   diagnostic(bool, CompilerDirectivesPrint, false,                          \
4053              "Print compiler directives on installation.")                  \
4054   diagnostic(int,  CompilerDirectivesLimit, 50,                             \
4055              "Limit on number of compiler directives.")
4056 
4057 
4058 /*
4059  *  Macros for factoring of globals
4060  */
4061 
4062 // Interface macros
4063 #define DECLARE_PRODUCT_FLAG(type, name, value, doc)      extern "C" type name;
4064 #define DECLARE_PD_PRODUCT_FLAG(type, name, doc)          extern "C" type name;
4065 #define DECLARE_DIAGNOSTIC_FLAG(type, name, value, doc)   extern "C" type name;
4066 #define DECLARE_PD_DIAGNOSTIC_FLAG(type, name, doc)       extern "C" type name;
4067 #define DECLARE_EXPERIMENTAL_FLAG(type, name, value, doc) extern "C" type name;
4068 #define DECLARE_MANAGEABLE_FLAG(type, name, value, doc)   extern "C" type name;
4069 #define DECLARE_PRODUCT_RW_FLAG(type, name, value, doc)   extern "C" type name;
4070 #ifdef PRODUCT
4071 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    const type name = value;
4072 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        const type name = pd_##name;
4073 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   const type name = value;
4074 #else
4075 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern "C" type name;
4076 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern "C" type name;
4077 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern "C" type name;
4078 #endif // PRODUCT
4079 // Special LP64 flags, product only needed for now.
4080 #ifdef _LP64
4081 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) extern "C" type name;
4082 #else
4083 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) const type name = value;
4084 #endif // _LP64
4085 
4086 // Implementation macros
4087 #define MATERIALIZE_PRODUCT_FLAG(type, name, value, doc)      type name = value;
4088 #define MATERIALIZE_PD_PRODUCT_FLAG(type, name, doc)          type name = pd_##name;
4089 #define MATERIALIZE_DIAGNOSTIC_FLAG(type, name, value, doc)   type name = value;
4090 #define MATERIALIZE_PD_DIAGNOSTIC_FLAG(type, name, doc)       type name = pd_##name;
4091 #define MATERIALIZE_EXPERIMENTAL_FLAG(type, name, value, doc) type name = value;
4092 #define MATERIALIZE_MANAGEABLE_FLAG(type, name, value, doc)   type name = value;
4093 #define MATERIALIZE_PRODUCT_RW_FLAG(type, name, value, doc)   type name = value;
4094 #ifdef PRODUCT
4095 #define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)
4096 #define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)
4097 #define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)
4098 #else
4099 #define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)    type name = value;
4100 #define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)        type name = pd_##name;
4101 #define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)   type name = value;
4102 #endif // PRODUCT
4103 #ifdef _LP64
4104 #define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) type name = value;
4105 #else
4106 #define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) /* flag is constant */
4107 #endif // _LP64
4108 
4109 // Only materialize src code for range checking when required, ignore otherwise
4110 #define IGNORE_RANGE(a, b)
4111 // Only materialize src code for contraint checking when required, ignore otherwise
4112 #define IGNORE_CONSTRAINT(func,type)
4113 
4114 #define IGNORE_WRITEABLE(type)
4115 
4116 RUNTIME_FLAGS(DECLARE_DEVELOPER_FLAG, \
4117               DECLARE_PD_DEVELOPER_FLAG, \
4118               DECLARE_PRODUCT_FLAG, \
4119               DECLARE_PD_PRODUCT_FLAG, \
4120               DECLARE_DIAGNOSTIC_FLAG, \
4121               DECLARE_PD_DIAGNOSTIC_FLAG, \
4122               DECLARE_EXPERIMENTAL_FLAG, \
4123               DECLARE_NOTPRODUCT_FLAG, \
4124               DECLARE_MANAGEABLE_FLAG, \
4125               DECLARE_PRODUCT_RW_FLAG, \
4126               DECLARE_LP64_PRODUCT_FLAG, \
4127               IGNORE_RANGE, \
4128               IGNORE_CONSTRAINT, \
4129               IGNORE_WRITEABLE)
4130 
4131 RUNTIME_OS_FLAGS(DECLARE_DEVELOPER_FLAG, \
4132                  DECLARE_PD_DEVELOPER_FLAG, \
4133                  DECLARE_PRODUCT_FLAG, \
4134                  DECLARE_PD_PRODUCT_FLAG, \
4135                  DECLARE_DIAGNOSTIC_FLAG, \
4136                  DECLARE_PD_DIAGNOSTIC_FLAG, \
4137                  DECLARE_NOTPRODUCT_FLAG, \
4138                  IGNORE_RANGE, \
4139                  IGNORE_CONSTRAINT, \
4140                  IGNORE_WRITEABLE)
4141 
4142 ARCH_FLAGS(DECLARE_DEVELOPER_FLAG, \
4143            DECLARE_PRODUCT_FLAG, \
4144            DECLARE_DIAGNOSTIC_FLAG, \
4145            DECLARE_EXPERIMENTAL_FLAG, \
4146            DECLARE_NOTPRODUCT_FLAG, \
4147            IGNORE_RANGE, \
4148            IGNORE_CONSTRAINT, \
4149            IGNORE_WRITEABLE)
4150 
4151 // Extensions
4152 
4153 #include "runtime/globals_ext.hpp"
4154 
4155 #endif // SHARE_VM_RUNTIME_GLOBALS_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
