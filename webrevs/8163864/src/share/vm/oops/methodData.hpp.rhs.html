<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_VM_OOPS_METHODDATAOOP_HPP
  26 #define SHARE_VM_OOPS_METHODDATAOOP_HPP
  27 
  28 #include "interpreter/bytecodes.hpp"
  29 #include "memory/universe.hpp"
  30 #include "oops/method.hpp"
  31 #include "oops/oop.hpp"
  32 #include "runtime/orderAccess.hpp"
<a name="1" id="anc1"></a><span class="new">  33 #if INCLUDE_JVMCI</span>
<span class="new">  34 #include "jvmci/jvmci_globals.hpp"</span>
<span class="new">  35 #endif</span>
  36 
  37 class BytecodeStream;
  38 class KlassSizeStats;
  39 
  40 // The MethodData object collects counts and other profile information
  41 // during zeroth-tier (interpretive) and first-tier execution.
  42 // The profile is used later by compilation heuristics.  Some heuristics
  43 // enable use of aggressive (or "heroic") optimizations.  An aggressive
  44 // optimization often has a down-side, a corner case that it handles
  45 // poorly, but which is thought to be rare.  The profile provides
  46 // evidence of this rarity for a given method or even BCI.  It allows
  47 // the compiler to back out of the optimization at places where it
  48 // has historically been a poor choice.  Other heuristics try to use
  49 // specific information gathered about types observed at a given site.
  50 //
  51 // All data in the profile is approximate.  It is expected to be accurate
  52 // on the whole, but the system expects occasional inaccuraces, due to
  53 // counter overflow, multiprocessor races during data collection, space
  54 // limitations, missing MDO blocks, etc.  Bad or missing data will degrade
  55 // optimization quality but will not affect correctness.  Also, each MDO
  56 // is marked with its birth-date ("creation_mileage") which can be used
  57 // to assess the quality ("maturity") of its data.
  58 //
  59 // Short (&lt;32-bit) counters are designed to overflow to a known "saturated"
  60 // state.  Also, certain recorded per-BCI events are given one-bit counters
  61 // which overflow to a saturated state which applied to all counters at
  62 // that BCI.  In other words, there is a small lattice which approximates
  63 // the ideal of an infinite-precision counter for each event at each BCI,
  64 // and the lattice quickly "bottoms out" in a state where all counters
  65 // are taken to be indefinitely large.
  66 //
  67 // The reader will find many data races in profile gathering code, starting
  68 // with invocation counter incrementation.  None of these races harm correct
  69 // execution of the compiled code.
  70 
  71 // forward decl
  72 class ProfileData;
  73 
  74 // DataLayout
  75 //
  76 // Overlay for generic profiling data.
  77 class DataLayout VALUE_OBJ_CLASS_SPEC {
  78   friend class VMStructs;
  79   friend class JVMCIVMStructs;
  80 
  81 private:
  82   // Every data layout begins with a header.  This header
  83   // contains a tag, which is used to indicate the size/layout
  84   // of the data, 4 bits of flags, which can be used in any way,
  85   // 4 bits of trap history (none/one reason/many reasons),
  86   // and a bci, which is used to tie this piece of data to a
  87   // specific bci in the bytecodes.
  88   union {
  89     intptr_t _bits;
  90     struct {
  91       u1 _tag;
  92       u1 _flags;
  93       u2 _bci;
  94     } _struct;
  95   } _header;
  96 
  97   // The data layout has an arbitrary number of cells, each sized
  98   // to accomodate a pointer or an integer.
  99   intptr_t _cells[1];
 100 
 101   // Some types of data layouts need a length field.
 102   static bool needs_array_len(u1 tag);
 103 
 104 public:
 105   enum {
 106     counter_increment = 1
 107   };
 108 
 109   enum {
 110     cell_size = sizeof(intptr_t)
 111   };
 112 
 113   // Tag values
 114   enum {
 115     no_tag,
 116     bit_data_tag,
 117     counter_data_tag,
 118     jump_data_tag,
 119     receiver_type_data_tag,
 120     virtual_call_data_tag,
 121     ret_data_tag,
 122     branch_data_tag,
 123     multi_branch_data_tag,
 124     arg_info_data_tag,
 125     call_type_data_tag,
 126     virtual_call_type_data_tag,
 127     parameters_type_data_tag,
 128     speculative_trap_data_tag
 129   };
 130 
 131   enum {
 132     // The _struct._flags word is formatted as [trap_state:4 | flags:4].
 133     // The trap state breaks down further as [recompile:1 | reason:3].
 134     // This further breakdown is defined in deoptimization.cpp.
 135     // See Deoptimization::trap_state_reason for an assert that
 136     // trap_bits is big enough to hold reasons &lt; Reason_RECORDED_LIMIT.
 137     //
 138     // The trap_state is collected only if ProfileTraps is true.
 139     trap_bits = 1+3,  // 3: enough to distinguish [0..Reason_RECORDED_LIMIT].
 140     trap_shift = BitsPerByte - trap_bits,
 141     trap_mask = right_n_bits(trap_bits),
 142     trap_mask_in_place = (trap_mask &lt;&lt; trap_shift),
 143     flag_limit = trap_shift,
 144     flag_mask = right_n_bits(flag_limit),
 145     first_flag = 0
 146   };
 147 
 148   // Size computation
 149   static int header_size_in_bytes() {
 150     return cell_size;
 151   }
 152   static int header_size_in_cells() {
 153     return 1;
 154   }
 155 
 156   static int compute_size_in_bytes(int cell_count) {
 157     return header_size_in_bytes() + cell_count * cell_size;
 158   }
 159 
 160   // Initialization
 161   void initialize(u1 tag, u2 bci, int cell_count);
 162 
 163   // Accessors
 164   u1 tag() {
 165     return _header._struct._tag;
 166   }
 167 
 168   // Return a few bits of trap state.  Range is [0..trap_mask].
 169   // The state tells if traps with zero, one, or many reasons have occurred.
 170   // It also tells whether zero or many recompilations have occurred.
 171   // The associated trap histogram in the MDO itself tells whether
 172   // traps are common or not.  If a BCI shows that a trap X has
 173   // occurred, and the MDO shows N occurrences of X, we make the
 174   // simplifying assumption that all N occurrences can be blamed
 175   // on that BCI.
 176   int trap_state() const {
 177     return ((_header._struct._flags &gt;&gt; trap_shift) &amp; trap_mask);
 178   }
 179 
 180   void set_trap_state(int new_state) {
 181     assert(ProfileTraps, "used only under +ProfileTraps");
 182     uint old_flags = (_header._struct._flags &amp; flag_mask);
 183     _header._struct._flags = (new_state &lt;&lt; trap_shift) | old_flags;
 184   }
 185 
 186   u1 flags() const {
 187     return _header._struct._flags;
 188   }
 189 
 190   u2 bci() const {
 191     return _header._struct._bci;
 192   }
 193 
 194   void set_header(intptr_t value) {
 195     _header._bits = value;
 196   }
 197   intptr_t header() {
 198     return _header._bits;
 199   }
 200   void set_cell_at(int index, intptr_t value) {
 201     _cells[index] = value;
 202   }
 203   void release_set_cell_at(int index, intptr_t value) {
 204     OrderAccess::release_store_ptr(&amp;_cells[index], value);
 205   }
 206   intptr_t cell_at(int index) const {
 207     return _cells[index];
 208   }
 209 
 210   void set_flag_at(int flag_number) {
 211     assert(flag_number &lt; flag_limit, "oob");
 212     _header._struct._flags |= (0x1 &lt;&lt; flag_number);
 213   }
 214   bool flag_at(int flag_number) const {
 215     assert(flag_number &lt; flag_limit, "oob");
 216     return (_header._struct._flags &amp; (0x1 &lt;&lt; flag_number)) != 0;
 217   }
 218 
 219   // Low-level support for code generation.
 220   static ByteSize header_offset() {
 221     return byte_offset_of(DataLayout, _header);
 222   }
 223   static ByteSize tag_offset() {
 224     return byte_offset_of(DataLayout, _header._struct._tag);
 225   }
 226   static ByteSize flags_offset() {
 227     return byte_offset_of(DataLayout, _header._struct._flags);
 228   }
 229   static ByteSize bci_offset() {
 230     return byte_offset_of(DataLayout, _header._struct._bci);
 231   }
 232   static ByteSize cell_offset(int index) {
 233     return byte_offset_of(DataLayout, _cells) + in_ByteSize(index * cell_size);
 234   }
 235 #ifdef CC_INTERP
 236   static int cell_offset_in_bytes(int index) {
 237     return (int)offset_of(DataLayout, _cells[index]);
 238   }
 239 #endif // CC_INTERP
 240   // Return a value which, when or-ed as a byte into _flags, sets the flag.
 241   static int flag_number_to_byte_constant(int flag_number) {
 242     assert(0 &lt;= flag_number &amp;&amp; flag_number &lt; flag_limit, "oob");
 243     DataLayout temp; temp.set_header(0);
 244     temp.set_flag_at(flag_number);
 245     return temp._header._struct._flags;
 246   }
 247   // Return a value which, when or-ed as a word into _header, sets the flag.
 248   static intptr_t flag_mask_to_header_mask(int byte_constant) {
 249     DataLayout temp; temp.set_header(0);
 250     temp._header._struct._flags = byte_constant;
 251     return temp._header._bits;
 252   }
 253 
 254   ProfileData* data_in();
 255 
 256   // GC support
 257   void clean_weak_klass_links(BoolObjectClosure* cl);
 258 
 259   // Redefinition support
 260   void clean_weak_method_links();
 261   DEBUG_ONLY(void verify_clean_weak_method_links();)
 262 };
 263 
 264 
 265 // ProfileData class hierarchy
 266 class ProfileData;
 267 class   BitData;
 268 class     CounterData;
 269 class       ReceiverTypeData;
 270 class         VirtualCallData;
 271 class           VirtualCallTypeData;
 272 class       RetData;
 273 class       CallTypeData;
 274 class   JumpData;
 275 class     BranchData;
 276 class   ArrayData;
 277 class     MultiBranchData;
 278 class     ArgInfoData;
 279 class     ParametersTypeData;
 280 class   SpeculativeTrapData;
 281 
 282 // ProfileData
 283 //
 284 // A ProfileData object is created to refer to a section of profiling
 285 // data in a structured way.
 286 class ProfileData : public ResourceObj {
 287   friend class TypeEntries;
 288   friend class ReturnTypeEntry;
 289   friend class TypeStackSlotEntries;
 290 private:
 291   enum {
 292     tab_width_one = 16,
 293     tab_width_two = 36
 294   };
 295 
 296   // This is a pointer to a section of profiling data.
 297   DataLayout* _data;
 298 
 299   char* print_data_on_helper(const MethodData* md) const;
 300 
 301 protected:
 302   DataLayout* data() { return _data; }
 303   const DataLayout* data() const { return _data; }
 304 
 305   enum {
 306     cell_size = DataLayout::cell_size
 307   };
 308 
 309 public:
 310   // How many cells are in this?
 311   virtual int cell_count() const {
 312     ShouldNotReachHere();
 313     return -1;
 314   }
 315 
 316   // Return the size of this data.
 317   int size_in_bytes() {
 318     return DataLayout::compute_size_in_bytes(cell_count());
 319   }
 320 
 321 protected:
 322   // Low-level accessors for underlying data
 323   void set_intptr_at(int index, intptr_t value) {
 324     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), "oob");
 325     data()-&gt;set_cell_at(index, value);
 326   }
 327   void release_set_intptr_at(int index, intptr_t value) {
 328     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), "oob");
 329     data()-&gt;release_set_cell_at(index, value);
 330   }
 331   intptr_t intptr_at(int index) const {
 332     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), "oob");
 333     return data()-&gt;cell_at(index);
 334   }
 335   void set_uint_at(int index, uint value) {
 336     set_intptr_at(index, (intptr_t) value);
 337   }
 338   void release_set_uint_at(int index, uint value) {
 339     release_set_intptr_at(index, (intptr_t) value);
 340   }
 341   uint uint_at(int index) const {
 342     return (uint)intptr_at(index);
 343   }
 344   void set_int_at(int index, int value) {
 345     set_intptr_at(index, (intptr_t) value);
 346   }
 347   void release_set_int_at(int index, int value) {
 348     release_set_intptr_at(index, (intptr_t) value);
 349   }
 350   int int_at(int index) const {
 351     return (int)intptr_at(index);
 352   }
 353   int int_at_unchecked(int index) const {
 354     return (int)data()-&gt;cell_at(index);
 355   }
 356   void set_oop_at(int index, oop value) {
 357     set_intptr_at(index, cast_from_oop&lt;intptr_t&gt;(value));
 358   }
 359   oop oop_at(int index) const {
 360     return cast_to_oop(intptr_at(index));
 361   }
 362 
 363   void set_flag_at(int flag_number) {
 364     data()-&gt;set_flag_at(flag_number);
 365   }
 366   bool flag_at(int flag_number) const {
 367     return data()-&gt;flag_at(flag_number);
 368   }
 369 
 370   // two convenient imports for use by subclasses:
 371   static ByteSize cell_offset(int index) {
 372     return DataLayout::cell_offset(index);
 373   }
 374   static int flag_number_to_byte_constant(int flag_number) {
 375     return DataLayout::flag_number_to_byte_constant(flag_number);
 376   }
 377 
 378   ProfileData(DataLayout* data) {
 379     _data = data;
 380   }
 381 
 382 #ifdef CC_INTERP
 383   // Static low level accessors for DataLayout with ProfileData's semantics.
 384 
 385   static int cell_offset_in_bytes(int index) {
 386     return DataLayout::cell_offset_in_bytes(index);
 387   }
 388 
 389   static void increment_uint_at_no_overflow(DataLayout* layout, int index,
 390                                             int inc = DataLayout::counter_increment) {
 391     uint count = ((uint)layout-&gt;cell_at(index)) + inc;
 392     if (count == 0) return;
 393     layout-&gt;set_cell_at(index, (intptr_t) count);
 394   }
 395 
 396   static int int_at(DataLayout* layout, int index) {
 397     return (int)layout-&gt;cell_at(index);
 398   }
 399 
 400   static int uint_at(DataLayout* layout, int index) {
 401     return (uint)layout-&gt;cell_at(index);
 402   }
 403 
 404   static oop oop_at(DataLayout* layout, int index) {
 405     return cast_to_oop(layout-&gt;cell_at(index));
 406   }
 407 
 408   static void set_intptr_at(DataLayout* layout, int index, intptr_t value) {
 409     layout-&gt;set_cell_at(index, (intptr_t) value);
 410   }
 411 
 412   static void set_flag_at(DataLayout* layout, int flag_number) {
 413     layout-&gt;set_flag_at(flag_number);
 414   }
 415 #endif // CC_INTERP
 416 
 417 public:
 418   // Constructor for invalid ProfileData.
 419   ProfileData();
 420 
 421   u2 bci() const {
 422     return data()-&gt;bci();
 423   }
 424 
 425   address dp() {
 426     return (address)_data;
 427   }
 428 
 429   int trap_state() const {
 430     return data()-&gt;trap_state();
 431   }
 432   void set_trap_state(int new_state) {
 433     data()-&gt;set_trap_state(new_state);
 434   }
 435 
 436   // Type checking
 437   virtual bool is_BitData()         const { return false; }
 438   virtual bool is_CounterData()     const { return false; }
 439   virtual bool is_JumpData()        const { return false; }
 440   virtual bool is_ReceiverTypeData()const { return false; }
 441   virtual bool is_VirtualCallData() const { return false; }
 442   virtual bool is_RetData()         const { return false; }
 443   virtual bool is_BranchData()      const { return false; }
 444   virtual bool is_ArrayData()       const { return false; }
 445   virtual bool is_MultiBranchData() const { return false; }
 446   virtual bool is_ArgInfoData()     const { return false; }
 447   virtual bool is_CallTypeData()    const { return false; }
 448   virtual bool is_VirtualCallTypeData()const { return false; }
 449   virtual bool is_ParametersTypeData() const { return false; }
 450   virtual bool is_SpeculativeTrapData()const { return false; }
 451 
 452 
 453   BitData* as_BitData() const {
 454     assert(is_BitData(), "wrong type");
 455     return is_BitData()         ? (BitData*)        this : NULL;
 456   }
 457   CounterData* as_CounterData() const {
 458     assert(is_CounterData(), "wrong type");
 459     return is_CounterData()     ? (CounterData*)    this : NULL;
 460   }
 461   JumpData* as_JumpData() const {
 462     assert(is_JumpData(), "wrong type");
 463     return is_JumpData()        ? (JumpData*)       this : NULL;
 464   }
 465   ReceiverTypeData* as_ReceiverTypeData() const {
 466     assert(is_ReceiverTypeData(), "wrong type");
 467     return is_ReceiverTypeData() ? (ReceiverTypeData*)this : NULL;
 468   }
 469   VirtualCallData* as_VirtualCallData() const {
 470     assert(is_VirtualCallData(), "wrong type");
 471     return is_VirtualCallData() ? (VirtualCallData*)this : NULL;
 472   }
 473   RetData* as_RetData() const {
 474     assert(is_RetData(), "wrong type");
 475     return is_RetData()         ? (RetData*)        this : NULL;
 476   }
 477   BranchData* as_BranchData() const {
 478     assert(is_BranchData(), "wrong type");
 479     return is_BranchData()      ? (BranchData*)     this : NULL;
 480   }
 481   ArrayData* as_ArrayData() const {
 482     assert(is_ArrayData(), "wrong type");
 483     return is_ArrayData()       ? (ArrayData*)      this : NULL;
 484   }
 485   MultiBranchData* as_MultiBranchData() const {
 486     assert(is_MultiBranchData(), "wrong type");
 487     return is_MultiBranchData() ? (MultiBranchData*)this : NULL;
 488   }
 489   ArgInfoData* as_ArgInfoData() const {
 490     assert(is_ArgInfoData(), "wrong type");
 491     return is_ArgInfoData() ? (ArgInfoData*)this : NULL;
 492   }
 493   CallTypeData* as_CallTypeData() const {
 494     assert(is_CallTypeData(), "wrong type");
 495     return is_CallTypeData() ? (CallTypeData*)this : NULL;
 496   }
 497   VirtualCallTypeData* as_VirtualCallTypeData() const {
 498     assert(is_VirtualCallTypeData(), "wrong type");
 499     return is_VirtualCallTypeData() ? (VirtualCallTypeData*)this : NULL;
 500   }
 501   ParametersTypeData* as_ParametersTypeData() const {
 502     assert(is_ParametersTypeData(), "wrong type");
 503     return is_ParametersTypeData() ? (ParametersTypeData*)this : NULL;
 504   }
 505   SpeculativeTrapData* as_SpeculativeTrapData() const {
 506     assert(is_SpeculativeTrapData(), "wrong type");
 507     return is_SpeculativeTrapData() ? (SpeculativeTrapData*)this : NULL;
 508   }
 509 
 510 
 511   // Subclass specific initialization
 512   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo) {}
 513 
 514   // GC support
 515   virtual void clean_weak_klass_links(BoolObjectClosure* is_alive_closure) {}
 516 
 517   // Redefinition support
 518   virtual void clean_weak_method_links() {}
 519   DEBUG_ONLY(virtual void verify_clean_weak_method_links() {})
 520 
 521   // CI translation: ProfileData can represent both MethodDataOop data
 522   // as well as CIMethodData data. This function is provided for translating
 523   // an oop in a ProfileData to the ci equivalent. Generally speaking,
 524   // most ProfileData don't require any translation, so we provide the null
 525   // translation here, and the required translators are in the ci subclasses.
 526   virtual void translate_from(const ProfileData* data) {}
 527 
 528   virtual void print_data_on(outputStream* st, const char* extra = NULL) const {
 529     ShouldNotReachHere();
 530   }
 531 
 532   void print_data_on(outputStream* st, const MethodData* md) const;
 533 
 534   void print_shared(outputStream* st, const char* name, const char* extra) const;
 535   void tab(outputStream* st, bool first = false) const;
 536 };
 537 
 538 // BitData
 539 //
 540 // A BitData holds a flag or two in its header.
 541 class BitData : public ProfileData {
 542   friend class VMStructs;
 543   friend class JVMCIVMStructs;
 544 protected:
 545   enum {
 546     // null_seen:
 547     //  saw a null operand (cast/aastore/instanceof)
 548       null_seen_flag              = DataLayout::first_flag + 0
 549 #if INCLUDE_JVMCI
 550     // bytecode threw any exception
 551     , exception_seen_flag         = null_seen_flag + 1
 552 #endif
 553   };
 554   enum { bit_cell_count = 0 };  // no additional data fields needed.
 555 public:
 556   BitData(DataLayout* layout) : ProfileData(layout) {
 557   }
 558 
 559   virtual bool is_BitData() const { return true; }
 560 
 561   static int static_cell_count() {
 562     return bit_cell_count;
 563   }
 564 
 565   virtual int cell_count() const {
 566     return static_cell_count();
 567   }
 568 
 569   // Accessor
 570 
 571   // The null_seen flag bit is specially known to the interpreter.
 572   // Consulting it allows the compiler to avoid setting up null_check traps.
 573   bool null_seen()     { return flag_at(null_seen_flag); }
 574   void set_null_seen()    { set_flag_at(null_seen_flag); }
 575 
 576 #if INCLUDE_JVMCI
 577   // true if an exception was thrown at the specific BCI
 578   bool exception_seen() { return flag_at(exception_seen_flag); }
 579   void set_exception_seen() { set_flag_at(exception_seen_flag); }
 580 #endif
 581 
 582   // Code generation support
 583   static int null_seen_byte_constant() {
 584     return flag_number_to_byte_constant(null_seen_flag);
 585   }
 586 
 587   static ByteSize bit_data_size() {
 588     return cell_offset(bit_cell_count);
 589   }
 590 
 591 #ifdef CC_INTERP
 592   static int bit_data_size_in_bytes() {
 593     return cell_offset_in_bytes(bit_cell_count);
 594   }
 595 
 596   static void set_null_seen(DataLayout* layout) {
 597     set_flag_at(layout, null_seen_flag);
 598   }
 599 
 600   static DataLayout* advance(DataLayout* layout) {
 601     return (DataLayout*) (((address)layout) + (ssize_t)BitData::bit_data_size_in_bytes());
 602   }
 603 #endif // CC_INTERP
 604 
 605   void print_data_on(outputStream* st, const char* extra = NULL) const;
 606 };
 607 
 608 // CounterData
 609 //
 610 // A CounterData corresponds to a simple counter.
 611 class CounterData : public BitData {
 612   friend class VMStructs;
 613   friend class JVMCIVMStructs;
 614 protected:
 615   enum {
 616     count_off,
 617     counter_cell_count
 618   };
 619 public:
 620   CounterData(DataLayout* layout) : BitData(layout) {}
 621 
 622   virtual bool is_CounterData() const { return true; }
 623 
 624   static int static_cell_count() {
 625     return counter_cell_count;
 626   }
 627 
 628   virtual int cell_count() const {
 629     return static_cell_count();
 630   }
 631 
 632   // Direct accessor
 633   uint count() const {
 634     return uint_at(count_off);
 635   }
 636 
 637   // Code generation support
 638   static ByteSize count_offset() {
 639     return cell_offset(count_off);
 640   }
 641   static ByteSize counter_data_size() {
 642     return cell_offset(counter_cell_count);
 643   }
 644 
 645   void set_count(uint count) {
 646     set_uint_at(count_off, count);
 647   }
 648 
 649 #ifdef CC_INTERP
 650   static int counter_data_size_in_bytes() {
 651     return cell_offset_in_bytes(counter_cell_count);
 652   }
 653 
 654   static void increment_count_no_overflow(DataLayout* layout) {
 655     increment_uint_at_no_overflow(layout, count_off);
 656   }
 657 
 658   // Support counter decrementation at checkcast / subtype check failed.
 659   static void decrement_count(DataLayout* layout) {
 660     increment_uint_at_no_overflow(layout, count_off, -1);
 661   }
 662 
 663   static DataLayout* advance(DataLayout* layout) {
 664     return (DataLayout*) (((address)layout) + (ssize_t)CounterData::counter_data_size_in_bytes());
 665   }
 666 #endif // CC_INTERP
 667 
 668   void print_data_on(outputStream* st, const char* extra = NULL) const;
 669 };
 670 
 671 // JumpData
 672 //
 673 // A JumpData is used to access profiling information for a direct
 674 // branch.  It is a counter, used for counting the number of branches,
 675 // plus a data displacement, used for realigning the data pointer to
 676 // the corresponding target bci.
 677 class JumpData : public ProfileData {
 678   friend class VMStructs;
 679   friend class JVMCIVMStructs;
 680 protected:
 681   enum {
 682     taken_off_set,
 683     displacement_off_set,
 684     jump_cell_count
 685   };
 686 
 687   void set_displacement(int displacement) {
 688     set_int_at(displacement_off_set, displacement);
 689   }
 690 
 691 public:
 692   JumpData(DataLayout* layout) : ProfileData(layout) {
 693     assert(layout-&gt;tag() == DataLayout::jump_data_tag ||
 694       layout-&gt;tag() == DataLayout::branch_data_tag, "wrong type");
 695   }
 696 
 697   virtual bool is_JumpData() const { return true; }
 698 
 699   static int static_cell_count() {
 700     return jump_cell_count;
 701   }
 702 
 703   virtual int cell_count() const {
 704     return static_cell_count();
 705   }
 706 
 707   // Direct accessor
 708   uint taken() const {
 709     return uint_at(taken_off_set);
 710   }
 711 
 712   void set_taken(uint cnt) {
 713     set_uint_at(taken_off_set, cnt);
 714   }
 715 
 716   // Saturating counter
 717   uint inc_taken() {
 718     uint cnt = taken() + 1;
 719     // Did we wrap? Will compiler screw us??
 720     if (cnt == 0) cnt--;
 721     set_uint_at(taken_off_set, cnt);
 722     return cnt;
 723   }
 724 
 725   int displacement() const {
 726     return int_at(displacement_off_set);
 727   }
 728 
 729   // Code generation support
 730   static ByteSize taken_offset() {
 731     return cell_offset(taken_off_set);
 732   }
 733 
 734   static ByteSize displacement_offset() {
 735     return cell_offset(displacement_off_set);
 736   }
 737 
 738 #ifdef CC_INTERP
 739   static void increment_taken_count_no_overflow(DataLayout* layout) {
 740     increment_uint_at_no_overflow(layout, taken_off_set);
 741   }
 742 
 743   static DataLayout* advance_taken(DataLayout* layout) {
 744     return (DataLayout*) (((address)layout) + (ssize_t)int_at(layout, displacement_off_set));
 745   }
 746 
 747   static uint taken_count(DataLayout* layout) {
 748     return (uint) uint_at(layout, taken_off_set);
 749   }
 750 #endif // CC_INTERP
 751 
 752   // Specific initialization.
 753   void post_initialize(BytecodeStream* stream, MethodData* mdo);
 754 
 755   void print_data_on(outputStream* st, const char* extra = NULL) const;
 756 };
 757 
 758 // Entries in a ProfileData object to record types: it can either be
 759 // none (no profile), unknown (conflicting profile data) or a klass if
 760 // a single one is seen. Whether a null reference was seen is also
 761 // recorded. No counter is associated with the type and a single type
 762 // is tracked (unlike VirtualCallData).
 763 class TypeEntries {
 764 
 765 public:
 766 
 767   // A single cell is used to record information for a type:
 768   // - the cell is initialized to 0
 769   // - when a type is discovered it is stored in the cell
 770   // - bit zero of the cell is used to record whether a null reference
 771   // was encountered or not
 772   // - bit 1 is set to record a conflict in the type information
 773 
 774   enum {
 775     null_seen = 1,
 776     type_mask = ~null_seen,
 777     type_unknown = 2,
 778     status_bits = null_seen | type_unknown,
 779     type_klass_mask = ~status_bits
 780   };
 781 
 782   // what to initialize a cell to
 783   static intptr_t type_none() {
 784     return 0;
 785   }
 786 
 787   // null seen = bit 0 set?
 788   static bool was_null_seen(intptr_t v) {
 789     return (v &amp; null_seen) != 0;
 790   }
 791 
 792   // conflicting type information = bit 1 set?
 793   static bool is_type_unknown(intptr_t v) {
 794     return (v &amp; type_unknown) != 0;
 795   }
 796 
 797   // not type information yet = all bits cleared, ignoring bit 0?
 798   static bool is_type_none(intptr_t v) {
 799     return (v &amp; type_mask) == 0;
 800   }
 801 
 802   // recorded type: cell without bit 0 and 1
 803   static intptr_t klass_part(intptr_t v) {
 804     intptr_t r = v &amp; type_klass_mask;
 805     return r;
 806   }
 807 
 808   // type recorded
 809   static Klass* valid_klass(intptr_t k) {
 810     if (!is_type_none(k) &amp;&amp;
 811         !is_type_unknown(k)) {
 812       Klass* res = (Klass*)klass_part(k);
 813       assert(res != NULL, "invalid");
 814       return res;
 815     } else {
 816       return NULL;
 817     }
 818   }
 819 
 820   static intptr_t with_status(intptr_t k, intptr_t in) {
 821     return k | (in &amp; status_bits);
 822   }
 823 
 824   static intptr_t with_status(Klass* k, intptr_t in) {
 825     return with_status((intptr_t)k, in);
 826   }
 827 
 828   static void print_klass(outputStream* st, intptr_t k);
 829 
 830   // GC support
 831   static bool is_loader_alive(BoolObjectClosure* is_alive_cl, intptr_t p);
 832 
 833 protected:
 834   // ProfileData object these entries are part of
 835   ProfileData* _pd;
 836   // offset within the ProfileData object where the entries start
 837   const int _base_off;
 838 
 839   TypeEntries(int base_off)
 840     : _base_off(base_off), _pd(NULL) {}
 841 
 842   void set_intptr_at(int index, intptr_t value) {
 843     _pd-&gt;set_intptr_at(index, value);
 844   }
 845 
 846   intptr_t intptr_at(int index) const {
 847     return _pd-&gt;intptr_at(index);
 848   }
 849 
 850 public:
 851   void set_profile_data(ProfileData* pd) {
 852     _pd = pd;
 853   }
 854 };
 855 
 856 // Type entries used for arguments passed at a call and parameters on
 857 // method entry. 2 cells per entry: one for the type encoded as in
 858 // TypeEntries and one initialized with the stack slot where the
 859 // profiled object is to be found so that the interpreter can locate
 860 // it quickly.
 861 class TypeStackSlotEntries : public TypeEntries {
 862 
 863 private:
 864   enum {
 865     stack_slot_entry,
 866     type_entry,
 867     per_arg_cell_count
 868   };
 869 
 870   // offset of cell for stack slot for entry i within ProfileData object
 871   int stack_slot_offset(int i) const {
 872     return _base_off + stack_slot_local_offset(i);
 873   }
 874 
 875   const int _number_of_entries;
 876 
 877   // offset of cell for type for entry i within ProfileData object
 878   int type_offset_in_cells(int i) const {
 879     return _base_off + type_local_offset(i);
 880   }
 881 
 882 public:
 883 
 884   TypeStackSlotEntries(int base_off, int nb_entries)
 885     : TypeEntries(base_off), _number_of_entries(nb_entries) {}
 886 
 887   static int compute_cell_count(Symbol* signature, bool include_receiver, int max);
 888 
 889   void post_initialize(Symbol* signature, bool has_receiver, bool include_receiver);
 890 
 891   int number_of_entries() const { return _number_of_entries; }
 892 
 893   // offset of cell for stack slot for entry i within this block of cells for a TypeStackSlotEntries
 894   static int stack_slot_local_offset(int i) {
 895     return i * per_arg_cell_count + stack_slot_entry;
 896   }
 897 
 898   // offset of cell for type for entry i within this block of cells for a TypeStackSlotEntries
 899   static int type_local_offset(int i) {
 900     return i * per_arg_cell_count + type_entry;
 901   }
 902 
 903   // stack slot for entry i
 904   uint stack_slot(int i) const {
 905     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, "oob");
 906     return _pd-&gt;uint_at(stack_slot_offset(i));
 907   }
 908 
 909   // set stack slot for entry i
 910   void set_stack_slot(int i, uint num) {
 911     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, "oob");
 912     _pd-&gt;set_uint_at(stack_slot_offset(i), num);
 913   }
 914 
 915   // type for entry i
 916   intptr_t type(int i) const {
 917     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, "oob");
 918     return _pd-&gt;intptr_at(type_offset_in_cells(i));
 919   }
 920 
 921   // set type for entry i
 922   void set_type(int i, intptr_t k) {
 923     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, "oob");
 924     _pd-&gt;set_intptr_at(type_offset_in_cells(i), k);
 925   }
 926 
 927   static ByteSize per_arg_size() {
 928     return in_ByteSize(per_arg_cell_count * DataLayout::cell_size);
 929   }
 930 
 931   static int per_arg_count() {
 932     return per_arg_cell_count;
 933   }
 934 
 935   ByteSize type_offset(int i) const {
 936     return DataLayout::cell_offset(type_offset_in_cells(i));
 937   }
 938 
 939   // GC support
 940   void clean_weak_klass_links(BoolObjectClosure* is_alive_closure);
 941 
 942   void print_data_on(outputStream* st) const;
 943 };
 944 
 945 // Type entry used for return from a call. A single cell to record the
 946 // type.
 947 class ReturnTypeEntry : public TypeEntries {
 948 
 949 private:
 950   enum {
 951     cell_count = 1
 952   };
 953 
 954 public:
 955   ReturnTypeEntry(int base_off)
 956     : TypeEntries(base_off) {}
 957 
 958   void post_initialize() {
 959     set_type(type_none());
 960   }
 961 
 962   intptr_t type() const {
 963     return _pd-&gt;intptr_at(_base_off);
 964   }
 965 
 966   void set_type(intptr_t k) {
 967     _pd-&gt;set_intptr_at(_base_off, k);
 968   }
 969 
 970   static int static_cell_count() {
 971     return cell_count;
 972   }
 973 
 974   static ByteSize size() {
 975     return in_ByteSize(cell_count * DataLayout::cell_size);
 976   }
 977 
 978   ByteSize type_offset() {
 979     return DataLayout::cell_offset(_base_off);
 980   }
 981 
 982   // GC support
 983   void clean_weak_klass_links(BoolObjectClosure* is_alive_closure);
 984 
 985   void print_data_on(outputStream* st) const;
 986 };
 987 
 988 // Entries to collect type information at a call: contains arguments
 989 // (TypeStackSlotEntries), a return type (ReturnTypeEntry) and a
 990 // number of cells. Because the number of cells for the return type is
 991 // smaller than the number of cells for the type of an arguments, the
 992 // number of cells is used to tell how many arguments are profiled and
 993 // whether a return value is profiled. See has_arguments() and
 994 // has_return().
 995 class TypeEntriesAtCall {
 996 private:
 997   static int stack_slot_local_offset(int i) {
 998     return header_cell_count() + TypeStackSlotEntries::stack_slot_local_offset(i);
 999   }
1000 
1001   static int argument_type_local_offset(int i) {
1002     return header_cell_count() + TypeStackSlotEntries::type_local_offset(i);
1003   }
1004 
1005 public:
1006 
1007   static int header_cell_count() {
1008     return 1;
1009   }
1010 
1011   static int cell_count_local_offset() {
1012     return 0;
1013   }
1014 
1015   static int compute_cell_count(BytecodeStream* stream);
1016 
1017   static void initialize(DataLayout* dl, int base, int cell_count) {
1018     int off = base + cell_count_local_offset();
1019     dl-&gt;set_cell_at(off, cell_count - base - header_cell_count());
1020   }
1021 
1022   static bool arguments_profiling_enabled();
1023   static bool return_profiling_enabled();
1024 
1025   // Code generation support
1026   static ByteSize cell_count_offset() {
1027     return in_ByteSize(cell_count_local_offset() * DataLayout::cell_size);
1028   }
1029 
1030   static ByteSize args_data_offset() {
1031     return in_ByteSize(header_cell_count() * DataLayout::cell_size);
1032   }
1033 
1034   static ByteSize stack_slot_offset(int i) {
1035     return in_ByteSize(stack_slot_local_offset(i) * DataLayout::cell_size);
1036   }
1037 
1038   static ByteSize argument_type_offset(int i) {
1039     return in_ByteSize(argument_type_local_offset(i) * DataLayout::cell_size);
1040   }
1041 
1042   static ByteSize return_only_size() {
1043     return ReturnTypeEntry::size() + in_ByteSize(header_cell_count() * DataLayout::cell_size);
1044   }
1045 
1046 };
1047 
1048 // CallTypeData
1049 //
1050 // A CallTypeData is used to access profiling information about a non
1051 // virtual call for which we collect type information about arguments
1052 // and return value.
1053 class CallTypeData : public CounterData {
1054 private:
1055   // entries for arguments if any
1056   TypeStackSlotEntries _args;
1057   // entry for return type if any
1058   ReturnTypeEntry _ret;
1059 
1060   int cell_count_global_offset() const {
1061     return CounterData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
1062   }
1063 
1064   // number of cells not counting the header
1065   int cell_count_no_header() const {
1066     return uint_at(cell_count_global_offset());
1067   }
1068 
1069   void check_number_of_arguments(int total) {
1070     assert(number_of_arguments() == total, "should be set in DataLayout::initialize");
1071   }
1072 
1073 public:
1074   CallTypeData(DataLayout* layout) :
1075     CounterData(layout),
1076     _args(CounterData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
1077     _ret(cell_count() - ReturnTypeEntry::static_cell_count())
1078   {
1079     assert(layout-&gt;tag() == DataLayout::call_type_data_tag, "wrong type");
1080     // Some compilers (VC++) don't want this passed in member initialization list
1081     _args.set_profile_data(this);
1082     _ret.set_profile_data(this);
1083   }
1084 
1085   const TypeStackSlotEntries* args() const {
1086     assert(has_arguments(), "no profiling of arguments");
1087     return &amp;_args;
1088   }
1089 
1090   const ReturnTypeEntry* ret() const {
1091     assert(has_return(), "no profiling of return value");
1092     return &amp;_ret;
1093   }
1094 
1095   virtual bool is_CallTypeData() const { return true; }
1096 
1097   static int static_cell_count() {
1098     return -1;
1099   }
1100 
1101   static int compute_cell_count(BytecodeStream* stream) {
1102     return CounterData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
1103   }
1104 
1105   static void initialize(DataLayout* dl, int cell_count) {
1106     TypeEntriesAtCall::initialize(dl, CounterData::static_cell_count(), cell_count);
1107   }
1108 
1109   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1110 
1111   virtual int cell_count() const {
1112     return CounterData::static_cell_count() +
1113       TypeEntriesAtCall::header_cell_count() +
1114       int_at_unchecked(cell_count_global_offset());
1115   }
1116 
1117   int number_of_arguments() const {
1118     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1119   }
1120 
1121   void set_argument_type(int i, Klass* k) {
1122     assert(has_arguments(), "no arguments!");
1123     intptr_t current = _args.type(i);
1124     _args.set_type(i, TypeEntries::with_status(k, current));
1125   }
1126 
1127   void set_return_type(Klass* k) {
1128     assert(has_return(), "no return!");
1129     intptr_t current = _ret.type();
1130     _ret.set_type(TypeEntries::with_status(k, current));
1131   }
1132 
1133   // An entry for a return value takes less space than an entry for an
1134   // argument so if the number of cells exceeds the number of cells
1135   // needed for an argument, this object contains type information for
1136   // at least one argument.
1137   bool has_arguments() const {
1138     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1139     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), "no profiling of arguments");
1140     return res;
1141   }
1142 
1143   // An entry for a return value takes less space than an entry for an
1144   // argument, so if the remainder of the number of cells divided by
1145   // the number of cells for an argument is not null, a return value
1146   // is profiled in this object.
1147   bool has_return() const {
1148     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1149     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), "no profiling of return values");
1150     return res;
1151   }
1152 
1153   // Code generation support
1154   static ByteSize args_data_offset() {
1155     return cell_offset(CounterData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1156   }
1157 
1158   ByteSize argument_type_offset(int i) {
1159     return _args.type_offset(i);
1160   }
1161 
1162   ByteSize return_type_offset() {
1163     return _ret.type_offset();
1164   }
1165 
1166   // GC support
1167   virtual void clean_weak_klass_links(BoolObjectClosure* is_alive_closure) {
1168     if (has_arguments()) {
1169       _args.clean_weak_klass_links(is_alive_closure);
1170     }
1171     if (has_return()) {
1172       _ret.clean_weak_klass_links(is_alive_closure);
1173     }
1174   }
1175 
1176   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1177 };
1178 
1179 // ReceiverTypeData
1180 //
1181 // A ReceiverTypeData is used to access profiling information about a
1182 // dynamic type check.  It consists of a counter which counts the total times
1183 // that the check is reached, and a series of (Klass*, count) pairs
1184 // which are used to store a type profile for the receiver of the check.
1185 class ReceiverTypeData : public CounterData {
1186   friend class VMStructs;
1187   friend class JVMCIVMStructs;
1188 protected:
1189   enum {
1190 #if INCLUDE_JVMCI
1191     // Description of the different counters
1192     // ReceiverTypeData for instanceof/checkcast/aastore:
1193     //   C1/C2: count is incremented on type overflow and decremented for failed type checks
1194     //   JVMCI: count decremented for failed type checks and nonprofiled_count is incremented on type overflow
1195     //          TODO (chaeubl): in fact, JVMCI should also increment the count for failed type checks to mimic the C1/C2 behavior
1196     // VirtualCallData for invokevirtual/invokeinterface:
1197     //   C1/C2: count is incremented on type overflow
1198     //   JVMCI: count is incremented on type overflow, nonprofiled_count is incremented on method overflow
1199 
1200     // JVMCI is interested in knowing the percentage of type checks involving a type not explicitly in the profile
1201     nonprofiled_count_off_set = counter_cell_count,
1202     receiver0_offset,
1203 #else
1204     receiver0_offset = counter_cell_count,
1205 #endif
1206     count0_offset,
1207     receiver_type_row_cell_count = (count0_offset + 1) - receiver0_offset
1208   };
1209 
1210 public:
1211   ReceiverTypeData(DataLayout* layout) : CounterData(layout) {
1212     assert(layout-&gt;tag() == DataLayout::receiver_type_data_tag ||
1213            layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1214            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, "wrong type");
1215   }
1216 
1217   virtual bool is_ReceiverTypeData() const { return true; }
1218 
1219   static int static_cell_count() {
1220     return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count JVMCI_ONLY(+ 1);
1221   }
1222 
1223   virtual int cell_count() const {
1224     return static_cell_count();
1225   }
1226 
1227   // Direct accessors
1228   static uint row_limit() {
1229     return TypeProfileWidth;
1230   }
1231   static int receiver_cell_index(uint row) {
1232     return receiver0_offset + row * receiver_type_row_cell_count;
1233   }
1234   static int receiver_count_cell_index(uint row) {
1235     return count0_offset + row * receiver_type_row_cell_count;
1236   }
1237 
1238   Klass* receiver(uint row) const {
1239     assert(row &lt; row_limit(), "oob");
1240 
1241     Klass* recv = (Klass*)intptr_at(receiver_cell_index(row));
1242     assert(recv == NULL || recv-&gt;is_klass(), "wrong type");
1243     return recv;
1244   }
1245 
1246   void set_receiver(uint row, Klass* k) {
1247     assert((uint)row &lt; row_limit(), "oob");
1248     set_intptr_at(receiver_cell_index(row), (uintptr_t)k);
1249   }
1250 
1251   uint receiver_count(uint row) const {
1252     assert(row &lt; row_limit(), "oob");
1253     return uint_at(receiver_count_cell_index(row));
1254   }
1255 
1256   void set_receiver_count(uint row, uint count) {
1257     assert(row &lt; row_limit(), "oob");
1258     set_uint_at(receiver_count_cell_index(row), count);
1259   }
1260 
1261   void clear_row(uint row) {
1262     assert(row &lt; row_limit(), "oob");
1263     // Clear total count - indicator of polymorphic call site.
1264     // The site may look like as monomorphic after that but
1265     // it allow to have more accurate profiling information because
1266     // there was execution phase change since klasses were unloaded.
1267     // If the site is still polymorphic then MDO will be updated
1268     // to reflect it. But it could be the case that the site becomes
1269     // only bimorphic. Then keeping total count not 0 will be wrong.
1270     // Even if we use monomorphic (when it is not) for compilation
1271     // we will only have trap, deoptimization and recompile again
1272     // with updated MDO after executing method in Interpreter.
1273     // An additional receiver will be recorded in the cleaned row
1274     // during next call execution.
1275     //
1276     // Note: our profiling logic works with empty rows in any slot.
1277     // We do sorting a profiling info (ciCallProfile) for compilation.
1278     //
1279     set_count(0);
1280     set_receiver(row, NULL);
1281     set_receiver_count(row, 0);
1282 #if INCLUDE_JVMCI
1283     if (!this-&gt;is_VirtualCallData()) {
1284       // if this is a ReceiverTypeData for JVMCI, the nonprofiled_count
1285       // must also be reset (see "Description of the different counters" above)
1286       set_nonprofiled_count(0);
1287     }
1288 #endif
1289   }
1290 
1291   // Code generation support
1292   static ByteSize receiver_offset(uint row) {
1293     return cell_offset(receiver_cell_index(row));
1294   }
1295   static ByteSize receiver_count_offset(uint row) {
1296     return cell_offset(receiver_count_cell_index(row));
1297   }
1298 #if INCLUDE_JVMCI
1299   static ByteSize nonprofiled_receiver_count_offset() {
1300     return cell_offset(nonprofiled_count_off_set);
1301   }
1302   uint nonprofiled_count() const {
1303     return uint_at(nonprofiled_count_off_set);
1304   }
1305   void set_nonprofiled_count(uint count) {
1306     set_uint_at(nonprofiled_count_off_set, count);
1307   }
1308 #endif // INCLUDE_JVMCI
1309   static ByteSize receiver_type_data_size() {
1310     return cell_offset(static_cell_count());
1311   }
1312 
1313   // GC support
1314   virtual void clean_weak_klass_links(BoolObjectClosure* is_alive_closure);
1315 
1316 #ifdef CC_INTERP
1317   static int receiver_type_data_size_in_bytes() {
1318     return cell_offset_in_bytes(static_cell_count());
1319   }
1320 
1321   static Klass *receiver_unchecked(DataLayout* layout, uint row) {
1322     Klass* recv = (Klass*)layout-&gt;cell_at(receiver_cell_index(row));
1323     return recv;
1324   }
1325 
1326   static void increment_receiver_count_no_overflow(DataLayout* layout, Klass *rcvr) {
1327     const int num_rows = row_limit();
1328     // Receiver already exists?
1329     for (int row = 0; row &lt; num_rows; row++) {
1330       if (receiver_unchecked(layout, row) == rcvr) {
1331         increment_uint_at_no_overflow(layout, receiver_count_cell_index(row));
1332         return;
1333       }
1334     }
1335     // New receiver, find a free slot.
1336     for (int row = 0; row &lt; num_rows; row++) {
1337       if (receiver_unchecked(layout, row) == NULL) {
1338         set_intptr_at(layout, receiver_cell_index(row), (intptr_t)rcvr);
1339         increment_uint_at_no_overflow(layout, receiver_count_cell_index(row));
1340         return;
1341       }
1342     }
1343     // Receiver did not match any saved receiver and there is no empty row for it.
1344     // Increment total counter to indicate polymorphic case.
1345     increment_count_no_overflow(layout);
1346   }
1347 
1348   static DataLayout* advance(DataLayout* layout) {
1349     return (DataLayout*) (((address)layout) + (ssize_t)ReceiverTypeData::receiver_type_data_size_in_bytes());
1350   }
1351 #endif // CC_INTERP
1352 
1353   void print_receiver_data_on(outputStream* st) const;
1354   void print_data_on(outputStream* st, const char* extra = NULL) const;
1355 };
1356 
1357 // VirtualCallData
1358 //
1359 // A VirtualCallData is used to access profiling information about a
1360 // virtual call.  For now, it has nothing more than a ReceiverTypeData.
1361 class VirtualCallData : public ReceiverTypeData {
1362 public:
1363   VirtualCallData(DataLayout* layout) : ReceiverTypeData(layout) {
1364     assert(layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1365            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, "wrong type");
1366   }
1367 
1368   virtual bool is_VirtualCallData() const { return true; }
1369 
1370   static int static_cell_count() {
1371     // At this point we could add more profile state, e.g., for arguments.
1372     // But for now it's the same size as the base record type.
1373     return ReceiverTypeData::static_cell_count() JVMCI_ONLY(+ (uint) MethodProfileWidth * receiver_type_row_cell_count);
1374   }
1375 
1376   virtual int cell_count() const {
1377     return static_cell_count();
1378   }
1379 
1380   // Direct accessors
1381   static ByteSize virtual_call_data_size() {
1382     return cell_offset(static_cell_count());
1383   }
1384 
1385 #ifdef CC_INTERP
1386   static int virtual_call_data_size_in_bytes() {
1387     return cell_offset_in_bytes(static_cell_count());
1388   }
1389 
1390   static DataLayout* advance(DataLayout* layout) {
1391     return (DataLayout*) (((address)layout) + (ssize_t)VirtualCallData::virtual_call_data_size_in_bytes());
1392   }
1393 #endif // CC_INTERP
1394 
1395 #if INCLUDE_JVMCI
1396   static ByteSize method_offset(uint row) {
1397     return cell_offset(method_cell_index(row));
1398   }
1399   static ByteSize method_count_offset(uint row) {
1400     return cell_offset(method_count_cell_index(row));
1401   }
1402   static int method_cell_index(uint row) {
1403     return receiver0_offset + (row + TypeProfileWidth) * receiver_type_row_cell_count;
1404   }
1405   static int method_count_cell_index(uint row) {
1406     return count0_offset + (row + TypeProfileWidth) * receiver_type_row_cell_count;
1407   }
1408   static uint method_row_limit() {
1409     return MethodProfileWidth;
1410   }
1411 
1412   Method* method(uint row) const {
1413     assert(row &lt; method_row_limit(), "oob");
1414 
1415     Method* method = (Method*)intptr_at(method_cell_index(row));
1416     assert(method == NULL || method-&gt;is_method(), "must be");
1417     return method;
1418   }
1419 
1420   uint method_count(uint row) const {
1421     assert(row &lt; method_row_limit(), "oob");
1422     return uint_at(method_count_cell_index(row));
1423   }
1424 
1425   void set_method(uint row, Method* m) {
1426     assert((uint)row &lt; method_row_limit(), "oob");
1427     set_intptr_at(method_cell_index(row), (uintptr_t)m);
1428   }
1429 
1430   void set_method_count(uint row, uint count) {
1431     assert(row &lt; method_row_limit(), "oob");
1432     set_uint_at(method_count_cell_index(row), count);
1433   }
1434 
1435   void clear_method_row(uint row) {
1436     assert(row &lt; method_row_limit(), "oob");
1437     // Clear total count - indicator of polymorphic call site (see comment for clear_row() in ReceiverTypeData).
1438     set_nonprofiled_count(0);
1439     set_method(row, NULL);
1440     set_method_count(row, 0);
1441   }
1442 
1443   // GC support
1444   virtual void clean_weak_klass_links(BoolObjectClosure* is_alive_closure);
1445 
1446   // Redefinition support
1447   virtual void clean_weak_method_links();
1448 #endif // INCLUDE_JVMCI
1449 
1450   void print_method_data_on(outputStream* st) const NOT_JVMCI_RETURN;
1451   void print_data_on(outputStream* st, const char* extra = NULL) const;
1452 };
1453 
1454 // VirtualCallTypeData
1455 //
1456 // A VirtualCallTypeData is used to access profiling information about
1457 // a virtual call for which we collect type information about
1458 // arguments and return value.
1459 class VirtualCallTypeData : public VirtualCallData {
1460 private:
1461   // entries for arguments if any
1462   TypeStackSlotEntries _args;
1463   // entry for return type if any
1464   ReturnTypeEntry _ret;
1465 
1466   int cell_count_global_offset() const {
1467     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
1468   }
1469 
1470   // number of cells not counting the header
1471   int cell_count_no_header() const {
1472     return uint_at(cell_count_global_offset());
1473   }
1474 
1475   void check_number_of_arguments(int total) {
1476     assert(number_of_arguments() == total, "should be set in DataLayout::initialize");
1477   }
1478 
1479 public:
1480   VirtualCallTypeData(DataLayout* layout) :
1481     VirtualCallData(layout),
1482     _args(VirtualCallData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
1483     _ret(cell_count() - ReturnTypeEntry::static_cell_count())
1484   {
1485     assert(layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, "wrong type");
1486     // Some compilers (VC++) don't want this passed in member initialization list
1487     _args.set_profile_data(this);
1488     _ret.set_profile_data(this);
1489   }
1490 
1491   const TypeStackSlotEntries* args() const {
1492     assert(has_arguments(), "no profiling of arguments");
1493     return &amp;_args;
1494   }
1495 
1496   const ReturnTypeEntry* ret() const {
1497     assert(has_return(), "no profiling of return value");
1498     return &amp;_ret;
1499   }
1500 
1501   virtual bool is_VirtualCallTypeData() const { return true; }
1502 
1503   static int static_cell_count() {
1504     return -1;
1505   }
1506 
1507   static int compute_cell_count(BytecodeStream* stream) {
1508     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
1509   }
1510 
1511   static void initialize(DataLayout* dl, int cell_count) {
1512     TypeEntriesAtCall::initialize(dl, VirtualCallData::static_cell_count(), cell_count);
1513   }
1514 
1515   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1516 
1517   virtual int cell_count() const {
1518     return VirtualCallData::static_cell_count() +
1519       TypeEntriesAtCall::header_cell_count() +
1520       int_at_unchecked(cell_count_global_offset());
1521   }
1522 
1523   int number_of_arguments() const {
1524     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1525   }
1526 
1527   void set_argument_type(int i, Klass* k) {
1528     assert(has_arguments(), "no arguments!");
1529     intptr_t current = _args.type(i);
1530     _args.set_type(i, TypeEntries::with_status(k, current));
1531   }
1532 
1533   void set_return_type(Klass* k) {
1534     assert(has_return(), "no return!");
1535     intptr_t current = _ret.type();
1536     _ret.set_type(TypeEntries::with_status(k, current));
1537   }
1538 
1539   // An entry for a return value takes less space than an entry for an
1540   // argument, so if the remainder of the number of cells divided by
1541   // the number of cells for an argument is not null, a return value
1542   // is profiled in this object.
1543   bool has_return() const {
1544     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1545     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), "no profiling of return values");
1546     return res;
1547   }
1548 
1549   // An entry for a return value takes less space than an entry for an
1550   // argument so if the number of cells exceeds the number of cells
1551   // needed for an argument, this object contains type information for
1552   // at least one argument.
1553   bool has_arguments() const {
1554     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1555     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), "no profiling of arguments");
1556     return res;
1557   }
1558 
1559   // Code generation support
1560   static ByteSize args_data_offset() {
1561     return cell_offset(VirtualCallData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1562   }
1563 
1564   ByteSize argument_type_offset(int i) {
1565     return _args.type_offset(i);
1566   }
1567 
1568   ByteSize return_type_offset() {
1569     return _ret.type_offset();
1570   }
1571 
1572   // GC support
1573   virtual void clean_weak_klass_links(BoolObjectClosure* is_alive_closure) {
1574     ReceiverTypeData::clean_weak_klass_links(is_alive_closure);
1575     if (has_arguments()) {
1576       _args.clean_weak_klass_links(is_alive_closure);
1577     }
1578     if (has_return()) {
1579       _ret.clean_weak_klass_links(is_alive_closure);
1580     }
1581   }
1582 
1583   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1584 };
1585 
1586 // RetData
1587 //
1588 // A RetData is used to access profiling information for a ret bytecode.
1589 // It is composed of a count of the number of times that the ret has
1590 // been executed, followed by a series of triples of the form
1591 // (bci, count, di) which count the number of times that some bci was the
1592 // target of the ret and cache a corresponding data displacement.
1593 class RetData : public CounterData {
1594 protected:
1595   enum {
1596     bci0_offset = counter_cell_count,
1597     count0_offset,
1598     displacement0_offset,
1599     ret_row_cell_count = (displacement0_offset + 1) - bci0_offset
1600   };
1601 
1602   void set_bci(uint row, int bci) {
1603     assert((uint)row &lt; row_limit(), "oob");
1604     set_int_at(bci0_offset + row * ret_row_cell_count, bci);
1605   }
1606   void release_set_bci(uint row, int bci) {
1607     assert((uint)row &lt; row_limit(), "oob");
1608     // 'release' when setting the bci acts as a valid flag for other
1609     // threads wrt bci_count and bci_displacement.
1610     release_set_int_at(bci0_offset + row * ret_row_cell_count, bci);
1611   }
1612   void set_bci_count(uint row, uint count) {
1613     assert((uint)row &lt; row_limit(), "oob");
1614     set_uint_at(count0_offset + row * ret_row_cell_count, count);
1615   }
1616   void set_bci_displacement(uint row, int disp) {
1617     set_int_at(displacement0_offset + row * ret_row_cell_count, disp);
1618   }
1619 
1620 public:
1621   RetData(DataLayout* layout) : CounterData(layout) {
1622     assert(layout-&gt;tag() == DataLayout::ret_data_tag, "wrong type");
1623   }
1624 
1625   virtual bool is_RetData() const { return true; }
1626 
1627   enum {
1628     no_bci = -1 // value of bci when bci1/2 are not in use.
1629   };
1630 
1631   static int static_cell_count() {
1632     return counter_cell_count + (uint) BciProfileWidth * ret_row_cell_count;
1633   }
1634 
1635   virtual int cell_count() const {
1636     return static_cell_count();
1637   }
1638 
1639   static uint row_limit() {
1640     return BciProfileWidth;
1641   }
1642   static int bci_cell_index(uint row) {
1643     return bci0_offset + row * ret_row_cell_count;
1644   }
1645   static int bci_count_cell_index(uint row) {
1646     return count0_offset + row * ret_row_cell_count;
1647   }
1648   static int bci_displacement_cell_index(uint row) {
1649     return displacement0_offset + row * ret_row_cell_count;
1650   }
1651 
1652   // Direct accessors
1653   int bci(uint row) const {
1654     return int_at(bci_cell_index(row));
1655   }
1656   uint bci_count(uint row) const {
1657     return uint_at(bci_count_cell_index(row));
1658   }
1659   int bci_displacement(uint row) const {
1660     return int_at(bci_displacement_cell_index(row));
1661   }
1662 
1663   // Interpreter Runtime support
1664   address fixup_ret(int return_bci, MethodData* mdo);
1665 
1666   // Code generation support
1667   static ByteSize bci_offset(uint row) {
1668     return cell_offset(bci_cell_index(row));
1669   }
1670   static ByteSize bci_count_offset(uint row) {
1671     return cell_offset(bci_count_cell_index(row));
1672   }
1673   static ByteSize bci_displacement_offset(uint row) {
1674     return cell_offset(bci_displacement_cell_index(row));
1675   }
1676 
1677 #ifdef CC_INTERP
1678   static DataLayout* advance(MethodData *md, int bci);
1679 #endif // CC_INTERP
1680 
1681   // Specific initialization.
1682   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1683 
1684   void print_data_on(outputStream* st, const char* extra = NULL) const;
1685 };
1686 
1687 // BranchData
1688 //
1689 // A BranchData is used to access profiling data for a two-way branch.
1690 // It consists of taken and not_taken counts as well as a data displacement
1691 // for the taken case.
1692 class BranchData : public JumpData {
1693   friend class VMStructs;
1694   friend class JVMCIVMStructs;
1695 protected:
1696   enum {
1697     not_taken_off_set = jump_cell_count,
1698     branch_cell_count
1699   };
1700 
1701   void set_displacement(int displacement) {
1702     set_int_at(displacement_off_set, displacement);
1703   }
1704 
1705 public:
1706   BranchData(DataLayout* layout) : JumpData(layout) {
1707     assert(layout-&gt;tag() == DataLayout::branch_data_tag, "wrong type");
1708   }
1709 
1710   virtual bool is_BranchData() const { return true; }
1711 
1712   static int static_cell_count() {
1713     return branch_cell_count;
1714   }
1715 
1716   virtual int cell_count() const {
1717     return static_cell_count();
1718   }
1719 
1720   // Direct accessor
1721   uint not_taken() const {
1722     return uint_at(not_taken_off_set);
1723   }
1724 
1725   void set_not_taken(uint cnt) {
1726     set_uint_at(not_taken_off_set, cnt);
1727   }
1728 
1729   uint inc_not_taken() {
1730     uint cnt = not_taken() + 1;
1731     // Did we wrap? Will compiler screw us??
1732     if (cnt == 0) cnt--;
1733     set_uint_at(not_taken_off_set, cnt);
1734     return cnt;
1735   }
1736 
1737   // Code generation support
1738   static ByteSize not_taken_offset() {
1739     return cell_offset(not_taken_off_set);
1740   }
1741   static ByteSize branch_data_size() {
1742     return cell_offset(branch_cell_count);
1743   }
1744 
1745 #ifdef CC_INTERP
1746   static int branch_data_size_in_bytes() {
1747     return cell_offset_in_bytes(branch_cell_count);
1748   }
1749 
1750   static void increment_not_taken_count_no_overflow(DataLayout* layout) {
1751     increment_uint_at_no_overflow(layout, not_taken_off_set);
1752   }
1753 
1754   static DataLayout* advance_not_taken(DataLayout* layout) {
1755     return (DataLayout*) (((address)layout) + (ssize_t)BranchData::branch_data_size_in_bytes());
1756   }
1757 #endif // CC_INTERP
1758 
1759   // Specific initialization.
1760   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1761 
1762   void print_data_on(outputStream* st, const char* extra = NULL) const;
1763 };
1764 
1765 // ArrayData
1766 //
1767 // A ArrayData is a base class for accessing profiling data which does
1768 // not have a statically known size.  It consists of an array length
1769 // and an array start.
1770 class ArrayData : public ProfileData {
1771   friend class VMStructs;
1772   friend class JVMCIVMStructs;
1773 protected:
1774   friend class DataLayout;
1775 
1776   enum {
1777     array_len_off_set,
1778     array_start_off_set
1779   };
1780 
1781   uint array_uint_at(int index) const {
1782     int aindex = index + array_start_off_set;
1783     return uint_at(aindex);
1784   }
1785   int array_int_at(int index) const {
1786     int aindex = index + array_start_off_set;
1787     return int_at(aindex);
1788   }
1789   oop array_oop_at(int index) const {
1790     int aindex = index + array_start_off_set;
1791     return oop_at(aindex);
1792   }
1793   void array_set_int_at(int index, int value) {
1794     int aindex = index + array_start_off_set;
1795     set_int_at(aindex, value);
1796   }
1797 
1798 #ifdef CC_INTERP
1799   // Static low level accessors for DataLayout with ArrayData's semantics.
1800 
1801   static void increment_array_uint_at_no_overflow(DataLayout* layout, int index) {
1802     int aindex = index + array_start_off_set;
1803     increment_uint_at_no_overflow(layout, aindex);
1804   }
1805 
1806   static int array_int_at(DataLayout* layout, int index) {
1807     int aindex = index + array_start_off_set;
1808     return int_at(layout, aindex);
1809   }
1810 #endif // CC_INTERP
1811 
1812   // Code generation support for subclasses.
1813   static ByteSize array_element_offset(int index) {
1814     return cell_offset(array_start_off_set + index);
1815   }
1816 
1817 public:
1818   ArrayData(DataLayout* layout) : ProfileData(layout) {}
1819 
1820   virtual bool is_ArrayData() const { return true; }
1821 
1822   static int static_cell_count() {
1823     return -1;
1824   }
1825 
1826   int array_len() const {
1827     return int_at_unchecked(array_len_off_set);
1828   }
1829 
1830   virtual int cell_count() const {
1831     return array_len() + 1;
1832   }
1833 
1834   // Code generation support
1835   static ByteSize array_len_offset() {
1836     return cell_offset(array_len_off_set);
1837   }
1838   static ByteSize array_start_offset() {
1839     return cell_offset(array_start_off_set);
1840   }
1841 };
1842 
1843 // MultiBranchData
1844 //
1845 // A MultiBranchData is used to access profiling information for
1846 // a multi-way branch (*switch bytecodes).  It consists of a series
1847 // of (count, displacement) pairs, which count the number of times each
1848 // case was taken and specify the data displacment for each branch target.
1849 class MultiBranchData : public ArrayData {
1850   friend class VMStructs;
1851   friend class JVMCIVMStructs;
1852 protected:
1853   enum {
1854     default_count_off_set,
1855     default_disaplacement_off_set,
1856     case_array_start
1857   };
1858   enum {
1859     relative_count_off_set,
1860     relative_displacement_off_set,
1861     per_case_cell_count
1862   };
1863 
1864   void set_default_displacement(int displacement) {
1865     array_set_int_at(default_disaplacement_off_set, displacement);
1866   }
1867   void set_displacement_at(int index, int displacement) {
1868     array_set_int_at(case_array_start +
1869                      index * per_case_cell_count +
1870                      relative_displacement_off_set,
1871                      displacement);
1872   }
1873 
1874 public:
1875   MultiBranchData(DataLayout* layout) : ArrayData(layout) {
1876     assert(layout-&gt;tag() == DataLayout::multi_branch_data_tag, "wrong type");
1877   }
1878 
1879   virtual bool is_MultiBranchData() const { return true; }
1880 
1881   static int compute_cell_count(BytecodeStream* stream);
1882 
1883   int number_of_cases() const {
1884     int alen = array_len() - 2; // get rid of default case here.
1885     assert(alen % per_case_cell_count == 0, "must be even");
1886     return (alen / per_case_cell_count);
1887   }
1888 
1889   uint default_count() const {
1890     return array_uint_at(default_count_off_set);
1891   }
1892   int default_displacement() const {
1893     return array_int_at(default_disaplacement_off_set);
1894   }
1895 
1896   uint count_at(int index) const {
1897     return array_uint_at(case_array_start +
1898                          index * per_case_cell_count +
1899                          relative_count_off_set);
1900   }
1901   int displacement_at(int index) const {
1902     return array_int_at(case_array_start +
1903                         index * per_case_cell_count +
1904                         relative_displacement_off_set);
1905   }
1906 
1907   // Code generation support
1908   static ByteSize default_count_offset() {
1909     return array_element_offset(default_count_off_set);
1910   }
1911   static ByteSize default_displacement_offset() {
1912     return array_element_offset(default_disaplacement_off_set);
1913   }
1914   static ByteSize case_count_offset(int index) {
1915     return case_array_offset() +
1916            (per_case_size() * index) +
1917            relative_count_offset();
1918   }
1919   static ByteSize case_array_offset() {
1920     return array_element_offset(case_array_start);
1921   }
1922   static ByteSize per_case_size() {
1923     return in_ByteSize(per_case_cell_count) * cell_size;
1924   }
1925   static ByteSize relative_count_offset() {
1926     return in_ByteSize(relative_count_off_set) * cell_size;
1927   }
1928   static ByteSize relative_displacement_offset() {
1929     return in_ByteSize(relative_displacement_off_set) * cell_size;
1930   }
1931 
1932 #ifdef CC_INTERP
1933   static void increment_count_no_overflow(DataLayout* layout, int index) {
1934     if (index == -1) {
1935       increment_array_uint_at_no_overflow(layout, default_count_off_set);
1936     } else {
1937       increment_array_uint_at_no_overflow(layout, case_array_start +
1938                                                   index * per_case_cell_count +
1939                                                   relative_count_off_set);
1940     }
1941   }
1942 
1943   static DataLayout* advance(DataLayout* layout, int index) {
1944     if (index == -1) {
1945       return (DataLayout*) (((address)layout) + (ssize_t)array_int_at(layout, default_disaplacement_off_set));
1946     } else {
1947       return (DataLayout*) (((address)layout) + (ssize_t)array_int_at(layout, case_array_start +
1948                                                                               index * per_case_cell_count +
1949                                                                               relative_displacement_off_set));
1950     }
1951   }
1952 #endif // CC_INTERP
1953 
1954   // Specific initialization.
1955   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1956 
1957   void print_data_on(outputStream* st, const char* extra = NULL) const;
1958 };
1959 
1960 class ArgInfoData : public ArrayData {
1961 
1962 public:
1963   ArgInfoData(DataLayout* layout) : ArrayData(layout) {
1964     assert(layout-&gt;tag() == DataLayout::arg_info_data_tag, "wrong type");
1965   }
1966 
1967   virtual bool is_ArgInfoData() const { return true; }
1968 
1969 
1970   int number_of_args() const {
1971     return array_len();
1972   }
1973 
1974   uint arg_modified(int arg) const {
1975     return array_uint_at(arg);
1976   }
1977 
1978   void set_arg_modified(int arg, uint val) {
1979     array_set_int_at(arg, val);
1980   }
1981 
1982   void print_data_on(outputStream* st, const char* extra = NULL) const;
1983 };
1984 
1985 // ParametersTypeData
1986 //
1987 // A ParametersTypeData is used to access profiling information about
1988 // types of parameters to a method
1989 class ParametersTypeData : public ArrayData {
1990 
1991 private:
1992   TypeStackSlotEntries _parameters;
1993 
1994   static int stack_slot_local_offset(int i) {
1995     assert_profiling_enabled();
1996     return array_start_off_set + TypeStackSlotEntries::stack_slot_local_offset(i);
1997   }
1998 
1999   static int type_local_offset(int i) {
2000     assert_profiling_enabled();
2001     return array_start_off_set + TypeStackSlotEntries::type_local_offset(i);
2002   }
2003 
2004   static bool profiling_enabled();
2005   static void assert_profiling_enabled() {
2006     assert(profiling_enabled(), "method parameters profiling should be on");
2007   }
2008 
2009 public:
2010   ParametersTypeData(DataLayout* layout) : ArrayData(layout), _parameters(1, number_of_parameters()) {
2011     assert(layout-&gt;tag() == DataLayout::parameters_type_data_tag, "wrong type");
2012     // Some compilers (VC++) don't want this passed in member initialization list
2013     _parameters.set_profile_data(this);
2014   }
2015 
2016   static int compute_cell_count(Method* m);
2017 
2018   virtual bool is_ParametersTypeData() const { return true; }
2019 
2020   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
2021 
2022   int number_of_parameters() const {
2023     return array_len() / TypeStackSlotEntries::per_arg_count();
2024   }
2025 
2026   const TypeStackSlotEntries* parameters() const { return &amp;_parameters; }
2027 
2028   uint stack_slot(int i) const {
2029     return _parameters.stack_slot(i);
2030   }
2031 
2032   void set_type(int i, Klass* k) {
2033     intptr_t current = _parameters.type(i);
2034     _parameters.set_type(i, TypeEntries::with_status((intptr_t)k, current));
2035   }
2036 
2037   virtual void clean_weak_klass_links(BoolObjectClosure* is_alive_closure) {
2038     _parameters.clean_weak_klass_links(is_alive_closure);
2039   }
2040 
2041   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
2042 
2043   static ByteSize stack_slot_offset(int i) {
2044     return cell_offset(stack_slot_local_offset(i));
2045   }
2046 
2047   static ByteSize type_offset(int i) {
2048     return cell_offset(type_local_offset(i));
2049   }
2050 };
2051 
2052 // SpeculativeTrapData
2053 //
2054 // A SpeculativeTrapData is used to record traps due to type
2055 // speculation. It records the root of the compilation: that type
2056 // speculation is wrong in the context of one compilation (for
2057 // method1) doesn't mean it's wrong in the context of another one (for
2058 // method2). Type speculation could have more/different data in the
2059 // context of the compilation of method2 and it's worthwhile to try an
2060 // optimization that failed for compilation of method1 in the context
2061 // of compilation of method2.
2062 // Space for SpeculativeTrapData entries is allocated from the extra
2063 // data space in the MDO. If we run out of space, the trap data for
2064 // the ProfileData at that bci is updated.
2065 class SpeculativeTrapData : public ProfileData {
2066 protected:
2067   enum {
2068     speculative_trap_method,
2069     speculative_trap_cell_count
2070   };
2071 public:
2072   SpeculativeTrapData(DataLayout* layout) : ProfileData(layout) {
2073     assert(layout-&gt;tag() == DataLayout::speculative_trap_data_tag, "wrong type");
2074   }
2075 
2076   virtual bool is_SpeculativeTrapData() const { return true; }
2077 
2078   static int static_cell_count() {
2079     return speculative_trap_cell_count;
2080   }
2081 
2082   virtual int cell_count() const {
2083     return static_cell_count();
2084   }
2085 
2086   // Direct accessor
2087   Method* method() const {
2088     return (Method*)intptr_at(speculative_trap_method);
2089   }
2090 
2091   void set_method(Method* m) {
2092     assert(!m-&gt;is_old(), "cannot add old methods");
2093     set_intptr_at(speculative_trap_method, (intptr_t)m);
2094   }
2095 
2096   static ByteSize method_offset() {
2097     return cell_offset(speculative_trap_method);
2098   }
2099 
2100   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
2101 };
2102 
2103 // MethodData*
2104 //
2105 // A MethodData* holds information which has been collected about
2106 // a method.  Its layout looks like this:
2107 //
2108 // -----------------------------
2109 // | header                    |
2110 // | klass                     |
2111 // -----------------------------
2112 // | method                    |
2113 // | size of the MethodData* |
2114 // -----------------------------
2115 // | Data entries...           |
2116 // |   (variable size)         |
2117 // |                           |
2118 // .                           .
2119 // .                           .
2120 // .                           .
2121 // |                           |
2122 // -----------------------------
2123 //
2124 // The data entry area is a heterogeneous array of DataLayouts. Each
2125 // DataLayout in the array corresponds to a specific bytecode in the
2126 // method.  The entries in the array are sorted by the corresponding
2127 // bytecode.  Access to the data is via resource-allocated ProfileData,
2128 // which point to the underlying blocks of DataLayout structures.
2129 //
2130 // During interpretation, if profiling in enabled, the interpreter
2131 // maintains a method data pointer (mdp), which points at the entry
2132 // in the array corresponding to the current bci.  In the course of
2133 // intepretation, when a bytecode is encountered that has profile data
2134 // associated with it, the entry pointed to by mdp is updated, then the
2135 // mdp is adjusted to point to the next appropriate DataLayout.  If mdp
2136 // is NULL to begin with, the interpreter assumes that the current method
2137 // is not (yet) being profiled.
2138 //
2139 // In MethodData* parlance, "dp" is a "data pointer", the actual address
2140 // of a DataLayout element.  A "di" is a "data index", the offset in bytes
2141 // from the base of the data entry array.  A "displacement" is the byte offset
2142 // in certain ProfileData objects that indicate the amount the mdp must be
2143 // adjusted in the event of a change in control flow.
2144 //
2145 
2146 CC_INTERP_ONLY(class BytecodeInterpreter;)
2147 class CleanExtraDataClosure;
2148 
2149 class MethodData : public Metadata {
2150   friend class VMStructs;
2151   friend class JVMCIVMStructs;
2152   CC_INTERP_ONLY(friend class BytecodeInterpreter;)
2153 private:
2154   friend class ProfileData;
2155 
2156   // Back pointer to the Method*
2157   Method* _method;
2158 
2159   // Size of this oop in bytes
2160   int _size;
2161 
2162   // Cached hint for bci_to_dp and bci_to_data
2163   int _hint_di;
2164 
2165   Mutex _extra_data_lock;
2166 
2167   MethodData(const methodHandle&amp; method, int size, TRAPS);
2168 public:
2169   static MethodData* allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS);
2170   MethodData() : _extra_data_lock(Monitor::leaf, "MDO extra data lock") {}; // For ciMethodData
2171 
2172   bool is_methodData() const volatile { return true; }
2173   void initialize();
2174 
2175   // Whole-method sticky bits and flags
2176   enum {
2177     _trap_hist_limit    = 22 JVMCI_ONLY(+5),   // decoupled from Deoptimization::Reason_LIMIT
2178     _trap_hist_mask     = max_jubyte,
2179     _extra_data_count   = 4     // extra DataLayout headers, for trap history
2180   }; // Public flag values
2181 private:
2182   uint _nof_decompiles;             // count of all nmethod removals
2183   uint _nof_overflow_recompiles;    // recompile count, excluding recomp. bits
2184   uint _nof_overflow_traps;         // trap count, excluding _trap_hist
2185   union {
2186     intptr_t _align;
2187     u1 _array[_trap_hist_limit];
2188   } _trap_hist;
2189 
2190   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2191   intx              _eflags;          // flags on escape information
2192   intx              _arg_local;       // bit set of non-escaping arguments
2193   intx              _arg_stack;       // bit set of stack-allocatable arguments
2194   intx              _arg_returned;    // bit set of returned arguments
2195 
2196   int _creation_mileage;              // method mileage at MDO creation
2197 
2198   // How many invocations has this MDO seen?
2199   // These counters are used to determine the exact age of MDO.
2200   // We need those because in tiered a method can be concurrently
2201   // executed at different levels.
2202   InvocationCounter _invocation_counter;
2203   // Same for backedges.
2204   InvocationCounter _backedge_counter;
2205   // Counter values at the time profiling started.
2206   int               _invocation_counter_start;
2207   int               _backedge_counter_start;
2208   uint              _tenure_traps;
2209   int               _invoke_mask;      // per-method Tier0InvokeNotifyFreqLog
2210   int               _backedge_mask;    // per-method Tier0BackedgeNotifyFreqLog
2211 
2212 #if INCLUDE_RTM_OPT
2213   // State of RTM code generation during compilation of the method
2214   int               _rtm_state;
2215 #endif
2216 
2217   // Number of loops and blocks is computed when compiling the first
2218   // time with C1. It is used to determine if method is trivial.
2219   short             _num_loops;
2220   short             _num_blocks;
2221   // Does this method contain anything worth profiling?
2222   enum WouldProfile {unknown, no_profile, profile};
2223   WouldProfile      _would_profile;
2224 
2225 #if INCLUDE_JVMCI
2226   // Support for HotSpotMethodData.setCompiledIRSize(int)
2227   int               _jvmci_ir_size;
2228 #endif
2229 
2230   // Size of _data array in bytes.  (Excludes header and extra_data fields.)
2231   int _data_size;
2232 
2233   // data index for the area dedicated to parameters. -1 if no
2234   // parameter profiling.
2235   enum { no_parameters = -2, parameters_uninitialized = -1 };
2236   int _parameters_type_data_di;
2237   int parameters_size_in_bytes() const {
2238     ParametersTypeData* param = parameters_type_data();
2239     return param == NULL ? 0 : param-&gt;size_in_bytes();
2240   }
2241 
2242   // Beginning of the data entries
2243   intptr_t _data[1];
2244 
2245   // Helper for size computation
2246   static int compute_data_size(BytecodeStream* stream);
2247   static int bytecode_cell_count(Bytecodes::Code code);
2248   static bool is_speculative_trap_bytecode(Bytecodes::Code code);
2249   enum { no_profile_data = -1, variable_cell_count = -2 };
2250 
2251   // Helper for initialization
2252   DataLayout* data_layout_at(int data_index) const {
2253     assert(data_index % sizeof(intptr_t) == 0, "unaligned");
2254     return (DataLayout*) (((address)_data) + data_index);
2255   }
2256 
2257   // Initialize an individual data segment.  Returns the size of
2258   // the segment in bytes.
2259   int initialize_data(BytecodeStream* stream, int data_index);
2260 
2261   // Helper for data_at
2262   DataLayout* limit_data_position() const {
2263     return data_layout_at(_data_size);
2264   }
2265   bool out_of_bounds(int data_index) const {
2266     return data_index &gt;= data_size();
2267   }
2268 
2269   // Give each of the data entries a chance to perform specific
2270   // data initialization.
2271   void post_initialize(BytecodeStream* stream);
2272 
2273   // hint accessors
2274   int      hint_di() const  { return _hint_di; }
2275   void set_hint_di(int di)  {
2276     assert(!out_of_bounds(di), "hint_di out of bounds");
2277     _hint_di = di;
2278   }
2279   ProfileData* data_before(int bci) {
2280     // avoid SEGV on this edge case
2281     if (data_size() == 0)
2282       return NULL;
2283     int hint = hint_di();
2284     if (data_layout_at(hint)-&gt;bci() &lt;= bci)
2285       return data_at(hint);
2286     return first_data();
2287   }
2288 
2289   // What is the index of the first data entry?
2290   int first_di() const { return 0; }
2291 
2292   ProfileData* bci_to_extra_data_helper(int bci, Method* m, DataLayout*&amp; dp, bool concurrent);
2293   // Find or create an extra ProfileData:
2294   ProfileData* bci_to_extra_data(int bci, Method* m, bool create_if_missing);
2295 
2296   // return the argument info cell
2297   ArgInfoData *arg_info();
2298 
2299   enum {
2300     no_type_profile = 0,
2301     type_profile_jsr292 = 1,
2302     type_profile_all = 2
2303   };
2304 
2305   static bool profile_jsr292(const methodHandle&amp; m, int bci);
2306   static int profile_arguments_flag();
2307   static bool profile_all_arguments();
2308   static bool profile_arguments_for_invoke(const methodHandle&amp; m, int bci);
2309   static int profile_return_flag();
2310   static bool profile_all_return();
2311   static bool profile_return_for_invoke(const methodHandle&amp; m, int bci);
2312   static int profile_parameters_flag();
2313   static bool profile_parameters_jsr292_only();
2314   static bool profile_all_parameters();
2315 
2316   void clean_extra_data(CleanExtraDataClosure* cl);
2317   void clean_extra_data_helper(DataLayout* dp, int shift, bool reset = false);
2318   void verify_extra_data_clean(CleanExtraDataClosure* cl);
2319 
2320 public:
2321   static int header_size() {
2322     return sizeof(MethodData)/wordSize;
2323   }
2324 
2325   // Compute the size of a MethodData* before it is created.
2326   static int compute_allocation_size_in_bytes(const methodHandle&amp; method);
2327   static int compute_allocation_size_in_words(const methodHandle&amp; method);
2328   static int compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps);
2329 
2330   // Determine if a given bytecode can have profile information.
2331   static bool bytecode_has_profile(Bytecodes::Code code) {
2332     return bytecode_cell_count(code) != no_profile_data;
2333   }
2334 
2335   // reset into original state
2336   void init();
2337 
2338   // My size
2339   int size_in_bytes() const { return _size; }
2340   int size() const    { return align_metadata_size(align_size_up(_size, BytesPerWord)/BytesPerWord); }
2341 #if INCLUDE_SERVICES
2342   void collect_statistics(KlassSizeStats *sz) const;
2343 #endif
2344 
2345   int      creation_mileage() const  { return _creation_mileage; }
2346   void set_creation_mileage(int x)   { _creation_mileage = x; }
2347 
2348   int invocation_count() {
2349     if (invocation_counter()-&gt;carry()) {
2350       return InvocationCounter::count_limit;
2351     }
2352     return invocation_counter()-&gt;count();
2353   }
2354   int backedge_count() {
2355     if (backedge_counter()-&gt;carry()) {
2356       return InvocationCounter::count_limit;
2357     }
2358     return backedge_counter()-&gt;count();
2359   }
2360 
2361   int invocation_count_start() {
2362     if (invocation_counter()-&gt;carry()) {
2363       return 0;
2364     }
2365     return _invocation_counter_start;
2366   }
2367 
2368   int backedge_count_start() {
2369     if (backedge_counter()-&gt;carry()) {
2370       return 0;
2371     }
2372     return _backedge_counter_start;
2373   }
2374 
2375   int invocation_count_delta() { return invocation_count() - invocation_count_start(); }
2376   int backedge_count_delta()   { return backedge_count()   - backedge_count_start();   }
2377 
2378   void reset_start_counters() {
2379     _invocation_counter_start = invocation_count();
2380     _backedge_counter_start = backedge_count();
2381   }
2382 
2383   InvocationCounter* invocation_counter()     { return &amp;_invocation_counter; }
2384   InvocationCounter* backedge_counter()       { return &amp;_backedge_counter;   }
2385 
2386 #if INCLUDE_RTM_OPT
2387   int rtm_state() const {
2388     return _rtm_state;
2389   }
2390   void set_rtm_state(RTMState rstate) {
2391     _rtm_state = (int)rstate;
2392   }
2393   void atomic_set_rtm_state(RTMState rstate) {
2394     Atomic::store((int)rstate, &amp;_rtm_state);
2395   }
2396 
2397   static int rtm_state_offset_in_bytes() {
2398     return offset_of(MethodData, _rtm_state);
2399   }
2400 #endif
2401 
2402   void set_would_profile(bool p)              { _would_profile = p ? profile : no_profile; }
2403   bool would_profile() const                  { return _would_profile != no_profile; }
2404 
2405   int num_loops() const                       { return _num_loops;  }
2406   void set_num_loops(int n)                   { _num_loops = n;     }
2407   int num_blocks() const                      { return _num_blocks; }
2408   void set_num_blocks(int n)                  { _num_blocks = n;    }
2409 
2410   bool is_mature() const;  // consult mileage and ProfileMaturityPercentage
2411   static int mileage_of(Method* m);
2412 
2413   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2414   enum EscapeFlag {
2415     estimated    = 1 &lt;&lt; 0,
2416     return_local = 1 &lt;&lt; 1,
2417     return_allocated = 1 &lt;&lt; 2,
2418     allocated_escapes = 1 &lt;&lt; 3,
2419     unknown_modified = 1 &lt;&lt; 4
2420   };
2421 
2422   intx eflags()                                  { return _eflags; }
2423   intx arg_local()                               { return _arg_local; }
2424   intx arg_stack()                               { return _arg_stack; }
2425   intx arg_returned()                            { return _arg_returned; }
2426   uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();
2427                                                    assert(aid != NULL, "arg_info must be not null");
2428                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), "valid argument number");
2429                                                    return aid-&gt;arg_modified(a); }
2430 
2431   void set_eflags(intx v)                        { _eflags = v; }
2432   void set_arg_local(intx v)                     { _arg_local = v; }
2433   void set_arg_stack(intx v)                     { _arg_stack = v; }
2434   void set_arg_returned(intx v)                  { _arg_returned = v; }
2435   void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();
2436                                                    assert(aid != NULL, "arg_info must be not null");
2437                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), "valid argument number");
2438                                                    aid-&gt;set_arg_modified(a, v); }
2439 
2440   void clear_escape_info()                       { _eflags = _arg_local = _arg_stack = _arg_returned = 0; }
2441 
2442   // Location and size of data area
2443   address data_base() const {
2444     return (address) _data;
2445   }
2446   int data_size() const {
2447     return _data_size;
2448   }
2449 
2450   // Accessors
2451   Method* method() const { return _method; }
2452 
2453   // Get the data at an arbitrary (sort of) data index.
2454   ProfileData* data_at(int data_index) const;
2455 
2456   // Walk through the data in order.
2457   ProfileData* first_data() const { return data_at(first_di()); }
2458   ProfileData* next_data(ProfileData* current) const;
2459   bool is_valid(ProfileData* current) const { return current != NULL; }
2460 
2461   // Convert a dp (data pointer) to a di (data index).
2462   int dp_to_di(address dp) const {
2463     return dp - ((address)_data);
2464   }
2465 
2466   // bci to di/dp conversion.
2467   address bci_to_dp(int bci);
2468   int bci_to_di(int bci) {
2469     return dp_to_di(bci_to_dp(bci));
2470   }
2471 
2472   // Get the data at an arbitrary bci, or NULL if there is none.
2473   ProfileData* bci_to_data(int bci);
2474 
2475   // Same, but try to create an extra_data record if one is needed:
2476   ProfileData* allocate_bci_to_data(int bci, Method* m) {
2477     ProfileData* data = NULL;
2478     // If m not NULL, try to allocate a SpeculativeTrapData entry
2479     if (m == NULL) {
2480       data = bci_to_data(bci);
2481     }
2482     if (data != NULL) {
2483       return data;
2484     }
2485     data = bci_to_extra_data(bci, m, true);
2486     if (data != NULL) {
2487       return data;
2488     }
2489     // If SpeculativeTrapData allocation fails try to allocate a
2490     // regular entry
2491     data = bci_to_data(bci);
2492     if (data != NULL) {
2493       return data;
2494     }
2495     return bci_to_extra_data(bci, NULL, true);
2496   }
2497 
2498   // Add a handful of extra data records, for trap tracking.
2499   DataLayout* extra_data_base() const  { return limit_data_position(); }
2500   DataLayout* extra_data_limit() const { return (DataLayout*)((address)this + size_in_bytes()); }
2501   DataLayout* args_data_limit() const  { return (DataLayout*)((address)this + size_in_bytes() -
2502                                                               parameters_size_in_bytes()); }
2503   int extra_data_size() const          { return (address)extra_data_limit() - (address)extra_data_base(); }
2504   static DataLayout* next_extra(DataLayout* dp);
2505 
2506   // Return (uint)-1 for overflow.
2507   uint trap_count(int reason) const {
2508     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, "oob");
2509     return (int)((_trap_hist._array[reason]+1) &amp; _trap_hist_mask) - 1;
2510   }
2511   // For loops:
2512   static uint trap_reason_limit() { return _trap_hist_limit; }
2513   static uint trap_count_limit()  { return _trap_hist_mask; }
2514   uint inc_trap_count(int reason) {
2515     // Count another trap, anywhere in this method.
2516     assert(reason &gt;= 0, "must be single trap");
2517     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, "oob");
2518     uint cnt1 = 1 + _trap_hist._array[reason];
2519     if ((cnt1 &amp; _trap_hist_mask) != 0) {  // if no counter overflow...
2520       _trap_hist._array[reason] = cnt1;
2521       return cnt1;
2522     } else {
2523       return _trap_hist_mask + (++_nof_overflow_traps);
2524     }
2525   }
2526 
2527   uint overflow_trap_count() const {
2528     return _nof_overflow_traps;
2529   }
2530   uint overflow_recompile_count() const {
2531     return _nof_overflow_recompiles;
2532   }
2533   void inc_overflow_recompile_count() {
2534     _nof_overflow_recompiles += 1;
2535   }
2536   uint decompile_count() const {
2537     return _nof_decompiles;
2538   }
2539   void inc_decompile_count() {
2540     _nof_decompiles += 1;
2541     if (decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
2542       method()-&gt;set_not_compilable(CompLevel_full_optimization, true, "decompile_count &gt; PerMethodRecompilationCutoff");
2543     }
2544   }
2545   uint tenure_traps() const {
2546     return _tenure_traps;
2547   }
2548   void inc_tenure_traps() {
2549     _tenure_traps += 1;
2550   }
2551 
2552   // Return pointer to area dedicated to parameters in MDO
2553   ParametersTypeData* parameters_type_data() const {
2554     assert(_parameters_type_data_di != parameters_uninitialized, "called too early");
2555     return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)-&gt;data_in()-&gt;as_ParametersTypeData() : NULL;
2556   }
2557 
2558   int parameters_type_data_di() const {
2559     assert(_parameters_type_data_di != parameters_uninitialized &amp;&amp; _parameters_type_data_di != no_parameters, "no args type data");
2560     return _parameters_type_data_di;
2561   }
2562 
2563   // Support for code generation
2564   static ByteSize data_offset() {
2565     return byte_offset_of(MethodData, _data[0]);
2566   }
2567 
2568   static ByteSize trap_history_offset() {
2569     return byte_offset_of(MethodData, _trap_hist._array);
2570   }
2571 
2572   static ByteSize invocation_counter_offset() {
2573     return byte_offset_of(MethodData, _invocation_counter);
2574   }
2575 
2576   static ByteSize backedge_counter_offset() {
2577     return byte_offset_of(MethodData, _backedge_counter);
2578   }
2579 
2580   static ByteSize invoke_mask_offset() {
2581     return byte_offset_of(MethodData, _invoke_mask);
2582   }
2583 
2584   static ByteSize backedge_mask_offset() {
2585     return byte_offset_of(MethodData, _backedge_mask);
2586   }
2587 
2588   static ByteSize parameters_type_data_di_offset() {
2589     return byte_offset_of(MethodData, _parameters_type_data_di);
2590   }
2591 
2592   // Deallocation support - no pointer fields to deallocate
2593   void deallocate_contents(ClassLoaderData* loader_data) {}
2594 
2595   // GC support
2596   void set_size(int object_size_in_bytes) { _size = object_size_in_bytes; }
2597 
2598   // Printing
2599   void print_on      (outputStream* st) const;
2600   void print_value_on(outputStream* st) const;
2601 
2602   // printing support for method data
2603   void print_data_on(outputStream* st) const;
2604 
2605   const char* internal_name() const { return "{method data}"; }
2606 
2607   // verification
2608   void verify_on(outputStream* st);
2609   void verify_data_on(outputStream* st);
2610 
2611   static bool profile_parameters_for_method(const methodHandle&amp; m);
2612   static bool profile_arguments();
2613   static bool profile_arguments_jsr292_only();
2614   static bool profile_return();
2615   static bool profile_parameters();
2616   static bool profile_return_jsr292_only();
2617 
2618   void clean_method_data(BoolObjectClosure* is_alive);
2619   void clean_weak_method_links();
2620   DEBUG_ONLY(void verify_clean_weak_method_links();)
2621   Mutex* extra_data_lock() { return &amp;_extra_data_lock; }
2622 };
2623 
2624 #endif // SHARE_VM_OOPS_METHODDATAOOP_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
