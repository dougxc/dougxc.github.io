<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "code/codeCache.hpp"
  27 #include "code/scopeDesc.hpp"
  28 #include "interpreter/linkResolver.hpp"
  29 #include "memory/oopFactory.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "oops/generateOopMap.hpp"
  32 #include "oops/fieldStreams.hpp"
  33 #include "oops/oop.inline.hpp"
  34 #include "oops/objArrayOop.inline.hpp"
  35 #include "runtime/fieldDescriptor.hpp"
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"
  56 #include "utilities/resourceHash.hpp"
  57 
  58 
  59 void JNIHandleMark::push_jni_handle_block() {
  60   JavaThread* thread = JavaThread::current();
  61   if (thread != NULL) {
  62     // Allocate a new block for JNI handles.
  63     // Inlined code from jni_PushLocalFrame()
  64     JNIHandleBlock* java_handles = ((JavaThread*)thread)-&gt;active_handles();
  65     JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
  66     assert(compile_handles != NULL &amp;&amp; java_handles != NULL, "should not be NULL");
  67     compile_handles-&gt;set_pop_frame_link(java_handles);
  68     thread-&gt;set_active_handles(compile_handles);
  69   }
  70 }
  71 
  72 void JNIHandleMark::pop_jni_handle_block() {
  73   JavaThread* thread = JavaThread::current();
  74   if (thread != NULL) {
  75     // Release our JNI handle block
  76     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  77     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  78     thread-&gt;set_active_handles(java_handles);
  79     compile_handles-&gt;set_pop_frame_link(NULL);
  80     JNIHandleBlock::release_block(compile_handles, thread); // may block
  81   }
  82 }
  83 
  84 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  85 #define C2V_VMENTRY(result_type, name, signature) \
  86   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  87   TRACE_jvmci_1("CompilerToVM::" #name); \
  88   TRACE_CALL(result_type, jvmci_ ## name signature) \
  89   JVMCI_VM_ENTRY_MARK; \
  90 
  91 #define C2V_END }
  92 
  93 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  94   if (method() != NULL) {
  95     JavaValue result(T_OBJECT);
  96     JavaCallArguments args;
  97     args.push_long((jlong) (address) method());
  98     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  99 
 100     return (oop)result.get_jobject();
 101   }
 102   return NULL;
 103 }
 104 
 105 oop CompilerToVM::get_jvmci_type(Klass* klass, TRAPS) {
 106   if (klass != NULL) {
 107     JavaValue result(T_OBJECT);
 108     JavaCallArguments args;
 109     args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
 110     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 111 
 112     return (oop)result.get_jobject();
 113   }
 114   return NULL;
 115 }
 116 
 117 
 118 int CompilerToVM::Data::Klass_vtable_start_offset;
 119 int CompilerToVM::Data::Klass_vtable_length_offset;
 120 
 121 int CompilerToVM::Data::Method_extra_stack_entries;
 122 
 123 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
 124 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
 125 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
 126 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 127 
 128 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 129 
 130 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 131 int CompilerToVM::Data::Universe_base_vtable_size;
 132 address CompilerToVM::Data::Universe_narrow_oop_base;
 133 int CompilerToVM::Data::Universe_narrow_oop_shift;
 134 address CompilerToVM::Data::Universe_narrow_klass_base;
 135 int CompilerToVM::Data::Universe_narrow_klass_shift;
 136 void* CompilerToVM::Data::Universe_non_oop_bits;
 137 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 138 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 139 
 140 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 141 HeapWord** CompilerToVM::Data::_heap_end_addr;
 142 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
 143 int CompilerToVM::Data::_max_oop_map_stack_offset;
 144 
 145 jbyte* CompilerToVM::Data::cardtable_start_address;
 146 int CompilerToVM::Data::cardtable_shift;
 147 
 148 int CompilerToVM::Data::vm_page_size;
 149 
 150 int CompilerToVM::Data::sizeof_vtableEntry = sizeof(vtableEntry);
 151 int CompilerToVM::Data::sizeof_ExceptionTableElement = sizeof(ExceptionTableElement);
 152 int CompilerToVM::Data::sizeof_LocalVariableTableElement = sizeof(LocalVariableTableElement);
 153 int CompilerToVM::Data::sizeof_ConstantPool = sizeof(ConstantPool);
 154 int CompilerToVM::Data::sizeof_SymbolPointer = sizeof(Symbol*);
 155 int CompilerToVM::Data::sizeof_narrowKlass = sizeof(narrowKlass);
 156 int CompilerToVM::Data::sizeof_arrayOopDesc = sizeof(arrayOopDesc);
 157 int CompilerToVM::Data::sizeof_BasicLock = sizeof(BasicLock);
 158 
 159 address CompilerToVM::Data::dsin;
 160 address CompilerToVM::Data::dcos;
 161 address CompilerToVM::Data::dtan;
 162 address CompilerToVM::Data::dexp;
 163 address CompilerToVM::Data::dlog;
 164 address CompilerToVM::Data::dlog10;
 165 address CompilerToVM::Data::dpow;
 166 
 167 address CompilerToVM::Data::symbol_init;
 168 address CompilerToVM::Data::symbol_clinit;
 169 
 170 void CompilerToVM::Data::initialize(TRAPS) {
 171   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 172   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 173 
 174   Method_extra_stack_entries = Method::extra_stack_entries();
 175 
 176   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 177   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 178   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 179   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 180 
 181   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 182 
 183   Universe_collectedHeap = Universe::heap();
 184   Universe_base_vtable_size = Universe::base_vtable_size();
 185   Universe_narrow_oop_base = Universe::narrow_oop_base();
 186   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 187   Universe_narrow_klass_base = Universe::narrow_klass_base();
 188   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 189   Universe_non_oop_bits = Universe::non_oop_word();
 190   Universe_verify_oop_mask = Universe::verify_oop_mask();
 191   Universe_verify_oop_bits = Universe::verify_oop_bits();
 192 
 193   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 194   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 195   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
 196 
 197   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 198   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 199   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 200   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 201 
 202   symbol_init = (address) vmSymbols::object_initializer_name();
 203   symbol_clinit = (address) vmSymbols::class_initializer_name();
 204 
 205   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 206   if (bs-&gt;is_a(BarrierSet::CardTableModRef)) {
 207     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 208     assert(base != 0, "unexpected byte_map_base");
 209     cardtable_start_address = base;
 210     cardtable_shift = CardTableModRefBS::card_shift;
 211   } else {
 212     // No card mark barriers
 213     cardtable_start_address = 0;
 214     cardtable_shift = 0;
 215   }
 216 
 217   vm_page_size = os::vm_page_size();
 218 
 219 #define SET_TRIGFUNC(name)                                      \
 220   if (StubRoutines::name() != NULL) {                           \
 221     name = StubRoutines::name();                                \
 222   } else {                                                      \
 223     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 224   }
 225 
 226   SET_TRIGFUNC(dsin);
 227   SET_TRIGFUNC(dcos);
 228   SET_TRIGFUNC(dtan);
 229   SET_TRIGFUNC(dexp);
 230   SET_TRIGFUNC(dlog10);
 231   SET_TRIGFUNC(dlog);
 232   SET_TRIGFUNC(dpow);
 233 
 234 #undef SET_TRIGFUNC
 235 }
 236 
 237 objArrayHandle CompilerToVM::initialize_intrinsics(TRAPS) {
 238   objArrayHandle vmIntrinsics = oopFactory::new_objArray_handle(VMIntrinsicMethod::klass(), (vmIntrinsics::ID_LIMIT - 1), CHECK_(objArrayHandle()));
 239   int index = 0;
 240   // The intrinsics for a class are usually adjacent to each other.
 241   // When they are, the string for the class name can be reused.
 242   vmSymbols::SID kls_sid = vmSymbols::NO_SID;
 243   Handle kls_str;
 244 #define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)
 245 #define VM_SYMBOL_TO_STRING(s) \
 246   java_lang_String::create_from_symbol(vmSymbols::symbol_at(SID_ENUM(s)), CHECK_(objArrayHandle()))
 247 #define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \
 248     instanceHandle vmIntrinsicMethod = InstanceKlass::cast(VMIntrinsicMethod::klass())-&gt;allocate_instance_handle(CHECK_(objArrayHandle())); \
 249     if (kls_sid != SID_ENUM(kls)) {                                       \
 250       kls_str = VM_SYMBOL_TO_STRING(kls);                                 \
 251       kls_sid = SID_ENUM(kls);                                            \
 252     }                                                                     \
 253     Handle name_str = VM_SYMBOL_TO_STRING(name);                          \
 254     Handle sig_str = VM_SYMBOL_TO_STRING(sig);                            \
 255     VMIntrinsicMethod::set_declaringClass(vmIntrinsicMethod, kls_str());  \
 256     VMIntrinsicMethod::set_name(vmIntrinsicMethod, name_str());           \
 257     VMIntrinsicMethod::set_descriptor(vmIntrinsicMethod, sig_str());      \
 258     VMIntrinsicMethod::set_id(vmIntrinsicMethod, vmIntrinsics::id);       \
 259       vmIntrinsics-&gt;obj_at_put(index++, vmIntrinsicMethod());             \
 260   }
 261 
 262   VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
 263 #undef SID_ENUM
 264 #undef VM_SYMBOL_TO_STRING
 265 #undef VM_INTRINSIC_INFO
 266   assert(index == vmIntrinsics::ID_LIMIT - 1, "must be");
 267 
 268   return vmIntrinsics;
 269 }
 270 
 271 /**
 272  * The set of VM flags known to be used.
 273  */
 274 #define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_intx_flag, do_uintx_flag) \
 275   do_intx_flag(AllocateInstancePrefetchLines)                              \
 276   do_intx_flag(AllocatePrefetchDistance)                                   \
 277   do_intx_flag(AllocatePrefetchInstr)                                      \
 278   do_intx_flag(AllocatePrefetchLines)                                      \
 279   do_intx_flag(AllocatePrefetchStepSize)                                   \
 280   do_intx_flag(AllocatePrefetchStyle)                                      \
 281   do_intx_flag(BciProfileWidth)                                            \
 282   do_bool_flag(BootstrapJVMCI)                                             \
 283   do_bool_flag(CITime)                                                     \
 284   do_bool_flag(CITimeEach)                                                 \
 285   do_uintx_flag(CodeCacheSegmentSize)                                      \
 286   do_intx_flag(CodeEntryAlignment)                                         \
 287   do_bool_flag(CompactFields)                                              \
 288   NOT_PRODUCT(do_intx_flag(CompileTheWorldStartAt))                        \
 289   NOT_PRODUCT(do_intx_flag(CompileTheWorldStopAt))                         \
 290   do_intx_flag(ContendedPaddingWidth)                                      \
 291   do_bool_flag(DontCompileHugeMethods)                                     \
 292   do_bool_flag(EnableContended)                                            \
 293   do_intx_flag(FieldsAllocationStyle)                                      \
 294   do_bool_flag(FoldStableValues)                                           \
 295   do_bool_flag(ForceUnreachable)                                           \
 296   do_intx_flag(HugeMethodLimit)                                            \
 297   do_bool_flag(Inline)                                                     \
 298   do_intx_flag(JVMCICounterSize)                                           \
 299   do_bool_flag(JVMCIPrintProperties)                                       \
 300   do_bool_flag(JVMCIUseFastLocking)                                        \
 301   do_intx_flag(MethodProfileWidth)                                         \
 302   do_intx_flag(ObjectAlignmentInBytes)                                     \
 303   do_bool_flag(PrintInlining)                                              \
 304   do_bool_flag(ReduceInitialCardMarks)                                     \
 305   do_bool_flag(RestrictContended)                                          \
 306   do_intx_flag(StackReservedPages)                                         \
 307   do_intx_flag(StackShadowPages)                                           \
 308   do_bool_flag(TLABStats)                                                  \
 309   do_uintx_flag(TLABWasteIncrement)                                        \
 310   do_intx_flag(TypeProfileWidth)                                           \
 311   do_bool_flag(UseAESIntrinsics)                                           \
 312   X86_ONLY(do_intx_flag(UseAVX))                                           \
 313   do_bool_flag(UseBiasedLocking)                                           \
 314   do_bool_flag(UseCRC32Intrinsics)                                         \
 315   do_bool_flag(UseCompressedClassPointers)                                 \
 316   do_bool_flag(UseCompressedOops)                                          \
 317   do_bool_flag(UseConcMarkSweepGC)                                         \
 318   X86_ONLY(do_bool_flag(UseCountLeadingZerosInstruction))                  \
 319   X86_ONLY(do_bool_flag(UseCountTrailingZerosInstruction))                 \
 320   do_bool_flag(UseG1GC)                                                    \
 321   COMPILER2_PRESENT(do_bool_flag(UseMontgomeryMultiplyIntrinsic))          \
 322   COMPILER2_PRESENT(do_bool_flag(UseMontgomerySquareIntrinsic))            \
 323   COMPILER2_PRESENT(do_bool_flag(UseMulAddIntrinsic))                      \
 324   COMPILER2_PRESENT(do_bool_flag(UseMultiplyToLenIntrinsic))               \
 325   do_bool_flag(UsePopCountInstruction)                                     \
 326   do_bool_flag(UseSHA1Intrinsics)                                          \
 327   do_bool_flag(UseSHA256Intrinsics)                                        \
 328   do_bool_flag(UseSHA512Intrinsics)                                        \
 329   do_intx_flag(UseSSE)                                                     \
 330   COMPILER2_PRESENT(do_bool_flag(UseSquareToLenIntrinsic))                 \
 331   do_bool_flag(UseStackBanging)                                            \
 332   do_bool_flag(UseTLAB)                                                    \
 333   do_bool_flag(VerifyOops)                                                 \
 334 
 335 #define BOXED_BOOLEAN(name, value) oop name = ((jboolean)(value) ? boxedTrue() : boxedFalse())
 336 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)
 337 #define BOXED_LONG(name, value) \
 338   oop name; \
 339   do { \
 340     jvalue p; p.j = (jlong) (value); \
 341     Handle* e = longs.get(p.j); \
 342     if (e == NULL) { \
 343       oop o = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); \
 344       Handle h(THREAD, o); \
 345       longs.put(p.j, h); \
 346       name = h(); \
 347     } else { \
 348       name = (*e)(); \
 349     } \
 350   } while (0)
 351 
 352 #define CSTRING_TO_JSTRING(name, value) \
 353   Handle name; \
 354   do { \
 355     if (value != NULL) { \
 356       Handle* e = strings.get(value); \
 357       if (e == NULL) { \
 358         Handle h = java_lang_String::create_from_str(value, CHECK_NULL); \
 359         strings.put(value, h); \
 360         name = h; \
 361       } else { \
 362         name = (*e); \
 363       } \
 364     } \
 365   } while (0)
 366 
 367 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))
 368   ResourceMark rm;
 369   HandleMark hm;
 370 
 371   // Used to canonicalize Long and String values.
 372   ResourceHashtable&lt;jlong, Handle&gt; longs;
 373   ResourceHashtable&lt;const char*, Handle, &amp;CompilerToVM::cstring_hash, &amp;CompilerToVM::cstring_equals&gt; strings;
 374 
 375   jvalue prim;
 376   prim.z = true;  oop boxedTrueOop =  java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 377   Handle boxedTrue(THREAD, boxedTrueOop);
 378   prim.z = false; oop boxedFalseOop = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 379   Handle boxedFalse(THREAD, boxedFalseOop);
 380 
 381   CompilerToVM::Data::initialize(CHECK_NULL);
 382 
 383   VMField::klass()-&gt;initialize(CHECK_NULL);
 384   VMFlag::klass()-&gt;initialize(CHECK_NULL);
 385   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);
 386 
 387   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
 388   objArrayHandle vmFields = oopFactory::new_objArray_handle(VMField::klass(), len, CHECK_NULL);
 389   for (int i = 0; i &lt; len ; i++) {
 390     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
 391     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 392     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* "::" */;
 393     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
 394     sprintf(name_buf, "%s::%s", vmField.typeName, vmField.fieldName);
 395     CSTRING_TO_JSTRING(name, name_buf);
 396     CSTRING_TO_JSTRING(type, vmField.typeString);
 397     VMField::set_name(vmFieldObj, name());
 398     VMField::set_type(vmFieldObj, type());
 399     VMField::set_offset(vmFieldObj, vmField.offset);
 400     VMField::set_address(vmFieldObj, (jlong) vmField.address);
 401     if (vmField.isStatic &amp;&amp; vmField.typeString != NULL) {
 402       if (strcmp(vmField.typeString, "bool") == 0) {
 403         BOXED_BOOLEAN(box, *(jbyte*) vmField.address);
 404         VMField::set_value(vmFieldObj, box);
 405       } else if (strcmp(vmField.typeString, "int") == 0 ||
 406                  strcmp(vmField.typeString, "jint") == 0) {
 407         BOXED_LONG(box, *(jint*) vmField.address);
 408         VMField::set_value(vmFieldObj, box);
 409       } else if (strcmp(vmField.typeString, "uint64_t") == 0) {
 410         BOXED_LONG(box, *(uint64_t*) vmField.address);
 411         VMField::set_value(vmFieldObj, box);
 412       } else if (strcmp(vmField.typeString, "address") == 0 ||
 413                  strcmp(vmField.typeString, "intptr_t") == 0 ||
 414                  strcmp(vmField.typeString, "uintptr_t") == 0 ||
 415                  strcmp(vmField.typeString, "OopHandle") == 0 ||
 416                  strcmp(vmField.typeString, "size_t") == 0 ||
 417                  // All foo* types are addresses.
 418                  vmField.typeString[strlen(vmField.typeString) - 1] == '*') {
 419         BOXED_LONG(box, *((address*) vmField.address));
 420         VMField::set_value(vmFieldObj, box);
 421       } else {
 422         JVMCI_ERROR_NULL("VM field %s has unsupported type %s", name_buf, vmField.typeString);
 423       }
 424     }
 425     vmFields-&gt;obj_at_put(i, vmFieldObj());
 426   }
 427 
 428   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
 429   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
 430   len = ints_len + longs_len;
 431   objArrayHandle vmConstants = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 432   int insert = 0;
 433   for (int i = 0; i &lt; ints_len ; i++) {
 434     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
 435     CSTRING_TO_JSTRING(name, c.name);
 436     BOXED_LONG(value, c.value);
 437     vmConstants-&gt;obj_at_put(insert++, name());
 438     vmConstants-&gt;obj_at_put(insert++, value);
 439   }
 440   for (int i = 0; i &lt; longs_len ; i++) {
 441     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
 442     CSTRING_TO_JSTRING(name, c.name);
 443     BOXED_LONG(value, c.value);
 444     vmConstants-&gt;obj_at_put(insert++, name());
 445     vmConstants-&gt;obj_at_put(insert++, value);
 446   }
 447   assert(insert == len * 2, "must be");
 448 
 449   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
 450   objArrayHandle vmAddresses = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 451   for (int i = 0; i &lt; len ; i++) {
 452     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
 453     CSTRING_TO_JSTRING(name, a.name);
 454     BOXED_LONG(value, a.value);
 455     vmAddresses-&gt;obj_at_put(i * 2, name());
 456     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);
 457   }
 458 
 459 #define COUNT_FLAG(ignore) +1
 460 #ifdef ASSERT
 461 #define CHECK_FLAG(type, name) { \
 462   Flag* flag = Flag::find_flag(#name, strlen(#name), /*allow_locked*/ true, /* return_flag */ true); \
 463   assert(flag != NULL, "No such flag named " #name); \
 464   assert(flag-&gt;is_##type(), "Flag " #name " is not of type " #type); \
 465 }
 466 #else
 467 #define CHECK_FLAG(type, name)
 468 #endif
 469 
 470 #define ADD_FLAG(type, name, convert) { \
 471   CHECK_FLAG(type, name) \
 472   instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL); \
 473   CSTRING_TO_JSTRING(fname, #name); \
 474   CSTRING_TO_JSTRING(ftype, #type); \
 475   VMFlag::set_name(vmFlagObj, fname()); \
 476   VMFlag::set_type(vmFlagObj, ftype()); \
 477   convert(value, name); \
 478   VMFlag::set_value(vmFlagObj, value); \
 479   vmFlags-&gt;obj_at_put(i++, vmFlagObj()); \
 480 }
 481 #define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)
 482 #define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)
 483 #define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)
 484 
 485   len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);
 486   objArrayHandle vmFlags = oopFactory::new_objArray_handle(VMFlag::klass(), len, CHECK_NULL);
 487   int i = 0;
 488   PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)
 489 
 490   objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);
 491 
 492   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 5, CHECK_NULL);
 493   data-&gt;obj_at_put(0, vmFields());
 494   data-&gt;obj_at_put(1, vmConstants());
 495   data-&gt;obj_at_put(2, vmAddresses());
 496   data-&gt;obj_at_put(3, vmFlags());
 497   data-&gt;obj_at_put(4, vmIntrinsics());
 498 
 499   return (jobjectArray) JNIHandles::make_local(THREAD, data);
 500 #undef COUNT_FLAG
 501 #undef ADD_FLAG
 502 #undef ADD_BOOL_FLAG
 503 #undef ADD_INTX_FLAG
 504 #undef ADD_UINTX_FLAG
 505 #undef CHECK_FLAG
 506 C2V_END
 507 
 508 C2V_VMENTRY(jobject, getFlagValue, (JNIEnv *, jobject c2vm, jobject name_handle))
 509 #define RETURN_BOXED_LONG(value) oop box; jvalue p; p.j = (jlong) (value); box = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);
 510 #define RETURN_BOXED_DOUBLE(value) oop box; jvalue p; p.d = (jdouble) (value); box = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);
 511   Handle name(THREAD, JNIHandles::resolve(name_handle));
 512   if (name.is_null()) {
 513     THROW_0(vmSymbols::java_lang_NullPointerException());
 514   }
 515   ResourceMark rm;
 516   const char* cstring = java_lang_String::as_utf8_string(name());
 517   Flag* flag = Flag::find_flag(cstring, strlen(cstring), /* allow_locked */ true, /* return_flag */ true);
 518   if (flag == NULL) {
 519     return c2vm;
 520   }
 521   if (flag-&gt;is_bool()) {
 522     jvalue prim;
 523     prim.z = flag-&gt;get_bool();
 524     oop box = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 525     return JNIHandles::make_local(THREAD, box);
 526   } else if (flag-&gt;is_ccstr()) {
 527     Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
 528     return JNIHandles::make_local(THREAD, value());
 529   } else if (flag-&gt;is_intx()) {
 530     RETURN_BOXED_LONG(flag-&gt;get_intx());
 531   } else if (flag-&gt;is_int()) {
 532     RETURN_BOXED_LONG(flag-&gt;get_int());
 533   } else if (flag-&gt;is_uint()) {
 534     RETURN_BOXED_LONG(flag-&gt;get_uint());
 535   } else if (flag-&gt;is_uint64_t()) {
 536     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());
 537   } else if (flag-&gt;is_size_t()) {
 538     RETURN_BOXED_LONG(flag-&gt;get_size_t());
 539   } else if (flag-&gt;is_uintx()) {
 540     RETURN_BOXED_LONG(flag-&gt;get_uintx());
 541   } else if (flag-&gt;is_double()) {
 542     RETURN_BOXED_DOUBLE(flag-&gt;get_double());
 543   } else {
 544     JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
 545   }
 546 C2V_END
 547 
 548 #undef BOXED_LONG
 549 #undef BOXED_DOUBLE
 550 #undef CSTRING_TO_JSTRING
 551 
 552 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 553   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 554   ResourceMark rm;
 555 
 556   int code_size = method-&gt;code_size();
 557   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 558 
 559   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 560   // iterate over all bytecodes and replace non-Java bytecodes
 561 
 562   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 563     Bytecodes::Code code = s.code();
 564     Bytecodes::Code raw_code = s.raw_code();
 565     int bci = s.bci();
 566     int len = s.instruction_size();
 567 
 568     // Restore original byte code.
 569     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 570     if (len &gt; 1) {
 571       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);
 572     }
 573 
 574     if (len &gt; 1) {
 575       // Restore the big-endian constant pool indexes.
 576       // Cf. Rewriter::scan_method
 577       switch (code) {
 578         case Bytecodes::_getstatic:
 579         case Bytecodes::_putstatic:
 580         case Bytecodes::_getfield:
 581         case Bytecodes::_putfield:
 582         case Bytecodes::_invokevirtual:
 583         case Bytecodes::_invokespecial:
 584         case Bytecodes::_invokestatic:
 585         case Bytecodes::_invokeinterface:
 586         case Bytecodes::_invokehandle: {
 587           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 588           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 589           break;
 590         }
 591 
 592         case Bytecodes::_invokedynamic: {
 593           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 594           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);
 595           break;
 596         }
 597 
 598         default:
 599           break;
 600       }
 601 
 602       // Not all ldc byte code are rewritten.
 603       switch (raw_code) {
 604         case Bytecodes::_fast_aldc: {
 605           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;
 606           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 607           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 608           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);
 609           break;
 610         }
 611 
 612         case Bytecodes::_fast_aldc_w: {
 613           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 614           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 615           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 616           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 617           break;
 618         }
 619 
 620         default:
 621           break;
 622       }
 623     }
 624   }
 625 
 626   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);
 627 C2V_END
 628 
 629 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 630   ResourceMark rm;
 631   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 632   return method-&gt;exception_table_length();
 633 C2V_END
 634 
 635 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 636   ResourceMark rm;
 637   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 638   if (method-&gt;exception_table_length() == 0) {
 639     return 0L;
 640   }
 641   return (jlong) (address) method-&gt;exception_table_start();
 642 C2V_END
 643 
 644 C2V_VMENTRY(jobject, asResolvedJavaMethod, (JNIEnv *, jobject, jobject executable_handle))
 645   oop executable = JNIHandles::resolve(executable_handle);
 646   oop mirror = NULL;
 647   int slot = 0;
 648 
 649   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 650     mirror = java_lang_reflect_Constructor::clazz(executable);
 651     slot = java_lang_reflect_Constructor::slot(executable);
 652   } else {
 653     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), "wrong type");
 654     mirror = java_lang_reflect_Method::clazz(executable);
 655     slot = java_lang_reflect_Method::slot(executable);
 656   }
 657   Klass* holder = java_lang_Class::as_Klass(mirror);
 658   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 659   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 660   return JNIHandles::make_local(THREAD, result);
 661 }
 662 
 663 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))
 664   methodHandle method;
 665   oop base_object = JNIHandles::resolve(base);
 666   if (base_object == NULL) {
 667     method = *((Method**)(offset));
 668   } else if (base_object-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {
 669     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);
 670   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 671     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));
 672   } else {
 673     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 674                 err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 675   }
 676   assert (method.is_null() || method-&gt;is_method(), "invalid read");
 677   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 678   return JNIHandles::make_local(THREAD, result);
 679 }
 680 
 681 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject object_handle))
 682   constantPoolHandle cp;
 683   oop object = JNIHandles::resolve(object_handle);
 684   if (object == NULL) {
 685     THROW_0(vmSymbols::java_lang_NullPointerException());
 686   }
 687   if (object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 688     cp = CompilerToVM::asMethod(object)-&gt;constMethod()-&gt;constants();
 689   } else if (object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 690     cp = InstanceKlass::cast(CompilerToVM::asKlass(object))-&gt;constants();
 691   } else {
 692     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 693                 err_msg("Unexpected type: %s", object-&gt;klass()-&gt;external_name()));
 694   }
 695   assert(!cp.is_null(), "npe");
 696   JavaValue method_result(T_OBJECT);
 697   JavaCallArguments args;
 698   args.push_long((jlong) (address) cp());
 699   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 700   return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());
 701 }
 702 
 703 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))
 704   Klass* klass = NULL;
 705   oop base_object = JNIHandles::resolve(base);
 706   jlong base_address = 0;
 707   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 708     klass = base_object-&gt;klass();
 709   } else if (!compressed) {
 710     if (base_object != NULL) {
 711       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 712         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 713       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 714         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 715       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 716         base_address = (jlong) CompilerToVM::asKlass(base_object);
 717       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {
 718         base_address = (jlong) (address) base_object;
 719       } else {
 720         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 721                     err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 722       }
 723     }
 724     klass = *((Klass**) (intptr_t) (base_address + offset));
 725   } else {
 726     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 727                 err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 728   }
 729   assert (klass == NULL || klass-&gt;is_klass(), "invalid read");
 730   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 731   return JNIHandles::make_local(THREAD, result);
 732 }
 733 
 734 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 735   ResourceMark rm;
 736   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 737   Klass* holder = CompilerToVM::asKlass(jvmci_type);
 738   if (holder-&gt;is_interface()) {
 739     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", holder-&gt;external_name()));
 740   }
 741 
 742   methodHandle ucm;
 743   {
 744     MutexLocker locker(Compile_lock);
 745     ucm = Dependencies::find_unique_concrete_method(holder, method());
 746   }
 747   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);
 748   return JNIHandles::make_local(THREAD, result);
 749 C2V_END
 750 
 751 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))
<a name="1" id="anc1"></a><span class="changed"> 752   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);</span>
<span class="changed"> 753   oop implementor = CompilerToVM::get_jvmci_type(klass-&gt;implementor(), CHECK_NULL);</span>





 754   return JNIHandles::make_local(THREAD, implementor);
 755 C2V_END
 756 
 757 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))
 758   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 759   return method-&gt;is_ignored_by_security_stack_walk();
 760 C2V_END
 761 
 762 C2V_VMENTRY(jboolean, isCompilable,(JNIEnv *, jobject, jobject jvmci_method))
 763   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 764   // Skip redefined methods
 765   if (method-&gt;is_old()) {
 766     return false;
 767   }
 768   return !method-&gt;is_not_compilable(CompLevel_full_optimization);
 769 C2V_END
 770 
 771 C2V_VMENTRY(jboolean, hasNeverInlineDirective,(JNIEnv *, jobject, jobject jvmci_method))
 772   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 773   return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 774 C2V_END
 775 
 776 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 777   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 778   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 779 C2V_END
 780 
 781 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 782   ResourceMark rm;
 783   Handle name(THREAD, JNIHandles::resolve(jname));
 784   Symbol* class_name = java_lang_String::as_symbol(name(), CHECK_0);
 785   if (java_lang_String::length(name()) &lt;= 1) {
 786     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Primitive type %s should be handled in Java code", class_name-&gt;as_C_string()));
 787   }
 788 
 789   Klass* resolved_klass = NULL;
 790   if (JNIHandles::resolve(accessing_class) == NULL) {
 791     THROW_0(vmSymbols::java_lang_NullPointerException());
 792   }
 793   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));
 794   Handle class_loader(THREAD, accessing_klass-&gt;class_loader());
 795   Handle protection_domain(THREAD, accessing_klass-&gt;protection_domain());
 796 
 797   if (resolve) {
 798     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 799   } else {
 800     if (class_name-&gt;byte_at(0) == 'L' &amp;&amp;
 801       class_name-&gt;byte_at(class_name-&gt;utf8_length()-1) == ';') {
 802       // This is a name from a signature.  Strip off the trimmings.
 803       // Call recursive to keep scope of strippedsym.
 804       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 805                                                           class_name-&gt;utf8_length()-2,
 806                                                           CHECK_0);
 807       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 808     } else if (FieldType::is_array(class_name)) {
 809       FieldArrayInfo fd;
 810       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 811       // of this call
 812       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 813       if (t == T_OBJECT) {
 814         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 815                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 816                                                             CHECK_0);
 817         // naked oop "k" is OK here -- we assign back into it
 818         resolved_klass = SystemDictionary::find(strippedsym,
 819                                                              class_loader,
 820                                                              protection_domain,
 821                                                              CHECK_0);
 822         if (resolved_klass != NULL) {
 823           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 824         }
 825       } else {
 826         resolved_klass = Universe::typeArrayKlassObj(t);
 827         resolved_klass = TypeArrayKlass::cast(resolved_klass)-&gt;array_klass(fd.dimension(), CHECK_0);
 828       }
 829     }
 830   }
 831   oop result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 832   return JNIHandles::make_local(THREAD, result);
 833 C2V_END
 834 
 835 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 836   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 837   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);
 838   return JNIHandles::make_local(THREAD, result);
 839 C2V_END
 840 
 841 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 842   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 843   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 844   return JNIHandles::make_local(THREAD, result);
 845 C2V_END
 846 
 847 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 848   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 849   return cp-&gt;name_and_type_ref_index_at(index);
 850 C2V_END
 851 
 852 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 853   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 854   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);
 855   return JNIHandles::make_local(THREAD, sym());
 856 C2V_END
 857 
 858 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 859   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 860   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);
 861   return JNIHandles::make_local(THREAD, sym());
 862 C2V_END
 863 
 864 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 865   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 866   return cp-&gt;klass_ref_index_at(index);
 867 C2V_END
 868 
 869 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 870   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 871   Klass* resolved_klass = cp-&gt;klass_at(index, CHECK_NULL);
 872   oop klass = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 873   return JNIHandles::make_local(THREAD, klass);
 874 C2V_END
 875 
 876 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 877   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 878   Klass* loading_klass = cp-&gt;pool_holder();
 879   bool is_accessible = false;
 880   Klass* klass = JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass);
 881   Symbol* symbol = NULL;
 882   if (klass == NULL) {
 883     symbol = cp-&gt;klass_name_at(index);
 884   }
 885   oop result_oop;
 886   if (klass != NULL) {
 887     result_oop = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 888   } else {
 889     Handle result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
 890     result_oop = result();
 891   }
 892   return JNIHandles::make_local(THREAD, result_oop);
 893 C2V_END
 894 
 895 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 896   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 897   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 898   return JNIHandles::make_local(THREAD, appendix_oop);
 899 C2V_END
 900 
 901 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 902   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 903   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 904   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 905   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 906   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 907   return JNIHandles::make_local(THREAD, result);
 908 C2V_END
 909 
 910 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 911   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 912   return cp-&gt;remap_instruction_operand_from_cache(index);
 913 C2V_END
 914 
 915 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))
 916   ResourceMark rm;
 917   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 918   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 919   fieldDescriptor fd;
 920   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
 921   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 922   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
 923   if (info == NULL || info-&gt;length() != 3) {
 924     JVMCI_ERROR_NULL("info must not be null and have a length of 3");
 925   }
 926   info-&gt;int_at_put(0, fd.access_flags().as_int());
 927   info-&gt;int_at_put(1, fd.offset());
 928   info-&gt;int_at_put(2, fd.index());
 929   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 930   return JNIHandles::make_local(THREAD, field_holder);
 931 C2V_END
 932 
 933 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 934   ResourceMark rm;
 935   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 936   Method* method = CompilerToVM::asMethod(jvmci_method);
 937   if (klass-&gt;is_interface()) {
 938     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 939   }
 940   if (!method-&gt;method_holder()-&gt;is_interface()) {
 941     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 942   }
 943   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 944     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 945   }
 946   return LinkResolver::vtable_index_of_interface_method(klass, method);
 947 C2V_END
 948 
 949 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 950   Klass* recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);
 951   Klass* caller_klass = CompilerToVM::asKlass(caller_jvmci_type);
 952   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 953 
 954   Klass* resolved     = method-&gt;method_holder();
 955   Symbol* h_name      = method-&gt;name();
 956   Symbol* h_signature = method-&gt;signature();
 957 
 958   if (MethodHandles::is_signature_polymorphic_method(method())) {
 959       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 960       return NULL;
 961   }
 962 
 963   LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
 964   methodHandle m;
 965   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 966   // the vtable has not been setup, and the LinkResolver will fail.
 967   if (recv_klass-&gt;is_array_klass() ||
 968       (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
 969     if (resolved-&gt;is_interface()) {
 970       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 971     } else {
 972       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 973     }
 974   }
 975 
 976   if (m.is_null()) {
 977     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 978     return NULL;
 979   }
 980 
 981   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);
 982   return JNIHandles::make_local(THREAD, result);
 983 C2V_END
 984 
 985 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))
 986   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 987   assert(klass != NULL, "method must not be called for primitive types");
 988   return Dependencies::find_finalizable_subclass(klass) != NULL;
 989 C2V_END
 990 
 991 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))
<a name="2" id="anc2"></a><span class="changed"> 992   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);</span>
<span class="changed"> 993   oop result = CompilerToVM::get_jvmci_method(klass-&gt;class_initializer(), CHECK_NULL);</span>




 994   return JNIHandles::make_local(THREAD, result);
 995 C2V_END
 996 
 997 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))
 998   address target_addr = (address) addr;
 999   if (target_addr != 0x0) {
1000     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
1001     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
1002     return MAX2(ABS(off_low), ABS(off_high));
1003   }
1004   return -1;
1005 C2V_END
1006 
1007 C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv *, jobject,  jobject jvmci_method))
1008   methodHandle method = CompilerToVM::asMethod(jvmci_method);
1009   method-&gt;set_not_c1_compilable();
1010   method-&gt;set_not_c2_compilable();
1011   method-&gt;set_dont_inline(true);
1012 C2V_END
1013 
1014 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))
1015   ResourceMark rm;
1016   HandleMark hm;
1017   JNIHandleMark jni_hm;
1018 
1019   Handle target_handle(THREAD, JNIHandles::resolve(target));
1020   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));
1021   CodeBlob* cb = NULL;
1022   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));
1023   Handle speculation_log_handle(THREAD, JNIHandles::resolve(speculation_log));
1024 
1025   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
1026 
1027   TraceTime install_time("installCode", JVMCICompiler::codeInstallTimer());
1028   bool is_immutable_PIC = HotSpotCompiledCode::isImmutablePIC(compiled_code_handle) &gt; 0;
1029   CodeInstaller installer(is_immutable_PIC);
1030   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);
1031 
1032   if (PrintCodeCacheOnCompilation) {
1033     stringStream s;
1034     // Dump code cache  into a buffer before locking the tty,
1035     {
1036       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1037       CodeCache::print_summary(&amp;s, false);
1038     }
1039     ttyLocker ttyl;
1040     tty-&gt;print_raw_cr(s.as_string());
1041   }
1042 
1043   if (result != JVMCIEnv::ok) {
1044     assert(cb == NULL, "should be");
1045   } else {
1046     if (installed_code_handle.not_null()) {
1047       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), "wrong type");
1048       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);
1049       {
1050         // Ensure that all updates to the InstalledCode fields are consistent.
1051         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
1052         InstalledCode::set_address(installed_code_handle, (jlong) cb);
1053         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);
1054         if (cb-&gt;is_nmethod()) {
1055           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());
1056         } else {
1057           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());
1058         }
1059         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {
1060           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());
1061           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());
1062           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());
1063         }
1064       }
1065     }
1066   }
1067   return result;
1068 C2V_END
1069 
1070 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))
1071   ResourceMark rm;
1072   HandleMark hm;
1073 
1074   Handle target_handle(THREAD, JNIHandles::resolve(target));
1075   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));
1076   Handle metadata_handle(THREAD, JNIHandles::resolve(metadata));
1077 
1078   CodeMetadata code_metadata;
1079   CodeBlob *cb = NULL;
1080   CodeInstaller installer(true /* immutable PIC compilation */);
1081 
1082   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);
1083   if (result != JVMCIEnv::ok) {
1084     return result;
1085   }
1086 
1087   if (code_metadata.get_nr_pc_desc() &gt; 0) {
1088     typeArrayHandle pcArrayOop = oopFactory::new_byteArray_handle(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));
1089     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());
1090     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());
1091   }
1092 
1093   if (code_metadata.get_scopes_size() &gt; 0) {
1094     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray_handle(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));
1095     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());
1096     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());
1097   }
1098 
1099   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
1100   typeArrayHandle relocArrayOop = oopFactory::new_byteArray_handle((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));
1101   if (reloc_buffer-&gt;size() &gt; 0) {
1102     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());
1103   }
1104   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());
1105 
1106   const OopMapSet* oopMapSet = installer.oopMapSet();
1107   {
1108     ResourceMark mark;
1109     ImmutableOopMapBuilder builder(oopMapSet);
1110     int oopmap_size = builder.heap_size();
1111     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray_handle(oopmap_size, CHECK_(JVMCIEnv::cache_full));
1112     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));
1113     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());
1114   }
1115 
1116   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
1117 
1118   int nr_meta_refs = recorder-&gt;nr_meta_refs();
1119   objArrayOop metadataArray = oopFactory::new_objectArray(nr_meta_refs, CHECK_(JVMCIEnv::cache_full));
1120   objArrayHandle metadataArrayHandle(THREAD, metadataArray);
1121   for (int i = 0; i &lt; nr_meta_refs; ++i) {
1122     jobject element = recorder-&gt;meta_element(i);
1123     if (element == NULL) {
1124       return JVMCIEnv::cache_full;
1125     }
1126     metadataArrayHandle-&gt;obj_at_put(i, JNIHandles::resolve(element));
1127   }
1128   HotSpotMetaData::set_metadata(metadata_handle, metadataArrayHandle());
1129 
1130   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
1131   int table_size = handler-&gt;size_in_bytes();
1132   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray_handle(table_size, CHECK_(JVMCIEnv::cache_full));
1133 
1134   if (table_size &gt; 0) {
1135     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));
1136   }
1137   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());
1138 
1139   return result;
1140 C2V_END
1141 
1142 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))
1143   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
1144   CompilerStatistics* stats = compiler-&gt;stats();
1145   stats-&gt;_standard.reset();
1146   stats-&gt;_osr.reset();
1147 C2V_END
1148 
1149 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))
1150   ResourceMark rm;
1151   HandleMark hm;
1152 
1153   if (installedCode == NULL) {
1154     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), "installedCode is null");
1155   }
1156 
1157   jlong codeBlob = InstalledCode::address(installedCode);
1158   if (codeBlob == 0L) {
1159     return NULL;
1160   }
1161 
1162   CodeBlob* cb = (CodeBlob*) (address) codeBlob;
1163   if (cb == NULL) {
1164     return NULL;
1165   }
1166 
1167   // We don't want the stringStream buffer to resize during disassembly as it
1168   // uses scoped resource memory. If a nested function called during disassembly uses
1169   // a ResourceMark and the buffer expands within the scope of the mark,
1170   // the buffer becomes garbage when that scope is exited. Experience shows that
1171   // the disassembled code is typically about 10x the code size so a fixed buffer
1172   // sized to 20x code size plus a fixed amount for header info should be sufficient.
1173   int bufferSize = cb-&gt;code_size() * 20 + 1024;
1174   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
1175   stringStream st(buffer, bufferSize);
1176   if (cb-&gt;is_nmethod()) {
1177     nmethod* nm = (nmethod*) cb;
1178     if (!nm-&gt;is_alive()) {
1179       return NULL;
1180     }
1181   }
1182   Disassembler::decode(cb, &amp;st);
1183   if (st.size() &lt;= 0) {
1184     return NULL;
1185   }
1186 
1187   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);
1188   return JNIHandles::make_local(THREAD, result());
1189 C2V_END
1190 
1191 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))
1192   ResourceMark rm;
1193   HandleMark hm;
1194 
1195   methodHandle method = CompilerToVM::asMethod(jvmci_method);
1196   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);
1197   return JNIHandles::make_local(THREAD, element);
1198 C2V_END
1199 
1200 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))
1201   ResourceMark rm;
1202   HandleMark hm;
1203 
1204   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);
1205   if (nmethodValue == 0L) {
1206     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
1207   }
1208   nmethod* nm = (nmethod*) (address) nmethodValue;
1209   methodHandle mh = nm-&gt;method();
1210   Symbol* signature = mh-&gt;signature();
1211   JavaCallArguments jca(mh-&gt;size_of_parameters());
1212 
1213   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1214   JavaValue result(jap.get_ret_type());
1215   jca.set_alternative_target(nm);
1216   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1217 
1218   if (jap.get_ret_type() == T_VOID) {
1219     return NULL;
1220   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
1221     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
1222   } else {
1223     jvalue *value = (jvalue *) result.get_value_addr();
1224     // Narrow the value down if required (Important on big endian machines)
1225     switch (jap.get_ret_type()) {
1226       case T_BOOLEAN:
1227        value-&gt;z = (jboolean) value-&gt;i;
1228        break;
1229       case T_BYTE:
1230        value-&gt;b = (jbyte) value-&gt;i;
1231        break;
1232       case T_CHAR:
1233        value-&gt;c = (jchar) value-&gt;i;
1234        break;
1235       case T_SHORT:
1236        value-&gt;s = (jshort) value-&gt;i;
1237        break;
1238       default:
1239         break;
1240     }
1241     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);
1242     return JNIHandles::make_local(THREAD, o);
1243   }
1244 C2V_END
1245 
1246 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))
1247   Method* method = CompilerToVM::asMethod(jvmci_method);
1248   if (!method-&gt;has_linenumber_table()) {
1249     return NULL;
1250   }
1251   u2 num_entries = 0;
1252   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1253   while (streamForSize.read_pair()) {
1254     num_entries++;
1255   }
1256 
1257   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1258   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);
1259 
1260   int i = 0;
1261   jlong value;
1262   while (stream.read_pair()) {
1263     value = ((long) stream.bci());
1264     result-&gt;long_at_put(i, value);
1265     value = ((long) stream.line());
1266     result-&gt;long_at_put(i + 1, value);
1267     i += 2;
1268   }
1269 
1270   return (jlongArray) JNIHandles::make_local(THREAD, result);
1271 C2V_END
1272 
1273 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))
1274   ResourceMark rm;
1275   Method* method = CompilerToVM::asMethod(jvmci_method);
1276   if (!method-&gt;has_localvariable_table()) {
1277     return 0;
1278   }
1279   return (jlong) (address) method-&gt;localvariable_table_start();
1280 C2V_END
1281 
1282 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))
1283   ResourceMark rm;
1284   Method* method = CompilerToVM::asMethod(jvmci_method);
1285   return method-&gt;localvariable_table_length();
1286 C2V_END
1287 
1288 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))
1289   Method* method = CompilerToVM::asMethod(jvmci_method);
1290   MethodCounters* mcs = method-&gt;method_counters();
1291   if (mcs != NULL) {
1292     mcs-&gt;clear_counters();
1293   }
1294   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1295 
1296   CompiledMethod* code = method-&gt;code();
1297   if (code != NULL) {
1298     code-&gt;make_not_entrant();
1299   }
1300 
1301   MethodData* method_data = method-&gt;method_data();
1302   if (method_data == NULL) {
1303     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1304     method_data = MethodData::allocate(loader_data, method, CHECK);
1305     method-&gt;set_method_data(method_data);
1306   } else {
1307     method_data-&gt;initialize();
1308   }
1309 C2V_END
1310 
1311 
1312 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))
1313   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));
1314   nmethod::invalidate_installed_code(installed_code_handle, CHECK);
1315 C2V_END
1316 
1317 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))
1318   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);
1319   JavaThread::collect_counters(arrayOop);
1320   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);
1321 C2V_END
1322 
1323 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))
1324   HandleMark hm;
1325   ResourceMark rm;
1326   if (JNIHandles::resolve(jvmci_method) == NULL) {
1327     THROW_0(vmSymbols::java_lang_NullPointerException());
1328   }
1329   Method* method = CompilerToVM::asMethod(jvmci_method);
1330   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1331     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Unexpected bci %d", entry_bci));
1332   }
1333   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1334 C2V_END
1335 
1336 
1337 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))
1338   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1339   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1340 C2V_END
1341 
1342 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1343   Method* method = CompilerToVM::asMethod(jvmci_method);
1344   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1345 C2V_END
1346 
1347 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))
1348   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);
1349   return JNIHandles::make_local(THREAD, sym());
1350 C2V_END
1351 
1352 bool matches(jobjectArray methods, Method* method) {
1353   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1354 
1355   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1356     oop resolved = methods_oop-&gt;obj_at(i);
1357     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {
1358       return true;
1359     }
1360   }
1361   return false;
1362 }
1363 
1364 C2V_VMENTRY(jobject, getNextStackFrame, (JNIEnv*, jobject compilerToVM, jobject hs_frame, jobjectArray methods, jint initialSkip))
1365   ResourceMark rm;
1366 
1367   if (!thread-&gt;has_last_Java_frame()) return NULL;
1368   Handle result = HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1369   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1370 
1371   StackFrameStream fst(thread);
1372   if (hs_frame != NULL) {
1373     // look for the correct stack frame if one is given
1374     intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1375     while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1376       fst.next();
1377     }
1378     if (fst.current()-&gt;sp() != stack_pointer) {
1379       THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1380     }
1381   }
1382 
1383   int frame_number = 0;
1384   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1385   if (hs_frame != NULL) {
1386     // look for the correct vframe within the stack frame if one is given
1387     int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1388     while (frame_number &lt; last_frame_number) {
1389       if (vf-&gt;is_top()) {
1390         THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1391       }
1392       vf = vf-&gt;sender();
1393       frame_number ++;
1394     }
1395     // move one frame forward
1396     if (vf-&gt;is_top()) {
1397       if (fst.is_done()) {
1398         return NULL;
1399       }
1400       fst.next();
1401       vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1402       frame_number = 0;
1403     } else {
1404       vf = vf-&gt;sender();
1405       frame_number++;
1406     }
1407   }
1408 
1409   while (true) {
1410     // look for the given method
1411     while (true) {
1412       StackValueCollection* locals = NULL;
1413       if (vf-&gt;is_compiled_frame()) {
1414         // compiled method frame
1415         compiledVFrame* cvf = compiledVFrame::cast(vf);
1416         if (methods == NULL || matches(methods, cvf-&gt;method())) {
1417           if (initialSkip &gt; 0) {
1418             initialSkip --;
1419           } else {
1420             ScopeDesc* scope = cvf-&gt;scope();
1421             // native wrappers do not have a scope
1422             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1423               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), scope-&gt;objects(), CHECK_NULL);
1424               Deoptimization::reassign_fields(fst.current(), fst.register_map(), scope-&gt;objects(), realloc_failures, false);
1425 
1426               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1427               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1428               typeArrayHandle array(THREAD, array_oop);
1429               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1430                 ScopeValue* value = local_values-&gt;at(i);
1431                 if (value-&gt;is_object()) {
1432                   array-&gt;bool_at_put(i, true);
1433                 }
1434               }
1435               HotSpotStackFrameReference::set_localIsVirtual(result, array());
1436             } else {
1437               HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1438             }
1439 
1440             locals = cvf-&gt;locals();
1441             HotSpotStackFrameReference::set_bci(result, cvf-&gt;bci());
1442             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);
1443             HotSpotStackFrameReference::set_method(result, method);
1444           }
1445         }
1446       } else if (vf-&gt;is_interpreted_frame()) {
1447         // interpreted method frame
1448         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1449         if (methods == NULL || matches(methods, ivf-&gt;method())) {
1450           if (initialSkip &gt; 0) {
1451             initialSkip --;
1452           } else {
1453             locals = ivf-&gt;locals();
1454             HotSpotStackFrameReference::set_bci(result, ivf-&gt;bci());
1455             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);
1456             HotSpotStackFrameReference::set_method(result, method);
1457             HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1458           }
1459         }
1460       }
1461 
1462       // locals != NULL means that we found a matching frame and result is already partially initialized
1463       if (locals != NULL) {
1464         HotSpotStackFrameReference::set_compilerToVM(result, JNIHandles::resolve(compilerToVM));
1465         HotSpotStackFrameReference::set_stackPointer(result, (jlong) fst.current()-&gt;sp());
1466         HotSpotStackFrameReference::set_frameNumber(result, frame_number);
1467 
1468         // initialize the locals array
1469         objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
1470         objArrayHandle array(THREAD, array_oop);
1471         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1472           StackValue* var = locals-&gt;at(i);
1473           if (var-&gt;type() == T_OBJECT) {
1474             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1475           }
1476         }
1477         HotSpotStackFrameReference::set_locals(result, array());
1478 
1479         return JNIHandles::make_local(thread, result());
1480       }
1481 
1482       if (vf-&gt;is_top()) {
1483         break;
1484       }
1485       frame_number++;
1486       vf = vf-&gt;sender();
1487     } // end of vframe loop
1488 
1489     if (fst.is_done()) {
1490       break;
1491     }
1492     fst.next();
1493     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1494     frame_number = 0;
1495   } // end of frame loop
1496 
1497   // the end was reached without finding a matching method
1498   return NULL;
1499 C2V_END
1500 
1501 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1502   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1503   CallInfo callInfo;
1504   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1505   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1506   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1507 C2V_END
1508 
1509 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1510   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1511   Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
1512   Symbol* name = cp-&gt;name_ref_at(index);
1513   if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
1514     CallInfo callInfo;
1515     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1516     ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1517     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1518   }
1519 C2V_END
1520 
1521 C2V_VMENTRY(jint, isResolvedInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1522   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1523   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1524   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
1525     // MethodHandle.invoke* --&gt; LambdaForm?
1526     ResourceMark rm;
1527 
1528     LinkInfo link_info(cp, index, CATCH);
1529 
1530     Klass* resolved_klass = link_info.resolved_klass();
1531 
1532     Symbol* name_sym = cp-&gt;name_ref_at(index);
1533 
1534     vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), "!");
1535     vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), "!");
1536 
1537     methodHandle adapter_method(cp_cache_entry-&gt;f1_as_method());
1538 
1539     methodHandle resolved_method(adapter_method);
1540 
1541     // Can we treat it as a regular invokevirtual?
1542     if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
1543       vmassert(!resolved_method-&gt;is_static(),"!");
1544       vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),"!");
1545       vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), "!");
1546       vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, "!");
1547       vmassert(cp_cache_entry-&gt;method_type_if_resolved(cp) == NULL, "!");
1548 
1549       methodHandle m(LinkResolver::linktime_resolve_virtual_method_or_null(link_info));
1550       vmassert(m == resolved_method, "!!");
1551       return -1;
1552     }
1553 
1554     return Bytecodes::_invokevirtual;
1555   }
1556   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokedynamic)) {
1557     return Bytecodes::_invokedynamic;
1558   }
1559   return -1;
1560 C2V_END
1561 
1562 
1563 C2V_VMENTRY(jobject, getSignaturePolymorphicHolders, (JNIEnv*, jobject))
1564   objArrayHandle holders = oopFactory::new_objArray_handle(SystemDictionary::String_klass(), 2, CHECK_NULL);
1565   Handle mh = java_lang_String::create_from_str("Ljava/lang/invoke/MethodHandle;", CHECK_NULL);
1566   Handle vh = java_lang_String::create_from_str("Ljava/lang/invoke/VarHandle;", CHECK_NULL);
1567   holders-&gt;obj_at_put(0, mh());
1568   holders-&gt;obj_at_put(1, vh());
1569   return JNIHandles::make_local(THREAD, holders());
1570 C2V_END
1571 
1572 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))
1573   //see compute_recording_non_safepoints in debugInfroRec.cpp
1574   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1575     return true;
1576   }
1577   return DebugNonSafepoints;
1578 C2V_END
1579 
1580 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1581 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))
1582   ResourceMark rm;
1583 
1584   if (hs_frame == NULL) {
1585     THROW_MSG(vmSymbols::java_lang_NullPointerException(), "stack frame is null")
1586   }
1587 
1588   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK);
1589 
1590   // look for the given stack frame
1591   StackFrameStream fst(thread);
1592   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1593   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1594     fst.next();
1595   }
1596   if (fst.current()-&gt;sp() != stack_pointer) {
1597     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1598   }
1599 
1600   if (invalidate) {
1601     if (!fst.current()-&gt;is_compiled_frame()) {
1602       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1603     }
1604     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), "nmethod expected");
1605     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1606   }
1607   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1608   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1609   StackFrameStream fstAfterDeopt(thread);
1610   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1611     fstAfterDeopt.next();
1612   }
1613   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1614     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found after deopt")
1615   }
1616 
1617   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1618   if (!vf-&gt;is_compiled_frame()) {
1619     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1620   }
1621 
1622   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1623   while (true) {
1624     assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1625     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1626     if (vf-&gt;is_top()) {
1627       break;
1628     }
1629     vf = vf-&gt;sender();
1630   }
1631 
1632   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1633   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1634     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1635   }
1636 
1637   // Reallocate the non-escaping objects and restore their fields.
1638   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,"invalid scope");
1639   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1640 
1641   if (objects == NULL) {
1642     // no objects to materialize
1643     return;
1644   }
1645 
1646   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, CHECK);
1647   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1648 
1649   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1650     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1651 
1652     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1653     StackValueCollection* locals = cvf-&gt;locals();
1654 
1655     if (locals != NULL) {
1656       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1657         StackValue* var = locals-&gt;at(i2);
1658         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1659           jvalue val;
1660           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1661           cvf-&gt;update_local(T_OBJECT, i2, val);
1662         }
1663       }
1664     }
1665   }
1666 
1667   // all locals are materialized by now
1668   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);
1669 
1670   // update the locals array
1671   objArrayHandle array(THREAD, HotSpotStackFrameReference::locals(hs_frame));
1672   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1673   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1674     StackValue* var = locals-&gt;at(i);
1675     if (var-&gt;type() == T_OBJECT) {
1676       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1677     }
1678   }
1679 C2V_END
1680 
1681 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))
1682   if (bytes == NULL) {
1683     THROW(vmSymbols::java_lang_NullPointerException());
1684   }
1685   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);
1686 
1687   // Check if offset and length are non negative.
1688   if (offset &lt; 0 || length &lt; 0) {
1689     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1690   }
1691   // Check if the range is valid.
1692   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {
1693     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1694   }
1695   while (length &gt; 0) {
1696     jbyte* start = array-&gt;byte_at_addr(offset);
1697     tty-&gt;write((char*) start, MIN2(length, (jint)O_BUFLEN));
1698     length -= O_BUFLEN;
1699     offset += O_BUFLEN;
1700   }
1701 C2V_END
1702 
1703 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))
1704   tty-&gt;flush();
1705 C2V_END
1706 
1707 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))
1708   ResourceMark rm;
1709   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1710   ProfileData* profile_data = mdo-&gt;data_at(position);
1711   if (mdo-&gt;is_valid(profile_data)) {
1712     return profile_data-&gt;size_in_bytes();
1713   }
1714   DataLayout* data    = mdo-&gt;extra_data_base();
1715   DataLayout* end   = mdo-&gt;extra_data_limit();
1716   for (;; data = mdo-&gt;next_extra(data)) {
1717     assert(data &lt; end, "moved past end of extra data");
1718     profile_data = data-&gt;data_in();
1719     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1720       return profile_data-&gt;size_in_bytes();
1721     }
1722   }
1723   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Invalid profile data position %d", position));
1724 C2V_END
1725 
1726 C2V_VMENTRY(jlong, getFingerprint, (JNIEnv*, jobject, jlong metaspace_klass))
1727   Klass *k = CompilerToVM::asKlass(metaspace_klass);
1728   if (k-&gt;is_instance_klass()) {
1729     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1730   } else {
1731     return 0;
1732   }
1733 C2V_END
1734 
1735 C2V_VMENTRY(jobject, getHostClass, (JNIEnv*, jobject, jobject jvmci_type))
1736   InstanceKlass* k = InstanceKlass::cast(CompilerToVM::asKlass(jvmci_type));
1737   InstanceKlass* host = k-&gt;host_klass();
1738   oop result = CompilerToVM::get_jvmci_type(host, CHECK_NULL);
1739   return JNIHandles::make_local(THREAD, result);
1740 C2V_END
1741 
1742 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))
1743   if (bytecode_frame_handle == NULL) {
1744     THROW_0(vmSymbols::java_lang_NullPointerException());
1745   }
1746 
1747   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);
1748   oop bytecode_frame = top_bytecode_frame;
1749   int size = 0;
1750   int callee_parameters = 0;
1751   int callee_locals = 0;
1752   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1753   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);
1754 
1755   while (bytecode_frame != NULL) {
1756     int locks = BytecodeFrame::numLocks(bytecode_frame);
1757     int temps = BytecodeFrame::numStack(bytecode_frame);
1758     bool is_top_frame = (bytecode_frame == top_bytecode_frame);
1759     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1760 
1761     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1762                                                                  temps + callee_parameters,
1763                                                                  extra_args,
1764                                                                  locks,
1765                                                                  callee_parameters,
1766                                                                  callee_locals,
1767                                                                  is_top_frame);
1768     size += frame_size;
1769 
1770     callee_parameters = method-&gt;size_of_parameters();
1771     callee_locals = method-&gt;max_locals();
1772     extra_args = 0;
1773     bytecode_frame = BytecodePosition::caller(bytecode_frame);
1774   }
1775   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1776 C2V_END
1777 
1778 C2V_VMENTRY(void, compileToBytecode, (JNIEnv*, jobject, jobject lambda_form_handle))
1779   Handle lambda_form(THREAD, JNIHandles::resolve_non_null(lambda_form_handle));
1780   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1781     TempNewSymbol compileToBytecode = SymbolTable::new_symbol("compileToBytecode", CHECK);
1782     JavaValue result(T_VOID);
1783     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1784   } else {
1785     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1786                 err_msg("Unexpected type: %s", lambda_form-&gt;klass()-&gt;external_name()));
1787   }
1788 C2V_END
1789 
1790 #define CC (char*)  /*cast a literal from (const char*)*/
1791 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1792 
1793 #define STRING                "Ljava/lang/String;"
1794 #define OBJECT                "Ljava/lang/Object;"
1795 #define CLASS                 "Ljava/lang/Class;"
1796 #define EXECUTABLE            "Ljava/lang/reflect/Executable;"
1797 #define STACK_TRACE_ELEMENT   "Ljava/lang/StackTraceElement;"
1798 #define INSTALLED_CODE        "Ljdk/vm/ci/code/InstalledCode;"
1799 #define TARGET_DESCRIPTION    "Ljdk/vm/ci/code/TargetDescription;"
1800 #define BYTECODE_FRAME        "Ljdk/vm/ci/code/BytecodeFrame;"
1801 #define RESOLVED_METHOD       "Ljdk/vm/ci/meta/ResolvedJavaMethod;"
1802 #define HS_RESOLVED_METHOD    "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;"
1803 #define HS_RESOLVED_KLASS     "Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;"
1804 #define HS_CONSTANT_POOL      "Ljdk/vm/ci/hotspot/HotSpotConstantPool;"
1805 #define HS_COMPILED_CODE      "Ljdk/vm/ci/hotspot/HotSpotCompiledCode;"
1806 #define HS_CONFIG             "Ljdk/vm/ci/hotspot/HotSpotVMConfig;"
1807 #define HS_METADATA           "Ljdk/vm/ci/hotspot/HotSpotMetaData;"
1808 #define HS_STACK_FRAME_REF    "Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;"
1809 #define HS_SPECULATION_LOG    "Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;"
1810 #define METASPACE_METHOD_DATA "J"
1811 
1812 JNINativeMethod CompilerToVM::methods[] = {
1813   {CC "getBytecode",                                  CC "(" HS_RESOLVED_METHOD ")[B",                                                      FN_PTR(getBytecode)},
1814   {CC "getExceptionTableStart",                       CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getExceptionTableStart)},
1815   {CC "getExceptionTableLength",                      CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getExceptionTableLength)},
1816   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1817   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1818   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1819   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1820   {CC "setNotInlinableOrCompilable",                  CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(setNotInlinableOrCompilable)},
1821   {CC "isCompilable",                                 CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(isCompilable)},
1822   {CC "hasNeverInlineDirective",                      CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(hasNeverInlineDirective)},
1823   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1824   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1825   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1826   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1827   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1828   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1829   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1830   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1831   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1832   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1833   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1834   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1835   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
1836   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[I)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
1837   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1838   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1839   {CC "isResolvedInvokeHandleInPool",                 CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(isResolvedInvokeHandleInPool)},
1840   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1841   {CC "getSignaturePolymorphicHolders",               CC "()[" STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
1842   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1843   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1844   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1845   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1846   {CC "asResolvedJavaMethod",                         CC "(" EXECUTABLE ")" HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
1847   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1848   {CC "getConstantPool",                              CC "(Ljava/lang/Object;)" HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},
1849   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1850   {CC "readConfiguration",                            CC "()[" OBJECT,                                                                      FN_PTR(readConfiguration)},
1851   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1852   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1853   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1854   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1855   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1856   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1857   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1858   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1859   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1860   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1861   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1862   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1863   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1864   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1865   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1866   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1867   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1868   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1869   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1870   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1871   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1872   {CC "getFingerprint",                               CC "(J)J",                                                                            FN_PTR(getFingerprint)},
1873   {CC "getHostClass",                                 CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
1874   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1875   {CC "compileToBytecode",                            CC "(" OBJECT ")V",                                                                   FN_PTR(compileToBytecode)},
1876   {CC "getFlagValue",                                 CC "(" STRING ")" OBJECT,                                                             FN_PTR(getFlagValue)},
1877 };
1878 
1879 int CompilerToVM::methods_count() {
1880   return sizeof(methods) / sizeof(JNINativeMethod);
1881 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="3" type="hidden" /></form></body></html>
