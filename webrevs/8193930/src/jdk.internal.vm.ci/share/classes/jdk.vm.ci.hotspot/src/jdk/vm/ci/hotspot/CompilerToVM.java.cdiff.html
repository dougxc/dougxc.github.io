<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>open Cdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java</title>
</head>
<body id="SUNWwebrev">
<center><a href='../../../../../../../../../../src/hotspot/share/jvmci/jvmciCompilerToVM.cpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre></pre>
        <pre>
<hr /><span class="oldmarker">*** 133,144 ****</span>
      native HotSpotResolvedJavaMethodImpl findUniqueConcreteMethod(HotSpotResolvedObjectTypeImpl actualHolderType, HotSpotResolvedJavaMethodImpl method);
  
      /**
       * Gets the implementor for the interface class {@code type}.
       *
<span class="changed">!      * @return the implementor if there is a single implementor, 0 if there is no implementor, or</span>
<span class="changed">!      *         {@code type} itself if there is more than one implementor</span>
       */
      native HotSpotResolvedObjectTypeImpl getImplementor(HotSpotResolvedObjectTypeImpl type);
  
      /**
       * Determines if {@code method} is ignored by security stack walks.
<span class="newmarker">--- 133,145 ----</span>
      native HotSpotResolvedJavaMethodImpl findUniqueConcreteMethod(HotSpotResolvedObjectTypeImpl actualHolderType, HotSpotResolvedJavaMethodImpl method);
  
      /**
       * Gets the implementor for the interface class {@code type}.
       *
<span class="changed">!      * @return the implementor if there is a single implementor, {@code null} if there is no</span>
<span class="changed">!      *         implementor, or {@code type} itself if there is more than one implementor</span>
<span class="changed">!      * @throws IllegalArgumentException if type is not an interface type</span>
       */
      native HotSpotResolvedObjectTypeImpl getImplementor(HotSpotResolvedObjectTypeImpl type);
  
      /**
       * Determines if {@code method} is ignored by security stack walks.
<hr /><span class="oldmarker">*** 254,271 ****</span>
       * does nothing.
       */
      native void resolveInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi);
  
      /**
<span class="changed">!      * If {@code cpi} denotes an entry representing a resolved dynamic adapter</span>
<span class="changed">!      * (see {@code resolveInvokeDynamicInPool} and {@code resolveInvokeHandleInPool}),</span>
<span class="changed">!      * return the opcode of the instruction for which the resolution was performed</span>
<span class="changed">!      * ({@code invokedynamic} or {@code invokevirtual}}, or {@code -1} otherwise.</span>
       */
      native int isResolvedInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi);
  
<span class="removed">- </span>
      /**
       * Gets the list of type names (in the format of {@link JavaType#getName()}) denoting the
       * classes that define signature polymorphic methods.
       */
      native String[] getSignaturePolymorphicHolders();
<span class="newmarker">--- 255,271 ----</span>
       * does nothing.
       */
      native void resolveInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi);
  
      /**
<span class="changed">!      * If {@code cpi} denotes an entry representing a resolved dynamic adapter (see</span>
<span class="changed">!      * {@code resolveInvokeDynamicInPool} and {@code resolveInvokeHandleInPool}), return the opcode</span>
<span class="changed">!      * of the instruction for which the resolution was performed ({@code invokedynamic} or</span>
<span class="changed">!      * {@code invokevirtual}}, or {@code -1} otherwise.</span>
       */
      native int isResolvedInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi);
  
      /**
       * Gets the list of type names (in the format of {@link JavaType#getName()}) denoting the
       * classes that define signature polymorphic methods.
       */
      native String[] getSignaturePolymorphicHolders();
<hr /><span class="oldmarker">*** 386,396 ****</span>
      native HotSpotResolvedJavaMethodImpl resolveMethod(HotSpotResolvedObjectTypeImpl exactReceiver, HotSpotResolvedJavaMethodImpl method, HotSpotResolvedObjectTypeImpl caller);
  
      /**
       * Gets the static initializer of {@code type}.
       *
<span class="changed">!      * @return 0 if {@code type} has no static initializer</span>
       */
      native HotSpotResolvedJavaMethodImpl getClassInitializer(HotSpotResolvedObjectTypeImpl type);
  
      /**
       * Determines if {@code type} or any of its currently loaded subclasses overrides
<span class="newmarker">--- 386,396 ----</span>
      native HotSpotResolvedJavaMethodImpl resolveMethod(HotSpotResolvedObjectTypeImpl exactReceiver, HotSpotResolvedJavaMethodImpl method, HotSpotResolvedObjectTypeImpl caller);
  
      /**
       * Gets the static initializer of {@code type}.
       *
<span class="changed">!      * @return {@code null} if {@code type} has no static initializer</span>
       */
      native HotSpotResolvedJavaMethodImpl getClassInitializer(HotSpotResolvedObjectTypeImpl type);
  
      /**
       * Determines if {@code type} or any of its currently loaded subclasses overrides
<hr /><span class="oldmarker">*** 466,476 ****</span>
       * @return 0 if {@code method} does not have a local variable table
       */
      native long getLocalVariableTableStart(HotSpotResolvedJavaMethodImpl method);
  
      /**
<span class="changed">!      * Sets flags on {@code method} indicating that it should never be inlined or compiled by the VM.</span>
       */
      native void setNotInlinableOrCompilable(HotSpotResolvedJavaMethodImpl method);
  
      /**
       * Invalidates the profiling information for {@code method} and (re)initializes it such that
<span class="newmarker">--- 466,477 ----</span>
       * @return 0 if {@code method} does not have a local variable table
       */
      native long getLocalVariableTableStart(HotSpotResolvedJavaMethodImpl method);
  
      /**
<span class="changed">!      * Sets flags on {@code method} indicating that it should never be inlined or compiled by the</span>
<span class="changed">!      * VM.</span>
       */
      native void setNotInlinableOrCompilable(HotSpotResolvedJavaMethodImpl method);
  
      /**
       * Invalidates the profiling information for {@code method} and (re)initializes it such that
</pre>
<center><a href='../../../../../../../../../../src/hotspot/share/jvmci/jvmciCompilerToVM.cpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

