<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestResolvedJavaType.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /**
  25  * @test
  26  * @requires vm.jvmci
  27  * @library ../../../../../
  28  * @modules java.base/jdk.internal.reflect
  29  *          jdk.internal.vm.ci/jdk.vm.ci.meta
  30  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
  31  *          jdk.internal.vm.ci/jdk.vm.ci.common
  32  *          java.base/jdk.internal.misc
  33  * @run junit/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -Djvmci.Compiler=null jdk.vm.ci.runtime.test.TestResolvedJavaType
  34  */
  35 
  36 package jdk.vm.ci.runtime.test;
  37 
  38 import static java.lang.reflect.Modifier.isAbstract;
  39 import static java.lang.reflect.Modifier.isFinal;
  40 import static java.lang.reflect.Modifier.isPrivate;
  41 import static java.lang.reflect.Modifier.isProtected;
  42 import static java.lang.reflect.Modifier.isPublic;
  43 import static java.lang.reflect.Modifier.isStatic;
  44 import static org.junit.Assert.assertArrayEquals;
  45 import static org.junit.Assert.assertEquals;
  46 import static org.junit.Assert.assertFalse;
  47 import static org.junit.Assert.assertNotNull;
  48 import static org.junit.Assert.assertNull;
  49 import static org.junit.Assert.assertTrue;
  50 
  51 import java.lang.annotation.Annotation;
  52 import java.lang.reflect.Field;
  53 import java.lang.reflect.Method;
  54 import java.lang.reflect.Modifier;
  55 import java.util.Arrays;
  56 import java.util.Collections;
  57 import java.util.function.Supplier;
  58 import java.util.HashMap;
  59 import java.util.HashSet;
  60 import java.util.Map;
  61 import java.util.Set;
  62 
  63 import org.junit.Test;
  64 
  65 import jdk.internal.reflect.ConstantPool;
  66 import jdk.vm.ci.common.JVMCIError;
  67 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  68 import jdk.vm.ci.meta.JavaConstant;
  69 import jdk.vm.ci.meta.JavaKind;
  70 import jdk.vm.ci.meta.ResolvedJavaField;
  71 import jdk.vm.ci.meta.ResolvedJavaMethod;
  72 import jdk.vm.ci.meta.ResolvedJavaType;
  73 
  74 /**
  75  * Tests for {@link ResolvedJavaType}.
  76  */
  77 @SuppressWarnings("unchecked")
  78 public class TestResolvedJavaType extends TypeUniverse {
  79     private static final Class&lt;? extends Annotation&gt; SIGNATURE_POLYMORPHIC_CLASS = findPolymorphicSignatureClass();
  80 
  81     public TestResolvedJavaType() {
  82     }
  83 
  84     private static Class&lt;? extends Annotation&gt; findPolymorphicSignatureClass() {
  85         Class&lt;? extends Annotation&gt; signaturePolyAnnotation = null;
  86         try {
  87             for (Class&lt;?&gt; clazz : TestResolvedJavaType.class.getClassLoader().loadClass("java.lang.invoke.MethodHandle").getDeclaredClasses()) {
  88                 if (clazz.getName().endsWith("PolymorphicSignature") &amp;&amp; Annotation.class.isAssignableFrom(clazz)) {
  89                     signaturePolyAnnotation = (Class&lt;? extends Annotation&gt;) clazz;
  90                     break;
  91                 }
  92             }
  93         } catch (Throwable e) {
  94             throw new AssertionError("Could not find annotation PolymorphicSignature in java.lang.invoke.MethodHandle", e);
  95         }
  96         assertNotNull(signaturePolyAnnotation);
  97         return signaturePolyAnnotation;
  98     }
  99 
 100     @Test
 101     public void findInstanceFieldWithOffsetTest() {
 102         for (Class&lt;?&gt; c : classes) {
 103             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 104             Set&lt;Field&gt; reflectionFields = getInstanceFields(c, true);
 105             for (Field f : reflectionFields) {
 106                 ResolvedJavaField rf = lookupField(type.getInstanceFields(true), f);
 107                 assertNotNull(rf);
 108                 long offset = isStatic(f.getModifiers()) ? unsafe.staticFieldOffset(f) : unsafe.objectFieldOffset(f);
 109                 ResolvedJavaField result = type.findInstanceFieldWithOffset(offset, rf.getJavaKind());
 110                 assertNotNull(result);
 111                 assertTrue(fieldsEqual(f, result));
 112             }
 113         }
 114     }
 115 
 116     @Test
 117     public void isInterfaceTest() {
 118         for (Class&lt;?&gt; c : classes) {
 119             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 120             boolean expected = c.isInterface();
 121             boolean actual = type.isInterface();
 122             assertEquals(expected, actual);
 123         }
 124     }
 125 
 126     @Test
 127     public void isInstanceClassTest() {
 128         for (Class&lt;?&gt; c : classes) {
 129             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 130             boolean expected = !c.isArray() &amp;&amp; !c.isPrimitive() &amp;&amp; !c.isInterface();
 131             boolean actual = type.isInstanceClass();
 132             assertEquals(expected, actual);
 133         }
 134     }
 135 
 136     @Test
 137     public void isArrayTest() {
 138         for (Class&lt;?&gt; c : classes) {
 139             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 140             boolean expected = c.isArray();
 141             boolean actual = type.isArray();
 142             assertEquals(expected, actual);
 143         }
 144     }
 145 
 146     @Test
 147     public void getHostClassTest() {
 148         for (Class&lt;?&gt; c : classes) {
 149             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 150             ResolvedJavaType host = type.getHostClass();
 151             assertNull(host);
 152         }
 153 
 154         class LocalClass {}
 155         Cloneable clone = new Cloneable() {};
 156         assertNull(metaAccess.lookupJavaType(LocalClass.class).getHostClass());
 157         assertNull(metaAccess.lookupJavaType(clone.getClass()).getHostClass());
 158 
 159         Supplier&lt;Runnable&gt; lambda = () -&gt; () -&gt; System.out.println("run");
 160         ResolvedJavaType lambdaType = metaAccess.lookupJavaType(lambda.getClass());
 161         ResolvedJavaType nestedLambdaType = metaAccess.lookupJavaType(lambda.get().getClass());
 162         assertNotNull(lambdaType.getHostClass());
 163         assertNotNull(nestedLambdaType.getHostClass());
 164         assertEquals(lambdaType.getHostClass(), nestedLambdaType.getHostClass());
 165     }
 166 
 167     @Test
 168     public void getModifiersTest() {
 169         for (Class&lt;?&gt; c : classes) {
 170             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 171             int mask = Modifier.classModifiers() &amp; ~Modifier.STATIC;
 172             int expected = c.getModifiers() &amp; mask;
 173             int actual = type.getModifiers() &amp; mask;
 174             Class&lt;?&gt; elementalType = c;
 175             while (elementalType.isArray()) {
 176                 elementalType = elementalType.getComponentType();
 177             }
 178             if (elementalType.isMemberClass()) {
 179                 // member class get their modifiers from the inner-class attribute in the JVM and
 180                 // from the classfile header in jvmci
 181                 expected &amp;= ~(Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED);
 182                 actual &amp;= ~(Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED);
 183             }
 184             assertEquals(String.format("%s: 0x%x != 0x%x", type, expected, actual), expected, actual);
 185         }
 186     }
 187 
 188     @Test
 189     public void isAssignableFromTest() {
 190         Class&lt;?&gt;[] all = classes.toArray(new Class&lt;?&gt;[classes.size()]);
 191         for (int i = 0; i &lt; all.length; i++) {
 192             Class&lt;?&gt; c1 = all[i];
 193             for (int j = i; j &lt; all.length; j++) {
 194                 Class&lt;?&gt; c2 = all[j];
 195                 ResolvedJavaType t1 = metaAccess.lookupJavaType(c1);
 196                 ResolvedJavaType t2 = metaAccess.lookupJavaType(c2);
 197                 boolean expected = c1.isAssignableFrom(c2);
 198                 boolean actual = t1.isAssignableFrom(t2);
 199                 assertEquals(expected, actual);
 200                 if (expected &amp;&amp; t1 != t2) {
 201                     assertFalse(t2.isAssignableFrom(t1));
 202                 }
 203             }
 204         }
 205     }
 206 
 207     @Test
 208     public void isInstanceTest() {
 209         for (ConstantValue cv : constants()) {
 210             JavaConstant c = cv.value;
 211             if (c.getJavaKind() == JavaKind.Object &amp;&amp; !c.isNull()) {
 212                 ResolvedJavaType cType = metaAccess.lookupJavaType(c);
 213                 for (ResolvedJavaType t : javaTypes) {
 214                     if (t.isAssignableFrom(cType)) {
 215                         assertTrue(t.isInstance(c));
 216                     } else {
 217                         assertFalse(t.isInstance(c));
 218                     }
 219                 }
 220             }
 221         }
 222     }
 223 
 224     @Test
 225     public void getSuperclassTest() {
 226         for (Class&lt;?&gt; c : classes) {
 227             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 228             Class&lt;?&gt; expected = c.getSuperclass();
 229             ResolvedJavaType actual = type.getSuperclass();
 230             if (expected == null) {
 231                 assertTrue(actual == null);
 232             } else {
 233                 assertNotNull(actual);
 234                 assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 235             }
 236         }
 237     }
 238 
 239     @Test
 240     public void getInterfacesTest() {
 241         for (Class&lt;?&gt; c : classes) {
 242             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 243             Class&lt;?&gt;[] expected = c.getInterfaces();
 244             ResolvedJavaType[] actual = type.getInterfaces();
 245             assertEquals(expected.length, actual.length);
 246             for (int i = 0; i &lt; expected.length; i++) {
 247                 assertTrue(actual[i].equals(metaAccess.lookupJavaType(expected[i])));
 248             }
 249         }
 250     }
 251 
 252     public Class&lt;?&gt; getSupertype(Class&lt;?&gt; c) {
 253         assert !c.isPrimitive();
 254         if (c.isArray()) {
 255             Class&lt;?&gt; componentType = c.getComponentType();
 256             if (componentType.isPrimitive() || componentType == Object.class) {
 257                 return Object.class;
 258             }
 259             return getArrayClass(getSupertype(componentType));
 260         }
 261         if (c.isInterface()) {
 262             return Object.class;
 263         }
 264         return c.getSuperclass();
 265     }
 266 
 267     public Class&lt;?&gt; findLeastCommonAncestor(Class&lt;?&gt; c1Initial, Class&lt;?&gt; c2Initial) {
 268         if (c1Initial.isPrimitive() || c2Initial.isPrimitive()) {
 269             return null;
 270         } else {
 271             Class&lt;?&gt; c1 = c1Initial;
 272             Class&lt;?&gt; c2 = c2Initial;
 273             while (true) {
 274                 if (c1.isAssignableFrom(c2)) {
 275                     return c1;
 276                 }
 277                 if (c2.isAssignableFrom(c1)) {
 278                     return c2;
 279                 }
 280                 c1 = getSupertype(c1);
 281                 c2 = getSupertype(c2);
 282             }
 283         }
 284     }
 285 
 286     @Test
 287     public void findLeastCommonAncestorTest() {
 288         Class&lt;?&gt;[] all = classes.toArray(new Class&lt;?&gt;[classes.size()]);
 289         for (int i = 0; i &lt; all.length; i++) {
 290             Class&lt;?&gt; c1 = all[i];
 291             for (int j = i; j &lt; all.length; j++) {
 292                 Class&lt;?&gt; c2 = all[j];
 293                 ResolvedJavaType t1 = metaAccess.lookupJavaType(c1);
 294                 ResolvedJavaType t2 = metaAccess.lookupJavaType(c2);
 295                 Class&lt;?&gt; expected = findLeastCommonAncestor(c1, c2);
 296                 ResolvedJavaType actual = t1.findLeastCommonAncestor(t2);
 297                 if (expected == null) {
 298                     assertTrue(actual == null);
 299                 } else {
 300                     assertNotNull(actual);
 301                     assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 302                 }
 303             }
 304         }
 305     }
 306 
 307     private static class Base {
 308     }
 309 
 310     abstract static class Abstract1 extends Base {
 311     }
 312 
 313     interface Interface1 {
 314     }
 315 
 316     static class Concrete1 extends Abstract1 {
 317     }
 318 
 319     static class Concrete2 extends Abstract1 implements Interface1 {
 320     }
 321 
 322     static class Concrete3 extends Concrete2 {
 323     }
 324 
 325     static final class Final1 extends Abstract1 {
 326     }
 327 
 328     abstract static class Abstract4 extends Concrete3 {
 329     }
 330 
 331     void checkConcreteSubtype(ResolvedJavaType type, ResolvedJavaType expected) {
 332         AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = type.findLeafConcreteSubtype();
 333         if (leafConcreteSubtype == null) {
 334             // findLeafConcreteSubtype() is conservative
 335         } else {
 336             if (expected == null) {
 337                 assertNull(leafConcreteSubtype);
 338             } else {
 339                 assertTrue(leafConcreteSubtype.getResult().equals(expected));
 340             }
 341             assertTrue(!type.isLeaf() || leafConcreteSubtype.isAssumptionFree());
 342         }
 343 
 344         if (!type.isArray()) {
 345             ResolvedJavaType arrayType = type.getArrayClass();
 346             AssumptionResult&lt;ResolvedJavaType&gt; arraySubtype = arrayType.findLeafConcreteSubtype();
 347             if (arraySubtype != null) {
 348                 assertEquals(arraySubtype.getResult(), arrayType);
 349             } else {
 350                 // findLeafConcreteSubtype() method is conservative
 351             }
 352         }
 353     }
 354 
 355     @Test
 356     public void findLeafConcreteSubtypeTest() {
 357         ResolvedJavaType base = metaAccess.lookupJavaType(Base.class);
 358         checkConcreteSubtype(base, base);
 359 
 360         ResolvedJavaType a1 = metaAccess.lookupJavaType(Abstract1.class);
 361         ResolvedJavaType c1 = metaAccess.lookupJavaType(Concrete1.class);
 362 
 363         checkConcreteSubtype(base, null);
 364         checkConcreteSubtype(a1, c1);
 365         checkConcreteSubtype(c1, c1);
 366 
 367         ResolvedJavaType i1 = metaAccess.lookupJavaType(Interface1.class);
 368         ResolvedJavaType c2 = metaAccess.lookupJavaType(Concrete2.class);
 369 
 370         checkConcreteSubtype(base, null);
 371         checkConcreteSubtype(a1, null);
 372         checkConcreteSubtype(c1, c1);
 373         checkConcreteSubtype(i1, c2);
 374         checkConcreteSubtype(c2, c2);
 375 
 376         ResolvedJavaType c3 = metaAccess.lookupJavaType(Concrete3.class);
 377         checkConcreteSubtype(c2, null);
 378         checkConcreteSubtype(c3, c3);
 379 
 380         ResolvedJavaType a4 = metaAccess.lookupJavaType(Abstract4.class);
 381         checkConcreteSubtype(c3, null);
 382         checkConcreteSubtype(a4, null);
 383 
 384         ResolvedJavaType a1a = metaAccess.lookupJavaType(Abstract1[].class);
 385         checkConcreteSubtype(a1a, null);
 386         ResolvedJavaType i1a = metaAccess.lookupJavaType(Interface1[].class);
 387         checkConcreteSubtype(i1a, null);
 388         ResolvedJavaType c1a = metaAccess.lookupJavaType(Concrete1[].class);
 389         checkConcreteSubtype(c1a, c1a);
 390         ResolvedJavaType f1a = metaAccess.lookupJavaType(Final1[].class);
 391         checkConcreteSubtype(f1a, f1a);
 392 
 393         ResolvedJavaType obja = metaAccess.lookupJavaType(Object[].class);
 394         checkConcreteSubtype(obja, null);
 395 
 396         ResolvedJavaType inta = metaAccess.lookupJavaType(int[].class);
 397         checkConcreteSubtype(inta, inta);
 398     }
 399 
 400     interface NoImplementor {
 401     }
 402 
 403     interface SingleImplementorInterface {
 404     }
 405 
 406     static class SingleConcreteImplementor implements SingleImplementorInterface {
 407     }
 408 
 409     interface SingleAbstractImplementorInterface {
 410     }
 411 
 412     abstract static class SingleAbstractImplementor implements SingleAbstractImplementorInterface {
 413     }
 414 
 415     interface MultiImplementorInterface {
 416     }
 417 
 418     static class ConcreteImplementor1 implements MultiImplementorInterface {
 419     }
 420 
 421     static class ConcreteImplementor2 implements MultiImplementorInterface {
 422     }
 423 
 424     interface MultipleAbstractImplementorInterface {
 425     }
 426 
 427     abstract static class MultiAbstractImplementor1 implements MultipleAbstractImplementorInterface {
 428     }
 429 
 430     abstract static class MultiAbstractImplementor2 implements MultipleAbstractImplementorInterface {
 431     }
 432 
 433     interface SingleAbstractImplementorInterface2 {
 434     }
 435 
 436     interface ExtendedSingleImplementorInterface {
 437     }
 438 
 439     abstract static class SingleAbstractImplementor2 implements SingleAbstractImplementorInterface2 {
 440     }
 441 
 442     static class ConcreteTransitiveImplementor1 extends SingleAbstractImplementor2 implements ExtendedSingleImplementorInterface {
 443     }
 444 
 445     static class ConcreteTransitiveImplementor2 extends SingleAbstractImplementor2 implements ExtendedSingleImplementorInterface {
 446     }
 447 
 448     @Test
 449     public void getSingleImplementorTest() {
 450         ResolvedJavaType iNi = metaAccess.lookupJavaType(NoImplementor.class);
 451         assertNull(iNi.getSingleImplementor());
 452 
 453         ResolvedJavaType iSi = metaAccess.lookupJavaType(SingleImplementorInterface.class);
 454         ResolvedJavaType cSi = metaAccess.lookupJavaType(SingleConcreteImplementor.class);
 455         assertEquals(cSi, iSi.getSingleImplementor());
 456 
 457         ResolvedJavaType iSai = metaAccess.lookupJavaType(SingleAbstractImplementorInterface.class);
 458         ResolvedJavaType aSai = metaAccess.lookupJavaType(SingleAbstractImplementor.class);
 459         assertEquals(aSai, iSai.getSingleImplementor());
 460 
 461         ResolvedJavaType iMi = metaAccess.lookupJavaType(MultiImplementorInterface.class);
 462         metaAccess.lookupJavaType(ConcreteImplementor1.class);
 463         metaAccess.lookupJavaType(ConcreteImplementor2.class);
 464         assertEquals(iMi, iMi.getSingleImplementor());
 465 
 466         ResolvedJavaType iMai = metaAccess.lookupJavaType(MultipleAbstractImplementorInterface.class);
 467         metaAccess.lookupJavaType(MultiAbstractImplementor1.class);
 468         metaAccess.lookupJavaType(MultiAbstractImplementor2.class);
 469         assertEquals(iMai, iMai.getSingleImplementor());
 470 
 471         ResolvedJavaType iSai2 = metaAccess.lookupJavaType(SingleAbstractImplementorInterface2.class);
 472         ResolvedJavaType aSai2 = metaAccess.lookupJavaType(SingleAbstractImplementor2.class);
 473         metaAccess.lookupJavaType(ConcreteTransitiveImplementor1.class);
 474         metaAccess.lookupJavaType(ConcreteTransitiveImplementor2.class);
 475         assertEquals(aSai2, iSai2.getSingleImplementor());
 476 
 477         for (Class&lt;?&gt; c : classes) {
 478             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 479             try {
 480                 type.getSingleImplementor();
 481                 if (!c.isInterface()) {
 482                     throw new AssertionError("Expected exception for calling getSingleImplmentor on " + c.getName());
 483                 }
 484             } catch (JVMCIError e) {
 485                 if (c.isInterface()) {
 486                     throw new AssertionError("Unexpected exception", e);
 487                 }
 488             }
 489         }
 490     }
 491 
 492     @Test(expected = JVMCIError.class)
 493     public void getSingleImplementorTestClassReceiver() {
 494         ResolvedJavaType base = metaAccess.lookupJavaType(Base.class);
 495         base.getSingleImplementor();
 496     }
 497 
 498     @Test(expected = JVMCIError.class)
 499     public void getSingleImplementorTestPrimitiveReceiver() {
 500         ResolvedJavaType primitive = metaAccess.lookupJavaType(int.class);
 501         primitive.getSingleImplementor();
 502     }
 503 
 504     @Test
 505     public void getComponentTypeTest() {
 506         for (Class&lt;?&gt; c : classes) {
 507             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 508             Class&lt;?&gt; expected = c.getComponentType();
 509             ResolvedJavaType actual = type.getComponentType();
 510             if (expected == null) {
 511                 assertNull(actual);
 512             } else {
 513                 assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 514             }
 515         }
 516     }
 517 
 518     @Test
 519     public void getArrayClassTest() {
 520         for (Class&lt;?&gt; c : classes) {
 521             if (c != void.class) {
 522                 ResolvedJavaType type = metaAccess.lookupJavaType(c);
 523                 Class&lt;?&gt; expected = getArrayClass(c);
 524                 ResolvedJavaType actual = type.getArrayClass();
 525                 assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 526             }
 527         }
 528     }
 529 
 530     static class Declarations {
 531 
 532         final Method implementation;
 533         final Set&lt;Method&gt; declarations;
 534 
 535         Declarations(Method impl) {
 536             this.implementation = impl;
 537             declarations = new HashSet&lt;&gt;();
 538         }
 539     }
 540 
 541     /**
 542      * See &lt;a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.5"&gt;Method
 543      * overriding&lt;/a&gt;.
 544      */
 545     static boolean isOverriderOf(Method impl, Method m) {
 546         if (!isPrivate(m.getModifiers()) &amp;&amp; !isFinal(m.getModifiers())) {
 547             if (m.getName().equals(impl.getName())) {
 548                 if (m.getReturnType() == impl.getReturnType()) {
 549                     if (Arrays.equals(m.getParameterTypes(), impl.getParameterTypes())) {
 550                         if (isPublic(m.getModifiers()) || isProtected(m.getModifiers())) {
 551                             // m is public or protected
 552                             return isPublic(impl.getModifiers()) || isProtected(impl.getModifiers());
 553                         } else {
 554                             // m is package-private
 555                             return impl.getDeclaringClass().getPackage() == m.getDeclaringClass().getPackage();
 556                         }
 557                     }
 558                 }
 559             }
 560         }
 561         return false;
 562     }
 563 
 564     static final Map&lt;Class&lt;?&gt;, VTable&gt; vtables = new HashMap&lt;&gt;();
 565 
 566     static class VTable {
 567 
 568         final Map&lt;NameAndSignature, Method&gt; methods = new HashMap&lt;&gt;();
 569     }
 570 
 571     static synchronized VTable getVTable(Class&lt;?&gt; c) {
 572         VTable vtable = vtables.get(c);
 573         if (vtable == null) {
 574             vtable = new VTable();
 575             if (c != Object.class) {
 576                 VTable superVtable = getVTable(c.getSuperclass());
 577                 vtable.methods.putAll(superVtable.methods);
 578             }
 579             for (Method m : c.getDeclaredMethods()) {
 580                 if (!isStatic(m.getModifiers()) &amp;&amp; !isPrivate(m.getModifiers())) {
 581                     if (isAbstract(m.getModifiers())) {
 582                         // A subclass makes a concrete method in a superclass abstract
 583                         vtable.methods.remove(new NameAndSignature(m));
 584                     } else {
 585                         vtable.methods.put(new NameAndSignature(m), m);
 586                     }
 587                 }
 588             }
 589             vtables.put(c, vtable);
 590         }
 591         return vtable;
 592     }
 593 
 594     static Set&lt;Method&gt; findDeclarations(Method impl, Class&lt;?&gt; c) {
 595         Set&lt;Method&gt; declarations = new HashSet&lt;&gt;();
 596         NameAndSignature implSig = new NameAndSignature(impl);
 597         if (c != null) {
 598             for (Method m : c.getDeclaredMethods()) {
 599                 if (new NameAndSignature(m).equals(implSig)) {
 600                     declarations.add(m);
 601                     break;
 602                 }
 603             }
 604             if (!c.isInterface()) {
 605                 declarations.addAll(findDeclarations(impl, c.getSuperclass()));
 606             }
 607             for (Class&lt;?&gt; i : c.getInterfaces()) {
 608                 declarations.addAll(findDeclarations(impl, i));
 609             }
 610         }
 611         return declarations;
 612     }
 613 
 614     @Test
 615     public void resolveMethodTest() {
 616         ResolvedJavaType context = metaAccess.lookupJavaType(TestResolvedJavaType.class);
 617         for (Class&lt;?&gt; c : classes) {
 618             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 619             if (c.isInterface()) {
 620                 for (Method m : c.getDeclaredMethods()) {
 621                     ResolvedJavaMethod resolved = metaAccess.lookupJavaMethod(m);
 622                     ResolvedJavaMethod impl = type.resolveMethod(resolved, context);
 623                     assertEquals(m.toString(), null, impl);
 624                 }
 625             } else if (c.isPrimitive()) {
 626                 assertEquals("No methods expected", c.getDeclaredMethods().length, 0);
 627             } else {
 628                 VTable vtable = getVTable(c);
 629                 for (Method impl : vtable.methods.values()) {
 630                     Set&lt;Method&gt; decls = findDeclarations(impl, c);
 631                     for (Method decl : decls) {
 632                         ResolvedJavaMethod m = metaAccess.lookupJavaMethod(decl);
 633                         if (m.isPublic()) {
 634                             ResolvedJavaMethod resolvedmethod = type.resolveMethod(m, context);
 635                             if (isSignaturePolymorphic(m)) {
 636                                 // Signature polymorphic methods must not be resolved
 637                                 assertNull(resolvedmethod);
 638                             } else {
 639                                 ResolvedJavaMethod i = metaAccess.lookupJavaMethod(impl);
 640                                 assertEquals(m.toString(), i, resolvedmethod);
 641                             }
 642                         }
 643                     }
 644                 }
 645             }
 646         }
 647     }
 648 
 649     @Test
 650     public void resolveConcreteMethodTest() {
 651         ResolvedJavaType context = metaAccess.lookupJavaType(TestResolvedJavaType.class);
 652         for (Class&lt;?&gt; c : classes) {
 653             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 654             if (c.isInterface()) {
 655                 for (Method m : c.getDeclaredMethods()) {
 656                     ResolvedJavaMethod resolved = metaAccess.lookupJavaMethod(m);
 657                     ResolvedJavaMethod impl = type.resolveConcreteMethod(resolved, context);
 658                     assertEquals(m.toString(), null, impl);
 659                 }
 660             } else if (c.isPrimitive()) {
 661                 assertEquals("No methods expected", c.getDeclaredMethods().length, 0);
 662             } else {
 663                 VTable vtable = getVTable(c);
 664                 for (Method impl : vtable.methods.values()) {
 665                     Set&lt;Method&gt; decls = findDeclarations(impl, c);
 666                     for (Method decl : decls) {
 667                         ResolvedJavaMethod m = metaAccess.lookupJavaMethod(decl);
 668                         if (m.isPublic()) {
 669                             ResolvedJavaMethod resolvedMethod = type.resolveConcreteMethod(m, context);
 670                             if (isSignaturePolymorphic(m)) {
 671                                 // Signature polymorphic methods must not be resolved
 672                                 assertNull(String.format("Got: %s", resolvedMethod), resolvedMethod);
 673                             } else {
 674                                 ResolvedJavaMethod i = metaAccess.lookupJavaMethod(impl);
 675                                 assertEquals(i, resolvedMethod);
 676                             }
 677                         }
 678                     }
 679                 }
 680                 for (Method m : c.getDeclaredMethods()) {
 681                     ResolvedJavaMethod impl = type.resolveConcreteMethod(metaAccess.lookupJavaMethod(m), context);
 682                     ResolvedJavaMethod expected = isAbstract(m.getModifiers()) ? null : impl;
 683                     assertEquals(type + " " + m.toString(), expected, impl);
 684                 }
 685             }
 686         }
 687     }
 688 
 689     @Test
 690     public void findUniqueConcreteMethodTest() throws NoSuchMethodException {
 691         ResolvedJavaMethod thisMethod = metaAccess.lookupJavaMethod(getClass().getDeclaredMethod("findUniqueConcreteMethodTest"));
 692         ResolvedJavaMethod ucm = metaAccess.lookupJavaType(getClass()).findUniqueConcreteMethod(thisMethod).getResult();
 693         assertEquals(thisMethod, ucm);
 694     }
 695 
 696     public static Set&lt;Field&gt; getInstanceFields(Class&lt;?&gt; c, boolean includeSuperclasses) {
 697         if (c.isArray() || c.isPrimitive() || c.isInterface()) {
 698             return Collections.emptySet();
 699         }
 700         Set&lt;Field&gt; result = new HashSet&lt;&gt;();
 701         for (Field f : c.getDeclaredFields()) {
 702             if (!Modifier.isStatic(f.getModifiers())) {
 703                 result.add(f);
 704             }
 705         }
 706         if (includeSuperclasses &amp;&amp; c != Object.class) {
 707             result.addAll(getInstanceFields(c.getSuperclass(), true));
 708         }
 709         return result;
 710     }
 711 
 712     public static Set&lt;Field&gt; getStaticFields(Class&lt;?&gt; c) {
 713         Set&lt;Field&gt; result = new HashSet&lt;&gt;();
 714         for (Field f : c.getDeclaredFields()) {
 715             if (Modifier.isStatic(f.getModifiers())) {
 716                 result.add(f);
 717             }
 718         }
 719         return result;
 720     }
 721 
 722     public boolean fieldsEqual(Field f, ResolvedJavaField rjf) {
 723         return rjf.getDeclaringClass().equals(metaAccess.lookupJavaType(f.getDeclaringClass())) &amp;&amp; rjf.getName().equals(f.getName()) &amp;&amp;
 724                         rjf.getType().resolve(rjf.getDeclaringClass()).equals(metaAccess.lookupJavaType(f.getType()));
 725     }
 726 
 727     public ResolvedJavaField lookupField(ResolvedJavaField[] fields, Field key) {
 728         for (ResolvedJavaField rf : fields) {
 729             if (fieldsEqual(key, rf)) {
 730                 return rf;
 731             }
 732         }
 733         return null;
 734     }
 735 
 736     public Field lookupField(Set&lt;Field&gt; fields, ResolvedJavaField key) {
 737         for (Field f : fields) {
 738             if (fieldsEqual(f, key)) {
 739                 return f;
 740             }
 741         }
 742         return null;
 743     }
 744 
 745     private static boolean isHiddenFromReflection(ResolvedJavaField f) {
 746         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Throwable.class)) &amp;&amp; f.getName().equals("backtrace")) {
 747             return true;
 748         }
 749         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(ConstantPool.class)) &amp;&amp; f.getName().equals("constantPoolOop")) {
 750             return true;
 751         }
 752         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Class.class)) &amp;&amp; f.getName().equals("classLoader")) {
 753             return true;
 754         }
 755         return false;
 756     }
 757 
 758     @Test
 759     public void getInstanceFieldsTest() {
 760         for (Class&lt;?&gt; c : classes) {
 761             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 762             for (boolean includeSuperclasses : new boolean[]{true, false}) {
 763                 Set&lt;Field&gt; expected = getInstanceFields(c, includeSuperclasses);
 764                 ResolvedJavaField[] actual = type.getInstanceFields(includeSuperclasses);
 765                 for (Field f : expected) {
 766                     assertNotNull(lookupField(actual, f));
 767                 }
 768                 for (ResolvedJavaField rf : actual) {
 769                     if (!isHiddenFromReflection(rf)) {
 770                         assertEquals(rf.toString(), lookupField(expected, rf) != null, !rf.isInternal());
 771                     }
 772                 }
 773 
 774                 // Test stability of getInstanceFields
 775                 ResolvedJavaField[] actual2 = type.getInstanceFields(includeSuperclasses);
 776                 assertArrayEquals(actual, actual2);
 777             }
 778         }
 779     }
 780 
 781     @Test
 782     public void getStaticFieldsTest() {
 783         for (Class&lt;?&gt; c : classes) {
 784             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 785             Set&lt;Field&gt; expected = getStaticFields(c);
 786             ResolvedJavaField[] actual = type.getStaticFields();
 787             for (Field f : expected) {
 788                 assertNotNull(lookupField(actual, f));
 789             }
 790             for (ResolvedJavaField rf : actual) {
 791                 if (!isHiddenFromReflection(rf)) {
 792                     assertEquals(lookupField(expected, rf) != null, !rf.isInternal());
 793                 }
 794             }
 795 
 796             // Test stability of getStaticFields
 797             ResolvedJavaField[] actual2 = type.getStaticFields();
 798             assertArrayEquals(actual, actual2);
 799         }
 800     }
 801 
 802     @Test
 803     public void getDeclaredMethodsTest() {
 804         for (Class&lt;?&gt; c : classes) {
 805             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 806             Method[] raw = c.getDeclaredMethods();
 807             Set&lt;ResolvedJavaMethod&gt; expected = new HashSet&lt;&gt;();
 808             for (Method m : raw) {
 809                 ResolvedJavaMethod resolvedMethod = metaAccess.lookupJavaMethod(m);
 810                 assertNotNull(resolvedMethod);
 811                 expected.add(resolvedMethod);
 812             }
 813             Set&lt;ResolvedJavaMethod&gt; actual = new HashSet&lt;&gt;(Arrays.asList(type.getDeclaredMethods()));
 814             assertEquals(expected, actual);
 815         }
 816     }
 817 
 818     static class A {
 819         static String name = "foo";
 820     }
 821 
 822     static class B extends A {
 823     }
 824 
 825     static class C {
 826     }
 827 
 828     static class D {
 829         void foo() {
 830             // use of assertions causes the class to have a &lt;clinit&gt;
 831             assert getClass() != null;
 832         }
 833     }
 834 
 835     static class SubD extends D {
 836 
 837     }
 838 
 839     @Test
 840     public void getClassInitializerTest() {
 841         assertNotNull(metaAccess.lookupJavaType(A.class).getClassInitializer());
 842         assertNotNull(metaAccess.lookupJavaType(D.class).getClassInitializer());
 843         assertNull(metaAccess.lookupJavaType(B.class).getClassInitializer());
 844         assertNull(metaAccess.lookupJavaType(C.class).getClassInitializer());
 845         assertNull(metaAccess.lookupJavaType(int.class).getClassInitializer());
 846         assertNull(metaAccess.lookupJavaType(void.class).getClassInitializer());
 847         for (Class&lt;?&gt; c : classes) {
 848             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 849             type.getClassInitializer();
 850         }
 851     }
 852 
 853     @Test
 854     public void getAnnotationsTest() {
 855         for (Class&lt;?&gt; c : classes) {
 856             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 857             assertArrayEquals(c.getAnnotations(), type.getAnnotations());
 858         }
 859     }
 860 
 861     @Test
 862     public void getAnnotationTest() {
 863         for (Class&lt;?&gt; c : classes) {
 864             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 865             for (Annotation a : c.getAnnotations()) {
 866                 assertEquals(a, type.getAnnotation(a.annotationType()));
 867             }
 868         }
 869     }
 870 
 871     @Test
 872     public void memberClassesTest() {
 873         for (Class&lt;?&gt; c : classes) {
 874             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 875             assertEquals(c.isLocalClass(), type.isLocal());
 876             assertEquals(c.isMemberClass(), type.isMember());
 877             Class&lt;?&gt; enclc = c.getEnclosingClass();
 878             ResolvedJavaType enclt = type.getEnclosingType();
 879             assertFalse(enclc == null ^ enclt == null);
 880             if (enclc != null) {
 881                 assertEquals(enclt, metaAccess.lookupJavaType(enclc));
 882             }
 883         }
 884     }
 885 
 886     @Test
 887     public void isLeafTest() {
 888         for (Class&lt;?&gt; c : classes) {
 889             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 890             ResolvedJavaType arrayType = c != void.class ? metaAccess.lookupJavaType(getArrayClass(c)) : null;
 891             if (c.isPrimitive()) {
 892                 assertTrue(type.isLeaf());
 893                 assertTrue(arrayType == null || arrayType.isLeaf());
 894             } else {
 895                 assertTrue(c.toString(), type.isLeaf() == arrayType.isLeaf());
 896                 if (!c.isArray()) {
 897                     assertTrue(c.toString(), type.isLeaf() == Modifier.isFinal(c.getModifiers()));
 898                 }
 899             }
 900         }
 901     }
 902 
 903     static class TrivialCloneable implements Cloneable {
 904         @Override
 905         protected Object clone() {
 906             return new TrivialCloneable();
 907         }
 908     }
 909 
 910     @Test
 911     public void isCloneableWithAllocationTest() {
 912         ResolvedJavaType cloneable = metaAccess.lookupJavaType(Cloneable.class);
 913         for (Class&lt;?&gt; c : classes) {
 914             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 915             if (type.isCloneableWithAllocation()) {
 916                 // Only Cloneable types should be allocation cloneable
 917                 assertTrue(c.toString(), cloneable.isAssignableFrom(type));
 918             }
 919         }
 920         /*
 921          * We can't know for sure which types should be allocation cloneable on a particular
 922          * platform but assume that at least totally trivial objects should be.
 923          */
 924         ResolvedJavaType trivialCloneable = metaAccess.lookupJavaType(TrivialCloneable.class);
 925         assertTrue(trivialCloneable.toString(), trivialCloneable.isCloneableWithAllocation());
 926     }
 927 
 928     @Test
 929     public void findMethodTest() {
 930         try {
 931             ResolvedJavaMethod findFoo = metaAccess.lookupJavaType(D.class).findMethod("foo", metaAccess.parseMethodDescriptor("()V"));
 932             ResolvedJavaMethod expectedFoo = metaAccess.lookupJavaMethod(D.class.getDeclaredMethod("foo"));
 933             assertEquals(expectedFoo, findFoo);
 934 
 935             ResolvedJavaMethod wrongReturnTypeFoo = metaAccess.lookupJavaType(D.class).findMethod("foo", metaAccess.parseMethodDescriptor("()I"));
 936             assertNull(wrongReturnTypeFoo);
 937 
 938             ResolvedJavaMethod wrongArgumentsFoo = metaAccess.lookupJavaType(D.class).findMethod("foo", metaAccess.parseMethodDescriptor("(I)V"));
 939             assertNull(wrongArgumentsFoo);
 940 
 941             ResolvedJavaMethod wrongNameFoo = metaAccess.lookupJavaType(D.class).findMethod("bar", metaAccess.parseMethodDescriptor("()V"));
 942             assertNull(wrongNameFoo);
 943 
 944             ResolvedJavaMethod wrongClassFoo = metaAccess.lookupJavaType(SubD.class).findMethod("foo", metaAccess.parseMethodDescriptor("()V"));
 945             assertNull(wrongClassFoo);
 946         } catch (NoSuchMethodException | SecurityException e) {
 947             throw new RuntimeException(e);
 948         }
 949     }
 950 
 951     private Method findTestMethod(Method apiMethod) {
 952         String testName = apiMethod.getName() + "Test";
 953         for (Method m : getClass().getDeclaredMethods()) {
 954             if (m.getName().equals(testName) &amp;&amp; m.getAnnotation(Test.class) != null) {
 955                 return m;
 956             }
 957         }
 958         return null;
 959     }
 960 
 961     // @formatter:off
 962     private static final String[] untestedApiMethods = {
 963         "initialize",
 964         "isPrimitive",
 965         "newArray",
 966         "getDeclaredConstructors",
 967         "isInitialized",
 968         "isLinked",
 969         "getJavaClass",
 970         "getObjectHub",
 971         "hasFinalizableSubclass",
 972         "hasFinalizer",
 973         "getSourceFileName",
 974         "getClassFilePath",
 975         "isLocal",
 976         "isJavaLangObject",
 977         "isMember",
 978         "getElementalType",
 979         "getEnclosingType",
 980         "$jacocoInit",
 981         "isCpiSet",
 982         "getCorrespondingCpi",
 983         "setCorrespondingCpi"
 984     };
 985     // @formatter:on
 986 
 987     /**
 988      * Ensures that any new methods added to {@link ResolvedJavaMethod} either have a test written
 989      * for them or are added to {@link #untestedApiMethods}.
 990      */
 991     @Test
 992     public void testCoverage() {
 993         Set&lt;String&gt; known = new HashSet&lt;&gt;(Arrays.asList(untestedApiMethods));
 994         for (Method m : ResolvedJavaType.class.getDeclaredMethods()) {
 995             if (findTestMethod(m) == null) {
 996                 assertTrue("test missing for " + m, known.contains(m.getName()));
 997             } else {
 998                 assertFalse("test should be removed from untestedApiMethods" + m, known.contains(m.getName()));
 999             }
1000         }
1001     }
1002 
1003     private static boolean isSignaturePolymorphic(ResolvedJavaMethod method) {
1004         return method.getAnnotation(SIGNATURE_POLYMORPHIC_CLASS) != null;
1005     }
1006 }
</pre></body></html>
