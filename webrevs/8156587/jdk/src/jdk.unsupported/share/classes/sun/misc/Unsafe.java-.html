<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/jdk.unsupported/share/classes/sun/misc/Unsafe.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.misc;
  27 
  28 import jdk.internal.vm.annotation.ForceInline;
  29 import jdk.internal.misc.VM;
  30 import jdk.internal.reflect.CallerSensitive;
  31 import jdk.internal.reflect.Reflection;
  32 
  33 import java.lang.reflect.Field;
  34 import java.security.ProtectionDomain;
  35 
  36 
  37 /**
  38  * A collection of methods for performing low-level, unsafe operations.
  39  * Although the class and all methods are public, use of this class is
  40  * limited because only trusted code can obtain instances of it.
  41  *
  42  * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make sure
  43  * arguments are checked before methods of this class are
  44  * called. While some rudimentary checks are performed on the input,
  45  * the checks are best effort and when performance is an overriding
  46  * priority, as when methods of this class are optimized by the
  47  * runtime compiler, some or all checks (if any) may be elided. Hence,
  48  * the caller must not rely on the checks and corresponding
  49  * exceptions!
  50  *
  51  * @author John R. Rose
  52  * @see #getUnsafe
  53  */
  54 
  55 public final class Unsafe {
  56 
  57     static {
  58         Reflection.registerMethodsToFilter(Unsafe.class, "getUnsafe");
  59     }
  60 
  61     private Unsafe() {}
  62 
  63     private static final Unsafe theUnsafe = new Unsafe();
  64     private static final jdk.internal.misc.Unsafe theInternalUnsafe = jdk.internal.misc.Unsafe.getUnsafe();
  65 
  66     /**
  67      * Provides the caller with the capability of performing unsafe
  68      * operations.
  69      *
  70      * &lt;p&gt;The returned {@code Unsafe} object should be carefully guarded
  71      * by the caller, since it can be used to read and write data at arbitrary
  72      * memory addresses.  It must never be passed to untrusted code.
  73      *
  74      * &lt;p&gt;Most methods in this class are very low-level, and correspond to a
  75      * small number of hardware instructions (on typical machines).  Compilers
  76      * are encouraged to optimize these methods accordingly.
  77      *
  78      * &lt;p&gt;Here is a suggested idiom for using unsafe operations:
  79      *
  80      * &lt;pre&gt; {@code
  81      * class MyTrustedClass {
  82      *   private static final Unsafe unsafe = Unsafe.getUnsafe();
  83      *   ...
  84      *   private long myCountAddress = ...;
  85      *   public int getCount() { return unsafe.getByte(myCountAddress); }
  86      * }}&lt;/pre&gt;
  87      *
  88      * (It may assist compilers to make the local variable {@code final}.)
  89      *
  90      * @throws  SecurityException  if a security manager exists and its
  91      *          {@code checkPropertiesAccess} method doesn't allow
  92      *          access to the system properties.
  93      */
  94     @CallerSensitive
  95     public static Unsafe getUnsafe() {
  96         Class&lt;?&gt; caller = Reflection.getCallerClass();
  97         if (!VM.isSystemDomainLoader(caller.getClassLoader()))
  98             throw new SecurityException("Unsafe");
  99         return theUnsafe;
 100     }
 101 
 102     /// peek and poke operations
 103     /// (compilers should optimize these to memory ops)
 104 
 105     // These work on object fields in the Java heap.
 106     // They will not work on elements of packed arrays.
 107 
 108     /**
 109      * Fetches a value from a given Java variable.
 110      * More specifically, fetches a field or array element within the given
 111      * object {@code o} at the given offset, or (if {@code o} is null)
 112      * from the memory address whose numerical value is the given offset.
 113      * &lt;p&gt;
 114      * The results are undefined unless one of the following cases is true:
 115      * &lt;ul&gt;
 116      * &lt;li&gt;The offset was obtained from {@link #objectFieldOffset} on
 117      * the {@link java.lang.reflect.Field} of some Java field and the object
 118      * referred to by {@code o} is of a class compatible with that
 119      * field's class.
 120      *
 121      * &lt;li&gt;The offset and object reference {@code o} (either null or
 122      * non-null) were both obtained via {@link #staticFieldOffset}
 123      * and {@link #staticFieldBase} (respectively) from the
 124      * reflective {@link Field} representation of some Java field.
 125      *
 126      * &lt;li&gt;The object referred to by {@code o} is an array, and the offset
 127      * is an integer of the form {@code B+N*S}, where {@code N} is
 128      * a valid index into the array, and {@code B} and {@code S} are
 129      * the values obtained by {@link #arrayBaseOffset} and {@link
 130      * #arrayIndexScale} (respectively) from the array's class.  The value
 131      * referred to is the {@code N}&lt;em&gt;th&lt;/em&gt; element of the array.
 132      *
 133      * &lt;/ul&gt;
 134      * &lt;p&gt;
 135      * If one of the above cases is true, the call references a specific Java
 136      * variable (field or array element).  However, the results are undefined
 137      * if that variable is not in fact of the type returned by this method.
 138      * &lt;p&gt;
 139      * This method refers to a variable by means of two parameters, and so
 140      * it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode
 141      * for Java variables.  When the object reference is null, this method
 142      * uses its offset as an absolute address.  This is similar in operation
 143      * to methods such as {@link #getInt(long)}, which provide (in effect) a
 144      * &lt;em&gt;single-register&lt;/em&gt; addressing mode for non-Java variables.
 145      * However, because Java variables may have a different layout in memory
 146      * from non-Java variables, programmers should not assume that these
 147      * two addressing modes are ever equivalent.  Also, programmers should
 148      * remember that offsets from the double-register addressing mode cannot
 149      * be portably confused with longs used in the single-register addressing
 150      * mode.
 151      *
 152      * @param o Java heap object in which the variable resides, if any, else
 153      *        null
 154      * @param offset indication of where the variable resides in a Java heap
 155      *        object, if any, else a memory address locating the variable
 156      *        statically
 157      * @return the value fetched from the indicated Java variable
 158      * @throws RuntimeException No defined exceptions are thrown, not even
 159      *         {@link NullPointerException}
 160      */
 161     @ForceInline
 162     public int getInt(Object o, long offset) {
 163         return theInternalUnsafe.getInt(o, offset);
 164     }
 165 
 166     /**
 167      * Stores a value into a given Java variable.
 168      * &lt;p&gt;
 169      * The first two parameters are interpreted exactly as with
 170      * {@link #getInt(Object, long)} to refer to a specific
 171      * Java variable (field or array element).  The given value
 172      * is stored into that variable.
 173      * &lt;p&gt;
 174      * The variable must be of the same type as the method
 175      * parameter {@code x}.
 176      *
 177      * @param o Java heap object in which the variable resides, if any, else
 178      *        null
 179      * @param offset indication of where the variable resides in a Java heap
 180      *        object, if any, else a memory address locating the variable
 181      *        statically
 182      * @param x the value to store into the indicated Java variable
 183      * @throws RuntimeException No defined exceptions are thrown, not even
 184      *         {@link NullPointerException}
 185      */
 186     @ForceInline
 187     public void putInt(Object o, long offset, int x) {
 188         theInternalUnsafe.putInt(o, offset, x);
 189     }
 190 
 191     /**
 192      * Fetches a reference value from a given Java variable.
 193      * @see #getInt(Object, long)
 194      */
 195     @ForceInline
 196     public Object getObject(Object o, long offset) {
 197         return theInternalUnsafe.getObject(o, offset);
 198     }
 199 
 200     /**
 201      * Stores a reference value into a given Java variable.
 202      * &lt;p&gt;
 203      * Unless the reference {@code x} being stored is either null
 204      * or matches the field type, the results are undefined.
 205      * If the reference {@code o} is non-null, card marks or
 206      * other store barriers for that object (if the VM requires them)
 207      * are updated.
 208      * @see #putInt(Object, long, int)
 209      */
 210     @ForceInline
 211     public void putObject(Object o, long offset, Object x) {
 212         theInternalUnsafe.putObject(o, offset, x);
 213     }
 214 
 215     /** @see #getInt(Object, long) */
 216     @ForceInline
 217     public boolean getBoolean(Object o, long offset) {
 218         return theInternalUnsafe.getBoolean(o, offset);
 219     }
 220 
 221     /** @see #putInt(Object, long, int) */
 222     @ForceInline
 223     public void putBoolean(Object o, long offset, boolean x) {
 224         theInternalUnsafe.putBoolean(o, offset, x);
 225     }
 226 
 227     /** @see #getInt(Object, long) */
 228     @ForceInline
 229     public byte getByte(Object o, long offset) {
 230         return theInternalUnsafe.getByte(o, offset);
 231     }
 232 
 233     /** @see #putInt(Object, long, int) */
 234     @ForceInline
 235     public void putByte(Object o, long offset, byte x) {
 236         theInternalUnsafe.putByte(o, offset, x);
 237     }
 238 
 239     /** @see #getInt(Object, long) */
 240     @ForceInline
 241     public short getShort(Object o, long offset) {
 242         return theInternalUnsafe.getShort(o, offset);
 243     }
 244 
 245     /** @see #putInt(Object, long, int) */
 246     @ForceInline
 247     public void putShort(Object o, long offset, short x) {
 248         theInternalUnsafe.putShort(o, offset, x);
 249     }
 250 
 251     /** @see #getInt(Object, long) */
 252     @ForceInline
 253     public char getChar(Object o, long offset) {
 254         return theInternalUnsafe.getChar(o, offset);
 255     }
 256 
 257     /** @see #putInt(Object, long, int) */
 258     @ForceInline
 259     public void putChar(Object o, long offset, char x) {
 260         theInternalUnsafe.putChar(o, offset, x);
 261     }
 262 
 263     /** @see #getInt(Object, long) */
 264     @ForceInline
 265     public long getLong(Object o, long offset) {
 266         return theInternalUnsafe.getLong(o, offset);
 267     }
 268 
 269     /** @see #putInt(Object, long, int) */
 270     @ForceInline
 271     public void putLong(Object o, long offset, long x) {
 272         theInternalUnsafe.putLong(o, offset, x);
 273     }
 274 
 275     /** @see #getInt(Object, long) */
 276     @ForceInline
 277     public float getFloat(Object o, long offset) {
 278         return theInternalUnsafe.getFloat(o, offset);
 279     }
 280 
 281     /** @see #putInt(Object, long, int) */
 282     @ForceInline
 283     public void putFloat(Object o, long offset, float x) {
 284         theInternalUnsafe.putFloat(o, offset, x);
 285     }
 286 
 287     /** @see #getInt(Object, long) */
 288     @ForceInline
 289     public double getDouble(Object o, long offset) {
 290         return theInternalUnsafe.getDouble(o, offset);
 291     }
 292 
 293     /** @see #putInt(Object, long, int) */
 294     @ForceInline
 295     public void putDouble(Object o, long offset, double x) {
 296         theInternalUnsafe.putDouble(o, offset, x);
 297     }
 298 
 299 
 300     // These read VM internal data.
 301 
 302     /**
 303      * Fetches an uncompressed reference value from a given native variable
 304      * ignoring the VM's compressed references mode.
 305      *
 306      * @param address a memory address locating the variable
 307      * @return the value fetched from the indicated native variable
 308      */
 309     @ForceInline
 310     public Object getUncompressedObject(long address) {
 311         return theInternalUnsafe.getUncompressedObject(address);
 312     }
 313 
 314     /**
 315      * Fetches the {@link java.lang.Class} Java mirror for the given native
 316      * metaspace {@code Klass} pointer.
 317      *
 318      * @param metaspaceKlass a native metaspace {@code Klass} pointer
 319      * @return the {@link java.lang.Class} Java mirror
 320      */
 321     @ForceInline
 322     public Class&lt;?&gt; getJavaMirror(long metaspaceKlass) {
 323         return theInternalUnsafe.getJavaMirror(metaspaceKlass);
 324     }
 325 
 326     /**
 327      * Fetches a native metaspace {@code Klass} pointer for the given Java
 328      * object.
 329      *
 330      * @param o Java heap object for which to fetch the class pointer
 331      * @return a native metaspace {@code Klass} pointer
 332      */
 333     @ForceInline
 334     public long getKlassPointer(Object o) {
 335         return theInternalUnsafe.getKlassPointer(o);
 336     }
 337 
 338     // These work on values in the C heap.
 339 
 340     /**
 341      * Fetches a value from a given memory address.  If the address is zero, or
 342      * does not point into a block obtained from {@link #allocateMemory}, the
 343      * results are undefined.
 344      *
 345      * @see #allocateMemory
 346      */
 347     @ForceInline
 348     public byte getByte(long address) {
 349         return theInternalUnsafe.getByte(address);
 350     }
 351 
 352     /**
 353      * Stores a value into a given memory address.  If the address is zero, or
 354      * does not point into a block obtained from {@link #allocateMemory}, the
 355      * results are undefined.
 356      *
 357      * @see #getByte(long)
 358      */
 359     @ForceInline
 360     public void putByte(long address, byte x) {
 361         theInternalUnsafe.putByte(address, x);
 362     }
 363 
 364     /** @see #getByte(long) */
 365     @ForceInline
 366     public short getShort(long address) {
 367         return theInternalUnsafe.getShort(address);
 368     }
 369 
 370     /** @see #putByte(long, byte) */
 371     @ForceInline
 372     public void putShort(long address, short x) {
 373         theInternalUnsafe.putShort(address, x);
 374     }
 375 
 376     /** @see #getByte(long) */
 377     @ForceInline
 378     public char getChar(long address) {
 379         return theInternalUnsafe.getChar(address);
 380     }
 381 
 382     /** @see #putByte(long, byte) */
 383     @ForceInline
 384     public void putChar(long address, char x) {
 385         theInternalUnsafe.putChar(address, x);
 386     }
 387 
 388     /** @see #getByte(long) */
 389     @ForceInline
 390     public int getInt(long address) {
 391         return theInternalUnsafe.getInt(address);
 392     }
 393 
 394     /** @see #putByte(long, byte) */
 395     @ForceInline
 396     public void putInt(long address, int x) {
 397         theInternalUnsafe.putInt(address, x);
 398     }
 399 
 400     /** @see #getByte(long) */
 401     @ForceInline
 402     public long getLong(long address) {
 403         return theInternalUnsafe.getLong(address);
 404     }
 405 
 406     /** @see #putByte(long, byte) */
 407     @ForceInline
 408     public void putLong(long address, long x) {
 409         theInternalUnsafe.putLong(address, x);
 410     }
 411 
 412     /** @see #getByte(long) */
 413     @ForceInline
 414     public float getFloat(long address) {
 415         return theInternalUnsafe.getFloat(address);
 416     }
 417 
 418     /** @see #putByte(long, byte) */
 419     @ForceInline
 420     public void putFloat(long address, float x) {
 421         theInternalUnsafe.putFloat(address, x);
 422     }
 423 
 424     /** @see #getByte(long) */
 425     @ForceInline
 426     public double getDouble(long address) {
 427         return theInternalUnsafe.getDouble(address);
 428     }
 429 
 430     /** @see #putByte(long, byte) */
 431     @ForceInline
 432     public void putDouble(long address, double x) {
 433         theInternalUnsafe.putDouble(address, x);
 434     }
 435 
 436 
 437     /**
 438      * Fetches a native pointer from a given memory address.  If the address is
 439      * zero, or does not point into a block obtained from {@link
 440      * #allocateMemory}, the results are undefined.
 441      *
 442      * &lt;p&gt;If the native pointer is less than 64 bits wide, it is extended as
 443      * an unsigned number to a Java long.  The pointer may be indexed by any
 444      * given byte offset, simply by adding that offset (as a simple integer) to
 445      * the long representing the pointer.  The number of bytes actually read
 446      * from the target address may be determined by consulting {@link
 447      * #addressSize}.
 448      *
 449      * @see #allocateMemory
 450      */
 451     @ForceInline
 452     public long getAddress(long address) {
 453         return theInternalUnsafe.getAddress(address);
 454     }
 455 
 456     /**
 457      * Stores a native pointer into a given memory address.  If the address is
 458      * zero, or does not point into a block obtained from {@link
 459      * #allocateMemory}, the results are undefined.
 460      *
 461      * &lt;p&gt;The number of bytes actually written at the target address may be
 462      * determined by consulting {@link #addressSize}.
 463      *
 464      * @see #getAddress(long)
 465      */
 466     @ForceInline
 467     public void putAddress(long address, long x) {
 468         theInternalUnsafe.putAddress(address, x);
 469     }
 470 
 471 
 472     /// wrappers for malloc, realloc, free:
 473 
 474     /**
 475      * Allocates a new block of native memory, of the given size in bytes.  The
 476      * contents of the memory are uninitialized; they will generally be
 477      * garbage.  The resulting native pointer will never be zero, and will be
 478      * aligned for all value types.  Dispose of this memory by calling {@link
 479      * #freeMemory}, or resize it with {@link #reallocateMemory}.
 480      *
 481      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 482      * sure arguments are checked before the methods are called. While
 483      * some rudimentary checks are performed on the input, the checks
 484      * are best effort and when performance is an overriding priority,
 485      * as when methods of this class are optimized by the runtime
 486      * compiler, some or all checks (if any) may be elided. Hence, the
 487      * caller must not rely on the checks and corresponding
 488      * exceptions!
 489      *
 490      * @throws RuntimeException if the size is negative or too large
 491      *         for the native size_t type
 492      *
 493      * @throws OutOfMemoryError if the allocation is refused by the system
 494      *
 495      * @see #getByte(long)
 496      * @see #putByte(long, byte)
 497      */
 498     @ForceInline
 499     public long allocateMemory(long bytes) {
 500         return theInternalUnsafe.allocateMemory(bytes);
 501     }
 502 
 503     /**
 504      * Resizes a new block of native memory, to the given size in bytes.  The
 505      * contents of the new block past the size of the old block are
 506      * uninitialized; they will generally be garbage.  The resulting native
 507      * pointer will be zero if and only if the requested size is zero.  The
 508      * resulting native pointer will be aligned for all value types.  Dispose
 509      * of this memory by calling {@link #freeMemory}, or resize it with {@link
 510      * #reallocateMemory}.  The address passed to this method may be null, in
 511      * which case an allocation will be performed.
 512      *
 513      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 514      * sure arguments are checked before the methods are called. While
 515      * some rudimentary checks are performed on the input, the checks
 516      * are best effort and when performance is an overriding priority,
 517      * as when methods of this class are optimized by the runtime
 518      * compiler, some or all checks (if any) may be elided. Hence, the
 519      * caller must not rely on the checks and corresponding
 520      * exceptions!
 521      *
 522      * @throws RuntimeException if the size is negative or too large
 523      *         for the native size_t type
 524      *
 525      * @throws OutOfMemoryError if the allocation is refused by the system
 526      *
 527      * @see #allocateMemory
 528      */
 529     @ForceInline
 530     public long reallocateMemory(long address, long bytes) {
 531         return theInternalUnsafe.reallocateMemory(address, bytes);
 532     }
 533 
 534     /**
 535      * Sets all bytes in a given block of memory to a fixed value
 536      * (usually zero).
 537      *
 538      * &lt;p&gt;This method determines a block's base address by means of two parameters,
 539      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 540      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 541      * the offset supplies an absolute base address.
 542      *
 543      * &lt;p&gt;The stores are in coherent (atomic) units of a size determined
 544      * by the address and length parameters.  If the effective address and
 545      * length are all even modulo 8, the stores take place in 'long' units.
 546      * If the effective address and length are (resp.) even modulo 4 or 2,
 547      * the stores take place in units of 'int' or 'short'.
 548      *
 549      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 550      * sure arguments are checked before the methods are called. While
 551      * some rudimentary checks are performed on the input, the checks
 552      * are best effort and when performance is an overriding priority,
 553      * as when methods of this class are optimized by the runtime
 554      * compiler, some or all checks (if any) may be elided. Hence, the
 555      * caller must not rely on the checks and corresponding
 556      * exceptions!
 557      *
 558      * @throws RuntimeException if any of the arguments is invalid
 559      *
 560      * @since 1.7
 561      */
 562     @ForceInline
 563     public void setMemory(Object o, long offset, long bytes, byte value) {
 564         theInternalUnsafe.setMemory(o, offset, bytes, value);
 565     }
 566 
 567     /**
 568      * Sets all bytes in a given block of memory to a fixed value
 569      * (usually zero).  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 570      * as discussed in {@link #getInt(Object,long)}.
 571      *
 572      * &lt;p&gt;Equivalent to {@code setMemory(null, address, bytes, value)}.
 573      */
 574     @ForceInline
 575     public void setMemory(long address, long bytes, byte value) {
 576         theInternalUnsafe.setMemory(address, bytes, value);
 577     }
 578 
 579     /**
 580      * Sets all bytes in a given block of memory to a copy of another
 581      * block.
 582      *
 583      * &lt;p&gt;This method determines each block's base address by means of two parameters,
 584      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 585      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 586      * the offset supplies an absolute base address.
 587      *
 588      * &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
 589      * by the address and length parameters.  If the effective addresses and
 590      * length are all even modulo 8, the transfer takes place in 'long' units.
 591      * If the effective addresses and length are (resp.) even modulo 4 or 2,
 592      * the transfer takes place in units of 'int' or 'short'.
 593      *
 594      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 595      * sure arguments are checked before the methods are called. While
 596      * some rudimentary checks are performed on the input, the checks
 597      * are best effort and when performance is an overriding priority,
 598      * as when methods of this class are optimized by the runtime
 599      * compiler, some or all checks (if any) may be elided. Hence, the
 600      * caller must not rely on the checks and corresponding
 601      * exceptions!
 602      *
 603      * @throws RuntimeException if any of the arguments is invalid
 604      *
 605      * @since 1.7
 606      */
 607     @ForceInline
 608     public void copyMemory(Object srcBase, long srcOffset,
 609                            Object destBase, long destOffset,
 610                            long bytes) {
 611         theInternalUnsafe.copyMemory(srcBase, srcOffset, destBase, destOffset, bytes);
 612     }
 613 
 614     /**
 615      * Sets all bytes in a given block of memory to a copy of another
 616      * block.  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 617      * as discussed in {@link #getInt(Object,long)}.
 618      *
 619      * Equivalent to {@code copyMemory(null, srcAddress, null, destAddress, bytes)}.
 620      */
 621     @ForceInline
 622     public void copyMemory(long srcAddress, long destAddress, long bytes) {
 623         theInternalUnsafe.copyMemory(srcAddress, destAddress, bytes);
 624     }
 625 
 626     /**
 627      * Disposes of a block of native memory, as obtained from {@link
 628      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 629      * this method may be null, in which case no action is taken.
 630      *
 631      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 632      * sure arguments are checked before the methods are called. While
 633      * some rudimentary checks are performed on the input, the checks
 634      * are best effort and when performance is an overriding priority,
 635      * as when methods of this class are optimized by the runtime
 636      * compiler, some or all checks (if any) may be elided. Hence, the
 637      * caller must not rely on the checks and corresponding
 638      * exceptions!
 639      *
 640      * @throws RuntimeException if any of the arguments is invalid
 641      *
 642      * @see #allocateMemory
 643      */
 644     @ForceInline
 645     public void freeMemory(long address) {
 646         theInternalUnsafe.freeMemory(address);
 647     }
 648 
 649     /// random queries
 650 
 651     /**
 652      * This constant differs from all results that will ever be returned from
 653      * {@link #staticFieldOffset}, {@link #objectFieldOffset},
 654      * or {@link #arrayBaseOffset}.
 655      */
 656     public static final int INVALID_FIELD_OFFSET = jdk.internal.misc.Unsafe.INVALID_FIELD_OFFSET;
 657 
 658     /**
 659      * Reports the location of a given field in the storage allocation of its
 660      * class.  Do not expect to perform any sort of arithmetic on this offset;
 661      * it is just a cookie which is passed to the unsafe heap memory accessors.
 662      *
 663      * &lt;p&gt;Any given field will always have the same offset and base, and no
 664      * two distinct fields of the same class will ever have the same offset
 665      * and base.
 666      *
 667      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 668      * although the Sun JVM does not use the most significant 32 bits.
 669      * However, JVM implementations which store static fields at absolute
 670      * addresses can use long offsets and null base pointers to express
 671      * the field locations in a form usable by {@link #getInt(Object,long)}.
 672      * Therefore, code which will be ported to such JVMs on 64-bit platforms
 673      * must preserve all bits of static field offsets.
 674      * @see #getInt(Object, long)
 675      */
 676     @ForceInline
 677     public long objectFieldOffset(Field f) {
 678         return theInternalUnsafe.objectFieldOffset(f);
 679     }
 680 
 681     /**
 682      * Reports the location of a given static field, in conjunction with {@link
 683      * #staticFieldBase}.
 684      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
 685      * it is just a cookie which is passed to the unsafe heap memory accessors.
 686      *
 687      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
 688      * fields of the same class will ever have the same offset.
 689      *
 690      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 691      * although the Sun JVM does not use the most significant 32 bits.
 692      * It is hard to imagine a JVM technology which needs more than
 693      * a few bits to encode an offset within a non-array object,
 694      * However, for consistency with other methods in this class,
 695      * this method reports its result as a long value.
 696      * @see #getInt(Object, long)
 697      */
 698     @ForceInline
 699     public long staticFieldOffset(Field f) {
 700         return theInternalUnsafe.staticFieldOffset(f);
 701     }
 702 
 703     /**
 704      * Reports the location of a given static field, in conjunction with {@link
 705      * #staticFieldOffset}.
 706      * &lt;p&gt;Fetch the base "Object", if any, with which static fields of the
 707      * given class can be accessed via methods like {@link #getInt(Object,
 708      * long)}.  This value may be null.  This value may refer to an object
 709      * which is a "cookie", not guaranteed to be a real Object, and it should
 710      * not be used in any way except as argument to the get and put routines in
 711      * this class.
 712      */
 713     @ForceInline
 714     public Object staticFieldBase(Field f) {
 715         return theInternalUnsafe.staticFieldBase(f);
 716     }
 717 
 718     /**
 719      * Detects if the given class may need to be initialized. This is often
 720      * needed in conjunction with obtaining the static field base of a
 721      * class.
 722      * @return false only if a call to {@code ensureClassInitialized} would have no effect
 723      */
 724     @ForceInline
 725     public boolean shouldBeInitialized(Class&lt;?&gt; c) {
 726         return theInternalUnsafe.shouldBeInitialized(c);
 727     }
 728 
 729     /**
 730      * Ensures the given class has been initialized. This is often
 731      * needed in conjunction with obtaining the static field base of a
 732      * class.
 733      */
 734     @ForceInline
 735     public void ensureClassInitialized(Class&lt;?&gt; c) {
 736         theInternalUnsafe.ensureClassInitialized(c);
 737     }
 738 
 739     /**
 740      * Reports the offset of the first element in the storage allocation of a
 741      * given array class.  If {@link #arrayIndexScale} returns a non-zero value
 742      * for the same class, you may use that scale factor, together with this
 743      * base offset, to form new offsets to access elements of arrays of the
 744      * given class.
 745      *
 746      * @see #getInt(Object, long)
 747      * @see #putInt(Object, long, int)
 748      */
 749     @ForceInline
 750     public int arrayBaseOffset(Class&lt;?&gt; arrayClass) {
 751         return theInternalUnsafe.arrayBaseOffset(arrayClass);
 752     }
 753 
 754     /** The value of {@code arrayBaseOffset(boolean[].class)} */
 755     public static final int ARRAY_BOOLEAN_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;
 756 
 757     /** The value of {@code arrayBaseOffset(byte[].class)} */
 758     public static final int ARRAY_BYTE_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;
 759 
 760     /** The value of {@code arrayBaseOffset(short[].class)} */
 761     public static final int ARRAY_SHORT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_SHORT_BASE_OFFSET;
 762 
 763     /** The value of {@code arrayBaseOffset(char[].class)} */
 764     public static final int ARRAY_CHAR_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_CHAR_BASE_OFFSET;
 765 
 766     /** The value of {@code arrayBaseOffset(int[].class)} */
 767     public static final int ARRAY_INT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_INT_BASE_OFFSET;
 768 
 769     /** The value of {@code arrayBaseOffset(long[].class)} */
 770     public static final int ARRAY_LONG_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_LONG_BASE_OFFSET;
 771 
 772     /** The value of {@code arrayBaseOffset(float[].class)} */
 773     public static final int ARRAY_FLOAT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_FLOAT_BASE_OFFSET;
 774 
 775     /** The value of {@code arrayBaseOffset(double[].class)} */
 776     public static final int ARRAY_DOUBLE_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_DOUBLE_BASE_OFFSET;
 777 
 778     /** The value of {@code arrayBaseOffset(Object[].class)} */
 779     public static final int ARRAY_OBJECT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_OBJECT_BASE_OFFSET;
 780 
 781     /**
 782      * Reports the scale factor for addressing elements in the storage
 783      * allocation of a given array class.  However, arrays of "narrow" types
 784      * will generally not work properly with accessors like {@link
 785      * #getByte(Object, long)}, so the scale factor for such classes is reported
 786      * as zero.
 787      *
 788      * @see #arrayBaseOffset
 789      * @see #getInt(Object, long)
 790      * @see #putInt(Object, long, int)
 791      */
 792     @ForceInline
 793     public int arrayIndexScale(Class&lt;?&gt; arrayClass) {
 794         return theInternalUnsafe.arrayIndexScale(arrayClass);
 795     }
 796 
 797     /** The value of {@code arrayIndexScale(boolean[].class)} */
 798     public static final int ARRAY_BOOLEAN_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_BOOLEAN_INDEX_SCALE;
 799 
 800     /** The value of {@code arrayIndexScale(byte[].class)} */
 801     public static final int ARRAY_BYTE_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_BYTE_INDEX_SCALE;
 802 
 803     /** The value of {@code arrayIndexScale(short[].class)} */
 804     public static final int ARRAY_SHORT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_SHORT_INDEX_SCALE;
 805 
 806     /** The value of {@code arrayIndexScale(char[].class)} */
 807     public static final int ARRAY_CHAR_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_CHAR_INDEX_SCALE;
 808 
 809     /** The value of {@code arrayIndexScale(int[].class)} */
 810     public static final int ARRAY_INT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_INT_INDEX_SCALE;
 811 
 812     /** The value of {@code arrayIndexScale(long[].class)} */
 813     public static final int ARRAY_LONG_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_LONG_INDEX_SCALE;
 814 
 815     /** The value of {@code arrayIndexScale(float[].class)} */
 816     public static final int ARRAY_FLOAT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_FLOAT_INDEX_SCALE;
 817 
 818     /** The value of {@code arrayIndexScale(double[].class)} */
 819     public static final int ARRAY_DOUBLE_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_DOUBLE_INDEX_SCALE;
 820 
 821     /** The value of {@code arrayIndexScale(Object[].class)} */
 822     public static final int ARRAY_OBJECT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_OBJECT_INDEX_SCALE;
 823 
 824     /**
 825      * Reports the size in bytes of a native pointer, as stored via {@link
 826      * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
 827      * other primitive types (as stored in native memory blocks) is determined
 828      * fully by their information content.
 829      */
 830     @ForceInline
 831     public int addressSize() {
 832         return theInternalUnsafe.addressSize();
 833     }
 834 
 835     /** The value of {@code addressSize()} */
 836     public static final int ADDRESS_SIZE = theInternalUnsafe.addressSize();
 837 
 838     /**
 839      * Reports the size in bytes of a native memory page (whatever that is).
 840      * This value will always be a power of two.
 841      */
 842     @ForceInline
 843     public int pageSize() {
 844         return theInternalUnsafe.pageSize();
 845     }
 846 
 847 
 848     /// random trusted operations from JNI:
 849 
 850     /**
 851      * Tells the VM to define a class, without security checks.  By default, the
 852      * class loader and protection domain come from the caller's class.
 853      */
 854     @ForceInline
 855     public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,
 856                                 ClassLoader loader,
 857                                 ProtectionDomain protectionDomain) {
 858         return theInternalUnsafe.defineClass(name, b, off, len, loader, protectionDomain);
 859     }
 860 
 861     /**
 862      * Defines a class but does not make it known to the class loader or system dictionary.
 863      * &lt;p&gt;
 864      * For each CP entry, the corresponding CP patch must either be null or have
 865      * the a format that matches its tag:
 866      * &lt;ul&gt;
 867      * &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
 868      * &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
 869      * &lt;li&gt;Class: any java.lang.Class object
 870      * &lt;li&gt;String: any object (not just a java.lang.String)
 871      * &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments
 872      * &lt;/ul&gt;
 873      * @param hostClass context for linkage, access control, protection domain, and class loader
 874      * @param data      bytes of a class file
 875      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
 876      */
 877     @ForceInline
 878     public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches) {
 879         return theInternalUnsafe.defineAnonymousClass(hostClass, data, cpPatches);
 880     }
 881 
 882     /**
 883      * Allocates an instance but does not run any constructor.
 884      * Initializes the class if it has not yet been.
 885      */
 886     @ForceInline
 887     public Object allocateInstance(Class&lt;?&gt; cls)
 888         throws InstantiationException {
 889         return theInternalUnsafe.allocateInstance(cls);
 890     }
 891 
 892     /** Throws the exception without telling the verifier. */
 893     @ForceInline
 894     public void throwException(Throwable ee) {
 895         theInternalUnsafe.throwException(ee);
 896     }
 897 
 898     /**
 899      * Atomically updates Java variable to {@code x} if it is currently
 900      * holding {@code expected}.
 901      *
 902      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 903      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 904      *
 905      * @return {@code true} if successful
 906      */
 907     @ForceInline
 908     public final boolean compareAndSwapObject(Object o, long offset,
 909                                               Object expected,
 910                                               Object x) {
 911         return theInternalUnsafe.compareAndSwapObject(o, offset, expected, x);
 912     }
 913 
 914     /**
 915      * Atomically updates Java variable to {@code x} if it is currently
 916      * holding {@code expected}.
 917      *
 918      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 919      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 920      *
 921      * @return {@code true} if successful
 922      */
 923     @ForceInline
 924     public final boolean compareAndSwapInt(Object o, long offset,
 925                                            int expected,
 926                                            int x) {
 927         return theInternalUnsafe.compareAndSwapInt(o, offset, expected, x);
 928     }
 929 
 930     /**
 931      * Atomically updates Java variable to {@code x} if it is currently
 932      * holding {@code expected}.
 933      *
 934      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 935      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 936      *
 937      * @return {@code true} if successful
 938      */
 939     @ForceInline
 940     public final boolean compareAndSwapLong(Object o, long offset,
 941                                             long expected,
 942                                             long x) {
 943         return theInternalUnsafe.compareAndSwapLong(o, offset, expected, x);
 944     }
 945 
 946     /**
 947      * Fetches a reference value from a given Java variable, with volatile
 948      * load semantics. Otherwise identical to {@link #getObject(Object, long)}
 949      */
 950     @ForceInline
 951     public Object getObjectVolatile(Object o, long offset) {
 952         return theInternalUnsafe.getObjectVolatile(o, offset);
 953     }
 954 
 955     /**
 956      * Stores a reference value into a given Java variable, with
 957      * volatile store semantics. Otherwise identical to {@link #putObject(Object, long, Object)}
 958      */
 959     @ForceInline
 960     public void putObjectVolatile(Object o, long offset, Object x) {
 961         theInternalUnsafe.putObjectVolatile(o, offset, x);
 962     }
 963 
 964     /** Volatile version of {@link #getInt(Object, long)}  */
 965     @ForceInline
 966     public int getIntVolatile(Object o, long offset) {
 967         return theInternalUnsafe.getIntVolatile(o, offset);
 968     }
 969 
 970     /** Volatile version of {@link #putInt(Object, long, int)}  */
 971     @ForceInline
 972     public void putIntVolatile(Object o, long offset, int x) {
 973         theInternalUnsafe.putIntVolatile(o, offset, x);
 974     }
 975 
 976     /** Volatile version of {@link #getBoolean(Object, long)}  */
 977     @ForceInline
 978     public boolean getBooleanVolatile(Object o, long offset) {
 979         return theInternalUnsafe.getBooleanVolatile(o, offset);
 980     }
 981 
 982     /** Volatile version of {@link #putBoolean(Object, long, boolean)}  */
 983     @ForceInline
 984     public void putBooleanVolatile(Object o, long offset, boolean x) {
 985         theInternalUnsafe.putBooleanVolatile(o, offset, x);
 986     }
 987 
 988     /** Volatile version of {@link #getByte(Object, long)}  */
 989     @ForceInline
 990     public byte getByteVolatile(Object o, long offset) {
 991         return theInternalUnsafe.getByteVolatile(o, offset);
 992     }
 993 
 994     /** Volatile version of {@link #putByte(Object, long, byte)}  */
 995     @ForceInline
 996     public void putByteVolatile(Object o, long offset, byte x) {
 997         theInternalUnsafe.putByteVolatile(o, offset, x);
 998     }
 999 
1000     /** Volatile version of {@link #getShort(Object, long)}  */
1001     @ForceInline
1002     public short getShortVolatile(Object o, long offset) {
1003         return theInternalUnsafe.getShortVolatile(o, offset);
1004     }
1005 
1006     /** Volatile version of {@link #putShort(Object, long, short)}  */
1007     @ForceInline
1008     public void putShortVolatile(Object o, long offset, short x) {
1009         theInternalUnsafe.putShortVolatile(o, offset, x);
1010     }
1011 
1012     /** Volatile version of {@link #getChar(Object, long)}  */
1013     @ForceInline
1014     public char getCharVolatile(Object o, long offset) {
1015         return theInternalUnsafe.getCharVolatile(o, offset);
1016     }
1017 
1018     /** Volatile version of {@link #putChar(Object, long, char)}  */
1019     @ForceInline
1020     public void putCharVolatile(Object o, long offset, char x) {
1021         theInternalUnsafe.putCharVolatile(o, offset, x);
1022     }
1023 
1024     /** Volatile version of {@link #getLong(Object, long)}  */
1025     @ForceInline
1026     public long getLongVolatile(Object o, long offset) {
1027         return theInternalUnsafe.getLongVolatile(o, offset);
1028     }
1029 
1030     /** Volatile version of {@link #putLong(Object, long, long)}  */
1031     @ForceInline
1032     public void putLongVolatile(Object o, long offset, long x) {
1033         theInternalUnsafe.putLongVolatile(o, offset, x);
1034     }
1035 
1036     /** Volatile version of {@link #getFloat(Object, long)}  */
1037     @ForceInline
1038     public float getFloatVolatile(Object o, long offset) {
1039         return theInternalUnsafe.getFloatVolatile(o, offset);
1040     }
1041 
1042     /** Volatile version of {@link #putFloat(Object, long, float)}  */
1043     @ForceInline
1044     public void putFloatVolatile(Object o, long offset, float x) {
1045         theInternalUnsafe.putFloatVolatile(o, offset, x);
1046     }
1047 
1048     /** Volatile version of {@link #getDouble(Object, long)}  */
1049     @ForceInline
1050     public double getDoubleVolatile(Object o, long offset) {
1051         return theInternalUnsafe.getDoubleVolatile(o, offset);
1052     }
1053 
1054     /** Volatile version of {@link #putDouble(Object, long, double)}  */
1055     @ForceInline
1056     public void putDoubleVolatile(Object o, long offset, double x) {
1057         theInternalUnsafe.putDoubleVolatile(o, offset, x);
1058     }
1059 
1060     /**
1061      * Version of {@link #putObjectVolatile(Object, long, Object)}
1062      * that does not guarantee immediate visibility of the store to
1063      * other threads. This method is generally only useful if the
1064      * underlying field is a Java volatile (or if an array cell, one
1065      * that is otherwise only accessed using volatile accesses).
1066      *
1067      * Corresponds to C11 atomic_store_explicit(..., memory_order_release).
1068      */
1069     @ForceInline
1070     public void putOrderedObject(Object o, long offset, Object x) {
1071         theInternalUnsafe.putObjectRelease(o, offset, x);
1072     }
1073 
1074     /** Ordered/Lazy version of {@link #putIntVolatile(Object, long, int)}  */
1075     @ForceInline
1076     public void putOrderedInt(Object o, long offset, int x) {
1077         theInternalUnsafe.putIntRelease(o, offset, x);
1078     }
1079 
1080     /** Ordered/Lazy version of {@link #putLongVolatile(Object, long, long)} */
1081     @ForceInline
1082     public void putOrderedLong(Object o, long offset, long x) {
1083         theInternalUnsafe.putLongRelease(o, offset, x);
1084     }
1085 
1086     /**
1087      * Unblocks the given thread blocked on {@code park}, or, if it is
1088      * not blocked, causes the subsequent call to {@code park} not to
1089      * block.  Note: this operation is "unsafe" solely because the
1090      * caller must somehow ensure that the thread has not been
1091      * destroyed. Nothing special is usually required to ensure this
1092      * when called from Java (in which there will ordinarily be a live
1093      * reference to the thread) but this is not nearly-automatically
1094      * so when calling from native code.
1095      *
1096      * @param thread the thread to unpark.
1097      */
1098     @ForceInline
1099     public void unpark(Object thread) {
1100         theInternalUnsafe.unpark(thread);
1101     }
1102 
1103     /**
1104      * Blocks current thread, returning when a balancing
1105      * {@code unpark} occurs, or a balancing {@code unpark} has
1106      * already occurred, or the thread is interrupted, or, if not
1107      * absolute and time is not zero, the given time nanoseconds have
1108      * elapsed, or if absolute, the given deadline in milliseconds
1109      * since Epoch has passed, or spuriously (i.e., returning for no
1110      * "reason"). Note: This operation is in the Unsafe class only
1111      * because {@code unpark} is, so it would be strange to place it
1112      * elsewhere.
1113      */
1114     @ForceInline
1115     public void park(boolean isAbsolute, long time) {
1116         theInternalUnsafe.park(isAbsolute, time);
1117     }
1118 
1119     /**
1120      * Gets the load average in the system run queue assigned
1121      * to the available processors averaged over various periods of time.
1122      * This method retrieves the given {@code nelem} samples and
1123      * assigns to the elements of the given {@code loadavg} array.
1124      * The system imposes a maximum of 3 samples, representing
1125      * averages over the last 1,  5,  and  15 minutes, respectively.
1126      *
1127      * @param loadavg an array of double of size nelems
1128      * @param nelems the number of samples to be retrieved and
1129      *        must be 1 to 3.
1130      *
1131      * @return the number of samples actually retrieved; or -1
1132      *         if the load average is unobtainable.
1133      */
1134     @ForceInline
1135     public int getLoadAverage(double[] loadavg, int nelems) {
1136         return theInternalUnsafe.getLoadAverage(loadavg, nelems);
1137     }
1138 
1139     // The following contain CAS-based Java implementations used on
1140     // platforms not supporting native instructions
1141 
1142     /**
1143      * Atomically adds the given value to the current value of a field
1144      * or array element within the given object {@code o}
1145      * at the given {@code offset}.
1146      *
1147      * @param o object/array to update the field/element in
1148      * @param offset field/element offset
1149      * @param delta the value to add
1150      * @return the previous value
1151      * @since 1.8
1152      */
1153     @ForceInline
1154     public final int getAndAddInt(Object o, long offset, int delta) {
1155         return theInternalUnsafe.getAndAddInt(o, offset, delta);
1156     }
1157 
1158     /**
1159      * Atomically adds the given value to the current value of a field
1160      * or array element within the given object {@code o}
1161      * at the given {@code offset}.
1162      *
1163      * @param o object/array to update the field/element in
1164      * @param offset field/element offset
1165      * @param delta the value to add
1166      * @return the previous value
1167      * @since 1.8
1168      */
1169     @ForceInline
1170     public final long getAndAddLong(Object o, long offset, long delta) {
1171         return theInternalUnsafe.getAndAddLong(o, offset, delta);
1172     }
1173 
1174     /**
1175      * Atomically exchanges the given value with the current value of
1176      * a field or array element within the given object {@code o}
1177      * at the given {@code offset}.
1178      *
1179      * @param o object/array to update the field/element in
1180      * @param offset field/element offset
1181      * @param newValue new value
1182      * @return the previous value
1183      * @since 1.8
1184      */
1185     @ForceInline
1186     public final int getAndSetInt(Object o, long offset, int newValue) {
1187         return theInternalUnsafe.getAndSetInt(o, offset, newValue);
1188     }
1189 
1190     /**
1191      * Atomically exchanges the given value with the current value of
1192      * a field or array element within the given object {@code o}
1193      * at the given {@code offset}.
1194      *
1195      * @param o object/array to update the field/element in
1196      * @param offset field/element offset
1197      * @param newValue new value
1198      * @return the previous value
1199      * @since 1.8
1200      */
1201     @ForceInline
1202     public final long getAndSetLong(Object o, long offset, long newValue) {
1203         return theInternalUnsafe.getAndSetLong(o, offset, newValue);
1204     }
1205 
1206     /**
1207      * Atomically exchanges the given reference value with the current
1208      * reference value of a field or array element within the given
1209      * object {@code o} at the given {@code offset}.
1210      *
1211      * @param o object/array to update the field/element in
1212      * @param offset field/element offset
1213      * @param newValue new value
1214      * @return the previous value
1215      * @since 1.8
1216      */
1217     @ForceInline
1218     public final Object getAndSetObject(Object o, long offset, Object newValue) {
1219         return theInternalUnsafe.getAndSetObject(o, offset, newValue);
1220     }
1221 
1222 
1223     /**
1224      * Ensures that loads before the fence will not be reordered with loads and
1225      * stores after the fence; a "LoadLoad plus LoadStore barrier".
1226      *
1227      * Corresponds to C11 atomic_thread_fence(memory_order_acquire)
1228      * (an "acquire fence").
1229      *
1230      * A pure LoadLoad fence is not provided, since the addition of LoadStore
1231      * is almost always desired, and most current hardware instructions that
1232      * provide a LoadLoad barrier also provide a LoadStore barrier for free.
1233      * @since 1.8
1234      */
1235     @ForceInline
1236     public void loadFence() {
1237         theInternalUnsafe.loadFence();
1238     }
1239 
1240     /**
1241      * Ensures that loads and stores before the fence will not be reordered with
1242      * stores after the fence; a "StoreStore plus LoadStore barrier".
1243      *
1244      * Corresponds to C11 atomic_thread_fence(memory_order_release)
1245      * (a "release fence").
1246      *
1247      * A pure StoreStore fence is not provided, since the addition of LoadStore
1248      * is almost always desired, and most current hardware instructions that
1249      * provide a StoreStore barrier also provide a LoadStore barrier for free.
1250      * @since 1.8
1251      */
1252     @ForceInline
1253     public void storeFence() {
1254         theInternalUnsafe.storeFence();
1255     }
1256 
1257     /**
1258      * Ensures that loads and stores before the fence will not be reordered
1259      * with loads and stores after the fence.  Implies the effects of both
1260      * loadFence() and storeFence(), and in addition, the effect of a StoreLoad
1261      * barrier.
1262      *
1263      * Corresponds to C11 atomic_thread_fence(memory_order_seq_cst).
1264      * @since 1.8
1265      */
1266     @ForceInline
1267     public void fullFence() {
1268         theInternalUnsafe.fullFence();
1269     }
1270 }
</pre></body></html>
