<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/jdk.unsupported/share/classes/sun/misc/Unsafe.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.misc;
  27 
  28 import jdk.internal.vm.annotation.ForceInline;
  29 import jdk.internal.misc.VM;
  30 import jdk.internal.reflect.CallerSensitive;
  31 import jdk.internal.reflect.Reflection;
  32 
  33 import java.lang.reflect.Field;
  34 import java.security.ProtectionDomain;
  35 
  36 
  37 /**
  38  * A collection of methods for performing low-level, unsafe operations.
  39  * Although the class and all methods are public, use of this class is
  40  * limited because only trusted code can obtain instances of it.
  41  *
  42  * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make sure
  43  * arguments are checked before methods of this class are
  44  * called. While some rudimentary checks are performed on the input,
  45  * the checks are best effort and when performance is an overriding
  46  * priority, as when methods of this class are optimized by the
  47  * runtime compiler, some or all checks (if any) may be elided. Hence,
  48  * the caller must not rely on the checks and corresponding
  49  * exceptions!
  50  *
  51  * @author John R. Rose
  52  * @see #getUnsafe
  53  */
  54 
  55 public final class Unsafe {
  56 
  57     static {
  58         Reflection.registerMethodsToFilter(Unsafe.class, "getUnsafe");
  59     }
  60 
  61     private Unsafe() {}
  62 
  63     private static final Unsafe theUnsafe = new Unsafe();
  64     private static final jdk.internal.misc.Unsafe theInternalUnsafe = jdk.internal.misc.Unsafe.getUnsafe();
  65 
  66     /**
  67      * Provides the caller with the capability of performing unsafe
  68      * operations.
  69      *
  70      * &lt;p&gt;The returned {@code Unsafe} object should be carefully guarded
  71      * by the caller, since it can be used to read and write data at arbitrary
  72      * memory addresses.  It must never be passed to untrusted code.
  73      *
  74      * &lt;p&gt;Most methods in this class are very low-level, and correspond to a
  75      * small number of hardware instructions (on typical machines).  Compilers
  76      * are encouraged to optimize these methods accordingly.
  77      *
  78      * &lt;p&gt;Here is a suggested idiom for using unsafe operations:
  79      *
  80      * &lt;pre&gt; {@code
  81      * class MyTrustedClass {
  82      *   private static final Unsafe unsafe = Unsafe.getUnsafe();
  83      *   ...
  84      *   private long myCountAddress = ...;
  85      *   public int getCount() { return unsafe.getByte(myCountAddress); }
  86      * }}&lt;/pre&gt;
  87      *
  88      * (It may assist compilers to make the local variable {@code final}.)
  89      *
  90      * @throws  SecurityException  if a security manager exists and its
  91      *          {@code checkPropertiesAccess} method doesn't allow
  92      *          access to the system properties.
  93      */
  94     @CallerSensitive
  95     public static Unsafe getUnsafe() {
  96         Class&lt;?&gt; caller = Reflection.getCallerClass();
  97         if (!VM.isSystemDomainLoader(caller.getClassLoader()))
  98             throw new SecurityException("Unsafe");
  99         return theUnsafe;
 100     }
 101 
 102     /// peek and poke operations
 103     /// (compilers should optimize these to memory ops)
 104 
 105     // These work on object fields in the Java heap.
 106     // They will not work on elements of packed arrays.
 107 
 108     /**
 109      * Fetches a value from a given Java variable.
 110      * More specifically, fetches a field or array element within the given
 111      * object {@code o} at the given offset, or (if {@code o} is null)
 112      * from the memory address whose numerical value is the given offset.
 113      * &lt;p&gt;
 114      * The results are undefined unless one of the following cases is true:
 115      * &lt;ul&gt;
 116      * &lt;li&gt;The offset was obtained from {@link #objectFieldOffset} on
 117      * the {@link java.lang.reflect.Field} of some Java field and the object
 118      * referred to by {@code o} is of a class compatible with that
 119      * field's class.
 120      *
 121      * &lt;li&gt;The offset and object reference {@code o} (either null or
 122      * non-null) were both obtained via {@link #staticFieldOffset}
 123      * and {@link #staticFieldBase} (respectively) from the
 124      * reflective {@link Field} representation of some Java field.
 125      *
 126      * &lt;li&gt;The object referred to by {@code o} is an array, and the offset
 127      * is an integer of the form {@code B+N*S}, where {@code N} is
 128      * a valid index into the array, and {@code B} and {@code S} are
 129      * the values obtained by {@link #arrayBaseOffset} and {@link
 130      * #arrayIndexScale} (respectively) from the array's class.  The value
 131      * referred to is the {@code N}&lt;em&gt;th&lt;/em&gt; element of the array.
 132      *
 133      * &lt;/ul&gt;
 134      * &lt;p&gt;
 135      * If one of the above cases is true, the call references a specific Java
 136      * variable (field or array element).  However, the results are undefined
 137      * if that variable is not in fact of the type returned by this method.
 138      * &lt;p&gt;
 139      * This method refers to a variable by means of two parameters, and so
 140      * it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode
 141      * for Java variables.  When the object reference is null, this method
 142      * uses its offset as an absolute address.  This is similar in operation
 143      * to methods such as {@link #getInt(long)}, which provide (in effect) a
 144      * &lt;em&gt;single-register&lt;/em&gt; addressing mode for non-Java variables.
 145      * However, because Java variables may have a different layout in memory
 146      * from non-Java variables, programmers should not assume that these
 147      * two addressing modes are ever equivalent.  Also, programmers should
 148      * remember that offsets from the double-register addressing mode cannot
 149      * be portably confused with longs used in the single-register addressing
 150      * mode.
 151      *
 152      * @param o Java heap object in which the variable resides, if any, else
 153      *        null
 154      * @param offset indication of where the variable resides in a Java heap
 155      *        object, if any, else a memory address locating the variable
 156      *        statically
 157      * @return the value fetched from the indicated Java variable
 158      * @throws RuntimeException No defined exceptions are thrown, not even
 159      *         {@link NullPointerException}
 160      */
 161     @ForceInline
 162     public int getInt(Object o, long offset) {
 163         return theInternalUnsafe.getInt(o, offset);
 164     }
 165 
 166     /**
 167      * Stores a value into a given Java variable.
 168      * &lt;p&gt;
 169      * The first two parameters are interpreted exactly as with
 170      * {@link #getInt(Object, long)} to refer to a specific
 171      * Java variable (field or array element).  The given value
 172      * is stored into that variable.
 173      * &lt;p&gt;
 174      * The variable must be of the same type as the method
 175      * parameter {@code x}.
 176      *
 177      * @param o Java heap object in which the variable resides, if any, else
 178      *        null
 179      * @param offset indication of where the variable resides in a Java heap
 180      *        object, if any, else a memory address locating the variable
 181      *        statically
 182      * @param x the value to store into the indicated Java variable
 183      * @throws RuntimeException No defined exceptions are thrown, not even
 184      *         {@link NullPointerException}
 185      */
 186     @ForceInline
 187     public void putInt(Object o, long offset, int x) {
 188         theInternalUnsafe.putInt(o, offset, x);
 189     }
 190 
 191     /**
 192      * Fetches a reference value from a given Java variable.
 193      * @see #getInt(Object, long)
 194      */
 195     @ForceInline
 196     public Object getObject(Object o, long offset) {
 197         return theInternalUnsafe.getObject(o, offset);
 198     }
 199 
 200     /**
 201      * Stores a reference value into a given Java variable.
 202      * &lt;p&gt;
 203      * Unless the reference {@code x} being stored is either null
 204      * or matches the field type, the results are undefined.
 205      * If the reference {@code o} is non-null, card marks or
 206      * other store barriers for that object (if the VM requires them)
 207      * are updated.
 208      * @see #putInt(Object, long, int)
 209      */
 210     @ForceInline
 211     public void putObject(Object o, long offset, Object x) {
 212         theInternalUnsafe.putObject(o, offset, x);
 213     }
 214 
 215     /** @see #getInt(Object, long) */
 216     @ForceInline
 217     public boolean getBoolean(Object o, long offset) {
 218         return theInternalUnsafe.getBoolean(o, offset);
 219     }
 220 
 221     /** @see #putInt(Object, long, int) */
 222     @ForceInline
 223     public void putBoolean(Object o, long offset, boolean x) {
 224         theInternalUnsafe.putBoolean(o, offset, x);
 225     }
 226 
 227     /** @see #getInt(Object, long) */
 228     @ForceInline
 229     public byte getByte(Object o, long offset) {
 230         return theInternalUnsafe.getByte(o, offset);
 231     }
 232 
 233     /** @see #putInt(Object, long, int) */
 234     @ForceInline
 235     public void putByte(Object o, long offset, byte x) {
 236         theInternalUnsafe.putByte(o, offset, x);
 237     }
 238 
 239     /** @see #getInt(Object, long) */
 240     @ForceInline
 241     public short getShort(Object o, long offset) {
 242         return theInternalUnsafe.getShort(o, offset);
 243     }
 244 
 245     /** @see #putInt(Object, long, int) */
 246     @ForceInline
 247     public void putShort(Object o, long offset, short x) {
 248         theInternalUnsafe.putShort(o, offset, x);
 249     }
 250 
 251     /** @see #getInt(Object, long) */
 252     @ForceInline
 253     public char getChar(Object o, long offset) {
 254         return theInternalUnsafe.getChar(o, offset);
 255     }
 256 
 257     /** @see #putInt(Object, long, int) */
 258     @ForceInline
 259     public void putChar(Object o, long offset, char x) {
 260         theInternalUnsafe.putChar(o, offset, x);
 261     }
 262 
 263     /** @see #getInt(Object, long) */
 264     @ForceInline
 265     public long getLong(Object o, long offset) {
 266         return theInternalUnsafe.getLong(o, offset);
 267     }
 268 
 269     /** @see #putInt(Object, long, int) */
 270     @ForceInline
 271     public void putLong(Object o, long offset, long x) {
 272         theInternalUnsafe.putLong(o, offset, x);
 273     }
 274 
 275     /** @see #getInt(Object, long) */
 276     @ForceInline
 277     public float getFloat(Object o, long offset) {
 278         return theInternalUnsafe.getFloat(o, offset);
 279     }
 280 
 281     /** @see #putInt(Object, long, int) */
 282     @ForceInline
 283     public void putFloat(Object o, long offset, float x) {
 284         theInternalUnsafe.putFloat(o, offset, x);
 285     }
 286 
 287     /** @see #getInt(Object, long) */
 288     @ForceInline
 289     public double getDouble(Object o, long offset) {
 290         return theInternalUnsafe.getDouble(o, offset);
 291     }
 292 
 293     /** @see #putInt(Object, long, int) */
 294     @ForceInline
 295     public void putDouble(Object o, long offset, double x) {
 296         theInternalUnsafe.putDouble(o, offset, x);
 297     }
 298 
 299 
 300     // These read VM internal data.
 301 
 302     /**
 303      * Fetches an uncompressed reference value from a given native variable
 304      * ignoring the VM's compressed references mode.
 305      *
 306      * @param address a memory address locating the variable
 307      * @return the value fetched from the indicated native variable
 308      */
 309     @ForceInline
 310     public Object getUncompressedObject(long address) {
 311         return theInternalUnsafe.getUncompressedObject(address);
 312     }
 313 
 314     // These work on values in the C heap.
 315 
 316     /**
 317      * Fetches a value from a given memory address.  If the address is zero, or
 318      * does not point into a block obtained from {@link #allocateMemory}, the
 319      * results are undefined.
 320      *
 321      * @see #allocateMemory
 322      */
 323     @ForceInline
 324     public byte getByte(long address) {
 325         return theInternalUnsafe.getByte(address);
 326     }
 327 
 328     /**
 329      * Stores a value into a given memory address.  If the address is zero, or
 330      * does not point into a block obtained from {@link #allocateMemory}, the
 331      * results are undefined.
 332      *
 333      * @see #getByte(long)
 334      */
 335     @ForceInline
 336     public void putByte(long address, byte x) {
 337         theInternalUnsafe.putByte(address, x);
 338     }
 339 
 340     /** @see #getByte(long) */
 341     @ForceInline
 342     public short getShort(long address) {
 343         return theInternalUnsafe.getShort(address);
 344     }
 345 
 346     /** @see #putByte(long, byte) */
 347     @ForceInline
 348     public void putShort(long address, short x) {
 349         theInternalUnsafe.putShort(address, x);
 350     }
 351 
 352     /** @see #getByte(long) */
 353     @ForceInline
 354     public char getChar(long address) {
 355         return theInternalUnsafe.getChar(address);
 356     }
 357 
 358     /** @see #putByte(long, byte) */
 359     @ForceInline
 360     public void putChar(long address, char x) {
 361         theInternalUnsafe.putChar(address, x);
 362     }
 363 
 364     /** @see #getByte(long) */
 365     @ForceInline
 366     public int getInt(long address) {
 367         return theInternalUnsafe.getInt(address);
 368     }
 369 
 370     /** @see #putByte(long, byte) */
 371     @ForceInline
 372     public void putInt(long address, int x) {
 373         theInternalUnsafe.putInt(address, x);
 374     }
 375 
 376     /** @see #getByte(long) */
 377     @ForceInline
 378     public long getLong(long address) {
 379         return theInternalUnsafe.getLong(address);
 380     }
 381 
 382     /** @see #putByte(long, byte) */
 383     @ForceInline
 384     public void putLong(long address, long x) {
 385         theInternalUnsafe.putLong(address, x);
 386     }
 387 
 388     /** @see #getByte(long) */
 389     @ForceInline
 390     public float getFloat(long address) {
 391         return theInternalUnsafe.getFloat(address);
 392     }
 393 
 394     /** @see #putByte(long, byte) */
 395     @ForceInline
 396     public void putFloat(long address, float x) {
 397         theInternalUnsafe.putFloat(address, x);
 398     }
 399 
 400     /** @see #getByte(long) */
 401     @ForceInline
 402     public double getDouble(long address) {
 403         return theInternalUnsafe.getDouble(address);
 404     }
 405 
 406     /** @see #putByte(long, byte) */
 407     @ForceInline
 408     public void putDouble(long address, double x) {
 409         theInternalUnsafe.putDouble(address, x);
 410     }
 411 
 412 
 413     /**
 414      * Fetches a native pointer from a given memory address.  If the address is
 415      * zero, or does not point into a block obtained from {@link
 416      * #allocateMemory}, the results are undefined.
 417      *
 418      * &lt;p&gt;If the native pointer is less than 64 bits wide, it is extended as
 419      * an unsigned number to a Java long.  The pointer may be indexed by any
 420      * given byte offset, simply by adding that offset (as a simple integer) to
 421      * the long representing the pointer.  The number of bytes actually read
 422      * from the target address may be determined by consulting {@link
 423      * #addressSize}.
 424      *
 425      * @see #allocateMemory
 426      */
 427     @ForceInline
 428     public long getAddress(long address) {
 429         return theInternalUnsafe.getAddress(address);
 430     }
 431 
 432     /**
 433      * Stores a native pointer into a given memory address.  If the address is
 434      * zero, or does not point into a block obtained from {@link
 435      * #allocateMemory}, the results are undefined.
 436      *
 437      * &lt;p&gt;The number of bytes actually written at the target address may be
 438      * determined by consulting {@link #addressSize}.
 439      *
 440      * @see #getAddress(long)
 441      */
 442     @ForceInline
 443     public void putAddress(long address, long x) {
 444         theInternalUnsafe.putAddress(address, x);
 445     }
 446 
 447 
 448     /// wrappers for malloc, realloc, free:
 449 
 450     /**
 451      * Allocates a new block of native memory, of the given size in bytes.  The
 452      * contents of the memory are uninitialized; they will generally be
 453      * garbage.  The resulting native pointer will never be zero, and will be
 454      * aligned for all value types.  Dispose of this memory by calling {@link
 455      * #freeMemory}, or resize it with {@link #reallocateMemory}.
 456      *
 457      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 458      * sure arguments are checked before the methods are called. While
 459      * some rudimentary checks are performed on the input, the checks
 460      * are best effort and when performance is an overriding priority,
 461      * as when methods of this class are optimized by the runtime
 462      * compiler, some or all checks (if any) may be elided. Hence, the
 463      * caller must not rely on the checks and corresponding
 464      * exceptions!
 465      *
 466      * @throws RuntimeException if the size is negative or too large
 467      *         for the native size_t type
 468      *
 469      * @throws OutOfMemoryError if the allocation is refused by the system
 470      *
 471      * @see #getByte(long)
 472      * @see #putByte(long, byte)
 473      */
 474     @ForceInline
 475     public long allocateMemory(long bytes) {
 476         return theInternalUnsafe.allocateMemory(bytes);
 477     }
 478 
 479     /**
 480      * Resizes a new block of native memory, to the given size in bytes.  The
 481      * contents of the new block past the size of the old block are
 482      * uninitialized; they will generally be garbage.  The resulting native
 483      * pointer will be zero if and only if the requested size is zero.  The
 484      * resulting native pointer will be aligned for all value types.  Dispose
 485      * of this memory by calling {@link #freeMemory}, or resize it with {@link
 486      * #reallocateMemory}.  The address passed to this method may be null, in
 487      * which case an allocation will be performed.
 488      *
 489      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 490      * sure arguments are checked before the methods are called. While
 491      * some rudimentary checks are performed on the input, the checks
 492      * are best effort and when performance is an overriding priority,
 493      * as when methods of this class are optimized by the runtime
 494      * compiler, some or all checks (if any) may be elided. Hence, the
 495      * caller must not rely on the checks and corresponding
 496      * exceptions!
 497      *
 498      * @throws RuntimeException if the size is negative or too large
 499      *         for the native size_t type
 500      *
 501      * @throws OutOfMemoryError if the allocation is refused by the system
 502      *
 503      * @see #allocateMemory
 504      */
 505     @ForceInline
 506     public long reallocateMemory(long address, long bytes) {
 507         return theInternalUnsafe.reallocateMemory(address, bytes);
 508     }
 509 
 510     /**
 511      * Sets all bytes in a given block of memory to a fixed value
 512      * (usually zero).
 513      *
 514      * &lt;p&gt;This method determines a block's base address by means of two parameters,
 515      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 516      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 517      * the offset supplies an absolute base address.
 518      *
 519      * &lt;p&gt;The stores are in coherent (atomic) units of a size determined
 520      * by the address and length parameters.  If the effective address and
 521      * length are all even modulo 8, the stores take place in 'long' units.
 522      * If the effective address and length are (resp.) even modulo 4 or 2,
 523      * the stores take place in units of 'int' or 'short'.
 524      *
 525      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 526      * sure arguments are checked before the methods are called. While
 527      * some rudimentary checks are performed on the input, the checks
 528      * are best effort and when performance is an overriding priority,
 529      * as when methods of this class are optimized by the runtime
 530      * compiler, some or all checks (if any) may be elided. Hence, the
 531      * caller must not rely on the checks and corresponding
 532      * exceptions!
 533      *
 534      * @throws RuntimeException if any of the arguments is invalid
 535      *
 536      * @since 1.7
 537      */
 538     @ForceInline
 539     public void setMemory(Object o, long offset, long bytes, byte value) {
 540         theInternalUnsafe.setMemory(o, offset, bytes, value);
 541     }
 542 
 543     /**
 544      * Sets all bytes in a given block of memory to a fixed value
 545      * (usually zero).  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 546      * as discussed in {@link #getInt(Object,long)}.
 547      *
 548      * &lt;p&gt;Equivalent to {@code setMemory(null, address, bytes, value)}.
 549      */
 550     @ForceInline
 551     public void setMemory(long address, long bytes, byte value) {
 552         theInternalUnsafe.setMemory(address, bytes, value);
 553     }
 554 
 555     /**
 556      * Sets all bytes in a given block of memory to a copy of another
 557      * block.
 558      *
 559      * &lt;p&gt;This method determines each block's base address by means of two parameters,
 560      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 561      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 562      * the offset supplies an absolute base address.
 563      *
 564      * &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
 565      * by the address and length parameters.  If the effective addresses and
 566      * length are all even modulo 8, the transfer takes place in 'long' units.
 567      * If the effective addresses and length are (resp.) even modulo 4 or 2,
 568      * the transfer takes place in units of 'int' or 'short'.
 569      *
 570      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 571      * sure arguments are checked before the methods are called. While
 572      * some rudimentary checks are performed on the input, the checks
 573      * are best effort and when performance is an overriding priority,
 574      * as when methods of this class are optimized by the runtime
 575      * compiler, some or all checks (if any) may be elided. Hence, the
 576      * caller must not rely on the checks and corresponding
 577      * exceptions!
 578      *
 579      * @throws RuntimeException if any of the arguments is invalid
 580      *
 581      * @since 1.7
 582      */
 583     @ForceInline
 584     public void copyMemory(Object srcBase, long srcOffset,
 585                            Object destBase, long destOffset,
 586                            long bytes) {
 587         theInternalUnsafe.copyMemory(srcBase, srcOffset, destBase, destOffset, bytes);
 588     }
 589 
 590     /**
 591      * Sets all bytes in a given block of memory to a copy of another
 592      * block.  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 593      * as discussed in {@link #getInt(Object,long)}.
 594      *
 595      * Equivalent to {@code copyMemory(null, srcAddress, null, destAddress, bytes)}.
 596      */
 597     @ForceInline
 598     public void copyMemory(long srcAddress, long destAddress, long bytes) {
 599         theInternalUnsafe.copyMemory(srcAddress, destAddress, bytes);
 600     }
 601 
 602     /**
 603      * Disposes of a block of native memory, as obtained from {@link
 604      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 605      * this method may be null, in which case no action is taken.
 606      *
 607      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 608      * sure arguments are checked before the methods are called. While
 609      * some rudimentary checks are performed on the input, the checks
 610      * are best effort and when performance is an overriding priority,
 611      * as when methods of this class are optimized by the runtime
 612      * compiler, some or all checks (if any) may be elided. Hence, the
 613      * caller must not rely on the checks and corresponding
 614      * exceptions!
 615      *
 616      * @throws RuntimeException if any of the arguments is invalid
 617      *
 618      * @see #allocateMemory
 619      */
 620     @ForceInline
 621     public void freeMemory(long address) {
 622         theInternalUnsafe.freeMemory(address);
 623     }
 624 
 625     /// random queries
 626 
 627     /**
 628      * This constant differs from all results that will ever be returned from
 629      * {@link #staticFieldOffset}, {@link #objectFieldOffset},
 630      * or {@link #arrayBaseOffset}.
 631      */
 632     public static final int INVALID_FIELD_OFFSET = jdk.internal.misc.Unsafe.INVALID_FIELD_OFFSET;
 633 
 634     /**
 635      * Reports the location of a given field in the storage allocation of its
 636      * class.  Do not expect to perform any sort of arithmetic on this offset;
 637      * it is just a cookie which is passed to the unsafe heap memory accessors.
 638      *
 639      * &lt;p&gt;Any given field will always have the same offset and base, and no
 640      * two distinct fields of the same class will ever have the same offset
 641      * and base.
 642      *
 643      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 644      * although the Sun JVM does not use the most significant 32 bits.
 645      * However, JVM implementations which store static fields at absolute
 646      * addresses can use long offsets and null base pointers to express
 647      * the field locations in a form usable by {@link #getInt(Object,long)}.
 648      * Therefore, code which will be ported to such JVMs on 64-bit platforms
 649      * must preserve all bits of static field offsets.
 650      * @see #getInt(Object, long)
 651      */
 652     @ForceInline
 653     public long objectFieldOffset(Field f) {
 654         return theInternalUnsafe.objectFieldOffset(f);
 655     }
 656 
 657     /**
 658      * Reports the location of a given static field, in conjunction with {@link
 659      * #staticFieldBase}.
 660      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
 661      * it is just a cookie which is passed to the unsafe heap memory accessors.
 662      *
 663      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
 664      * fields of the same class will ever have the same offset.
 665      *
 666      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 667      * although the Sun JVM does not use the most significant 32 bits.
 668      * It is hard to imagine a JVM technology which needs more than
 669      * a few bits to encode an offset within a non-array object,
 670      * However, for consistency with other methods in this class,
 671      * this method reports its result as a long value.
 672      * @see #getInt(Object, long)
 673      */
 674     @ForceInline
 675     public long staticFieldOffset(Field f) {
 676         return theInternalUnsafe.staticFieldOffset(f);
 677     }
 678 
 679     /**
 680      * Reports the location of a given static field, in conjunction with {@link
 681      * #staticFieldOffset}.
 682      * &lt;p&gt;Fetch the base "Object", if any, with which static fields of the
 683      * given class can be accessed via methods like {@link #getInt(Object,
 684      * long)}.  This value may be null.  This value may refer to an object
 685      * which is a "cookie", not guaranteed to be a real Object, and it should
 686      * not be used in any way except as argument to the get and put routines in
 687      * this class.
 688      */
 689     @ForceInline
 690     public Object staticFieldBase(Field f) {
 691         return theInternalUnsafe.staticFieldBase(f);
 692     }
 693 
 694     /**
 695      * Detects if the given class may need to be initialized. This is often
 696      * needed in conjunction with obtaining the static field base of a
 697      * class.
 698      * @return false only if a call to {@code ensureClassInitialized} would have no effect
 699      */
 700     @ForceInline
 701     public boolean shouldBeInitialized(Class&lt;?&gt; c) {
 702         return theInternalUnsafe.shouldBeInitialized(c);
 703     }
 704 
 705     /**
 706      * Ensures the given class has been initialized. This is often
 707      * needed in conjunction with obtaining the static field base of a
 708      * class.
 709      */
 710     @ForceInline
 711     public void ensureClassInitialized(Class&lt;?&gt; c) {
 712         theInternalUnsafe.ensureClassInitialized(c);
 713     }
 714 
 715     /**
 716      * Reports the offset of the first element in the storage allocation of a
 717      * given array class.  If {@link #arrayIndexScale} returns a non-zero value
 718      * for the same class, you may use that scale factor, together with this
 719      * base offset, to form new offsets to access elements of arrays of the
 720      * given class.
 721      *
 722      * @see #getInt(Object, long)
 723      * @see #putInt(Object, long, int)
 724      */
 725     @ForceInline
 726     public int arrayBaseOffset(Class&lt;?&gt; arrayClass) {
 727         return theInternalUnsafe.arrayBaseOffset(arrayClass);
 728     }
 729 
 730     /** The value of {@code arrayBaseOffset(boolean[].class)} */
 731     public static final int ARRAY_BOOLEAN_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;
 732 
 733     /** The value of {@code arrayBaseOffset(byte[].class)} */
 734     public static final int ARRAY_BYTE_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;
 735 
 736     /** The value of {@code arrayBaseOffset(short[].class)} */
 737     public static final int ARRAY_SHORT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_SHORT_BASE_OFFSET;
 738 
 739     /** The value of {@code arrayBaseOffset(char[].class)} */
 740     public static final int ARRAY_CHAR_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_CHAR_BASE_OFFSET;
 741 
 742     /** The value of {@code arrayBaseOffset(int[].class)} */
 743     public static final int ARRAY_INT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_INT_BASE_OFFSET;
 744 
 745     /** The value of {@code arrayBaseOffset(long[].class)} */
 746     public static final int ARRAY_LONG_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_LONG_BASE_OFFSET;
 747 
 748     /** The value of {@code arrayBaseOffset(float[].class)} */
 749     public static final int ARRAY_FLOAT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_FLOAT_BASE_OFFSET;
 750 
 751     /** The value of {@code arrayBaseOffset(double[].class)} */
 752     public static final int ARRAY_DOUBLE_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_DOUBLE_BASE_OFFSET;
 753 
 754     /** The value of {@code arrayBaseOffset(Object[].class)} */
 755     public static final int ARRAY_OBJECT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_OBJECT_BASE_OFFSET;
 756 
 757     /**
 758      * Reports the scale factor for addressing elements in the storage
 759      * allocation of a given array class.  However, arrays of "narrow" types
 760      * will generally not work properly with accessors like {@link
 761      * #getByte(Object, long)}, so the scale factor for such classes is reported
 762      * as zero.
 763      *
 764      * @see #arrayBaseOffset
 765      * @see #getInt(Object, long)
 766      * @see #putInt(Object, long, int)
 767      */
 768     @ForceInline
 769     public int arrayIndexScale(Class&lt;?&gt; arrayClass) {
 770         return theInternalUnsafe.arrayIndexScale(arrayClass);
 771     }
 772 
 773     /** The value of {@code arrayIndexScale(boolean[].class)} */
 774     public static final int ARRAY_BOOLEAN_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_BOOLEAN_INDEX_SCALE;
 775 
 776     /** The value of {@code arrayIndexScale(byte[].class)} */
 777     public static final int ARRAY_BYTE_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_BYTE_INDEX_SCALE;
 778 
 779     /** The value of {@code arrayIndexScale(short[].class)} */
 780     public static final int ARRAY_SHORT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_SHORT_INDEX_SCALE;
 781 
 782     /** The value of {@code arrayIndexScale(char[].class)} */
 783     public static final int ARRAY_CHAR_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_CHAR_INDEX_SCALE;
 784 
 785     /** The value of {@code arrayIndexScale(int[].class)} */
 786     public static final int ARRAY_INT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_INT_INDEX_SCALE;
 787 
 788     /** The value of {@code arrayIndexScale(long[].class)} */
 789     public static final int ARRAY_LONG_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_LONG_INDEX_SCALE;
 790 
 791     /** The value of {@code arrayIndexScale(float[].class)} */
 792     public static final int ARRAY_FLOAT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_FLOAT_INDEX_SCALE;
 793 
 794     /** The value of {@code arrayIndexScale(double[].class)} */
 795     public static final int ARRAY_DOUBLE_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_DOUBLE_INDEX_SCALE;
 796 
 797     /** The value of {@code arrayIndexScale(Object[].class)} */
 798     public static final int ARRAY_OBJECT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_OBJECT_INDEX_SCALE;
 799 
 800     /**
 801      * Reports the size in bytes of a native pointer, as stored via {@link
 802      * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
 803      * other primitive types (as stored in native memory blocks) is determined
 804      * fully by their information content.
 805      */
 806     @ForceInline
 807     public int addressSize() {
 808         return theInternalUnsafe.addressSize();
 809     }
 810 
 811     /** The value of {@code addressSize()} */
 812     public static final int ADDRESS_SIZE = theInternalUnsafe.addressSize();
 813 
 814     /**
 815      * Reports the size in bytes of a native memory page (whatever that is).
 816      * This value will always be a power of two.
 817      */
 818     @ForceInline
 819     public int pageSize() {
 820         return theInternalUnsafe.pageSize();
 821     }
 822 
 823 
 824     /// random trusted operations from JNI:
 825 
 826     /**
 827      * Tells the VM to define a class, without security checks.  By default, the
 828      * class loader and protection domain come from the caller's class.
 829      */
 830     @ForceInline
 831     public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,
 832                                 ClassLoader loader,
 833                                 ProtectionDomain protectionDomain) {
 834         return theInternalUnsafe.defineClass(name, b, off, len, loader, protectionDomain);
 835     }
 836 
 837     /**
 838      * Defines a class but does not make it known to the class loader or system dictionary.
 839      * &lt;p&gt;
 840      * For each CP entry, the corresponding CP patch must either be null or have
 841      * the a format that matches its tag:
 842      * &lt;ul&gt;
 843      * &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
 844      * &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
 845      * &lt;li&gt;Class: any java.lang.Class object
 846      * &lt;li&gt;String: any object (not just a java.lang.String)
 847      * &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments
 848      * &lt;/ul&gt;
 849      * @param hostClass context for linkage, access control, protection domain, and class loader
 850      * @param data      bytes of a class file
 851      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
 852      */
 853     @ForceInline
 854     public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches) {
 855         return theInternalUnsafe.defineAnonymousClass(hostClass, data, cpPatches);
 856     }
 857 
 858     /**
 859      * Allocates an instance but does not run any constructor.
 860      * Initializes the class if it has not yet been.
 861      */
 862     @ForceInline
 863     public Object allocateInstance(Class&lt;?&gt; cls)
 864         throws InstantiationException {
 865         return theInternalUnsafe.allocateInstance(cls);
 866     }
 867 
 868     /** Throws the exception without telling the verifier. */
 869     @ForceInline
 870     public void throwException(Throwable ee) {
 871         theInternalUnsafe.throwException(ee);
 872     }
 873 
 874     /**
 875      * Atomically updates Java variable to {@code x} if it is currently
 876      * holding {@code expected}.
 877      *
 878      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 879      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 880      *
 881      * @return {@code true} if successful
 882      */
 883     @ForceInline
 884     public final boolean compareAndSwapObject(Object o, long offset,
 885                                               Object expected,
 886                                               Object x) {
 887         return theInternalUnsafe.compareAndSwapObject(o, offset, expected, x);
 888     }
 889 
 890     /**
 891      * Atomically updates Java variable to {@code x} if it is currently
 892      * holding {@code expected}.
 893      *
 894      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 895      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 896      *
 897      * @return {@code true} if successful
 898      */
 899     @ForceInline
 900     public final boolean compareAndSwapInt(Object o, long offset,
 901                                            int expected,
 902                                            int x) {
 903         return theInternalUnsafe.compareAndSwapInt(o, offset, expected, x);
 904     }
 905 
 906     /**
 907      * Atomically updates Java variable to {@code x} if it is currently
 908      * holding {@code expected}.
 909      *
 910      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 911      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 912      *
 913      * @return {@code true} if successful
 914      */
 915     @ForceInline
 916     public final boolean compareAndSwapLong(Object o, long offset,
 917                                             long expected,
 918                                             long x) {
 919         return theInternalUnsafe.compareAndSwapLong(o, offset, expected, x);
 920     }
 921 
 922     /**
 923      * Fetches a reference value from a given Java variable, with volatile
 924      * load semantics. Otherwise identical to {@link #getObject(Object, long)}
 925      */
 926     @ForceInline
 927     public Object getObjectVolatile(Object o, long offset) {
 928         return theInternalUnsafe.getObjectVolatile(o, offset);
 929     }
 930 
 931     /**
 932      * Stores a reference value into a given Java variable, with
 933      * volatile store semantics. Otherwise identical to {@link #putObject(Object, long, Object)}
 934      */
 935     @ForceInline
 936     public void putObjectVolatile(Object o, long offset, Object x) {
 937         theInternalUnsafe.putObjectVolatile(o, offset, x);
 938     }
 939 
 940     /** Volatile version of {@link #getInt(Object, long)}  */
 941     @ForceInline
 942     public int getIntVolatile(Object o, long offset) {
 943         return theInternalUnsafe.getIntVolatile(o, offset);
 944     }
 945 
 946     /** Volatile version of {@link #putInt(Object, long, int)}  */
 947     @ForceInline
 948     public void putIntVolatile(Object o, long offset, int x) {
 949         theInternalUnsafe.putIntVolatile(o, offset, x);
 950     }
 951 
 952     /** Volatile version of {@link #getBoolean(Object, long)}  */
 953     @ForceInline
 954     public boolean getBooleanVolatile(Object o, long offset) {
 955         return theInternalUnsafe.getBooleanVolatile(o, offset);
 956     }
 957 
 958     /** Volatile version of {@link #putBoolean(Object, long, boolean)}  */
 959     @ForceInline
 960     public void putBooleanVolatile(Object o, long offset, boolean x) {
 961         theInternalUnsafe.putBooleanVolatile(o, offset, x);
 962     }
 963 
 964     /** Volatile version of {@link #getByte(Object, long)}  */
 965     @ForceInline
 966     public byte getByteVolatile(Object o, long offset) {
 967         return theInternalUnsafe.getByteVolatile(o, offset);
 968     }
 969 
 970     /** Volatile version of {@link #putByte(Object, long, byte)}  */
 971     @ForceInline
 972     public void putByteVolatile(Object o, long offset, byte x) {
 973         theInternalUnsafe.putByteVolatile(o, offset, x);
 974     }
 975 
 976     /** Volatile version of {@link #getShort(Object, long)}  */
 977     @ForceInline
 978     public short getShortVolatile(Object o, long offset) {
 979         return theInternalUnsafe.getShortVolatile(o, offset);
 980     }
 981 
 982     /** Volatile version of {@link #putShort(Object, long, short)}  */
 983     @ForceInline
 984     public void putShortVolatile(Object o, long offset, short x) {
 985         theInternalUnsafe.putShortVolatile(o, offset, x);
 986     }
 987 
 988     /** Volatile version of {@link #getChar(Object, long)}  */
 989     @ForceInline
 990     public char getCharVolatile(Object o, long offset) {
 991         return theInternalUnsafe.getCharVolatile(o, offset);
 992     }
 993 
 994     /** Volatile version of {@link #putChar(Object, long, char)}  */
 995     @ForceInline
 996     public void putCharVolatile(Object o, long offset, char x) {
 997         theInternalUnsafe.putCharVolatile(o, offset, x);
 998     }
 999 
1000     /** Volatile version of {@link #getLong(Object, long)}  */
1001     @ForceInline
1002     public long getLongVolatile(Object o, long offset) {
1003         return theInternalUnsafe.getLongVolatile(o, offset);
1004     }
1005 
1006     /** Volatile version of {@link #putLong(Object, long, long)}  */
1007     @ForceInline
1008     public void putLongVolatile(Object o, long offset, long x) {
1009         theInternalUnsafe.putLongVolatile(o, offset, x);
1010     }
1011 
1012     /** Volatile version of {@link #getFloat(Object, long)}  */
1013     @ForceInline
1014     public float getFloatVolatile(Object o, long offset) {
1015         return theInternalUnsafe.getFloatVolatile(o, offset);
1016     }
1017 
1018     /** Volatile version of {@link #putFloat(Object, long, float)}  */
1019     @ForceInline
1020     public void putFloatVolatile(Object o, long offset, float x) {
1021         theInternalUnsafe.putFloatVolatile(o, offset, x);
1022     }
1023 
1024     /** Volatile version of {@link #getDouble(Object, long)}  */
1025     @ForceInline
1026     public double getDoubleVolatile(Object o, long offset) {
1027         return theInternalUnsafe.getDoubleVolatile(o, offset);
1028     }
1029 
1030     /** Volatile version of {@link #putDouble(Object, long, double)}  */
1031     @ForceInline
1032     public void putDoubleVolatile(Object o, long offset, double x) {
1033         theInternalUnsafe.putDoubleVolatile(o, offset, x);
1034     }
1035 
1036     /**
1037      * Version of {@link #putObjectVolatile(Object, long, Object)}
1038      * that does not guarantee immediate visibility of the store to
1039      * other threads. This method is generally only useful if the
1040      * underlying field is a Java volatile (or if an array cell, one
1041      * that is otherwise only accessed using volatile accesses).
1042      *
1043      * Corresponds to C11 atomic_store_explicit(..., memory_order_release).
1044      */
1045     @ForceInline
1046     public void putOrderedObject(Object o, long offset, Object x) {
1047         theInternalUnsafe.putObjectRelease(o, offset, x);
1048     }
1049 
1050     /** Ordered/Lazy version of {@link #putIntVolatile(Object, long, int)}  */
1051     @ForceInline
1052     public void putOrderedInt(Object o, long offset, int x) {
1053         theInternalUnsafe.putIntRelease(o, offset, x);
1054     }
1055 
1056     /** Ordered/Lazy version of {@link #putLongVolatile(Object, long, long)} */
1057     @ForceInline
1058     public void putOrderedLong(Object o, long offset, long x) {
1059         theInternalUnsafe.putLongRelease(o, offset, x);
1060     }
1061 
1062     /**
1063      * Unblocks the given thread blocked on {@code park}, or, if it is
1064      * not blocked, causes the subsequent call to {@code park} not to
1065      * block.  Note: this operation is "unsafe" solely because the
1066      * caller must somehow ensure that the thread has not been
1067      * destroyed. Nothing special is usually required to ensure this
1068      * when called from Java (in which there will ordinarily be a live
1069      * reference to the thread) but this is not nearly-automatically
1070      * so when calling from native code.
1071      *
1072      * @param thread the thread to unpark.
1073      */
1074     @ForceInline
1075     public void unpark(Object thread) {
1076         theInternalUnsafe.unpark(thread);
1077     }
1078 
1079     /**
1080      * Blocks current thread, returning when a balancing
1081      * {@code unpark} occurs, or a balancing {@code unpark} has
1082      * already occurred, or the thread is interrupted, or, if not
1083      * absolute and time is not zero, the given time nanoseconds have
1084      * elapsed, or if absolute, the given deadline in milliseconds
1085      * since Epoch has passed, or spuriously (i.e., returning for no
1086      * "reason"). Note: This operation is in the Unsafe class only
1087      * because {@code unpark} is, so it would be strange to place it
1088      * elsewhere.
1089      */
1090     @ForceInline
1091     public void park(boolean isAbsolute, long time) {
1092         theInternalUnsafe.park(isAbsolute, time);
1093     }
1094 
1095     /**
1096      * Gets the load average in the system run queue assigned
1097      * to the available processors averaged over various periods of time.
1098      * This method retrieves the given {@code nelem} samples and
1099      * assigns to the elements of the given {@code loadavg} array.
1100      * The system imposes a maximum of 3 samples, representing
1101      * averages over the last 1,  5,  and  15 minutes, respectively.
1102      *
1103      * @param loadavg an array of double of size nelems
1104      * @param nelems the number of samples to be retrieved and
1105      *        must be 1 to 3.
1106      *
1107      * @return the number of samples actually retrieved; or -1
1108      *         if the load average is unobtainable.
1109      */
1110     @ForceInline
1111     public int getLoadAverage(double[] loadavg, int nelems) {
1112         return theInternalUnsafe.getLoadAverage(loadavg, nelems);
1113     }
1114 
1115     // The following contain CAS-based Java implementations used on
1116     // platforms not supporting native instructions
1117 
1118     /**
1119      * Atomically adds the given value to the current value of a field
1120      * or array element within the given object {@code o}
1121      * at the given {@code offset}.
1122      *
1123      * @param o object/array to update the field/element in
1124      * @param offset field/element offset
1125      * @param delta the value to add
1126      * @return the previous value
1127      * @since 1.8
1128      */
1129     @ForceInline
1130     public final int getAndAddInt(Object o, long offset, int delta) {
1131         return theInternalUnsafe.getAndAddInt(o, offset, delta);
1132     }
1133 
1134     /**
1135      * Atomically adds the given value to the current value of a field
1136      * or array element within the given object {@code o}
1137      * at the given {@code offset}.
1138      *
1139      * @param o object/array to update the field/element in
1140      * @param offset field/element offset
1141      * @param delta the value to add
1142      * @return the previous value
1143      * @since 1.8
1144      */
1145     @ForceInline
1146     public final long getAndAddLong(Object o, long offset, long delta) {
1147         return theInternalUnsafe.getAndAddLong(o, offset, delta);
1148     }
1149 
1150     /**
1151      * Atomically exchanges the given value with the current value of
1152      * a field or array element within the given object {@code o}
1153      * at the given {@code offset}.
1154      *
1155      * @param o object/array to update the field/element in
1156      * @param offset field/element offset
1157      * @param newValue new value
1158      * @return the previous value
1159      * @since 1.8
1160      */
1161     @ForceInline
1162     public final int getAndSetInt(Object o, long offset, int newValue) {
1163         return theInternalUnsafe.getAndSetInt(o, offset, newValue);
1164     }
1165 
1166     /**
1167      * Atomically exchanges the given value with the current value of
1168      * a field or array element within the given object {@code o}
1169      * at the given {@code offset}.
1170      *
1171      * @param o object/array to update the field/element in
1172      * @param offset field/element offset
1173      * @param newValue new value
1174      * @return the previous value
1175      * @since 1.8
1176      */
1177     @ForceInline
1178     public final long getAndSetLong(Object o, long offset, long newValue) {
1179         return theInternalUnsafe.getAndSetLong(o, offset, newValue);
1180     }
1181 
1182     /**
1183      * Atomically exchanges the given reference value with the current
1184      * reference value of a field or array element within the given
1185      * object {@code o} at the given {@code offset}.
1186      *
1187      * @param o object/array to update the field/element in
1188      * @param offset field/element offset
1189      * @param newValue new value
1190      * @return the previous value
1191      * @since 1.8
1192      */
1193     @ForceInline
1194     public final Object getAndSetObject(Object o, long offset, Object newValue) {
1195         return theInternalUnsafe.getAndSetObject(o, offset, newValue);
1196     }
1197 
1198 
1199     /**
1200      * Ensures that loads before the fence will not be reordered with loads and
1201      * stores after the fence; a "LoadLoad plus LoadStore barrier".
1202      *
1203      * Corresponds to C11 atomic_thread_fence(memory_order_acquire)
1204      * (an "acquire fence").
1205      *
1206      * A pure LoadLoad fence is not provided, since the addition of LoadStore
1207      * is almost always desired, and most current hardware instructions that
1208      * provide a LoadLoad barrier also provide a LoadStore barrier for free.
1209      * @since 1.8
1210      */
1211     @ForceInline
1212     public void loadFence() {
1213         theInternalUnsafe.loadFence();
1214     }
1215 
1216     /**
1217      * Ensures that loads and stores before the fence will not be reordered with
1218      * stores after the fence; a "StoreStore plus LoadStore barrier".
1219      *
1220      * Corresponds to C11 atomic_thread_fence(memory_order_release)
1221      * (a "release fence").
1222      *
1223      * A pure StoreStore fence is not provided, since the addition of LoadStore
1224      * is almost always desired, and most current hardware instructions that
1225      * provide a StoreStore barrier also provide a LoadStore barrier for free.
1226      * @since 1.8
1227      */
1228     @ForceInline
1229     public void storeFence() {
1230         theInternalUnsafe.storeFence();
1231     }
1232 
1233     /**
1234      * Ensures that loads and stores before the fence will not be reordered
1235      * with loads and stores after the fence.  Implies the effects of both
1236      * loadFence() and storeFence(), and in addition, the effect of a StoreLoad
1237      * barrier.
1238      *
1239      * Corresponds to C11 atomic_thread_fence(memory_order_seq_cst).
1240      * @since 1.8
1241      */
1242     @ForceInline
1243     public void fullFence() {
1244         theInternalUnsafe.fullFence();
1245     }
1246 }
</pre></body></html>
