<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Sdiff src/jdk.unsupported/share/classes/sun/misc </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../src/java.base/share/classes/jdk/internal/misc/Unsafe.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> next &gt</center>
<h2>src/jdk.unsupported/share/classes/sun/misc/Unsafe.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 294     @ForceInline
 295     public void putDouble(Object o, long offset, double x) {
 296         theInternalUnsafe.putDouble(o, offset, x);
 297     }
 298 
 299 
 300     // These read VM internal data.
 301 
 302     /**
 303      * Fetches an uncompressed reference value from a given native variable
 304      * ignoring the VM's compressed references mode.
 305      *
 306      * @param address a memory address locating the variable
 307      * @return the value fetched from the indicated native variable
 308      */
 309     @ForceInline
 310     public Object getUncompressedObject(long address) {
 311         return theInternalUnsafe.getUncompressedObject(address);
 312     }
 313 
<span class="removed"> 314     /**</span>
<span class="removed"> 315      * Fetches the {@link java.lang.Class} Java mirror for the given native</span>
<span class="removed"> 316      * metaspace {@code Klass} pointer.</span>
<span class="removed"> 317      *</span>
<span class="removed"> 318      * @param metaspaceKlass a native metaspace {@code Klass} pointer</span>
<span class="removed"> 319      * @return the {@link java.lang.Class} Java mirror</span>
<span class="removed"> 320      */</span>
<span class="removed"> 321     @ForceInline</span>
<span class="removed"> 322     public Class&lt;?&gt; getJavaMirror(long metaspaceKlass) {</span>
<span class="removed"> 323         return theInternalUnsafe.getJavaMirror(metaspaceKlass);</span>
<span class="removed"> 324     }</span>
<span class="removed"> 325 </span>
<span class="removed"> 326     /**</span>
<span class="removed"> 327      * Fetches a native metaspace {@code Klass} pointer for the given Java</span>
<span class="removed"> 328      * object.</span>
<span class="removed"> 329      *</span>
<span class="removed"> 330      * @param o Java heap object for which to fetch the class pointer</span>
<span class="removed"> 331      * @return a native metaspace {@code Klass} pointer</span>
<span class="removed"> 332      */</span>
<span class="removed"> 333     @ForceInline</span>
<span class="removed"> 334     public long getKlassPointer(Object o) {</span>
<span class="removed"> 335         return theInternalUnsafe.getKlassPointer(o);</span>
<span class="removed"> 336     }</span>
<span class="removed"> 337 </span>
 338     // These work on values in the C heap.
 339 
 340     /**
 341      * Fetches a value from a given memory address.  If the address is zero, or
 342      * does not point into a block obtained from {@link #allocateMemory}, the
 343      * results are undefined.
 344      *
 345      * @see #allocateMemory
 346      */
 347     @ForceInline
 348     public byte getByte(long address) {
 349         return theInternalUnsafe.getByte(address);
 350     }
 351 
 352     /**
 353      * Stores a value into a given memory address.  If the address is zero, or
 354      * does not point into a block obtained from {@link #allocateMemory}, the
 355      * results are undefined.
 356      *
 357      * @see #getByte(long)

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 294     @ForceInline
 295     public void putDouble(Object o, long offset, double x) {
 296         theInternalUnsafe.putDouble(o, offset, x);
 297     }
 298 
 299 
 300     // These read VM internal data.
 301 
 302     /**
 303      * Fetches an uncompressed reference value from a given native variable
 304      * ignoring the VM's compressed references mode.
 305      *
 306      * @param address a memory address locating the variable
 307      * @return the value fetched from the indicated native variable
 308      */
 309     @ForceInline
 310     public Object getUncompressedObject(long address) {
 311         return theInternalUnsafe.getUncompressedObject(address);
 312     }
 313 
























 314     // These work on values in the C heap.
 315 
 316     /**
 317      * Fetches a value from a given memory address.  If the address is zero, or
 318      * does not point into a block obtained from {@link #allocateMemory}, the
 319      * results are undefined.
 320      *
 321      * @see #allocateMemory
 322      */
 323     @ForceInline
 324     public byte getByte(long address) {
 325         return theInternalUnsafe.getByte(address);
 326     }
 327 
 328     /**
 329      * Stores a value into a given memory address.  If the address is zero, or
 330      * does not point into a block obtained from {@link #allocateMemory}, the
 331      * results are undefined.
 332      *
 333      * @see #getByte(long)

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../../../src/java.base/share/classes/jdk/internal/misc/Unsafe.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> next &gt</center>
</body></html>
