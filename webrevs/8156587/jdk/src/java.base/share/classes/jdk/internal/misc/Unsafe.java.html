<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/java.base/share/classes/jdk/internal/misc/Unsafe.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.misc;
  27 
  28 import java.lang.reflect.Field;
  29 import java.security.ProtectionDomain;
  30 
  31 import jdk.internal.reflect.CallerSensitive;
  32 import jdk.internal.reflect.Reflection;
  33 import jdk.internal.misc.VM;
  34 
  35 import jdk.internal.HotSpotIntrinsicCandidate;
  36 import jdk.internal.vm.annotation.ForceInline;
  37 
  38 
  39 /**
  40  * A collection of methods for performing low-level, unsafe operations.
  41  * Although the class and all methods are public, use of this class is
  42  * limited because only trusted code can obtain instances of it.
  43  *
  44  * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make sure
  45  * arguments are checked before methods of this class are
  46  * called. While some rudimentary checks are performed on the input,
  47  * the checks are best effort and when performance is an overriding
  48  * priority, as when methods of this class are optimized by the
  49  * runtime compiler, some or all checks (if any) may be elided. Hence,
  50  * the caller must not rely on the checks and corresponding
  51  * exceptions!
  52  *
  53  * @author John R. Rose
  54  * @see #getUnsafe
  55  */
  56 
  57 public final class Unsafe {
  58 
  59     private static native void registerNatives();
  60     static {
  61         registerNatives();
  62         Reflection.registerMethodsToFilter(Unsafe.class, "getUnsafe");
  63     }
  64 
  65     private Unsafe() {}
  66 
  67     private static final Unsafe theUnsafe = new Unsafe();
  68 
  69     /**
  70      * Provides the caller with the capability of performing unsafe
  71      * operations.
  72      *
  73      * &lt;p&gt;The returned {@code Unsafe} object should be carefully guarded
  74      * by the caller, since it can be used to read and write data at arbitrary
  75      * memory addresses.  It must never be passed to untrusted code.
  76      *
  77      * &lt;p&gt;Most methods in this class are very low-level, and correspond to a
  78      * small number of hardware instructions (on typical machines).  Compilers
  79      * are encouraged to optimize these methods accordingly.
  80      *
  81      * &lt;p&gt;Here is a suggested idiom for using unsafe operations:
  82      *
  83      * &lt;pre&gt; {@code
  84      * class MyTrustedClass {
  85      *   private static final Unsafe unsafe = Unsafe.getUnsafe();
  86      *   ...
  87      *   private long myCountAddress = ...;
  88      *   public int getCount() { return unsafe.getByte(myCountAddress); }
  89      * }}&lt;/pre&gt;
  90      *
  91      * (It may assist compilers to make the local variable {@code final}.)
  92      *
  93      * @throws  SecurityException  if a security manager exists and its
  94      *          {@code checkPropertiesAccess} method doesn't allow
  95      *          access to the system properties.
  96      */
  97     @CallerSensitive
  98     public static Unsafe getUnsafe() {
  99         Class&lt;?&gt; caller = Reflection.getCallerClass();
 100         if (!VM.isSystemDomainLoader(caller.getClassLoader()))
 101             throw new SecurityException("Unsafe");
 102         return theUnsafe;
 103     }
 104 
 105     /// peek and poke operations
 106     /// (compilers should optimize these to memory ops)
 107 
 108     // These work on object fields in the Java heap.
 109     // They will not work on elements of packed arrays.
 110 
 111     /**
 112      * Fetches a value from a given Java variable.
 113      * More specifically, fetches a field or array element within the given
 114      * object {@code o} at the given offset, or (if {@code o} is null)
 115      * from the memory address whose numerical value is the given offset.
 116      * &lt;p&gt;
 117      * The results are undefined unless one of the following cases is true:
 118      * &lt;ul&gt;
 119      * &lt;li&gt;The offset was obtained from {@link #objectFieldOffset} on
 120      * the {@link java.lang.reflect.Field} of some Java field and the object
 121      * referred to by {@code o} is of a class compatible with that
 122      * field's class.
 123      *
 124      * &lt;li&gt;The offset and object reference {@code o} (either null or
 125      * non-null) were both obtained via {@link #staticFieldOffset}
 126      * and {@link #staticFieldBase} (respectively) from the
 127      * reflective {@link Field} representation of some Java field.
 128      *
 129      * &lt;li&gt;The object referred to by {@code o} is an array, and the offset
 130      * is an integer of the form {@code B+N*S}, where {@code N} is
 131      * a valid index into the array, and {@code B} and {@code S} are
 132      * the values obtained by {@link #arrayBaseOffset} and {@link
 133      * #arrayIndexScale} (respectively) from the array's class.  The value
 134      * referred to is the {@code N}&lt;em&gt;th&lt;/em&gt; element of the array.
 135      *
 136      * &lt;/ul&gt;
 137      * &lt;p&gt;
 138      * If one of the above cases is true, the call references a specific Java
 139      * variable (field or array element).  However, the results are undefined
 140      * if that variable is not in fact of the type returned by this method.
 141      * &lt;p&gt;
 142      * This method refers to a variable by means of two parameters, and so
 143      * it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode
 144      * for Java variables.  When the object reference is null, this method
 145      * uses its offset as an absolute address.  This is similar in operation
 146      * to methods such as {@link #getInt(long)}, which provide (in effect) a
 147      * &lt;em&gt;single-register&lt;/em&gt; addressing mode for non-Java variables.
 148      * However, because Java variables may have a different layout in memory
 149      * from non-Java variables, programmers should not assume that these
 150      * two addressing modes are ever equivalent.  Also, programmers should
 151      * remember that offsets from the double-register addressing mode cannot
 152      * be portably confused with longs used in the single-register addressing
 153      * mode.
 154      *
 155      * @param o Java heap object in which the variable resides, if any, else
 156      *        null
 157      * @param offset indication of where the variable resides in a Java heap
 158      *        object, if any, else a memory address locating the variable
 159      *        statically
 160      * @return the value fetched from the indicated Java variable
 161      * @throws RuntimeException No defined exceptions are thrown, not even
 162      *         {@link NullPointerException}
 163      */
 164     @HotSpotIntrinsicCandidate
 165     public native int getInt(Object o, long offset);
 166 
 167     /**
 168      * Stores a value into a given Java variable.
 169      * &lt;p&gt;
 170      * The first two parameters are interpreted exactly as with
 171      * {@link #getInt(Object, long)} to refer to a specific
 172      * Java variable (field or array element).  The given value
 173      * is stored into that variable.
 174      * &lt;p&gt;
 175      * The variable must be of the same type as the method
 176      * parameter {@code x}.
 177      *
 178      * @param o Java heap object in which the variable resides, if any, else
 179      *        null
 180      * @param offset indication of where the variable resides in a Java heap
 181      *        object, if any, else a memory address locating the variable
 182      *        statically
 183      * @param x the value to store into the indicated Java variable
 184      * @throws RuntimeException No defined exceptions are thrown, not even
 185      *         {@link NullPointerException}
 186      */
 187     @HotSpotIntrinsicCandidate
 188     public native void putInt(Object o, long offset, int x);
 189 
 190     /**
 191      * Fetches a reference value from a given Java variable.
 192      * @see #getInt(Object, long)
 193      */
 194     @HotSpotIntrinsicCandidate
 195     public native Object getObject(Object o, long offset);
 196 
 197     /**
 198      * Stores a reference value into a given Java variable.
 199      * &lt;p&gt;
 200      * Unless the reference {@code x} being stored is either null
 201      * or matches the field type, the results are undefined.
 202      * If the reference {@code o} is non-null, card marks or
 203      * other store barriers for that object (if the VM requires them)
 204      * are updated.
 205      * @see #putInt(Object, long, int)
 206      */
 207     @HotSpotIntrinsicCandidate
 208     public native void putObject(Object o, long offset, Object x);
 209 
 210     /** @see #getInt(Object, long) */
 211     @HotSpotIntrinsicCandidate
 212     public native boolean getBoolean(Object o, long offset);
 213 
 214     /** @see #putInt(Object, long, int) */
 215     @HotSpotIntrinsicCandidate
 216     public native void    putBoolean(Object o, long offset, boolean x);
 217 
 218     /** @see #getInt(Object, long) */
 219     @HotSpotIntrinsicCandidate
 220     public native byte    getByte(Object o, long offset);
 221 
 222     /** @see #putInt(Object, long, int) */
 223     @HotSpotIntrinsicCandidate
 224     public native void    putByte(Object o, long offset, byte x);
 225 
 226     /** @see #getInt(Object, long) */
 227     @HotSpotIntrinsicCandidate
 228     public native short   getShort(Object o, long offset);
 229 
 230     /** @see #putInt(Object, long, int) */
 231     @HotSpotIntrinsicCandidate
 232     public native void    putShort(Object o, long offset, short x);
 233 
 234     /** @see #getInt(Object, long) */
 235     @HotSpotIntrinsicCandidate
 236     public native char    getChar(Object o, long offset);
 237 
 238     /** @see #putInt(Object, long, int) */
 239     @HotSpotIntrinsicCandidate
 240     public native void    putChar(Object o, long offset, char x);
 241 
 242     /** @see #getInt(Object, long) */
 243     @HotSpotIntrinsicCandidate
 244     public native long    getLong(Object o, long offset);
 245 
 246     /** @see #putInt(Object, long, int) */
 247     @HotSpotIntrinsicCandidate
 248     public native void    putLong(Object o, long offset, long x);
 249 
 250     /** @see #getInt(Object, long) */
 251     @HotSpotIntrinsicCandidate
 252     public native float   getFloat(Object o, long offset);
 253 
 254     /** @see #putInt(Object, long, int) */
 255     @HotSpotIntrinsicCandidate
 256     public native void    putFloat(Object o, long offset, float x);
 257 
 258     /** @see #getInt(Object, long) */
 259     @HotSpotIntrinsicCandidate
 260     public native double  getDouble(Object o, long offset);
 261 
 262     /** @see #putInt(Object, long, int) */
 263     @HotSpotIntrinsicCandidate
 264     public native void    putDouble(Object o, long offset, double x);
 265 
 266     /**
 267      * Fetches a native pointer from a given memory address.  If the address is
 268      * zero, or does not point into a block obtained from {@link
 269      * #allocateMemory}, the results are undefined.
 270      *
 271      * &lt;p&gt;If the native pointer is less than 64 bits wide, it is extended as
 272      * an unsigned number to a Java long.  The pointer may be indexed by any
 273      * given byte offset, simply by adding that offset (as a simple integer) to
 274      * the long representing the pointer.  The number of bytes actually read
 275      * from the target address may be determined by consulting {@link
 276      * #addressSize}.
 277      *
 278      * @see #allocateMemory
 279      * @see #getInt(Object, long)
 280      */
 281     @ForceInline
 282     public long getAddress(Object o, long offset) {
 283         if (ADDRESS_SIZE == 4) {
 284             return Integer.toUnsignedLong(getInt(o, offset));
 285         } else {
 286             return getLong(o, offset);
 287         }
 288     }
 289 
 290     /**
 291      * Stores a native pointer into a given memory address.  If the address is
 292      * zero, or does not point into a block obtained from {@link
 293      * #allocateMemory}, the results are undefined.
 294      *
 295      * &lt;p&gt;The number of bytes actually written at the target address may be
 296      * determined by consulting {@link #addressSize}.
 297      *
 298      * @see #allocateMemory
 299      * @see #putInt(Object, long, int)
 300      */
 301     @ForceInline
 302     public void putAddress(Object o, long offset, long x) {
 303         if (ADDRESS_SIZE == 4) {
 304             putInt(o, offset, (int)x);
 305         } else {
 306             putLong(o, offset, x);
 307         }
 308     }
 309 
 310     // These read VM internal data.
 311 
 312     /**
 313      * Fetches an uncompressed reference value from a given native variable
 314      * ignoring the VM's compressed references mode.
 315      *
 316      * @param address a memory address locating the variable
 317      * @return the value fetched from the indicated native variable
 318      */
 319     public native Object getUncompressedObject(long address);
 320 
 321     // These work on values in the C heap.
 322 
 323     /**
 324      * Fetches a value from a given memory address.  If the address is zero, or
 325      * does not point into a block obtained from {@link #allocateMemory}, the
 326      * results are undefined.
 327      *
 328      * @see #allocateMemory
 329      */
 330     @ForceInline
 331     public byte getByte(long address) {
 332         return getByte(null, address);
 333     }
 334 
 335     /**
 336      * Stores a value into a given memory address.  If the address is zero, or
 337      * does not point into a block obtained from {@link #allocateMemory}, the
 338      * results are undefined.
 339      *
 340      * @see #getByte(long)
 341      */
 342     @ForceInline
 343     public void putByte(long address, byte x) {
 344         putByte(null, address, x);
 345     }
 346 
 347     /** @see #getByte(long) */
 348     @ForceInline
 349     public short getShort(long address) {
 350         return getShort(null, address);
 351     }
 352 
 353     /** @see #putByte(long, byte) */
 354     @ForceInline
 355     public void putShort(long address, short x) {
 356         putShort(null, address, x);
 357     }
 358 
 359     /** @see #getByte(long) */
 360     @ForceInline
 361     public char getChar(long address) {
 362         return getChar(null, address);
 363     }
 364 
 365     /** @see #putByte(long, byte) */
 366     @ForceInline
 367     public void putChar(long address, char x) {
 368         putChar(null, address, x);
 369     }
 370 
 371     /** @see #getByte(long) */
 372     @ForceInline
 373     public int getInt(long address) {
 374         return getInt(null, address);
 375     }
 376 
 377     /** @see #putByte(long, byte) */
 378     @ForceInline
 379     public void putInt(long address, int x) {
 380         putInt(null, address, x);
 381     }
 382 
 383     /** @see #getByte(long) */
 384     @ForceInline
 385     public long getLong(long address) {
 386         return getLong(null, address);
 387     }
 388 
 389     /** @see #putByte(long, byte) */
 390     @ForceInline
 391     public void putLong(long address, long x) {
 392         putLong(null, address, x);
 393     }
 394 
 395     /** @see #getByte(long) */
 396     @ForceInline
 397     public float getFloat(long address) {
 398         return getFloat(null, address);
 399     }
 400 
 401     /** @see #putByte(long, byte) */
 402     @ForceInline
 403     public void putFloat(long address, float x) {
 404         putFloat(null, address, x);
 405     }
 406 
 407     /** @see #getByte(long) */
 408     @ForceInline
 409     public double getDouble(long address) {
 410         return getDouble(null, address);
 411     }
 412 
 413     /** @see #putByte(long, byte) */
 414     @ForceInline
 415     public void putDouble(long address, double x) {
 416         putDouble(null, address, x);
 417     }
 418 
 419     /** @see #getAddress(Object, long) */
 420     @ForceInline
 421     public long getAddress(long address) {
 422         return getAddress(null, address);
 423     }
 424 
 425     /** @see #putAddress(Object, long, long) */
 426     @ForceInline
 427     public void putAddress(long address, long x) {
 428         putAddress(null, address, x);
 429     }
 430 
 431 
 432 
 433     /// helper methods for validating various types of objects/values
 434 
 435     /**
 436      * Create an exception reflecting that some of the input was invalid
 437      *
 438      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 439      * sure arguments are checked before the methods are called. While
 440      * some rudimentary checks are performed on the input, the checks
 441      * are best effort and when performance is an overriding priority,
 442      * as when methods of this class are optimized by the runtime
 443      * compiler, some or all checks (if any) may be elided. Hence, the
 444      * caller must not rely on the checks and corresponding
 445      * exceptions!
 446      *
 447      * @return an exception object
 448      */
 449     private RuntimeException invalidInput() {
 450         return new IllegalArgumentException();
 451     }
 452 
 453     /**
 454      * Check if a value is 32-bit clean (32 MSB are all zero)
 455      *
 456      * @param value the 64-bit value to check
 457      *
 458      * @return true if the value is 32-bit clean
 459      */
 460     private boolean is32BitClean(long value) {
 461         return value &gt;&gt;&gt; 32 == 0;
 462     }
 463 
 464     /**
 465      * Check the validity of a size (the equivalent of a size_t)
 466      *
 467      * @throws RuntimeException if the size is invalid
 468      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 469      *         go undetected, which will lead to unpredictable
 470      *         behavior)
 471      */
 472     private void checkSize(long size) {
 473         if (ADDRESS_SIZE == 4) {
 474             // Note: this will also check for negative sizes
 475             if (!is32BitClean(size)) {
 476                 throw invalidInput();
 477             }
 478         } else if (size &lt; 0) {
 479             throw invalidInput();
 480         }
 481     }
 482 
 483     /**
 484      * Check the validity of a native address (the equivalent of void*)
 485      *
 486      * @throws RuntimeException if the address is invalid
 487      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 488      *         go undetected, which will lead to unpredictable
 489      *         behavior)
 490      */
 491     private void checkNativeAddress(long address) {
 492         if (ADDRESS_SIZE == 4) {
 493             // Accept both zero and sign extended pointers. A valid
 494             // pointer will, after the +1 below, either have produced
 495             // the value 0x0 or 0x1. Masking off the low bit allows
 496             // for testing against 0.
 497             if ((((address &gt;&gt; 32) + 1) &amp; ~1) != 0) {
 498                 throw invalidInput();
 499             }
 500         }
 501     }
 502 
 503     /**
 504      * Check the validity of an offset, relative to a base object
 505      *
 506      * @param o the base object
 507      * @param offset the offset to check
 508      *
 509      * @throws RuntimeException if the size is invalid
 510      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 511      *         go undetected, which will lead to unpredictable
 512      *         behavior)
 513      */
 514     private void checkOffset(Object o, long offset) {
 515         if (ADDRESS_SIZE == 4) {
 516             // Note: this will also check for negative offsets
 517             if (!is32BitClean(offset)) {
 518                 throw invalidInput();
 519             }
 520         } else if (offset &lt; 0) {
 521             throw invalidInput();
 522         }
 523     }
 524 
 525     /**
 526      * Check the validity of a double-register pointer
 527      *
 528      * Note: This code deliberately does *not* check for NPE for (at
 529      * least) three reasons:
 530      *
 531      * 1) NPE is not just NULL/0 - there is a range of values all
 532      * resulting in an NPE, which is not trivial to check for
 533      *
 534      * 2) It is the responsibility of the callers of Unsafe methods
 535      * to verify the input, so throwing an exception here is not really
 536      * useful - passing in a NULL pointer is a critical error and the
 537      * must not expect an exception to be thrown anyway.
 538      *
 539      * 3) the actual operations will detect NULL pointers anyway by
 540      * means of traps and signals (like SIGSEGV).
 541      *
 542      * @param o Java heap object, or null
 543      * @param offset indication of where the variable resides in a Java heap
 544      *        object, if any, else a memory address locating the variable
 545      *        statically
 546      *
 547      * @throws RuntimeException if the pointer is invalid
 548      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 549      *         go undetected, which will lead to unpredictable
 550      *         behavior)
 551      */
 552     private void checkPointer(Object o, long offset) {
 553         if (o == null) {
 554             checkNativeAddress(offset);
 555         } else {
 556             checkOffset(o, offset);
 557         }
 558     }
 559 
 560     /**
 561      * Check if a type is a primitive array type
 562      *
 563      * @param c the type to check
 564      *
 565      * @return true if the type is a primitive array type
 566      */
 567     private void checkPrimitiveArray(Class&lt;?&gt; c) {
 568         Class&lt;?&gt; componentType = c.getComponentType();
 569         if (componentType == null || !componentType.isPrimitive()) {
 570             throw invalidInput();
 571         }
 572     }
 573 
 574     /**
 575      * Check that a pointer is a valid primitive array type pointer
 576      *
 577      * Note: pointers off-heap are considered to be primitive arrays
 578      *
 579      * @throws RuntimeException if the pointer is invalid
 580      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 581      *         go undetected, which will lead to unpredictable
 582      *         behavior)
 583      */
 584     private void checkPrimitivePointer(Object o, long offset) {
 585         checkPointer(o, offset);
 586 
 587         if (o != null) {
 588             // If on heap, it it must be a primitive array
 589             checkPrimitiveArray(o.getClass());
 590         }
 591     }
 592 
 593 
 594     /// wrappers for malloc, realloc, free:
 595 
 596     /**
 597      * Allocates a new block of native memory, of the given size in bytes.  The
 598      * contents of the memory are uninitialized; they will generally be
 599      * garbage.  The resulting native pointer will never be zero, and will be
 600      * aligned for all value types.  Dispose of this memory by calling {@link
 601      * #freeMemory}, or resize it with {@link #reallocateMemory}.
 602      *
 603      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 604      * sure arguments are checked before the methods are called. While
 605      * some rudimentary checks are performed on the input, the checks
 606      * are best effort and when performance is an overriding priority,
 607      * as when methods of this class are optimized by the runtime
 608      * compiler, some or all checks (if any) may be elided. Hence, the
 609      * caller must not rely on the checks and corresponding
 610      * exceptions!
 611      *
 612      * @throws RuntimeException if the size is negative or too large
 613      *         for the native size_t type
 614      *
 615      * @throws OutOfMemoryError if the allocation is refused by the system
 616      *
 617      * @see #getByte(long)
 618      * @see #putByte(long, byte)
 619      */
 620     public long allocateMemory(long bytes) {
 621         allocateMemoryChecks(bytes);
 622 
 623         if (bytes == 0) {
 624             return 0;
 625         }
 626 
 627         long p = allocateMemory0(bytes);
 628         if (p == 0) {
 629             throw new OutOfMemoryError();
 630         }
 631 
 632         return p;
 633     }
 634 
 635     /**
 636      * Validate the arguments to allocateMemory
 637      *
 638      * @throws RuntimeException if the arguments are invalid
 639      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 640      *         go undetected, which will lead to unpredictable
 641      *         behavior)
 642      */
 643     private void allocateMemoryChecks(long bytes) {
 644         checkSize(bytes);
 645     }
 646 
 647     /**
 648      * Resizes a new block of native memory, to the given size in bytes.  The
 649      * contents of the new block past the size of the old block are
 650      * uninitialized; they will generally be garbage.  The resulting native
 651      * pointer will be zero if and only if the requested size is zero.  The
 652      * resulting native pointer will be aligned for all value types.  Dispose
 653      * of this memory by calling {@link #freeMemory}, or resize it with {@link
 654      * #reallocateMemory}.  The address passed to this method may be null, in
 655      * which case an allocation will be performed.
 656      *
 657      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 658      * sure arguments are checked before the methods are called. While
 659      * some rudimentary checks are performed on the input, the checks
 660      * are best effort and when performance is an overriding priority,
 661      * as when methods of this class are optimized by the runtime
 662      * compiler, some or all checks (if any) may be elided. Hence, the
 663      * caller must not rely on the checks and corresponding
 664      * exceptions!
 665      *
 666      * @throws RuntimeException if the size is negative or too large
 667      *         for the native size_t type
 668      *
 669      * @throws OutOfMemoryError if the allocation is refused by the system
 670      *
 671      * @see #allocateMemory
 672      */
 673     public long reallocateMemory(long address, long bytes) {
 674         reallocateMemoryChecks(address, bytes);
 675 
 676         if (bytes == 0) {
 677             freeMemory(address);
 678             return 0;
 679         }
 680 
 681         long p = (address == 0) ? allocateMemory0(bytes) : reallocateMemory0(address, bytes);
 682         if (p == 0) {
 683             throw new OutOfMemoryError();
 684         }
 685 
 686         return p;
 687     }
 688 
 689     /**
 690      * Validate the arguments to reallocateMemory
 691      *
 692      * @throws RuntimeException if the arguments are invalid
 693      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 694      *         go undetected, which will lead to unpredictable
 695      *         behavior)
 696      */
 697     private void reallocateMemoryChecks(long address, long bytes) {
 698         checkPointer(null, address);
 699         checkSize(bytes);
 700     }
 701 
 702     /**
 703      * Sets all bytes in a given block of memory to a fixed value
 704      * (usually zero).
 705      *
 706      * &lt;p&gt;This method determines a block's base address by means of two parameters,
 707      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 708      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 709      * the offset supplies an absolute base address.
 710      *
 711      * &lt;p&gt;The stores are in coherent (atomic) units of a size determined
 712      * by the address and length parameters.  If the effective address and
 713      * length are all even modulo 8, the stores take place in 'long' units.
 714      * If the effective address and length are (resp.) even modulo 4 or 2,
 715      * the stores take place in units of 'int' or 'short'.
 716      *
 717      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 718      * sure arguments are checked before the methods are called. While
 719      * some rudimentary checks are performed on the input, the checks
 720      * are best effort and when performance is an overriding priority,
 721      * as when methods of this class are optimized by the runtime
 722      * compiler, some or all checks (if any) may be elided. Hence, the
 723      * caller must not rely on the checks and corresponding
 724      * exceptions!
 725      *
 726      * @throws RuntimeException if any of the arguments is invalid
 727      *
 728      * @since 1.7
 729      */
 730     public void setMemory(Object o, long offset, long bytes, byte value) {
 731         setMemoryChecks(o, offset, bytes, value);
 732 
 733         if (bytes == 0) {
 734             return;
 735         }
 736 
 737         setMemory0(o, offset, bytes, value);
 738     }
 739 
 740     /**
 741      * Sets all bytes in a given block of memory to a fixed value
 742      * (usually zero).  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 743      * as discussed in {@link #getInt(Object,long)}.
 744      *
 745      * &lt;p&gt;Equivalent to {@code setMemory(null, address, bytes, value)}.
 746      */
 747     public void setMemory(long address, long bytes, byte value) {
 748         setMemory(null, address, bytes, value);
 749     }
 750 
 751     /**
 752      * Validate the arguments to setMemory
 753      *
 754      * @throws RuntimeException if the arguments are invalid
 755      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 756      *         go undetected, which will lead to unpredictable
 757      *         behavior)
 758      */
 759     private void setMemoryChecks(Object o, long offset, long bytes, byte value) {
 760         checkPrimitivePointer(o, offset);
 761         checkSize(bytes);
 762     }
 763 
 764     /**
 765      * Sets all bytes in a given block of memory to a copy of another
 766      * block.
 767      *
 768      * &lt;p&gt;This method determines each block's base address by means of two parameters,
 769      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 770      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 771      * the offset supplies an absolute base address.
 772      *
 773      * &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
 774      * by the address and length parameters.  If the effective addresses and
 775      * length are all even modulo 8, the transfer takes place in 'long' units.
 776      * If the effective addresses and length are (resp.) even modulo 4 or 2,
 777      * the transfer takes place in units of 'int' or 'short'.
 778      *
 779      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 780      * sure arguments are checked before the methods are called. While
 781      * some rudimentary checks are performed on the input, the checks
 782      * are best effort and when performance is an overriding priority,
 783      * as when methods of this class are optimized by the runtime
 784      * compiler, some or all checks (if any) may be elided. Hence, the
 785      * caller must not rely on the checks and corresponding
 786      * exceptions!
 787      *
 788      * @throws RuntimeException if any of the arguments is invalid
 789      *
 790      * @since 1.7
 791      */
 792     public void copyMemory(Object srcBase, long srcOffset,
 793                            Object destBase, long destOffset,
 794                            long bytes) {
 795         copyMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes);
 796 
 797         if (bytes == 0) {
 798             return;
 799         }
 800 
 801         copyMemory0(srcBase, srcOffset, destBase, destOffset, bytes);
 802     }
 803 
 804     /**
 805      * Sets all bytes in a given block of memory to a copy of another
 806      * block.  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 807      * as discussed in {@link #getInt(Object,long)}.
 808      *
 809      * Equivalent to {@code copyMemory(null, srcAddress, null, destAddress, bytes)}.
 810      */
 811     public void copyMemory(long srcAddress, long destAddress, long bytes) {
 812         copyMemory(null, srcAddress, null, destAddress, bytes);
 813     }
 814 
 815     /**
 816      * Validate the arguments to copyMemory
 817      *
 818      * @throws RuntimeException if any of the arguments is invalid
 819      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 820      *         go undetected, which will lead to unpredictable
 821      *         behavior)
 822      */
 823     private void copyMemoryChecks(Object srcBase, long srcOffset,
 824                                   Object destBase, long destOffset,
 825                                   long bytes) {
 826         checkSize(bytes);
 827         checkPrimitivePointer(srcBase, srcOffset);
 828         checkPrimitivePointer(destBase, destOffset);
 829     }
 830 
 831     /**
 832      * Copies all elements from one block of memory to another block,
 833      * *unconditionally* byte swapping the elements on the fly.
 834      *
 835      * &lt;p&gt;This method determines each block's base address by means of two parameters,
 836      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 837      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 838      * the offset supplies an absolute base address.
 839      *
 840      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 841      * sure arguments are checked before the methods are called. While
 842      * some rudimentary checks are performed on the input, the checks
 843      * are best effort and when performance is an overriding priority,
 844      * as when methods of this class are optimized by the runtime
 845      * compiler, some or all checks (if any) may be elided. Hence, the
 846      * caller must not rely on the checks and corresponding
 847      * exceptions!
 848      *
 849      * @throws RuntimeException if any of the arguments is invalid
 850      *
 851      * @since 9
 852      */
 853     public void copySwapMemory(Object srcBase, long srcOffset,
 854                                Object destBase, long destOffset,
 855                                long bytes, long elemSize) {
 856         copySwapMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 857 
 858         if (bytes == 0) {
 859             return;
 860         }
 861 
 862         copySwapMemory0(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 863     }
 864 
 865     private void copySwapMemoryChecks(Object srcBase, long srcOffset,
 866                                       Object destBase, long destOffset,
 867                                       long bytes, long elemSize) {
 868         checkSize(bytes);
 869 
 870         if (elemSize != 2 &amp;&amp; elemSize != 4 &amp;&amp; elemSize != 8) {
 871             throw invalidInput();
 872         }
 873         if (bytes % elemSize != 0) {
 874             throw invalidInput();
 875         }
 876 
 877         checkPrimitivePointer(srcBase, srcOffset);
 878         checkPrimitivePointer(destBase, destOffset);
 879     }
 880 
 881    /**
 882      * Copies all elements from one block of memory to another block, byte swapping the
 883      * elements on the fly.
 884      *
 885      * This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode, as
 886      * discussed in {@link #getInt(Object,long)}.
 887      *
 888      * Equivalent to {@code copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize)}.
 889      */
 890     public void copySwapMemory(long srcAddress, long destAddress, long bytes, long elemSize) {
 891         copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize);
 892     }
 893 
 894     /**
 895      * Disposes of a block of native memory, as obtained from {@link
 896      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 897      * this method may be null, in which case no action is taken.
 898      *
 899      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 900      * sure arguments are checked before the methods are called. While
 901      * some rudimentary checks are performed on the input, the checks
 902      * are best effort and when performance is an overriding priority,
 903      * as when methods of this class are optimized by the runtime
 904      * compiler, some or all checks (if any) may be elided. Hence, the
 905      * caller must not rely on the checks and corresponding
 906      * exceptions!
 907      *
 908      * @throws RuntimeException if any of the arguments is invalid
 909      *
 910      * @see #allocateMemory
 911      */
 912     public void freeMemory(long address) {
 913         freeMemoryChecks(address);
 914 
 915         if (address == 0) {
 916             return;
 917         }
 918 
 919         freeMemory0(address);
 920     }
 921 
 922     /**
 923      * Validate the arguments to freeMemory
 924      *
 925      * @throws RuntimeException if the arguments are invalid
 926      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 927      *         go undetected, which will lead to unpredictable
 928      *         behavior)
 929      */
 930     private void freeMemoryChecks(long address) {
 931         checkPointer(null, address);
 932     }
 933 
 934     /// random queries
 935 
 936     /**
 937      * This constant differs from all results that will ever be returned from
 938      * {@link #staticFieldOffset}, {@link #objectFieldOffset},
 939      * or {@link #arrayBaseOffset}.
 940      */
 941     public static final int INVALID_FIELD_OFFSET = -1;
 942 
 943     /**
 944      * Reports the location of a given field in the storage allocation of its
 945      * class.  Do not expect to perform any sort of arithmetic on this offset;
 946      * it is just a cookie which is passed to the unsafe heap memory accessors.
 947      *
 948      * &lt;p&gt;Any given field will always have the same offset and base, and no
 949      * two distinct fields of the same class will ever have the same offset
 950      * and base.
 951      *
 952      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 953      * although the Sun JVM does not use the most significant 32 bits.
 954      * However, JVM implementations which store static fields at absolute
 955      * addresses can use long offsets and null base pointers to express
 956      * the field locations in a form usable by {@link #getInt(Object,long)}.
 957      * Therefore, code which will be ported to such JVMs on 64-bit platforms
 958      * must preserve all bits of static field offsets.
 959      * @see #getInt(Object, long)
 960      */
 961     public long objectFieldOffset(Field f) {
 962         if (f == null) {
 963             throw new NullPointerException();
 964         }
 965 
 966         return objectFieldOffset0(f);
 967     }
 968 
 969     /**
 970      * Reports the location of a given static field, in conjunction with {@link
 971      * #staticFieldBase}.
 972      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
 973      * it is just a cookie which is passed to the unsafe heap memory accessors.
 974      *
 975      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
 976      * fields of the same class will ever have the same offset.
 977      *
 978      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 979      * although the Sun JVM does not use the most significant 32 bits.
 980      * It is hard to imagine a JVM technology which needs more than
 981      * a few bits to encode an offset within a non-array object,
 982      * However, for consistency with other methods in this class,
 983      * this method reports its result as a long value.
 984      * @see #getInt(Object, long)
 985      */
 986     public long staticFieldOffset(Field f) {
 987         if (f == null) {
 988             throw new NullPointerException();
 989         }
 990 
 991         return staticFieldOffset0(f);
 992     }
 993 
 994     /**
 995      * Reports the location of a given static field, in conjunction with {@link
 996      * #staticFieldOffset}.
 997      * &lt;p&gt;Fetch the base "Object", if any, with which static fields of the
 998      * given class can be accessed via methods like {@link #getInt(Object,
 999      * long)}.  This value may be null.  This value may refer to an object
1000      * which is a "cookie", not guaranteed to be a real Object, and it should
1001      * not be used in any way except as argument to the get and put routines in
1002      * this class.
1003      */
1004     public Object staticFieldBase(Field f) {
1005         if (f == null) {
1006             throw new NullPointerException();
1007         }
1008 
1009         return staticFieldBase0(f);
1010     }
1011 
1012     /**
1013      * Detects if the given class may need to be initialized. This is often
1014      * needed in conjunction with obtaining the static field base of a
1015      * class.
1016      * @return false only if a call to {@code ensureClassInitialized} would have no effect
1017      */
1018     public boolean shouldBeInitialized(Class&lt;?&gt; c) {
1019         if (c == null) {
1020             throw new NullPointerException();
1021         }
1022 
1023         return shouldBeInitialized0(c);
1024     }
1025 
1026     /**
1027      * Ensures the given class has been initialized. This is often
1028      * needed in conjunction with obtaining the static field base of a
1029      * class.
1030      */
1031     public void ensureClassInitialized(Class&lt;?&gt; c) {
1032         if (c == null) {
1033             throw new NullPointerException();
1034         }
1035 
1036         ensureClassInitialized0(c);
1037     }
1038 
1039     /**
1040      * Reports the offset of the first element in the storage allocation of a
1041      * given array class.  If {@link #arrayIndexScale} returns a non-zero value
1042      * for the same class, you may use that scale factor, together with this
1043      * base offset, to form new offsets to access elements of arrays of the
1044      * given class.
1045      *
1046      * @see #getInt(Object, long)
1047      * @see #putInt(Object, long, int)
1048      */
1049     public int arrayBaseOffset(Class&lt;?&gt; arrayClass) {
1050         if (arrayClass == null) {
1051             throw new NullPointerException();
1052         }
1053 
1054         return arrayBaseOffset0(arrayClass);
1055     }
1056 
1057 
1058     /** The value of {@code arrayBaseOffset(boolean[].class)} */
1059     public static final int ARRAY_BOOLEAN_BASE_OFFSET
1060             = theUnsafe.arrayBaseOffset(boolean[].class);
1061 
1062     /** The value of {@code arrayBaseOffset(byte[].class)} */
1063     public static final int ARRAY_BYTE_BASE_OFFSET
1064             = theUnsafe.arrayBaseOffset(byte[].class);
1065 
1066     /** The value of {@code arrayBaseOffset(short[].class)} */
1067     public static final int ARRAY_SHORT_BASE_OFFSET
1068             = theUnsafe.arrayBaseOffset(short[].class);
1069 
1070     /** The value of {@code arrayBaseOffset(char[].class)} */
1071     public static final int ARRAY_CHAR_BASE_OFFSET
1072             = theUnsafe.arrayBaseOffset(char[].class);
1073 
1074     /** The value of {@code arrayBaseOffset(int[].class)} */
1075     public static final int ARRAY_INT_BASE_OFFSET
1076             = theUnsafe.arrayBaseOffset(int[].class);
1077 
1078     /** The value of {@code arrayBaseOffset(long[].class)} */
1079     public static final int ARRAY_LONG_BASE_OFFSET
1080             = theUnsafe.arrayBaseOffset(long[].class);
1081 
1082     /** The value of {@code arrayBaseOffset(float[].class)} */
1083     public static final int ARRAY_FLOAT_BASE_OFFSET
1084             = theUnsafe.arrayBaseOffset(float[].class);
1085 
1086     /** The value of {@code arrayBaseOffset(double[].class)} */
1087     public static final int ARRAY_DOUBLE_BASE_OFFSET
1088             = theUnsafe.arrayBaseOffset(double[].class);
1089 
1090     /** The value of {@code arrayBaseOffset(Object[].class)} */
1091     public static final int ARRAY_OBJECT_BASE_OFFSET
1092             = theUnsafe.arrayBaseOffset(Object[].class);
1093 
1094     /**
1095      * Reports the scale factor for addressing elements in the storage
1096      * allocation of a given array class.  However, arrays of "narrow" types
1097      * will generally not work properly with accessors like {@link
1098      * #getByte(Object, long)}, so the scale factor for such classes is reported
1099      * as zero.
1100      *
1101      * @see #arrayBaseOffset
1102      * @see #getInt(Object, long)
1103      * @see #putInt(Object, long, int)
1104      */
1105     public int arrayIndexScale(Class&lt;?&gt; arrayClass) {
1106         if (arrayClass == null) {
1107             throw new NullPointerException();
1108         }
1109 
1110         return arrayIndexScale0(arrayClass);
1111     }
1112 
1113 
1114     /** The value of {@code arrayIndexScale(boolean[].class)} */
1115     public static final int ARRAY_BOOLEAN_INDEX_SCALE
1116             = theUnsafe.arrayIndexScale(boolean[].class);
1117 
1118     /** The value of {@code arrayIndexScale(byte[].class)} */
1119     public static final int ARRAY_BYTE_INDEX_SCALE
1120             = theUnsafe.arrayIndexScale(byte[].class);
1121 
1122     /** The value of {@code arrayIndexScale(short[].class)} */
1123     public static final int ARRAY_SHORT_INDEX_SCALE
1124             = theUnsafe.arrayIndexScale(short[].class);
1125 
1126     /** The value of {@code arrayIndexScale(char[].class)} */
1127     public static final int ARRAY_CHAR_INDEX_SCALE
1128             = theUnsafe.arrayIndexScale(char[].class);
1129 
1130     /** The value of {@code arrayIndexScale(int[].class)} */
1131     public static final int ARRAY_INT_INDEX_SCALE
1132             = theUnsafe.arrayIndexScale(int[].class);
1133 
1134     /** The value of {@code arrayIndexScale(long[].class)} */
1135     public static final int ARRAY_LONG_INDEX_SCALE
1136             = theUnsafe.arrayIndexScale(long[].class);
1137 
1138     /** The value of {@code arrayIndexScale(float[].class)} */
1139     public static final int ARRAY_FLOAT_INDEX_SCALE
1140             = theUnsafe.arrayIndexScale(float[].class);
1141 
1142     /** The value of {@code arrayIndexScale(double[].class)} */
1143     public static final int ARRAY_DOUBLE_INDEX_SCALE
1144             = theUnsafe.arrayIndexScale(double[].class);
1145 
1146     /** The value of {@code arrayIndexScale(Object[].class)} */
1147     public static final int ARRAY_OBJECT_INDEX_SCALE
1148             = theUnsafe.arrayIndexScale(Object[].class);
1149 
1150     /**
1151      * Reports the size in bytes of a native pointer, as stored via {@link
1152      * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
1153      * other primitive types (as stored in native memory blocks) is determined
1154      * fully by their information content.
1155      */
1156     public int addressSize() {
1157         return ADDRESS_SIZE;
1158     }
1159 
1160     /** The value of {@code addressSize()} */
1161     public static final int ADDRESS_SIZE = theUnsafe.addressSize0();
1162 
1163     /**
1164      * Reports the size in bytes of a native memory page (whatever that is).
1165      * This value will always be a power of two.
1166      */
1167     public native int pageSize();
1168 
1169 
1170     /// random trusted operations from JNI:
1171 
1172     /**
1173      * Tells the VM to define a class, without security checks.  By default, the
1174      * class loader and protection domain come from the caller's class.
1175      */
1176     public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,
1177                                 ClassLoader loader,
1178                                 ProtectionDomain protectionDomain) {
1179         if (b == null) {
1180             throw new NullPointerException();
1181         }
1182         if (len &lt; 0) {
1183             throw new ArrayIndexOutOfBoundsException();
1184         }
1185 
1186         return defineClass0(name, b, off, len, loader, protectionDomain);
1187     }
1188 
1189     public native Class&lt;?&gt; defineClass0(String name, byte[] b, int off, int len,
1190                                         ClassLoader loader,
1191                                         ProtectionDomain protectionDomain);
1192 
1193     /**
1194      * Defines a class but does not make it known to the class loader or system dictionary.
1195      * &lt;p&gt;
1196      * For each CP entry, the corresponding CP patch must either be null or have
1197      * the a format that matches its tag:
1198      * &lt;ul&gt;
1199      * &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
1200      * &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
1201      * &lt;li&gt;Class: any java.lang.Class object
1202      * &lt;li&gt;String: any object (not just a java.lang.String)
1203      * &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments
1204      * &lt;/ul&gt;
1205      * @param hostClass context for linkage, access control, protection domain, and class loader
1206      * @param data      bytes of a class file
1207      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
1208      */
1209     public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches) {
1210         if (hostClass == null || data == null) {
1211             throw new NullPointerException();
1212         }
1213 
1214         return defineAnonymousClass0(hostClass, data, cpPatches);
1215     }
1216 
1217     /**
1218      * Allocates an instance but does not run any constructor.
1219      * Initializes the class if it has not yet been.
1220      */
1221     @HotSpotIntrinsicCandidate
1222     public native Object allocateInstance(Class&lt;?&gt; cls)
1223         throws InstantiationException;
1224 
1225     /**
1226      * Allocates an array of a given type, but does not do zeroing.
1227      * &lt;p&gt;
1228      * This method should only be used in the very rare cases where a high-performance code
1229      * overwrites the destination array completely, and compilers cannot assist in zeroing elimination.
1230      * In an overwhelming majority of cases, a normal Java allocation should be used instead.
1231      * &lt;p&gt;
1232      * Users of this method are &lt;b&gt;required&lt;/b&gt; to overwrite the initial (garbage) array contents
1233      * before allowing untrusted code, or code in other threads, to observe the reference
1234      * to the newly allocated array. In addition, the publication of the array reference must be
1235      * safe according to the Java Memory Model requirements.
1236      * &lt;p&gt;
1237      * The safest approach to deal with an uninitialized array is to keep the reference to it in local
1238      * variable at least until the initialization is complete, and then publish it &lt;b&gt;once&lt;/b&gt;, either
1239      * by writing it to a &lt;em&gt;volatile&lt;/em&gt; field, or storing it into a &lt;em&gt;final&lt;/em&gt; field in constructor,
1240      * or issuing a {@link #storeFence} before publishing the reference.
1241      * &lt;p&gt;
1242      * @implnote This method can only allocate primitive arrays, to avoid garbage reference
1243      * elements that could break heap integrity.
1244      *
1245      * @param componentType array component type to allocate
1246      * @param length array size to allocate
1247      * @throws IllegalArgumentException if component type is null, or not a primitive class;
1248      *                                  or the length is negative
1249      */
1250     public Object allocateUninitializedArray(Class&lt;?&gt; componentType, int length) {
1251        if (componentType == null) {
1252            throw new IllegalArgumentException("Component type is null");
1253        }
1254        if (!componentType.isPrimitive()) {
1255            throw new IllegalArgumentException("Component type is not primitive");
1256        }
1257        if (length &lt; 0) {
1258            throw new IllegalArgumentException("Negative length");
1259        }
1260        return allocateUninitializedArray0(componentType, length);
1261     }
1262 
1263     @HotSpotIntrinsicCandidate
1264     private Object allocateUninitializedArray0(Class&lt;?&gt; componentType, int length) {
1265        // These fallbacks provide zeroed arrays, but intrinsic is not required to
1266        // return the zeroed arrays.
1267        if (componentType == byte.class)    return new byte[length];
1268        if (componentType == boolean.class) return new boolean[length];
1269        if (componentType == short.class)   return new short[length];
1270        if (componentType == char.class)    return new char[length];
1271        if (componentType == int.class)     return new int[length];
1272        if (componentType == float.class)   return new float[length];
1273        if (componentType == long.class)    return new long[length];
1274        if (componentType == double.class)  return new double[length];
1275        return null;
1276     }
1277 
1278     /** Throws the exception without telling the verifier. */
1279     public native void throwException(Throwable ee);
1280 
1281     /**
1282      * Atomically updates Java variable to {@code x} if it is currently
1283      * holding {@code expected}.
1284      *
1285      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1286      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1287      *
1288      * @return {@code true} if successful
1289      */
1290     @HotSpotIntrinsicCandidate
1291     public final native boolean compareAndSwapObject(Object o, long offset,
1292                                                      Object expected,
1293                                                      Object x);
1294 
1295     @HotSpotIntrinsicCandidate
1296     public final native Object compareAndExchangeObjectVolatile(Object o, long offset,
1297                                                                 Object expected,
1298                                                                 Object x);
1299 
1300     @HotSpotIntrinsicCandidate
1301     public final Object compareAndExchangeObjectAcquire(Object o, long offset,
1302                                                                Object expected,
1303                                                                Object x) {
1304         return compareAndExchangeObjectVolatile(o, offset, expected, x);
1305     }
1306 
1307     @HotSpotIntrinsicCandidate
1308     public final Object compareAndExchangeObjectRelease(Object o, long offset,
1309                                                                Object expected,
1310                                                                Object x) {
1311         return compareAndExchangeObjectVolatile(o, offset, expected, x);
1312     }
1313 
1314     @HotSpotIntrinsicCandidate
1315     public final boolean weakCompareAndSwapObject(Object o, long offset,
1316                                                          Object expected,
1317                                                          Object x) {
1318         return compareAndSwapObject(o, offset, expected, x);
1319     }
1320 
1321     @HotSpotIntrinsicCandidate
1322     public final boolean weakCompareAndSwapObjectAcquire(Object o, long offset,
1323                                                                 Object expected,
1324                                                                 Object x) {
1325         return compareAndSwapObject(o, offset, expected, x);
1326     }
1327 
1328     @HotSpotIntrinsicCandidate
1329     public final boolean weakCompareAndSwapObjectRelease(Object o, long offset,
1330                                                                 Object expected,
1331                                                                 Object x) {
1332         return compareAndSwapObject(o, offset, expected, x);
1333     }
1334 
1335     @HotSpotIntrinsicCandidate
1336     public final boolean weakCompareAndSwapObjectVolatile(Object o, long offset,
1337                                                                 Object expected,
1338                                                                 Object x) {
1339         return compareAndSwapObject(o, offset, expected, x);
1340     }
1341 
1342     /**
1343      * Atomically updates Java variable to {@code x} if it is currently
1344      * holding {@code expected}.
1345      *
1346      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1347      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1348      *
1349      * @return {@code true} if successful
1350      */
1351     @HotSpotIntrinsicCandidate
1352     public final native boolean compareAndSwapInt(Object o, long offset,
1353                                                   int expected,
1354                                                   int x);
1355 
1356     @HotSpotIntrinsicCandidate
1357     public final native int compareAndExchangeIntVolatile(Object o, long offset,
1358                                                           int expected,
1359                                                           int x);
1360 
1361     @HotSpotIntrinsicCandidate
1362     public final int compareAndExchangeIntAcquire(Object o, long offset,
1363                                                          int expected,
1364                                                          int x) {
1365         return compareAndExchangeIntVolatile(o, offset, expected, x);
1366     }
1367 
1368     @HotSpotIntrinsicCandidate
1369     public final int compareAndExchangeIntRelease(Object o, long offset,
1370                                                          int expected,
1371                                                          int x) {
1372         return compareAndExchangeIntVolatile(o, offset, expected, x);
1373     }
1374 
1375     @HotSpotIntrinsicCandidate
1376     public final boolean weakCompareAndSwapInt(Object o, long offset,
1377                                                       int expected,
1378                                                       int x) {
1379         return compareAndSwapInt(o, offset, expected, x);
1380     }
1381 
1382     @HotSpotIntrinsicCandidate
1383     public final boolean weakCompareAndSwapIntAcquire(Object o, long offset,
1384                                                              int expected,
1385                                                              int x) {
1386         return compareAndSwapInt(o, offset, expected, x);
1387     }
1388 
1389     @HotSpotIntrinsicCandidate
1390     public final boolean weakCompareAndSwapIntRelease(Object o, long offset,
1391                                                              int expected,
1392                                                              int x) {
1393         return compareAndSwapInt(o, offset, expected, x);
1394     }
1395 
1396     @HotSpotIntrinsicCandidate
1397     public final boolean weakCompareAndSwapIntVolatile(Object o, long offset,
1398                                                              int expected,
1399                                                              int x) {
1400         return compareAndSwapInt(o, offset, expected, x);
1401     }
1402 
1403     /**
1404      * Atomically updates Java variable to {@code x} if it is currently
1405      * holding {@code expected}.
1406      *
1407      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1408      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1409      *
1410      * @return {@code true} if successful
1411      */
1412     @HotSpotIntrinsicCandidate
1413     public final native boolean compareAndSwapLong(Object o, long offset,
1414                                                    long expected,
1415                                                    long x);
1416 
1417     @HotSpotIntrinsicCandidate
1418     public final native long compareAndExchangeLongVolatile(Object o, long offset,
1419                                                             long expected,
1420                                                             long x);
1421 
1422     @HotSpotIntrinsicCandidate
1423     public final long compareAndExchangeLongAcquire(Object o, long offset,
1424                                                            long expected,
1425                                                            long x) {
1426         return compareAndExchangeLongVolatile(o, offset, expected, x);
1427     }
1428 
1429     @HotSpotIntrinsicCandidate
1430     public final long compareAndExchangeLongRelease(Object o, long offset,
1431                                                            long expected,
1432                                                            long x) {
1433         return compareAndExchangeLongVolatile(o, offset, expected, x);
1434     }
1435 
1436     @HotSpotIntrinsicCandidate
1437     public final boolean weakCompareAndSwapLong(Object o, long offset,
1438                                                        long expected,
1439                                                        long x) {
1440         return compareAndSwapLong(o, offset, expected, x);
1441     }
1442 
1443     @HotSpotIntrinsicCandidate
1444     public final boolean weakCompareAndSwapLongAcquire(Object o, long offset,
1445                                                               long expected,
1446                                                               long x) {
1447         return compareAndSwapLong(o, offset, expected, x);
1448     }
1449 
1450     @HotSpotIntrinsicCandidate
1451     public final boolean weakCompareAndSwapLongRelease(Object o, long offset,
1452                                                               long expected,
1453                                                               long x) {
1454         return compareAndSwapLong(o, offset, expected, x);
1455     }
1456 
1457     @HotSpotIntrinsicCandidate
1458     public final boolean weakCompareAndSwapLongVolatile(Object o, long offset,
1459                                                               long expected,
1460                                                               long x) {
1461         return compareAndSwapLong(o, offset, expected, x);
1462     }
1463 
1464     /**
1465      * Fetches a reference value from a given Java variable, with volatile
1466      * load semantics. Otherwise identical to {@link #getObject(Object, long)}
1467      */
1468     @HotSpotIntrinsicCandidate
1469     public native Object getObjectVolatile(Object o, long offset);
1470 
1471     /**
1472      * Stores a reference value into a given Java variable, with
1473      * volatile store semantics. Otherwise identical to {@link #putObject(Object, long, Object)}
1474      */
1475     @HotSpotIntrinsicCandidate
1476     public native void    putObjectVolatile(Object o, long offset, Object x);
1477 
1478     /** Volatile version of {@link #getInt(Object, long)}  */
1479     @HotSpotIntrinsicCandidate
1480     public native int     getIntVolatile(Object o, long offset);
1481 
1482     /** Volatile version of {@link #putInt(Object, long, int)}  */
1483     @HotSpotIntrinsicCandidate
1484     public native void    putIntVolatile(Object o, long offset, int x);
1485 
1486     /** Volatile version of {@link #getBoolean(Object, long)}  */
1487     @HotSpotIntrinsicCandidate
1488     public native boolean getBooleanVolatile(Object o, long offset);
1489 
1490     /** Volatile version of {@link #putBoolean(Object, long, boolean)}  */
1491     @HotSpotIntrinsicCandidate
1492     public native void    putBooleanVolatile(Object o, long offset, boolean x);
1493 
1494     /** Volatile version of {@link #getByte(Object, long)}  */
1495     @HotSpotIntrinsicCandidate
1496     public native byte    getByteVolatile(Object o, long offset);
1497 
1498     /** Volatile version of {@link #putByte(Object, long, byte)}  */
1499     @HotSpotIntrinsicCandidate
1500     public native void    putByteVolatile(Object o, long offset, byte x);
1501 
1502     /** Volatile version of {@link #getShort(Object, long)}  */
1503     @HotSpotIntrinsicCandidate
1504     public native short   getShortVolatile(Object o, long offset);
1505 
1506     /** Volatile version of {@link #putShort(Object, long, short)}  */
1507     @HotSpotIntrinsicCandidate
1508     public native void    putShortVolatile(Object o, long offset, short x);
1509 
1510     /** Volatile version of {@link #getChar(Object, long)}  */
1511     @HotSpotIntrinsicCandidate
1512     public native char    getCharVolatile(Object o, long offset);
1513 
1514     /** Volatile version of {@link #putChar(Object, long, char)}  */
1515     @HotSpotIntrinsicCandidate
1516     public native void    putCharVolatile(Object o, long offset, char x);
1517 
1518     /** Volatile version of {@link #getLong(Object, long)}  */
1519     @HotSpotIntrinsicCandidate
1520     public native long    getLongVolatile(Object o, long offset);
1521 
1522     /** Volatile version of {@link #putLong(Object, long, long)}  */
1523     @HotSpotIntrinsicCandidate
1524     public native void    putLongVolatile(Object o, long offset, long x);
1525 
1526     /** Volatile version of {@link #getFloat(Object, long)}  */
1527     @HotSpotIntrinsicCandidate
1528     public native float   getFloatVolatile(Object o, long offset);
1529 
1530     /** Volatile version of {@link #putFloat(Object, long, float)}  */
1531     @HotSpotIntrinsicCandidate
1532     public native void    putFloatVolatile(Object o, long offset, float x);
1533 
1534     /** Volatile version of {@link #getDouble(Object, long)}  */
1535     @HotSpotIntrinsicCandidate
1536     public native double  getDoubleVolatile(Object o, long offset);
1537 
1538     /** Volatile version of {@link #putDouble(Object, long, double)}  */
1539     @HotSpotIntrinsicCandidate
1540     public native void    putDoubleVolatile(Object o, long offset, double x);
1541 
1542 
1543 
1544     /** Acquire version of {@link #getObjectVolatile(Object, long)} */
1545     @HotSpotIntrinsicCandidate
1546     public final Object getObjectAcquire(Object o, long offset) {
1547         return getObjectVolatile(o, offset);
1548     }
1549 
1550     /** Acquire version of {@link #getBooleanVolatile(Object, long)} */
1551     @HotSpotIntrinsicCandidate
1552     public final boolean getBooleanAcquire(Object o, long offset) {
1553         return getBooleanVolatile(o, offset);
1554     }
1555 
1556     /** Acquire version of {@link #getByteVolatile(Object, long)} */
1557     @HotSpotIntrinsicCandidate
1558     public final byte getByteAcquire(Object o, long offset) {
1559         return getByteVolatile(o, offset);
1560     }
1561 
1562     /** Acquire version of {@link #getShortVolatile(Object, long)} */
1563     @HotSpotIntrinsicCandidate
1564     public final short getShortAcquire(Object o, long offset) {
1565         return getShortVolatile(o, offset);
1566     }
1567 
1568     /** Acquire version of {@link #getCharVolatile(Object, long)} */
1569     @HotSpotIntrinsicCandidate
1570     public final char getCharAcquire(Object o, long offset) {
1571         return getCharVolatile(o, offset);
1572     }
1573 
1574     /** Acquire version of {@link #getIntVolatile(Object, long)} */
1575     @HotSpotIntrinsicCandidate
1576     public final int getIntAcquire(Object o, long offset) {
1577         return getIntVolatile(o, offset);
1578     }
1579 
1580     /** Acquire version of {@link #getFloatVolatile(Object, long)} */
1581     @HotSpotIntrinsicCandidate
1582     public final float getFloatAcquire(Object o, long offset) {
1583         return getFloatVolatile(o, offset);
1584     }
1585 
1586     /** Acquire version of {@link #getLongVolatile(Object, long)} */
1587     @HotSpotIntrinsicCandidate
1588     public final long getLongAcquire(Object o, long offset) {
1589         return getLongVolatile(o, offset);
1590     }
1591 
1592     /** Acquire version of {@link #getDoubleVolatile(Object, long)} */
1593     @HotSpotIntrinsicCandidate
1594     public final double getDoubleAcquire(Object o, long offset) {
1595         return getDoubleVolatile(o, offset);
1596     }
1597 
1598     /*
1599       * Versions of {@link #putObjectVolatile(Object, long, Object)}
1600       * that do not guarantee immediate visibility of the store to
1601       * other threads. This method is generally only useful if the
1602       * underlying field is a Java volatile (or if an array cell, one
1603       * that is otherwise only accessed using volatile accesses).
1604       *
1605       * Corresponds to C11 atomic_store_explicit(..., memory_order_release).
1606       */
1607 
1608     /** Release version of {@link #putObjectVolatile(Object, long, Object)} */
1609     @HotSpotIntrinsicCandidate
1610     public final void putObjectRelease(Object o, long offset, Object x) {
1611         putObjectVolatile(o, offset, x);
1612     }
1613 
1614     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
1615     @HotSpotIntrinsicCandidate
1616     public final void putBooleanRelease(Object o, long offset, boolean x) {
1617         putBooleanVolatile(o, offset, x);
1618     }
1619 
1620     /** Release version of {@link #putByteVolatile(Object, long, byte)} */
1621     @HotSpotIntrinsicCandidate
1622     public final void putByteRelease(Object o, long offset, byte x) {
1623         putByteVolatile(o, offset, x);
1624     }
1625 
1626     /** Release version of {@link #putShortVolatile(Object, long, short)} */
1627     @HotSpotIntrinsicCandidate
1628     public final void putShortRelease(Object o, long offset, short x) {
1629         putShortVolatile(o, offset, x);
1630     }
1631 
1632     /** Release version of {@link #putCharVolatile(Object, long, char)} */
1633     @HotSpotIntrinsicCandidate
1634     public final void putCharRelease(Object o, long offset, char x) {
1635         putCharVolatile(o, offset, x);
1636     }
1637 
1638     /** Release version of {@link #putIntVolatile(Object, long, int)} */
1639     @HotSpotIntrinsicCandidate
1640     public final void putIntRelease(Object o, long offset, int x) {
1641         putIntVolatile(o, offset, x);
1642     }
1643 
1644     /** Release version of {@link #putFloatVolatile(Object, long, float)} */
1645     @HotSpotIntrinsicCandidate
1646     public final void putFloatRelease(Object o, long offset, float x) {
1647         putFloatVolatile(o, offset, x);
1648     }
1649 
1650     /** Release version of {@link #putLongVolatile(Object, long, long)} */
1651     @HotSpotIntrinsicCandidate
1652     public final void putLongRelease(Object o, long offset, long x) {
1653         putLongVolatile(o, offset, x);
1654     }
1655 
1656     /** Release version of {@link #putDoubleVolatile(Object, long, double)} */
1657     @HotSpotIntrinsicCandidate
1658     public final void putDoubleRelease(Object o, long offset, double x) {
1659         putDoubleVolatile(o, offset, x);
1660     }
1661 
1662     // ------------------------------ Opaque --------------------------------------
1663 
1664     /** Opaque version of {@link #getObjectVolatile(Object, long)} */
1665     @HotSpotIntrinsicCandidate
1666     public final Object getObjectOpaque(Object o, long offset) {
1667         return getObjectVolatile(o, offset);
1668     }
1669 
1670     /** Opaque version of {@link #getBooleanVolatile(Object, long)} */
1671     @HotSpotIntrinsicCandidate
1672     public final boolean getBooleanOpaque(Object o, long offset) {
1673         return getBooleanVolatile(o, offset);
1674     }
1675 
1676     /** Opaque version of {@link #getByteVolatile(Object, long)} */
1677     @HotSpotIntrinsicCandidate
1678     public final byte getByteOpaque(Object o, long offset) {
1679         return getByteVolatile(o, offset);
1680     }
1681 
1682     /** Opaque version of {@link #getShortVolatile(Object, long)} */
1683     @HotSpotIntrinsicCandidate
1684     public final short getShortOpaque(Object o, long offset) {
1685         return getShortVolatile(o, offset);
1686     }
1687 
1688     /** Opaque version of {@link #getCharVolatile(Object, long)} */
1689     @HotSpotIntrinsicCandidate
1690     public final char getCharOpaque(Object o, long offset) {
1691         return getCharVolatile(o, offset);
1692     }
1693 
1694     /** Opaque version of {@link #getIntVolatile(Object, long)} */
1695     @HotSpotIntrinsicCandidate
1696     public final int getIntOpaque(Object o, long offset) {
1697         return getIntVolatile(o, offset);
1698     }
1699 
1700     /** Opaque version of {@link #getFloatVolatile(Object, long)} */
1701     @HotSpotIntrinsicCandidate
1702     public final float getFloatOpaque(Object o, long offset) {
1703         return getFloatVolatile(o, offset);
1704     }
1705 
1706     /** Opaque version of {@link #getLongVolatile(Object, long)} */
1707     @HotSpotIntrinsicCandidate
1708     public final long getLongOpaque(Object o, long offset) {
1709         return getLongVolatile(o, offset);
1710     }
1711 
1712     /** Opaque version of {@link #getDoubleVolatile(Object, long)} */
1713     @HotSpotIntrinsicCandidate
1714     public final double getDoubleOpaque(Object o, long offset) {
1715         return getDoubleVolatile(o, offset);
1716     }
1717 
1718     /** Opaque version of {@link #putObjectVolatile(Object, long, Object)} */
1719     @HotSpotIntrinsicCandidate
1720     public final void putObjectOpaque(Object o, long offset, Object x) {
1721         putObjectVolatile(o, offset, x);
1722     }
1723 
1724     /** Opaque version of {@link #putBooleanVolatile(Object, long, boolean)} */
1725     @HotSpotIntrinsicCandidate
1726     public final void putBooleanOpaque(Object o, long offset, boolean x) {
1727         putBooleanVolatile(o, offset, x);
1728     }
1729 
1730     /** Opaque version of {@link #putByteVolatile(Object, long, byte)} */
1731     @HotSpotIntrinsicCandidate
1732     public final void putByteOpaque(Object o, long offset, byte x) {
1733         putByteVolatile(o, offset, x);
1734     }
1735 
1736     /** Opaque version of {@link #putShortVolatile(Object, long, short)} */
1737     @HotSpotIntrinsicCandidate
1738     public final void putShortOpaque(Object o, long offset, short x) {
1739         putShortVolatile(o, offset, x);
1740     }
1741 
1742     /** Opaque version of {@link #putCharVolatile(Object, long, char)} */
1743     @HotSpotIntrinsicCandidate
1744     public final void putCharOpaque(Object o, long offset, char x) {
1745         putCharVolatile(o, offset, x);
1746     }
1747 
1748     /** Opaque version of {@link #putIntVolatile(Object, long, int)} */
1749     @HotSpotIntrinsicCandidate
1750     public final void putIntOpaque(Object o, long offset, int x) {
1751         putIntVolatile(o, offset, x);
1752     }
1753 
1754     /** Opaque version of {@link #putFloatVolatile(Object, long, float)} */
1755     @HotSpotIntrinsicCandidate
1756     public final void putFloatOpaque(Object o, long offset, float x) {
1757         putFloatVolatile(o, offset, x);
1758     }
1759 
1760     /** Opaque version of {@link #putLongVolatile(Object, long, long)} */
1761     @HotSpotIntrinsicCandidate
1762     public final void putLongOpaque(Object o, long offset, long x) {
1763         putLongVolatile(o, offset, x);
1764     }
1765 
1766     /** Opaque version of {@link #putDoubleVolatile(Object, long, double)} */
1767     @HotSpotIntrinsicCandidate
1768     public final void putDoubleOpaque(Object o, long offset, double x) {
1769         putDoubleVolatile(o, offset, x);
1770     }
1771 
1772     /**
1773      * Unblocks the given thread blocked on {@code park}, or, if it is
1774      * not blocked, causes the subsequent call to {@code park} not to
1775      * block.  Note: this operation is "unsafe" solely because the
1776      * caller must somehow ensure that the thread has not been
1777      * destroyed. Nothing special is usually required to ensure this
1778      * when called from Java (in which there will ordinarily be a live
1779      * reference to the thread) but this is not nearly-automatically
1780      * so when calling from native code.
1781      *
1782      * @param thread the thread to unpark.
1783      */
1784     @HotSpotIntrinsicCandidate
1785     public native void unpark(Object thread);
1786 
1787     /**
1788      * Blocks current thread, returning when a balancing
1789      * {@code unpark} occurs, or a balancing {@code unpark} has
1790      * already occurred, or the thread is interrupted, or, if not
1791      * absolute and time is not zero, the given time nanoseconds have
1792      * elapsed, or if absolute, the given deadline in milliseconds
1793      * since Epoch has passed, or spuriously (i.e., returning for no
1794      * "reason"). Note: This operation is in the Unsafe class only
1795      * because {@code unpark} is, so it would be strange to place it
1796      * elsewhere.
1797      */
1798     @HotSpotIntrinsicCandidate
1799     public native void park(boolean isAbsolute, long time);
1800 
1801     /**
1802      * Gets the load average in the system run queue assigned
1803      * to the available processors averaged over various periods of time.
1804      * This method retrieves the given {@code nelem} samples and
1805      * assigns to the elements of the given {@code loadavg} array.
1806      * The system imposes a maximum of 3 samples, representing
1807      * averages over the last 1,  5,  and  15 minutes, respectively.
1808      *
1809      * @param loadavg an array of double of size nelems
1810      * @param nelems the number of samples to be retrieved and
1811      *        must be 1 to 3.
1812      *
1813      * @return the number of samples actually retrieved; or -1
1814      *         if the load average is unobtainable.
1815      */
1816     public int getLoadAverage(double[] loadavg, int nelems) {
1817         if (nelems &lt; 0 || nelems &gt; 3 || nelems &gt; loadavg.length) {
1818             throw new ArrayIndexOutOfBoundsException();
1819         }
1820 
1821         return getLoadAverage0(loadavg, nelems);
1822     }
1823 
1824     // The following contain CAS-based Java implementations used on
1825     // platforms not supporting native instructions
1826 
1827     /**
1828      * Atomically adds the given value to the current value of a field
1829      * or array element within the given object {@code o}
1830      * at the given {@code offset}.
1831      *
1832      * @param o object/array to update the field/element in
1833      * @param offset field/element offset
1834      * @param delta the value to add
1835      * @return the previous value
1836      * @since 1.8
1837      */
1838     @HotSpotIntrinsicCandidate
1839     public final int getAndAddInt(Object o, long offset, int delta) {
1840         int v;
1841         do {
1842             v = getIntVolatile(o, offset);
1843         } while (!compareAndSwapInt(o, offset, v, v + delta));
1844         return v;
1845     }
1846 
1847     /**
1848      * Atomically adds the given value to the current value of a field
1849      * or array element within the given object {@code o}
1850      * at the given {@code offset}.
1851      *
1852      * @param o object/array to update the field/element in
1853      * @param offset field/element offset
1854      * @param delta the value to add
1855      * @return the previous value
1856      * @since 1.8
1857      */
1858     @HotSpotIntrinsicCandidate
1859     public final long getAndAddLong(Object o, long offset, long delta) {
1860         long v;
1861         do {
1862             v = getLongVolatile(o, offset);
1863         } while (!compareAndSwapLong(o, offset, v, v + delta));
1864         return v;
1865     }
1866 
1867     /**
1868      * Atomically exchanges the given value with the current value of
1869      * a field or array element within the given object {@code o}
1870      * at the given {@code offset}.
1871      *
1872      * @param o object/array to update the field/element in
1873      * @param offset field/element offset
1874      * @param newValue new value
1875      * @return the previous value
1876      * @since 1.8
1877      */
1878     @HotSpotIntrinsicCandidate
1879     public final int getAndSetInt(Object o, long offset, int newValue) {
1880         int v;
1881         do {
1882             v = getIntVolatile(o, offset);
1883         } while (!compareAndSwapInt(o, offset, v, newValue));
1884         return v;
1885     }
1886 
1887     /**
1888      * Atomically exchanges the given value with the current value of
1889      * a field or array element within the given object {@code o}
1890      * at the given {@code offset}.
1891      *
1892      * @param o object/array to update the field/element in
1893      * @param offset field/element offset
1894      * @param newValue new value
1895      * @return the previous value
1896      * @since 1.8
1897      */
1898     @HotSpotIntrinsicCandidate
1899     public final long getAndSetLong(Object o, long offset, long newValue) {
1900         long v;
1901         do {
1902             v = getLongVolatile(o, offset);
1903         } while (!compareAndSwapLong(o, offset, v, newValue));
1904         return v;
1905     }
1906 
1907     /**
1908      * Atomically exchanges the given reference value with the current
1909      * reference value of a field or array element within the given
1910      * object {@code o} at the given {@code offset}.
1911      *
1912      * @param o object/array to update the field/element in
1913      * @param offset field/element offset
1914      * @param newValue new value
1915      * @return the previous value
1916      * @since 1.8
1917      */
1918     @HotSpotIntrinsicCandidate
1919     public final Object getAndSetObject(Object o, long offset, Object newValue) {
1920         Object v;
1921         do {
1922             v = getObjectVolatile(o, offset);
1923         } while (!compareAndSwapObject(o, offset, v, newValue));
1924         return v;
1925     }
1926 
1927 
1928     /**
1929      * Ensures that loads before the fence will not be reordered with loads and
1930      * stores after the fence; a "LoadLoad plus LoadStore barrier".
1931      *
1932      * Corresponds to C11 atomic_thread_fence(memory_order_acquire)
1933      * (an "acquire fence").
1934      *
1935      * A pure LoadLoad fence is not provided, since the addition of LoadStore
1936      * is almost always desired, and most current hardware instructions that
1937      * provide a LoadLoad barrier also provide a LoadStore barrier for free.
1938      * @since 1.8
1939      */
1940     @HotSpotIntrinsicCandidate
1941     public native void loadFence();
1942 
1943     /**
1944      * Ensures that loads and stores before the fence will not be reordered with
1945      * stores after the fence; a "StoreStore plus LoadStore barrier".
1946      *
1947      * Corresponds to C11 atomic_thread_fence(memory_order_release)
1948      * (a "release fence").
1949      *
1950      * A pure StoreStore fence is not provided, since the addition of LoadStore
1951      * is almost always desired, and most current hardware instructions that
1952      * provide a StoreStore barrier also provide a LoadStore barrier for free.
1953      * @since 1.8
1954      */
1955     @HotSpotIntrinsicCandidate
1956     public native void storeFence();
1957 
1958     /**
1959      * Ensures that loads and stores before the fence will not be reordered
1960      * with loads and stores after the fence.  Implies the effects of both
1961      * loadFence() and storeFence(), and in addition, the effect of a StoreLoad
1962      * barrier.
1963      *
1964      * Corresponds to C11 atomic_thread_fence(memory_order_seq_cst).
1965      * @since 1.8
1966      */
1967     @HotSpotIntrinsicCandidate
1968     public native void fullFence();
1969 
1970     /**
1971      * Ensures that loads before the fence will not be reordered with
1972      * loads after the fence.
1973      */
1974     public final void loadLoadFence() {
1975         loadFence();
1976     }
1977 
1978     /**
1979      * Ensures that stores before the fence will not be reordered with
1980      * stores after the fence.
1981      */
1982     public final void storeStoreFence() {
1983         storeFence();
1984     }
1985 
1986 
1987     /**
1988      * Throws IllegalAccessError; for use by the VM for access control
1989      * error support.
1990      * @since 1.8
1991      */
1992     private static void throwIllegalAccessError() {
1993         throw new IllegalAccessError();
1994     }
1995 
1996     /**
1997      * @return Returns true if the native byte ordering of this
1998      * platform is big-endian, false if it is little-endian.
1999      */
2000     public final boolean isBigEndian() { return BE; }
2001 
2002     /**
2003      * @return Returns true if this platform is capable of performing
2004      * accesses at addresses which are not aligned for the type of the
2005      * primitive type being accessed, false otherwise.
2006      */
2007     public final boolean unalignedAccess() { return unalignedAccess; }
2008 
2009     /**
2010      * Fetches a value at some byte offset into a given Java object.
2011      * More specifically, fetches a value within the given object
2012      * &lt;code&gt;o&lt;/code&gt; at the given offset, or (if &lt;code&gt;o&lt;/code&gt; is
2013      * null) from the memory address whose numerical value is the
2014      * given offset.  &lt;p&gt;
2015      *
2016      * The specification of this method is the same as {@link
2017      * #getLong(Object, long)} except that the offset does not need to
2018      * have been obtained from {@link #objectFieldOffset} on the
2019      * {@link java.lang.reflect.Field} of some Java field.  The value
2020      * in memory is raw data, and need not correspond to any Java
2021      * variable.  Unless &lt;code&gt;o&lt;/code&gt; is null, the value accessed
2022      * must be entirely within the allocated object.  The endianness
2023      * of the value in memory is the endianness of the native platform.
2024      *
2025      * &lt;p&gt; The read will be atomic with respect to the largest power
2026      * of two that divides the GCD of the offset and the storage size.
2027      * For example, getLongUnaligned will make atomic reads of 2-, 4-,
2028      * or 8-byte storage units if the offset is zero mod 2, 4, or 8,
2029      * respectively.  There are no other guarantees of atomicity.
2030      * &lt;p&gt;
2031      * 8-byte atomicity is only guaranteed on platforms on which
2032      * support atomic accesses to longs.
2033      *
2034      * @param o Java heap object in which the value resides, if any, else
2035      *        null
2036      * @param offset The offset in bytes from the start of the object
2037      * @return the value fetched from the indicated object
2038      * @throws RuntimeException No defined exceptions are thrown, not even
2039      *         {@link NullPointerException}
2040      * @since 9
2041      */
2042     @HotSpotIntrinsicCandidate
2043     public final long getLongUnaligned(Object o, long offset) {
2044         if ((offset &amp; 7) == 0) {
2045             return getLong(o, offset);
2046         } else if ((offset &amp; 3) == 0) {
2047             return makeLong(getInt(o, offset),
2048                             getInt(o, offset + 4));
2049         } else if ((offset &amp; 1) == 0) {
2050             return makeLong(getShort(o, offset),
2051                             getShort(o, offset + 2),
2052                             getShort(o, offset + 4),
2053                             getShort(o, offset + 6));
2054         } else {
2055             return makeLong(getByte(o, offset),
2056                             getByte(o, offset + 1),
2057                             getByte(o, offset + 2),
2058                             getByte(o, offset + 3),
2059                             getByte(o, offset + 4),
2060                             getByte(o, offset + 5),
2061                             getByte(o, offset + 6),
2062                             getByte(o, offset + 7));
2063         }
2064     }
2065     /**
2066      * As {@link #getLongUnaligned(Object, long)} but with an
2067      * additional argument which specifies the endianness of the value
2068      * as stored in memory.
2069      *
2070      * @param o Java heap object in which the variable resides
2071      * @param offset The offset in bytes from the start of the object
2072      * @param bigEndian The endianness of the value
2073      * @return the value fetched from the indicated object
2074      * @since 9
2075      */
2076     public final long getLongUnaligned(Object o, long offset, boolean bigEndian) {
2077         return convEndian(bigEndian, getLongUnaligned(o, offset));
2078     }
2079 
2080     /** @see #getLongUnaligned(Object, long) */
2081     @HotSpotIntrinsicCandidate
2082     public final int getIntUnaligned(Object o, long offset) {
2083         if ((offset &amp; 3) == 0) {
2084             return getInt(o, offset);
2085         } else if ((offset &amp; 1) == 0) {
2086             return makeInt(getShort(o, offset),
2087                            getShort(o, offset + 2));
2088         } else {
2089             return makeInt(getByte(o, offset),
2090                            getByte(o, offset + 1),
2091                            getByte(o, offset + 2),
2092                            getByte(o, offset + 3));
2093         }
2094     }
2095     /** @see #getLongUnaligned(Object, long, boolean) */
2096     public final int getIntUnaligned(Object o, long offset, boolean bigEndian) {
2097         return convEndian(bigEndian, getIntUnaligned(o, offset));
2098     }
2099 
2100     /** @see #getLongUnaligned(Object, long) */
2101     @HotSpotIntrinsicCandidate
2102     public final short getShortUnaligned(Object o, long offset) {
2103         if ((offset &amp; 1) == 0) {
2104             return getShort(o, offset);
2105         } else {
2106             return makeShort(getByte(o, offset),
2107                              getByte(o, offset + 1));
2108         }
2109     }
2110     /** @see #getLongUnaligned(Object, long, boolean) */
2111     public final short getShortUnaligned(Object o, long offset, boolean bigEndian) {
2112         return convEndian(bigEndian, getShortUnaligned(o, offset));
2113     }
2114 
2115     /** @see #getLongUnaligned(Object, long) */
2116     @HotSpotIntrinsicCandidate
2117     public final char getCharUnaligned(Object o, long offset) {
2118         if ((offset &amp; 1) == 0) {
2119             return getChar(o, offset);
2120         } else {
2121             return (char)makeShort(getByte(o, offset),
2122                                    getByte(o, offset + 1));
2123         }
2124     }
2125 
2126     /** @see #getLongUnaligned(Object, long, boolean) */
2127     public final char getCharUnaligned(Object o, long offset, boolean bigEndian) {
2128         return convEndian(bigEndian, getCharUnaligned(o, offset));
2129     }
2130 
2131     /**
2132      * Stores a value at some byte offset into a given Java object.
2133      * &lt;p&gt;
2134      * The specification of this method is the same as {@link
2135      * #getLong(Object, long)} except that the offset does not need to
2136      * have been obtained from {@link #objectFieldOffset} on the
2137      * {@link java.lang.reflect.Field} of some Java field.  The value
2138      * in memory is raw data, and need not correspond to any Java
2139      * variable.  The endianness of the value in memory is the
2140      * endianness of the native platform.
2141      * &lt;p&gt;
2142      * The write will be atomic with respect to the largest power of
2143      * two that divides the GCD of the offset and the storage size.
2144      * For example, putLongUnaligned will make atomic writes of 2-, 4-,
2145      * or 8-byte storage units if the offset is zero mod 2, 4, or 8,
2146      * respectively.  There are no other guarantees of atomicity.
2147      * &lt;p&gt;
2148      * 8-byte atomicity is only guaranteed on platforms on which
2149      * support atomic accesses to longs.
2150      *
2151      * @param o Java heap object in which the value resides, if any, else
2152      *        null
2153      * @param offset The offset in bytes from the start of the object
2154      * @param x the value to store
2155      * @throws RuntimeException No defined exceptions are thrown, not even
2156      *         {@link NullPointerException}
2157      * @since 9
2158      */
2159     @HotSpotIntrinsicCandidate
2160     public final void putLongUnaligned(Object o, long offset, long x) {
2161         if ((offset &amp; 7) == 0) {
2162             putLong(o, offset, x);
2163         } else if ((offset &amp; 3) == 0) {
2164             putLongParts(o, offset,
2165                          (int)(x &gt;&gt; 0),
2166                          (int)(x &gt;&gt;&gt; 32));
2167         } else if ((offset &amp; 1) == 0) {
2168             putLongParts(o, offset,
2169                          (short)(x &gt;&gt;&gt; 0),
2170                          (short)(x &gt;&gt;&gt; 16),
2171                          (short)(x &gt;&gt;&gt; 32),
2172                          (short)(x &gt;&gt;&gt; 48));
2173         } else {
2174             putLongParts(o, offset,
2175                          (byte)(x &gt;&gt;&gt; 0),
2176                          (byte)(x &gt;&gt;&gt; 8),
2177                          (byte)(x &gt;&gt;&gt; 16),
2178                          (byte)(x &gt;&gt;&gt; 24),
2179                          (byte)(x &gt;&gt;&gt; 32),
2180                          (byte)(x &gt;&gt;&gt; 40),
2181                          (byte)(x &gt;&gt;&gt; 48),
2182                          (byte)(x &gt;&gt;&gt; 56));
2183         }
2184     }
2185 
2186     /**
2187      * As {@link #putLongUnaligned(Object, long, long)} but with an additional
2188      * argument which specifies the endianness of the value as stored in memory.
2189      * @param o Java heap object in which the value resides
2190      * @param offset The offset in bytes from the start of the object
2191      * @param x the value to store
2192      * @param bigEndian The endianness of the value
2193      * @throws RuntimeException No defined exceptions are thrown, not even
2194      *         {@link NullPointerException}
2195      * @since 9
2196      */
2197     public final void putLongUnaligned(Object o, long offset, long x, boolean bigEndian) {
2198         putLongUnaligned(o, offset, convEndian(bigEndian, x));
2199     }
2200 
2201     /** @see #putLongUnaligned(Object, long, long) */
2202     @HotSpotIntrinsicCandidate
2203     public final void putIntUnaligned(Object o, long offset, int x) {
2204         if ((offset &amp; 3) == 0) {
2205             putInt(o, offset, x);
2206         } else if ((offset &amp; 1) == 0) {
2207             putIntParts(o, offset,
2208                         (short)(x &gt;&gt; 0),
2209                         (short)(x &gt;&gt;&gt; 16));
2210         } else {
2211             putIntParts(o, offset,
2212                         (byte)(x &gt;&gt;&gt; 0),
2213                         (byte)(x &gt;&gt;&gt; 8),
2214                         (byte)(x &gt;&gt;&gt; 16),
2215                         (byte)(x &gt;&gt;&gt; 24));
2216         }
2217     }
2218     /** @see #putLongUnaligned(Object, long, long, boolean) */
2219     public final void putIntUnaligned(Object o, long offset, int x, boolean bigEndian) {
2220         putIntUnaligned(o, offset, convEndian(bigEndian, x));
2221     }
2222 
2223     /** @see #putLongUnaligned(Object, long, long) */
2224     @HotSpotIntrinsicCandidate
2225     public final void putShortUnaligned(Object o, long offset, short x) {
2226         if ((offset &amp; 1) == 0) {
2227             putShort(o, offset, x);
2228         } else {
2229             putShortParts(o, offset,
2230                           (byte)(x &gt;&gt;&gt; 0),
2231                           (byte)(x &gt;&gt;&gt; 8));
2232         }
2233     }
2234     /** @see #putLongUnaligned(Object, long, long, boolean) */
2235     public final void putShortUnaligned(Object o, long offset, short x, boolean bigEndian) {
2236         putShortUnaligned(o, offset, convEndian(bigEndian, x));
2237     }
2238 
2239     /** @see #putLongUnaligned(Object, long, long) */
2240     @HotSpotIntrinsicCandidate
2241     public final void putCharUnaligned(Object o, long offset, char x) {
2242         putShortUnaligned(o, offset, (short)x);
2243     }
2244     /** @see #putLongUnaligned(Object, long, long, boolean) */
2245     public final void putCharUnaligned(Object o, long offset, char x, boolean bigEndian) {
2246         putCharUnaligned(o, offset, convEndian(bigEndian, x));
2247     }
2248 
2249     // JVM interface methods
2250     // BE is true iff the native endianness of this platform is big.
2251     private static final boolean BE = theUnsafe.isBigEndian0();
2252 
2253     // unalignedAccess is true iff this platform can perform unaligned accesses.
2254     private static final boolean unalignedAccess = theUnsafe.unalignedAccess0();
2255 
2256     private static int pickPos(int top, int pos) { return BE ? top - pos : pos; }
2257 
2258     // These methods construct integers from bytes.  The byte ordering
2259     // is the native endianness of this platform.
2260     private static long makeLong(byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
2261         return ((toUnsignedLong(i0) &lt;&lt; pickPos(56, 0))
2262               | (toUnsignedLong(i1) &lt;&lt; pickPos(56, 8))
2263               | (toUnsignedLong(i2) &lt;&lt; pickPos(56, 16))
2264               | (toUnsignedLong(i3) &lt;&lt; pickPos(56, 24))
2265               | (toUnsignedLong(i4) &lt;&lt; pickPos(56, 32))
2266               | (toUnsignedLong(i5) &lt;&lt; pickPos(56, 40))
2267               | (toUnsignedLong(i6) &lt;&lt; pickPos(56, 48))
2268               | (toUnsignedLong(i7) &lt;&lt; pickPos(56, 56)));
2269     }
2270     private static long makeLong(short i0, short i1, short i2, short i3) {
2271         return ((toUnsignedLong(i0) &lt;&lt; pickPos(48, 0))
2272               | (toUnsignedLong(i1) &lt;&lt; pickPos(48, 16))
2273               | (toUnsignedLong(i2) &lt;&lt; pickPos(48, 32))
2274               | (toUnsignedLong(i3) &lt;&lt; pickPos(48, 48)));
2275     }
2276     private static long makeLong(int i0, int i1) {
2277         return (toUnsignedLong(i0) &lt;&lt; pickPos(32, 0))
2278              | (toUnsignedLong(i1) &lt;&lt; pickPos(32, 32));
2279     }
2280     private static int makeInt(short i0, short i1) {
2281         return (toUnsignedInt(i0) &lt;&lt; pickPos(16, 0))
2282              | (toUnsignedInt(i1) &lt;&lt; pickPos(16, 16));
2283     }
2284     private static int makeInt(byte i0, byte i1, byte i2, byte i3) {
2285         return ((toUnsignedInt(i0) &lt;&lt; pickPos(24, 0))
2286               | (toUnsignedInt(i1) &lt;&lt; pickPos(24, 8))
2287               | (toUnsignedInt(i2) &lt;&lt; pickPos(24, 16))
2288               | (toUnsignedInt(i3) &lt;&lt; pickPos(24, 24)));
2289     }
2290     private static short makeShort(byte i0, byte i1) {
2291         return (short)((toUnsignedInt(i0) &lt;&lt; pickPos(8, 0))
2292                      | (toUnsignedInt(i1) &lt;&lt; pickPos(8, 8)));
2293     }
2294 
2295     private static byte  pick(byte  le, byte  be) { return BE ? be : le; }
2296     private static short pick(short le, short be) { return BE ? be : le; }
2297     private static int   pick(int   le, int   be) { return BE ? be : le; }
2298 
2299     // These methods write integers to memory from smaller parts
2300     // provided by their caller.  The ordering in which these parts
2301     // are written is the native endianness of this platform.
2302     private void putLongParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
2303         putByte(o, offset + 0, pick(i0, i7));
2304         putByte(o, offset + 1, pick(i1, i6));
2305         putByte(o, offset + 2, pick(i2, i5));
2306         putByte(o, offset + 3, pick(i3, i4));
2307         putByte(o, offset + 4, pick(i4, i3));
2308         putByte(o, offset + 5, pick(i5, i2));
2309         putByte(o, offset + 6, pick(i6, i1));
2310         putByte(o, offset + 7, pick(i7, i0));
2311     }
2312     private void putLongParts(Object o, long offset, short i0, short i1, short i2, short i3) {
2313         putShort(o, offset + 0, pick(i0, i3));
2314         putShort(o, offset + 2, pick(i1, i2));
2315         putShort(o, offset + 4, pick(i2, i1));
2316         putShort(o, offset + 6, pick(i3, i0));
2317     }
2318     private void putLongParts(Object o, long offset, int i0, int i1) {
2319         putInt(o, offset + 0, pick(i0, i1));
2320         putInt(o, offset + 4, pick(i1, i0));
2321     }
2322     private void putIntParts(Object o, long offset, short i0, short i1) {
2323         putShort(o, offset + 0, pick(i0, i1));
2324         putShort(o, offset + 2, pick(i1, i0));
2325     }
2326     private void putIntParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3) {
2327         putByte(o, offset + 0, pick(i0, i3));
2328         putByte(o, offset + 1, pick(i1, i2));
2329         putByte(o, offset + 2, pick(i2, i1));
2330         putByte(o, offset + 3, pick(i3, i0));
2331     }
2332     private void putShortParts(Object o, long offset, byte i0, byte i1) {
2333         putByte(o, offset + 0, pick(i0, i1));
2334         putByte(o, offset + 1, pick(i1, i0));
2335     }
2336 
2337     // Zero-extend an integer
2338     private static int toUnsignedInt(byte n)    { return n &amp; 0xff; }
2339     private static int toUnsignedInt(short n)   { return n &amp; 0xffff; }
2340     private static long toUnsignedLong(byte n)  { return n &amp; 0xffl; }
2341     private static long toUnsignedLong(short n) { return n &amp; 0xffffl; }
2342     private static long toUnsignedLong(int n)   { return n &amp; 0xffffffffl; }
2343 
2344     // Maybe byte-reverse an integer
2345     private static char convEndian(boolean big, char n)   { return big == BE ? n : Character.reverseBytes(n); }
2346     private static short convEndian(boolean big, short n) { return big == BE ? n : Short.reverseBytes(n)    ; }
2347     private static int convEndian(boolean big, int n)     { return big == BE ? n : Integer.reverseBytes(n)  ; }
2348     private static long convEndian(boolean big, long n)   { return big == BE ? n : Long.reverseBytes(n)     ; }
2349 
2350 
2351 
2352     private native long allocateMemory0(long bytes);
2353     private native long reallocateMemory0(long address, long bytes);
2354     private native void freeMemory0(long address);
2355     private native void setMemory0(Object o, long offset, long bytes, byte value);
2356     @HotSpotIntrinsicCandidate
2357     private native void copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
2358     private native void copySwapMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes, long elemSize);
2359     private native long objectFieldOffset0(Field f);
2360     private native long staticFieldOffset0(Field f);
2361     private native Object staticFieldBase0(Field f);
2362     private native boolean shouldBeInitialized0(Class&lt;?&gt; c);
2363     private native void ensureClassInitialized0(Class&lt;?&gt; c);
2364     private native int arrayBaseOffset0(Class&lt;?&gt; arrayClass);
2365     private native int arrayIndexScale0(Class&lt;?&gt; arrayClass);
2366     private native int addressSize0();
2367     private native Class&lt;?&gt; defineAnonymousClass0(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
2368     private native int getLoadAverage0(double[] loadavg, int nelems);
2369     private native boolean unalignedAccess0();
2370     private native boolean isBigEndian0();
2371 }
</pre></body></html>
