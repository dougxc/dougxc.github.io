<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/share/vm/prims/unsafe.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "classfile/classFileStream.hpp"
  27 #include "classfile/vmSymbols.hpp"
  28 #include "memory/allocation.inline.hpp"
  29 #include "memory/resourceArea.hpp"
  30 #include "oops/objArrayOop.inline.hpp"
  31 #include "oops/oop.inline.hpp"
  32 #include "prims/jni.h"
  33 #include "prims/jvm.h"
  34 #include "prims/unsafe.hpp"
  35 #include "runtime/atomic.inline.hpp"
  36 #include "runtime/globals.hpp"
  37 #include "runtime/interfaceSupport.hpp"
  38 #include "runtime/orderAccess.inline.hpp"
  39 #include "runtime/reflection.hpp"
  40 #include "runtime/vm_version.hpp"
  41 #include "services/threadService.hpp"
  42 #include "trace/tracing.hpp"
  43 #include "utilities/copy.hpp"
  44 #include "utilities/dtrace.hpp"
  45 #include "utilities/macros.hpp"
  46 #if INCLUDE_ALL_GCS
  47 #include "gc/g1/g1SATBCardTableModRefBS.hpp"
  48 #endif // INCLUDE_ALL_GCS
  49 
  50 /**
  51  * Implementation of the jdk.internal.misc.Unsafe class
  52  */
  53 
  54 
  55 #define MAX_OBJECT_SIZE \
  56   ( arrayOopDesc::header_size(T_DOUBLE) * HeapWordSize \
  57     + ((julong)max_jint * sizeof(double)) )
  58 
  59 
  60 #define UNSAFE_ENTRY(result_type, header) \
  61   JVM_ENTRY(static result_type, header)
  62 
  63 #define UNSAFE_LEAF(result_type, header) \
  64   JVM_LEAF(static result_type, header)
  65 
  66 #define UNSAFE_END JVM_END
  67 
  68 
  69 static inline void* addr_from_java(jlong addr) {
  70   // This assert fails in a variety of ways on 32-bit systems.
  71   // It is impossible to predict whether native code that converts
  72   // pointers to longs will sign-extend or zero-extend the addresses.
  73   //assert(addr == (uintptr_t)addr, "must not be odd high bits");
  74   return (void*)(uintptr_t)addr;
  75 }
  76 
  77 static inline jlong addr_to_java(void* p) {
  78   assert(p == (void*)(uintptr_t)p, "must not be odd high bits");
  79   return (uintptr_t)p;
  80 }
  81 
  82 
  83 // Note: The VM's obj_field and related accessors use byte-scaled
  84 // ("unscaled") offsets, just as the unsafe methods do.
  85 
  86 // However, the method Unsafe.fieldOffset explicitly declines to
  87 // guarantee this.  The field offset values manipulated by the Java user
  88 // through the Unsafe API are opaque cookies that just happen to be byte
  89 // offsets.  We represent this state of affairs by passing the cookies
  90 // through conversion functions when going between the VM and the Unsafe API.
  91 // The conversion functions just happen to be no-ops at present.
  92 
  93 static inline jlong field_offset_to_byte_offset(jlong field_offset) {
  94   return field_offset;
  95 }
  96 
  97 static inline jlong field_offset_from_byte_offset(jlong byte_offset) {
  98   return byte_offset;
  99 }
 100 
 101 static inline void* index_oop_from_field_offset_long(oop p, jlong field_offset) {
 102   jlong byte_offset = field_offset_to_byte_offset(field_offset);
 103 
 104 #ifdef ASSERT
 105   if (p != NULL) {
 106     assert(byte_offset &gt;= 0 &amp;&amp; byte_offset &lt;= (jlong)MAX_OBJECT_SIZE, "sane offset");
 107     if (byte_offset == (jint)byte_offset) {
 108       void* ptr_plus_disp = (address)p + byte_offset;
 109       assert((void*)p-&gt;obj_field_addr&lt;oop&gt;((jint)byte_offset) == ptr_plus_disp,
 110              "raw [ptr+disp] must be consistent with oop::field_base");
 111     }
 112     jlong p_size = HeapWordSize * (jlong)(p-&gt;size());
 113     assert(byte_offset &lt; p_size, "Unsafe access: offset " INT64_FORMAT " &gt; object's size " INT64_FORMAT, byte_offset, p_size);
 114   }
 115 #endif
 116 
 117   if (sizeof(char*) == sizeof(jint)) {   // (this constant folds!)
 118     return (address)p + (jint) byte_offset;
 119   } else {
 120     return (address)p +        byte_offset;
 121   }
 122 }
 123 
 124 // Externally callable versions:
 125 // (Use these in compiler intrinsics which emulate unsafe primitives.)
 126 jlong Unsafe_field_offset_to_byte_offset(jlong field_offset) {
 127   return field_offset;
 128 }
 129 jlong Unsafe_field_offset_from_byte_offset(jlong byte_offset) {
 130   return byte_offset;
 131 }
 132 
 133 
 134 ///// Data read/writes on the Java heap and in native (off-heap) memory
 135 
 136 /**
 137  * Helper class for accessing memory.
 138  *
 139  * Normalizes values and wraps accesses in
 140  * JavaThread::doing_unsafe_access() if needed.
 141  */
 142 class MemoryAccess : StackObj {
 143   JavaThread* _thread;
 144   jobject _obj;
 145   jlong _offset;
 146 
 147   // Resolves and returns the address of the memory access
 148   void* addr() {
 149     return index_oop_from_field_offset_long(JNIHandles::resolve(_obj), _offset);
 150   }
 151 
 152   template &lt;typename T&gt;
 153   T normalize(T x) {
 154     return x;
 155   }
 156 
 157   jboolean normalize(jboolean x) {
 158     return x &amp; 1;
 159   }
 160 
 161   /**
 162    * Helper class to wrap memory accesses in JavaThread::doing_unsafe_access()
 163    */
 164   class GuardUnsafeAccess {
 165     JavaThread* _thread;
 166     bool _active;
 167 
 168   public:
 169     GuardUnsafeAccess(JavaThread* thread, jobject _obj) : _thread(thread) {
 170       if (JNIHandles::resolve(_obj) == NULL) {
 171         // native/off-heap access which may raise SIGBUS if accessing
 172         // memory mapped file data in a region of the file which has
 173         // been truncated and is now invalid
 174         _thread-&gt;set_doing_unsafe_access(true);
 175         _active = true;
 176       } else {
 177         _active = false;
 178       }
 179     }
 180 
 181     ~GuardUnsafeAccess() {
 182       if (_active) {
 183         _thread-&gt;set_doing_unsafe_access(false);
 184       }
 185     }
 186   };
 187 
 188 public:
 189   MemoryAccess(JavaThread* thread, jobject obj, jlong offset)
 190     : _thread(thread), _obj(obj), _offset(offset) {
 191   }
 192 
 193   template &lt;typename T&gt;
 194   T get() {
 195     GuardUnsafeAccess guard(_thread, _obj);
 196 
 197     T* p = (T*)addr();
 198 
 199     T x = *p;
 200 
 201     return x;
 202   }
 203 
 204   template &lt;typename T&gt;
 205   void put(T x) {
 206     GuardUnsafeAccess guard(_thread, _obj);
 207 
 208     T* p = (T*)addr();
 209 
 210     *p = normalize(x);
 211   }
 212 
 213 
 214   template &lt;typename T&gt;
 215   T get_volatile() {
 216     GuardUnsafeAccess guard(_thread, _obj);
 217 
 218     T* p = (T*)addr();
 219 
 220     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 221       OrderAccess::fence();
 222     }
 223 
 224     T x = OrderAccess::load_acquire((volatile T*)p);
 225 
 226     return x;
 227   }
 228 
 229   template &lt;typename T&gt;
 230   void put_volatile(T x) {
 231     GuardUnsafeAccess guard(_thread, _obj);
 232 
 233     T* p = (T*)addr();
 234 
 235     OrderAccess::release_store_fence((volatile T*)p, normalize(x));
 236   }
 237 
 238 
 239 #ifndef SUPPORTS_NATIVE_CX8
 240   jlong get_jlong_locked() {
 241     GuardUnsafeAccess guard(_thread, _obj);
 242 
 243     MutexLockerEx mu(UnsafeJlong_lock, Mutex::_no_safepoint_check_flag);
 244 
 245     jlong* p = (jlong*)addr();
 246 
 247     jlong x = Atomic::load(p);
 248 
 249     return x;
 250   }
 251 
 252   void put_jlong_locked(jlong x) {
 253     GuardUnsafeAccess guard(_thread, _obj);
 254 
 255     MutexLockerEx mu(UnsafeJlong_lock, Mutex::_no_safepoint_check_flag);
 256 
 257     jlong* p = (jlong*)addr();
 258 
 259     Atomic::store(normalize(x),  p);
 260   }
 261 #endif
 262 };
 263 
 264 // Get/PutObject must be special-cased, since it works with handles.
 265 
 266 // These functions allow a null base pointer with an arbitrary address.
 267 // But if the base pointer is non-null, the offset should make some sense.
 268 // That is, it should be in the range [0, MAX_OBJECT_SIZE].
 269 UNSAFE_ENTRY(jobject, Unsafe_GetObject(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 270   oop p = JNIHandles::resolve(obj);
 271   oop v;
 272 
 273   if (UseCompressedOops) {
 274     narrowOop n = *(narrowOop*)index_oop_from_field_offset_long(p, offset);
 275     v = oopDesc::decode_heap_oop(n);
 276   } else {
 277     v = *(oop*)index_oop_from_field_offset_long(p, offset);
 278   }
 279 
 280   jobject ret = JNIHandles::make_local(env, v);
 281 
 282 #if INCLUDE_ALL_GCS
 283   // We could be accessing the referent field in a reference
 284   // object. If G1 is enabled then we need to register non-null
 285   // referent with the SATB barrier.
 286   if (UseG1GC) {
 287     bool needs_barrier = false;
 288 
 289     if (ret != NULL) {
 290       if (offset == java_lang_ref_Reference::referent_offset &amp;&amp; obj != NULL) {
 291         oop o = JNIHandles::resolve(obj);
 292         Klass* k = o-&gt;klass();
 293         if (InstanceKlass::cast(k)-&gt;reference_type() != REF_NONE) {
 294           assert(InstanceKlass::cast(k)-&gt;is_subclass_of(SystemDictionary::Reference_klass()), "sanity");
 295           needs_barrier = true;
 296         }
 297       }
 298     }
 299 
 300     if (needs_barrier) {
 301       oop referent = JNIHandles::resolve(ret);
 302       G1SATBCardTableModRefBS::enqueue(referent);
 303     }
 304   }
 305 #endif // INCLUDE_ALL_GCS
 306 
 307   return ret;
 308 } UNSAFE_END
 309 
 310 UNSAFE_ENTRY(void, Unsafe_PutObject(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 311   oop x = JNIHandles::resolve(x_h);
 312   oop p = JNIHandles::resolve(obj);
 313 
 314   if (UseCompressedOops) {
 315     oop_store((narrowOop*)index_oop_from_field_offset_long(p, offset), x);
 316   } else {
 317     oop_store((oop*)index_oop_from_field_offset_long(p, offset), x);
 318   }
 319 } UNSAFE_END
 320 
 321 UNSAFE_ENTRY(jobject, Unsafe_GetObjectVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 322   oop p = JNIHandles::resolve(obj);
 323   void* addr = index_oop_from_field_offset_long(p, offset);
 324 
 325   volatile oop v;
 326 
 327   if (UseCompressedOops) {
 328     volatile narrowOop n = *(volatile narrowOop*) addr;
 329     (void)const_cast&lt;oop&amp;&gt;(v = oopDesc::decode_heap_oop(n));
 330   } else {
 331     (void)const_cast&lt;oop&amp;&gt;(v = *(volatile oop*) addr);
 332   }
 333 
 334   OrderAccess::acquire();
 335   return JNIHandles::make_local(env, v);
 336 } UNSAFE_END
 337 
 338 UNSAFE_ENTRY(void, Unsafe_PutObjectVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 339   oop x = JNIHandles::resolve(x_h);
 340   oop p = JNIHandles::resolve(obj);
 341   void* addr = index_oop_from_field_offset_long(p, offset);
 342   OrderAccess::release();
 343 
 344   if (UseCompressedOops) {
 345     oop_store((narrowOop*)addr, x);
 346   } else {
 347     oop_store((oop*)addr, x);
 348   }
 349 
 350   OrderAccess::fence();
 351 } UNSAFE_END
 352 
 353 UNSAFE_ENTRY(jobject, Unsafe_GetUncompressedObject(JNIEnv *env, jobject unsafe, jlong addr)) {
 354   oop v = *(oop*) (address) addr;
 355 
 356   return JNIHandles::make_local(env, v);
 357 } UNSAFE_END
 358 
 359 UNSAFE_ENTRY(jclass, Unsafe_GetJavaMirror(JNIEnv *env, jobject unsafe, jlong metaspace_klass)) {
 360   Klass* klass = (Klass*) (address) metaspace_klass;
 361 
 362   return (jclass) JNIHandles::make_local(klass-&gt;java_mirror());
 363 } UNSAFE_END
 364 
 365 UNSAFE_ENTRY(jlong, Unsafe_GetKlassPointer(JNIEnv *env, jobject unsafe, jobject obj)) {
 366   oop o = JNIHandles::resolve(obj);
 367   jlong klass = (jlong) (address) o-&gt;klass();
 368 
 369   return klass;
 370 } UNSAFE_END
 371 
 372 #ifndef SUPPORTS_NATIVE_CX8
 373 
 374 // VM_Version::supports_cx8() is a surrogate for 'supports atomic long memory ops'.
 375 //
 376 // On platforms which do not support atomic compare-and-swap of jlong (8 byte)
 377 // values we have to use a lock-based scheme to enforce atomicity. This has to be
 378 // applied to all Unsafe operations that set the value of a jlong field. Even so
 379 // the compareAndSwapLong operation will not be atomic with respect to direct stores
 380 // to the field from Java code. It is important therefore that any Java code that
 381 // utilizes these Unsafe jlong operations does not perform direct stores. To permit
 382 // direct loads of the field from Java code we must also use Atomic::store within the
 383 // locked regions. And for good measure, in case there are direct stores, we also
 384 // employ Atomic::load within those regions. Note that the field in question must be
 385 // volatile and so must have atomic load/store accesses applied at the Java level.
 386 //
 387 // The locking scheme could utilize a range of strategies for controlling the locking
 388 // granularity: from a lock per-field through to a single global lock. The latter is
 389 // the simplest and is used for the current implementation. Note that the Java object
 390 // that contains the field, can not, in general, be used for locking. To do so can lead
 391 // to deadlocks as we may introduce locking into what appears to the Java code to be a
 392 // lock-free path.
 393 //
 394 // As all the locked-regions are very short and themselves non-blocking we can treat
 395 // them as leaf routines and elide safepoint checks (ie we don't perform any thread
 396 // state transitions even when blocking for the lock). Note that if we do choose to
 397 // add safepoint checks and thread state transitions, we must ensure that we calculate
 398 // the address of the field _after_ we have acquired the lock, else the object may have
 399 // been moved by the GC
 400 
 401 UNSAFE_ENTRY(jlong, Unsafe_GetLongVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 402   if (VM_Version::supports_cx8()) {
 403     return MemoryAccess(thread, obj, offset).get_volatile&lt;jlong&gt;();
 404   } else {
 405     return MemoryAccess(thread, obj, offset).get_jlong_locked();
 406   }
 407 } UNSAFE_END
 408 
 409 UNSAFE_ENTRY(void, Unsafe_PutLongVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong x)) {
 410   if (VM_Version::supports_cx8()) {
 411     MemoryAccess(thread, obj, offset).put_volatile&lt;jlong&gt;(x);
 412   } else {
 413     MemoryAccess(thread, obj, offset).put_jlong_locked(x);
 414   }
 415 } UNSAFE_END
 416 
 417 #endif // not SUPPORTS_NATIVE_CX8
 418 
 419 UNSAFE_LEAF(jboolean, Unsafe_isBigEndian0(JNIEnv *env, jobject unsafe)) {
 420 #ifdef VM_LITTLE_ENDIAN
 421   return false;
 422 #else
 423   return true;
 424 #endif
 425 } UNSAFE_END
 426 
 427 UNSAFE_LEAF(jint, Unsafe_unalignedAccess0(JNIEnv *env, jobject unsafe)) {
 428   return UseUnalignedAccesses;
 429 } UNSAFE_END
 430 
 431 #define DEFINE_GETSETOOP(java_type, Type) \
 432  \
 433 UNSAFE_ENTRY(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \
 434   return MemoryAccess(thread, obj, offset).get&lt;java_type&gt;(); \
 435 } UNSAFE_END \
 436  \
 437 UNSAFE_ENTRY(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \
 438   MemoryAccess(thread, obj, offset).put&lt;java_type&gt;(x); \
 439 } UNSAFE_END \
 440  \
 441 // END DEFINE_GETSETOOP.
 442 
 443 DEFINE_GETSETOOP(jboolean, Boolean)
 444 DEFINE_GETSETOOP(jbyte, Byte)
 445 DEFINE_GETSETOOP(jshort, Short);
 446 DEFINE_GETSETOOP(jchar, Char);
 447 DEFINE_GETSETOOP(jint, Int);
 448 DEFINE_GETSETOOP(jlong, Long);
 449 DEFINE_GETSETOOP(jfloat, Float);
 450 DEFINE_GETSETOOP(jdouble, Double);
 451 
 452 #undef DEFINE_GETSETOOP
 453 
 454 #define DEFINE_GETSETOOP_VOLATILE(java_type, Type) \
 455  \
 456 UNSAFE_ENTRY(java_type, Unsafe_Get##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \
 457   return MemoryAccess(thread, obj, offset).get_volatile&lt;java_type&gt;(); \
 458 } UNSAFE_END \
 459  \
 460 UNSAFE_ENTRY(void, Unsafe_Put##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \
 461   MemoryAccess(thread, obj, offset).put_volatile&lt;java_type&gt;(x); \
 462 } UNSAFE_END \
 463  \
 464 // END DEFINE_GETSETOOP_VOLATILE.
 465 
 466 DEFINE_GETSETOOP_VOLATILE(jboolean, Boolean)
 467 DEFINE_GETSETOOP_VOLATILE(jbyte, Byte)
 468 DEFINE_GETSETOOP_VOLATILE(jshort, Short);
 469 DEFINE_GETSETOOP_VOLATILE(jchar, Char);
 470 DEFINE_GETSETOOP_VOLATILE(jint, Int);
 471 DEFINE_GETSETOOP_VOLATILE(jfloat, Float);
 472 DEFINE_GETSETOOP_VOLATILE(jdouble, Double);
 473 
 474 #ifdef SUPPORTS_NATIVE_CX8
 475 DEFINE_GETSETOOP_VOLATILE(jlong, Long);
 476 #endif
 477 
 478 #undef DEFINE_GETSETOOP_VOLATILE
 479 
 480 UNSAFE_LEAF(void, Unsafe_LoadFence(JNIEnv *env, jobject unsafe)) {
 481   OrderAccess::acquire();
 482 } UNSAFE_END
 483 
 484 UNSAFE_LEAF(void, Unsafe_StoreFence(JNIEnv *env, jobject unsafe)) {
 485   OrderAccess::release();
 486 } UNSAFE_END
 487 
 488 UNSAFE_LEAF(void, Unsafe_FullFence(JNIEnv *env, jobject unsafe)) {
 489   OrderAccess::fence();
 490 } UNSAFE_END
 491 
 492 ////// Allocation requests
 493 
 494 UNSAFE_ENTRY(jobject, Unsafe_AllocateInstance(JNIEnv *env, jobject unsafe, jclass cls)) {
 495   ThreadToNativeFromVM ttnfv(thread);
 496   return env-&gt;AllocObject(cls);
 497 } UNSAFE_END
 498 
 499 UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong size)) {
 500   size_t sz = (size_t)size;
 501 
 502   sz = round_to(sz, HeapWordSize);
 503   void* x = os::malloc(sz, mtInternal);
 504 
 505   return addr_to_java(x);
 506 } UNSAFE_END
 507 
 508 UNSAFE_ENTRY(jlong, Unsafe_ReallocateMemory0(JNIEnv *env, jobject unsafe, jlong addr, jlong size)) {
 509   void* p = addr_from_java(addr);
 510   size_t sz = (size_t)size;
 511   sz = round_to(sz, HeapWordSize);
 512 
 513   void* x = os::realloc(p, sz, mtInternal);
 514 
 515   return addr_to_java(x);
 516 } UNSAFE_END
 517 
 518 UNSAFE_ENTRY(void, Unsafe_FreeMemory0(JNIEnv *env, jobject unsafe, jlong addr)) {
 519   void* p = addr_from_java(addr);
 520 
 521   os::free(p);
 522 } UNSAFE_END
 523 
 524 UNSAFE_ENTRY(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {
 525   size_t sz = (size_t)size;
 526 
 527   oop base = JNIHandles::resolve(obj);
 528   void* p = index_oop_from_field_offset_long(base, offset);
 529 
 530   Copy::fill_to_memory_atomic(p, sz, value);
 531 } UNSAFE_END
 532 
 533 UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {
 534   size_t sz = (size_t)size;
 535 
 536   oop srcp = JNIHandles::resolve(srcObj);
 537   oop dstp = JNIHandles::resolve(dstObj);
 538 
 539   void* src = index_oop_from_field_offset_long(srcp, srcOffset);
 540   void* dst = index_oop_from_field_offset_long(dstp, dstOffset);
 541 
 542   Copy::conjoint_memory_atomic(src, dst, sz);
 543 } UNSAFE_END
 544 
 545 // This function is a leaf since if the source and destination are both in native memory
 546 // the copy may potentially be very large, and we don't want to disable GC if we can avoid it.
 547 // If either source or destination (or both) are on the heap, the function will enter VM using
 548 // JVM_ENTRY_FROM_LEAF
 549 UNSAFE_LEAF(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {
 550   size_t sz = (size_t)size;
 551   size_t esz = (size_t)elemSize;
 552 
 553   if (srcObj == NULL &amp;&amp; dstObj == NULL) {
 554     // Both src &amp; dst are in native memory
 555     address src = (address)srcOffset;
 556     address dst = (address)dstOffset;
 557 
 558     Copy::conjoint_swap(src, dst, sz, esz);
 559   } else {
 560     // At least one of src/dst are on heap, transition to VM to access raw pointers
 561 
 562     JVM_ENTRY_FROM_LEAF(env, void, Unsafe_CopySwapMemory0) {
 563       oop srcp = JNIHandles::resolve(srcObj);
 564       oop dstp = JNIHandles::resolve(dstObj);
 565 
 566       address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);
 567       address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);
 568 
 569       Copy::conjoint_swap(src, dst, sz, esz);
 570     } JVM_END
 571   }
 572 } UNSAFE_END
 573 
 574 ////// Random queries
 575 
 576 UNSAFE_LEAF(jint, Unsafe_AddressSize0(JNIEnv *env, jobject unsafe)) {
 577   return sizeof(void*);
 578 } UNSAFE_END
 579 
 580 UNSAFE_LEAF(jint, Unsafe_PageSize()) {
 581   return os::vm_page_size();
 582 } UNSAFE_END
 583 
 584 static jint find_field_offset(jobject field, int must_be_static, TRAPS) {
 585   assert(field != NULL, "field must not be NULL");
 586 
 587   oop reflected   = JNIHandles::resolve_non_null(field);
 588   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 589   Klass* k        = java_lang_Class::as_Klass(mirror);
 590   int slot        = java_lang_reflect_Field::slot(reflected);
 591   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 592 
 593   if (must_be_static &gt;= 0) {
 594     int really_is_static = ((modifiers &amp; JVM_ACC_STATIC) != 0);
 595     if (must_be_static != really_is_static) {
 596       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 597     }
 598   }
 599 
 600   int offset = InstanceKlass::cast(k)-&gt;field_offset(slot);
 601   return field_offset_from_byte_offset(offset);
 602 }
 603 
 604 UNSAFE_ENTRY(jlong, Unsafe_ObjectFieldOffset0(JNIEnv *env, jobject unsafe, jobject field)) {
 605   return find_field_offset(field, 0, THREAD);
 606 } UNSAFE_END
 607 
 608 UNSAFE_ENTRY(jlong, Unsafe_StaticFieldOffset0(JNIEnv *env, jobject unsafe, jobject field)) {
 609   return find_field_offset(field, 1, THREAD);
 610 } UNSAFE_END
 611 
 612 UNSAFE_ENTRY(jobject, Unsafe_StaticFieldBase0(JNIEnv *env, jobject unsafe, jobject field)) {
 613   assert(field != NULL, "field must not be NULL");
 614 
 615   // Note:  In this VM implementation, a field address is always a short
 616   // offset from the base of a a klass metaobject.  Thus, the full dynamic
 617   // range of the return type is never used.  However, some implementations
 618   // might put the static field inside an array shared by many classes,
 619   // or even at a fixed address, in which case the address could be quite
 620   // large.  In that last case, this function would return NULL, since
 621   // the address would operate alone, without any base pointer.
 622 
 623   oop reflected   = JNIHandles::resolve_non_null(field);
 624   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 625   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 626 
 627   if ((modifiers &amp; JVM_ACC_STATIC) == 0) {
 628     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 629   }
 630 
 631   return JNIHandles::make_local(env, mirror);
 632 } UNSAFE_END
 633 
 634 UNSAFE_ENTRY(void, Unsafe_EnsureClassInitialized0(JNIEnv *env, jobject unsafe, jobject clazz)) {
 635   assert(clazz != NULL, "clazz must not be NULL");
 636 
 637   oop mirror = JNIHandles::resolve_non_null(clazz);
 638 
 639   Klass* klass = java_lang_Class::as_Klass(mirror);
 640   if (klass != NULL &amp;&amp; klass-&gt;should_be_initialized()) {
 641     InstanceKlass* k = InstanceKlass::cast(klass);
 642     k-&gt;initialize(CHECK);
 643   }
 644 }
 645 UNSAFE_END
 646 
 647 UNSAFE_ENTRY(jboolean, Unsafe_ShouldBeInitialized0(JNIEnv *env, jobject unsafe, jobject clazz)) {
 648   assert(clazz != NULL, "clazz must not be NULL");
 649 
 650   oop mirror = JNIHandles::resolve_non_null(clazz);
 651   Klass* klass = java_lang_Class::as_Klass(mirror);
 652 
 653   if (klass != NULL &amp;&amp; klass-&gt;should_be_initialized()) {
 654     return true;
 655   }
 656 
 657   return false;
 658 }
 659 UNSAFE_END
 660 
 661 static void getBaseAndScale(int&amp; base, int&amp; scale, jclass clazz, TRAPS) {
 662   assert(clazz != NULL, "clazz must not be NULL");
 663 
 664   oop mirror = JNIHandles::resolve_non_null(clazz);
 665   Klass* k = java_lang_Class::as_Klass(mirror);
 666 
 667   if (k == NULL || !k-&gt;is_array_klass()) {
 668     THROW(vmSymbols::java_lang_InvalidClassException());
 669   } else if (k-&gt;is_objArray_klass()) {
 670     base  = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
 671     scale = heapOopSize;
 672   } else if (k-&gt;is_typeArray_klass()) {
 673     TypeArrayKlass* tak = TypeArrayKlass::cast(k);
 674     base  = tak-&gt;array_header_in_bytes();
 675     assert(base == arrayOopDesc::base_offset_in_bytes(tak-&gt;element_type()), "array_header_size semantics ok");
 676     scale = (1 &lt;&lt; tak-&gt;log2_element_size());
 677   } else {
 678     ShouldNotReachHere();
 679   }
 680 }
 681 
 682 UNSAFE_ENTRY(jint, Unsafe_ArrayBaseOffset0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 683   int base = 0, scale = 0;
 684   getBaseAndScale(base, scale, clazz, CHECK_0);
 685 
 686   return field_offset_from_byte_offset(base);
 687 } UNSAFE_END
 688 
 689 
 690 UNSAFE_ENTRY(jint, Unsafe_ArrayIndexScale0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 691   int base = 0, scale = 0;
 692   getBaseAndScale(base, scale, clazz, CHECK_0);
 693 
 694   // This VM packs both fields and array elements down to the byte.
 695   // But watch out:  If this changes, so that array references for
 696   // a given primitive type (say, T_BOOLEAN) use different memory units
 697   // than fields, this method MUST return zero for such arrays.
 698   // For example, the VM used to store sub-word sized fields in full
 699   // words in the object layout, so that accessors like getByte(Object,int)
 700   // did not really do what one might expect for arrays.  Therefore,
 701   // this function used to report a zero scale factor, so that the user
 702   // would know not to attempt to access sub-word array elements.
 703   // // Code for unpacked fields:
 704   // if (scale &lt; wordSize)  return 0;
 705 
 706   // The following allows for a pretty general fieldOffset cookie scheme,
 707   // but requires it to be linear in byte offset.
 708   return field_offset_from_byte_offset(scale) - field_offset_from_byte_offset(0);
 709 } UNSAFE_END
 710 
 711 
 712 static inline void throw_new(JNIEnv *env, const char *ename) {
 713   char buf[100];
 714 
 715   jio_snprintf(buf, 100, "%s%s", "java/lang/", ename);
 716 
 717   jclass cls = env-&gt;FindClass(buf);
 718   if (env-&gt;ExceptionCheck()) {
 719     env-&gt;ExceptionClear();
 720     tty-&gt;print_cr("Unsafe: cannot throw %s because FindClass has failed", buf);
 721     return;
 722   }
 723 
 724   env-&gt;ThrowNew(cls, NULL);
 725 }
 726 
 727 static jclass Unsafe_DefineClass_impl(JNIEnv *env, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd) {
 728   // Code lifted from JDK 1.3 ClassLoader.c
 729 
 730   jbyte *body;
 731   char *utfName = NULL;
 732   jclass result = 0;
 733   char buf[128];
 734 
 735   assert(data != NULL, "Class bytes must not be NULL");
 736   assert(length &gt;= 0, "length must not be negative: %d", length);
 737 
 738   if (UsePerfData) {
 739     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 740   }
 741 
 742   body = NEW_C_HEAP_ARRAY(jbyte, length, mtInternal);
 743   if (body == NULL) {
 744     throw_new(env, "OutOfMemoryError");
 745     return 0;
 746   }
 747 
 748   env-&gt;GetByteArrayRegion(data, offset, length, body);
 749   if (env-&gt;ExceptionOccurred()) {
 750     goto free_body;
 751   }
 752 
 753   if (name != NULL) {
 754     uint len = env-&gt;GetStringUTFLength(name);
 755     int unicode_len = env-&gt;GetStringLength(name);
 756 
 757     if (len &gt;= sizeof(buf)) {
 758       utfName = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);
 759       if (utfName == NULL) {
 760         throw_new(env, "OutOfMemoryError");
 761         goto free_body;
 762       }
 763     } else {
 764       utfName = buf;
 765     }
 766 
 767     env-&gt;GetStringUTFRegion(name, 0, unicode_len, utfName);
 768 
 769     for (uint i = 0; i &lt; len; i++) {
 770       if (utfName[i] == '.')   utfName[i] = '/';
 771     }
 772   }
 773 
 774   result = JVM_DefineClass(env, utfName, loader, body, length, pd);
 775 
 776   if (utfName &amp;&amp; utfName != buf) {
 777     FREE_C_HEAP_ARRAY(char, utfName);
 778   }
 779 
 780  free_body:
 781   FREE_C_HEAP_ARRAY(jbyte, body);
 782   return result;
 783 }
 784 
 785 
 786 UNSAFE_ENTRY(jclass, Unsafe_DefineClass0(JNIEnv *env, jobject unsafe, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd)) {
 787   ThreadToNativeFromVM ttnfv(thread);
 788 
 789   return Unsafe_DefineClass_impl(env, name, data, offset, length, loader, pd);
 790 } UNSAFE_END
 791 
 792 
 793 // define a class but do not make it known to the class loader or system dictionary
 794 // - host_class:  supplies context for linkage, access control, protection domain, and class loader
 795 // - data:  bytes of a class file, a raw memory address (length gives the number of bytes)
 796 // - cp_patches:  where non-null entries exist, they replace corresponding CP entries in data
 797 
 798 // When you load an anonymous class U, it works as if you changed its name just before loading,
 799 // to a name that you will never use again.  Since the name is lost, no other class can directly
 800 // link to any member of U.  Just after U is loaded, the only way to use it is reflectively,
 801 // through java.lang.Class methods like Class.newInstance.
 802 
 803 // Access checks for linkage sites within U continue to follow the same rules as for named classes.
 804 // The package of an anonymous class is given by the package qualifier on the name under which it was loaded.
 805 // An anonymous class also has special privileges to access any member of its host class.
 806 // This is the main reason why this loading operation is unsafe.  The purpose of this is to
 807 // allow language implementations to simulate "open classes"; a host class in effect gets
 808 // new code when an anonymous class is loaded alongside it.  A less convenient but more
 809 // standard way to do this is with reflection, which can also be set to ignore access
 810 // restrictions.
 811 
 812 // Access into an anonymous class is possible only through reflection.  Therefore, there
 813 // are no special access rules for calling into an anonymous class.  The relaxed access
 814 // rule for the host class is applied in the opposite direction:  A host class reflectively
 815 // access one of its anonymous classes.
 816 
 817 // If you load the same bytecodes twice, you get two different classes.  You can reload
 818 // the same bytecodes with or without varying CP patches.
 819 
 820 // By using the CP patching array, you can have a new anonymous class U2 refer to an older one U1.
 821 // The bytecodes for U2 should refer to U1 by a symbolic name (doesn't matter what the name is).
 822 // The CONSTANT_Class entry for that name can be patched to refer directly to U1.
 823 
 824 // This allows, for example, U2 to use U1 as a superclass or super-interface, or as
 825 // an outer class (so that U2 is an anonymous inner class of anonymous U1).
 826 // It is not possible for a named class, or an older anonymous class, to refer by
 827 // name (via its CP) to a newer anonymous class.
 828 
 829 // CP patching may also be used to modify (i.e., hack) the names of methods, classes,
 830 // or type descriptors used in the loaded anonymous class.
 831 
 832 // Finally, CP patching may be used to introduce "live" objects into the constant pool,
 833 // instead of "dead" strings.  A compiled statement like println((Object)"hello") can
 834 // be changed to println(greeting), where greeting is an arbitrary object created before
 835 // the anonymous class is loaded.  This is useful in dynamic languages, in which
 836 // various kinds of metaobjects must be introduced as constants into bytecode.
 837 // Note the cast (Object), which tells the verifier to expect an arbitrary object,
 838 // not just a literal string.  For such ldc instructions, the verifier uses the
 839 // type Object instead of String, if the loaded constant is not in fact a String.
 840 
 841 static instanceKlassHandle
 842 Unsafe_DefineAnonymousClass_impl(JNIEnv *env,
 843                                  jclass host_class, jbyteArray data, jobjectArray cp_patches_jh,
 844                                  u1** temp_alloc,
 845                                  TRAPS) {
 846   assert(host_class != NULL, "host_class must not be NULL");
 847   assert(data != NULL, "data must not be NULL");
 848 
 849   if (UsePerfData) {
 850     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 851   }
 852 
 853   jint length = typeArrayOop(JNIHandles::resolve_non_null(data))-&gt;length();
 854   assert(length &gt;= 0, "class_bytes_length must not be negative: %d", length);
 855 
 856   int class_bytes_length = (int) length;
 857 
 858   u1* class_bytes = NEW_C_HEAP_ARRAY(u1, length, mtInternal);
 859   if (class_bytes == NULL) {
 860     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
 861   }
 862 
 863   // caller responsible to free it:
 864   *temp_alloc = class_bytes;
 865 
 866   jbyte* array_base = typeArrayOop(JNIHandles::resolve_non_null(data))-&gt;byte_at_addr(0);
 867   Copy::conjoint_jbytes(array_base, class_bytes, length);
 868 
 869   objArrayHandle cp_patches_h;
 870   if (cp_patches_jh != NULL) {
 871     oop p = JNIHandles::resolve_non_null(cp_patches_jh);
 872     assert(p-&gt;is_objArray(), "cp_patches must be an object[]");
 873     cp_patches_h = objArrayHandle(THREAD, (objArrayOop)p);
 874   }
 875 
 876   const Klass* host_klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(host_class));
 877   // Primitive types have NULL Klass* fields in their java.lang.Class instances.
 878   if (host_klass == NULL) {
 879     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 880   }
 881 
 882   const char* host_source = host_klass-&gt;external_name();
 883   Handle      host_loader(THREAD, host_klass-&gt;class_loader());
 884   Handle      host_domain(THREAD, host_klass-&gt;protection_domain());
 885 
 886   GrowableArray&lt;Handle&gt;* cp_patches = NULL;
 887 
 888   if (cp_patches_h.not_null()) {
 889     int alen = cp_patches_h-&gt;length();
 890 
 891     for (int i = alen-1; i &gt;= 0; i--) {
 892       oop p = cp_patches_h-&gt;obj_at(i);
 893       if (p != NULL) {
 894         Handle patch(THREAD, p);
 895 
 896         if (cp_patches == NULL) {
 897           cp_patches = new GrowableArray&lt;Handle&gt;(i+1, i+1, Handle());
 898         }
 899 
 900         cp_patches-&gt;at_put(i, patch);
 901       }
 902     }
 903   }
 904 
 905   ClassFileStream st(class_bytes, class_bytes_length, host_source, ClassFileStream::verify);
 906 
 907   Symbol* no_class_name = NULL;
 908   Klass* anonk = SystemDictionary::parse_stream(no_class_name,
 909                                                 host_loader,
 910                                                 host_domain,
 911                                                 &amp;st,
 912                                                 host_klass,
 913                                                 cp_patches,
 914                                                 CHECK_NULL);
 915   if (anonk == NULL) {
 916     return NULL;
 917   }
 918 
 919   return instanceKlassHandle(THREAD, anonk);
 920 }
 921 
 922 UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, jclass host_class, jbyteArray data, jobjectArray cp_patches_jh)) {
 923   ResourceMark rm(THREAD);
 924 
 925   instanceKlassHandle anon_klass;
 926   jobject res_jh = NULL;
 927   u1* temp_alloc = NULL;
 928 
 929   anon_klass = Unsafe_DefineAnonymousClass_impl(env, host_class, data, cp_patches_jh, &amp;temp_alloc, THREAD);
 930   if (anon_klass() != NULL) {
 931     res_jh = JNIHandles::make_local(env, anon_klass-&gt;java_mirror());
 932   }
 933 
 934   // try/finally clause:
 935   if (temp_alloc != NULL) {
 936     FREE_C_HEAP_ARRAY(u1, temp_alloc);
 937   }
 938 
 939   // The anonymous class loader data has been artificially been kept alive to
 940   // this point.   The mirror and any instances of this class have to keep
 941   // it alive afterwards.
 942   if (anon_klass() != NULL) {
 943     anon_klass-&gt;class_loader_data()-&gt;dec_keep_alive();
 944   }
 945 
 946   // let caller initialize it as needed...
 947 
 948   return (jclass) res_jh;
 949 } UNSAFE_END
 950 
 951 
 952 
 953 UNSAFE_ENTRY(void, Unsafe_ThrowException(JNIEnv *env, jobject unsafe, jthrowable thr)) {
 954   ThreadToNativeFromVM ttnfv(thread);
 955   env-&gt;Throw(thr);
 956 } UNSAFE_END
 957 
 958 // JSR166 ------------------------------------------------------------------
 959 
 960 UNSAFE_ENTRY(jobject, Unsafe_CompareAndExchangeObject(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h)) {
 961   oop x = JNIHandles::resolve(x_h);
 962   oop e = JNIHandles::resolve(e_h);
 963   oop p = JNIHandles::resolve(obj);
 964   HeapWord* addr = (HeapWord *)index_oop_from_field_offset_long(p, offset);
 965   oop res = oopDesc::atomic_compare_exchange_oop(x, addr, e, true);
 966   if (res == e) {
 967     update_barrier_set((void*)addr, x);
 968   }
 969   return JNIHandles::make_local(env, res);
 970 } UNSAFE_END
 971 
 972 UNSAFE_ENTRY(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {
 973   oop p = JNIHandles::resolve(obj);
 974   jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);
 975 
 976   return (jint)(Atomic::cmpxchg(x, addr, e));
 977 } UNSAFE_END
 978 
 979 UNSAFE_ENTRY(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {
 980   Handle p(THREAD, JNIHandles::resolve(obj));
 981   jlong* addr = (jlong*)index_oop_from_field_offset_long(p(), offset);
 982 
 983 #ifdef SUPPORTS_NATIVE_CX8
 984   return (jlong)(Atomic::cmpxchg(x, addr, e));
 985 #else
 986   if (VM_Version::supports_cx8()) {
 987     return (jlong)(Atomic::cmpxchg(x, addr, e));
 988   } else {
 989     MutexLockerEx mu(UnsafeJlong_lock, Mutex::_no_safepoint_check_flag);
 990 
 991     jlong val = Atomic::load(addr);
 992     if (val == e) {
 993       Atomic::store(x, addr);
 994     }
 995     return val;
 996   }
 997 #endif
 998 } UNSAFE_END
 999 
1000 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapObject(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h)) {
1001   oop x = JNIHandles::resolve(x_h);
1002   oop e = JNIHandles::resolve(e_h);
1003   oop p = JNIHandles::resolve(obj);
1004   HeapWord* addr = (HeapWord *)index_oop_from_field_offset_long(p, offset);
1005   oop res = oopDesc::atomic_compare_exchange_oop(x, addr, e, true);
1006   if (res != e) {
1007     return false;
1008   }
1009 
1010   update_barrier_set((void*)addr, x);
1011 
1012   return true;
1013 } UNSAFE_END
1014 
1015 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {
1016   oop p = JNIHandles::resolve(obj);
1017   jint* addr = (jint *)index_oop_from_field_offset_long(p, offset);
1018 
1019   return (jint)(Atomic::cmpxchg(x, addr, e)) == e;
1020 } UNSAFE_END
1021 
1022 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {
1023   Handle p(THREAD, JNIHandles::resolve(obj));
1024   jlong* addr = (jlong*)index_oop_from_field_offset_long(p(), offset);
1025 
1026 #ifdef SUPPORTS_NATIVE_CX8
1027   return (jlong)(Atomic::cmpxchg(x, addr, e)) == e;
1028 #else
1029   if (VM_Version::supports_cx8()) {
1030     return (jlong)(Atomic::cmpxchg(x, addr, e)) == e;
1031   } else {
1032     MutexLockerEx mu(UnsafeJlong_lock, Mutex::_no_safepoint_check_flag);
1033 
1034     jlong val = Atomic::load(addr);
1035     if (val != e) {
1036       return false;
1037     }
1038 
1039     Atomic::store(x, addr);
1040     return true;
1041   }
1042 #endif
1043 } UNSAFE_END
1044 
1045 UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time)) {
1046   EventThreadPark event;
1047   HOTSPOT_THREAD_PARK_BEGIN((uintptr_t) thread-&gt;parker(), (int) isAbsolute, time);
1048 
1049   JavaThreadParkedState jtps(thread, time != 0);
1050   thread-&gt;parker()-&gt;park(isAbsolute != 0, time);
1051 
1052   HOTSPOT_THREAD_PARK_END((uintptr_t) thread-&gt;parker());
1053 
1054   if (event.should_commit()) {
1055     oop obj = thread-&gt;current_park_blocker();
1056     event.set_klass((obj != NULL) ? obj-&gt;klass() : NULL);
1057     event.set_timeout(time);
1058     event.set_address((obj != NULL) ? (TYPE_ADDRESS) cast_from_oop&lt;uintptr_t&gt;(obj) : 0);
1059     event.commit();
1060   }
1061 } UNSAFE_END
1062 
1063 UNSAFE_ENTRY(void, Unsafe_Unpark(JNIEnv *env, jobject unsafe, jobject jthread)) {
1064   Parker* p = NULL;
1065 
1066   if (jthread != NULL) {
1067     oop java_thread = JNIHandles::resolve_non_null(jthread);
1068     if (java_thread != NULL) {
1069       jlong lp = java_lang_Thread::park_event(java_thread);
1070       if (lp != 0) {
1071         // This cast is OK even though the jlong might have been read
1072         // non-atomically on 32bit systems, since there, one word will
1073         // always be zero anyway and the value set is always the same
1074         p = (Parker*)addr_from_java(lp);
1075       } else {
1076         // Grab lock if apparently null or using older version of library
1077         MutexLocker mu(Threads_lock);
1078         java_thread = JNIHandles::resolve_non_null(jthread);
1079 
1080         if (java_thread != NULL) {
1081           JavaThread* thr = java_lang_Thread::thread(java_thread);
1082           if (thr != NULL) {
1083             p = thr-&gt;parker();
1084             if (p != NULL) { // Bind to Java thread for next time.
1085               java_lang_Thread::set_park_event(java_thread, addr_to_java(p));
1086             }
1087           }
1088         }
1089       }
1090     }
1091   }
1092 
1093   if (p != NULL) {
1094     HOTSPOT_THREAD_UNPARK((uintptr_t) p);
1095     p-&gt;unpark();
1096   }
1097 } UNSAFE_END
1098 
1099 UNSAFE_ENTRY(jint, Unsafe_GetLoadAverage0(JNIEnv *env, jobject unsafe, jdoubleArray loadavg, jint nelem)) {
1100   const int max_nelem = 3;
1101   double la[max_nelem];
1102   jint ret;
1103 
1104   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(loadavg));
1105   assert(a-&gt;is_typeArray(), "must be type array");
1106 
1107   ret = os::loadavg(la, nelem);
1108   if (ret == -1) {
1109     return -1;
1110   }
1111 
1112   // if successful, ret is the number of samples actually retrieved.
1113   assert(ret &gt;= 0 &amp;&amp; ret &lt;= max_nelem, "Unexpected loadavg return value");
1114   switch(ret) {
1115     case 3: a-&gt;double_at_put(2, (jdouble)la[2]); // fall through
1116     case 2: a-&gt;double_at_put(1, (jdouble)la[1]); // fall through
1117     case 1: a-&gt;double_at_put(0, (jdouble)la[0]); break;
1118   }
1119 
1120   return ret;
1121 } UNSAFE_END
1122 
1123 
1124 /// JVM_RegisterUnsafeMethods
1125 
1126 #define ADR "J"
1127 
1128 #define LANG "Ljava/lang/"
1129 
1130 #define OBJ LANG "Object;"
1131 #define CLS LANG "Class;"
1132 #define FLD LANG "reflect/Field;"
1133 #define THR LANG "Throwable;"
1134 
1135 #define DC_Args  LANG "String;[BII" LANG "ClassLoader;" "Ljava/security/ProtectionDomain;"
1136 #define DAC_Args CLS "[B[" OBJ
1137 
1138 #define CC (char*)  /*cast a literal from (const char*)*/
1139 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
1140 
1141 #define DECLARE_GETPUTOOP(Type, Desc) \
1142     {CC "get" #Type,      CC "(" OBJ "J)" #Desc,       FN_PTR(Unsafe_Get##Type)}, \
1143     {CC "put" #Type,      CC "(" OBJ "J" #Desc ")V",   FN_PTR(Unsafe_Put##Type)}, \
1144     {CC "get" #Type "Volatile",      CC "(" OBJ "J)" #Desc,       FN_PTR(Unsafe_Get##Type##Volatile)}, \
1145     {CC "put" #Type "Volatile",      CC "(" OBJ "J" #Desc ")V",   FN_PTR(Unsafe_Put##Type##Volatile)}
1146 
1147 
1148 static JNINativeMethod jdk_internal_misc_Unsafe_methods[] = {
1149     {CC "getObject",        CC "(" OBJ "J)" OBJ "",   FN_PTR(Unsafe_GetObject)},
1150     {CC "putObject",        CC "(" OBJ "J" OBJ ")V",  FN_PTR(Unsafe_PutObject)},
1151     {CC "getObjectVolatile",CC "(" OBJ "J)" OBJ "",   FN_PTR(Unsafe_GetObjectVolatile)},
1152     {CC "putObjectVolatile",CC "(" OBJ "J" OBJ ")V",  FN_PTR(Unsafe_PutObjectVolatile)},
1153 
1154     {CC "getUncompressedObject", CC "(" ADR ")" OBJ,  FN_PTR(Unsafe_GetUncompressedObject)},
1155     {CC "getJavaMirror",         CC "(" ADR ")" CLS,  FN_PTR(Unsafe_GetJavaMirror)},
1156     {CC "getKlassPointer",       CC "(" OBJ ")" ADR,  FN_PTR(Unsafe_GetKlassPointer)},
1157 
1158     DECLARE_GETPUTOOP(Boolean, Z),
1159     DECLARE_GETPUTOOP(Byte, B),
1160     DECLARE_GETPUTOOP(Short, S),
1161     DECLARE_GETPUTOOP(Char, C),
1162     DECLARE_GETPUTOOP(Int, I),
1163     DECLARE_GETPUTOOP(Long, J),
1164     DECLARE_GETPUTOOP(Float, F),
1165     DECLARE_GETPUTOOP(Double, D),
1166 
1167     {CC "allocateMemory0",    CC "(J)" ADR,              FN_PTR(Unsafe_AllocateMemory0)},
1168     {CC "reallocateMemory0",  CC "(" ADR "J)" ADR,       FN_PTR(Unsafe_ReallocateMemory0)},
1169     {CC "freeMemory0",        CC "(" ADR ")V",           FN_PTR(Unsafe_FreeMemory0)},
1170 
1171     {CC "objectFieldOffset0", CC "(" FLD ")J",           FN_PTR(Unsafe_ObjectFieldOffset0)},
1172     {CC "staticFieldOffset0", CC "(" FLD ")J",           FN_PTR(Unsafe_StaticFieldOffset0)},
1173     {CC "staticFieldBase0",   CC "(" FLD ")" OBJ,        FN_PTR(Unsafe_StaticFieldBase0)},
1174     {CC "ensureClassInitialized0", CC "(" CLS ")V",      FN_PTR(Unsafe_EnsureClassInitialized0)},
1175     {CC "arrayBaseOffset0",   CC "(" CLS ")I",           FN_PTR(Unsafe_ArrayBaseOffset0)},
1176     {CC "arrayIndexScale0",   CC "(" CLS ")I",           FN_PTR(Unsafe_ArrayIndexScale0)},
1177     {CC "addressSize0",       CC "()I",                  FN_PTR(Unsafe_AddressSize0)},
1178     {CC "pageSize",           CC "()I",                  FN_PTR(Unsafe_PageSize)},
1179 
1180     {CC "defineClass0",       CC "(" DC_Args ")" CLS,    FN_PTR(Unsafe_DefineClass0)},
1181     {CC "allocateInstance",   CC "(" CLS ")" OBJ,        FN_PTR(Unsafe_AllocateInstance)},
1182     {CC "throwException",     CC "(" THR ")V",           FN_PTR(Unsafe_ThrowException)},
1183     {CC "compareAndSwapObject", CC "(" OBJ "J" OBJ "" OBJ ")Z", FN_PTR(Unsafe_CompareAndSwapObject)},
1184     {CC "compareAndSwapInt",  CC "(" OBJ "J""I""I"")Z",  FN_PTR(Unsafe_CompareAndSwapInt)},
1185     {CC "compareAndSwapLong", CC "(" OBJ "J""J""J"")Z",  FN_PTR(Unsafe_CompareAndSwapLong)},
1186     {CC "compareAndExchangeObjectVolatile", CC "(" OBJ "J" OBJ "" OBJ ")" OBJ, FN_PTR(Unsafe_CompareAndExchangeObject)},
1187     {CC "compareAndExchangeIntVolatile",  CC "(" OBJ "J""I""I"")I", FN_PTR(Unsafe_CompareAndExchangeInt)},
1188     {CC "compareAndExchangeLongVolatile", CC "(" OBJ "J""J""J"")J", FN_PTR(Unsafe_CompareAndExchangeLong)},
1189 
1190     {CC "park",               CC "(ZJ)V",                FN_PTR(Unsafe_Park)},
1191     {CC "unpark",             CC "(" OBJ ")V",           FN_PTR(Unsafe_Unpark)},
1192 
1193     {CC "getLoadAverage0",    CC "([DI)I",               FN_PTR(Unsafe_GetLoadAverage0)},
1194 
1195     {CC "copyMemory0",        CC "(" OBJ "J" OBJ "JJ)V", FN_PTR(Unsafe_CopyMemory0)},
1196     {CC "copySwapMemory0",    CC "(" OBJ "J" OBJ "JJJ)V", FN_PTR(Unsafe_CopySwapMemory0)},
1197     {CC "setMemory0",         CC "(" OBJ "JJB)V",        FN_PTR(Unsafe_SetMemory0)},
1198 
1199     {CC "defineAnonymousClass0", CC "(" DAC_Args ")" CLS, FN_PTR(Unsafe_DefineAnonymousClass0)},
1200 
1201     {CC "shouldBeInitialized0", CC "(" CLS ")Z",         FN_PTR(Unsafe_ShouldBeInitialized0)},
1202 
1203     {CC "loadFence",          CC "()V",                  FN_PTR(Unsafe_LoadFence)},
1204     {CC "storeFence",         CC "()V",                  FN_PTR(Unsafe_StoreFence)},
1205     {CC "fullFence",          CC "()V",                  FN_PTR(Unsafe_FullFence)},
1206 
1207     {CC "isBigEndian0",       CC "()Z",                  FN_PTR(Unsafe_isBigEndian0)},
1208     {CC "unalignedAccess0",   CC "()Z",                  FN_PTR(Unsafe_unalignedAccess0)}
1209 };
1210 
1211 #undef CC
1212 #undef FN_PTR
1213 
1214 #undef ADR
1215 #undef LANG
1216 #undef OBJ
1217 #undef CLS
1218 #undef FLD
1219 #undef THR
1220 #undef DC_Args
1221 #undef DAC_Args
1222 
1223 #undef DECLARE_GETPUTOOP
1224 
1225 
1226 // This function is exported, used by NativeLookup.
1227 // The Unsafe_xxx functions above are called only from the interpreter.
1228 // The optimizer looks at names and signatures to recognize
1229 // individual functions.
1230 
1231 JVM_ENTRY(void, JVM_RegisterJDKInternalMiscUnsafeMethods(JNIEnv *env, jclass unsafeclass)) {
1232   ThreadToNativeFromVM ttnfv(thread);
1233 
1234   int ok = env-&gt;RegisterNatives(unsafeclass, jdk_internal_misc_Unsafe_methods, sizeof(jdk_internal_misc_Unsafe_methods)/sizeof(JNINativeMethod));
1235   guarantee(ok == 0, "register jdk.internal.misc.Unsafe natives");
1236 } JVM_END
</pre></body></html>
