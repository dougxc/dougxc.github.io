<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotSignature.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfigVerifier.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfig.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
<span class="removed">  25 import static jdk.vm.ci.common.UnsafeUtil.readCString;</span>
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  27 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  28 
  29 import java.lang.reflect.Field;
  30 import java.lang.reflect.Modifier;
  31 import java.util.HashMap;
  32 import java.util.Iterator;
  33 

  34 import jdk.internal.vm.annotation.Stable;
<span class="removed">  35 import jdk.vm.ci.common.JVMCIError;</span>
  36 import jdk.vm.ci.hotspotvmconfig.HotSpotVMAddress;
  37 import jdk.vm.ci.hotspotvmconfig.HotSpotVMConstant;
  38 import jdk.vm.ci.hotspotvmconfig.HotSpotVMData;
  39 import jdk.vm.ci.hotspotvmconfig.HotSpotVMField;
  40 import jdk.vm.ci.hotspotvmconfig.HotSpotVMFlag;
  41 import jdk.vm.ci.hotspotvmconfig.HotSpotVMType;
<span class="removed">  42 import jdk.internal.misc.Unsafe;</span>
  43 
  44 //JaCoCo Exclude
  45 
  46 /**
  47  * Used to access native configuration details.
  48  *
  49  * All non-static, public fields in this class are so that they can be compiled as constants.
  50  */
  51 public class HotSpotVMConfig {
  52 
  53     /**
  54      * Gets the configuration associated with the singleton {@link HotSpotJVMCIRuntime}.
  55      */
  56     public static HotSpotVMConfig config() {
  57         return runtime().getConfig();
  58     }
  59 
  60     /**
  61      * Maximum allowed size of allocated area for a frame.
  62      */

</pre><hr></hr><pre>
  66         // Get raw pointer to the array that contains all gHotSpotVM values.
  67         final long gHotSpotVMData = compilerToVm.initializeConfiguration(this);
  68         assert gHotSpotVMData != 0;
  69 
  70         // Make FindBugs happy.
  71         jvmciHotSpotVMStructs = 0;
  72         jvmciHotSpotVMTypes = 0;
  73         jvmciHotSpotVMIntConstants = 0;
  74         jvmciHotSpotVMLongConstants = 0;
  75         jvmciHotSpotVMAddresses = 0;
  76 
  77         // Initialize the gHotSpotVM fields.
  78         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
  79             if (f.isAnnotationPresent(HotSpotVMData.class)) {
  80                 HotSpotVMData annotation = f.getAnnotation(HotSpotVMData.class);
  81                 final int index = annotation.index();
  82                 final long value = UNSAFE.getAddress(gHotSpotVMData + Unsafe.ADDRESS_SIZE * index);
  83                 try {
  84                     f.setLong(this, value);
  85                 } catch (IllegalAccessException e) {
<span class="changed">  86                     throw new JVMCIError("index " + index, e);</span>
  87                 }
  88             }
  89         }
  90 
  91         // Quick sanity check.
  92         assert jvmciHotSpotVMStructs != 0;
  93         assert jvmciHotSpotVMTypes != 0;
  94         assert jvmciHotSpotVMIntConstants != 0;
  95         assert jvmciHotSpotVMLongConstants != 0;
  96         assert jvmciHotSpotVMAddresses != 0;
  97 
  98         initialize();
  99 
 100         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift, logMinObjAlignment());
 101         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift, logKlassAlignment);
 102 
 103         assert check();
 104         assert HotSpotVMConfigVerifier.check();
 105     }
 106 
 107     @Override
 108     public String toString() {
 109         return getClass().getSimpleName();
 110     }
 111 
 112     /**





















 113      * Initialize fields by reading their values from vmStructs.
 114      */
 115     private void initialize() {
 116         // Fill the VM fields hash map.
 117         HashMap&lt;String, VMFields.Field&gt; vmFields = new HashMap&lt;&gt;();
 118         for (VMFields.Field e : new VMFields(jvmciHotSpotVMStructs)) {
 119             vmFields.put(e.getName(), e);
 120         }
 121 
 122         // Fill the VM types hash map.
 123         HashMap&lt;String, VMTypes.Type&gt; vmTypes = new HashMap&lt;&gt;();
 124         for (VMTypes.Type e : new VMTypes(jvmciHotSpotVMTypes)) {
 125             vmTypes.put(e.getTypeName(), e);
 126         }
 127 
 128         // Fill the VM constants hash map.
 129         HashMap&lt;String, AbstractConstant&gt; vmConstants = new HashMap&lt;&gt;();
 130         for (AbstractConstant e : new VMIntConstants(jvmciHotSpotVMIntConstants)) {
 131             vmConstants.put(e.getName(), e);
 132         }

</pre><hr></hr><pre>
 142 
 143         // Fill the flags hash map.
 144         HashMap&lt;String, Flags.Flag&gt; flags = new HashMap&lt;&gt;();
 145         for (Flags.Flag e : new Flags(vmFields, vmTypes)) {
 146             flags.put(e.getName(), e);
 147         }
 148 
 149         String osName = getHostOSName();
 150         String osArch = getHostArchitectureName();
 151 
 152         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
 153             if (f.isAnnotationPresent(HotSpotVMField.class)) {
 154                 HotSpotVMField annotation = f.getAnnotation(HotSpotVMField.class);
 155                 String name = annotation.name();
 156                 String type = annotation.type();
 157                 VMFields.Field entry = vmFields.get(name);
 158                 if (entry == null) {
 159                     if (!isRequired(osArch, annotation.archs())) {
 160                         continue;
 161                     }
<span class="changed"> 162                     throw new JVMCIError(f.getName() + ": expected VM field not found: " + name);</span>
 163                 }
 164 
 165                 // Make sure the native type is still the type we expect.
 166                 if (!type.isEmpty()) {
 167                     if (!type.equals(entry.getTypeString())) {
<span class="changed"> 168                         throw new JVMCIError(f.getName() + ": compiler expects type " + type + " but VM field " + name + " is of type " + entry.getTypeString());</span>
 169                     }
 170                 }
 171 
 172                 switch (annotation.get()) {
 173                     case OFFSET:
 174                         setField(f, entry.getOffset());
 175                         break;
 176                     case ADDRESS:
 177                         setField(f, entry.getAddress());
 178                         break;
 179                     case VALUE:
 180                         setField(f, entry.getValue());
 181                         break;
 182                     default:
<span class="changed"> 183                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());</span>
 184                 }
 185             } else if (f.isAnnotationPresent(HotSpotVMType.class)) {
 186                 HotSpotVMType annotation = f.getAnnotation(HotSpotVMType.class);
 187                 String name = annotation.name();
 188                 VMTypes.Type entry = vmTypes.get(name);
 189                 if (entry == null) {
<span class="changed"> 190                     throw new JVMCIError(f.getName() + ": expected VM type not found: " + name);</span>
 191                 }
 192 
 193                 switch (annotation.get()) {
 194                     case SIZE:
 195                         setField(f, entry.getSize());
 196                         break;
 197                     default:
<span class="changed"> 198                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());</span>
 199                 }
 200             } else if (f.isAnnotationPresent(HotSpotVMConstant.class)) {
 201                 HotSpotVMConstant annotation = f.getAnnotation(HotSpotVMConstant.class);
 202                 String name = annotation.name();
 203                 AbstractConstant entry = vmConstants.get(name);
 204                 if (entry == null) {
 205                     if (!isRequired(osArch, annotation.archs())) {
 206                         continue;
 207                     }
<span class="changed"> 208                     throw new JVMCIError(f.getName() + ": expected VM constant not found: " + name);</span>
 209                 }
 210                 setField(f, entry.getValue());
 211             } else if (f.isAnnotationPresent(HotSpotVMAddress.class)) {
 212                 HotSpotVMAddress annotation = f.getAnnotation(HotSpotVMAddress.class);
 213                 String name = annotation.name();
 214                 VMAddresses.Address entry = vmAddresses.get(name);
 215                 if (entry == null) {
 216                     if (!isRequired(osName, annotation.os())) {
 217                         continue;
 218                     }
<span class="changed"> 219                     throw new JVMCIError(f.getName() + ": expected VM address not found: " + name);</span>
 220                 }
 221                 setField(f, entry.getValue());
 222             } else if (f.isAnnotationPresent(HotSpotVMFlag.class)) {
 223                 HotSpotVMFlag annotation = f.getAnnotation(HotSpotVMFlag.class);
 224                 String name = annotation.name();
 225                 Flags.Flag entry = flags.get(name);
 226                 if (entry == null) {
 227                     if (annotation.optional() || !isRequired(osArch, annotation.archs())) {
 228                         continue;
 229                     }
<span class="changed"> 230                     throw new JVMCIError(f.getName() + ": expected VM flag not found: " + name);</span>
 231 
 232                 }
 233                 setField(f, entry.getValue());
 234             }
 235         }
 236     }
 237 
 238     private final CompressEncoding oopEncoding;
 239     private final CompressEncoding klassEncoding;
 240 
 241     public CompressEncoding getOopEncoding() {
 242         return oopEncoding;
 243     }
 244 
 245     public CompressEncoding getKlassEncoding() {
 246         return klassEncoding;
 247     }
 248 
 249     private void setField(Field field, Object value) {
 250         try {
 251             Class&lt;?&gt; fieldType = field.getType();
 252             if (fieldType == boolean.class) {
 253                 if (value instanceof String) {
 254                     field.setBoolean(this, Boolean.valueOf((String) value));
 255                 } else if (value instanceof Boolean) {
 256                     field.setBoolean(this, (boolean) value);
 257                 } else if (value instanceof Long) {
 258                     field.setBoolean(this, ((long) value) != 0);
 259                 } else {
<span class="changed"> 260                     throw new JVMCIError(value.getClass().getSimpleName());</span>
 261                 }
 262             } else if (fieldType == byte.class) {
 263                 if (value instanceof Long) {
 264                     field.setByte(this, (byte) (long) value);
 265                 } else {
<span class="changed"> 266                     throw new JVMCIError(value.getClass().getSimpleName());</span>
 267                 }
 268             } else if (fieldType == int.class) {
 269                 if (value instanceof Integer) {
 270                     field.setInt(this, (int) value);
 271                 } else if (value instanceof Long) {
 272                     field.setInt(this, (int) (long) value);
 273                 } else {
<span class="changed"> 274                     throw new JVMCIError(value.getClass().getSimpleName());</span>
 275                 }
 276             } else if (fieldType == long.class) {
 277                 field.setLong(this, (long) value);
 278             } else {
<span class="changed"> 279                 throw new JVMCIError(field.toString());</span>
 280             }
 281         } catch (IllegalAccessException e) {
<span class="changed"> 282             throw new JVMCIError("%s: %s", field, e);</span>
 283         }
 284     }
 285 
 286     /**
 287      * Gets the host operating system name.
 288      */
 289     private static String getHostOSName() {
 290         String osName = System.getProperty("os.name");
 291         switch (osName) {
 292             case "Linux":
 293                 osName = "linux";
 294                 break;
 295             case "SunOS":
 296                 osName = "solaris";
 297                 break;
 298             case "Mac OS X":
 299                 osName = "bsd";
 300                 break;
 301             default:
 302                 // Of course Windows is different...
 303                 if (osName.startsWith("Windows")) {
 304                     osName = "windows";
 305                 } else {
<span class="changed"> 306                     throw new JVMCIError("Unexpected OS name: " + osName);</span>
 307                 }
 308         }
 309         return osName;
 310     }
 311 
 312     /**
 313      * Gets the host architecture name for the purpose of finding the corresponding
 314      * {@linkplain HotSpotJVMCIBackendFactory backend}.
 315      */
 316     public String getHostArchitectureName() {
 317         String arch = System.getProperty("os.arch");
 318         switch (arch) {
 319             case "x86_64":
 320                 arch = "amd64";
 321                 break;
 322             case "sparcv9":
 323                 arch = "sparc";
 324                 break;
 325         }
 326         return arch;

</pre><hr></hr><pre>
 433 
 434             public long getValue() {
 435                 String type = getTypeString();
 436                 switch (type) {
 437                     case "bool":
 438                         return UNSAFE.getByte(getAddress());
 439                     case "int":
 440                         return UNSAFE.getInt(getAddress());
 441                     case "uint64_t":
 442                         return UNSAFE.getLong(getAddress());
 443                     case "address":
 444                     case "intptr_t":
 445                     case "uintptr_t":
 446                     case "size_t":
 447                         return UNSAFE.getAddress(getAddress());
 448                     default:
 449                         // All foo* types are addresses.
 450                         if (type.endsWith("*")) {
 451                             return UNSAFE.getAddress(getAddress());
 452                         }
<span class="changed"> 453                         throw new JVMCIError(type);</span>
 454                 }
 455             }
 456 
 457             @Override
 458             public String toString() {
 459                 return String.format("Field[typeName=%s, fieldName=%s, typeString=%s, isStatic=%b, offset=%d, address=0x%x]", getTypeName(), getFieldName(), getTypeString(), isStatic(), getOffset(),
 460                                 getAddress());
 461             }
 462         }
 463     }
 464 
 465     /**
 466      * VMTypeEntry (see vmStructs.hpp).
 467      */
 468     @HotSpotVMData(index = 8) @Stable private long jvmciHotSpotVMTypes;
 469     @HotSpotVMData(index = 9) @Stable private long jvmciHotSpotVMTypeEntryTypeNameOffset;
 470     @HotSpotVMData(index = 10) @Stable private long jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 471     @HotSpotVMData(index = 11) @Stable private long jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 472     @HotSpotVMData(index = 12) @Stable private long jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 473     @HotSpotVMData(index = 13) @Stable private long jvmciHotSpotVMTypeEntryIsUnsignedOffset;

</pre><hr></hr><pre>
 810             }
 811 
 812             public long getAddr() {
 813                 return UNSAFE.getAddress(entryAddress + addrOffset);
 814             }
 815 
 816             public Object getValue() {
 817                 switch (getType()) {
 818                     case "bool":
 819                         return Boolean.valueOf(UNSAFE.getByte(getAddr()) != 0);
 820                     case "intx":
 821                     case "uintx":
 822                     case "uint64_t":
 823                         return Long.valueOf(UNSAFE.getLong(getAddr()));
 824                     case "double":
 825                         return Double.valueOf(UNSAFE.getDouble(getAddr()));
 826                     case "ccstr":
 827                     case "ccstrlist":
 828                         return readCString(UNSAFE, getAddr());
 829                     default:
<span class="changed"> 830                         throw new JVMCIError(getType());</span>
 831                 }
 832             }
 833 
 834             @Override
 835             public String toString() {
 836                 return String.format("Flag[type=%s, name=%s, value=%s]", getType(), getName(), getValue());
 837             }
 838         }
 839     }
 840 
 841     @HotSpotVMConstant(name = "ASSERT") @Stable public boolean cAssertions;
 842     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
 843     public final boolean linuxOs = System.getProperty("os.name", "").startsWith("Linux");
 844 
 845     @HotSpotVMFlag(name = "CodeEntryAlignment") @Stable public int codeEntryAlignment;
 846     @HotSpotVMFlag(name = "VerifyOops") @Stable public boolean verifyOops;
 847     @HotSpotVMFlag(name = "CITime") @Stable public boolean ciTime;
 848     @HotSpotVMFlag(name = "CITimeEach") @Stable public boolean ciTimeEach;
 849     @HotSpotVMFlag(name = "CompileTheWorldStartAt", optional = true) @Stable public int compileTheWorldStartAt;
 850     @HotSpotVMFlag(name = "CompileTheWorldStopAt", optional = true) @Stable public int compileTheWorldStopAt;

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 

  25 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  26 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  27 
  28 import java.lang.reflect.Field;
  29 import java.lang.reflect.Modifier;
  30 import java.util.HashMap;
  31 import java.util.Iterator;
  32 
<span class="new">  33 import jdk.internal.misc.Unsafe;</span>
  34 import jdk.internal.vm.annotation.Stable;

  35 import jdk.vm.ci.hotspotvmconfig.HotSpotVMAddress;
  36 import jdk.vm.ci.hotspotvmconfig.HotSpotVMConstant;
  37 import jdk.vm.ci.hotspotvmconfig.HotSpotVMData;
  38 import jdk.vm.ci.hotspotvmconfig.HotSpotVMField;
  39 import jdk.vm.ci.hotspotvmconfig.HotSpotVMFlag;
  40 import jdk.vm.ci.hotspotvmconfig.HotSpotVMType;

  41 
  42 //JaCoCo Exclude
  43 
  44 /**
  45  * Used to access native configuration details.
  46  *
  47  * All non-static, public fields in this class are so that they can be compiled as constants.
  48  */
  49 public class HotSpotVMConfig {
  50 
  51     /**
  52      * Gets the configuration associated with the singleton {@link HotSpotJVMCIRuntime}.
  53      */
  54     public static HotSpotVMConfig config() {
  55         return runtime().getConfig();
  56     }
  57 
  58     /**
  59      * Maximum allowed size of allocated area for a frame.
  60      */

</pre><hr></hr><pre>
  64         // Get raw pointer to the array that contains all gHotSpotVM values.
  65         final long gHotSpotVMData = compilerToVm.initializeConfiguration(this);
  66         assert gHotSpotVMData != 0;
  67 
  68         // Make FindBugs happy.
  69         jvmciHotSpotVMStructs = 0;
  70         jvmciHotSpotVMTypes = 0;
  71         jvmciHotSpotVMIntConstants = 0;
  72         jvmciHotSpotVMLongConstants = 0;
  73         jvmciHotSpotVMAddresses = 0;
  74 
  75         // Initialize the gHotSpotVM fields.
  76         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
  77             if (f.isAnnotationPresent(HotSpotVMData.class)) {
  78                 HotSpotVMData annotation = f.getAnnotation(HotSpotVMData.class);
  79                 final int index = annotation.index();
  80                 final long value = UNSAFE.getAddress(gHotSpotVMData + Unsafe.ADDRESS_SIZE * index);
  81                 try {
  82                     f.setLong(this, value);
  83                 } catch (IllegalAccessException e) {
<span class="changed">  84                     throw new InternalError("index " + index, e);</span>
  85                 }
  86             }
  87         }
  88 
  89         // Quick sanity check.
  90         assert jvmciHotSpotVMStructs != 0;
  91         assert jvmciHotSpotVMTypes != 0;
  92         assert jvmciHotSpotVMIntConstants != 0;
  93         assert jvmciHotSpotVMLongConstants != 0;
  94         assert jvmciHotSpotVMAddresses != 0;
  95 
  96         initialize();
  97 
  98         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift, logMinObjAlignment());
  99         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift, logKlassAlignment);
 100 
 101         assert check();
 102         assert HotSpotVMConfigVerifier.check();
 103     }
 104 
 105     @Override
 106     public String toString() {
 107         return getClass().getSimpleName();
 108     }
 109 
 110     /**
<span class="new"> 111      * Reads a {@code '\0'} terminated C string from native memory and converts it to a</span>
<span class="new"> 112      * {@link String}.</span>
<span class="new"> 113      *</span>
<span class="new"> 114      * @return a Java string</span>
<span class="new"> 115      */</span>
<span class="new"> 116     static String readCString(Unsafe unsafe, long address) {</span>
<span class="new"> 117         if (address == 0) {</span>
<span class="new"> 118             return null;</span>
<span class="new"> 119         }</span>
<span class="new"> 120         StringBuilder sb = new StringBuilder();</span>
<span class="new"> 121         for (int i = 0;; i++) {</span>
<span class="new"> 122             char c = (char) unsafe.getByte(address + i);</span>
<span class="new"> 123             if (c == 0) {</span>
<span class="new"> 124                 break;</span>
<span class="new"> 125             }</span>
<span class="new"> 126             sb.append(c);</span>
<span class="new"> 127         }</span>
<span class="new"> 128         return sb.toString();</span>
<span class="new"> 129     }</span>
<span class="new"> 130 </span>
<span class="new"> 131     /**</span>
 132      * Initialize fields by reading their values from vmStructs.
 133      */
 134     private void initialize() {
 135         // Fill the VM fields hash map.
 136         HashMap&lt;String, VMFields.Field&gt; vmFields = new HashMap&lt;&gt;();
 137         for (VMFields.Field e : new VMFields(jvmciHotSpotVMStructs)) {
 138             vmFields.put(e.getName(), e);
 139         }
 140 
 141         // Fill the VM types hash map.
 142         HashMap&lt;String, VMTypes.Type&gt; vmTypes = new HashMap&lt;&gt;();
 143         for (VMTypes.Type e : new VMTypes(jvmciHotSpotVMTypes)) {
 144             vmTypes.put(e.getTypeName(), e);
 145         }
 146 
 147         // Fill the VM constants hash map.
 148         HashMap&lt;String, AbstractConstant&gt; vmConstants = new HashMap&lt;&gt;();
 149         for (AbstractConstant e : new VMIntConstants(jvmciHotSpotVMIntConstants)) {
 150             vmConstants.put(e.getName(), e);
 151         }

</pre><hr></hr><pre>
 161 
 162         // Fill the flags hash map.
 163         HashMap&lt;String, Flags.Flag&gt; flags = new HashMap&lt;&gt;();
 164         for (Flags.Flag e : new Flags(vmFields, vmTypes)) {
 165             flags.put(e.getName(), e);
 166         }
 167 
 168         String osName = getHostOSName();
 169         String osArch = getHostArchitectureName();
 170 
 171         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
 172             if (f.isAnnotationPresent(HotSpotVMField.class)) {
 173                 HotSpotVMField annotation = f.getAnnotation(HotSpotVMField.class);
 174                 String name = annotation.name();
 175                 String type = annotation.type();
 176                 VMFields.Field entry = vmFields.get(name);
 177                 if (entry == null) {
 178                     if (!isRequired(osArch, annotation.archs())) {
 179                         continue;
 180                     }
<span class="changed"> 181                     throw new InternalError(f.getName() + ": expected VM field not found: " + name);</span>
 182                 }
 183 
 184                 // Make sure the native type is still the type we expect.
 185                 if (!type.isEmpty()) {
 186                     if (!type.equals(entry.getTypeString())) {
<span class="changed"> 187                         throw new InternalError(f.getName() + ": compiler expects type " + type + " but VM field " + name + " is of type " + entry.getTypeString());</span>
 188                     }
 189                 }
 190 
 191                 switch (annotation.get()) {
 192                     case OFFSET:
 193                         setField(f, entry.getOffset());
 194                         break;
 195                     case ADDRESS:
 196                         setField(f, entry.getAddress());
 197                         break;
 198                     case VALUE:
 199                         setField(f, entry.getValue());
 200                         break;
 201                     default:
<span class="changed"> 202                         throw new InternalError(f.getName() + ": unknown kind: " + annotation.get());</span>
 203                 }
 204             } else if (f.isAnnotationPresent(HotSpotVMType.class)) {
 205                 HotSpotVMType annotation = f.getAnnotation(HotSpotVMType.class);
 206                 String name = annotation.name();
 207                 VMTypes.Type entry = vmTypes.get(name);
 208                 if (entry == null) {
<span class="changed"> 209                     throw new InternalError(f.getName() + ": expected VM type not found: " + name);</span>
 210                 }
 211 
 212                 switch (annotation.get()) {
 213                     case SIZE:
 214                         setField(f, entry.getSize());
 215                         break;
 216                     default:
<span class="changed"> 217                         throw new InternalError(f.getName() + ": unknown kind: " + annotation.get());</span>
 218                 }
 219             } else if (f.isAnnotationPresent(HotSpotVMConstant.class)) {
 220                 HotSpotVMConstant annotation = f.getAnnotation(HotSpotVMConstant.class);
 221                 String name = annotation.name();
 222                 AbstractConstant entry = vmConstants.get(name);
 223                 if (entry == null) {
 224                     if (!isRequired(osArch, annotation.archs())) {
 225                         continue;
 226                     }
<span class="changed"> 227                     throw new InternalError(f.getName() + ": expected VM constant not found: " + name);</span>
 228                 }
 229                 setField(f, entry.getValue());
 230             } else if (f.isAnnotationPresent(HotSpotVMAddress.class)) {
 231                 HotSpotVMAddress annotation = f.getAnnotation(HotSpotVMAddress.class);
 232                 String name = annotation.name();
 233                 VMAddresses.Address entry = vmAddresses.get(name);
 234                 if (entry == null) {
 235                     if (!isRequired(osName, annotation.os())) {
 236                         continue;
 237                     }
<span class="changed"> 238                     throw new InternalError(f.getName() + ": expected VM address not found: " + name);</span>
 239                 }
 240                 setField(f, entry.getValue());
 241             } else if (f.isAnnotationPresent(HotSpotVMFlag.class)) {
 242                 HotSpotVMFlag annotation = f.getAnnotation(HotSpotVMFlag.class);
 243                 String name = annotation.name();
 244                 Flags.Flag entry = flags.get(name);
 245                 if (entry == null) {
 246                     if (annotation.optional() || !isRequired(osArch, annotation.archs())) {
 247                         continue;
 248                     }
<span class="changed"> 249                     throw new InternalError(f.getName() + ": expected VM flag not found: " + name);</span>
 250 
 251                 }
 252                 setField(f, entry.getValue());
 253             }
 254         }
 255     }
 256 
 257     private final CompressEncoding oopEncoding;
 258     private final CompressEncoding klassEncoding;
 259 
 260     public CompressEncoding getOopEncoding() {
 261         return oopEncoding;
 262     }
 263 
 264     public CompressEncoding getKlassEncoding() {
 265         return klassEncoding;
 266     }
 267 
 268     private void setField(Field field, Object value) {
 269         try {
 270             Class&lt;?&gt; fieldType = field.getType();
 271             if (fieldType == boolean.class) {
 272                 if (value instanceof String) {
 273                     field.setBoolean(this, Boolean.valueOf((String) value));
 274                 } else if (value instanceof Boolean) {
 275                     field.setBoolean(this, (boolean) value);
 276                 } else if (value instanceof Long) {
 277                     field.setBoolean(this, ((long) value) != 0);
 278                 } else {
<span class="changed"> 279                     throw new InternalError(value.getClass().getSimpleName());</span>
 280                 }
 281             } else if (fieldType == byte.class) {
 282                 if (value instanceof Long) {
 283                     field.setByte(this, (byte) (long) value);
 284                 } else {
<span class="changed"> 285                     throw new InternalError(value.getClass().getSimpleName());</span>
 286                 }
 287             } else if (fieldType == int.class) {
 288                 if (value instanceof Integer) {
 289                     field.setInt(this, (int) value);
 290                 } else if (value instanceof Long) {
 291                     field.setInt(this, (int) (long) value);
 292                 } else {
<span class="changed"> 293                     throw new InternalError(value.getClass().getSimpleName());</span>
 294                 }
 295             } else if (fieldType == long.class) {
 296                 field.setLong(this, (long) value);
 297             } else {
<span class="changed"> 298                 throw new InternalError(field.toString());</span>
 299             }
 300         } catch (IllegalAccessException e) {
<span class="changed"> 301             throw new InternalError(String.format("%s: %s", field, e));</span>
 302         }
 303     }
 304 
 305     /**
 306      * Gets the host operating system name.
 307      */
 308     private static String getHostOSName() {
 309         String osName = System.getProperty("os.name");
 310         switch (osName) {
 311             case "Linux":
 312                 osName = "linux";
 313                 break;
 314             case "SunOS":
 315                 osName = "solaris";
 316                 break;
 317             case "Mac OS X":
 318                 osName = "bsd";
 319                 break;
 320             default:
 321                 // Of course Windows is different...
 322                 if (osName.startsWith("Windows")) {
 323                     osName = "windows";
 324                 } else {
<span class="changed"> 325                     throw new InternalError("Unexpected OS name: " + osName);</span>
 326                 }
 327         }
 328         return osName;
 329     }
 330 
 331     /**
 332      * Gets the host architecture name for the purpose of finding the corresponding
 333      * {@linkplain HotSpotJVMCIBackendFactory backend}.
 334      */
 335     public String getHostArchitectureName() {
 336         String arch = System.getProperty("os.arch");
 337         switch (arch) {
 338             case "x86_64":
 339                 arch = "amd64";
 340                 break;
 341             case "sparcv9":
 342                 arch = "sparc";
 343                 break;
 344         }
 345         return arch;

</pre><hr></hr><pre>
 452 
 453             public long getValue() {
 454                 String type = getTypeString();
 455                 switch (type) {
 456                     case "bool":
 457                         return UNSAFE.getByte(getAddress());
 458                     case "int":
 459                         return UNSAFE.getInt(getAddress());
 460                     case "uint64_t":
 461                         return UNSAFE.getLong(getAddress());
 462                     case "address":
 463                     case "intptr_t":
 464                     case "uintptr_t":
 465                     case "size_t":
 466                         return UNSAFE.getAddress(getAddress());
 467                     default:
 468                         // All foo* types are addresses.
 469                         if (type.endsWith("*")) {
 470                             return UNSAFE.getAddress(getAddress());
 471                         }
<span class="changed"> 472                         throw new InternalError(type);</span>
 473                 }
 474             }
 475 
 476             @Override
 477             public String toString() {
 478                 return String.format("Field[typeName=%s, fieldName=%s, typeString=%s, isStatic=%b, offset=%d, address=0x%x]", getTypeName(), getFieldName(), getTypeString(), isStatic(), getOffset(),
 479                                 getAddress());
 480             }
 481         }
 482     }
 483 
 484     /**
 485      * VMTypeEntry (see vmStructs.hpp).
 486      */
 487     @HotSpotVMData(index = 8) @Stable private long jvmciHotSpotVMTypes;
 488     @HotSpotVMData(index = 9) @Stable private long jvmciHotSpotVMTypeEntryTypeNameOffset;
 489     @HotSpotVMData(index = 10) @Stable private long jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 490     @HotSpotVMData(index = 11) @Stable private long jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 491     @HotSpotVMData(index = 12) @Stable private long jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 492     @HotSpotVMData(index = 13) @Stable private long jvmciHotSpotVMTypeEntryIsUnsignedOffset;

</pre><hr></hr><pre>
 829             }
 830 
 831             public long getAddr() {
 832                 return UNSAFE.getAddress(entryAddress + addrOffset);
 833             }
 834 
 835             public Object getValue() {
 836                 switch (getType()) {
 837                     case "bool":
 838                         return Boolean.valueOf(UNSAFE.getByte(getAddr()) != 0);
 839                     case "intx":
 840                     case "uintx":
 841                     case "uint64_t":
 842                         return Long.valueOf(UNSAFE.getLong(getAddr()));
 843                     case "double":
 844                         return Double.valueOf(UNSAFE.getDouble(getAddr()));
 845                     case "ccstr":
 846                     case "ccstrlist":
 847                         return readCString(UNSAFE, getAddr());
 848                     default:
<span class="changed"> 849                         throw new InternalError(getType());</span>
 850                 }
 851             }
 852 
 853             @Override
 854             public String toString() {
 855                 return String.format("Flag[type=%s, name=%s, value=%s]", getType(), getName(), getValue());
 856             }
 857         }
 858     }
 859 
 860     @HotSpotVMConstant(name = "ASSERT") @Stable public boolean cAssertions;
 861     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
 862     public final boolean linuxOs = System.getProperty("os.name", "").startsWith("Linux");
 863 
 864     @HotSpotVMFlag(name = "CodeEntryAlignment") @Stable public int codeEntryAlignment;
 865     @HotSpotVMFlag(name = "VerifyOops") @Stable public boolean verifyOops;
 866     @HotSpotVMFlag(name = "CITime") @Stable public boolean ciTime;
 867     @HotSpotVMFlag(name = "CITimeEach") @Stable public boolean ciTimeEach;
 868     @HotSpotVMFlag(name = "CompileTheWorldStartAt", optional = true) @Stable public int compileTheWorldStartAt;
 869     @HotSpotVMFlag(name = "CompileTheWorldStopAt", optional = true) @Stable public int compileTheWorldStopAt;

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotSignature.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../../../../../src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfigVerifier.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
