<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfig.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.UnsafeUtil.readCString;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  27 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  28 
  29 import java.lang.reflect.Field;
  30 import java.lang.reflect.Modifier;
  31 import java.util.HashMap;
  32 import java.util.Iterator;
  33 
  34 import jdk.internal.vm.annotation.Stable;
  35 import jdk.vm.ci.common.JVMCIError;
  36 import jdk.vm.ci.hotspotvmconfig.HotSpotVMAddress;
  37 import jdk.vm.ci.hotspotvmconfig.HotSpotVMConstant;
  38 import jdk.vm.ci.hotspotvmconfig.HotSpotVMData;
  39 import jdk.vm.ci.hotspotvmconfig.HotSpotVMField;
  40 import jdk.vm.ci.hotspotvmconfig.HotSpotVMFlag;
  41 import jdk.vm.ci.hotspotvmconfig.HotSpotVMType;
  42 import jdk.internal.misc.Unsafe;
  43 
  44 //JaCoCo Exclude
  45 
  46 /**
  47  * Used to access native configuration details.
  48  *
  49  * All non-static, public fields in this class are so that they can be compiled as constants.
  50  */
  51 public class HotSpotVMConfig {
  52 
  53     /**
  54      * Gets the configuration associated with the singleton {@link HotSpotJVMCIRuntime}.
  55      */
  56     public static HotSpotVMConfig config() {
  57         return runtime().getConfig();
  58     }
  59 
  60     /**
  61      * Maximum allowed size of allocated area for a frame.
  62      */
  63     public final int maxFrameSize = 16 * 1024;
  64 
  65     public HotSpotVMConfig(CompilerToVM compilerToVm) {
  66         // Get raw pointer to the array that contains all gHotSpotVM values.
  67         final long gHotSpotVMData = compilerToVm.initializeConfiguration(this);
  68         assert gHotSpotVMData != 0;
  69 
  70         // Make FindBugs happy.
  71         jvmciHotSpotVMStructs = 0;
  72         jvmciHotSpotVMTypes = 0;
  73         jvmciHotSpotVMIntConstants = 0;
  74         jvmciHotSpotVMLongConstants = 0;
  75         jvmciHotSpotVMAddresses = 0;
  76 
  77         // Initialize the gHotSpotVM fields.
  78         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
  79             if (f.isAnnotationPresent(HotSpotVMData.class)) {
  80                 HotSpotVMData annotation = f.getAnnotation(HotSpotVMData.class);
  81                 final int index = annotation.index();
  82                 final long value = UNSAFE.getAddress(gHotSpotVMData + Unsafe.ADDRESS_SIZE * index);
  83                 try {
  84                     f.setLong(this, value);
  85                 } catch (IllegalAccessException e) {
  86                     throw new JVMCIError("index " + index, e);
  87                 }
  88             }
  89         }
  90 
  91         // Quick sanity check.
  92         assert jvmciHotSpotVMStructs != 0;
  93         assert jvmciHotSpotVMTypes != 0;
  94         assert jvmciHotSpotVMIntConstants != 0;
  95         assert jvmciHotSpotVMLongConstants != 0;
  96         assert jvmciHotSpotVMAddresses != 0;
  97 
  98         initialize();
  99 
 100         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift, logMinObjAlignment());
 101         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift, logKlassAlignment);
 102 
 103         assert check();
 104         assert HotSpotVMConfigVerifier.check();
 105     }
 106 
 107     @Override
 108     public String toString() {
 109         return getClass().getSimpleName();
 110     }
 111 
 112     /**
 113      * Initialize fields by reading their values from vmStructs.
 114      */
 115     private void initialize() {
 116         // Fill the VM fields hash map.
 117         HashMap&lt;String, VMFields.Field&gt; vmFields = new HashMap&lt;&gt;();
 118         for (VMFields.Field e : new VMFields(jvmciHotSpotVMStructs)) {
 119             vmFields.put(e.getName(), e);
 120         }
 121 
 122         // Fill the VM types hash map.
 123         HashMap&lt;String, VMTypes.Type&gt; vmTypes = new HashMap&lt;&gt;();
 124         for (VMTypes.Type e : new VMTypes(jvmciHotSpotVMTypes)) {
 125             vmTypes.put(e.getTypeName(), e);
 126         }
 127 
 128         // Fill the VM constants hash map.
 129         HashMap&lt;String, AbstractConstant&gt; vmConstants = new HashMap&lt;&gt;();
 130         for (AbstractConstant e : new VMIntConstants(jvmciHotSpotVMIntConstants)) {
 131             vmConstants.put(e.getName(), e);
 132         }
 133         for (AbstractConstant e : new VMLongConstants(jvmciHotSpotVMLongConstants)) {
 134             vmConstants.put(e.getName(), e);
 135         }
 136 
 137         // Fill the VM addresses hash map.
 138         HashMap&lt;String, VMAddresses.Address&gt; vmAddresses = new HashMap&lt;&gt;();
 139         for (VMAddresses.Address e : new VMAddresses(jvmciHotSpotVMAddresses)) {
 140             vmAddresses.put(e.getName(), e);
 141         }
 142 
 143         // Fill the flags hash map.
 144         HashMap&lt;String, Flags.Flag&gt; flags = new HashMap&lt;&gt;();
 145         for (Flags.Flag e : new Flags(vmFields, vmTypes)) {
 146             flags.put(e.getName(), e);
 147         }
 148 
 149         String osName = getHostOSName();
 150         String osArch = getHostArchitectureName();
 151 
 152         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
 153             if (f.isAnnotationPresent(HotSpotVMField.class)) {
 154                 HotSpotVMField annotation = f.getAnnotation(HotSpotVMField.class);
 155                 String name = annotation.name();
 156                 String type = annotation.type();
 157                 VMFields.Field entry = vmFields.get(name);
 158                 if (entry == null) {
 159                     if (!isRequired(osArch, annotation.archs())) {
 160                         continue;
 161                     }
 162                     throw new JVMCIError(f.getName() + ": expected VM field not found: " + name);
 163                 }
 164 
 165                 // Make sure the native type is still the type we expect.
 166                 if (!type.isEmpty()) {
 167                     if (!type.equals(entry.getTypeString())) {
 168                         throw new JVMCIError(f.getName() + ": compiler expects type " + type + " but VM field " + name + " is of type " + entry.getTypeString());
 169                     }
 170                 }
 171 
 172                 switch (annotation.get()) {
 173                     case OFFSET:
 174                         setField(f, entry.getOffset());
 175                         break;
 176                     case ADDRESS:
 177                         setField(f, entry.getAddress());
 178                         break;
 179                     case VALUE:
 180                         setField(f, entry.getValue());
 181                         break;
 182                     default:
 183                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
 184                 }
 185             } else if (f.isAnnotationPresent(HotSpotVMType.class)) {
 186                 HotSpotVMType annotation = f.getAnnotation(HotSpotVMType.class);
 187                 String name = annotation.name();
 188                 VMTypes.Type entry = vmTypes.get(name);
 189                 if (entry == null) {
 190                     throw new JVMCIError(f.getName() + ": expected VM type not found: " + name);
 191                 }
 192 
 193                 switch (annotation.get()) {
 194                     case SIZE:
 195                         setField(f, entry.getSize());
 196                         break;
 197                     default:
 198                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
 199                 }
 200             } else if (f.isAnnotationPresent(HotSpotVMConstant.class)) {
 201                 HotSpotVMConstant annotation = f.getAnnotation(HotSpotVMConstant.class);
 202                 String name = annotation.name();
 203                 AbstractConstant entry = vmConstants.get(name);
 204                 if (entry == null) {
 205                     if (!isRequired(osArch, annotation.archs())) {
 206                         continue;
 207                     }
 208                     throw new JVMCIError(f.getName() + ": expected VM constant not found: " + name);
 209                 }
 210                 setField(f, entry.getValue());
 211             } else if (f.isAnnotationPresent(HotSpotVMAddress.class)) {
 212                 HotSpotVMAddress annotation = f.getAnnotation(HotSpotVMAddress.class);
 213                 String name = annotation.name();
 214                 VMAddresses.Address entry = vmAddresses.get(name);
 215                 if (entry == null) {
 216                     if (!isRequired(osName, annotation.os())) {
 217                         continue;
 218                     }
 219                     throw new JVMCIError(f.getName() + ": expected VM address not found: " + name);
 220                 }
 221                 setField(f, entry.getValue());
 222             } else if (f.isAnnotationPresent(HotSpotVMFlag.class)) {
 223                 HotSpotVMFlag annotation = f.getAnnotation(HotSpotVMFlag.class);
 224                 String name = annotation.name();
 225                 Flags.Flag entry = flags.get(name);
 226                 if (entry == null) {
 227                     if (annotation.optional() || !isRequired(osArch, annotation.archs())) {
 228                         continue;
 229                     }
 230                     throw new JVMCIError(f.getName() + ": expected VM flag not found: " + name);
 231 
 232                 }
 233                 setField(f, entry.getValue());
 234             }
 235         }
 236     }
 237 
 238     private final CompressEncoding oopEncoding;
 239     private final CompressEncoding klassEncoding;
 240 
 241     public CompressEncoding getOopEncoding() {
 242         return oopEncoding;
 243     }
 244 
 245     public CompressEncoding getKlassEncoding() {
 246         return klassEncoding;
 247     }
 248 
 249     private void setField(Field field, Object value) {
 250         try {
 251             Class&lt;?&gt; fieldType = field.getType();
 252             if (fieldType == boolean.class) {
 253                 if (value instanceof String) {
 254                     field.setBoolean(this, Boolean.valueOf((String) value));
 255                 } else if (value instanceof Boolean) {
 256                     field.setBoolean(this, (boolean) value);
 257                 } else if (value instanceof Long) {
 258                     field.setBoolean(this, ((long) value) != 0);
 259                 } else {
 260                     throw new JVMCIError(value.getClass().getSimpleName());
 261                 }
 262             } else if (fieldType == byte.class) {
 263                 if (value instanceof Long) {
 264                     field.setByte(this, (byte) (long) value);
 265                 } else {
 266                     throw new JVMCIError(value.getClass().getSimpleName());
 267                 }
 268             } else if (fieldType == int.class) {
 269                 if (value instanceof Integer) {
 270                     field.setInt(this, (int) value);
 271                 } else if (value instanceof Long) {
 272                     field.setInt(this, (int) (long) value);
 273                 } else {
 274                     throw new JVMCIError(value.getClass().getSimpleName());
 275                 }
 276             } else if (fieldType == long.class) {
 277                 field.setLong(this, (long) value);
 278             } else {
 279                 throw new JVMCIError(field.toString());
 280             }
 281         } catch (IllegalAccessException e) {
 282             throw new JVMCIError("%s: %s", field, e);
 283         }
 284     }
 285 
 286     /**
 287      * Gets the host operating system name.
 288      */
 289     private static String getHostOSName() {
 290         String osName = System.getProperty("os.name");
 291         switch (osName) {
 292             case "Linux":
 293                 osName = "linux";
 294                 break;
 295             case "SunOS":
 296                 osName = "solaris";
 297                 break;
 298             case "Mac OS X":
 299                 osName = "bsd";
 300                 break;
 301             default:
 302                 // Of course Windows is different...
 303                 if (osName.startsWith("Windows")) {
 304                     osName = "windows";
 305                 } else {
 306                     throw new JVMCIError("Unexpected OS name: " + osName);
 307                 }
 308         }
 309         return osName;
 310     }
 311 
 312     /**
 313      * Gets the host architecture name for the purpose of finding the corresponding
 314      * {@linkplain HotSpotJVMCIBackendFactory backend}.
 315      */
 316     public String getHostArchitectureName() {
 317         String arch = System.getProperty("os.arch");
 318         switch (arch) {
 319             case "x86_64":
 320                 arch = "amd64";
 321                 break;
 322             case "sparcv9":
 323                 arch = "sparc";
 324                 break;
 325         }
 326         return arch;
 327     }
 328 
 329     /**
 330      * Determines if the current specification is included in a given set of specifications.
 331      *
 332      * @param current
 333      * @param specification specifies a set of specifications, e.g. architectures or operating
 334      *            systems. A zero length value implies all.
 335      */
 336     private static boolean isRequired(String current, String[] specification) {
 337         if (specification.length == 0) {
 338             return true;
 339         }
 340         for (String arch : specification) {
 341             if (arch.equals(current)) {
 342                 return true;
 343             }
 344         }
 345         return false;
 346     }
 347 
 348     /**
 349      * VMStructEntry (see {@code vmStructs.hpp}).
 350      */
 351     @HotSpotVMData(index = 0) @Stable private long jvmciHotSpotVMStructs;
 352     @HotSpotVMData(index = 1) @Stable private long jvmciHotSpotVMStructEntryTypeNameOffset;
 353     @HotSpotVMData(index = 2) @Stable private long jvmciHotSpotVMStructEntryFieldNameOffset;
 354     @HotSpotVMData(index = 3) @Stable private long jvmciHotSpotVMStructEntryTypeStringOffset;
 355     @HotSpotVMData(index = 4) @Stable private long jvmciHotSpotVMStructEntryIsStaticOffset;
 356     @HotSpotVMData(index = 5) @Stable private long jvmciHotSpotVMStructEntryOffsetOffset;
 357     @HotSpotVMData(index = 6) @Stable private long jvmciHotSpotVMStructEntryAddressOffset;
 358     @HotSpotVMData(index = 7) @Stable private long jvmciHotSpotVMStructEntryArrayStride;
 359 
 360     final class VMFields implements Iterable&lt;VMFields.Field&gt; {
 361 
 362         private final long address;
 363 
 364         VMFields(long address) {
 365             this.address = address;
 366         }
 367 
 368         public Iterator&lt;VMFields.Field&gt; iterator() {
 369             return new Iterator&lt;VMFields.Field&gt;() {
 370 
 371                 private int index = 0;
 372 
 373                 private Field current() {
 374                     return new Field(address + jvmciHotSpotVMStructEntryArrayStride * index);
 375                 }
 376 
 377                 /**
 378                  * The last entry is identified by a NULL fieldName.
 379                  */
 380                 public boolean hasNext() {
 381                     Field entry = current();
 382                     return entry.getFieldName() != null;
 383                 }
 384 
 385                 public Field next() {
 386                     Field entry = current();
 387                     index++;
 388                     return entry;
 389                 }
 390             };
 391         }
 392 
 393         final class Field {
 394 
 395             private final long entryAddress;
 396 
 397             Field(long address) {
 398                 this.entryAddress = address;
 399             }
 400 
 401             public String getTypeName() {
 402                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeNameOffset);
 403                 return readCString(UNSAFE, typeNameAddress);
 404             }
 405 
 406             public String getFieldName() {
 407                 long fieldNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryFieldNameOffset);
 408                 return readCString(UNSAFE, fieldNameAddress);
 409             }
 410 
 411             public String getTypeString() {
 412                 long typeStringAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeStringOffset);
 413                 return readCString(UNSAFE, typeStringAddress);
 414             }
 415 
 416             public boolean isStatic() {
 417                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMStructEntryIsStaticOffset) != 0;
 418             }
 419 
 420             public long getOffset() {
 421                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMStructEntryOffsetOffset);
 422             }
 423 
 424             public long getAddress() {
 425                 return UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryAddressOffset);
 426             }
 427 
 428             public String getName() {
 429                 String typeName = getTypeName();
 430                 String fieldName = getFieldName();
 431                 return typeName + "::" + fieldName;
 432             }
 433 
 434             public long getValue() {
 435                 String type = getTypeString();
 436                 switch (type) {
 437                     case "bool":
 438                         return UNSAFE.getByte(getAddress());
 439                     case "int":
 440                         return UNSAFE.getInt(getAddress());
 441                     case "uint64_t":
 442                         return UNSAFE.getLong(getAddress());
 443                     case "address":
 444                     case "intptr_t":
 445                     case "uintptr_t":
 446                     case "size_t":
 447                         return UNSAFE.getAddress(getAddress());
 448                     default:
 449                         // All foo* types are addresses.
 450                         if (type.endsWith("*")) {
 451                             return UNSAFE.getAddress(getAddress());
 452                         }
 453                         throw new JVMCIError(type);
 454                 }
 455             }
 456 
 457             @Override
 458             public String toString() {
 459                 return String.format("Field[typeName=%s, fieldName=%s, typeString=%s, isStatic=%b, offset=%d, address=0x%x]", getTypeName(), getFieldName(), getTypeString(), isStatic(), getOffset(),
 460                                 getAddress());
 461             }
 462         }
 463     }
 464 
 465     /**
 466      * VMTypeEntry (see vmStructs.hpp).
 467      */
 468     @HotSpotVMData(index = 8) @Stable private long jvmciHotSpotVMTypes;
 469     @HotSpotVMData(index = 9) @Stable private long jvmciHotSpotVMTypeEntryTypeNameOffset;
 470     @HotSpotVMData(index = 10) @Stable private long jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 471     @HotSpotVMData(index = 11) @Stable private long jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 472     @HotSpotVMData(index = 12) @Stable private long jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 473     @HotSpotVMData(index = 13) @Stable private long jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 474     @HotSpotVMData(index = 14) @Stable private long jvmciHotSpotVMTypeEntrySizeOffset;
 475     @HotSpotVMData(index = 15) @Stable private long jvmciHotSpotVMTypeEntryArrayStride;
 476 
 477     final class VMTypes implements Iterable&lt;VMTypes.Type&gt; {
 478 
 479         private final long address;
 480 
 481         VMTypes(long address) {
 482             this.address = address;
 483         }
 484 
 485         public Iterator&lt;VMTypes.Type&gt; iterator() {
 486             return new Iterator&lt;VMTypes.Type&gt;() {
 487 
 488                 private int index = 0;
 489 
 490                 private Type current() {
 491                     return new Type(address + jvmciHotSpotVMTypeEntryArrayStride * index);
 492                 }
 493 
 494                 /**
 495                  * The last entry is identified by a NULL type name.
 496                  */
 497                 public boolean hasNext() {
 498                     Type entry = current();
 499                     return entry.getTypeName() != null;
 500                 }
 501 
 502                 public Type next() {
 503                     Type entry = current();
 504                     index++;
 505                     return entry;
 506                 }
 507             };
 508         }
 509 
 510         final class Type {
 511 
 512             private final long entryAddress;
 513 
 514             Type(long address) {
 515                 this.entryAddress = address;
 516             }
 517 
 518             public String getTypeName() {
 519                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntryTypeNameOffset);
 520                 return readCString(UNSAFE, typeNameAddress);
 521             }
 522 
 523             public String getSuperclassName() {
 524                 long superclassNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntrySuperclassNameOffset);
 525                 return readCString(UNSAFE, superclassNameAddress);
 526             }
 527 
 528             public boolean isOopType() {
 529                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsOopTypeOffset) != 0;
 530             }
 531 
 532             public boolean isIntegerType() {
 533                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsIntegerTypeOffset) != 0;
 534             }
 535 
 536             public boolean isUnsigned() {
 537                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsUnsignedOffset) != 0;
 538             }
 539 
 540             public long getSize() {
 541                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMTypeEntrySizeOffset);
 542             }
 543 
 544             @Override
 545             public String toString() {
 546                 return String.format("Type[typeName=%s, superclassName=%s, isOopType=%b, isIntegerType=%b, isUnsigned=%b, size=%d]", getTypeName(), getSuperclassName(), isOopType(), isIntegerType(),
 547                                 isUnsigned(), getSize());
 548             }
 549         }
 550     }
 551 
 552     public abstract class AbstractConstant {
 553 
 554         protected final long address;
 555         protected final long nameOffset;
 556         protected final long valueOffset;
 557 
 558         AbstractConstant(long address, long nameOffset, long valueOffset) {
 559             this.address = address;
 560             this.nameOffset = nameOffset;
 561             this.valueOffset = valueOffset;
 562         }
 563 
 564         public String getName() {
 565             long nameAddress = UNSAFE.getAddress(address + nameOffset);
 566             return readCString(UNSAFE, nameAddress);
 567         }
 568 
 569         public abstract long getValue();
 570     }
 571 
 572     /**
 573      * VMIntConstantEntry (see vmStructs.hpp).
 574      */
 575     @HotSpotVMData(index = 16) @Stable private long jvmciHotSpotVMIntConstants;
 576     @HotSpotVMData(index = 17) @Stable private long jvmciHotSpotVMIntConstantEntryNameOffset;
 577     @HotSpotVMData(index = 18) @Stable private long jvmciHotSpotVMIntConstantEntryValueOffset;
 578     @HotSpotVMData(index = 19) @Stable private long jvmciHotSpotVMIntConstantEntryArrayStride;
 579 
 580     final class VMIntConstants implements Iterable&lt;VMIntConstants.Constant&gt; {
 581 
 582         private final long address;
 583 
 584         VMIntConstants(long address) {
 585             this.address = address;
 586         }
 587 
 588         public Iterator&lt;VMIntConstants.Constant&gt; iterator() {
 589             return new Iterator&lt;VMIntConstants.Constant&gt;() {
 590 
 591                 private int index = 0;
 592 
 593                 private Constant current() {
 594                     return new Constant(address + jvmciHotSpotVMIntConstantEntryArrayStride * index);
 595                 }
 596 
 597                 /**
 598                  * The last entry is identified by a NULL name.
 599                  */
 600                 public boolean hasNext() {
 601                     Constant entry = current();
 602                     return entry.getName() != null;
 603                 }
 604 
 605                 public Constant next() {
 606                     Constant entry = current();
 607                     index++;
 608                     return entry;
 609                 }
 610             };
 611         }
 612 
 613         final class Constant extends AbstractConstant {
 614 
 615             Constant(long address) {
 616                 super(address, jvmciHotSpotVMIntConstantEntryNameOffset, jvmciHotSpotVMIntConstantEntryValueOffset);
 617             }
 618 
 619             @Override
 620             public long getValue() {
 621                 return UNSAFE.getInt(address + valueOffset);
 622             }
 623 
 624             @Override
 625             public String toString() {
 626                 return String.format("IntConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 627             }
 628         }
 629     }
 630 
 631     /**
 632      * VMLongConstantEntry (see vmStructs.hpp).
 633      */
 634     @HotSpotVMData(index = 20) @Stable private long jvmciHotSpotVMLongConstants;
 635     @HotSpotVMData(index = 21) @Stable private long jvmciHotSpotVMLongConstantEntryNameOffset;
 636     @HotSpotVMData(index = 22) @Stable private long jvmciHotSpotVMLongConstantEntryValueOffset;
 637     @HotSpotVMData(index = 23) @Stable private long jvmciHotSpotVMLongConstantEntryArrayStride;
 638 
 639     final class VMLongConstants implements Iterable&lt;VMLongConstants.Constant&gt; {
 640 
 641         private final long address;
 642 
 643         VMLongConstants(long address) {
 644             this.address = address;
 645         }
 646 
 647         public Iterator&lt;VMLongConstants.Constant&gt; iterator() {
 648             return new Iterator&lt;VMLongConstants.Constant&gt;() {
 649 
 650                 private int index = 0;
 651 
 652                 private Constant currentEntry() {
 653                     return new Constant(address + jvmciHotSpotVMLongConstantEntryArrayStride * index);
 654                 }
 655 
 656                 /**
 657                  * The last entry is identified by a NULL name.
 658                  */
 659                 public boolean hasNext() {
 660                     Constant entry = currentEntry();
 661                     return entry.getName() != null;
 662                 }
 663 
 664                 public Constant next() {
 665                     Constant entry = currentEntry();
 666                     index++;
 667                     return entry;
 668                 }
 669             };
 670         }
 671 
 672         final class Constant extends AbstractConstant {
 673 
 674             Constant(long address) {
 675                 super(address, jvmciHotSpotVMLongConstantEntryNameOffset, jvmciHotSpotVMLongConstantEntryValueOffset);
 676             }
 677 
 678             @Override
 679             public long getValue() {
 680                 return UNSAFE.getLong(address + valueOffset);
 681             }
 682 
 683             @Override
 684             public String toString() {
 685                 return String.format("LongConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 686             }
 687         }
 688     }
 689 
 690     /**
 691      * VMAddressEntry (see vmStructs.hpp).
 692      */
 693     @HotSpotVMData(index = 24) @Stable private long jvmciHotSpotVMAddresses;
 694     @HotSpotVMData(index = 25) @Stable private long jvmciHotSpotVMAddressEntryNameOffset;
 695     @HotSpotVMData(index = 26) @Stable private long jvmciHotSpotVMAddressEntryValueOffset;
 696     @HotSpotVMData(index = 27) @Stable private long jvmciHotSpotVMAddressEntryArrayStride;
 697 
 698     final class VMAddresses implements Iterable&lt;VMAddresses.Address&gt; {
 699 
 700         private final long address;
 701 
 702         VMAddresses(long address) {
 703             this.address = address;
 704         }
 705 
 706         public Iterator&lt;VMAddresses.Address&gt; iterator() {
 707             return new Iterator&lt;VMAddresses.Address&gt;() {
 708 
 709                 private int index = 0;
 710 
 711                 private Address currentEntry() {
 712                     return new Address(address + jvmciHotSpotVMAddressEntryArrayStride * index);
 713                 }
 714 
 715                 /**
 716                  * The last entry is identified by a NULL name.
 717                  */
 718                 public boolean hasNext() {
 719                     Address entry = currentEntry();
 720                     return entry.getName() != null;
 721                 }
 722 
 723                 public Address next() {
 724                     Address entry = currentEntry();
 725                     index++;
 726                     return entry;
 727                 }
 728             };
 729         }
 730 
 731         final class Address extends AbstractConstant {
 732 
 733             Address(long address) {
 734                 super(address, jvmciHotSpotVMAddressEntryNameOffset, jvmciHotSpotVMAddressEntryValueOffset);
 735             }
 736 
 737             @Override
 738             public long getValue() {
 739                 return UNSAFE.getLong(address + valueOffset);
 740             }
 741 
 742             @Override
 743             public String toString() {
 744                 return String.format("Address[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 745             }
 746         }
 747     }
 748 
 749     final class Flags implements Iterable&lt;Flags.Flag&gt; {
 750 
 751         private final long address;
 752         private final long entrySize;
 753         private final long typeOffset;
 754         private final long nameOffset;
 755         private final long addrOffset;
 756 
 757         Flags(HashMap&lt;String, VMFields.Field&gt; vmStructs, HashMap&lt;String, VMTypes.Type&gt; vmTypes) {
 758             address = vmStructs.get("Flag::flags").getValue();
 759             entrySize = vmTypes.get("Flag").getSize();
 760             typeOffset = vmStructs.get("Flag::_type").getOffset();
 761             nameOffset = vmStructs.get("Flag::_name").getOffset();
 762             addrOffset = vmStructs.get("Flag::_addr").getOffset();
 763 
 764             assert vmTypes.get("bool").getSize() == Byte.BYTES;
 765             assert vmTypes.get("intx").getSize() == Long.BYTES;
 766             assert vmTypes.get("uintx").getSize() == Long.BYTES;
 767         }
 768 
 769         public Iterator&lt;Flags.Flag&gt; iterator() {
 770             return new Iterator&lt;Flags.Flag&gt;() {
 771 
 772                 private int index = 0;
 773 
 774                 private Flag current() {
 775                     return new Flag(address + entrySize * index);
 776                 }
 777 
 778                 /**
 779                  * The last entry is identified by a NULL name.
 780                  */
 781                 public boolean hasNext() {
 782                     Flag entry = current();
 783                     return entry.getName() != null;
 784                 }
 785 
 786                 public Flag next() {
 787                     Flag entry = current();
 788                     index++;
 789                     return entry;
 790                 }
 791             };
 792         }
 793 
 794         final class Flag {
 795 
 796             private final long entryAddress;
 797 
 798             Flag(long address) {
 799                 this.entryAddress = address;
 800             }
 801 
 802             public String getType() {
 803                 long typeAddress = UNSAFE.getAddress(entryAddress + typeOffset);
 804                 return readCString(UNSAFE, typeAddress);
 805             }
 806 
 807             public String getName() {
 808                 long nameAddress = UNSAFE.getAddress(entryAddress + nameOffset);
 809                 return readCString(UNSAFE, nameAddress);
 810             }
 811 
 812             public long getAddr() {
 813                 return UNSAFE.getAddress(entryAddress + addrOffset);
 814             }
 815 
 816             public Object getValue() {
 817                 switch (getType()) {
 818                     case "bool":
 819                         return Boolean.valueOf(UNSAFE.getByte(getAddr()) != 0);
 820                     case "intx":
 821                     case "uintx":
 822                     case "uint64_t":
 823                         return Long.valueOf(UNSAFE.getLong(getAddr()));
 824                     case "double":
 825                         return Double.valueOf(UNSAFE.getDouble(getAddr()));
 826                     case "ccstr":
 827                     case "ccstrlist":
 828                         return readCString(UNSAFE, getAddr());
 829                     default:
 830                         throw new JVMCIError(getType());
 831                 }
 832             }
 833 
 834             @Override
 835             public String toString() {
 836                 return String.format("Flag[type=%s, name=%s, value=%s]", getType(), getName(), getValue());
 837             }
 838         }
 839     }
 840 
 841     @HotSpotVMConstant(name = "ASSERT") @Stable public boolean cAssertions;
 842     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
 843     public final boolean linuxOs = System.getProperty("os.name", "").startsWith("Linux");
 844 
 845     @HotSpotVMFlag(name = "CodeEntryAlignment") @Stable public int codeEntryAlignment;
 846     @HotSpotVMFlag(name = "VerifyOops") @Stable public boolean verifyOops;
 847     @HotSpotVMFlag(name = "CITime") @Stable public boolean ciTime;
 848     @HotSpotVMFlag(name = "CITimeEach") @Stable public boolean ciTimeEach;
 849     @HotSpotVMFlag(name = "CompileTheWorldStartAt", optional = true) @Stable public int compileTheWorldStartAt;
 850     @HotSpotVMFlag(name = "CompileTheWorldStopAt", optional = true) @Stable public int compileTheWorldStopAt;
 851     @HotSpotVMFlag(name = "DontCompileHugeMethods") @Stable public boolean dontCompileHugeMethods;
 852     @HotSpotVMFlag(name = "HugeMethodLimit") @Stable public int hugeMethodLimit;
 853     @HotSpotVMFlag(name = "PrintInlining") @Stable public boolean printInlining;
 854     @HotSpotVMFlag(name = "Inline") @Stable public boolean inline;
 855     @HotSpotVMFlag(name = "JVMCIUseFastLocking") @Stable public boolean useFastLocking;
 856     @HotSpotVMFlag(name = "ForceUnreachable") @Stable public boolean forceUnreachable;
 857     @HotSpotVMFlag(name = "CodeCacheSegmentSize") @Stable public int codeSegmentSize;
 858     @HotSpotVMFlag(name = "FoldStableValues") @Stable public boolean foldStableValues;
 859 
 860     @HotSpotVMFlag(name = "UseTLAB") @Stable public boolean useTLAB;
 861     @HotSpotVMFlag(name = "UseBiasedLocking") @Stable public boolean useBiasedLocking;
 862     @HotSpotVMFlag(name = "UsePopCountInstruction") @Stable public boolean usePopCountInstruction;
 863     @HotSpotVMFlag(name = "UseCountLeadingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountLeadingZerosInstruction;
 864     @HotSpotVMFlag(name = "UseCountTrailingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountTrailingZerosInstruction;
 865     @HotSpotVMFlag(name = "UseAESIntrinsics") @Stable public boolean useAESIntrinsics;
 866     @HotSpotVMFlag(name = "UseCRC32Intrinsics") @Stable public boolean useCRC32Intrinsics;
 867     @HotSpotVMFlag(name = "UseG1GC") @Stable public boolean useG1GC;
 868     @HotSpotVMFlag(name = "UseConcMarkSweepGC") @Stable public boolean useCMSGC;
 869 
 870     @HotSpotVMFlag(name = "AllocatePrefetchStyle") @Stable public int allocatePrefetchStyle;
 871     @HotSpotVMFlag(name = "AllocatePrefetchInstr") @Stable public int allocatePrefetchInstr;
 872     @HotSpotVMFlag(name = "AllocatePrefetchLines") @Stable public int allocatePrefetchLines;
 873     @HotSpotVMFlag(name = "AllocateInstancePrefetchLines") @Stable public int allocateInstancePrefetchLines;
 874     @HotSpotVMFlag(name = "AllocatePrefetchStepSize") @Stable public int allocatePrefetchStepSize;
 875     @HotSpotVMFlag(name = "AllocatePrefetchDistance") @Stable public int allocatePrefetchDistance;
 876 
 877     @HotSpotVMFlag(name = "FlightRecorder", optional = true) @Stable public boolean flightRecorder;
 878 
 879     @HotSpotVMField(name = "CompilerToVM::Data::Universe_collectedHeap", type = "CollectedHeap*", get = HotSpotVMField.Type.VALUE) @Stable private long universeCollectedHeap;
 880     @HotSpotVMField(name = "CollectedHeap::_total_collections", type = "unsigned int", get = HotSpotVMField.Type.OFFSET) @Stable private int collectedHeapTotalCollectionsOffset;
 881 
 882     public long gcTotalCollectionsAddress() {
 883         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
 884     }
 885 
 886     @HotSpotVMFlag(name = "ReduceInitialCardMarks") @Stable public boolean useDeferredInitBarriers;
 887 
 888     // Compressed Oops related values.
 889     @HotSpotVMFlag(name = "UseCompressedOops") @Stable public boolean useCompressedOops;
 890     @HotSpotVMFlag(name = "UseCompressedClassPointers") @Stable public boolean useCompressedClassPointers;
 891 
 892     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowOopBase;
 893     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowOopShift;
 894     @HotSpotVMFlag(name = "ObjectAlignmentInBytes") @Stable public int objectAlignment;
 895 
 896     public final int minObjAlignment() {
 897         return objectAlignment / heapWordSize;
 898     }
 899 
 900     public final int logMinObjAlignment() {
 901         return (int) (Math.log(objectAlignment) / Math.log(2));
 902     }
 903 
 904     @HotSpotVMType(name = "narrowKlass", get = HotSpotVMType.Type.SIZE) @Stable public int narrowKlassSize;
 905     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowKlassBase;
 906     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowKlassShift;
 907     @HotSpotVMConstant(name = "LogKlassAlignmentInBytes") @Stable public int logKlassAlignment;
 908 
 909     // CPU capabilities
 910     @HotSpotVMFlag(name = "UseSSE") @Stable public int useSSE;
 911     @HotSpotVMFlag(name = "UseAVX", archs = {"amd64"}) @Stable public int useAVX;
 912 
 913     @HotSpotVMField(name = "Abstract_VM_Version::_features", type = "uint64_t", get = HotSpotVMField.Type.VALUE) @Stable public long vmVersionFeatures;
 914 
 915     // AMD64 specific values
 916     @HotSpotVMConstant(name = "VM_Version::CPU_CX8", archs = {"amd64"}) @Stable public long amd64CX8;
 917     @HotSpotVMConstant(name = "VM_Version::CPU_CMOV", archs = {"amd64"}) @Stable public long amd64CMOV;
 918     @HotSpotVMConstant(name = "VM_Version::CPU_FXSR", archs = {"amd64"}) @Stable public long amd64FXSR;
 919     @HotSpotVMConstant(name = "VM_Version::CPU_HT", archs = {"amd64"}) @Stable public long amd64HT;
 920     @HotSpotVMConstant(name = "VM_Version::CPU_MMX", archs = {"amd64"}) @Stable public long amd64MMX;
 921     @HotSpotVMConstant(name = "VM_Version::CPU_3DNOW_PREFETCH", archs = {"amd64"}) @Stable public long amd643DNOWPREFETCH;
 922     @HotSpotVMConstant(name = "VM_Version::CPU_SSE", archs = {"amd64"}) @Stable public long amd64SSE;
 923     @HotSpotVMConstant(name = "VM_Version::CPU_SSE2", archs = {"amd64"}) @Stable public long amd64SSE2;
 924     @HotSpotVMConstant(name = "VM_Version::CPU_SSE3", archs = {"amd64"}) @Stable public long amd64SSE3;
 925     @HotSpotVMConstant(name = "VM_Version::CPU_SSSE3", archs = {"amd64"}) @Stable public long amd64SSSE3;
 926     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4A", archs = {"amd64"}) @Stable public long amd64SSE4A;
 927     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_1", archs = {"amd64"}) @Stable public long amd64SSE41;
 928     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_2", archs = {"amd64"}) @Stable public long amd64SSE42;
 929     @HotSpotVMConstant(name = "VM_Version::CPU_POPCNT", archs = {"amd64"}) @Stable public long amd64POPCNT;
 930     @HotSpotVMConstant(name = "VM_Version::CPU_LZCNT", archs = {"amd64"}) @Stable public long amd64LZCNT;
 931     @HotSpotVMConstant(name = "VM_Version::CPU_TSC", archs = {"amd64"}) @Stable public long amd64TSC;
 932     @HotSpotVMConstant(name = "VM_Version::CPU_TSCINV", archs = {"amd64"}) @Stable public long amd64TSCINV;
 933     @HotSpotVMConstant(name = "VM_Version::CPU_AVX", archs = {"amd64"}) @Stable public long amd64AVX;
 934     @HotSpotVMConstant(name = "VM_Version::CPU_AVX2", archs = {"amd64"}) @Stable public long amd64AVX2;
 935     @HotSpotVMConstant(name = "VM_Version::CPU_AES", archs = {"amd64"}) @Stable public long amd64AES;
 936     @HotSpotVMConstant(name = "VM_Version::CPU_ERMS", archs = {"amd64"}) @Stable public long amd64ERMS;
 937     @HotSpotVMConstant(name = "VM_Version::CPU_CLMUL", archs = {"amd64"}) @Stable public long amd64CLMUL;
 938     @HotSpotVMConstant(name = "VM_Version::CPU_BMI1", archs = {"amd64"}) @Stable public long amd64BMI1;
 939     @HotSpotVMConstant(name = "VM_Version::CPU_BMI2", archs = {"amd64"}) @Stable public long amd64BMI2;
 940     @HotSpotVMConstant(name = "VM_Version::CPU_RTM", archs = {"amd64"}) @Stable public long amd64RTM;
 941     @HotSpotVMConstant(name = "VM_Version::CPU_ADX", archs = {"amd64"}) @Stable public long amd64ADX;
 942     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512F", archs = {"amd64"}) @Stable public long amd64AVX512F;
 943     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512DQ", archs = {"amd64"}) @Stable public long amd64AVX512DQ;
 944     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512PF", archs = {"amd64"}) @Stable public long amd64AVX512PF;
 945     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512ER", archs = {"amd64"}) @Stable public long amd64AVX512ER;
 946     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512CD", archs = {"amd64"}) @Stable public long amd64AVX512CD;
 947     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512BW", archs = {"amd64"}) @Stable public long amd64AVX512BW;
 948     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512VL", archs = {"amd64"}) @Stable public long amd64AVX512VL;
 949     @HotSpotVMConstant(name = "VM_Version::CPU_SHA", archs = {"amd64"}) @Stable public long amd64SHA;
 950 
 951     // SPARC specific values
 952     @HotSpotVMConstant(name = "VM_Version::vis3_instructions_m", archs = {"sparc"}) @Stable public int sparcVis3Instructions;
 953     @HotSpotVMConstant(name = "VM_Version::vis2_instructions_m", archs = {"sparc"}) @Stable public int sparcVis2Instructions;
 954     @HotSpotVMConstant(name = "VM_Version::vis1_instructions_m", archs = {"sparc"}) @Stable public int sparcVis1Instructions;
 955     @HotSpotVMConstant(name = "VM_Version::cbcond_instructions_m", archs = {"sparc"}) @Stable public int sparcCbcondInstructions;
 956     @HotSpotVMConstant(name = "VM_Version::v8_instructions_m", archs = {"sparc"}) @Stable public int sparcV8Instructions;
 957     @HotSpotVMConstant(name = "VM_Version::hardware_mul32_m", archs = {"sparc"}) @Stable public int sparcHardwareMul32;
 958     @HotSpotVMConstant(name = "VM_Version::hardware_div32_m", archs = {"sparc"}) @Stable public int sparcHardwareDiv32;
 959     @HotSpotVMConstant(name = "VM_Version::hardware_fsmuld_m", archs = {"sparc"}) @Stable public int sparcHardwareFsmuld;
 960     @HotSpotVMConstant(name = "VM_Version::hardware_popc_m", archs = {"sparc"}) @Stable public int sparcHardwarePopc;
 961     @HotSpotVMConstant(name = "VM_Version::v9_instructions_m", archs = {"sparc"}) @Stable public int sparcV9Instructions;
 962     @HotSpotVMConstant(name = "VM_Version::sun4v_m", archs = {"sparc"}) @Stable public int sparcSun4v;
 963     @HotSpotVMConstant(name = "VM_Version::blk_init_instructions_m", archs = {"sparc"}) @Stable public int sparcBlkInitInstructions;
 964     @HotSpotVMConstant(name = "VM_Version::fmaf_instructions_m", archs = {"sparc"}) @Stable public int sparcFmafInstructions;
 965     @HotSpotVMConstant(name = "VM_Version::fmau_instructions_m", archs = {"sparc"}) @Stable public int sparcFmauInstructions;
 966     @HotSpotVMConstant(name = "VM_Version::sparc64_family_m", archs = {"sparc"}) @Stable public int sparcSparc64Family;
 967     @HotSpotVMConstant(name = "VM_Version::M_family_m", archs = {"sparc"}) @Stable public int sparcMFamily;
 968     @HotSpotVMConstant(name = "VM_Version::T_family_m", archs = {"sparc"}) @Stable public int sparcTFamily;
 969     @HotSpotVMConstant(name = "VM_Version::T1_model_m", archs = {"sparc"}) @Stable public int sparcT1Model;
 970     @HotSpotVMConstant(name = "VM_Version::sparc5_instructions_m", archs = {"sparc"}) @Stable public int sparcSparc5Instructions;
 971     @HotSpotVMConstant(name = "VM_Version::aes_instructions_m", archs = {"sparc"}) @Stable public int sparcAesInstructions;
 972     @HotSpotVMConstant(name = "VM_Version::sha1_instruction_m", archs = {"sparc"}) @Stable public int sparcSha1Instruction;
 973     @HotSpotVMConstant(name = "VM_Version::sha256_instruction_m", archs = {"sparc"}) @Stable public int sparcSha256Instruction;
 974     @HotSpotVMConstant(name = "VM_Version::sha512_instruction_m", archs = {"sparc"}) @Stable public int sparcSha512Instruction;
 975 
 976     @HotSpotVMFlag(name = "UseBlockZeroing", archs = {"sparc"}) @Stable public boolean useBlockZeroing;
 977     @HotSpotVMFlag(name = "BlockZeroingLowLimit", archs = {"sparc"}) @Stable public int blockZeroingLowLimit;
 978 
 979     @HotSpotVMFlag(name = "StackShadowPages") @Stable public int stackShadowPages;
 980     @HotSpotVMFlag(name = "StackReservedPages") @Stable public int stackReservedPages;
 981     @HotSpotVMFlag(name = "UseStackBanging") @Stable public boolean useStackBanging;
 982     @HotSpotVMConstant(name = "STACK_BIAS") @Stable public int stackBias;
 983     @HotSpotVMField(name = "CompilerToVM::Data::vm_page_size", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int vmPageSize;
 984 
 985     // offsets, ...
 986     @HotSpotVMField(name = "oopDesc::_mark", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int markOffset;
 987     @HotSpotVMField(name = "oopDesc::_metadata._klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int hubOffset;
 988 
 989     @HotSpotVMField(name = "Klass::_prototype_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int prototypeMarkWordOffset;
 990     @HotSpotVMField(name = "Klass::_subklass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int subklassOffset;
 991     @HotSpotVMField(name = "Klass::_next_sibling", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int nextSiblingOffset;
 992     @HotSpotVMField(name = "Klass::_super_check_offset", type = "juint", get = HotSpotVMField.Type.OFFSET) @Stable public int superCheckOffsetOffset;
 993     @HotSpotVMField(name = "Klass::_secondary_super_cache", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySuperCacheOffset;
 994     @HotSpotVMField(name = "Klass::_secondary_supers", type = "Array&lt;Klass*&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySupersOffset;
 995 
 996     /**
 997      * The offset of the _java_mirror field (of type {@link Class}) in a Klass.
 998      */
 999     @HotSpotVMField(name = "Klass::_java_mirror", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int classMirrorOffset;
1000 
1001     @HotSpotVMField(name = "Klass::_super", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int klassSuperKlassOffset;
1002     @HotSpotVMField(name = "Klass::_modifier_flags", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassModifierFlagsOffset;
1003     @HotSpotVMField(name = "Klass::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int klassAccessFlagsOffset;
1004     @HotSpotVMField(name = "Klass::_layout_helper", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassLayoutHelperOffset;
1005     @HotSpotVMField(name = "Klass::_name", type = "Symbol*", get = HotSpotVMField.Type.OFFSET) @Stable public int klassNameOffset;
1006 
1007     @HotSpotVMConstant(name = "Klass::_lh_neutral_value") @Stable public int klassLayoutHelperNeutralValue;
1008     @HotSpotVMConstant(name = "Klass::_lh_instance_slow_path_bit") @Stable public int klassLayoutHelperInstanceSlowPathBit;
1009     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_shift") @Stable public int layoutHelperLog2ElementSizeShift;
1010     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_mask") @Stable public int layoutHelperLog2ElementSizeMask;
1011     @HotSpotVMConstant(name = "Klass::_lh_element_type_shift") @Stable public int layoutHelperElementTypeShift;
1012     @HotSpotVMConstant(name = "Klass::_lh_element_type_mask") @Stable public int layoutHelperElementTypeMask;
1013     @HotSpotVMConstant(name = "Klass::_lh_header_size_shift") @Stable public int layoutHelperHeaderSizeShift;
1014     @HotSpotVMConstant(name = "Klass::_lh_header_size_mask") @Stable public int layoutHelperHeaderSizeMask;
1015     @HotSpotVMConstant(name = "Klass::_lh_array_tag_shift") @Stable public int layoutHelperArrayTagShift;
1016     @HotSpotVMConstant(name = "Klass::_lh_array_tag_type_value") @Stable public int layoutHelperArrayTagTypeValue;
1017     @HotSpotVMConstant(name = "Klass::_lh_array_tag_obj_value") @Stable public int layoutHelperArrayTagObjectValue;
1018 
1019     /**
1020      * This filters out the bit that differentiates a type array from an object array.
1021      */
1022     public int layoutHelperElementTypePrimitiveInPlace() {
1023         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
1024     }
1025 
1026     /**
1027      * Bit pattern in the klass layout helper that can be used to identify arrays.
1028      */
1029     public final int arrayKlassLayoutHelperIdentifier = 0x80000000;
1030 
1031     @HotSpotVMType(name = "vtableEntry", get = HotSpotVMType.Type.SIZE) @Stable public int vtableEntrySize;
1032     @HotSpotVMField(name = "vtableEntry::_method", type = "Method*", get = HotSpotVMField.Type.OFFSET) @Stable public int vtableEntryMethodOffset;
1033 
1034     @HotSpotVMType(name = "InstanceKlass", get = HotSpotVMType.Type.SIZE) @Stable public int instanceKlassSize;
1035     @HotSpotVMField(name = "InstanceKlass::_source_file_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassSourceFileNameIndexOffset;
1036     @HotSpotVMField(name = "InstanceKlass::_init_state", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassInitStateOffset;
1037     @HotSpotVMField(name = "InstanceKlass::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassConstantsOffset;
1038     @HotSpotVMField(name = "InstanceKlass::_fields", type = "Array&lt;u2&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassFieldsOffset;
1039     @HotSpotVMField(name = "CompilerToVM::Data::Klass_vtable_start_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassVtableStartOffset;
1040     @HotSpotVMField(name = "CompilerToVM::Data::Klass_vtable_length_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassVtableLengthOffset;
1041 
1042     @HotSpotVMConstant(name = "InstanceKlass::linked") @Stable public int instanceKlassStateLinked;
1043     @HotSpotVMConstant(name = "InstanceKlass::fully_initialized") @Stable public int instanceKlassStateFullyInitialized;
1044 
1045     @HotSpotVMType(name = "arrayOopDesc", get = HotSpotVMType.Type.SIZE) @Stable public int arrayOopDescSize;
1046 
1047     /**
1048      * The offset of the array length word in an array object's header.
1049      *
1050      * See {@code arrayOopDesc::length_offset_in_bytes()}.
1051      */
1052     public final int arrayOopDescLengthOffset() {
1053         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
1054     }
1055 
1056     @HotSpotVMField(name = "Array&lt;int&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1LengthOffset;
1057     @HotSpotVMField(name = "Array&lt;u1&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1DataOffset;
1058     @HotSpotVMField(name = "Array&lt;u2&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU2DataOffset;
1059     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayLengthOffset;
1060     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_data[0]", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayBaseOffset;
1061 
1062     @HotSpotVMField(name = "ObjArrayKlass::_element_klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayClassElementOffset;
1063 
1064     @HotSpotVMConstant(name = "FieldInfo::access_flags_offset") @Stable public int fieldInfoAccessFlagsOffset;
1065     @HotSpotVMConstant(name = "FieldInfo::name_index_offset") @Stable public int fieldInfoNameIndexOffset;
1066     @HotSpotVMConstant(name = "FieldInfo::signature_index_offset") @Stable public int fieldInfoSignatureIndexOffset;
1067     @HotSpotVMConstant(name = "FieldInfo::initval_index_offset") @Stable public int fieldInfoInitvalIndexOffset;
1068     @HotSpotVMConstant(name = "FieldInfo::low_packed_offset") @Stable public int fieldInfoLowPackedOffset;
1069     @HotSpotVMConstant(name = "FieldInfo::high_packed_offset") @Stable public int fieldInfoHighPackedOffset;
1070     @HotSpotVMConstant(name = "FieldInfo::field_slots") @Stable public int fieldInfoFieldSlots;
1071 
1072     @HotSpotVMConstant(name = "FIELDINFO_TAG_SIZE") @Stable public int fieldInfoTagSize;
1073 
1074     @HotSpotVMConstant(name = "JVM_ACC_MONITOR_MATCH") @Stable public int jvmAccMonitorMatch;
1075     @HotSpotVMConstant(name = "JVM_ACC_HAS_MONITOR_BYTECODES") @Stable public int jvmAccHasMonitorBytecodes;
1076     @HotSpotVMConstant(name = "JVM_ACC_HAS_FINALIZER") @Stable public int jvmAccHasFinalizer;
1077     @HotSpotVMConstant(name = "JVM_ACC_FIELD_INTERNAL") @Stable public int jvmAccFieldInternal;
1078     @HotSpotVMConstant(name = "JVM_ACC_FIELD_STABLE") @Stable public int jvmAccFieldStable;
1079     @HotSpotVMConstant(name = "JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE") @Stable public int jvmAccFieldHasGenericSignature;
1080     @HotSpotVMConstant(name = "JVM_ACC_WRITTEN_FLAGS") @Stable public int jvmAccWrittenFlags;
1081     @HotSpotVMConstant(name = "JVM_ACC_IS_CLONEABLE_FAST") @Stable public int jvmAccIsCloneableFast;
1082 
1083     // Modifier.SYNTHETIC is not public so we get it via vmStructs.
1084     @HotSpotVMConstant(name = "JVM_ACC_SYNTHETIC") @Stable public int jvmAccSynthetic;
1085 
1086     /**
1087      * @see HotSpotResolvedObjectTypeImpl#createField
1088      */
1089     @HotSpotVMConstant(name = "JVM_RECOGNIZED_FIELD_MODIFIERS") @Stable public int recognizedFieldModifiers;
1090 
1091     @HotSpotVMField(name = "Thread::_tlab", type = "ThreadLocalAllocBuffer", get = HotSpotVMField.Type.OFFSET) @Stable public int threadTlabOffset;
1092 
1093     @HotSpotVMField(name = "JavaThread::_anchor", type = "JavaFrameAnchor", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadAnchorOffset;
1094     @HotSpotVMField(name = "JavaThread::_threadObj", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectOffset;
1095     @HotSpotVMField(name = "JavaThread::_osthread", type = "OSThread*", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadOffset;
1096     @HotSpotVMField(name = "JavaThread::_dirty_card_queue", type = "DirtyCardQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadDirtyCardQueueOffset;
1097     @HotSpotVMField(name = "JavaThread::_is_method_handle_return", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int threadIsMethodHandleReturnOffset;
1098     @HotSpotVMField(name = "JavaThread::_satb_mark_queue", type = "SATBMarkQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadSatbMarkQueueOffset;
1099     @HotSpotVMField(name = "JavaThread::_vm_result", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectResultOffset;
1100     @HotSpotVMField(name = "JavaThread::_jvmci_counters", type = "jlong*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciCountersThreadOffset;
1101     @HotSpotVMField(name = "JavaThread::_reserved_stack_activation", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadReservedStackActivationOffset;
1102 
1103     /**
1104      * An invalid value for {@link #rtldDefault}.
1105      */
1106     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
1107 
1108     /**
1109      * Address of the library lookup routine. The C signature of this routine is:
1110      *
1111      * &lt;pre&gt;
1112      *     void* (const char *filename, char *ebuf, int ebuflen)
1113      * &lt;/pre&gt;
1114      */
1115     @HotSpotVMAddress(name = "os::dll_load") @Stable public long dllLoad;
1116 
1117     /**
1118      * Address of the library lookup routine. The C signature of this routine is:
1119      *
1120      * &lt;pre&gt;
1121      *     void* (void* handle, const char* name)
1122      * &lt;/pre&gt;
1123      */
1124     @HotSpotVMAddress(name = "os::dll_lookup") @Stable public long dllLookup;
1125 
1126     /**
1127      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
1128      * return the first occurrence of the desired symbol using the default library search order. If
1129      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
1130      * the current platform.
1131      */
1132     @HotSpotVMAddress(name = "RTLD_DEFAULT", os = {"bsd", "linux"}) @Stable public long rtldDefault = INVALID_RTLD_DEFAULT_HANDLE;
1133 
1134     /**
1135      * This field is used to pass exception objects into and out of the runtime system during
1136      * exception handling for compiled code.
1137      */
1138     @HotSpotVMField(name = "JavaThread::_exception_oop", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionOopOffset;
1139     @HotSpotVMField(name = "JavaThread::_exception_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionPcOffset;
1140     @HotSpotVMField(name = "ThreadShadow::_pending_exception", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingExceptionOffset;
1141 
1142     @HotSpotVMField(name = "JavaThread::_pending_deoptimization", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingDeoptimizationOffset;
1143     @HotSpotVMField(name = "JavaThread::_pending_failed_speculation", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingFailedSpeculationOffset;
1144     @HotSpotVMField(name = "JavaThread::_pending_transfer_to_interpreter", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingTransferToInterpreterOffset;
1145 
1146     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_sp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaSpOffset;
1147     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaPcOffset;
1148     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_fp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET, archs = {"aarch64, amd64"}) @Stable private int javaFrameAnchorLastJavaFpOffset;
1149     @HotSpotVMField(name = "JavaFrameAnchor::_flags", type = "int", get = HotSpotVMField.Type.OFFSET, archs = {"sparc"}) @Stable private int javaFrameAnchorFlagsOffset;
1150 
1151     public int threadLastJavaSpOffset() {
1152         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
1153     }
1154 
1155     public int threadLastJavaPcOffset() {
1156         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
1157     }
1158 
1159     public int threadLastJavaFpOffset() {
1160         assert getHostArchitectureName().equals("aarch64") || getHostArchitectureName().equals("amd64");
1161         return javaThreadAnchorOffset + javaFrameAnchorLastJavaFpOffset;
1162     }
1163 
1164     /**
1165      * This value is only valid on SPARC.
1166      */
1167     public int threadJavaFrameAnchorFlagsOffset() {
1168         // TODO add an assert for SPARC
1169         return javaThreadAnchorOffset + javaFrameAnchorFlagsOffset;
1170     }
1171 
1172     // These are only valid on AMD64.
1173     @HotSpotVMConstant(name = "frame::arg_reg_save_area_bytes", archs = {"amd64"}) @Stable public int runtimeCallStackSize;
1174     @HotSpotVMConstant(name = "frame::interpreter_frame_sender_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameSenderSpOffset;
1175     @HotSpotVMConstant(name = "frame::interpreter_frame_last_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameLastSpOffset;
1176 
1177     @HotSpotVMConstant(name = "dirtyCardQueueBufferOffset") @Stable private int dirtyCardQueueBufferOffset;
1178     @HotSpotVMConstant(name = "dirtyCardQueueIndexOffset") @Stable private int dirtyCardQueueIndexOffset;
1179 
1180     @HotSpotVMConstant(name = "satbMarkQueueBufferOffset") @Stable private int satbMarkQueueBufferOffset;
1181     @HotSpotVMConstant(name = "satbMarkQueueIndexOffset") @Stable private int satbMarkQueueIndexOffset;
1182     @HotSpotVMConstant(name = "satbMarkQueueActiveOffset") @Stable private int satbMarkQueueActiveOffset;
1183 
1184     @HotSpotVMField(name = "OSThread::_interrupted", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadInterruptedOffset;
1185 
1186     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public long markOopDescHashShift;
1187 
1188     @HotSpotVMConstant(name = "markOopDesc::biased_lock_mask_in_place") @Stable public int biasedLockMaskInPlace;
1189     @HotSpotVMConstant(name = "markOopDesc::age_mask_in_place") @Stable public int ageMaskInPlace;
1190     @HotSpotVMConstant(name = "markOopDesc::epoch_mask_in_place") @Stable public int epochMaskInPlace;
1191     @HotSpotVMConstant(name = "markOopDesc::hash_mask") @Stable public long markOopDescHashMask;
1192     @HotSpotVMConstant(name = "markOopDesc::hash_mask_in_place") @Stable public long markOopDescHashMaskInPlace;
1193 
1194     @HotSpotVMConstant(name = "markOopDesc::unlocked_value") @Stable public int unlockedMask;
1195     @HotSpotVMConstant(name = "markOopDesc::biased_lock_pattern") @Stable public int biasedLockPattern;
1196 
1197     @HotSpotVMConstant(name = "markOopDesc::no_hash_in_place") @Stable public int markWordNoHashInPlace;
1198     @HotSpotVMConstant(name = "markOopDesc::no_lock_in_place") @Stable public int markWordNoLockInPlace;
1199 
1200     /**
1201      * See {@code markOopDesc::prototype()}.
1202      */
1203     public long arrayPrototypeMarkWord() {
1204         return markWordNoHashInPlace | markWordNoLockInPlace;
1205     }
1206 
1207     /**
1208      * See {@code markOopDesc::copy_set_hash()}.
1209      */
1210     public long tlabIntArrayMarkWord() {
1211         long tmp = arrayPrototypeMarkWord() &amp; (~markOopDescHashMaskInPlace);
1212         tmp |= ((0x2 &amp; markOopDescHashMask) &lt;&lt; markOopDescHashShift);
1213         return tmp;
1214     }
1215 
1216     /**
1217      * Mark word right shift to get identity hash code.
1218      */
1219     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public int identityHashCodeShift;
1220 
1221     /**
1222      * Identity hash code value when uninitialized.
1223      */
1224     @HotSpotVMConstant(name = "markOopDesc::no_hash") @Stable public int uninitializedIdentityHashCodeValue;
1225 
1226     @HotSpotVMField(name = "Method::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int methodAccessFlagsOffset;
1227     @HotSpotVMField(name = "Method::_constMethod", type = "ConstMethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodConstMethodOffset;
1228     @HotSpotVMField(name = "Method::_intrinsic_id", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodIntrinsicIdOffset;
1229     @HotSpotVMField(name = "Method::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodFlagsOffset;
1230     @HotSpotVMField(name = "Method::_vtable_index", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodVtableIndexOffset;
1231 
1232     @HotSpotVMField(name = "Method::_method_counters", type = "MethodCounters*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCountersOffset;
1233     @HotSpotVMField(name = "Method::_method_data", type = "MethodData*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOffset;
1234     @HotSpotVMField(name = "Method::_from_compiled_entry", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCompiledEntryOffset;
1235     @HotSpotVMField(name = "Method::_code", type = "CompiledMethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCodeOffset;
1236 
1237     @HotSpotVMConstant(name = "Method::_jfr_towrite") @Stable public int methodFlagsJfrTowrite;
1238     @HotSpotVMConstant(name = "Method::_caller_sensitive") @Stable public int methodFlagsCallerSensitive;
1239     @HotSpotVMConstant(name = "Method::_force_inline") @Stable public int methodFlagsForceInline;
1240     @HotSpotVMConstant(name = "Method::_dont_inline") @Stable public int methodFlagsDontInline;
1241     @HotSpotVMConstant(name = "Method::_hidden") @Stable public int methodFlagsHidden;
1242     @HotSpotVMConstant(name = "Method::_reserved_stack_access") @Stable public int methodFlagsReservedStackAccess;
1243     @HotSpotVMConstant(name = "Method::nonvirtual_vtable_index") @Stable public int nonvirtualVtableIndex;
1244     @HotSpotVMConstant(name = "Method::invalid_vtable_index") @Stable public int invalidVtableIndex;
1245 
1246     @HotSpotVMField(name = "MethodCounters::_invocation_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int invocationCounterOffset;
1247     @HotSpotVMField(name = "MethodCounters::_backedge_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int backedgeCounterOffset;
1248     @HotSpotVMConstant(name = "InvocationCounter::count_increment") @Stable public int invocationCounterIncrement;
1249     @HotSpotVMConstant(name = "InvocationCounter::count_shift") @Stable public int invocationCounterShift;
1250 
1251     @HotSpotVMField(name = "MethodData::_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataSize;
1252     @HotSpotVMField(name = "MethodData::_data_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataDataSize;
1253     @HotSpotVMField(name = "MethodData::_data[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopDataOffset;
1254     @HotSpotVMField(name = "MethodData::_trap_hist._array[0]", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopTrapHistoryOffset;
1255     @HotSpotVMField(name = "MethodData::_jvmci_ir_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataIRSizeOffset;
1256 
1257     @HotSpotVMField(name = "nmethod::_verified_entry_point", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodEntryOffset;
1258     @HotSpotVMField(name = "nmethod::_comp_level", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodCompLevelOffset;
1259 
1260     @HotSpotVMConstant(name = "CompLevel_none") @Stable public int compilationLevelNone;
1261     @HotSpotVMConstant(name = "CompLevel_simple") @Stable public int compilationLevelSimple;
1262     @HotSpotVMConstant(name = "CompLevel_limited_profile") @Stable public int compilationLevelLimitedProfile;
1263     @HotSpotVMConstant(name = "CompLevel_full_profile") @Stable public int compilationLevelFullProfile;
1264     @HotSpotVMConstant(name = "CompLevel_full_optimization") @Stable public int compilationLevelFullOptimization;
1265 
1266     @HotSpotVMConstant(name = "JVMCIRuntime::none") @Stable public int compLevelAdjustmentNone;
1267     @HotSpotVMConstant(name = "JVMCIRuntime::by_holder") @Stable public int compLevelAdjustmentByHolder;
1268     @HotSpotVMConstant(name = "JVMCIRuntime::by_full_signature") @Stable public int compLevelAdjustmentByFullSignature;
1269 
1270     @HotSpotVMConstant(name = "InvocationEntryBci") @Stable public int invocationEntryBci;
1271 
1272     @HotSpotVMField(name = "JVMCIEnv::_task", type = "CompileTask*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvTaskOffset;
1273     @HotSpotVMField(name = "JVMCIEnv::_jvmti_can_hotswap_or_post_breakpoint", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvJvmtiCanHotswapOrPostBreakpointOffset;
1274     @HotSpotVMField(name = "CompileTask::_num_inlined_bytecodes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int compileTaskNumInlinedBytecodesOffset;
1275 
1276     @HotSpotVMField(name = "CompilerToVM::Data::Method_extra_stack_entries", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int extraStackEntries;
1277 
1278     @HotSpotVMField(name = "ConstMethod::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodConstantsOffset;
1279     @HotSpotVMField(name = "ConstMethod::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodFlagsOffset;
1280     @HotSpotVMField(name = "ConstMethod::_code_size", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodCodeSizeOffset;
1281     @HotSpotVMField(name = "ConstMethod::_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodNameIndexOffset;
1282     @HotSpotVMField(name = "ConstMethod::_signature_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodSignatureIndexOffset;
1283     @HotSpotVMField(name = "ConstMethod::_max_stack", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodMaxStackOffset;
1284     @HotSpotVMField(name = "ConstMethod::_max_locals", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodMaxLocalsOffset;
1285 
1286     @HotSpotVMConstant(name = "ConstMethod::_has_linenumber_table") @Stable public int constMethodHasLineNumberTable;
1287     @HotSpotVMConstant(name = "ConstMethod::_has_localvariable_table") @Stable public int constMethodHasLocalVariableTable;
1288     @HotSpotVMConstant(name = "ConstMethod::_has_exception_table") @Stable public int constMethodHasExceptionTable;
1289 
1290     @HotSpotVMType(name = "ExceptionTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int exceptionTableElementSize;
1291     @HotSpotVMField(name = "ExceptionTableElement::start_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementStartPcOffset;
1292     @HotSpotVMField(name = "ExceptionTableElement::end_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementEndPcOffset;
1293     @HotSpotVMField(name = "ExceptionTableElement::handler_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementHandlerPcOffset;
1294     @HotSpotVMField(name = "ExceptionTableElement::catch_type_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementCatchTypeIndexOffset;
1295 
1296     @HotSpotVMType(name = "LocalVariableTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int localVariableTableElementSize;
1297     @HotSpotVMField(name = "LocalVariableTableElement::start_bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementStartBciOffset;
1298     @HotSpotVMField(name = "LocalVariableTableElement::length", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementLengthOffset;
1299     @HotSpotVMField(name = "LocalVariableTableElement::name_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementNameCpIndexOffset;
1300     @HotSpotVMField(name = "LocalVariableTableElement::descriptor_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementDescriptorCpIndexOffset;
1301     @HotSpotVMField(name = "LocalVariableTableElement::signature_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSignatureCpIndexOffset;
1302     @HotSpotVMField(name = "LocalVariableTableElement::slot", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSlotOffset;
1303 
1304     @HotSpotVMType(name = "ConstantPool", get = HotSpotVMType.Type.SIZE) @Stable public int constantPoolSize;
1305     @HotSpotVMField(name = "ConstantPool::_tags", type = "Array&lt;u1&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolTagsOffset;
1306     @HotSpotVMField(name = "ConstantPool::_pool_holder", type = "InstanceKlass*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolHolderOffset;
1307     @HotSpotVMField(name = "ConstantPool::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolLengthOffset;
1308 
1309     @HotSpotVMConstant(name = "ConstantPool::CPCACHE_INDEX_TAG") @Stable public int constantPoolCpCacheIndexTag;
1310 
1311     @HotSpotVMConstant(name = "JVM_CONSTANT_Utf8") @Stable public int jvmConstantUtf8;
1312     @HotSpotVMConstant(name = "JVM_CONSTANT_Integer") @Stable public int jvmConstantInteger;
1313     @HotSpotVMConstant(name = "JVM_CONSTANT_Long") @Stable public int jvmConstantLong;
1314     @HotSpotVMConstant(name = "JVM_CONSTANT_Float") @Stable public int jvmConstantFloat;
1315     @HotSpotVMConstant(name = "JVM_CONSTANT_Double") @Stable public int jvmConstantDouble;
1316     @HotSpotVMConstant(name = "JVM_CONSTANT_Class") @Stable public int jvmConstantClass;
1317     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClass") @Stable public int jvmConstantUnresolvedClass;
1318     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClassInError") @Stable public int jvmConstantUnresolvedClassInError;
1319     @HotSpotVMConstant(name = "JVM_CONSTANT_String") @Stable public int jvmConstantString;
1320     @HotSpotVMConstant(name = "JVM_CONSTANT_Fieldref") @Stable public int jvmConstantFieldref;
1321     @HotSpotVMConstant(name = "JVM_CONSTANT_Methodref") @Stable public int jvmConstantMethodref;
1322     @HotSpotVMConstant(name = "JVM_CONSTANT_InterfaceMethodref") @Stable public int jvmConstantInterfaceMethodref;
1323     @HotSpotVMConstant(name = "JVM_CONSTANT_NameAndType") @Stable public int jvmConstantNameAndType;
1324     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandle") @Stable public int jvmConstantMethodHandle;
1325     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandleInError") @Stable public int jvmConstantMethodHandleInError;
1326     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodType") @Stable public int jvmConstantMethodType;
1327     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodTypeInError") @Stable public int jvmConstantMethodTypeInError;
1328     @HotSpotVMConstant(name = "JVM_CONSTANT_InvokeDynamic") @Stable public int jvmConstantInvokeDynamic;
1329 
1330     @HotSpotVMConstant(name = "JVM_CONSTANT_ExternalMax") @Stable public int jvmConstantExternalMax;
1331     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMin") @Stable public int jvmConstantInternalMin;
1332     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMax") @Stable public int jvmConstantInternalMax;
1333 
1334     @HotSpotVMConstant(name = "HeapWordSize") @Stable public int heapWordSize;
1335 
1336     @HotSpotVMType(name = "Symbol*", get = HotSpotVMType.Type.SIZE) @Stable public int symbolPointerSize;
1337 
1338     @HotSpotVMField(name = "vmSymbols::_symbols[0]", type = "Symbol*", get = HotSpotVMField.Type.ADDRESS) @Stable public long vmSymbolsSymbols;
1339     @HotSpotVMConstant(name = "vmSymbols::FIRST_SID") @Stable public int vmSymbolsFirstSID;
1340     @HotSpotVMConstant(name = "vmSymbols::SID_LIMIT") @Stable public int vmSymbolsSIDLimit;
1341 
1342     /**
1343      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
1344      * are allowed to look like (respectively) the high or low bits of a real oop.
1345      */
1346     @HotSpotVMField(name = "CompilerToVM::Data::Universe_non_oop_bits", type = "void*", get = HotSpotVMField.Type.VALUE) @Stable public long nonOopBits;
1347 
1348     @HotSpotVMField(name = "StubRoutines::_verify_oop_count", type = "jint", get = HotSpotVMField.Type.ADDRESS) @Stable public long verifyOopCounterAddress;
1349     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_mask", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopMask;
1350     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_bits", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopBits;
1351     @HotSpotVMField(name = "CompilerToVM::Data::Universe_base_vtable_size", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int universeBaseVtableSize;
1352 
1353     public final int baseVtableLength() {
1354         return universeBaseVtableSize / vtableEntrySize;
1355     }
1356 
1357     @HotSpotVMField(name = "HeapRegion::LogOfHRGrainBytes", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int logOfHRGrainBytes;
1358 
1359     @HotSpotVMConstant(name = "CardTableModRefBS::dirty_card") @Stable public byte dirtyCardValue;
1360     @HotSpotVMConstant(name = "G1SATBCardTableModRefBS::g1_young_gen") @Stable public byte g1YoungCardValue;
1361 
1362     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_start_address", type = "jbyte*", get = HotSpotVMField.Type.VALUE) @Stable private long cardtableStartAddress;
1363     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable private int cardtableShift;
1364 
1365     public long cardtableStartAddress() {
1366         return cardtableStartAddress;
1367     }
1368 
1369     public int cardtableShift() {
1370         return cardtableShift;
1371     }
1372 
1373     @HotSpotVMField(name = "os::_polling_page", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long safepointPollingAddress;
1374 
1375     // G1 Collector Related Values.
1376 
1377     public int g1CardQueueIndexOffset() {
1378         return javaThreadDirtyCardQueueOffset + dirtyCardQueueIndexOffset;
1379     }
1380 
1381     public int g1CardQueueBufferOffset() {
1382         return javaThreadDirtyCardQueueOffset + dirtyCardQueueBufferOffset;
1383     }
1384 
1385     public int g1SATBQueueMarkingOffset() {
1386         return javaThreadSatbMarkQueueOffset + satbMarkQueueActiveOffset;
1387     }
1388 
1389     public int g1SATBQueueIndexOffset() {
1390         return javaThreadSatbMarkQueueOffset + satbMarkQueueIndexOffset;
1391     }
1392 
1393     public int g1SATBQueueBufferOffset() {
1394         return javaThreadSatbMarkQueueOffset + satbMarkQueueBufferOffset;
1395     }
1396 
1397     @HotSpotVMField(name = "java_lang_Class::_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassOffset;
1398     @HotSpotVMField(name = "java_lang_Class::_array_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int arrayKlassOffset;
1399 
1400     @HotSpotVMType(name = "BasicLock", get = HotSpotVMType.Type.SIZE) @Stable public int basicLockSize;
1401     @HotSpotVMField(name = "BasicLock::_displaced_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int basicLockDisplacedHeaderOffset;
1402 
1403     @HotSpotVMField(name = "Thread::_allocated_bytes", type = "jlong", get = HotSpotVMField.Type.OFFSET) @Stable public int threadAllocatedBytesOffset;
1404 
1405     @HotSpotVMFlag(name = "TLABWasteIncrement") @Stable public int tlabRefillWasteIncrement;
1406 
1407     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_start", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferStartOffset;
1408     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_end", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferEndOffset;
1409     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferTopOffset;
1410     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_pf_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferPfTopOffset;
1411     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_slow_allocations", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferSlowAllocationsOffset;
1412     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_fast_refill_waste", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferFastRefillWasteOffset;
1413     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_number_of_refills", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferNumberOfRefillsOffset;
1414     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_refill_waste_limit", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferRefillWasteLimitOffset;
1415     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_desired_size", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferDesiredSizeOffset;
1416 
1417     public int tlabSlowAllocationsOffset() {
1418         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
1419     }
1420 
1421     public int tlabFastRefillWasteOffset() {
1422         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
1423     }
1424 
1425     public int tlabNumberOfRefillsOffset() {
1426         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
1427     }
1428 
1429     public int tlabRefillWasteLimitOffset() {
1430         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
1431     }
1432 
1433     public int threadTlabSizeOffset() {
1434         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
1435     }
1436 
1437     public int threadTlabStartOffset() {
1438         return threadTlabOffset + threadLocalAllocBufferStartOffset;
1439     }
1440 
1441     public int threadTlabEndOffset() {
1442         return threadTlabOffset + threadLocalAllocBufferEndOffset;
1443     }
1444 
1445     public int threadTlabTopOffset() {
1446         return threadTlabOffset + threadLocalAllocBufferTopOffset;
1447     }
1448 
1449     public int threadTlabPfTopOffset() {
1450         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
1451     }
1452 
1453     @HotSpotVMField(name = "CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve", type = "size_t", get = HotSpotVMField.Type.VALUE) @Stable public int tlabAlignmentReserve;
1454 
1455     @HotSpotVMFlag(name = "TLABStats") @Stable public boolean tlabStats;
1456 
1457     // FIXME This is only temporary until the GC code is changed.
1458     @HotSpotVMField(name = "CompilerToVM::Data::_supports_inline_contig_alloc", type = "bool", get = HotSpotVMField.Type.VALUE) @Stable public boolean inlineContiguousAllocationSupported;
1459     @HotSpotVMField(name = "CompilerToVM::Data::_heap_end_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapEndAddress;
1460     @HotSpotVMField(name = "CompilerToVM::Data::_heap_top_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapTopAddress;
1461 
1462     /**
1463      * The DataLayout header size is the same as the cell size.
1464      */
1465     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutHeaderSize;
1466     @HotSpotVMField(name = "DataLayout::_header._struct._tag", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutTagOffset;
1467     @HotSpotVMField(name = "DataLayout::_header._struct._flags", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutFlagsOffset;
1468     @HotSpotVMField(name = "DataLayout::_header._struct._bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutBCIOffset;
1469     @HotSpotVMField(name = "DataLayout::_cells[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutCellsOffset;
1470     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutCellSize;
1471 
1472     @HotSpotVMConstant(name = "DataLayout::no_tag") @Stable public int dataLayoutNoTag;
1473     @HotSpotVMConstant(name = "DataLayout::bit_data_tag") @Stable public int dataLayoutBitDataTag;
1474     @HotSpotVMConstant(name = "DataLayout::counter_data_tag") @Stable public int dataLayoutCounterDataTag;
1475     @HotSpotVMConstant(name = "DataLayout::jump_data_tag") @Stable public int dataLayoutJumpDataTag;
1476     @HotSpotVMConstant(name = "DataLayout::receiver_type_data_tag") @Stable public int dataLayoutReceiverTypeDataTag;
1477     @HotSpotVMConstant(name = "DataLayout::virtual_call_data_tag") @Stable public int dataLayoutVirtualCallDataTag;
1478     @HotSpotVMConstant(name = "DataLayout::ret_data_tag") @Stable public int dataLayoutRetDataTag;
1479     @HotSpotVMConstant(name = "DataLayout::branch_data_tag") @Stable public int dataLayoutBranchDataTag;
1480     @HotSpotVMConstant(name = "DataLayout::multi_branch_data_tag") @Stable public int dataLayoutMultiBranchDataTag;
1481     @HotSpotVMConstant(name = "DataLayout::arg_info_data_tag") @Stable public int dataLayoutArgInfoDataTag;
1482     @HotSpotVMConstant(name = "DataLayout::call_type_data_tag") @Stable public int dataLayoutCallTypeDataTag;
1483     @HotSpotVMConstant(name = "DataLayout::virtual_call_type_data_tag") @Stable public int dataLayoutVirtualCallTypeDataTag;
1484     @HotSpotVMConstant(name = "DataLayout::parameters_type_data_tag") @Stable public int dataLayoutParametersTypeDataTag;
1485     @HotSpotVMConstant(name = "DataLayout::speculative_trap_data_tag") @Stable public int dataLayoutSpeculativeTrapDataTag;
1486 
1487     @HotSpotVMFlag(name = "BciProfileWidth") @Stable public int bciProfileWidth;
1488     @HotSpotVMFlag(name = "TypeProfileWidth") @Stable public int typeProfileWidth;
1489     @HotSpotVMFlag(name = "MethodProfileWidth") @Stable public int methodProfileWidth;
1490 
1491     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_ic_miss_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long inlineCacheMissStub;
1492     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleWrongMethodStub;
1493 
1494     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_unpack", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleDeoptStub;
1495     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long uncommonTrapStub;
1496 
1497     @HotSpotVMField(name = "CodeCache::_low_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheLowBound;
1498     @HotSpotVMField(name = "CodeCache::_high_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheHighBound;
1499 
1500     @HotSpotVMField(name = "StubRoutines::_aescrypt_encryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptEncryptBlockStub;
1501     @HotSpotVMField(name = "StubRoutines::_aescrypt_decryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptDecryptBlockStub;
1502     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_encryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingEncryptAESCryptStub;
1503     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_decryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingDecryptAESCryptStub;
1504     @HotSpotVMField(name = "StubRoutines::_updateBytesCRC32", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long updateBytesCRC32Stub;
1505     @HotSpotVMField(name = "StubRoutines::_crc_table_adr", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long crcTableAddress;
1506 
1507     @HotSpotVMField(name = "StubRoutines::_throw_delayed_StackOverflowError_entry", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long throwDelayedStackOverflowErrorEntry;
1508 
1509     @HotSpotVMField(name = "StubRoutines::_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteArraycopy;
1510     @HotSpotVMField(name = "StubRoutines::_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortArraycopy;
1511     @HotSpotVMField(name = "StubRoutines::_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintArraycopy;
1512     @HotSpotVMField(name = "StubRoutines::_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongArraycopy;
1513     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopy;
1514     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopyUninit;
1515     @HotSpotVMField(name = "StubRoutines::_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteDisjointArraycopy;
1516     @HotSpotVMField(name = "StubRoutines::_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortDisjointArraycopy;
1517     @HotSpotVMField(name = "StubRoutines::_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintDisjointArraycopy;
1518     @HotSpotVMField(name = "StubRoutines::_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongDisjointArraycopy;
1519     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopy;
1520     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopyUninit;
1521     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedArraycopy;
1522     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedArraycopy;
1523     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedArraycopy;
1524     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedArraycopy;
1525     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopy;
1526     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopyUninit;
1527     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedDisjointArraycopy;
1528     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedDisjointArraycopy;
1529     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedDisjointArraycopy;
1530     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedDisjointArraycopy;
1531     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopy;
1532     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopyUninit;
1533     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopy;
1534     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopyUninit;
1535     @HotSpotVMField(name = "StubRoutines::_unsafe_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long unsafeArraycopy;
1536     @HotSpotVMField(name = "StubRoutines::_generic_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long genericArraycopy;
1537 
1538     @HotSpotVMAddress(name = "JVMCIRuntime::new_instance") @Stable public long newInstanceAddress;
1539     @HotSpotVMAddress(name = "JVMCIRuntime::new_array") @Stable public long newArrayAddress;
1540     @HotSpotVMAddress(name = "JVMCIRuntime::new_multi_array") @Stable public long newMultiArrayAddress;
1541     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_array") @Stable public long dynamicNewArrayAddress;
1542     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_instance") @Stable public long dynamicNewInstanceAddress;
1543 
1544     @HotSpotVMAddress(name = "JVMCIRuntime::thread_is_interrupted") @Stable public long threadIsInterruptedAddress;
1545     @HotSpotVMAddress(name = "JVMCIRuntime::vm_message") @Stable public long vmMessageAddress;
1546     @HotSpotVMAddress(name = "JVMCIRuntime::identity_hash_code") @Stable public long identityHashCodeAddress;
1547     @HotSpotVMAddress(name = "JVMCIRuntime::exception_handler_for_pc") @Stable public long exceptionHandlerForPcAddress;
1548     @HotSpotVMAddress(name = "JVMCIRuntime::monitorenter") @Stable public long monitorenterAddress;
1549     @HotSpotVMAddress(name = "JVMCIRuntime::monitorexit") @Stable public long monitorexitAddress;
1550     @HotSpotVMAddress(name = "JVMCIRuntime::throw_and_post_jvmti_exception") @Stable public long throwAndPostJvmtiExceptionAddress;
1551     @HotSpotVMAddress(name = "JVMCIRuntime::throw_klass_external_name_exception") @Stable public long throwKlassExternalNameExceptionAddress;
1552     @HotSpotVMAddress(name = "JVMCIRuntime::throw_class_cast_exception") @Stable public long throwClassCastExceptionAddress;
1553     @HotSpotVMAddress(name = "JVMCIRuntime::log_primitive") @Stable public long logPrimitiveAddress;
1554     @HotSpotVMAddress(name = "JVMCIRuntime::log_object") @Stable public long logObjectAddress;
1555     @HotSpotVMAddress(name = "JVMCIRuntime::log_printf") @Stable public long logPrintfAddress;
1556     @HotSpotVMAddress(name = "JVMCIRuntime::vm_error") @Stable public long vmErrorAddress;
1557     @HotSpotVMAddress(name = "JVMCIRuntime::load_and_clear_exception") @Stable public long loadAndClearExceptionAddress;
1558     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_pre") @Stable public long writeBarrierPreAddress;
1559     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_post") @Stable public long writeBarrierPostAddress;
1560     @HotSpotVMAddress(name = "JVMCIRuntime::validate_object") @Stable public long validateObject;
1561 
1562     @HotSpotVMAddress(name = "JVMCIRuntime::test_deoptimize_call_int") @Stable public long testDeoptimizeCallInt;
1563 
1564     @HotSpotVMAddress(name = "SharedRuntime::register_finalizer") @Stable public long registerFinalizerAddress;
1565     @HotSpotVMAddress(name = "SharedRuntime::exception_handler_for_return_address") @Stable public long exceptionHandlerForReturnAddressAddress;
1566     @HotSpotVMAddress(name = "SharedRuntime::OSR_migration_end") @Stable public long osrMigrationEndAddress;
1567     @HotSpotVMAddress(name = "SharedRuntime::enable_stack_reserved_zone") @Stable public long enableStackReservedZoneAddress;
1568 
1569     @HotSpotVMAddress(name = "os::javaTimeMillis") @Stable public long javaTimeMillisAddress;
1570     @HotSpotVMAddress(name = "os::javaTimeNanos") @Stable public long javaTimeNanosAddress;
1571     @HotSpotVMField(name = "CompilerToVM::Data::dsin", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticSinAddress;
1572     @HotSpotVMField(name = "CompilerToVM::Data::dcos", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticCosAddress;
1573     @HotSpotVMField(name = "CompilerToVM::Data::dtan", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticTanAddress;
1574     @HotSpotVMField(name = "CompilerToVM::Data::dexp", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticExpAddress;
1575     @HotSpotVMField(name = "CompilerToVM::Data::dlog", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticLogAddress;
1576     @HotSpotVMField(name = "CompilerToVM::Data::dlog10", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticLog10Address;
1577     @HotSpotVMField(name = "CompilerToVM::Data::dpow", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticPowAddress;
1578 
1579     @HotSpotVMFlag(name = "JVMCICounterSize") @Stable public int jvmciCountersSize;
1580 
1581     @HotSpotVMAddress(name = "Deoptimization::fetch_unroll_info") @Stable public long deoptimizationFetchUnrollInfo;
1582     @HotSpotVMAddress(name = "Deoptimization::uncommon_trap") @Stable public long deoptimizationUncommonTrap;
1583     @HotSpotVMAddress(name = "Deoptimization::unpack_frames") @Stable public long deoptimizationUnpackFrames;
1584 
1585     @HotSpotVMConstant(name = "Deoptimization::Reason_none") @Stable public int deoptReasonNone;
1586     @HotSpotVMConstant(name = "Deoptimization::Reason_null_check") @Stable public int deoptReasonNullCheck;
1587     @HotSpotVMConstant(name = "Deoptimization::Reason_range_check") @Stable public int deoptReasonRangeCheck;
1588     @HotSpotVMConstant(name = "Deoptimization::Reason_class_check") @Stable public int deoptReasonClassCheck;
1589     @HotSpotVMConstant(name = "Deoptimization::Reason_array_check") @Stable public int deoptReasonArrayCheck;
1590     @HotSpotVMConstant(name = "Deoptimization::Reason_unreached0") @Stable public int deoptReasonUnreached0;
1591     @HotSpotVMConstant(name = "Deoptimization::Reason_type_checked_inlining") @Stable public int deoptReasonTypeCheckInlining;
1592     @HotSpotVMConstant(name = "Deoptimization::Reason_optimized_type_check") @Stable public int deoptReasonOptimizedTypeCheck;
1593     @HotSpotVMConstant(name = "Deoptimization::Reason_not_compiled_exception_handler") @Stable public int deoptReasonNotCompiledExceptionHandler;
1594     @HotSpotVMConstant(name = "Deoptimization::Reason_unresolved") @Stable public int deoptReasonUnresolved;
1595     @HotSpotVMConstant(name = "Deoptimization::Reason_jsr_mismatch") @Stable public int deoptReasonJsrMismatch;
1596     @HotSpotVMConstant(name = "Deoptimization::Reason_div0_check") @Stable public int deoptReasonDiv0Check;
1597     @HotSpotVMConstant(name = "Deoptimization::Reason_constraint") @Stable public int deoptReasonConstraint;
1598     @HotSpotVMConstant(name = "Deoptimization::Reason_loop_limit_check") @Stable public int deoptReasonLoopLimitCheck;
1599     @HotSpotVMConstant(name = "Deoptimization::Reason_aliasing") @Stable public int deoptReasonAliasing;
1600     @HotSpotVMConstant(name = "Deoptimization::Reason_transfer_to_interpreter") @Stable public int deoptReasonTransferToInterpreter;
1601     @HotSpotVMConstant(name = "Deoptimization::Reason_LIMIT") @Stable public int deoptReasonOSROffset;
1602 
1603     @HotSpotVMConstant(name = "Deoptimization::Action_none") @Stable public int deoptActionNone;
1604     @HotSpotVMConstant(name = "Deoptimization::Action_maybe_recompile") @Stable public int deoptActionMaybeRecompile;
1605     @HotSpotVMConstant(name = "Deoptimization::Action_reinterpret") @Stable public int deoptActionReinterpret;
1606     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_entrant") @Stable public int deoptActionMakeNotEntrant;
1607     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_compilable") @Stable public int deoptActionMakeNotCompilable;
1608 
1609     @HotSpotVMConstant(name = "Deoptimization::_action_bits") @Stable public int deoptimizationActionBits;
1610     @HotSpotVMConstant(name = "Deoptimization::_reason_bits") @Stable public int deoptimizationReasonBits;
1611     @HotSpotVMConstant(name = "Deoptimization::_debug_id_bits") @Stable public int deoptimizationDebugIdBits;
1612     @HotSpotVMConstant(name = "Deoptimization::_action_shift") @Stable public int deoptimizationActionShift;
1613     @HotSpotVMConstant(name = "Deoptimization::_reason_shift") @Stable public int deoptimizationReasonShift;
1614     @HotSpotVMConstant(name = "Deoptimization::_debug_id_shift") @Stable public int deoptimizationDebugIdShift;
1615 
1616     @HotSpotVMConstant(name = "Deoptimization::Unpack_deopt") @Stable public int deoptimizationUnpackDeopt;
1617     @HotSpotVMConstant(name = "Deoptimization::Unpack_exception") @Stable public int deoptimizationUnpackException;
1618     @HotSpotVMConstant(name = "Deoptimization::Unpack_uncommon_trap") @Stable public int deoptimizationUnpackUncommonTrap;
1619     @HotSpotVMConstant(name = "Deoptimization::Unpack_reexecute") @Stable public int deoptimizationUnpackReexecute;
1620 
1621     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_size_of_deoptimized_frame", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockSizeOfDeoptimizedFrameOffset;
1622     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_caller_adjustment", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockCallerAdjustmentOffset;
1623     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_number_of_frames", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockNumberOfFramesOffset;
1624     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_total_frame_sizes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockTotalFrameSizesOffset;
1625     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_unpack_kind", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockUnpackKindOffset;
1626     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_sizes", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFrameSizesOffset;
1627     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_pcs", type = "address*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFramePcsOffset;
1628     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_initial_info", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockInitialInfoOffset;
1629 
1630     @HotSpotVMConstant(name = "vmIntrinsics::_invokeBasic") @Stable public int vmIntrinsicInvokeBasic;
1631     @HotSpotVMConstant(name = "vmIntrinsics::_linkToVirtual") @Stable public int vmIntrinsicLinkToVirtual;
1632     @HotSpotVMConstant(name = "vmIntrinsics::_linkToStatic") @Stable public int vmIntrinsicLinkToStatic;
1633     @HotSpotVMConstant(name = "vmIntrinsics::_linkToSpecial") @Stable public int vmIntrinsicLinkToSpecial;
1634     @HotSpotVMConstant(name = "vmIntrinsics::_linkToInterface") @Stable public int vmIntrinsicLinkToInterface;
1635 
1636     @HotSpotVMConstant(name = "JVMCIEnv::ok") @Stable public int codeInstallResultOk;
1637     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_failed") @Stable public int codeInstallResultDependenciesFailed;
1638     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_invalid") @Stable public int codeInstallResultDependenciesInvalid;
1639     @HotSpotVMConstant(name = "JVMCIEnv::cache_full") @Stable public int codeInstallResultCacheFull;
1640     @HotSpotVMConstant(name = "JVMCIEnv::code_too_large") @Stable public int codeInstallResultCodeTooLarge;
1641 
1642     public String getCodeInstallResultDescription(int codeInstallResult) {
1643         if (codeInstallResult == codeInstallResultOk) {
1644             return "ok";
1645         }
1646         if (codeInstallResult == codeInstallResultDependenciesFailed) {
1647             return "dependencies failed";
1648         }
1649         if (codeInstallResult == codeInstallResultDependenciesInvalid) {
1650             return "dependencies invalid";
1651         }
1652         if (codeInstallResult == codeInstallResultCacheFull) {
1653             return "code cache is full";
1654         }
1655         if (codeInstallResult == codeInstallResultCodeTooLarge) {
1656             return "code is too large";
1657         }
1658         assert false : codeInstallResult;
1659         return "unknown";
1660     }
1661 
1662     // Checkstyle: stop
1663     @HotSpotVMConstant(name = "CodeInstaller::VERIFIED_ENTRY") @Stable public int MARKID_VERIFIED_ENTRY;
1664     @HotSpotVMConstant(name = "CodeInstaller::UNVERIFIED_ENTRY") @Stable public int MARKID_UNVERIFIED_ENTRY;
1665     @HotSpotVMConstant(name = "CodeInstaller::OSR_ENTRY") @Stable public int MARKID_OSR_ENTRY;
1666     @HotSpotVMConstant(name = "CodeInstaller::EXCEPTION_HANDLER_ENTRY") @Stable public int MARKID_EXCEPTION_HANDLER_ENTRY;
1667     @HotSpotVMConstant(name = "CodeInstaller::DEOPT_HANDLER_ENTRY") @Stable public int MARKID_DEOPT_HANDLER_ENTRY;
1668     @HotSpotVMConstant(name = "CodeInstaller::INVOKEINTERFACE") @Stable public int MARKID_INVOKEINTERFACE;
1669     @HotSpotVMConstant(name = "CodeInstaller::INVOKEVIRTUAL") @Stable public int MARKID_INVOKEVIRTUAL;
1670     @HotSpotVMConstant(name = "CodeInstaller::INVOKESTATIC") @Stable public int MARKID_INVOKESTATIC;
1671     @HotSpotVMConstant(name = "CodeInstaller::INVOKESPECIAL") @Stable public int MARKID_INVOKESPECIAL;
1672     @HotSpotVMConstant(name = "CodeInstaller::INLINE_INVOKE") @Stable public int MARKID_INLINE_INVOKE;
1673     @HotSpotVMConstant(name = "CodeInstaller::POLL_NEAR") @Stable public int MARKID_POLL_NEAR;
1674     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_NEAR") @Stable public int MARKID_POLL_RETURN_NEAR;
1675     @HotSpotVMConstant(name = "CodeInstaller::POLL_FAR") @Stable public int MARKID_POLL_FAR;
1676     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_FAR") @Stable public int MARKID_POLL_RETURN_FAR;
1677     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_SHIFT") @Stable public int MARKID_CARD_TABLE_SHIFT;
1678     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_ADDRESS") @Stable public int MARKID_CARD_TABLE_ADDRESS;
1679     @HotSpotVMConstant(name = "CodeInstaller::HEAP_TOP_ADDRESS") @Stable public int MARKID_HEAP_TOP_ADDRESS;
1680     @HotSpotVMConstant(name = "CodeInstaller::HEAP_END_ADDRESS") @Stable public int MARKID_HEAP_END_ADDRESS;
1681     @HotSpotVMConstant(name = "CodeInstaller::NARROW_KLASS_BASE_ADDRESS") @Stable public int MARKID_NARROW_KLASS_BASE_ADDRESS;
1682     @HotSpotVMConstant(name = "CodeInstaller::CRC_TABLE_ADDRESS") @Stable public int MARKID_CRC_TABLE_ADDRESS;
1683     @HotSpotVMConstant(name = "CodeInstaller::INVOKE_INVALID") @Stable public int MARKID_INVOKE_INVALID;
1684 
1685     @HotSpotVMConstant(name = "BitData::exception_seen_flag") @Stable public int bitDataExceptionSeenFlag;
1686     @HotSpotVMConstant(name = "BitData::null_seen_flag") @Stable public int bitDataNullSeenFlag;
1687     @HotSpotVMConstant(name = "CounterData::count_off") @Stable public int methodDataCountOffset;
1688     @HotSpotVMConstant(name = "JumpData::taken_off_set") @Stable public int jumpDataTakenOffset;
1689     @HotSpotVMConstant(name = "JumpData::displacement_off_set") @Stable public int jumpDataDisplacementOffset;
1690     @HotSpotVMConstant(name = "ReceiverTypeData::nonprofiled_count_off_set") @Stable public int receiverTypeDataNonprofiledCountOffset;
1691     @HotSpotVMConstant(name = "ReceiverTypeData::receiver_type_row_cell_count") @Stable public int receiverTypeDataReceiverTypeRowCellCount;
1692     @HotSpotVMConstant(name = "ReceiverTypeData::receiver0_offset") @Stable public int receiverTypeDataReceiver0Offset;
1693     @HotSpotVMConstant(name = "ReceiverTypeData::count0_offset") @Stable public int receiverTypeDataCount0Offset;
1694     @HotSpotVMConstant(name = "BranchData::not_taken_off_set") @Stable public int branchDataNotTakenOffset;
1695     @HotSpotVMConstant(name = "ArrayData::array_len_off_set") @Stable public int arrayDataArrayLenOffset;
1696     @HotSpotVMConstant(name = "ArrayData::array_start_off_set") @Stable public int arrayDataArrayStartOffset;
1697     @HotSpotVMConstant(name = "MultiBranchData::per_case_cell_count") @Stable public int multiBranchDataPerCaseCellCount;
1698 
1699     // Checkstyle: resume
1700 
1701     private boolean check() {
1702         for (Field f : getClass().getDeclaredFields()) {
1703             int modifiers = f.getModifiers();
1704             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
1705                 assert Modifier.isFinal(modifiers) || f.getAnnotation(Stable.class) != null : "field should either be final or @Stable: " + f;
1706             }
1707         }
1708 
1709         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
1710         assert (layoutHelperArrayTagObjectValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "object array must have first bit set";
1711         assert (layoutHelperArrayTagTypeValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "type array must have first bit set";
1712 
1713         return true;
1714     }
1715 
1716     /**
1717      * A compact representation of the different encoding strategies for Objects and metadata.
1718      */
1719     public static class CompressEncoding {
1720         public final long base;
1721         public final int shift;
1722         public final int alignment;
1723 
1724         CompressEncoding(long base, int shift, int alignment) {
1725             this.base = base;
1726             this.shift = shift;
1727             this.alignment = alignment;
1728         }
1729 
1730         public int compress(long ptr) {
1731             if (ptr == 0L) {
1732                 return 0;
1733             } else {
1734                 return (int) ((ptr - base) &gt;&gt;&gt; shift);
1735             }
1736         }
1737 
1738         public long uncompress(int ptr) {
1739             if (ptr == 0) {
1740                 return 0L;
1741             } else {
1742                 return ((ptr &amp; 0xFFFFFFFFL) &lt;&lt; shift) + base;
1743             }
1744         }
1745 
1746         @Override
1747         public String toString() {
1748             return "base: " + base + " shift: " + shift + " alignment: " + alignment;
1749         }
1750 
1751         @Override
1752         public int hashCode() {
1753             final int prime = 31;
1754             int result = 1;
1755             result = prime * result + alignment;
1756             result = prime * result + (int) (base ^ (base &gt;&gt;&gt; 32));
1757             result = prime * result + shift;
1758             return result;
1759         }
1760 
1761         @Override
1762         public boolean equals(Object obj) {
1763             if (obj instanceof CompressEncoding) {
1764                 CompressEncoding other = (CompressEncoding) obj;
1765                 return alignment == other.alignment &amp;&amp; base == other.base &amp;&amp; shift == other.shift;
1766             } else {
1767                 return false;
1768             }
1769         }
1770     }
1771 
1772 }
</pre></body></html>
