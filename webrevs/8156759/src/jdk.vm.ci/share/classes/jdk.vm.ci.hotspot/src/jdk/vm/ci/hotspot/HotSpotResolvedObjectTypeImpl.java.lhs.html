<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  30 
  31 import java.lang.annotation.Annotation;
  32 import java.lang.reflect.Array;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.Method;
  35 import java.lang.reflect.Modifier;
  36 import java.nio.ByteOrder;
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.HashMap;
  40 
<a name="1" id="anc1"></a><span class="removed">  41 import jdk.vm.ci.common.JVMCIError;</span>
  42 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  43 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  45 import jdk.vm.ci.meta.Assumptions.LeafType;
  46 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  47 import jdk.vm.ci.meta.Constant;
  48 import jdk.vm.ci.meta.JavaConstant;
  49 import jdk.vm.ci.meta.JavaKind;
  50 import jdk.vm.ci.meta.JavaType;
  51 import jdk.vm.ci.meta.ModifiersProvider;
  52 import jdk.vm.ci.meta.ResolvedJavaField;
  53 import jdk.vm.ci.meta.ResolvedJavaMethod;
  54 import jdk.vm.ci.meta.ResolvedJavaType;
  55 
  56 /**
  57  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.
  58  */
  59 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, HotSpotProxified, MetaspaceWrapperObject {
  60 
  61     /**
  62      * The Java class this type represents.
  63      */
  64     private final Class&lt;?&gt; javaClass;
  65     private HashMap&lt;Long, HotSpotResolvedJavaField&gt; fieldCache;
  66     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCache;
  67     private HotSpotResolvedJavaField[] instanceFields;
  68     private HotSpotResolvedObjectTypeImpl[] interfaces;
  69     private HotSpotConstantPool constantPool;
  70     final HotSpotJVMCIMetaAccessContext context;
  71     private HotSpotResolvedObjectType arrayOfType;
  72 
  73     /**
  74      * Gets the JVMCI mirror for a {@link Class} object.
  75      *
  76      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}
  77      */
  78     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {
  79         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);
  80     }
  81 
  82     /**
  83      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the
  84      * underlying Klass*, it is used instead of the raw Klass*.
  85      *
  86      * Called from the VM.
  87      *
  88      * @param javaClass a {@link Class} object
  89      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
  90      */
  91     @SuppressWarnings("unused")
  92     private static HotSpotResolvedObjectTypeImpl fromMetaspace(Class&lt;?&gt; javaClass) {
  93         return fromObjectClass(javaClass);
  94     }
  95 
  96     /**
  97      * Creates the JVMCI mirror for a {@link Class} object.
  98      *
  99      * &lt;p&gt;
 100      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
 101      * {@link Class} type. Use {@link #fromObjectClass(Class)} or {@link #fromMetaspace(Class)}
 102      * instead.
 103      * &lt;/p&gt;
 104      *
 105      * @param javaClass the Class to create the mirror for
 106      * @param context
 107      */
 108     HotSpotResolvedObjectTypeImpl(Class&lt;?&gt; javaClass, HotSpotJVMCIMetaAccessContext context) {
 109         super(getSignatureName(javaClass));
 110         this.javaClass = javaClass;
 111         this.context = context;
 112         assert getName().charAt(0) != '[' || isArray() : getName();
 113     }
 114 
 115     /**
 116      * Returns the name of this type as it would appear in a signature.
 117      */
 118     private static String getSignatureName(Class&lt;?&gt; javaClass) {
 119         if (javaClass.isArray()) {
 120             return javaClass.getName().replace('.', '/');
 121         }
 122         return "L" + javaClass.getName().replace('.', '/') + ";";
 123     }
 124 
 125     /**
 126      * Gets the metaspace Klass for this type.
 127      */
 128     long getMetaspaceKlass() {
 129         if (HotSpotJVMCIRuntime.getHostWordKind() == JavaKind.Long) {
<a name="2" id="anc2"></a><span class="changed"> 130             return UNSAFE.getLong(javaClass, (long) config().klassOffset);</span>
 131         }
<a name="3" id="anc3"></a><span class="changed"> 132         return UNSAFE.getInt(javaClass, (long) config().klassOffset) &amp; 0xFFFFFFFFL;</span>
 133     }
 134 
 135     public long getMetaspacePointer() {
 136         return getMetaspaceKlass();
 137     }
 138 
 139     @Override
 140     public int getModifiers() {
 141         if (isArray()) {
 142             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 143         } else {
 144             return getAccessFlags() &amp; ModifiersProvider.jvmClassModifiers();
 145         }
 146     }
 147 
 148     public int getAccessFlags() {
 149         HotSpotVMConfig config = config();
 150         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 151     }
 152 
 153     @Override
 154     public HotSpotResolvedObjectType getArrayClass() {
 155         if (arrayOfType == null) {
 156             arrayOfType = fromObjectClass(Array.newInstance(mirror(), 0).getClass());
 157         }
 158         return arrayOfType;
 159     }
 160 
 161     @Override
 162     public ResolvedJavaType getComponentType() {
 163         Class&lt;?&gt; javaComponentType = mirror().getComponentType();
 164         return javaComponentType == null ? null : runtime().fromClass(javaComponentType);
 165     }
 166 
 167     @Override
 168     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 169         HotSpotVMConfig config = config();
 170         if (isArray()) {
 171             return getElementalType().isLeaf() ? new AssumptionResult&lt;&gt;(this) : null;
 172         } else if (isInterface()) {
 173             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
 174             /*
 175              * If the implementor field contains itself that indicates that the interface has more
 176              * than one implementors (see: InstanceKlass::add_implementor).
 177              */
 178             if (implementor == null || implementor.equals(this)) {
 179                 return null;
 180             }
 181 
 182             assert !implementor.isInterface();
 183             if (implementor.isAbstract() || !implementor.isLeafClass()) {
 184                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
 185                 if (leafConcreteSubtype != null) {
 186                     assert !leafConcreteSubtype.getResult().equals(implementor);
 187                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
 188                     // Accumulate leaf assumptions and return the combined result.
 189                     newResult.add(leafConcreteSubtype);
 190                     return newResult;
 191                 }
 192                 return null;
 193             }
 194 
 195             return new AssumptionResult&lt;&gt;(implementor, new LeafType(implementor), new ConcreteSubtype(this, implementor));
 196         } else {
 197             HotSpotResolvedObjectTypeImpl type = this;
 198             while (type.isAbstract()) {
 199                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
 200                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
 201                     return null;
 202                 }
 203                 type = subklass;
 204             }
 205             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
 206                 return null;
 207             }
 208             if (this.isAbstract()) {
 209                 return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 210             } else {
 211                 assert this.equals(type);
 212                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 213             }
 214         }
 215     }
 216 
 217     /**
 218      * Returns if type {@code type} is a leaf class. This is the case if the
 219      * {@code Klass::_subklass} field of the underlying class is zero.
 220      *
 221      * @return true if the type is a leaf class
 222      */
 223     private boolean isLeafClass() {
 224         return getSubklass() == null;
 225     }
 226 
 227     /**
 228      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 229      * type {@code type}.
 230      *
 231      * @return value of the subklass field as metaspace klass pointer
 232      */
 233     private HotSpotResolvedObjectTypeImpl getSubklass() {
 234         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 235     }
 236 
 237     @Override
 238     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 239         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();
 240         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);
 241     }
 242 
 243     @Override
 244     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 245         if (interfaces == null) {
 246             Class&lt;?&gt;[] javaInterfaces = mirror().getInterfaces();
 247             HotSpotResolvedObjectTypeImpl[] result = new HotSpotResolvedObjectTypeImpl[javaInterfaces.length];
 248             for (int i = 0; i &lt; javaInterfaces.length; i++) {
 249                 result[i] = fromObjectClass(javaInterfaces[i]);
 250             }
 251             interfaces = result;
 252         }
 253         return interfaces;
 254     }
 255 
 256     @Override
 257     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 258         if (!isInterface()) {
<a name="4" id="anc4"></a><span class="changed"> 259             throw new JVMCIError("Cannot call getSingleImplementor() on a non-interface type: %s", this);</span>
 260         }
 261         return compilerToVM().getImplementor(this);
 262     }
 263 
 264     public HotSpotResolvedObjectTypeImpl getSupertype() {
 265         if (isArray()) {
 266             ResolvedJavaType componentType = getComponentType();
 267             if (mirror() == Object[].class || componentType.isPrimitive()) {
 268                 return fromObjectClass(Object.class);
 269             }
 270             return (HotSpotResolvedObjectTypeImpl) ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype().getArrayClass();
 271         }
 272         if (isInterface()) {
 273             return fromObjectClass(Object.class);
 274         }
 275         return getSuperclass();
 276     }
 277 
 278     @Override
 279     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 280         if (otherType.isPrimitive()) {
 281             return null;
 282         } else {
 283             HotSpotResolvedObjectTypeImpl t1 = this;
 284             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 285             while (true) {
 286                 if (t1.isAssignableFrom(t2)) {
 287                     return t1;
 288                 }
 289                 if (t2.isAssignableFrom(t1)) {
 290                     return t2;
 291                 }
 292                 t1 = t1.getSupertype();
 293                 t2 = t2.getSupertype();
 294             }
 295         }
 296     }
 297 
 298     @Override
 299     public HotSpotResolvedObjectType asExactType() {
 300         return isLeaf() ? this : null;
 301     }
 302 
 303     @Override
 304     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 305         assert !isArray();
 306         if (!compilerToVM().hasFinalizableSubclass(this)) {
 307             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 308         }
 309         return new AssumptionResult&lt;&gt;(true);
 310     }
 311 
 312     @Override
 313     public boolean hasFinalizer() {
 314         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 315     }
 316 
 317     @Override
 318     public boolean isPrimitive() {
 319         return false;
 320     }
 321 
 322     @Override
 323     public boolean isArray() {
 324         return mirror().isArray();
 325     }
 326 
 327     @Override
 328     public boolean isInitialized() {
 329         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 330     }
 331 
 332     @Override
 333     public boolean isLinked() {
 334         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 335     }
 336 
 337     /**
 338      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 339      * klass.
 340      *
 341      * @return state field value of this type
 342      */
 343     private int getInitState() {
 344         assert !isArray() : "_init_state only exists in InstanceKlass";
 345         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 346     }
 347 
 348     @Override
 349     public void initialize() {
 350         if (!isInitialized()) {
 351             UNSAFE.ensureClassInitialized(mirror());
 352             assert isInitialized();
 353         }
 354     }
 355 
 356     @Override
 357     public boolean isInstance(JavaConstant obj) {
 358         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
 359             return mirror().isInstance(((HotSpotObjectConstantImpl) obj).object());
 360         }
 361         return false;
 362     }
 363 
 364     @Override
 365     public boolean isInstanceClass() {
 366         return !isArray() &amp;&amp; !isInterface();
 367     }
 368 
 369     @Override
 370     public boolean isInterface() {
 371         return mirror().isInterface();
 372     }
 373 
 374     @Override
 375     public boolean isAssignableFrom(ResolvedJavaType other) {
 376         assert other != null;
 377         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 378             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
 379             return mirror().isAssignableFrom(otherType.mirror());
 380         }
 381         return false;
 382     }
 383 
 384     @Override
 385     public boolean isJavaLangObject() {
 386         return javaClass.equals(Object.class);
 387     }
 388 
 389     @Override
 390     public JavaKind getJavaKind() {
 391         return JavaKind.Object;
 392     }
 393 
 394     @Override
 395     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 396         assert !callerType.isArray();
 397         if (isInterface()) {
 398             // Methods can only be resolved against concrete types
 399             return null;
 400         }
 401         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic()) {
 402             return method;
 403         }
 404         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 405             return null;
 406         }
 407         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
 408         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
 409         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
 410     }
 411 
 412     public HotSpotConstantPool getConstantPool() {
 413         if (constantPool == null) {
 414             constantPool = compilerToVM().getConstantPool(this, config().instanceKlassConstantsOffset);
 415         }
 416         return constantPool;
 417     }
 418 
 419     /**
 420      * Gets the instance size of this type. If an instance of this type cannot be fast path
 421      * allocated, then the returned value is negative (its absolute value gives the size). Must not
 422      * be called if this is an array or interface type.
 423      */
 424     public int instanceSize() {
 425         assert !isArray();
 426         assert !isInterface();
 427 
 428         HotSpotVMConfig config = config();
 429         final int layoutHelper = layoutHelper();
 430         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : "must be instance";
 431 
 432         // See: Klass::layout_helper_size_in_bytes
 433         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 434 
 435         // See: Klass::layout_helper_needs_slow_path
 436         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 437 
 438         return needsSlowPath ? -size : size;
 439     }
 440 
 441     public int layoutHelper() {
 442         HotSpotVMConfig config = config();
 443         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 444     }
 445 
 446     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {
 447         HotSpotResolvedJavaMethodImpl method = null;
 448         if (methodCache == null) {
 449             methodCache = new HashMap&lt;&gt;(8);
 450         } else {
 451             method = methodCache.get(metaspaceMethod);
 452         }
 453         if (method == null) {
 454             method = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);
 455             methodCache.put(metaspaceMethod, method);
 456             context.add(method);
 457         }
 458         return method;
 459     }
 460 
 461     public int getVtableLength() {
 462         HotSpotVMConfig config = config();
 463         if (isInterface() || isArray()) {
 464             /* Everything has the core vtable of java.lang.Object */
 465             return config.baseVtableLength();
 466         }
 467         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 468         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + " " + config.vtableEntrySize;
 469         return result;
 470     }
 471 
 472     synchronized HotSpotResolvedJavaField createField(String fieldName, JavaType type, long offset, int rawFlags) {
 473         HotSpotResolvedJavaField result = null;
 474 
 475         final int flags = rawFlags &amp; ModifiersProvider.jvmFieldModifiers();
 476 
 477         final long id = offset + ((long) flags &lt;&lt; 32);
 478 
 479         // Must cache the fields, because the local load elimination only works if the
 480         // objects from two field lookups are identical.
 481         if (fieldCache == null) {
 482             fieldCache = new HashMap&lt;&gt;(8);
 483         } else {
 484             result = fieldCache.get(id);
 485         }
 486 
 487         if (result == null) {
 488             result = new HotSpotResolvedJavaFieldImpl(this, fieldName, type, offset, rawFlags);
 489             fieldCache.put(id, result);
 490         } else {
 491             assert result.getName().equals(fieldName);
 492             /*
 493              * Comparing the types directly is too strict, because the type in the cache could be
 494              * resolved while the incoming type is unresolved. The name comparison is sufficient
 495              * because the type will always be resolved in the context of the holder.
 496              */
 497             assert result.getType().getName().equals(type.getName());
 498             assert result.offset() == offset;
 499             assert result.getModifiers() == flags;
 500         }
 501 
 502         return result;
 503     }
 504 
 505     @Override
 506     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 507         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 508         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 509         /*
 510          * Sometimes the receiver type in the graph hasn't stabilized to a subtype of declared
 511          * holder, usually because of phis, so make sure that the type is related to the declared
 512          * type before using it for lookup. Unlinked types should also be ignored because we can't
 513          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 514          * a deopt instead since they can't really be used if they aren't linked yet.
 515          */
 516         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 517             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 518             if (result != null) {
 519                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 520             }
 521             return null;
 522         }
 523         /*
 524          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 525          * the correct method for the subtype.
 526          */
 527         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 528         if (resolvedMethod == null) {
 529             // The type isn't known to implement the method.
 530             return null;
 531         }
 532 
 533         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 534         if (result != null) {
 535             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 536         }
 537         return null;
 538     }
 539 
 540     /**
 541      * This class represents the field information for one field contained in the fields array of an
 542      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 543      */
 544     private class FieldInfo {
 545         /**
 546          * Native pointer into the array of Java shorts.
 547          */
 548         private final long metaspaceData;
 549 
 550         /**
 551          * Creates a field info for the field in the fields array at index {@code index}.
 552          *
 553          * @param index index to the fields array
 554          */
 555         FieldInfo(int index) {
 556             HotSpotVMConfig config = config();
 557             // Get Klass::_fields
 558             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 559             assert config.fieldInfoFieldSlots == 6 : "revisit the field parsing code";
 560             metaspaceData = metaspaceFields + config.arrayU2DataOffset + config.fieldInfoFieldSlots * Short.BYTES * index;
 561         }
 562 
 563         private int getAccessFlags() {
 564             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
 565         }
 566 
 567         private int getNameIndex() {
 568             return readFieldSlot(config().fieldInfoNameIndexOffset);
 569         }
 570 
 571         private int getSignatureIndex() {
 572             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
 573         }
 574 
 575         public int getOffset() {
 576             HotSpotVMConfig config = config();
 577             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
 578             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
 579             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
 580             return offset;
 581         }
 582 
 583         /**
 584          * Helper method to read an entry (slot) from the field array. Currently field info is laid
 585          * on top an array of Java shorts.
 586          */
 587         private int readFieldSlot(int index) {
 588             return UNSAFE.getChar(metaspaceData + Short.BYTES * index);
 589         }
 590 
 591         /**
 592          * Returns the name of this field as a {@link String}. If the field is an internal field the
 593          * name index is pointing into the vmSymbols table.
 594          */
 595         public String getName() {
 596             final int nameIndex = getNameIndex();
 597             return isInternal() ? HotSpotVmSymbols.symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
 598         }
 599 
 600         /**
 601          * Returns the signature of this field as {@link String}. If the field is an internal field
 602          * the signature index is pointing into the vmSymbols table.
 603          */
 604         public String getSignature() {
 605             final int signatureIndex = getSignatureIndex();
 606             return isInternal() ? HotSpotVmSymbols.symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
 607         }
 608 
 609         public JavaType getType() {
 610             String signature = getSignature();
 611             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 612         }
 613 
 614         private boolean isInternal() {
 615             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 616         }
 617 
 618         public boolean isStatic() {
 619             return Modifier.isStatic(getAccessFlags());
 620         }
 621 
 622         public boolean hasGenericSignature() {
 623             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 624         }
 625     }
 626 
 627     private static class OffsetComparator implements java.util.Comparator&lt;HotSpotResolvedJavaField&gt; {
 628         @Override
 629         public int compare(HotSpotResolvedJavaField o1, HotSpotResolvedJavaField o2) {
 630             return o1.offset() - o2.offset();
 631         }
 632     }
 633 
 634     @Override
 635     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 636         if (instanceFields == null) {
 637             if (isArray() || isInterface()) {
 638                 instanceFields = new HotSpotResolvedJavaField[0];
 639             } else {
 640                 final int fieldCount = getFieldCount();
 641                 ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 642 
 643                 for (int i = 0; i &lt; fieldCount; i++) {
 644                     FieldInfo field = new FieldInfo(i);
 645 
 646                     // We are only interested in instance fields.
 647                     if (!field.isStatic()) {
 648                         HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 649                         fieldsArray.add(resolvedJavaField);
 650                     }
 651                 }
 652 
 653                 fieldsArray.sort(new OffsetComparator());
 654 
 655                 HotSpotResolvedJavaField[] myFields = fieldsArray.toArray(new HotSpotResolvedJavaField[0]);
 656 
 657                 if (mirror() != Object.class) {
 658                     HotSpotResolvedJavaField[] superFields = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 659                     HotSpotResolvedJavaField[] fields = Arrays.copyOf(superFields, superFields.length + myFields.length);
 660                     System.arraycopy(myFields, 0, fields, superFields.length, myFields.length);
 661                     instanceFields = fields;
 662                 } else {
 663                     assert myFields.length == 0 : "java.lang.Object has fields!";
 664                     instanceFields = myFields;
 665                 }
 666 
 667             }
 668         }
 669         if (!includeSuperclasses) {
 670             int myFieldsStart = 0;
 671             while (myFieldsStart &lt; instanceFields.length &amp;&amp; !instanceFields[myFieldsStart].getDeclaringClass().equals(this)) {
 672                 myFieldsStart++;
 673             }
 674             if (myFieldsStart == 0) {
 675                 return instanceFields;
 676             }
 677             if (myFieldsStart == instanceFields.length) {
 678                 return new HotSpotResolvedJavaField[0];
 679             }
 680             return Arrays.copyOfRange(instanceFields, myFieldsStart, instanceFields.length);
 681         }
 682         return instanceFields;
 683     }
 684 
 685     @Override
 686     public ResolvedJavaField[] getStaticFields() {
 687         if (isArray()) {
 688             return new HotSpotResolvedJavaField[0];
 689         } else {
 690             final int fieldCount = getFieldCount();
 691             ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 692 
 693             for (int i = 0; i &lt; fieldCount; i++) {
 694                 FieldInfo field = new FieldInfo(i);
 695 
 696                 // We are only interested in static fields.
 697                 if (field.isStatic()) {
 698                     HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 699                     fieldsArray.add(resolvedJavaField);
 700                 }
 701             }
 702 
 703             fieldsArray.sort(new OffsetComparator());
 704             return fieldsArray.toArray(new HotSpotResolvedJavaField[fieldsArray.size()]);
 705         }
 706     }
 707 
 708     /**
 709      * Returns the actual field count of this class's internal {@code InstanceKlass::_fields} array
 710      * by walking the array and discounting the generic signature slots at the end of the array.
 711      *
 712      * &lt;p&gt;
 713      * See {@code FieldStreamBase::init_generic_signature_start_slot}
 714      */
 715     private int getFieldCount() {
 716         HotSpotVMConfig config = config();
 717         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 718         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
 719         int fieldCount = 0;
 720 
 721         for (int i = 0, index = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
 722             FieldInfo field = new FieldInfo(index);
 723             if (field.hasGenericSignature()) {
 724                 metaspaceFieldsLength--;
 725             }
 726             fieldCount++;
 727         }
 728         return fieldCount;
 729     }
 730 
 731     @Override
 732     public Class&lt;?&gt; mirror() {
 733         return javaClass;
 734     }
 735 
 736     @Override
 737     public String getSourceFileName() {
 738         HotSpotVMConfig config = config();
 739         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
 740         if (sourceFileNameIndex == 0) {
 741             return null;
 742         }
 743         return getConstantPool().lookupUtf8(sourceFileNameIndex);
 744     }
 745 
 746     @Override
 747     public Annotation[] getAnnotations() {
 748         return mirror().getAnnotations();
 749     }
 750 
 751     @Override
 752     public Annotation[] getDeclaredAnnotations() {
 753         return mirror().getDeclaredAnnotations();
 754     }
 755 
 756     @Override
 757     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 758         return mirror().getAnnotation(annotationClass);
 759     }
 760 
 761     /**
 762      * Performs a fast-path check that this type is resolved in the context of a given accessing
 763      * class. A negative result does not mean this type is not resolved with respect to
 764      * {@code accessingClass}. That can only be determined by
 765      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 766      * re-resolving} the type.
 767      */
 768     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 769         assert accessingClass != null;
 770         ResolvedJavaType elementType = getElementalType();
 771         if (elementType.isPrimitive()) {
 772             // Primitive type resolution is context free.
 773             return true;
 774         }
 775         if (elementType.getName().startsWith("Ljava/")) {
 776             // Classes in a java.* package can only be defined by the
 777             // boot class loader. This is enforced by ClassLoader.preDefineClass()
 778             assert mirror().getClassLoader() == null;
 779             return true;
 780         }
 781         ClassLoader thisCl = mirror().getClassLoader();
 782         ClassLoader accessingClassCl = ((HotSpotResolvedObjectTypeImpl) accessingClass).mirror().getClassLoader();
 783         return thisCl == accessingClassCl;
 784     }
 785 
 786     @Override
 787     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 788         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 789             return this;
 790         }
 791         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 792         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 793     }
 794 
 795     /**
 796      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 797      */
 798     public Constant klass() {
 799         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 800     }
 801 
 802     public boolean isPrimaryType() {
 803         return config().secondarySuperCacheOffset != superCheckOffset();
 804     }
 805 
 806     public int superCheckOffset() {
 807         HotSpotVMConfig config = config();
 808         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
 809     }
 810 
 811     public long prototypeMarkWord() {
 812         HotSpotVMConfig config = config();
 813         if (isArray()) {
 814             return config.arrayPrototypeMarkWord();
 815         } else {
 816             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 817         }
 818     }
 819 
 820     @Override
 821     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 822         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 823         for (ResolvedJavaField field : declaredFields) {
 824             HotSpotResolvedJavaField resolvedField = (HotSpotResolvedJavaField) field;
 825             long resolvedFieldOffset = resolvedField.offset();
 826             // @formatter:off
 827             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN  &amp;&amp;
 828                             expectedEntryKind.isPrimitive() &amp;&amp;
 829                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;
 830                             resolvedField.getJavaKind().isPrimitive()) {
 831                 resolvedFieldOffset +=
 832                                 resolvedField.getJavaKind().getByteCount() -
 833                                 Math.min(resolvedField.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());
 834             }
 835             if (resolvedFieldOffset == offset) {
 836                 return field;
 837             }
 838             // @formatter:on
 839         }
 840         return null;
 841     }
 842 
 843     @Override
 844     public boolean isLocal() {
 845         return mirror().isLocalClass();
 846     }
 847 
 848     @Override
 849     public boolean isMember() {
 850         return mirror().isMemberClass();
 851     }
 852 
 853     @Override
 854     public HotSpotResolvedObjectTypeImpl getEnclosingType() {
 855         final Class&lt;?&gt; encl = mirror().getEnclosingClass();
 856         return encl == null ? null : fromObjectClass(encl);
 857     }
 858 
 859     @Override
 860     public ResolvedJavaMethod[] getDeclaredConstructors() {
 861         Constructor&lt;?&gt;[] constructors = mirror().getDeclaredConstructors();
 862         ResolvedJavaMethod[] result = new ResolvedJavaMethod[constructors.length];
 863         for (int i = 0; i &lt; constructors.length; i++) {
 864             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(constructors[i]);
 865             assert result[i].isConstructor();
 866         }
 867         return result;
 868     }
 869 
 870     @Override
 871     public ResolvedJavaMethod[] getDeclaredMethods() {
 872         Method[] methods = mirror().getDeclaredMethods();
 873         ResolvedJavaMethod[] result = new ResolvedJavaMethod[methods.length];
 874         for (int i = 0; i &lt; methods.length; i++) {
 875             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(methods[i]);
 876             assert !result[i].isConstructor();
 877         }
 878         return result;
 879     }
 880 
 881     public ResolvedJavaMethod getClassInitializer() {
 882         return compilerToVM().getClassInitializer(this);
 883     }
 884 
 885     @Override
 886     public String toString() {
 887         return "HotSpotType&lt;" + getName() + ", resolved&gt;";
 888     }
 889 
 890     @Override
 891     public boolean isCloneableWithAllocation() {
 892         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
 893     }
 894 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="5" type="hidden" /></form></body></html>
