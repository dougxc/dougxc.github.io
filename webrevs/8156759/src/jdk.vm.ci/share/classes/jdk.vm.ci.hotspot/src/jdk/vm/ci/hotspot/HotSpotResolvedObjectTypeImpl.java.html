<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  30 
  31 import java.lang.annotation.Annotation;
  32 import java.lang.reflect.Array;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.Method;
  35 import java.lang.reflect.Modifier;
  36 import java.nio.ByteOrder;
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.HashMap;
  40 
  41 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  42 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  43 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  44 import jdk.vm.ci.meta.Assumptions.LeafType;
  45 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  46 import jdk.vm.ci.meta.Constant;
  47 import jdk.vm.ci.meta.JavaConstant;
  48 import jdk.vm.ci.meta.JavaKind;
  49 import jdk.vm.ci.meta.JavaType;
  50 import jdk.vm.ci.meta.ModifiersProvider;
  51 import jdk.vm.ci.meta.ResolvedJavaField;
  52 import jdk.vm.ci.meta.ResolvedJavaMethod;
  53 import jdk.vm.ci.meta.ResolvedJavaType;
  54 
  55 /**
  56  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.
  57  */
  58 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, HotSpotProxified, MetaspaceWrapperObject {
  59 
  60     /**
  61      * The Java class this type represents.
  62      */
  63     private final Class&lt;?&gt; javaClass;
  64     private HashMap&lt;Long, HotSpotResolvedJavaField&gt; fieldCache;
  65     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCache;
  66     private HotSpotResolvedJavaField[] instanceFields;
  67     private HotSpotResolvedObjectTypeImpl[] interfaces;
  68     private HotSpotConstantPool constantPool;
  69     final HotSpotJVMCIMetaAccessContext context;
  70     private HotSpotResolvedObjectType arrayOfType;
  71 
  72     /**
  73      * Gets the JVMCI mirror for a {@link Class} object.
  74      *
  75      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}
  76      */
  77     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {
  78         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);
  79     }
  80 
  81     /**
  82      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the
  83      * underlying Klass*, it is used instead of the raw Klass*.
  84      *
  85      * Called from the VM.
  86      *
  87      * @param javaClass a {@link Class} object
  88      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
  89      */
  90     @SuppressWarnings("unused")
  91     private static HotSpotResolvedObjectTypeImpl fromMetaspace(Class&lt;?&gt; javaClass) {
  92         return fromObjectClass(javaClass);
  93     }
  94 
  95     /**
  96      * Creates the JVMCI mirror for a {@link Class} object.
  97      *
  98      * &lt;p&gt;
  99      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
 100      * {@link Class} type. Use {@link #fromObjectClass(Class)} or {@link #fromMetaspace(Class)}
 101      * instead.
 102      * &lt;/p&gt;
 103      *
 104      * @param javaClass the Class to create the mirror for
 105      * @param context
 106      */
 107     HotSpotResolvedObjectTypeImpl(Class&lt;?&gt; javaClass, HotSpotJVMCIMetaAccessContext context) {
 108         super(getSignatureName(javaClass));
 109         this.javaClass = javaClass;
 110         this.context = context;
 111         assert getName().charAt(0) != '[' || isArray() : getName();
 112     }
 113 
 114     /**
 115      * Returns the name of this type as it would appear in a signature.
 116      */
 117     private static String getSignatureName(Class&lt;?&gt; javaClass) {
 118         if (javaClass.isArray()) {
 119             return javaClass.getName().replace('.', '/');
 120         }
 121         return "L" + javaClass.getName().replace('.', '/') + ";";
 122     }
 123 
 124     /**
 125      * Gets the metaspace Klass for this type.
 126      */
 127     long getMetaspaceKlass() {
 128         if (HotSpotJVMCIRuntime.getHostWordKind() == JavaKind.Long) {
 129             return UNSAFE.getLong(javaClass, config().klassOffset);
 130         }
 131         return UNSAFE.getInt(javaClass, config().klassOffset) &amp; 0xFFFFFFFFL;
 132     }
 133 
 134     public long getMetaspacePointer() {
 135         return getMetaspaceKlass();
 136     }
 137 
 138     @Override
 139     public int getModifiers() {
 140         if (isArray()) {
 141             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 142         } else {
 143             return getAccessFlags() &amp; ModifiersProvider.jvmClassModifiers();
 144         }
 145     }
 146 
 147     public int getAccessFlags() {
 148         HotSpotVMConfig config = config();
 149         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 150     }
 151 
 152     @Override
 153     public HotSpotResolvedObjectType getArrayClass() {
 154         if (arrayOfType == null) {
 155             arrayOfType = fromObjectClass(Array.newInstance(mirror(), 0).getClass());
 156         }
 157         return arrayOfType;
 158     }
 159 
 160     @Override
 161     public ResolvedJavaType getComponentType() {
 162         Class&lt;?&gt; javaComponentType = mirror().getComponentType();
 163         return javaComponentType == null ? null : runtime().fromClass(javaComponentType);
 164     }
 165 
 166     @Override
 167     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 168         HotSpotVMConfig config = config();
 169         if (isArray()) {
 170             return getElementalType().isLeaf() ? new AssumptionResult&lt;&gt;(this) : null;
 171         } else if (isInterface()) {
 172             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
 173             /*
 174              * If the implementor field contains itself that indicates that the interface has more
 175              * than one implementors (see: InstanceKlass::add_implementor).
 176              */
 177             if (implementor == null || implementor.equals(this)) {
 178                 return null;
 179             }
 180 
 181             assert !implementor.isInterface();
 182             if (implementor.isAbstract() || !implementor.isLeafClass()) {
 183                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
 184                 if (leafConcreteSubtype != null) {
 185                     assert !leafConcreteSubtype.getResult().equals(implementor);
 186                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
 187                     // Accumulate leaf assumptions and return the combined result.
 188                     newResult.add(leafConcreteSubtype);
 189                     return newResult;
 190                 }
 191                 return null;
 192             }
 193 
 194             return new AssumptionResult&lt;&gt;(implementor, new LeafType(implementor), new ConcreteSubtype(this, implementor));
 195         } else {
 196             HotSpotResolvedObjectTypeImpl type = this;
 197             while (type.isAbstract()) {
 198                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
 199                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
 200                     return null;
 201                 }
 202                 type = subklass;
 203             }
 204             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
 205                 return null;
 206             }
 207             if (this.isAbstract()) {
 208                 return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 209             } else {
 210                 assert this.equals(type);
 211                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 212             }
 213         }
 214     }
 215 
 216     /**
 217      * Returns if type {@code type} is a leaf class. This is the case if the
 218      * {@code Klass::_subklass} field of the underlying class is zero.
 219      *
 220      * @return true if the type is a leaf class
 221      */
 222     private boolean isLeafClass() {
 223         return getSubklass() == null;
 224     }
 225 
 226     /**
 227      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 228      * type {@code type}.
 229      *
 230      * @return value of the subklass field as metaspace klass pointer
 231      */
 232     private HotSpotResolvedObjectTypeImpl getSubklass() {
 233         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 234     }
 235 
 236     @Override
 237     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 238         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();
 239         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);
 240     }
 241 
 242     @Override
 243     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 244         if (interfaces == null) {
 245             Class&lt;?&gt;[] javaInterfaces = mirror().getInterfaces();
 246             HotSpotResolvedObjectTypeImpl[] result = new HotSpotResolvedObjectTypeImpl[javaInterfaces.length];
 247             for (int i = 0; i &lt; javaInterfaces.length; i++) {
 248                 result[i] = fromObjectClass(javaInterfaces[i]);
 249             }
 250             interfaces = result;
 251         }
 252         return interfaces;
 253     }
 254 
 255     @Override
 256     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 257         if (!isInterface()) {
 258             throw new InternalError("Cannot call getSingleImplementor() on a non-interface type: " + this);
 259         }
 260         return compilerToVM().getImplementor(this);
 261     }
 262 
 263     public HotSpotResolvedObjectTypeImpl getSupertype() {
 264         if (isArray()) {
 265             ResolvedJavaType componentType = getComponentType();
 266             if (mirror() == Object[].class || componentType.isPrimitive()) {
 267                 return fromObjectClass(Object.class);
 268             }
 269             return (HotSpotResolvedObjectTypeImpl) ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype().getArrayClass();
 270         }
 271         if (isInterface()) {
 272             return fromObjectClass(Object.class);
 273         }
 274         return getSuperclass();
 275     }
 276 
 277     @Override
 278     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 279         if (otherType.isPrimitive()) {
 280             return null;
 281         } else {
 282             HotSpotResolvedObjectTypeImpl t1 = this;
 283             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 284             while (true) {
 285                 if (t1.isAssignableFrom(t2)) {
 286                     return t1;
 287                 }
 288                 if (t2.isAssignableFrom(t1)) {
 289                     return t2;
 290                 }
 291                 t1 = t1.getSupertype();
 292                 t2 = t2.getSupertype();
 293             }
 294         }
 295     }
 296 
 297     @Override
 298     public HotSpotResolvedObjectType asExactType() {
 299         return isLeaf() ? this : null;
 300     }
 301 
 302     @Override
 303     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 304         assert !isArray();
 305         if (!compilerToVM().hasFinalizableSubclass(this)) {
 306             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 307         }
 308         return new AssumptionResult&lt;&gt;(true);
 309     }
 310 
 311     @Override
 312     public boolean hasFinalizer() {
 313         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 314     }
 315 
 316     @Override
 317     public boolean isPrimitive() {
 318         return false;
 319     }
 320 
 321     @Override
 322     public boolean isArray() {
 323         return mirror().isArray();
 324     }
 325 
 326     @Override
 327     public boolean isInitialized() {
 328         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 329     }
 330 
 331     @Override
 332     public boolean isLinked() {
 333         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 334     }
 335 
 336     /**
 337      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 338      * klass.
 339      *
 340      * @return state field value of this type
 341      */
 342     private int getInitState() {
 343         assert !isArray() : "_init_state only exists in InstanceKlass";
 344         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 345     }
 346 
 347     @Override
 348     public void initialize() {
 349         if (!isInitialized()) {
 350             UNSAFE.ensureClassInitialized(mirror());
 351             assert isInitialized();
 352         }
 353     }
 354 
 355     @Override
 356     public boolean isInstance(JavaConstant obj) {
 357         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
 358             return mirror().isInstance(((HotSpotObjectConstantImpl) obj).object());
 359         }
 360         return false;
 361     }
 362 
 363     @Override
 364     public boolean isInstanceClass() {
 365         return !isArray() &amp;&amp; !isInterface();
 366     }
 367 
 368     @Override
 369     public boolean isInterface() {
 370         return mirror().isInterface();
 371     }
 372 
 373     @Override
 374     public boolean isAssignableFrom(ResolvedJavaType other) {
 375         assert other != null;
 376         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 377             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
 378             return mirror().isAssignableFrom(otherType.mirror());
 379         }
 380         return false;
 381     }
 382 
 383     @Override
 384     public boolean isJavaLangObject() {
 385         return javaClass.equals(Object.class);
 386     }
 387 
 388     @Override
 389     public JavaKind getJavaKind() {
 390         return JavaKind.Object;
 391     }
 392 
 393     @Override
 394     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 395         assert !callerType.isArray();
 396         if (isInterface()) {
 397             // Methods can only be resolved against concrete types
 398             return null;
 399         }
 400         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic()) {
 401             return method;
 402         }
 403         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 404             return null;
 405         }
 406         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
 407         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
 408         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
 409     }
 410 
 411     public HotSpotConstantPool getConstantPool() {
 412         if (constantPool == null) {
 413             constantPool = compilerToVM().getConstantPool(this, config().instanceKlassConstantsOffset);
 414         }
 415         return constantPool;
 416     }
 417 
 418     /**
 419      * Gets the instance size of this type. If an instance of this type cannot be fast path
 420      * allocated, then the returned value is negative (its absolute value gives the size). Must not
 421      * be called if this is an array or interface type.
 422      */
 423     public int instanceSize() {
 424         assert !isArray();
 425         assert !isInterface();
 426 
 427         HotSpotVMConfig config = config();
 428         final int layoutHelper = layoutHelper();
 429         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : "must be instance";
 430 
 431         // See: Klass::layout_helper_size_in_bytes
 432         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 433 
 434         // See: Klass::layout_helper_needs_slow_path
 435         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 436 
 437         return needsSlowPath ? -size : size;
 438     }
 439 
 440     public int layoutHelper() {
 441         HotSpotVMConfig config = config();
 442         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 443     }
 444 
 445     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {
 446         HotSpotResolvedJavaMethodImpl method = null;
 447         if (methodCache == null) {
 448             methodCache = new HashMap&lt;&gt;(8);
 449         } else {
 450             method = methodCache.get(metaspaceMethod);
 451         }
 452         if (method == null) {
 453             method = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);
 454             methodCache.put(metaspaceMethod, method);
 455             context.add(method);
 456         }
 457         return method;
 458     }
 459 
 460     public int getVtableLength() {
 461         HotSpotVMConfig config = config();
 462         if (isInterface() || isArray()) {
 463             /* Everything has the core vtable of java.lang.Object */
 464             return config.baseVtableLength();
 465         }
 466         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 467         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + " " + config.vtableEntrySize;
 468         return result;
 469     }
 470 
 471     synchronized HotSpotResolvedJavaField createField(String fieldName, JavaType type, long offset, int rawFlags) {
 472         HotSpotResolvedJavaField result = null;
 473 
 474         final int flags = rawFlags &amp; ModifiersProvider.jvmFieldModifiers();
 475 
 476         final long id = offset + ((long) flags &lt;&lt; 32);
 477 
 478         // Must cache the fields, because the local load elimination only works if the
 479         // objects from two field lookups are identical.
 480         if (fieldCache == null) {
 481             fieldCache = new HashMap&lt;&gt;(8);
 482         } else {
 483             result = fieldCache.get(id);
 484         }
 485 
 486         if (result == null) {
 487             result = new HotSpotResolvedJavaFieldImpl(this, fieldName, type, offset, rawFlags);
 488             fieldCache.put(id, result);
 489         } else {
 490             assert result.getName().equals(fieldName);
 491             /*
 492              * Comparing the types directly is too strict, because the type in the cache could be
 493              * resolved while the incoming type is unresolved. The name comparison is sufficient
 494              * because the type will always be resolved in the context of the holder.
 495              */
 496             assert result.getType().getName().equals(type.getName());
 497             assert result.offset() == offset;
 498             assert result.getModifiers() == flags;
 499         }
 500 
 501         return result;
 502     }
 503 
 504     @Override
 505     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 506         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 507         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 508         /*
 509          * Sometimes the receiver type in the graph hasn't stabilized to a subtype of declared
 510          * holder, usually because of phis, so make sure that the type is related to the declared
 511          * type before using it for lookup. Unlinked types should also be ignored because we can't
 512          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 513          * a deopt instead since they can't really be used if they aren't linked yet.
 514          */
 515         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 516             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 517             if (result != null) {
 518                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 519             }
 520             return null;
 521         }
 522         /*
 523          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 524          * the correct method for the subtype.
 525          */
 526         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 527         if (resolvedMethod == null) {
 528             // The type isn't known to implement the method.
 529             return null;
 530         }
 531 
 532         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 533         if (result != null) {
 534             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 535         }
 536         return null;
 537     }
 538 
 539     /**
 540      * This class represents the field information for one field contained in the fields array of an
 541      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 542      */
 543     private class FieldInfo {
 544         /**
 545          * Native pointer into the array of Java shorts.
 546          */
 547         private final long metaspaceData;
 548 
 549         /**
 550          * Creates a field info for the field in the fields array at index {@code index}.
 551          *
 552          * @param index index to the fields array
 553          */
 554         FieldInfo(int index) {
 555             HotSpotVMConfig config = config();
 556             // Get Klass::_fields
 557             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 558             assert config.fieldInfoFieldSlots == 6 : "revisit the field parsing code";
 559             metaspaceData = metaspaceFields + config.arrayU2DataOffset + config.fieldInfoFieldSlots * Short.BYTES * index;
 560         }
 561 
 562         private int getAccessFlags() {
 563             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
 564         }
 565 
 566         private int getNameIndex() {
 567             return readFieldSlot(config().fieldInfoNameIndexOffset);
 568         }
 569 
 570         private int getSignatureIndex() {
 571             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
 572         }
 573 
 574         public int getOffset() {
 575             HotSpotVMConfig config = config();
 576             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
 577             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
 578             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
 579             return offset;
 580         }
 581 
 582         /**
 583          * Helper method to read an entry (slot) from the field array. Currently field info is laid
 584          * on top an array of Java shorts.
 585          */
 586         private int readFieldSlot(int index) {
 587             return UNSAFE.getChar(metaspaceData + Short.BYTES * index);
 588         }
 589 
 590         /**
 591          * Returns the name of this field as a {@link String}. If the field is an internal field the
 592          * name index is pointing into the vmSymbols table.
 593          */
 594         public String getName() {
 595             final int nameIndex = getNameIndex();
 596             return isInternal() ? HotSpotVmSymbols.symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
 597         }
 598 
 599         /**
 600          * Returns the signature of this field as {@link String}. If the field is an internal field
 601          * the signature index is pointing into the vmSymbols table.
 602          */
 603         public String getSignature() {
 604             final int signatureIndex = getSignatureIndex();
 605             return isInternal() ? HotSpotVmSymbols.symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
 606         }
 607 
 608         public JavaType getType() {
 609             String signature = getSignature();
 610             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 611         }
 612 
 613         private boolean isInternal() {
 614             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 615         }
 616 
 617         public boolean isStatic() {
 618             return Modifier.isStatic(getAccessFlags());
 619         }
 620 
 621         public boolean hasGenericSignature() {
 622             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 623         }
 624     }
 625 
 626     private static class OffsetComparator implements java.util.Comparator&lt;HotSpotResolvedJavaField&gt; {
 627         @Override
 628         public int compare(HotSpotResolvedJavaField o1, HotSpotResolvedJavaField o2) {
 629             return o1.offset() - o2.offset();
 630         }
 631     }
 632 
 633     @Override
 634     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 635         if (instanceFields == null) {
 636             if (isArray() || isInterface()) {
 637                 instanceFields = new HotSpotResolvedJavaField[0];
 638             } else {
 639                 final int fieldCount = getFieldCount();
 640                 ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 641 
 642                 for (int i = 0; i &lt; fieldCount; i++) {
 643                     FieldInfo field = new FieldInfo(i);
 644 
 645                     // We are only interested in instance fields.
 646                     if (!field.isStatic()) {
 647                         HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 648                         fieldsArray.add(resolvedJavaField);
 649                     }
 650                 }
 651 
 652                 fieldsArray.sort(new OffsetComparator());
 653 
 654                 HotSpotResolvedJavaField[] myFields = fieldsArray.toArray(new HotSpotResolvedJavaField[0]);
 655 
 656                 if (mirror() != Object.class) {
 657                     HotSpotResolvedJavaField[] superFields = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 658                     HotSpotResolvedJavaField[] fields = Arrays.copyOf(superFields, superFields.length + myFields.length);
 659                     System.arraycopy(myFields, 0, fields, superFields.length, myFields.length);
 660                     instanceFields = fields;
 661                 } else {
 662                     assert myFields.length == 0 : "java.lang.Object has fields!";
 663                     instanceFields = myFields;
 664                 }
 665 
 666             }
 667         }
 668         if (!includeSuperclasses) {
 669             int myFieldsStart = 0;
 670             while (myFieldsStart &lt; instanceFields.length &amp;&amp; !instanceFields[myFieldsStart].getDeclaringClass().equals(this)) {
 671                 myFieldsStart++;
 672             }
 673             if (myFieldsStart == 0) {
 674                 return instanceFields;
 675             }
 676             if (myFieldsStart == instanceFields.length) {
 677                 return new HotSpotResolvedJavaField[0];
 678             }
 679             return Arrays.copyOfRange(instanceFields, myFieldsStart, instanceFields.length);
 680         }
 681         return instanceFields;
 682     }
 683 
 684     @Override
 685     public ResolvedJavaField[] getStaticFields() {
 686         if (isArray()) {
 687             return new HotSpotResolvedJavaField[0];
 688         } else {
 689             final int fieldCount = getFieldCount();
 690             ArrayList&lt;HotSpotResolvedJavaField&gt; fieldsArray = new ArrayList&lt;&gt;(fieldCount);
 691 
 692             for (int i = 0; i &lt; fieldCount; i++) {
 693                 FieldInfo field = new FieldInfo(i);
 694 
 695                 // We are only interested in static fields.
 696                 if (field.isStatic()) {
 697                     HotSpotResolvedJavaField resolvedJavaField = createField(field.getName(), field.getType(), field.getOffset(), field.getAccessFlags());
 698                     fieldsArray.add(resolvedJavaField);
 699                 }
 700             }
 701 
 702             fieldsArray.sort(new OffsetComparator());
 703             return fieldsArray.toArray(new HotSpotResolvedJavaField[fieldsArray.size()]);
 704         }
 705     }
 706 
 707     /**
 708      * Returns the actual field count of this class's internal {@code InstanceKlass::_fields} array
 709      * by walking the array and discounting the generic signature slots at the end of the array.
 710      *
 711      * &lt;p&gt;
 712      * See {@code FieldStreamBase::init_generic_signature_start_slot}
 713      */
 714     private int getFieldCount() {
 715         HotSpotVMConfig config = config();
 716         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 717         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
 718         int fieldCount = 0;
 719 
 720         for (int i = 0, index = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
 721             FieldInfo field = new FieldInfo(index);
 722             if (field.hasGenericSignature()) {
 723                 metaspaceFieldsLength--;
 724             }
 725             fieldCount++;
 726         }
 727         return fieldCount;
 728     }
 729 
 730     @Override
 731     public Class&lt;?&gt; mirror() {
 732         return javaClass;
 733     }
 734 
 735     @Override
 736     public String getSourceFileName() {
 737         HotSpotVMConfig config = config();
 738         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
 739         if (sourceFileNameIndex == 0) {
 740             return null;
 741         }
 742         return getConstantPool().lookupUtf8(sourceFileNameIndex);
 743     }
 744 
 745     @Override
 746     public Annotation[] getAnnotations() {
 747         return mirror().getAnnotations();
 748     }
 749 
 750     @Override
 751     public Annotation[] getDeclaredAnnotations() {
 752         return mirror().getDeclaredAnnotations();
 753     }
 754 
 755     @Override
 756     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 757         return mirror().getAnnotation(annotationClass);
 758     }
 759 
 760     /**
 761      * Performs a fast-path check that this type is resolved in the context of a given accessing
 762      * class. A negative result does not mean this type is not resolved with respect to
 763      * {@code accessingClass}. That can only be determined by
 764      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 765      * re-resolving} the type.
 766      */
 767     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 768         assert accessingClass != null;
 769         ResolvedJavaType elementType = getElementalType();
 770         if (elementType.isPrimitive()) {
 771             // Primitive type resolution is context free.
 772             return true;
 773         }
 774         if (elementType.getName().startsWith("Ljava/")) {
 775             // Classes in a java.* package can only be defined by the
 776             // boot class loader. This is enforced by ClassLoader.preDefineClass()
 777             assert mirror().getClassLoader() == null;
 778             return true;
 779         }
 780         ClassLoader thisCl = mirror().getClassLoader();
 781         ClassLoader accessingClassCl = ((HotSpotResolvedObjectTypeImpl) accessingClass).mirror().getClassLoader();
 782         return thisCl == accessingClassCl;
 783     }
 784 
 785     @Override
 786     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 787         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 788             return this;
 789         }
 790         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 791         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 792     }
 793 
 794     /**
 795      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 796      */
 797     public Constant klass() {
 798         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 799     }
 800 
 801     public boolean isPrimaryType() {
 802         return config().secondarySuperCacheOffset != superCheckOffset();
 803     }
 804 
 805     public int superCheckOffset() {
 806         HotSpotVMConfig config = config();
 807         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
 808     }
 809 
 810     public long prototypeMarkWord() {
 811         HotSpotVMConfig config = config();
 812         if (isArray()) {
 813             return config.arrayPrototypeMarkWord();
 814         } else {
 815             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 816         }
 817     }
 818 
 819     @Override
 820     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 821         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 822         for (ResolvedJavaField field : declaredFields) {
 823             HotSpotResolvedJavaField resolvedField = (HotSpotResolvedJavaField) field;
 824             long resolvedFieldOffset = resolvedField.offset();
 825             // @formatter:off
 826             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN  &amp;&amp;
 827                             expectedEntryKind.isPrimitive() &amp;&amp;
 828                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;
 829                             resolvedField.getJavaKind().isPrimitive()) {
 830                 resolvedFieldOffset +=
 831                                 resolvedField.getJavaKind().getByteCount() -
 832                                 Math.min(resolvedField.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());
 833             }
 834             if (resolvedFieldOffset == offset) {
 835                 return field;
 836             }
 837             // @formatter:on
 838         }
 839         return null;
 840     }
 841 
 842     @Override
 843     public boolean isLocal() {
 844         return mirror().isLocalClass();
 845     }
 846 
 847     @Override
 848     public boolean isMember() {
 849         return mirror().isMemberClass();
 850     }
 851 
 852     @Override
 853     public HotSpotResolvedObjectTypeImpl getEnclosingType() {
 854         final Class&lt;?&gt; encl = mirror().getEnclosingClass();
 855         return encl == null ? null : fromObjectClass(encl);
 856     }
 857 
 858     @Override
 859     public ResolvedJavaMethod[] getDeclaredConstructors() {
 860         Constructor&lt;?&gt;[] constructors = mirror().getDeclaredConstructors();
 861         ResolvedJavaMethod[] result = new ResolvedJavaMethod[constructors.length];
 862         for (int i = 0; i &lt; constructors.length; i++) {
 863             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(constructors[i]);
 864             assert result[i].isConstructor();
 865         }
 866         return result;
 867     }
 868 
 869     @Override
 870     public ResolvedJavaMethod[] getDeclaredMethods() {
 871         Method[] methods = mirror().getDeclaredMethods();
 872         ResolvedJavaMethod[] result = new ResolvedJavaMethod[methods.length];
 873         for (int i = 0; i &lt; methods.length; i++) {
 874             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(methods[i]);
 875             assert !result[i].isConstructor();
 876         }
 877         return result;
 878     }
 879 
 880     public ResolvedJavaMethod getClassInitializer() {
 881         return compilerToVM().getClassInitializer(this);
 882     }
 883 
 884     @Override
 885     public String toString() {
 886         return "HotSpotType&lt;" + getName() + ", resolved&gt;";
 887     }
 888 
 889     @Override
 890     public boolean isCloneableWithAllocation() {
 891         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
 892     }
 893 }
</pre></body></html>
