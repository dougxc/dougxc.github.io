<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
<a name="1" id="anc1"></a>
  25 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  26 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  27 
  28 import java.lang.reflect.Field;
  29 import java.lang.reflect.Modifier;
  30 import java.util.HashMap;
  31 import java.util.Iterator;
  32 
<a name="2" id="anc2"></a><span class="new">  33 import jdk.internal.misc.Unsafe;</span>
  34 import jdk.internal.vm.annotation.Stable;
<a name="3" id="anc3"></a>
  35 import jdk.vm.ci.hotspotvmconfig.HotSpotVMAddress;
  36 import jdk.vm.ci.hotspotvmconfig.HotSpotVMConstant;
  37 import jdk.vm.ci.hotspotvmconfig.HotSpotVMData;
  38 import jdk.vm.ci.hotspotvmconfig.HotSpotVMField;
  39 import jdk.vm.ci.hotspotvmconfig.HotSpotVMFlag;
  40 import jdk.vm.ci.hotspotvmconfig.HotSpotVMType;
<a name="4" id="anc4"></a>
  41 
  42 //JaCoCo Exclude
  43 
  44 /**
  45  * Used to access native configuration details.
  46  *
  47  * All non-static, public fields in this class are so that they can be compiled as constants.
  48  */
  49 public class HotSpotVMConfig {
  50 
  51     /**
  52      * Gets the configuration associated with the singleton {@link HotSpotJVMCIRuntime}.
  53      */
  54     public static HotSpotVMConfig config() {
  55         return runtime().getConfig();
  56     }
  57 
  58     /**
  59      * Maximum allowed size of allocated area for a frame.
  60      */
  61     public final int maxFrameSize = 16 * 1024;
  62 
  63     public HotSpotVMConfig(CompilerToVM compilerToVm) {
  64         // Get raw pointer to the array that contains all gHotSpotVM values.
  65         final long gHotSpotVMData = compilerToVm.initializeConfiguration(this);
  66         assert gHotSpotVMData != 0;
  67 
  68         // Make FindBugs happy.
  69         jvmciHotSpotVMStructs = 0;
  70         jvmciHotSpotVMTypes = 0;
  71         jvmciHotSpotVMIntConstants = 0;
  72         jvmciHotSpotVMLongConstants = 0;
  73         jvmciHotSpotVMAddresses = 0;
  74 
  75         // Initialize the gHotSpotVM fields.
  76         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
  77             if (f.isAnnotationPresent(HotSpotVMData.class)) {
  78                 HotSpotVMData annotation = f.getAnnotation(HotSpotVMData.class);
  79                 final int index = annotation.index();
  80                 final long value = UNSAFE.getAddress(gHotSpotVMData + Unsafe.ADDRESS_SIZE * index);
  81                 try {
  82                     f.setLong(this, value);
  83                 } catch (IllegalAccessException e) {
<a name="5" id="anc5"></a><span class="changed">  84                     throw new InternalError("index " + index, e);</span>
  85                 }
  86             }
  87         }
  88 
  89         // Quick sanity check.
  90         assert jvmciHotSpotVMStructs != 0;
  91         assert jvmciHotSpotVMTypes != 0;
  92         assert jvmciHotSpotVMIntConstants != 0;
  93         assert jvmciHotSpotVMLongConstants != 0;
  94         assert jvmciHotSpotVMAddresses != 0;
  95 
  96         initialize();
  97 
  98         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift, logMinObjAlignment());
  99         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift, logKlassAlignment);
 100 
 101         assert check();
 102         assert HotSpotVMConfigVerifier.check();
 103     }
 104 
 105     @Override
 106     public String toString() {
 107         return getClass().getSimpleName();
 108     }
 109 
 110     /**
<a name="6" id="anc6"></a><span class="new"> 111      * Reads a {@code '\0'} terminated C string from native memory and converts it to a</span>
<span class="new"> 112      * {@link String}.</span>
<span class="new"> 113      *</span>
<span class="new"> 114      * @return a Java string</span>
<span class="new"> 115      */</span>
<span class="new"> 116     static String readCString(Unsafe unsafe, long address) {</span>
<span class="new"> 117         if (address == 0) {</span>
<span class="new"> 118             return null;</span>
<span class="new"> 119         }</span>
<span class="new"> 120         StringBuilder sb = new StringBuilder();</span>
<span class="new"> 121         for (int i = 0;; i++) {</span>
<span class="new"> 122             char c = (char) unsafe.getByte(address + i);</span>
<span class="new"> 123             if (c == 0) {</span>
<span class="new"> 124                 break;</span>
<span class="new"> 125             }</span>
<span class="new"> 126             sb.append(c);</span>
<span class="new"> 127         }</span>
<span class="new"> 128         return sb.toString();</span>
<span class="new"> 129     }</span>
<span class="new"> 130 </span>
<span class="new"> 131     /**</span>
 132      * Initialize fields by reading their values from vmStructs.
 133      */
 134     private void initialize() {
 135         // Fill the VM fields hash map.
 136         HashMap&lt;String, VMFields.Field&gt; vmFields = new HashMap&lt;&gt;();
 137         for (VMFields.Field e : new VMFields(jvmciHotSpotVMStructs)) {
 138             vmFields.put(e.getName(), e);
 139         }
 140 
 141         // Fill the VM types hash map.
 142         HashMap&lt;String, VMTypes.Type&gt; vmTypes = new HashMap&lt;&gt;();
 143         for (VMTypes.Type e : new VMTypes(jvmciHotSpotVMTypes)) {
 144             vmTypes.put(e.getTypeName(), e);
 145         }
 146 
 147         // Fill the VM constants hash map.
 148         HashMap&lt;String, AbstractConstant&gt; vmConstants = new HashMap&lt;&gt;();
 149         for (AbstractConstant e : new VMIntConstants(jvmciHotSpotVMIntConstants)) {
 150             vmConstants.put(e.getName(), e);
 151         }
 152         for (AbstractConstant e : new VMLongConstants(jvmciHotSpotVMLongConstants)) {
 153             vmConstants.put(e.getName(), e);
 154         }
 155 
 156         // Fill the VM addresses hash map.
 157         HashMap&lt;String, VMAddresses.Address&gt; vmAddresses = new HashMap&lt;&gt;();
 158         for (VMAddresses.Address e : new VMAddresses(jvmciHotSpotVMAddresses)) {
 159             vmAddresses.put(e.getName(), e);
 160         }
 161 
 162         // Fill the flags hash map.
 163         HashMap&lt;String, Flags.Flag&gt; flags = new HashMap&lt;&gt;();
 164         for (Flags.Flag e : new Flags(vmFields, vmTypes)) {
 165             flags.put(e.getName(), e);
 166         }
 167 
 168         String osName = getHostOSName();
 169         String osArch = getHostArchitectureName();
 170 
 171         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
 172             if (f.isAnnotationPresent(HotSpotVMField.class)) {
 173                 HotSpotVMField annotation = f.getAnnotation(HotSpotVMField.class);
 174                 String name = annotation.name();
 175                 String type = annotation.type();
 176                 VMFields.Field entry = vmFields.get(name);
 177                 if (entry == null) {
 178                     if (!isRequired(osArch, annotation.archs())) {
 179                         continue;
 180                     }
<a name="7" id="anc7"></a><span class="changed"> 181                     throw new InternalError(f.getName() + ": expected VM field not found: " + name);</span>
 182                 }
 183 
 184                 // Make sure the native type is still the type we expect.
 185                 if (!type.isEmpty()) {
 186                     if (!type.equals(entry.getTypeString())) {
<a name="8" id="anc8"></a><span class="changed"> 187                         throw new InternalError(f.getName() + ": compiler expects type " + type + " but VM field " + name + " is of type " + entry.getTypeString());</span>
 188                     }
 189                 }
 190 
 191                 switch (annotation.get()) {
 192                     case OFFSET:
 193                         setField(f, entry.getOffset());
 194                         break;
 195                     case ADDRESS:
 196                         setField(f, entry.getAddress());
 197                         break;
 198                     case VALUE:
 199                         setField(f, entry.getValue());
 200                         break;
 201                     default:
<a name="9" id="anc9"></a><span class="changed"> 202                         throw new InternalError(f.getName() + ": unknown kind: " + annotation.get());</span>
 203                 }
 204             } else if (f.isAnnotationPresent(HotSpotVMType.class)) {
 205                 HotSpotVMType annotation = f.getAnnotation(HotSpotVMType.class);
 206                 String name = annotation.name();
 207                 VMTypes.Type entry = vmTypes.get(name);
 208                 if (entry == null) {
<a name="10" id="anc10"></a><span class="changed"> 209                     throw new InternalError(f.getName() + ": expected VM type not found: " + name);</span>
 210                 }
 211 
 212                 switch (annotation.get()) {
 213                     case SIZE:
 214                         setField(f, entry.getSize());
 215                         break;
 216                     default:
<a name="11" id="anc11"></a><span class="changed"> 217                         throw new InternalError(f.getName() + ": unknown kind: " + annotation.get());</span>
 218                 }
 219             } else if (f.isAnnotationPresent(HotSpotVMConstant.class)) {
 220                 HotSpotVMConstant annotation = f.getAnnotation(HotSpotVMConstant.class);
 221                 String name = annotation.name();
 222                 AbstractConstant entry = vmConstants.get(name);
 223                 if (entry == null) {
 224                     if (!isRequired(osArch, annotation.archs())) {
 225                         continue;
 226                     }
<a name="12" id="anc12"></a><span class="changed"> 227                     throw new InternalError(f.getName() + ": expected VM constant not found: " + name);</span>
 228                 }
 229                 setField(f, entry.getValue());
 230             } else if (f.isAnnotationPresent(HotSpotVMAddress.class)) {
 231                 HotSpotVMAddress annotation = f.getAnnotation(HotSpotVMAddress.class);
 232                 String name = annotation.name();
 233                 VMAddresses.Address entry = vmAddresses.get(name);
 234                 if (entry == null) {
 235                     if (!isRequired(osName, annotation.os())) {
 236                         continue;
 237                     }
<a name="13" id="anc13"></a><span class="changed"> 238                     throw new InternalError(f.getName() + ": expected VM address not found: " + name);</span>
 239                 }
 240                 setField(f, entry.getValue());
 241             } else if (f.isAnnotationPresent(HotSpotVMFlag.class)) {
 242                 HotSpotVMFlag annotation = f.getAnnotation(HotSpotVMFlag.class);
 243                 String name = annotation.name();
 244                 Flags.Flag entry = flags.get(name);
 245                 if (entry == null) {
 246                     if (annotation.optional() || !isRequired(osArch, annotation.archs())) {
 247                         continue;
 248                     }
<a name="14" id="anc14"></a><span class="changed"> 249                     throw new InternalError(f.getName() + ": expected VM flag not found: " + name);</span>
 250 
 251                 }
 252                 setField(f, entry.getValue());
 253             }
 254         }
 255     }
 256 
 257     private final CompressEncoding oopEncoding;
 258     private final CompressEncoding klassEncoding;
 259 
 260     public CompressEncoding getOopEncoding() {
 261         return oopEncoding;
 262     }
 263 
 264     public CompressEncoding getKlassEncoding() {
 265         return klassEncoding;
 266     }
 267 
 268     private void setField(Field field, Object value) {
 269         try {
 270             Class&lt;?&gt; fieldType = field.getType();
 271             if (fieldType == boolean.class) {
 272                 if (value instanceof String) {
 273                     field.setBoolean(this, Boolean.valueOf((String) value));
 274                 } else if (value instanceof Boolean) {
 275                     field.setBoolean(this, (boolean) value);
 276                 } else if (value instanceof Long) {
 277                     field.setBoolean(this, ((long) value) != 0);
 278                 } else {
<a name="15" id="anc15"></a><span class="changed"> 279                     throw new InternalError(value.getClass().getSimpleName());</span>
 280                 }
 281             } else if (fieldType == byte.class) {
 282                 if (value instanceof Long) {
 283                     field.setByte(this, (byte) (long) value);
 284                 } else {
<a name="16" id="anc16"></a><span class="changed"> 285                     throw new InternalError(value.getClass().getSimpleName());</span>
 286                 }
 287             } else if (fieldType == int.class) {
 288                 if (value instanceof Integer) {
 289                     field.setInt(this, (int) value);
 290                 } else if (value instanceof Long) {
 291                     field.setInt(this, (int) (long) value);
 292                 } else {
<a name="17" id="anc17"></a><span class="changed"> 293                     throw new InternalError(value.getClass().getSimpleName());</span>
 294                 }
 295             } else if (fieldType == long.class) {
 296                 field.setLong(this, (long) value);
 297             } else {
<a name="18" id="anc18"></a><span class="changed"> 298                 throw new InternalError(field.toString());</span>
 299             }
 300         } catch (IllegalAccessException e) {
<a name="19" id="anc19"></a><span class="changed"> 301             throw new InternalError(String.format("%s: %s", field, e));</span>
 302         }
 303     }
 304 
 305     /**
 306      * Gets the host operating system name.
 307      */
 308     private static String getHostOSName() {
 309         String osName = System.getProperty("os.name");
 310         switch (osName) {
 311             case "Linux":
 312                 osName = "linux";
 313                 break;
 314             case "SunOS":
 315                 osName = "solaris";
 316                 break;
 317             case "Mac OS X":
 318                 osName = "bsd";
 319                 break;
 320             default:
 321                 // Of course Windows is different...
 322                 if (osName.startsWith("Windows")) {
 323                     osName = "windows";
 324                 } else {
<a name="20" id="anc20"></a><span class="changed"> 325                     throw new InternalError("Unexpected OS name: " + osName);</span>
 326                 }
 327         }
 328         return osName;
 329     }
 330 
 331     /**
 332      * Gets the host architecture name for the purpose of finding the corresponding
 333      * {@linkplain HotSpotJVMCIBackendFactory backend}.
 334      */
 335     public String getHostArchitectureName() {
 336         String arch = System.getProperty("os.arch");
 337         switch (arch) {
 338             case "x86_64":
 339                 arch = "amd64";
 340                 break;
 341             case "sparcv9":
 342                 arch = "sparc";
 343                 break;
 344         }
 345         return arch;
 346     }
 347 
 348     /**
 349      * Determines if the current specification is included in a given set of specifications.
 350      *
 351      * @param current
 352      * @param specification specifies a set of specifications, e.g. architectures or operating
 353      *            systems. A zero length value implies all.
 354      */
 355     private static boolean isRequired(String current, String[] specification) {
 356         if (specification.length == 0) {
 357             return true;
 358         }
 359         for (String arch : specification) {
 360             if (arch.equals(current)) {
 361                 return true;
 362             }
 363         }
 364         return false;
 365     }
 366 
 367     /**
 368      * VMStructEntry (see {@code vmStructs.hpp}).
 369      */
 370     @HotSpotVMData(index = 0) @Stable private long jvmciHotSpotVMStructs;
 371     @HotSpotVMData(index = 1) @Stable private long jvmciHotSpotVMStructEntryTypeNameOffset;
 372     @HotSpotVMData(index = 2) @Stable private long jvmciHotSpotVMStructEntryFieldNameOffset;
 373     @HotSpotVMData(index = 3) @Stable private long jvmciHotSpotVMStructEntryTypeStringOffset;
 374     @HotSpotVMData(index = 4) @Stable private long jvmciHotSpotVMStructEntryIsStaticOffset;
 375     @HotSpotVMData(index = 5) @Stable private long jvmciHotSpotVMStructEntryOffsetOffset;
 376     @HotSpotVMData(index = 6) @Stable private long jvmciHotSpotVMStructEntryAddressOffset;
 377     @HotSpotVMData(index = 7) @Stable private long jvmciHotSpotVMStructEntryArrayStride;
 378 
 379     final class VMFields implements Iterable&lt;VMFields.Field&gt; {
 380 
 381         private final long address;
 382 
 383         VMFields(long address) {
 384             this.address = address;
 385         }
 386 
 387         public Iterator&lt;VMFields.Field&gt; iterator() {
 388             return new Iterator&lt;VMFields.Field&gt;() {
 389 
 390                 private int index = 0;
 391 
 392                 private Field current() {
 393                     return new Field(address + jvmciHotSpotVMStructEntryArrayStride * index);
 394                 }
 395 
 396                 /**
 397                  * The last entry is identified by a NULL fieldName.
 398                  */
 399                 public boolean hasNext() {
 400                     Field entry = current();
 401                     return entry.getFieldName() != null;
 402                 }
 403 
 404                 public Field next() {
 405                     Field entry = current();
 406                     index++;
 407                     return entry;
 408                 }
 409             };
 410         }
 411 
 412         final class Field {
 413 
 414             private final long entryAddress;
 415 
 416             Field(long address) {
 417                 this.entryAddress = address;
 418             }
 419 
 420             public String getTypeName() {
 421                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeNameOffset);
 422                 return readCString(UNSAFE, typeNameAddress);
 423             }
 424 
 425             public String getFieldName() {
 426                 long fieldNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryFieldNameOffset);
 427                 return readCString(UNSAFE, fieldNameAddress);
 428             }
 429 
 430             public String getTypeString() {
 431                 long typeStringAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeStringOffset);
 432                 return readCString(UNSAFE, typeStringAddress);
 433             }
 434 
 435             public boolean isStatic() {
 436                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMStructEntryIsStaticOffset) != 0;
 437             }
 438 
 439             public long getOffset() {
 440                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMStructEntryOffsetOffset);
 441             }
 442 
 443             public long getAddress() {
 444                 return UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryAddressOffset);
 445             }
 446 
 447             public String getName() {
 448                 String typeName = getTypeName();
 449                 String fieldName = getFieldName();
 450                 return typeName + "::" + fieldName;
 451             }
 452 
 453             public long getValue() {
 454                 String type = getTypeString();
 455                 switch (type) {
 456                     case "bool":
 457                         return UNSAFE.getByte(getAddress());
 458                     case "int":
 459                         return UNSAFE.getInt(getAddress());
 460                     case "uint64_t":
 461                         return UNSAFE.getLong(getAddress());
 462                     case "address":
 463                     case "intptr_t":
 464                     case "uintptr_t":
 465                     case "size_t":
 466                         return UNSAFE.getAddress(getAddress());
 467                     default:
 468                         // All foo* types are addresses.
 469                         if (type.endsWith("*")) {
 470                             return UNSAFE.getAddress(getAddress());
 471                         }
<a name="21" id="anc21"></a><span class="changed"> 472                         throw new InternalError(type);</span>
 473                 }
 474             }
 475 
 476             @Override
 477             public String toString() {
 478                 return String.format("Field[typeName=%s, fieldName=%s, typeString=%s, isStatic=%b, offset=%d, address=0x%x]", getTypeName(), getFieldName(), getTypeString(), isStatic(), getOffset(),
 479                                 getAddress());
 480             }
 481         }
 482     }
 483 
 484     /**
 485      * VMTypeEntry (see vmStructs.hpp).
 486      */
 487     @HotSpotVMData(index = 8) @Stable private long jvmciHotSpotVMTypes;
 488     @HotSpotVMData(index = 9) @Stable private long jvmciHotSpotVMTypeEntryTypeNameOffset;
 489     @HotSpotVMData(index = 10) @Stable private long jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 490     @HotSpotVMData(index = 11) @Stable private long jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 491     @HotSpotVMData(index = 12) @Stable private long jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 492     @HotSpotVMData(index = 13) @Stable private long jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 493     @HotSpotVMData(index = 14) @Stable private long jvmciHotSpotVMTypeEntrySizeOffset;
 494     @HotSpotVMData(index = 15) @Stable private long jvmciHotSpotVMTypeEntryArrayStride;
 495 
 496     final class VMTypes implements Iterable&lt;VMTypes.Type&gt; {
 497 
 498         private final long address;
 499 
 500         VMTypes(long address) {
 501             this.address = address;
 502         }
 503 
 504         public Iterator&lt;VMTypes.Type&gt; iterator() {
 505             return new Iterator&lt;VMTypes.Type&gt;() {
 506 
 507                 private int index = 0;
 508 
 509                 private Type current() {
 510                     return new Type(address + jvmciHotSpotVMTypeEntryArrayStride * index);
 511                 }
 512 
 513                 /**
 514                  * The last entry is identified by a NULL type name.
 515                  */
 516                 public boolean hasNext() {
 517                     Type entry = current();
 518                     return entry.getTypeName() != null;
 519                 }
 520 
 521                 public Type next() {
 522                     Type entry = current();
 523                     index++;
 524                     return entry;
 525                 }
 526             };
 527         }
 528 
 529         final class Type {
 530 
 531             private final long entryAddress;
 532 
 533             Type(long address) {
 534                 this.entryAddress = address;
 535             }
 536 
 537             public String getTypeName() {
 538                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntryTypeNameOffset);
 539                 return readCString(UNSAFE, typeNameAddress);
 540             }
 541 
 542             public String getSuperclassName() {
 543                 long superclassNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntrySuperclassNameOffset);
 544                 return readCString(UNSAFE, superclassNameAddress);
 545             }
 546 
 547             public boolean isOopType() {
 548                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsOopTypeOffset) != 0;
 549             }
 550 
 551             public boolean isIntegerType() {
 552                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsIntegerTypeOffset) != 0;
 553             }
 554 
 555             public boolean isUnsigned() {
 556                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsUnsignedOffset) != 0;
 557             }
 558 
 559             public long getSize() {
 560                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMTypeEntrySizeOffset);
 561             }
 562 
 563             @Override
 564             public String toString() {
 565                 return String.format("Type[typeName=%s, superclassName=%s, isOopType=%b, isIntegerType=%b, isUnsigned=%b, size=%d]", getTypeName(), getSuperclassName(), isOopType(), isIntegerType(),
 566                                 isUnsigned(), getSize());
 567             }
 568         }
 569     }
 570 
 571     public abstract class AbstractConstant {
 572 
 573         protected final long address;
 574         protected final long nameOffset;
 575         protected final long valueOffset;
 576 
 577         AbstractConstant(long address, long nameOffset, long valueOffset) {
 578             this.address = address;
 579             this.nameOffset = nameOffset;
 580             this.valueOffset = valueOffset;
 581         }
 582 
 583         public String getName() {
 584             long nameAddress = UNSAFE.getAddress(address + nameOffset);
 585             return readCString(UNSAFE, nameAddress);
 586         }
 587 
 588         public abstract long getValue();
 589     }
 590 
 591     /**
 592      * VMIntConstantEntry (see vmStructs.hpp).
 593      */
 594     @HotSpotVMData(index = 16) @Stable private long jvmciHotSpotVMIntConstants;
 595     @HotSpotVMData(index = 17) @Stable private long jvmciHotSpotVMIntConstantEntryNameOffset;
 596     @HotSpotVMData(index = 18) @Stable private long jvmciHotSpotVMIntConstantEntryValueOffset;
 597     @HotSpotVMData(index = 19) @Stable private long jvmciHotSpotVMIntConstantEntryArrayStride;
 598 
 599     final class VMIntConstants implements Iterable&lt;VMIntConstants.Constant&gt; {
 600 
 601         private final long address;
 602 
 603         VMIntConstants(long address) {
 604             this.address = address;
 605         }
 606 
 607         public Iterator&lt;VMIntConstants.Constant&gt; iterator() {
 608             return new Iterator&lt;VMIntConstants.Constant&gt;() {
 609 
 610                 private int index = 0;
 611 
 612                 private Constant current() {
 613                     return new Constant(address + jvmciHotSpotVMIntConstantEntryArrayStride * index);
 614                 }
 615 
 616                 /**
 617                  * The last entry is identified by a NULL name.
 618                  */
 619                 public boolean hasNext() {
 620                     Constant entry = current();
 621                     return entry.getName() != null;
 622                 }
 623 
 624                 public Constant next() {
 625                     Constant entry = current();
 626                     index++;
 627                     return entry;
 628                 }
 629             };
 630         }
 631 
 632         final class Constant extends AbstractConstant {
 633 
 634             Constant(long address) {
 635                 super(address, jvmciHotSpotVMIntConstantEntryNameOffset, jvmciHotSpotVMIntConstantEntryValueOffset);
 636             }
 637 
 638             @Override
 639             public long getValue() {
 640                 return UNSAFE.getInt(address + valueOffset);
 641             }
 642 
 643             @Override
 644             public String toString() {
 645                 return String.format("IntConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 646             }
 647         }
 648     }
 649 
 650     /**
 651      * VMLongConstantEntry (see vmStructs.hpp).
 652      */
 653     @HotSpotVMData(index = 20) @Stable private long jvmciHotSpotVMLongConstants;
 654     @HotSpotVMData(index = 21) @Stable private long jvmciHotSpotVMLongConstantEntryNameOffset;
 655     @HotSpotVMData(index = 22) @Stable private long jvmciHotSpotVMLongConstantEntryValueOffset;
 656     @HotSpotVMData(index = 23) @Stable private long jvmciHotSpotVMLongConstantEntryArrayStride;
 657 
 658     final class VMLongConstants implements Iterable&lt;VMLongConstants.Constant&gt; {
 659 
 660         private final long address;
 661 
 662         VMLongConstants(long address) {
 663             this.address = address;
 664         }
 665 
 666         public Iterator&lt;VMLongConstants.Constant&gt; iterator() {
 667             return new Iterator&lt;VMLongConstants.Constant&gt;() {
 668 
 669                 private int index = 0;
 670 
 671                 private Constant currentEntry() {
 672                     return new Constant(address + jvmciHotSpotVMLongConstantEntryArrayStride * index);
 673                 }
 674 
 675                 /**
 676                  * The last entry is identified by a NULL name.
 677                  */
 678                 public boolean hasNext() {
 679                     Constant entry = currentEntry();
 680                     return entry.getName() != null;
 681                 }
 682 
 683                 public Constant next() {
 684                     Constant entry = currentEntry();
 685                     index++;
 686                     return entry;
 687                 }
 688             };
 689         }
 690 
 691         final class Constant extends AbstractConstant {
 692 
 693             Constant(long address) {
 694                 super(address, jvmciHotSpotVMLongConstantEntryNameOffset, jvmciHotSpotVMLongConstantEntryValueOffset);
 695             }
 696 
 697             @Override
 698             public long getValue() {
 699                 return UNSAFE.getLong(address + valueOffset);
 700             }
 701 
 702             @Override
 703             public String toString() {
 704                 return String.format("LongConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 705             }
 706         }
 707     }
 708 
 709     /**
 710      * VMAddressEntry (see vmStructs.hpp).
 711      */
 712     @HotSpotVMData(index = 24) @Stable private long jvmciHotSpotVMAddresses;
 713     @HotSpotVMData(index = 25) @Stable private long jvmciHotSpotVMAddressEntryNameOffset;
 714     @HotSpotVMData(index = 26) @Stable private long jvmciHotSpotVMAddressEntryValueOffset;
 715     @HotSpotVMData(index = 27) @Stable private long jvmciHotSpotVMAddressEntryArrayStride;
 716 
 717     final class VMAddresses implements Iterable&lt;VMAddresses.Address&gt; {
 718 
 719         private final long address;
 720 
 721         VMAddresses(long address) {
 722             this.address = address;
 723         }
 724 
 725         public Iterator&lt;VMAddresses.Address&gt; iterator() {
 726             return new Iterator&lt;VMAddresses.Address&gt;() {
 727 
 728                 private int index = 0;
 729 
 730                 private Address currentEntry() {
 731                     return new Address(address + jvmciHotSpotVMAddressEntryArrayStride * index);
 732                 }
 733 
 734                 /**
 735                  * The last entry is identified by a NULL name.
 736                  */
 737                 public boolean hasNext() {
 738                     Address entry = currentEntry();
 739                     return entry.getName() != null;
 740                 }
 741 
 742                 public Address next() {
 743                     Address entry = currentEntry();
 744                     index++;
 745                     return entry;
 746                 }
 747             };
 748         }
 749 
 750         final class Address extends AbstractConstant {
 751 
 752             Address(long address) {
 753                 super(address, jvmciHotSpotVMAddressEntryNameOffset, jvmciHotSpotVMAddressEntryValueOffset);
 754             }
 755 
 756             @Override
 757             public long getValue() {
 758                 return UNSAFE.getLong(address + valueOffset);
 759             }
 760 
 761             @Override
 762             public String toString() {
 763                 return String.format("Address[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 764             }
 765         }
 766     }
 767 
 768     final class Flags implements Iterable&lt;Flags.Flag&gt; {
 769 
 770         private final long address;
 771         private final long entrySize;
 772         private final long typeOffset;
 773         private final long nameOffset;
 774         private final long addrOffset;
 775 
 776         Flags(HashMap&lt;String, VMFields.Field&gt; vmStructs, HashMap&lt;String, VMTypes.Type&gt; vmTypes) {
 777             address = vmStructs.get("Flag::flags").getValue();
 778             entrySize = vmTypes.get("Flag").getSize();
 779             typeOffset = vmStructs.get("Flag::_type").getOffset();
 780             nameOffset = vmStructs.get("Flag::_name").getOffset();
 781             addrOffset = vmStructs.get("Flag::_addr").getOffset();
 782 
 783             assert vmTypes.get("bool").getSize() == Byte.BYTES;
 784             assert vmTypes.get("intx").getSize() == Long.BYTES;
 785             assert vmTypes.get("uintx").getSize() == Long.BYTES;
 786         }
 787 
 788         public Iterator&lt;Flags.Flag&gt; iterator() {
 789             return new Iterator&lt;Flags.Flag&gt;() {
 790 
 791                 private int index = 0;
 792 
 793                 private Flag current() {
 794                     return new Flag(address + entrySize * index);
 795                 }
 796 
 797                 /**
 798                  * The last entry is identified by a NULL name.
 799                  */
 800                 public boolean hasNext() {
 801                     Flag entry = current();
 802                     return entry.getName() != null;
 803                 }
 804 
 805                 public Flag next() {
 806                     Flag entry = current();
 807                     index++;
 808                     return entry;
 809                 }
 810             };
 811         }
 812 
 813         final class Flag {
 814 
 815             private final long entryAddress;
 816 
 817             Flag(long address) {
 818                 this.entryAddress = address;
 819             }
 820 
 821             public String getType() {
 822                 long typeAddress = UNSAFE.getAddress(entryAddress + typeOffset);
 823                 return readCString(UNSAFE, typeAddress);
 824             }
 825 
 826             public String getName() {
 827                 long nameAddress = UNSAFE.getAddress(entryAddress + nameOffset);
 828                 return readCString(UNSAFE, nameAddress);
 829             }
 830 
 831             public long getAddr() {
 832                 return UNSAFE.getAddress(entryAddress + addrOffset);
 833             }
 834 
 835             public Object getValue() {
 836                 switch (getType()) {
 837                     case "bool":
 838                         return Boolean.valueOf(UNSAFE.getByte(getAddr()) != 0);
 839                     case "intx":
 840                     case "uintx":
 841                     case "uint64_t":
 842                         return Long.valueOf(UNSAFE.getLong(getAddr()));
 843                     case "double":
 844                         return Double.valueOf(UNSAFE.getDouble(getAddr()));
 845                     case "ccstr":
 846                     case "ccstrlist":
 847                         return readCString(UNSAFE, getAddr());
 848                     default:
<a name="22" id="anc22"></a><span class="changed"> 849                         throw new InternalError(getType());</span>
 850                 }
 851             }
 852 
 853             @Override
 854             public String toString() {
 855                 return String.format("Flag[type=%s, name=%s, value=%s]", getType(), getName(), getValue());
 856             }
 857         }
 858     }
 859 
 860     @HotSpotVMConstant(name = "ASSERT") @Stable public boolean cAssertions;
 861     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
 862     public final boolean linuxOs = System.getProperty("os.name", "").startsWith("Linux");
 863 
 864     @HotSpotVMFlag(name = "CodeEntryAlignment") @Stable public int codeEntryAlignment;
 865     @HotSpotVMFlag(name = "VerifyOops") @Stable public boolean verifyOops;
 866     @HotSpotVMFlag(name = "CITime") @Stable public boolean ciTime;
 867     @HotSpotVMFlag(name = "CITimeEach") @Stable public boolean ciTimeEach;
 868     @HotSpotVMFlag(name = "CompileTheWorldStartAt", optional = true) @Stable public int compileTheWorldStartAt;
 869     @HotSpotVMFlag(name = "CompileTheWorldStopAt", optional = true) @Stable public int compileTheWorldStopAt;
 870     @HotSpotVMFlag(name = "DontCompileHugeMethods") @Stable public boolean dontCompileHugeMethods;
 871     @HotSpotVMFlag(name = "HugeMethodLimit") @Stable public int hugeMethodLimit;
 872     @HotSpotVMFlag(name = "PrintInlining") @Stable public boolean printInlining;
 873     @HotSpotVMFlag(name = "Inline") @Stable public boolean inline;
 874     @HotSpotVMFlag(name = "JVMCIUseFastLocking") @Stable public boolean useFastLocking;
 875     @HotSpotVMFlag(name = "ForceUnreachable") @Stable public boolean forceUnreachable;
 876     @HotSpotVMFlag(name = "CodeCacheSegmentSize") @Stable public int codeSegmentSize;
 877     @HotSpotVMFlag(name = "FoldStableValues") @Stable public boolean foldStableValues;
 878 
 879     @HotSpotVMFlag(name = "UseTLAB") @Stable public boolean useTLAB;
 880     @HotSpotVMFlag(name = "UseBiasedLocking") @Stable public boolean useBiasedLocking;
 881     @HotSpotVMFlag(name = "UsePopCountInstruction") @Stable public boolean usePopCountInstruction;
 882     @HotSpotVMFlag(name = "UseCountLeadingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountLeadingZerosInstruction;
 883     @HotSpotVMFlag(name = "UseCountTrailingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountTrailingZerosInstruction;
 884     @HotSpotVMFlag(name = "UseAESIntrinsics") @Stable public boolean useAESIntrinsics;
 885     @HotSpotVMFlag(name = "UseCRC32Intrinsics") @Stable public boolean useCRC32Intrinsics;
 886     @HotSpotVMFlag(name = "UseG1GC") @Stable public boolean useG1GC;
 887     @HotSpotVMFlag(name = "UseConcMarkSweepGC") @Stable public boolean useCMSGC;
 888 
 889     @HotSpotVMFlag(name = "AllocatePrefetchStyle") @Stable public int allocatePrefetchStyle;
 890     @HotSpotVMFlag(name = "AllocatePrefetchInstr") @Stable public int allocatePrefetchInstr;
 891     @HotSpotVMFlag(name = "AllocatePrefetchLines") @Stable public int allocatePrefetchLines;
 892     @HotSpotVMFlag(name = "AllocateInstancePrefetchLines") @Stable public int allocateInstancePrefetchLines;
 893     @HotSpotVMFlag(name = "AllocatePrefetchStepSize") @Stable public int allocatePrefetchStepSize;
 894     @HotSpotVMFlag(name = "AllocatePrefetchDistance") @Stable public int allocatePrefetchDistance;
 895 
 896     @HotSpotVMFlag(name = "FlightRecorder", optional = true) @Stable public boolean flightRecorder;
 897 
 898     @HotSpotVMField(name = "CompilerToVM::Data::Universe_collectedHeap", type = "CollectedHeap*", get = HotSpotVMField.Type.VALUE) @Stable private long universeCollectedHeap;
 899     @HotSpotVMField(name = "CollectedHeap::_total_collections", type = "unsigned int", get = HotSpotVMField.Type.OFFSET) @Stable private int collectedHeapTotalCollectionsOffset;
 900 
 901     public long gcTotalCollectionsAddress() {
 902         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
 903     }
 904 
 905     @HotSpotVMFlag(name = "ReduceInitialCardMarks") @Stable public boolean useDeferredInitBarriers;
 906 
 907     // Compressed Oops related values.
 908     @HotSpotVMFlag(name = "UseCompressedOops") @Stable public boolean useCompressedOops;
 909     @HotSpotVMFlag(name = "UseCompressedClassPointers") @Stable public boolean useCompressedClassPointers;
 910 
 911     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowOopBase;
 912     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowOopShift;
 913     @HotSpotVMFlag(name = "ObjectAlignmentInBytes") @Stable public int objectAlignment;
 914 
 915     public final int minObjAlignment() {
 916         return objectAlignment / heapWordSize;
 917     }
 918 
 919     public final int logMinObjAlignment() {
 920         return (int) (Math.log(objectAlignment) / Math.log(2));
 921     }
 922 
 923     @HotSpotVMType(name = "narrowKlass", get = HotSpotVMType.Type.SIZE) @Stable public int narrowKlassSize;
 924     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowKlassBase;
 925     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowKlassShift;
 926     @HotSpotVMConstant(name = "LogKlassAlignmentInBytes") @Stable public int logKlassAlignment;
 927 
 928     // CPU capabilities
 929     @HotSpotVMFlag(name = "UseSSE") @Stable public int useSSE;
 930     @HotSpotVMFlag(name = "UseAVX", archs = {"amd64"}) @Stable public int useAVX;
 931 
 932     @HotSpotVMField(name = "Abstract_VM_Version::_features", type = "uint64_t", get = HotSpotVMField.Type.VALUE) @Stable public long vmVersionFeatures;
 933 
 934     // AMD64 specific values
 935     @HotSpotVMConstant(name = "VM_Version::CPU_CX8", archs = {"amd64"}) @Stable public long amd64CX8;
 936     @HotSpotVMConstant(name = "VM_Version::CPU_CMOV", archs = {"amd64"}) @Stable public long amd64CMOV;
 937     @HotSpotVMConstant(name = "VM_Version::CPU_FXSR", archs = {"amd64"}) @Stable public long amd64FXSR;
 938     @HotSpotVMConstant(name = "VM_Version::CPU_HT", archs = {"amd64"}) @Stable public long amd64HT;
 939     @HotSpotVMConstant(name = "VM_Version::CPU_MMX", archs = {"amd64"}) @Stable public long amd64MMX;
 940     @HotSpotVMConstant(name = "VM_Version::CPU_3DNOW_PREFETCH", archs = {"amd64"}) @Stable public long amd643DNOWPREFETCH;
 941     @HotSpotVMConstant(name = "VM_Version::CPU_SSE", archs = {"amd64"}) @Stable public long amd64SSE;
 942     @HotSpotVMConstant(name = "VM_Version::CPU_SSE2", archs = {"amd64"}) @Stable public long amd64SSE2;
 943     @HotSpotVMConstant(name = "VM_Version::CPU_SSE3", archs = {"amd64"}) @Stable public long amd64SSE3;
 944     @HotSpotVMConstant(name = "VM_Version::CPU_SSSE3", archs = {"amd64"}) @Stable public long amd64SSSE3;
 945     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4A", archs = {"amd64"}) @Stable public long amd64SSE4A;
 946     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_1", archs = {"amd64"}) @Stable public long amd64SSE41;
 947     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_2", archs = {"amd64"}) @Stable public long amd64SSE42;
 948     @HotSpotVMConstant(name = "VM_Version::CPU_POPCNT", archs = {"amd64"}) @Stable public long amd64POPCNT;
 949     @HotSpotVMConstant(name = "VM_Version::CPU_LZCNT", archs = {"amd64"}) @Stable public long amd64LZCNT;
 950     @HotSpotVMConstant(name = "VM_Version::CPU_TSC", archs = {"amd64"}) @Stable public long amd64TSC;
 951     @HotSpotVMConstant(name = "VM_Version::CPU_TSCINV", archs = {"amd64"}) @Stable public long amd64TSCINV;
 952     @HotSpotVMConstant(name = "VM_Version::CPU_AVX", archs = {"amd64"}) @Stable public long amd64AVX;
 953     @HotSpotVMConstant(name = "VM_Version::CPU_AVX2", archs = {"amd64"}) @Stable public long amd64AVX2;
 954     @HotSpotVMConstant(name = "VM_Version::CPU_AES", archs = {"amd64"}) @Stable public long amd64AES;
 955     @HotSpotVMConstant(name = "VM_Version::CPU_ERMS", archs = {"amd64"}) @Stable public long amd64ERMS;
 956     @HotSpotVMConstant(name = "VM_Version::CPU_CLMUL", archs = {"amd64"}) @Stable public long amd64CLMUL;
 957     @HotSpotVMConstant(name = "VM_Version::CPU_BMI1", archs = {"amd64"}) @Stable public long amd64BMI1;
 958     @HotSpotVMConstant(name = "VM_Version::CPU_BMI2", archs = {"amd64"}) @Stable public long amd64BMI2;
 959     @HotSpotVMConstant(name = "VM_Version::CPU_RTM", archs = {"amd64"}) @Stable public long amd64RTM;
 960     @HotSpotVMConstant(name = "VM_Version::CPU_ADX", archs = {"amd64"}) @Stable public long amd64ADX;
 961     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512F", archs = {"amd64"}) @Stable public long amd64AVX512F;
 962     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512DQ", archs = {"amd64"}) @Stable public long amd64AVX512DQ;
 963     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512PF", archs = {"amd64"}) @Stable public long amd64AVX512PF;
 964     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512ER", archs = {"amd64"}) @Stable public long amd64AVX512ER;
 965     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512CD", archs = {"amd64"}) @Stable public long amd64AVX512CD;
 966     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512BW", archs = {"amd64"}) @Stable public long amd64AVX512BW;
 967     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512VL", archs = {"amd64"}) @Stable public long amd64AVX512VL;
 968     @HotSpotVMConstant(name = "VM_Version::CPU_SHA", archs = {"amd64"}) @Stable public long amd64SHA;
 969 
 970     // SPARC specific values
 971     @HotSpotVMConstant(name = "VM_Version::vis3_instructions_m", archs = {"sparc"}) @Stable public int sparcVis3Instructions;
 972     @HotSpotVMConstant(name = "VM_Version::vis2_instructions_m", archs = {"sparc"}) @Stable public int sparcVis2Instructions;
 973     @HotSpotVMConstant(name = "VM_Version::vis1_instructions_m", archs = {"sparc"}) @Stable public int sparcVis1Instructions;
 974     @HotSpotVMConstant(name = "VM_Version::cbcond_instructions_m", archs = {"sparc"}) @Stable public int sparcCbcondInstructions;
 975     @HotSpotVMConstant(name = "VM_Version::v8_instructions_m", archs = {"sparc"}) @Stable public int sparcV8Instructions;
 976     @HotSpotVMConstant(name = "VM_Version::hardware_mul32_m", archs = {"sparc"}) @Stable public int sparcHardwareMul32;
 977     @HotSpotVMConstant(name = "VM_Version::hardware_div32_m", archs = {"sparc"}) @Stable public int sparcHardwareDiv32;
 978     @HotSpotVMConstant(name = "VM_Version::hardware_fsmuld_m", archs = {"sparc"}) @Stable public int sparcHardwareFsmuld;
 979     @HotSpotVMConstant(name = "VM_Version::hardware_popc_m", archs = {"sparc"}) @Stable public int sparcHardwarePopc;
 980     @HotSpotVMConstant(name = "VM_Version::v9_instructions_m", archs = {"sparc"}) @Stable public int sparcV9Instructions;
 981     @HotSpotVMConstant(name = "VM_Version::sun4v_m", archs = {"sparc"}) @Stable public int sparcSun4v;
 982     @HotSpotVMConstant(name = "VM_Version::blk_init_instructions_m", archs = {"sparc"}) @Stable public int sparcBlkInitInstructions;
 983     @HotSpotVMConstant(name = "VM_Version::fmaf_instructions_m", archs = {"sparc"}) @Stable public int sparcFmafInstructions;
 984     @HotSpotVMConstant(name = "VM_Version::fmau_instructions_m", archs = {"sparc"}) @Stable public int sparcFmauInstructions;
 985     @HotSpotVMConstant(name = "VM_Version::sparc64_family_m", archs = {"sparc"}) @Stable public int sparcSparc64Family;
 986     @HotSpotVMConstant(name = "VM_Version::M_family_m", archs = {"sparc"}) @Stable public int sparcMFamily;
 987     @HotSpotVMConstant(name = "VM_Version::T_family_m", archs = {"sparc"}) @Stable public int sparcTFamily;
 988     @HotSpotVMConstant(name = "VM_Version::T1_model_m", archs = {"sparc"}) @Stable public int sparcT1Model;
 989     @HotSpotVMConstant(name = "VM_Version::sparc5_instructions_m", archs = {"sparc"}) @Stable public int sparcSparc5Instructions;
 990     @HotSpotVMConstant(name = "VM_Version::aes_instructions_m", archs = {"sparc"}) @Stable public int sparcAesInstructions;
 991     @HotSpotVMConstant(name = "VM_Version::sha1_instruction_m", archs = {"sparc"}) @Stable public int sparcSha1Instruction;
 992     @HotSpotVMConstant(name = "VM_Version::sha256_instruction_m", archs = {"sparc"}) @Stable public int sparcSha256Instruction;
 993     @HotSpotVMConstant(name = "VM_Version::sha512_instruction_m", archs = {"sparc"}) @Stable public int sparcSha512Instruction;
 994 
 995     @HotSpotVMFlag(name = "UseBlockZeroing", archs = {"sparc"}) @Stable public boolean useBlockZeroing;
 996     @HotSpotVMFlag(name = "BlockZeroingLowLimit", archs = {"sparc"}) @Stable public int blockZeroingLowLimit;
 997 
 998     @HotSpotVMFlag(name = "StackShadowPages") @Stable public int stackShadowPages;
 999     @HotSpotVMFlag(name = "StackReservedPages") @Stable public int stackReservedPages;
1000     @HotSpotVMFlag(name = "UseStackBanging") @Stable public boolean useStackBanging;
1001     @HotSpotVMConstant(name = "STACK_BIAS") @Stable public int stackBias;
1002     @HotSpotVMField(name = "CompilerToVM::Data::vm_page_size", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int vmPageSize;
1003 
1004     // offsets, ...
1005     @HotSpotVMField(name = "oopDesc::_mark", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int markOffset;
1006     @HotSpotVMField(name = "oopDesc::_metadata._klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int hubOffset;
1007 
1008     @HotSpotVMField(name = "Klass::_prototype_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int prototypeMarkWordOffset;
1009     @HotSpotVMField(name = "Klass::_subklass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int subklassOffset;
1010     @HotSpotVMField(name = "Klass::_next_sibling", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int nextSiblingOffset;
1011     @HotSpotVMField(name = "Klass::_super_check_offset", type = "juint", get = HotSpotVMField.Type.OFFSET) @Stable public int superCheckOffsetOffset;
1012     @HotSpotVMField(name = "Klass::_secondary_super_cache", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySuperCacheOffset;
1013     @HotSpotVMField(name = "Klass::_secondary_supers", type = "Array&lt;Klass*&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySupersOffset;
1014 
1015     /**
1016      * The offset of the _java_mirror field (of type {@link Class}) in a Klass.
1017      */
1018     @HotSpotVMField(name = "Klass::_java_mirror", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int classMirrorOffset;
1019 
1020     @HotSpotVMField(name = "Klass::_super", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int klassSuperKlassOffset;
1021     @HotSpotVMField(name = "Klass::_modifier_flags", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassModifierFlagsOffset;
1022     @HotSpotVMField(name = "Klass::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int klassAccessFlagsOffset;
1023     @HotSpotVMField(name = "Klass::_layout_helper", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassLayoutHelperOffset;
1024     @HotSpotVMField(name = "Klass::_name", type = "Symbol*", get = HotSpotVMField.Type.OFFSET) @Stable public int klassNameOffset;
1025 
1026     @HotSpotVMConstant(name = "Klass::_lh_neutral_value") @Stable public int klassLayoutHelperNeutralValue;
1027     @HotSpotVMConstant(name = "Klass::_lh_instance_slow_path_bit") @Stable public int klassLayoutHelperInstanceSlowPathBit;
1028     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_shift") @Stable public int layoutHelperLog2ElementSizeShift;
1029     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_mask") @Stable public int layoutHelperLog2ElementSizeMask;
1030     @HotSpotVMConstant(name = "Klass::_lh_element_type_shift") @Stable public int layoutHelperElementTypeShift;
1031     @HotSpotVMConstant(name = "Klass::_lh_element_type_mask") @Stable public int layoutHelperElementTypeMask;
1032     @HotSpotVMConstant(name = "Klass::_lh_header_size_shift") @Stable public int layoutHelperHeaderSizeShift;
1033     @HotSpotVMConstant(name = "Klass::_lh_header_size_mask") @Stable public int layoutHelperHeaderSizeMask;
1034     @HotSpotVMConstant(name = "Klass::_lh_array_tag_shift") @Stable public int layoutHelperArrayTagShift;
1035     @HotSpotVMConstant(name = "Klass::_lh_array_tag_type_value") @Stable public int layoutHelperArrayTagTypeValue;
1036     @HotSpotVMConstant(name = "Klass::_lh_array_tag_obj_value") @Stable public int layoutHelperArrayTagObjectValue;
1037 
1038     /**
1039      * This filters out the bit that differentiates a type array from an object array.
1040      */
1041     public int layoutHelperElementTypePrimitiveInPlace() {
1042         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
1043     }
1044 
1045     /**
1046      * Bit pattern in the klass layout helper that can be used to identify arrays.
1047      */
1048     public final int arrayKlassLayoutHelperIdentifier = 0x80000000;
1049 
1050     @HotSpotVMType(name = "vtableEntry", get = HotSpotVMType.Type.SIZE) @Stable public int vtableEntrySize;
1051     @HotSpotVMField(name = "vtableEntry::_method", type = "Method*", get = HotSpotVMField.Type.OFFSET) @Stable public int vtableEntryMethodOffset;
1052 
1053     @HotSpotVMType(name = "InstanceKlass", get = HotSpotVMType.Type.SIZE) @Stable public int instanceKlassSize;
1054     @HotSpotVMField(name = "InstanceKlass::_source_file_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassSourceFileNameIndexOffset;
1055     @HotSpotVMField(name = "InstanceKlass::_init_state", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassInitStateOffset;
1056     @HotSpotVMField(name = "InstanceKlass::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassConstantsOffset;
1057     @HotSpotVMField(name = "InstanceKlass::_fields", type = "Array&lt;u2&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassFieldsOffset;
1058     @HotSpotVMField(name = "CompilerToVM::Data::Klass_vtable_start_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassVtableStartOffset;
1059     @HotSpotVMField(name = "CompilerToVM::Data::Klass_vtable_length_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassVtableLengthOffset;
1060 
1061     @HotSpotVMConstant(name = "InstanceKlass::linked") @Stable public int instanceKlassStateLinked;
1062     @HotSpotVMConstant(name = "InstanceKlass::fully_initialized") @Stable public int instanceKlassStateFullyInitialized;
1063 
1064     @HotSpotVMType(name = "arrayOopDesc", get = HotSpotVMType.Type.SIZE) @Stable public int arrayOopDescSize;
1065 
1066     /**
1067      * The offset of the array length word in an array object's header.
1068      *
1069      * See {@code arrayOopDesc::length_offset_in_bytes()}.
1070      */
1071     public final int arrayOopDescLengthOffset() {
1072         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
1073     }
1074 
1075     @HotSpotVMField(name = "Array&lt;int&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1LengthOffset;
1076     @HotSpotVMField(name = "Array&lt;u1&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1DataOffset;
1077     @HotSpotVMField(name = "Array&lt;u2&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU2DataOffset;
1078     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayLengthOffset;
1079     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_data[0]", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayBaseOffset;
1080 
1081     @HotSpotVMField(name = "ObjArrayKlass::_element_klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayClassElementOffset;
1082 
1083     @HotSpotVMConstant(name = "FieldInfo::access_flags_offset") @Stable public int fieldInfoAccessFlagsOffset;
1084     @HotSpotVMConstant(name = "FieldInfo::name_index_offset") @Stable public int fieldInfoNameIndexOffset;
1085     @HotSpotVMConstant(name = "FieldInfo::signature_index_offset") @Stable public int fieldInfoSignatureIndexOffset;
1086     @HotSpotVMConstant(name = "FieldInfo::initval_index_offset") @Stable public int fieldInfoInitvalIndexOffset;
1087     @HotSpotVMConstant(name = "FieldInfo::low_packed_offset") @Stable public int fieldInfoLowPackedOffset;
1088     @HotSpotVMConstant(name = "FieldInfo::high_packed_offset") @Stable public int fieldInfoHighPackedOffset;
1089     @HotSpotVMConstant(name = "FieldInfo::field_slots") @Stable public int fieldInfoFieldSlots;
1090 
1091     @HotSpotVMConstant(name = "FIELDINFO_TAG_SIZE") @Stable public int fieldInfoTagSize;
1092 
1093     @HotSpotVMConstant(name = "JVM_ACC_MONITOR_MATCH") @Stable public int jvmAccMonitorMatch;
1094     @HotSpotVMConstant(name = "JVM_ACC_HAS_MONITOR_BYTECODES") @Stable public int jvmAccHasMonitorBytecodes;
1095     @HotSpotVMConstant(name = "JVM_ACC_HAS_FINALIZER") @Stable public int jvmAccHasFinalizer;
1096     @HotSpotVMConstant(name = "JVM_ACC_FIELD_INTERNAL") @Stable public int jvmAccFieldInternal;
1097     @HotSpotVMConstant(name = "JVM_ACC_FIELD_STABLE") @Stable public int jvmAccFieldStable;
1098     @HotSpotVMConstant(name = "JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE") @Stable public int jvmAccFieldHasGenericSignature;
1099     @HotSpotVMConstant(name = "JVM_ACC_WRITTEN_FLAGS") @Stable public int jvmAccWrittenFlags;
1100     @HotSpotVMConstant(name = "JVM_ACC_IS_CLONEABLE_FAST") @Stable public int jvmAccIsCloneableFast;
1101 
1102     // Modifier.SYNTHETIC is not public so we get it via vmStructs.
1103     @HotSpotVMConstant(name = "JVM_ACC_SYNTHETIC") @Stable public int jvmAccSynthetic;
1104 
1105     /**
1106      * @see HotSpotResolvedObjectTypeImpl#createField
1107      */
1108     @HotSpotVMConstant(name = "JVM_RECOGNIZED_FIELD_MODIFIERS") @Stable public int recognizedFieldModifiers;
1109 
1110     @HotSpotVMField(name = "Thread::_tlab", type = "ThreadLocalAllocBuffer", get = HotSpotVMField.Type.OFFSET) @Stable public int threadTlabOffset;
1111 
1112     @HotSpotVMField(name = "JavaThread::_anchor", type = "JavaFrameAnchor", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadAnchorOffset;
1113     @HotSpotVMField(name = "JavaThread::_threadObj", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectOffset;
1114     @HotSpotVMField(name = "JavaThread::_osthread", type = "OSThread*", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadOffset;
1115     @HotSpotVMField(name = "JavaThread::_dirty_card_queue", type = "DirtyCardQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadDirtyCardQueueOffset;
1116     @HotSpotVMField(name = "JavaThread::_is_method_handle_return", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int threadIsMethodHandleReturnOffset;
1117     @HotSpotVMField(name = "JavaThread::_satb_mark_queue", type = "SATBMarkQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadSatbMarkQueueOffset;
1118     @HotSpotVMField(name = "JavaThread::_vm_result", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectResultOffset;
1119     @HotSpotVMField(name = "JavaThread::_jvmci_counters", type = "jlong*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciCountersThreadOffset;
1120     @HotSpotVMField(name = "JavaThread::_reserved_stack_activation", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadReservedStackActivationOffset;
1121 
1122     /**
1123      * An invalid value for {@link #rtldDefault}.
1124      */
1125     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
1126 
1127     /**
1128      * Address of the library lookup routine. The C signature of this routine is:
1129      *
1130      * &lt;pre&gt;
1131      *     void* (const char *filename, char *ebuf, int ebuflen)
1132      * &lt;/pre&gt;
1133      */
1134     @HotSpotVMAddress(name = "os::dll_load") @Stable public long dllLoad;
1135 
1136     /**
1137      * Address of the library lookup routine. The C signature of this routine is:
1138      *
1139      * &lt;pre&gt;
1140      *     void* (void* handle, const char* name)
1141      * &lt;/pre&gt;
1142      */
1143     @HotSpotVMAddress(name = "os::dll_lookup") @Stable public long dllLookup;
1144 
1145     /**
1146      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
1147      * return the first occurrence of the desired symbol using the default library search order. If
1148      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
1149      * the current platform.
1150      */
1151     @HotSpotVMAddress(name = "RTLD_DEFAULT", os = {"bsd", "linux"}) @Stable public long rtldDefault = INVALID_RTLD_DEFAULT_HANDLE;
1152 
1153     /**
1154      * This field is used to pass exception objects into and out of the runtime system during
1155      * exception handling for compiled code.
1156      */
1157     @HotSpotVMField(name = "JavaThread::_exception_oop", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionOopOffset;
1158     @HotSpotVMField(name = "JavaThread::_exception_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionPcOffset;
1159     @HotSpotVMField(name = "ThreadShadow::_pending_exception", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingExceptionOffset;
1160 
1161     @HotSpotVMField(name = "JavaThread::_pending_deoptimization", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingDeoptimizationOffset;
1162     @HotSpotVMField(name = "JavaThread::_pending_failed_speculation", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingFailedSpeculationOffset;
1163     @HotSpotVMField(name = "JavaThread::_pending_transfer_to_interpreter", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingTransferToInterpreterOffset;
1164 
1165     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_sp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaSpOffset;
1166     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaPcOffset;
1167     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_fp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET, archs = {"aarch64, amd64"}) @Stable private int javaFrameAnchorLastJavaFpOffset;
1168     @HotSpotVMField(name = "JavaFrameAnchor::_flags", type = "int", get = HotSpotVMField.Type.OFFSET, archs = {"sparc"}) @Stable private int javaFrameAnchorFlagsOffset;
1169 
1170     public int threadLastJavaSpOffset() {
1171         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
1172     }
1173 
1174     public int threadLastJavaPcOffset() {
1175         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
1176     }
1177 
1178     public int threadLastJavaFpOffset() {
1179         assert getHostArchitectureName().equals("aarch64") || getHostArchitectureName().equals("amd64");
1180         return javaThreadAnchorOffset + javaFrameAnchorLastJavaFpOffset;
1181     }
1182 
1183     /**
1184      * This value is only valid on SPARC.
1185      */
1186     public int threadJavaFrameAnchorFlagsOffset() {
1187         // TODO add an assert for SPARC
1188         return javaThreadAnchorOffset + javaFrameAnchorFlagsOffset;
1189     }
1190 
1191     // These are only valid on AMD64.
1192     @HotSpotVMConstant(name = "frame::arg_reg_save_area_bytes", archs = {"amd64"}) @Stable public int runtimeCallStackSize;
1193     @HotSpotVMConstant(name = "frame::interpreter_frame_sender_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameSenderSpOffset;
1194     @HotSpotVMConstant(name = "frame::interpreter_frame_last_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameLastSpOffset;
1195 
1196     @HotSpotVMConstant(name = "dirtyCardQueueBufferOffset") @Stable private int dirtyCardQueueBufferOffset;
1197     @HotSpotVMConstant(name = "dirtyCardQueueIndexOffset") @Stable private int dirtyCardQueueIndexOffset;
1198 
1199     @HotSpotVMConstant(name = "satbMarkQueueBufferOffset") @Stable private int satbMarkQueueBufferOffset;
1200     @HotSpotVMConstant(name = "satbMarkQueueIndexOffset") @Stable private int satbMarkQueueIndexOffset;
1201     @HotSpotVMConstant(name = "satbMarkQueueActiveOffset") @Stable private int satbMarkQueueActiveOffset;
1202 
1203     @HotSpotVMField(name = "OSThread::_interrupted", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadInterruptedOffset;
1204 
1205     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public long markOopDescHashShift;
1206 
1207     @HotSpotVMConstant(name = "markOopDesc::biased_lock_mask_in_place") @Stable public int biasedLockMaskInPlace;
1208     @HotSpotVMConstant(name = "markOopDesc::age_mask_in_place") @Stable public int ageMaskInPlace;
1209     @HotSpotVMConstant(name = "markOopDesc::epoch_mask_in_place") @Stable public int epochMaskInPlace;
1210     @HotSpotVMConstant(name = "markOopDesc::hash_mask") @Stable public long markOopDescHashMask;
1211     @HotSpotVMConstant(name = "markOopDesc::hash_mask_in_place") @Stable public long markOopDescHashMaskInPlace;
1212 
1213     @HotSpotVMConstant(name = "markOopDesc::unlocked_value") @Stable public int unlockedMask;
1214     @HotSpotVMConstant(name = "markOopDesc::biased_lock_pattern") @Stable public int biasedLockPattern;
1215 
1216     @HotSpotVMConstant(name = "markOopDesc::no_hash_in_place") @Stable public int markWordNoHashInPlace;
1217     @HotSpotVMConstant(name = "markOopDesc::no_lock_in_place") @Stable public int markWordNoLockInPlace;
1218 
1219     /**
1220      * See {@code markOopDesc::prototype()}.
1221      */
1222     public long arrayPrototypeMarkWord() {
1223         return markWordNoHashInPlace | markWordNoLockInPlace;
1224     }
1225 
1226     /**
1227      * See {@code markOopDesc::copy_set_hash()}.
1228      */
1229     public long tlabIntArrayMarkWord() {
1230         long tmp = arrayPrototypeMarkWord() &amp; (~markOopDescHashMaskInPlace);
1231         tmp |= ((0x2 &amp; markOopDescHashMask) &lt;&lt; markOopDescHashShift);
1232         return tmp;
1233     }
1234 
1235     /**
1236      * Mark word right shift to get identity hash code.
1237      */
1238     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public int identityHashCodeShift;
1239 
1240     /**
1241      * Identity hash code value when uninitialized.
1242      */
1243     @HotSpotVMConstant(name = "markOopDesc::no_hash") @Stable public int uninitializedIdentityHashCodeValue;
1244 
1245     @HotSpotVMField(name = "Method::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int methodAccessFlagsOffset;
1246     @HotSpotVMField(name = "Method::_constMethod", type = "ConstMethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodConstMethodOffset;
1247     @HotSpotVMField(name = "Method::_intrinsic_id", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodIntrinsicIdOffset;
1248     @HotSpotVMField(name = "Method::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodFlagsOffset;
1249     @HotSpotVMField(name = "Method::_vtable_index", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodVtableIndexOffset;
1250 
1251     @HotSpotVMField(name = "Method::_method_counters", type = "MethodCounters*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCountersOffset;
1252     @HotSpotVMField(name = "Method::_method_data", type = "MethodData*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOffset;
1253     @HotSpotVMField(name = "Method::_from_compiled_entry", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCompiledEntryOffset;
1254     @HotSpotVMField(name = "Method::_code", type = "CompiledMethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCodeOffset;
1255 
1256     @HotSpotVMConstant(name = "Method::_jfr_towrite") @Stable public int methodFlagsJfrTowrite;
1257     @HotSpotVMConstant(name = "Method::_caller_sensitive") @Stable public int methodFlagsCallerSensitive;
1258     @HotSpotVMConstant(name = "Method::_force_inline") @Stable public int methodFlagsForceInline;
1259     @HotSpotVMConstant(name = "Method::_dont_inline") @Stable public int methodFlagsDontInline;
1260     @HotSpotVMConstant(name = "Method::_hidden") @Stable public int methodFlagsHidden;
1261     @HotSpotVMConstant(name = "Method::_reserved_stack_access") @Stable public int methodFlagsReservedStackAccess;
1262     @HotSpotVMConstant(name = "Method::nonvirtual_vtable_index") @Stable public int nonvirtualVtableIndex;
1263     @HotSpotVMConstant(name = "Method::invalid_vtable_index") @Stable public int invalidVtableIndex;
1264 
1265     @HotSpotVMField(name = "MethodCounters::_invocation_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int invocationCounterOffset;
1266     @HotSpotVMField(name = "MethodCounters::_backedge_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int backedgeCounterOffset;
1267     @HotSpotVMConstant(name = "InvocationCounter::count_increment") @Stable public int invocationCounterIncrement;
1268     @HotSpotVMConstant(name = "InvocationCounter::count_shift") @Stable public int invocationCounterShift;
1269 
1270     @HotSpotVMField(name = "MethodData::_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataSize;
1271     @HotSpotVMField(name = "MethodData::_data_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataDataSize;
1272     @HotSpotVMField(name = "MethodData::_data[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopDataOffset;
1273     @HotSpotVMField(name = "MethodData::_trap_hist._array[0]", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopTrapHistoryOffset;
1274     @HotSpotVMField(name = "MethodData::_jvmci_ir_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataIRSizeOffset;
1275 
1276     @HotSpotVMField(name = "nmethod::_verified_entry_point", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodEntryOffset;
1277     @HotSpotVMField(name = "nmethod::_comp_level", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodCompLevelOffset;
1278 
1279     @HotSpotVMConstant(name = "CompLevel_none") @Stable public int compilationLevelNone;
1280     @HotSpotVMConstant(name = "CompLevel_simple") @Stable public int compilationLevelSimple;
1281     @HotSpotVMConstant(name = "CompLevel_limited_profile") @Stable public int compilationLevelLimitedProfile;
1282     @HotSpotVMConstant(name = "CompLevel_full_profile") @Stable public int compilationLevelFullProfile;
1283     @HotSpotVMConstant(name = "CompLevel_full_optimization") @Stable public int compilationLevelFullOptimization;
1284 
1285     @HotSpotVMConstant(name = "JVMCIRuntime::none") @Stable public int compLevelAdjustmentNone;
1286     @HotSpotVMConstant(name = "JVMCIRuntime::by_holder") @Stable public int compLevelAdjustmentByHolder;
1287     @HotSpotVMConstant(name = "JVMCIRuntime::by_full_signature") @Stable public int compLevelAdjustmentByFullSignature;
1288 
1289     @HotSpotVMConstant(name = "InvocationEntryBci") @Stable public int invocationEntryBci;
1290 
1291     @HotSpotVMField(name = "JVMCIEnv::_task", type = "CompileTask*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvTaskOffset;
1292     @HotSpotVMField(name = "JVMCIEnv::_jvmti_can_hotswap_or_post_breakpoint", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvJvmtiCanHotswapOrPostBreakpointOffset;
1293     @HotSpotVMField(name = "CompileTask::_num_inlined_bytecodes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int compileTaskNumInlinedBytecodesOffset;
1294 
1295     @HotSpotVMField(name = "CompilerToVM::Data::Method_extra_stack_entries", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int extraStackEntries;
1296 
1297     @HotSpotVMField(name = "ConstMethod::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodConstantsOffset;
1298     @HotSpotVMField(name = "ConstMethod::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodFlagsOffset;
1299     @HotSpotVMField(name = "ConstMethod::_code_size", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodCodeSizeOffset;
1300     @HotSpotVMField(name = "ConstMethod::_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodNameIndexOffset;
1301     @HotSpotVMField(name = "ConstMethod::_signature_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodSignatureIndexOffset;
1302     @HotSpotVMField(name = "ConstMethod::_max_stack", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodMaxStackOffset;
1303     @HotSpotVMField(name = "ConstMethod::_max_locals", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodMaxLocalsOffset;
1304 
1305     @HotSpotVMConstant(name = "ConstMethod::_has_linenumber_table") @Stable public int constMethodHasLineNumberTable;
1306     @HotSpotVMConstant(name = "ConstMethod::_has_localvariable_table") @Stable public int constMethodHasLocalVariableTable;
1307     @HotSpotVMConstant(name = "ConstMethod::_has_exception_table") @Stable public int constMethodHasExceptionTable;
1308 
1309     @HotSpotVMType(name = "ExceptionTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int exceptionTableElementSize;
1310     @HotSpotVMField(name = "ExceptionTableElement::start_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementStartPcOffset;
1311     @HotSpotVMField(name = "ExceptionTableElement::end_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementEndPcOffset;
1312     @HotSpotVMField(name = "ExceptionTableElement::handler_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementHandlerPcOffset;
1313     @HotSpotVMField(name = "ExceptionTableElement::catch_type_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementCatchTypeIndexOffset;
1314 
1315     @HotSpotVMType(name = "LocalVariableTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int localVariableTableElementSize;
1316     @HotSpotVMField(name = "LocalVariableTableElement::start_bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementStartBciOffset;
1317     @HotSpotVMField(name = "LocalVariableTableElement::length", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementLengthOffset;
1318     @HotSpotVMField(name = "LocalVariableTableElement::name_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementNameCpIndexOffset;
1319     @HotSpotVMField(name = "LocalVariableTableElement::descriptor_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementDescriptorCpIndexOffset;
1320     @HotSpotVMField(name = "LocalVariableTableElement::signature_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSignatureCpIndexOffset;
1321     @HotSpotVMField(name = "LocalVariableTableElement::slot", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSlotOffset;
1322 
1323     @HotSpotVMType(name = "ConstantPool", get = HotSpotVMType.Type.SIZE) @Stable public int constantPoolSize;
1324     @HotSpotVMField(name = "ConstantPool::_tags", type = "Array&lt;u1&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolTagsOffset;
1325     @HotSpotVMField(name = "ConstantPool::_pool_holder", type = "InstanceKlass*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolHolderOffset;
1326     @HotSpotVMField(name = "ConstantPool::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolLengthOffset;
1327 
1328     @HotSpotVMConstant(name = "ConstantPool::CPCACHE_INDEX_TAG") @Stable public int constantPoolCpCacheIndexTag;
1329 
1330     @HotSpotVMConstant(name = "JVM_CONSTANT_Utf8") @Stable public int jvmConstantUtf8;
1331     @HotSpotVMConstant(name = "JVM_CONSTANT_Integer") @Stable public int jvmConstantInteger;
1332     @HotSpotVMConstant(name = "JVM_CONSTANT_Long") @Stable public int jvmConstantLong;
1333     @HotSpotVMConstant(name = "JVM_CONSTANT_Float") @Stable public int jvmConstantFloat;
1334     @HotSpotVMConstant(name = "JVM_CONSTANT_Double") @Stable public int jvmConstantDouble;
1335     @HotSpotVMConstant(name = "JVM_CONSTANT_Class") @Stable public int jvmConstantClass;
1336     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClass") @Stable public int jvmConstantUnresolvedClass;
1337     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClassInError") @Stable public int jvmConstantUnresolvedClassInError;
1338     @HotSpotVMConstant(name = "JVM_CONSTANT_String") @Stable public int jvmConstantString;
1339     @HotSpotVMConstant(name = "JVM_CONSTANT_Fieldref") @Stable public int jvmConstantFieldref;
1340     @HotSpotVMConstant(name = "JVM_CONSTANT_Methodref") @Stable public int jvmConstantMethodref;
1341     @HotSpotVMConstant(name = "JVM_CONSTANT_InterfaceMethodref") @Stable public int jvmConstantInterfaceMethodref;
1342     @HotSpotVMConstant(name = "JVM_CONSTANT_NameAndType") @Stable public int jvmConstantNameAndType;
1343     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandle") @Stable public int jvmConstantMethodHandle;
1344     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandleInError") @Stable public int jvmConstantMethodHandleInError;
1345     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodType") @Stable public int jvmConstantMethodType;
1346     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodTypeInError") @Stable public int jvmConstantMethodTypeInError;
1347     @HotSpotVMConstant(name = "JVM_CONSTANT_InvokeDynamic") @Stable public int jvmConstantInvokeDynamic;
1348 
1349     @HotSpotVMConstant(name = "JVM_CONSTANT_ExternalMax") @Stable public int jvmConstantExternalMax;
1350     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMin") @Stable public int jvmConstantInternalMin;
1351     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMax") @Stable public int jvmConstantInternalMax;
1352 
1353     @HotSpotVMConstant(name = "HeapWordSize") @Stable public int heapWordSize;
1354 
1355     @HotSpotVMType(name = "Symbol*", get = HotSpotVMType.Type.SIZE) @Stable public int symbolPointerSize;
1356 
1357     @HotSpotVMField(name = "vmSymbols::_symbols[0]", type = "Symbol*", get = HotSpotVMField.Type.ADDRESS) @Stable public long vmSymbolsSymbols;
1358     @HotSpotVMConstant(name = "vmSymbols::FIRST_SID") @Stable public int vmSymbolsFirstSID;
1359     @HotSpotVMConstant(name = "vmSymbols::SID_LIMIT") @Stable public int vmSymbolsSIDLimit;
1360 
1361     /**
1362      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
1363      * are allowed to look like (respectively) the high or low bits of a real oop.
1364      */
1365     @HotSpotVMField(name = "CompilerToVM::Data::Universe_non_oop_bits", type = "void*", get = HotSpotVMField.Type.VALUE) @Stable public long nonOopBits;
1366 
1367     @HotSpotVMField(name = "StubRoutines::_verify_oop_count", type = "jint", get = HotSpotVMField.Type.ADDRESS) @Stable public long verifyOopCounterAddress;
1368     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_mask", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopMask;
1369     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_bits", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopBits;
1370     @HotSpotVMField(name = "CompilerToVM::Data::Universe_base_vtable_size", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int universeBaseVtableSize;
1371 
1372     public final int baseVtableLength() {
1373         return universeBaseVtableSize / vtableEntrySize;
1374     }
1375 
1376     @HotSpotVMField(name = "HeapRegion::LogOfHRGrainBytes", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int logOfHRGrainBytes;
1377 
1378     @HotSpotVMConstant(name = "CardTableModRefBS::dirty_card") @Stable public byte dirtyCardValue;
1379     @HotSpotVMConstant(name = "G1SATBCardTableModRefBS::g1_young_gen") @Stable public byte g1YoungCardValue;
1380 
1381     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_start_address", type = "jbyte*", get = HotSpotVMField.Type.VALUE) @Stable private long cardtableStartAddress;
1382     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable private int cardtableShift;
1383 
1384     public long cardtableStartAddress() {
1385         return cardtableStartAddress;
1386     }
1387 
1388     public int cardtableShift() {
1389         return cardtableShift;
1390     }
1391 
1392     @HotSpotVMField(name = "os::_polling_page", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long safepointPollingAddress;
1393 
1394     // G1 Collector Related Values.
1395 
1396     public int g1CardQueueIndexOffset() {
1397         return javaThreadDirtyCardQueueOffset + dirtyCardQueueIndexOffset;
1398     }
1399 
1400     public int g1CardQueueBufferOffset() {
1401         return javaThreadDirtyCardQueueOffset + dirtyCardQueueBufferOffset;
1402     }
1403 
1404     public int g1SATBQueueMarkingOffset() {
1405         return javaThreadSatbMarkQueueOffset + satbMarkQueueActiveOffset;
1406     }
1407 
1408     public int g1SATBQueueIndexOffset() {
1409         return javaThreadSatbMarkQueueOffset + satbMarkQueueIndexOffset;
1410     }
1411 
1412     public int g1SATBQueueBufferOffset() {
1413         return javaThreadSatbMarkQueueOffset + satbMarkQueueBufferOffset;
1414     }
1415 
1416     @HotSpotVMField(name = "java_lang_Class::_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassOffset;
1417     @HotSpotVMField(name = "java_lang_Class::_array_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int arrayKlassOffset;
1418 
1419     @HotSpotVMType(name = "BasicLock", get = HotSpotVMType.Type.SIZE) @Stable public int basicLockSize;
1420     @HotSpotVMField(name = "BasicLock::_displaced_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int basicLockDisplacedHeaderOffset;
1421 
1422     @HotSpotVMField(name = "Thread::_allocated_bytes", type = "jlong", get = HotSpotVMField.Type.OFFSET) @Stable public int threadAllocatedBytesOffset;
1423 
1424     @HotSpotVMFlag(name = "TLABWasteIncrement") @Stable public int tlabRefillWasteIncrement;
1425 
1426     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_start", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferStartOffset;
1427     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_end", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferEndOffset;
1428     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferTopOffset;
1429     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_pf_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferPfTopOffset;
1430     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_slow_allocations", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferSlowAllocationsOffset;
1431     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_fast_refill_waste", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferFastRefillWasteOffset;
1432     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_number_of_refills", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferNumberOfRefillsOffset;
1433     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_refill_waste_limit", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferRefillWasteLimitOffset;
1434     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_desired_size", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferDesiredSizeOffset;
1435 
1436     public int tlabSlowAllocationsOffset() {
1437         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
1438     }
1439 
1440     public int tlabFastRefillWasteOffset() {
1441         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
1442     }
1443 
1444     public int tlabNumberOfRefillsOffset() {
1445         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
1446     }
1447 
1448     public int tlabRefillWasteLimitOffset() {
1449         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
1450     }
1451 
1452     public int threadTlabSizeOffset() {
1453         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
1454     }
1455 
1456     public int threadTlabStartOffset() {
1457         return threadTlabOffset + threadLocalAllocBufferStartOffset;
1458     }
1459 
1460     public int threadTlabEndOffset() {
1461         return threadTlabOffset + threadLocalAllocBufferEndOffset;
1462     }
1463 
1464     public int threadTlabTopOffset() {
1465         return threadTlabOffset + threadLocalAllocBufferTopOffset;
1466     }
1467 
1468     public int threadTlabPfTopOffset() {
1469         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
1470     }
1471 
1472     @HotSpotVMField(name = "CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve", type = "size_t", get = HotSpotVMField.Type.VALUE) @Stable public int tlabAlignmentReserve;
1473 
1474     @HotSpotVMFlag(name = "TLABStats") @Stable public boolean tlabStats;
1475 
1476     // FIXME This is only temporary until the GC code is changed.
1477     @HotSpotVMField(name = "CompilerToVM::Data::_supports_inline_contig_alloc", type = "bool", get = HotSpotVMField.Type.VALUE) @Stable public boolean inlineContiguousAllocationSupported;
1478     @HotSpotVMField(name = "CompilerToVM::Data::_heap_end_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapEndAddress;
1479     @HotSpotVMField(name = "CompilerToVM::Data::_heap_top_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapTopAddress;
1480 
1481     /**
1482      * The DataLayout header size is the same as the cell size.
1483      */
1484     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutHeaderSize;
1485     @HotSpotVMField(name = "DataLayout::_header._struct._tag", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutTagOffset;
1486     @HotSpotVMField(name = "DataLayout::_header._struct._flags", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutFlagsOffset;
1487     @HotSpotVMField(name = "DataLayout::_header._struct._bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutBCIOffset;
1488     @HotSpotVMField(name = "DataLayout::_cells[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutCellsOffset;
1489     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutCellSize;
1490 
1491     @HotSpotVMConstant(name = "DataLayout::no_tag") @Stable public int dataLayoutNoTag;
1492     @HotSpotVMConstant(name = "DataLayout::bit_data_tag") @Stable public int dataLayoutBitDataTag;
1493     @HotSpotVMConstant(name = "DataLayout::counter_data_tag") @Stable public int dataLayoutCounterDataTag;
1494     @HotSpotVMConstant(name = "DataLayout::jump_data_tag") @Stable public int dataLayoutJumpDataTag;
1495     @HotSpotVMConstant(name = "DataLayout::receiver_type_data_tag") @Stable public int dataLayoutReceiverTypeDataTag;
1496     @HotSpotVMConstant(name = "DataLayout::virtual_call_data_tag") @Stable public int dataLayoutVirtualCallDataTag;
1497     @HotSpotVMConstant(name = "DataLayout::ret_data_tag") @Stable public int dataLayoutRetDataTag;
1498     @HotSpotVMConstant(name = "DataLayout::branch_data_tag") @Stable public int dataLayoutBranchDataTag;
1499     @HotSpotVMConstant(name = "DataLayout::multi_branch_data_tag") @Stable public int dataLayoutMultiBranchDataTag;
1500     @HotSpotVMConstant(name = "DataLayout::arg_info_data_tag") @Stable public int dataLayoutArgInfoDataTag;
1501     @HotSpotVMConstant(name = "DataLayout::call_type_data_tag") @Stable public int dataLayoutCallTypeDataTag;
1502     @HotSpotVMConstant(name = "DataLayout::virtual_call_type_data_tag") @Stable public int dataLayoutVirtualCallTypeDataTag;
1503     @HotSpotVMConstant(name = "DataLayout::parameters_type_data_tag") @Stable public int dataLayoutParametersTypeDataTag;
1504     @HotSpotVMConstant(name = "DataLayout::speculative_trap_data_tag") @Stable public int dataLayoutSpeculativeTrapDataTag;
1505 
1506     @HotSpotVMFlag(name = "BciProfileWidth") @Stable public int bciProfileWidth;
1507     @HotSpotVMFlag(name = "TypeProfileWidth") @Stable public int typeProfileWidth;
1508     @HotSpotVMFlag(name = "MethodProfileWidth") @Stable public int methodProfileWidth;
1509 
1510     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_ic_miss_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long inlineCacheMissStub;
1511     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleWrongMethodStub;
1512 
1513     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_unpack", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleDeoptStub;
1514     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long uncommonTrapStub;
1515 
1516     @HotSpotVMField(name = "CodeCache::_low_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheLowBound;
1517     @HotSpotVMField(name = "CodeCache::_high_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheHighBound;
1518 
1519     @HotSpotVMField(name = "StubRoutines::_aescrypt_encryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptEncryptBlockStub;
1520     @HotSpotVMField(name = "StubRoutines::_aescrypt_decryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptDecryptBlockStub;
1521     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_encryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingEncryptAESCryptStub;
1522     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_decryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingDecryptAESCryptStub;
1523     @HotSpotVMField(name = "StubRoutines::_updateBytesCRC32", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long updateBytesCRC32Stub;
1524     @HotSpotVMField(name = "StubRoutines::_crc_table_adr", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long crcTableAddress;
1525 
1526     @HotSpotVMField(name = "StubRoutines::_throw_delayed_StackOverflowError_entry", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long throwDelayedStackOverflowErrorEntry;
1527 
1528     @HotSpotVMField(name = "StubRoutines::_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteArraycopy;
1529     @HotSpotVMField(name = "StubRoutines::_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortArraycopy;
1530     @HotSpotVMField(name = "StubRoutines::_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintArraycopy;
1531     @HotSpotVMField(name = "StubRoutines::_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongArraycopy;
1532     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopy;
1533     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopyUninit;
1534     @HotSpotVMField(name = "StubRoutines::_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteDisjointArraycopy;
1535     @HotSpotVMField(name = "StubRoutines::_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortDisjointArraycopy;
1536     @HotSpotVMField(name = "StubRoutines::_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintDisjointArraycopy;
1537     @HotSpotVMField(name = "StubRoutines::_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongDisjointArraycopy;
1538     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopy;
1539     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopyUninit;
1540     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedArraycopy;
1541     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedArraycopy;
1542     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedArraycopy;
1543     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedArraycopy;
1544     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopy;
1545     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopyUninit;
1546     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedDisjointArraycopy;
1547     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedDisjointArraycopy;
1548     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedDisjointArraycopy;
1549     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedDisjointArraycopy;
1550     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopy;
1551     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopyUninit;
1552     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopy;
1553     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopyUninit;
1554     @HotSpotVMField(name = "StubRoutines::_unsafe_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long unsafeArraycopy;
1555     @HotSpotVMField(name = "StubRoutines::_generic_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long genericArraycopy;
1556 
1557     @HotSpotVMAddress(name = "JVMCIRuntime::new_instance") @Stable public long newInstanceAddress;
1558     @HotSpotVMAddress(name = "JVMCIRuntime::new_array") @Stable public long newArrayAddress;
1559     @HotSpotVMAddress(name = "JVMCIRuntime::new_multi_array") @Stable public long newMultiArrayAddress;
1560     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_array") @Stable public long dynamicNewArrayAddress;
1561     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_instance") @Stable public long dynamicNewInstanceAddress;
1562 
1563     @HotSpotVMAddress(name = "JVMCIRuntime::thread_is_interrupted") @Stable public long threadIsInterruptedAddress;
1564     @HotSpotVMAddress(name = "JVMCIRuntime::vm_message") @Stable public long vmMessageAddress;
1565     @HotSpotVMAddress(name = "JVMCIRuntime::identity_hash_code") @Stable public long identityHashCodeAddress;
1566     @HotSpotVMAddress(name = "JVMCIRuntime::exception_handler_for_pc") @Stable public long exceptionHandlerForPcAddress;
1567     @HotSpotVMAddress(name = "JVMCIRuntime::monitorenter") @Stable public long monitorenterAddress;
1568     @HotSpotVMAddress(name = "JVMCIRuntime::monitorexit") @Stable public long monitorexitAddress;
1569     @HotSpotVMAddress(name = "JVMCIRuntime::throw_and_post_jvmti_exception") @Stable public long throwAndPostJvmtiExceptionAddress;
1570     @HotSpotVMAddress(name = "JVMCIRuntime::throw_klass_external_name_exception") @Stable public long throwKlassExternalNameExceptionAddress;
1571     @HotSpotVMAddress(name = "JVMCIRuntime::throw_class_cast_exception") @Stable public long throwClassCastExceptionAddress;
1572     @HotSpotVMAddress(name = "JVMCIRuntime::log_primitive") @Stable public long logPrimitiveAddress;
1573     @HotSpotVMAddress(name = "JVMCIRuntime::log_object") @Stable public long logObjectAddress;
1574     @HotSpotVMAddress(name = "JVMCIRuntime::log_printf") @Stable public long logPrintfAddress;
1575     @HotSpotVMAddress(name = "JVMCIRuntime::vm_error") @Stable public long vmErrorAddress;
1576     @HotSpotVMAddress(name = "JVMCIRuntime::load_and_clear_exception") @Stable public long loadAndClearExceptionAddress;
1577     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_pre") @Stable public long writeBarrierPreAddress;
1578     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_post") @Stable public long writeBarrierPostAddress;
1579     @HotSpotVMAddress(name = "JVMCIRuntime::validate_object") @Stable public long validateObject;
1580 
1581     @HotSpotVMAddress(name = "JVMCIRuntime::test_deoptimize_call_int") @Stable public long testDeoptimizeCallInt;
1582 
1583     @HotSpotVMAddress(name = "SharedRuntime::register_finalizer") @Stable public long registerFinalizerAddress;
1584     @HotSpotVMAddress(name = "SharedRuntime::exception_handler_for_return_address") @Stable public long exceptionHandlerForReturnAddressAddress;
1585     @HotSpotVMAddress(name = "SharedRuntime::OSR_migration_end") @Stable public long osrMigrationEndAddress;
1586     @HotSpotVMAddress(name = "SharedRuntime::enable_stack_reserved_zone") @Stable public long enableStackReservedZoneAddress;
1587 
1588     @HotSpotVMAddress(name = "os::javaTimeMillis") @Stable public long javaTimeMillisAddress;
1589     @HotSpotVMAddress(name = "os::javaTimeNanos") @Stable public long javaTimeNanosAddress;
1590     @HotSpotVMField(name = "CompilerToVM::Data::dsin", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticSinAddress;
1591     @HotSpotVMField(name = "CompilerToVM::Data::dcos", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticCosAddress;
1592     @HotSpotVMField(name = "CompilerToVM::Data::dtan", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticTanAddress;
1593     @HotSpotVMField(name = "CompilerToVM::Data::dexp", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticExpAddress;
1594     @HotSpotVMField(name = "CompilerToVM::Data::dlog", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticLogAddress;
1595     @HotSpotVMField(name = "CompilerToVM::Data::dlog10", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticLog10Address;
1596     @HotSpotVMField(name = "CompilerToVM::Data::dpow", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticPowAddress;
1597 
1598     @HotSpotVMFlag(name = "JVMCICounterSize") @Stable public int jvmciCountersSize;
1599 
1600     @HotSpotVMAddress(name = "Deoptimization::fetch_unroll_info") @Stable public long deoptimizationFetchUnrollInfo;
1601     @HotSpotVMAddress(name = "Deoptimization::uncommon_trap") @Stable public long deoptimizationUncommonTrap;
1602     @HotSpotVMAddress(name = "Deoptimization::unpack_frames") @Stable public long deoptimizationUnpackFrames;
1603 
1604     @HotSpotVMConstant(name = "Deoptimization::Reason_none") @Stable public int deoptReasonNone;
1605     @HotSpotVMConstant(name = "Deoptimization::Reason_null_check") @Stable public int deoptReasonNullCheck;
1606     @HotSpotVMConstant(name = "Deoptimization::Reason_range_check") @Stable public int deoptReasonRangeCheck;
1607     @HotSpotVMConstant(name = "Deoptimization::Reason_class_check") @Stable public int deoptReasonClassCheck;
1608     @HotSpotVMConstant(name = "Deoptimization::Reason_array_check") @Stable public int deoptReasonArrayCheck;
1609     @HotSpotVMConstant(name = "Deoptimization::Reason_unreached0") @Stable public int deoptReasonUnreached0;
1610     @HotSpotVMConstant(name = "Deoptimization::Reason_type_checked_inlining") @Stable public int deoptReasonTypeCheckInlining;
1611     @HotSpotVMConstant(name = "Deoptimization::Reason_optimized_type_check") @Stable public int deoptReasonOptimizedTypeCheck;
1612     @HotSpotVMConstant(name = "Deoptimization::Reason_not_compiled_exception_handler") @Stable public int deoptReasonNotCompiledExceptionHandler;
1613     @HotSpotVMConstant(name = "Deoptimization::Reason_unresolved") @Stable public int deoptReasonUnresolved;
1614     @HotSpotVMConstant(name = "Deoptimization::Reason_jsr_mismatch") @Stable public int deoptReasonJsrMismatch;
1615     @HotSpotVMConstant(name = "Deoptimization::Reason_div0_check") @Stable public int deoptReasonDiv0Check;
1616     @HotSpotVMConstant(name = "Deoptimization::Reason_constraint") @Stable public int deoptReasonConstraint;
1617     @HotSpotVMConstant(name = "Deoptimization::Reason_loop_limit_check") @Stable public int deoptReasonLoopLimitCheck;
1618     @HotSpotVMConstant(name = "Deoptimization::Reason_aliasing") @Stable public int deoptReasonAliasing;
1619     @HotSpotVMConstant(name = "Deoptimization::Reason_transfer_to_interpreter") @Stable public int deoptReasonTransferToInterpreter;
1620     @HotSpotVMConstant(name = "Deoptimization::Reason_LIMIT") @Stable public int deoptReasonOSROffset;
1621 
1622     @HotSpotVMConstant(name = "Deoptimization::Action_none") @Stable public int deoptActionNone;
1623     @HotSpotVMConstant(name = "Deoptimization::Action_maybe_recompile") @Stable public int deoptActionMaybeRecompile;
1624     @HotSpotVMConstant(name = "Deoptimization::Action_reinterpret") @Stable public int deoptActionReinterpret;
1625     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_entrant") @Stable public int deoptActionMakeNotEntrant;
1626     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_compilable") @Stable public int deoptActionMakeNotCompilable;
1627 
1628     @HotSpotVMConstant(name = "Deoptimization::_action_bits") @Stable public int deoptimizationActionBits;
1629     @HotSpotVMConstant(name = "Deoptimization::_reason_bits") @Stable public int deoptimizationReasonBits;
1630     @HotSpotVMConstant(name = "Deoptimization::_debug_id_bits") @Stable public int deoptimizationDebugIdBits;
1631     @HotSpotVMConstant(name = "Deoptimization::_action_shift") @Stable public int deoptimizationActionShift;
1632     @HotSpotVMConstant(name = "Deoptimization::_reason_shift") @Stable public int deoptimizationReasonShift;
1633     @HotSpotVMConstant(name = "Deoptimization::_debug_id_shift") @Stable public int deoptimizationDebugIdShift;
1634 
1635     @HotSpotVMConstant(name = "Deoptimization::Unpack_deopt") @Stable public int deoptimizationUnpackDeopt;
1636     @HotSpotVMConstant(name = "Deoptimization::Unpack_exception") @Stable public int deoptimizationUnpackException;
1637     @HotSpotVMConstant(name = "Deoptimization::Unpack_uncommon_trap") @Stable public int deoptimizationUnpackUncommonTrap;
1638     @HotSpotVMConstant(name = "Deoptimization::Unpack_reexecute") @Stable public int deoptimizationUnpackReexecute;
1639 
1640     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_size_of_deoptimized_frame", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockSizeOfDeoptimizedFrameOffset;
1641     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_caller_adjustment", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockCallerAdjustmentOffset;
1642     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_number_of_frames", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockNumberOfFramesOffset;
1643     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_total_frame_sizes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockTotalFrameSizesOffset;
1644     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_unpack_kind", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockUnpackKindOffset;
1645     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_sizes", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFrameSizesOffset;
1646     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_pcs", type = "address*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFramePcsOffset;
1647     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_initial_info", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockInitialInfoOffset;
1648 
1649     @HotSpotVMConstant(name = "vmIntrinsics::_invokeBasic") @Stable public int vmIntrinsicInvokeBasic;
1650     @HotSpotVMConstant(name = "vmIntrinsics::_linkToVirtual") @Stable public int vmIntrinsicLinkToVirtual;
1651     @HotSpotVMConstant(name = "vmIntrinsics::_linkToStatic") @Stable public int vmIntrinsicLinkToStatic;
1652     @HotSpotVMConstant(name = "vmIntrinsics::_linkToSpecial") @Stable public int vmIntrinsicLinkToSpecial;
1653     @HotSpotVMConstant(name = "vmIntrinsics::_linkToInterface") @Stable public int vmIntrinsicLinkToInterface;
1654 
1655     @HotSpotVMConstant(name = "JVMCIEnv::ok") @Stable public int codeInstallResultOk;
1656     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_failed") @Stable public int codeInstallResultDependenciesFailed;
1657     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_invalid") @Stable public int codeInstallResultDependenciesInvalid;
1658     @HotSpotVMConstant(name = "JVMCIEnv::cache_full") @Stable public int codeInstallResultCacheFull;
1659     @HotSpotVMConstant(name = "JVMCIEnv::code_too_large") @Stable public int codeInstallResultCodeTooLarge;
1660 
1661     public String getCodeInstallResultDescription(int codeInstallResult) {
1662         if (codeInstallResult == codeInstallResultOk) {
1663             return "ok";
1664         }
1665         if (codeInstallResult == codeInstallResultDependenciesFailed) {
1666             return "dependencies failed";
1667         }
1668         if (codeInstallResult == codeInstallResultDependenciesInvalid) {
1669             return "dependencies invalid";
1670         }
1671         if (codeInstallResult == codeInstallResultCacheFull) {
1672             return "code cache is full";
1673         }
1674         if (codeInstallResult == codeInstallResultCodeTooLarge) {
1675             return "code is too large";
1676         }
1677         assert false : codeInstallResult;
1678         return "unknown";
1679     }
1680 
1681     // Checkstyle: stop
1682     @HotSpotVMConstant(name = "CodeInstaller::VERIFIED_ENTRY") @Stable public int MARKID_VERIFIED_ENTRY;
1683     @HotSpotVMConstant(name = "CodeInstaller::UNVERIFIED_ENTRY") @Stable public int MARKID_UNVERIFIED_ENTRY;
1684     @HotSpotVMConstant(name = "CodeInstaller::OSR_ENTRY") @Stable public int MARKID_OSR_ENTRY;
1685     @HotSpotVMConstant(name = "CodeInstaller::EXCEPTION_HANDLER_ENTRY") @Stable public int MARKID_EXCEPTION_HANDLER_ENTRY;
1686     @HotSpotVMConstant(name = "CodeInstaller::DEOPT_HANDLER_ENTRY") @Stable public int MARKID_DEOPT_HANDLER_ENTRY;
1687     @HotSpotVMConstant(name = "CodeInstaller::INVOKEINTERFACE") @Stable public int MARKID_INVOKEINTERFACE;
1688     @HotSpotVMConstant(name = "CodeInstaller::INVOKEVIRTUAL") @Stable public int MARKID_INVOKEVIRTUAL;
1689     @HotSpotVMConstant(name = "CodeInstaller::INVOKESTATIC") @Stable public int MARKID_INVOKESTATIC;
1690     @HotSpotVMConstant(name = "CodeInstaller::INVOKESPECIAL") @Stable public int MARKID_INVOKESPECIAL;
1691     @HotSpotVMConstant(name = "CodeInstaller::INLINE_INVOKE") @Stable public int MARKID_INLINE_INVOKE;
1692     @HotSpotVMConstant(name = "CodeInstaller::POLL_NEAR") @Stable public int MARKID_POLL_NEAR;
1693     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_NEAR") @Stable public int MARKID_POLL_RETURN_NEAR;
1694     @HotSpotVMConstant(name = "CodeInstaller::POLL_FAR") @Stable public int MARKID_POLL_FAR;
1695     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_FAR") @Stable public int MARKID_POLL_RETURN_FAR;
1696     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_SHIFT") @Stable public int MARKID_CARD_TABLE_SHIFT;
1697     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_ADDRESS") @Stable public int MARKID_CARD_TABLE_ADDRESS;
1698     @HotSpotVMConstant(name = "CodeInstaller::HEAP_TOP_ADDRESS") @Stable public int MARKID_HEAP_TOP_ADDRESS;
1699     @HotSpotVMConstant(name = "CodeInstaller::HEAP_END_ADDRESS") @Stable public int MARKID_HEAP_END_ADDRESS;
1700     @HotSpotVMConstant(name = "CodeInstaller::NARROW_KLASS_BASE_ADDRESS") @Stable public int MARKID_NARROW_KLASS_BASE_ADDRESS;
1701     @HotSpotVMConstant(name = "CodeInstaller::CRC_TABLE_ADDRESS") @Stable public int MARKID_CRC_TABLE_ADDRESS;
1702     @HotSpotVMConstant(name = "CodeInstaller::INVOKE_INVALID") @Stable public int MARKID_INVOKE_INVALID;
1703 
1704     @HotSpotVMConstant(name = "BitData::exception_seen_flag") @Stable public int bitDataExceptionSeenFlag;
1705     @HotSpotVMConstant(name = "BitData::null_seen_flag") @Stable public int bitDataNullSeenFlag;
1706     @HotSpotVMConstant(name = "CounterData::count_off") @Stable public int methodDataCountOffset;
1707     @HotSpotVMConstant(name = "JumpData::taken_off_set") @Stable public int jumpDataTakenOffset;
1708     @HotSpotVMConstant(name = "JumpData::displacement_off_set") @Stable public int jumpDataDisplacementOffset;
1709     @HotSpotVMConstant(name = "ReceiverTypeData::nonprofiled_count_off_set") @Stable public int receiverTypeDataNonprofiledCountOffset;
1710     @HotSpotVMConstant(name = "ReceiverTypeData::receiver_type_row_cell_count") @Stable public int receiverTypeDataReceiverTypeRowCellCount;
1711     @HotSpotVMConstant(name = "ReceiverTypeData::receiver0_offset") @Stable public int receiverTypeDataReceiver0Offset;
1712     @HotSpotVMConstant(name = "ReceiverTypeData::count0_offset") @Stable public int receiverTypeDataCount0Offset;
1713     @HotSpotVMConstant(name = "BranchData::not_taken_off_set") @Stable public int branchDataNotTakenOffset;
1714     @HotSpotVMConstant(name = "ArrayData::array_len_off_set") @Stable public int arrayDataArrayLenOffset;
1715     @HotSpotVMConstant(name = "ArrayData::array_start_off_set") @Stable public int arrayDataArrayStartOffset;
1716     @HotSpotVMConstant(name = "MultiBranchData::per_case_cell_count") @Stable public int multiBranchDataPerCaseCellCount;
1717 
1718     // Checkstyle: resume
1719 
1720     private boolean check() {
1721         for (Field f : getClass().getDeclaredFields()) {
1722             int modifiers = f.getModifiers();
1723             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
1724                 assert Modifier.isFinal(modifiers) || f.getAnnotation(Stable.class) != null : "field should either be final or @Stable: " + f;
1725             }
1726         }
1727 
1728         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
1729         assert (layoutHelperArrayTagObjectValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "object array must have first bit set";
1730         assert (layoutHelperArrayTagTypeValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "type array must have first bit set";
1731 
1732         return true;
1733     }
1734 
1735     /**
1736      * A compact representation of the different encoding strategies for Objects and metadata.
1737      */
1738     public static class CompressEncoding {
1739         public final long base;
1740         public final int shift;
1741         public final int alignment;
1742 
1743         CompressEncoding(long base, int shift, int alignment) {
1744             this.base = base;
1745             this.shift = shift;
1746             this.alignment = alignment;
1747         }
1748 
1749         public int compress(long ptr) {
1750             if (ptr == 0L) {
1751                 return 0;
1752             } else {
1753                 return (int) ((ptr - base) &gt;&gt;&gt; shift);
1754             }
1755         }
1756 
1757         public long uncompress(int ptr) {
1758             if (ptr == 0) {
1759                 return 0L;
1760             } else {
1761                 return ((ptr &amp; 0xFFFFFFFFL) &lt;&lt; shift) + base;
1762             }
1763         }
1764 
1765         @Override
1766         public String toString() {
1767             return "base: " + base + " shift: " + shift + " alignment: " + alignment;
1768         }
1769 
1770         @Override
1771         public int hashCode() {
1772             final int prime = 31;
1773             int result = 1;
1774             result = prime * result + alignment;
1775             result = prime * result + (int) (base ^ (base &gt;&gt;&gt; 32));
1776             result = prime * result + shift;
1777             return result;
1778         }
1779 
1780         @Override
1781         public boolean equals(Object obj) {
1782             if (obj instanceof CompressEncoding) {
1783                 CompressEncoding other = (CompressEncoding) obj;
1784                 return alignment == other.alignment &amp;&amp; base == other.base &amp;&amp; shift == other.shift;
1785             } else {
1786                 return false;
1787             }
1788         }
1789     }
1790 
1791 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="23" type="hidden" /></form></body></html>
