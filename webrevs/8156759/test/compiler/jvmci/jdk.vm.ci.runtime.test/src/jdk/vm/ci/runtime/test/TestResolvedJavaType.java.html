<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestResolvedJavaType.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /**
  25  * @test
  26  * @requires (os.simpleArch == "x64" | os.simpleArch == "sparcv9" | os.simpleArch == "aarch64")
  27  * @library ../../../../../
  28  * @modules java.base/jdk.internal.reflect
  29  *          jdk.vm.ci/jdk.vm.ci.meta
  30  *          jdk.vm.ci/jdk.vm.ci.runtime
  31  *          java.base/jdk.internal.misc
  32  * @build jdk.vm.ci.runtime.test.TestResolvedJavaType
  33  * @run junit/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI jdk.vm.ci.runtime.test.TestResolvedJavaType
  34  */
  35 
  36 package jdk.vm.ci.runtime.test;
  37 
  38 import static java.lang.reflect.Modifier.isAbstract;
  39 import static java.lang.reflect.Modifier.isFinal;
  40 import static java.lang.reflect.Modifier.isPrivate;
  41 import static java.lang.reflect.Modifier.isProtected;
  42 import static java.lang.reflect.Modifier.isPublic;
  43 import static java.lang.reflect.Modifier.isStatic;
  44 import static org.junit.Assert.assertArrayEquals;
  45 import static org.junit.Assert.assertEquals;
  46 import static org.junit.Assert.assertFalse;
  47 import static org.junit.Assert.assertNotNull;
  48 import static org.junit.Assert.assertNull;
  49 import static org.junit.Assert.assertTrue;
  50 
  51 import java.lang.annotation.Annotation;
  52 import java.lang.reflect.Field;
  53 import java.lang.reflect.Method;
  54 import java.lang.reflect.Modifier;
  55 import java.util.Arrays;
  56 import java.util.Collections;
  57 import java.util.HashMap;
  58 import java.util.HashSet;
  59 import java.util.Map;
  60 import java.util.Set;
  61 
  62 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  63 import jdk.vm.ci.meta.JavaConstant;
  64 import jdk.vm.ci.meta.JavaKind;
  65 import jdk.vm.ci.meta.ModifiersProvider;
  66 import jdk.vm.ci.meta.ResolvedJavaField;
  67 import jdk.vm.ci.meta.ResolvedJavaMethod;
  68 import jdk.vm.ci.meta.ResolvedJavaType;
  69 
  70 import org.junit.Test;
  71 
  72 import jdk.internal.reflect.ConstantPool;
  73 
  74 /**
  75  * Tests for {@link ResolvedJavaType}.
  76  */
  77 public class TestResolvedJavaType extends TypeUniverse {
  78 
  79     public TestResolvedJavaType() {
  80     }
  81 
  82     @Test
  83     public void findInstanceFieldWithOffsetTest() {
  84         for (Class&lt;?&gt; c : classes) {
  85             ResolvedJavaType type = metaAccess.lookupJavaType(c);
  86             Set&lt;Field&gt; reflectionFields = getInstanceFields(c, true);
  87             for (Field f : reflectionFields) {
  88                 ResolvedJavaField rf = lookupField(type.getInstanceFields(true), f);
  89                 assertNotNull(rf);
  90                 long offset = isStatic(f.getModifiers()) ? unsafe.staticFieldOffset(f) : unsafe.objectFieldOffset(f);
  91                 ResolvedJavaField result = type.findInstanceFieldWithOffset(offset, rf.getJavaKind());
  92                 assertNotNull(result);
  93                 assertTrue(fieldsEqual(f, result));
  94             }
  95         }
  96     }
  97 
  98     @Test
  99     public void isInterfaceTest() {
 100         for (Class&lt;?&gt; c : classes) {
 101             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 102             boolean expected = c.isInterface();
 103             boolean actual = type.isInterface();
 104             assertEquals(expected, actual);
 105         }
 106     }
 107 
 108     @Test
 109     public void isInstanceClassTest() {
 110         for (Class&lt;?&gt; c : classes) {
 111             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 112             boolean expected = !c.isArray() &amp;&amp; !c.isPrimitive() &amp;&amp; !c.isInterface();
 113             boolean actual = type.isInstanceClass();
 114             assertEquals(expected, actual);
 115         }
 116     }
 117 
 118     @Test
 119     public void isArrayTest() {
 120         for (Class&lt;?&gt; c : classes) {
 121             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 122             boolean expected = c.isArray();
 123             boolean actual = type.isArray();
 124             assertEquals(expected, actual);
 125         }
 126     }
 127 
 128     @Test
 129     public void getModifiersTest() {
 130         for (Class&lt;?&gt; c : classes) {
 131             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 132             int expected = c.getModifiers() &amp; ModifiersProvider.jvmClassModifiers();
 133             int actual = type.getModifiers() &amp; ModifiersProvider.jvmClassModifiers();
 134             Class&lt;?&gt; elementalType = c;
 135             while (elementalType.isArray()) {
 136                 elementalType = elementalType.getComponentType();
 137             }
 138             if (elementalType.isMemberClass()) {
 139                 // member class get their modifiers from the inner-class attribute in the JVM and
 140                 // from the classfile header in jvmci
 141                 expected &amp;= ~(Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED);
 142                 actual &amp;= ~(Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED);
 143             }
 144             assertEquals(String.format("%s: 0x%x != 0x%x", type, expected, actual), expected, actual);
 145         }
 146     }
 147 
 148     @Test
 149     public void isAssignableFromTest() {
 150         Class&lt;?&gt;[] all = classes.toArray(new Class&lt;?&gt;[classes.size()]);
 151         for (int i = 0; i &lt; all.length; i++) {
 152             Class&lt;?&gt; c1 = all[i];
 153             for (int j = i; j &lt; all.length; j++) {
 154                 Class&lt;?&gt; c2 = all[j];
 155                 ResolvedJavaType t1 = metaAccess.lookupJavaType(c1);
 156                 ResolvedJavaType t2 = metaAccess.lookupJavaType(c2);
 157                 boolean expected = c1.isAssignableFrom(c2);
 158                 boolean actual = t1.isAssignableFrom(t2);
 159                 assertEquals(expected, actual);
 160                 if (expected &amp;&amp; t1 != t2) {
 161                     assertFalse(t2.isAssignableFrom(t1));
 162                 }
 163             }
 164         }
 165     }
 166 
 167     @Test
 168     public void isInstanceTest() {
 169         for (ConstantValue cv : constants()) {
 170             JavaConstant c = cv.value;
 171             if (c.getJavaKind() == JavaKind.Object &amp;&amp; !c.isNull()) {
 172                 ResolvedJavaType cType = metaAccess.lookupJavaType(c);
 173                 for (ResolvedJavaType t : javaTypes) {
 174                     if (t.isAssignableFrom(cType)) {
 175                         assertTrue(t.isInstance(c));
 176                     } else {
 177                         assertFalse(t.isInstance(c));
 178                     }
 179                 }
 180             }
 181         }
 182     }
 183 
 184     private static Class&lt;?&gt; asExactClass(Class&lt;?&gt; c) {
 185         if (c.isArray()) {
 186             if (asExactClass(c.getComponentType()) != null) {
 187                 return c;
 188             }
 189         } else {
 190             if (c.isPrimitive() || Modifier.isFinal(c.getModifiers())) {
 191                 return c;
 192             }
 193         }
 194         return null;
 195     }
 196 
 197     @Test
 198     public void asExactTypeTest() {
 199         for (Class&lt;?&gt; c : classes) {
 200             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 201             ResolvedJavaType exactType = type.asExactType();
 202             Class&lt;?&gt; expected = asExactClass(c);
 203             if (expected == null) {
 204                 assertTrue("exact(" + c.getName() + ") != null", exactType == null);
 205             } else {
 206                 assertNotNull(exactType);
 207                 assertTrue(exactType.equals(metaAccess.lookupJavaType(expected)));
 208             }
 209         }
 210     }
 211 
 212     @Test
 213     public void getSuperclassTest() {
 214         for (Class&lt;?&gt; c : classes) {
 215             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 216             Class&lt;?&gt; expected = c.getSuperclass();
 217             ResolvedJavaType actual = type.getSuperclass();
 218             if (expected == null) {
 219                 assertTrue(actual == null);
 220             } else {
 221                 assertNotNull(actual);
 222                 assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 223             }
 224         }
 225     }
 226 
 227     @Test
 228     public void getInterfacesTest() {
 229         for (Class&lt;?&gt; c : classes) {
 230             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 231             Class&lt;?&gt;[] expected = c.getInterfaces();
 232             ResolvedJavaType[] actual = type.getInterfaces();
 233             assertEquals(expected.length, actual.length);
 234             for (int i = 0; i &lt; expected.length; i++) {
 235                 assertTrue(actual[i].equals(metaAccess.lookupJavaType(expected[i])));
 236             }
 237         }
 238     }
 239 
 240     public Class&lt;?&gt; getSupertype(Class&lt;?&gt; c) {
 241         assert !c.isPrimitive();
 242         if (c.isArray()) {
 243             Class&lt;?&gt; componentType = c.getComponentType();
 244             if (componentType.isPrimitive() || componentType == Object.class) {
 245                 return Object.class;
 246             }
 247             return getArrayClass(getSupertype(componentType));
 248         }
 249         if (c.isInterface()) {
 250             return Object.class;
 251         }
 252         return c.getSuperclass();
 253     }
 254 
 255     public Class&lt;?&gt; findLeastCommonAncestor(Class&lt;?&gt; c1Initial, Class&lt;?&gt; c2Initial) {
 256         if (c1Initial.isPrimitive() || c2Initial.isPrimitive()) {
 257             return null;
 258         } else {
 259             Class&lt;?&gt; c1 = c1Initial;
 260             Class&lt;?&gt; c2 = c2Initial;
 261             while (true) {
 262                 if (c1.isAssignableFrom(c2)) {
 263                     return c1;
 264                 }
 265                 if (c2.isAssignableFrom(c1)) {
 266                     return c2;
 267                 }
 268                 c1 = getSupertype(c1);
 269                 c2 = getSupertype(c2);
 270             }
 271         }
 272     }
 273 
 274     @Test
 275     public void findLeastCommonAncestorTest() {
 276         Class&lt;?&gt;[] all = classes.toArray(new Class&lt;?&gt;[classes.size()]);
 277         for (int i = 0; i &lt; all.length; i++) {
 278             Class&lt;?&gt; c1 = all[i];
 279             for (int j = i; j &lt; all.length; j++) {
 280                 Class&lt;?&gt; c2 = all[j];
 281                 ResolvedJavaType t1 = metaAccess.lookupJavaType(c1);
 282                 ResolvedJavaType t2 = metaAccess.lookupJavaType(c2);
 283                 Class&lt;?&gt; expected = findLeastCommonAncestor(c1, c2);
 284                 ResolvedJavaType actual = t1.findLeastCommonAncestor(t2);
 285                 if (expected == null) {
 286                     assertTrue(actual == null);
 287                 } else {
 288                     assertNotNull(actual);
 289                     assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 290                 }
 291             }
 292         }
 293     }
 294 
 295     private static class Base {
 296     }
 297 
 298     abstract static class Abstract1 extends Base {
 299     }
 300 
 301     interface Interface1 {
 302     }
 303 
 304     static class Concrete1 extends Abstract1 {
 305     }
 306 
 307     static class Concrete2 extends Abstract1 implements Interface1 {
 308     }
 309 
 310     static class Concrete3 extends Concrete2 {
 311     }
 312 
 313     static final class Final1 extends Abstract1 {
 314     }
 315 
 316     abstract static class Abstract4 extends Concrete3 {
 317     }
 318 
 319     void checkConcreteSubtype(ResolvedJavaType type, ResolvedJavaType expected) {
 320         AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = type.findLeafConcreteSubtype();
 321         if (leafConcreteSubtype == null) {
 322             // findLeafConcreteSubtype() is conservative
 323         } else {
 324             if (expected == null) {
 325                 assertNull(leafConcreteSubtype);
 326             } else {
 327                 assertTrue(leafConcreteSubtype.getResult().equals(expected));
 328             }
 329         }
 330 
 331         if (!type.isArray()) {
 332             ResolvedJavaType arrayType = type.getArrayClass();
 333             AssumptionResult&lt;ResolvedJavaType&gt; arraySubtype = arrayType.findLeafConcreteSubtype();
 334             if (arraySubtype != null) {
 335                 assertEquals(arraySubtype.getResult(), arrayType);
 336             } else {
 337                 // findLeafConcreteSubtype() method is conservative
 338             }
 339         }
 340     }
 341 
 342     @Test
 343     public void findLeafConcreteSubtypeTest() {
 344         ResolvedJavaType base = metaAccess.lookupJavaType(Base.class);
 345         checkConcreteSubtype(base, base);
 346 
 347         ResolvedJavaType a1 = metaAccess.lookupJavaType(Abstract1.class);
 348         ResolvedJavaType c1 = metaAccess.lookupJavaType(Concrete1.class);
 349 
 350         checkConcreteSubtype(base, null);
 351         checkConcreteSubtype(a1, c1);
 352         checkConcreteSubtype(c1, c1);
 353 
 354         ResolvedJavaType i1 = metaAccess.lookupJavaType(Interface1.class);
 355         ResolvedJavaType c2 = metaAccess.lookupJavaType(Concrete2.class);
 356 
 357         checkConcreteSubtype(base, null);
 358         checkConcreteSubtype(a1, null);
 359         checkConcreteSubtype(c1, c1);
 360         checkConcreteSubtype(i1, c2);
 361         checkConcreteSubtype(c2, c2);
 362 
 363         ResolvedJavaType c3 = metaAccess.lookupJavaType(Concrete3.class);
 364         checkConcreteSubtype(c2, null);
 365         checkConcreteSubtype(c3, c3);
 366 
 367         ResolvedJavaType a4 = metaAccess.lookupJavaType(Abstract4.class);
 368         checkConcreteSubtype(c3, null);
 369         checkConcreteSubtype(a4, null);
 370 
 371         ResolvedJavaType a1a = metaAccess.lookupJavaType(Abstract1[].class);
 372         checkConcreteSubtype(a1a, null);
 373         ResolvedJavaType c1a = metaAccess.lookupJavaType(Concrete1[].class);
 374         checkConcreteSubtype(c1a, null);
 375         ResolvedJavaType f1a = metaAccess.lookupJavaType(Final1[].class);
 376         checkConcreteSubtype(f1a, f1a);
 377 
 378         ResolvedJavaType obja = metaAccess.lookupJavaType(Object[].class);
 379         checkConcreteSubtype(obja, null);
 380 
 381         ResolvedJavaType inta = metaAccess.lookupJavaType(int[].class);
 382         checkConcreteSubtype(inta, inta);
 383     }
 384 
 385     interface NoImplementor {
 386     }
 387 
 388     interface SingleImplementorInterface {
 389     }
 390 
 391     static class SingleConcreteImplementor implements SingleImplementorInterface {
 392     }
 393 
 394     interface SingleAbstractImplementorInterface {
 395     }
 396 
 397     abstract static class SingleAbstractImplementor implements SingleAbstractImplementorInterface {
 398     }
 399 
 400     interface MultiImplementorInterface {
 401     }
 402 
 403     static class ConcreteImplementor1 implements MultiImplementorInterface {
 404     }
 405 
 406     static class ConcreteImplementor2 implements MultiImplementorInterface {
 407     }
 408 
 409     interface MultipleAbstractImplementorInterface {
 410     }
 411 
 412     abstract static class MultiAbstractImplementor1 implements MultipleAbstractImplementorInterface {
 413     }
 414 
 415     abstract static class MultiAbstractImplementor2 implements MultipleAbstractImplementorInterface {
 416     }
 417 
 418     interface SingleAbstractImplementorInterface2 {
 419     }
 420 
 421     interface ExtendedSingleImplementorInterface {
 422     }
 423 
 424     abstract static class SingleAbstractImplementor2 implements SingleAbstractImplementorInterface2 {
 425     }
 426 
 427     static class ConcreteTransitiveImplementor1 extends SingleAbstractImplementor2 implements ExtendedSingleImplementorInterface {
 428     }
 429 
 430     static class ConcreteTransitiveImplementor2 extends SingleAbstractImplementor2 implements ExtendedSingleImplementorInterface {
 431     }
 432 
 433     @Test
 434     public void getSingleImplementorTest() {
 435         ResolvedJavaType iNi = metaAccess.lookupJavaType(NoImplementor.class);
 436         assertNull(iNi.getSingleImplementor());
 437 
 438         ResolvedJavaType iSi = metaAccess.lookupJavaType(SingleImplementorInterface.class);
 439         ResolvedJavaType cSi = metaAccess.lookupJavaType(SingleConcreteImplementor.class);
 440         assertEquals(cSi, iSi.getSingleImplementor());
 441 
 442         ResolvedJavaType iSai = metaAccess.lookupJavaType(SingleAbstractImplementorInterface.class);
 443         ResolvedJavaType aSai = metaAccess.lookupJavaType(SingleAbstractImplementor.class);
 444         assertEquals(aSai, iSai.getSingleImplementor());
 445 
 446         ResolvedJavaType iMi = metaAccess.lookupJavaType(MultiImplementorInterface.class);
 447         metaAccess.lookupJavaType(ConcreteImplementor1.class);
 448         metaAccess.lookupJavaType(ConcreteImplementor2.class);
 449         assertEquals(iMi, iMi.getSingleImplementor());
 450 
 451         ResolvedJavaType iMai = metaAccess.lookupJavaType(MultipleAbstractImplementorInterface.class);
 452         metaAccess.lookupJavaType(MultiAbstractImplementor1.class);
 453         metaAccess.lookupJavaType(MultiAbstractImplementor2.class);
 454         assertEquals(iMai, iMai.getSingleImplementor());
 455 
 456         ResolvedJavaType iSai2 = metaAccess.lookupJavaType(SingleAbstractImplementorInterface2.class);
 457         ResolvedJavaType aSai2 = metaAccess.lookupJavaType(SingleAbstractImplementor2.class);
 458         metaAccess.lookupJavaType(ConcreteTransitiveImplementor1.class);
 459         metaAccess.lookupJavaType(ConcreteTransitiveImplementor2.class);
 460         assertEquals(aSai2, iSai2.getSingleImplementor());
 461     }
 462 
 463     @Test(expected = InternalError.class)
 464     public void getSingleImplementorTestClassReceiver() {
 465         ResolvedJavaType base = metaAccess.lookupJavaType(Base.class);
 466         base.getSingleImplementor();
 467     }
 468 
 469     @Test(expected = InternalError.class)
 470     public void getSingleImplementorTestPrimitiveReceiver() {
 471         ResolvedJavaType primitive = metaAccess.lookupJavaType(int.class);
 472         primitive.getSingleImplementor();
 473     }
 474 
 475     @Test
 476     public void getComponentTypeTest() {
 477         for (Class&lt;?&gt; c : classes) {
 478             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 479             Class&lt;?&gt; expected = c.getComponentType();
 480             ResolvedJavaType actual = type.getComponentType();
 481             if (expected == null) {
 482                 assertNull(actual);
 483             } else {
 484                 assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 485             }
 486         }
 487     }
 488 
 489     @Test
 490     public void getArrayClassTest() {
 491         for (Class&lt;?&gt; c : classes) {
 492             if (c != void.class) {
 493                 ResolvedJavaType type = metaAccess.lookupJavaType(c);
 494                 Class&lt;?&gt; expected = getArrayClass(c);
 495                 ResolvedJavaType actual = type.getArrayClass();
 496                 assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 497             }
 498         }
 499     }
 500 
 501     static class Declarations {
 502 
 503         final Method implementation;
 504         final Set&lt;Method&gt; declarations;
 505 
 506         Declarations(Method impl) {
 507             this.implementation = impl;
 508             declarations = new HashSet&lt;&gt;();
 509         }
 510     }
 511 
 512     /**
 513      * See &lt;a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.5"&gt;Method
 514      * overriding&lt;/a&gt;.
 515      */
 516     static boolean isOverriderOf(Method impl, Method m) {
 517         if (!isPrivate(m.getModifiers()) &amp;&amp; !isFinal(m.getModifiers())) {
 518             if (m.getName().equals(impl.getName())) {
 519                 if (m.getReturnType() == impl.getReturnType()) {
 520                     if (Arrays.equals(m.getParameterTypes(), impl.getParameterTypes())) {
 521                         if (isPublic(m.getModifiers()) || isProtected(m.getModifiers())) {
 522                             // m is public or protected
 523                             return isPublic(impl.getModifiers()) || isProtected(impl.getModifiers());
 524                         } else {
 525                             // m is package-private
 526                             return impl.getDeclaringClass().getPackage() == m.getDeclaringClass().getPackage();
 527                         }
 528                     }
 529                 }
 530             }
 531         }
 532         return false;
 533     }
 534 
 535     static final Map&lt;Class&lt;?&gt;, VTable&gt; vtables = new HashMap&lt;&gt;();
 536 
 537     static class VTable {
 538 
 539         final Map&lt;NameAndSignature, Method&gt; methods = new HashMap&lt;&gt;();
 540     }
 541 
 542     static synchronized VTable getVTable(Class&lt;?&gt; c) {
 543         VTable vtable = vtables.get(c);
 544         if (vtable == null) {
 545             vtable = new VTable();
 546             if (c != Object.class) {
 547                 VTable superVtable = getVTable(c.getSuperclass());
 548                 vtable.methods.putAll(superVtable.methods);
 549             }
 550             for (Method m : c.getDeclaredMethods()) {
 551                 if (!isStatic(m.getModifiers()) &amp;&amp; !isPrivate(m.getModifiers())) {
 552                     if (isAbstract(m.getModifiers())) {
 553                         // A subclass makes a concrete method in a superclass abstract
 554                         vtable.methods.remove(new NameAndSignature(m));
 555                     } else {
 556                         vtable.methods.put(new NameAndSignature(m), m);
 557                     }
 558                 }
 559             }
 560             vtables.put(c, vtable);
 561         }
 562         return vtable;
 563     }
 564 
 565     static Set&lt;Method&gt; findDeclarations(Method impl, Class&lt;?&gt; c) {
 566         Set&lt;Method&gt; declarations = new HashSet&lt;&gt;();
 567         NameAndSignature implSig = new NameAndSignature(impl);
 568         if (c != null) {
 569             for (Method m : c.getDeclaredMethods()) {
 570                 if (new NameAndSignature(m).equals(implSig)) {
 571                     declarations.add(m);
 572                     break;
 573                 }
 574             }
 575             if (!c.isInterface()) {
 576                 declarations.addAll(findDeclarations(impl, c.getSuperclass()));
 577             }
 578             for (Class&lt;?&gt; i : c.getInterfaces()) {
 579                 declarations.addAll(findDeclarations(impl, i));
 580             }
 581         }
 582         return declarations;
 583     }
 584 
 585     @Test
 586     public void resolveMethodTest() {
 587         ResolvedJavaType context = metaAccess.lookupJavaType(TestResolvedJavaType.class);
 588         for (Class&lt;?&gt; c : classes) {
 589             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 590             if (c.isInterface()) {
 591                 for (Method m : c.getDeclaredMethods()) {
 592                     ResolvedJavaMethod resolved = metaAccess.lookupJavaMethod(m);
 593                     ResolvedJavaMethod impl = type.resolveMethod(resolved, context);
 594                     assertEquals(m.toString(), null, impl);
 595                 }
 596             } else if (c.isPrimitive()) {
 597                 assertEquals("No methods expected", c.getDeclaredMethods().length, 0);
 598             } else {
 599                 VTable vtable = getVTable(c);
 600                 for (Method impl : vtable.methods.values()) {
 601                     Set&lt;Method&gt; decls = findDeclarations(impl, c);
 602                     for (Method decl : decls) {
 603                         ResolvedJavaMethod m = metaAccess.lookupJavaMethod(decl);
 604                         if (m.isPublic()) {
 605                             ResolvedJavaMethod i = metaAccess.lookupJavaMethod(impl);
 606                             assertEquals(m.toString(), i, type.resolveMethod(m, context));
 607                         }
 608                     }
 609                 }
 610             }
 611         }
 612     }
 613 
 614     @Test
 615     public void resolveConcreteMethodTest() {
 616         ResolvedJavaType context = metaAccess.lookupJavaType(TestResolvedJavaType.class);
 617         for (Class&lt;?&gt; c : classes) {
 618             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 619             if (c.isInterface()) {
 620                 for (Method m : c.getDeclaredMethods()) {
 621                     ResolvedJavaMethod resolved = metaAccess.lookupJavaMethod(m);
 622                     ResolvedJavaMethod impl = type.resolveConcreteMethod(resolved, context);
 623                     assertEquals(m.toString(), null, impl);
 624                 }
 625             } else if (c.isPrimitive()) {
 626                 assertEquals("No methods expected", c.getDeclaredMethods().length, 0);
 627             } else {
 628                 VTable vtable = getVTable(c);
 629                 for (Method impl : vtable.methods.values()) {
 630                     Set&lt;Method&gt; decls = findDeclarations(impl, c);
 631                     for (Method decl : decls) {
 632                         ResolvedJavaMethod m = metaAccess.lookupJavaMethod(decl);
 633                         if (m.isPublic()) {
 634                             ResolvedJavaMethod i = metaAccess.lookupJavaMethod(impl);
 635                             assertEquals(i, type.resolveConcreteMethod(m, context));
 636                         }
 637                     }
 638                 }
 639                 for (Method m : c.getDeclaredMethods()) {
 640                     ResolvedJavaMethod impl = type.resolveConcreteMethod(metaAccess.lookupJavaMethod(m), context);
 641                     ResolvedJavaMethod expected = isAbstract(m.getModifiers()) ? null : impl;
 642                     assertEquals(type + " " + m.toString(), expected, impl);
 643                 }
 644             }
 645         }
 646     }
 647 
 648     @Test
 649     public void findUniqueConcreteMethodTest() throws NoSuchMethodException {
 650         ResolvedJavaMethod thisMethod = metaAccess.lookupJavaMethod(getClass().getDeclaredMethod("findUniqueConcreteMethodTest"));
 651         ResolvedJavaMethod ucm = metaAccess.lookupJavaType(getClass()).findUniqueConcreteMethod(thisMethod).getResult();
 652         assertEquals(thisMethod, ucm);
 653     }
 654 
 655     public static Set&lt;Field&gt; getInstanceFields(Class&lt;?&gt; c, boolean includeSuperclasses) {
 656         if (c.isArray() || c.isPrimitive() || c.isInterface()) {
 657             return Collections.emptySet();
 658         }
 659         Set&lt;Field&gt; result = new HashSet&lt;&gt;();
 660         for (Field f : c.getDeclaredFields()) {
 661             if (!Modifier.isStatic(f.getModifiers())) {
 662                 result.add(f);
 663             }
 664         }
 665         if (includeSuperclasses &amp;&amp; c != Object.class) {
 666             result.addAll(getInstanceFields(c.getSuperclass(), true));
 667         }
 668         return result;
 669     }
 670 
 671     public static Set&lt;Field&gt; getStaticFields(Class&lt;?&gt; c) {
 672         Set&lt;Field&gt; result = new HashSet&lt;&gt;();
 673         for (Field f : c.getDeclaredFields()) {
 674             if (Modifier.isStatic(f.getModifiers())) {
 675                 result.add(f);
 676             }
 677         }
 678         return result;
 679     }
 680 
 681     public boolean fieldsEqual(Field f, ResolvedJavaField rjf) {
 682         return rjf.getDeclaringClass().equals(metaAccess.lookupJavaType(f.getDeclaringClass())) &amp;&amp; rjf.getName().equals(f.getName()) &amp;&amp;
 683                         rjf.getType().resolve(rjf.getDeclaringClass()).equals(metaAccess.lookupJavaType(f.getType()));
 684     }
 685 
 686     public ResolvedJavaField lookupField(ResolvedJavaField[] fields, Field key) {
 687         for (ResolvedJavaField rf : fields) {
 688             if (fieldsEqual(key, rf)) {
 689                 return rf;
 690             }
 691         }
 692         return null;
 693     }
 694 
 695     public Field lookupField(Set&lt;Field&gt; fields, ResolvedJavaField key) {
 696         for (Field f : fields) {
 697             if (fieldsEqual(f, key)) {
 698                 return f;
 699             }
 700         }
 701         return null;
 702     }
 703 
 704     private static boolean isHiddenFromReflection(ResolvedJavaField f) {
 705         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Throwable.class)) &amp;&amp; f.getName().equals("backtrace")) {
 706             return true;
 707         }
 708         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(ConstantPool.class)) &amp;&amp; f.getName().equals("constantPoolOop")) {
 709             return true;
 710         }
 711         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Class.class)) &amp;&amp; f.getName().equals("classLoader")) {
 712             return true;
 713         }
 714         return false;
 715     }
 716 
 717     @Test
 718     public void getInstanceFieldsTest() {
 719         for (Class&lt;?&gt; c : classes) {
 720             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 721             for (boolean includeSuperclasses : new boolean[]{true, false}) {
 722                 Set&lt;Field&gt; expected = getInstanceFields(c, includeSuperclasses);
 723                 ResolvedJavaField[] actual = type.getInstanceFields(includeSuperclasses);
 724                 for (Field f : expected) {
 725                     assertNotNull(lookupField(actual, f));
 726                 }
 727                 for (ResolvedJavaField rf : actual) {
 728                     if (!isHiddenFromReflection(rf)) {
 729                         assertEquals(rf.toString(), lookupField(expected, rf) != null, !rf.isInternal());
 730                     }
 731                 }
 732 
 733                 // Test stability of getInstanceFields
 734                 ResolvedJavaField[] actual2 = type.getInstanceFields(includeSuperclasses);
 735                 assertArrayEquals(actual, actual2);
 736             }
 737         }
 738     }
 739 
 740     @Test
 741     public void getStaticFieldsTest() {
 742         for (Class&lt;?&gt; c : classes) {
 743             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 744             Set&lt;Field&gt; expected = getStaticFields(c);
 745             ResolvedJavaField[] actual = type.getStaticFields();
 746             for (Field f : expected) {
 747                 assertNotNull(lookupField(actual, f));
 748             }
 749             for (ResolvedJavaField rf : actual) {
 750                 if (!isHiddenFromReflection(rf)) {
 751                     assertEquals(lookupField(expected, rf) != null, !rf.isInternal());
 752                 }
 753             }
 754 
 755             // Test stability of getStaticFields
 756             ResolvedJavaField[] actual2 = type.getStaticFields();
 757             assertArrayEquals(actual, actual2);
 758         }
 759     }
 760 
 761     @Test
 762     public void getDeclaredMethodsTest() {
 763         for (Class&lt;?&gt; c : classes) {
 764             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 765             Method[] raw = c.getDeclaredMethods();
 766             Set&lt;ResolvedJavaMethod&gt; expected = new HashSet&lt;&gt;();
 767             for (Method m : raw) {
 768                 ResolvedJavaMethod resolvedMethod = metaAccess.lookupJavaMethod(m);
 769                 assertNotNull(resolvedMethod);
 770                 expected.add(resolvedMethod);
 771             }
 772             Set&lt;ResolvedJavaMethod&gt; actual = new HashSet&lt;&gt;(Arrays.asList(type.getDeclaredMethods()));
 773             assertEquals(expected, actual);
 774         }
 775     }
 776 
 777     static class A {
 778         static String name = "foo";
 779     }
 780 
 781     static class B extends A {
 782     }
 783 
 784     static class C {
 785     }
 786 
 787     static class D {
 788         void foo() {
 789             // use of assertions causes the class to have a &lt;clinit&gt;
 790             assert getClass() != null;
 791         }
 792     }
 793 
 794     static class SubD extends D {
 795 
 796     }
 797 
 798     @Test
 799     public void getClassInitializerTest() {
 800         assertNotNull(metaAccess.lookupJavaType(A.class).getClassInitializer());
 801         assertNotNull(metaAccess.lookupJavaType(D.class).getClassInitializer());
 802         assertNull(metaAccess.lookupJavaType(B.class).getClassInitializer());
 803         assertNull(metaAccess.lookupJavaType(C.class).getClassInitializer());
 804         assertNull(metaAccess.lookupJavaType(int.class).getClassInitializer());
 805         assertNull(metaAccess.lookupJavaType(void.class).getClassInitializer());
 806     }
 807 
 808     @Test
 809     public void getAnnotationsTest() {
 810         for (Class&lt;?&gt; c : classes) {
 811             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 812             assertArrayEquals(c.getAnnotations(), type.getAnnotations());
 813         }
 814     }
 815 
 816     @Test
 817     public void getAnnotationTest() {
 818         for (Class&lt;?&gt; c : classes) {
 819             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 820             for (Annotation a : c.getAnnotations()) {
 821                 assertEquals(a, type.getAnnotation(a.annotationType()));
 822             }
 823         }
 824     }
 825 
 826     @Test
 827     public void memberClassesTest() {
 828         for (Class&lt;?&gt; c : classes) {
 829             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 830             assertEquals(c.isLocalClass(), type.isLocal());
 831             assertEquals(c.isMemberClass(), type.isMember());
 832             Class&lt;?&gt; enclc = c.getEnclosingClass();
 833             ResolvedJavaType enclt = type.getEnclosingType();
 834             assertFalse(enclc == null ^ enclt == null);
 835             if (enclc != null) {
 836                 assertEquals(enclt, metaAccess.lookupJavaType(enclc));
 837             }
 838         }
 839     }
 840 
 841     @Test
 842     public void isLeafTest() {
 843         for (Class&lt;?&gt; c : classes) {
 844             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 845             ResolvedJavaType arrayType = c != void.class ? metaAccess.lookupJavaType(getArrayClass(c)) : null;
 846             if (c.isPrimitive()) {
 847                 assertTrue(type.isLeaf());
 848                 assertTrue(arrayType == null || arrayType.isLeaf());
 849             } else {
 850                 assertTrue(c.toString(), type.isLeaf() == arrayType.isLeaf());
 851                 if (!c.isArray()) {
 852                     assertTrue(c.toString(), type.isLeaf() == Modifier.isFinal(c.getModifiers()));
 853                 }
 854             }
 855         }
 856     }
 857 
 858     static class TrivialCloneable implements Cloneable {
 859         @Override
 860         protected Object clone() {
 861             return new TrivialCloneable();
 862         }
 863     }
 864 
 865     @Test
 866     public void isCloneableWithAllocationTest() {
 867         ResolvedJavaType cloneable = metaAccess.lookupJavaType(Cloneable.class);
 868         for (Class&lt;?&gt; c : classes) {
 869             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 870             if (type.isCloneableWithAllocation()) {
 871                 // Only Cloneable types should be allocation cloneable
 872                 assertTrue(c.toString(), cloneable.isAssignableFrom(type));
 873             }
 874         }
 875         /*
 876          * We can't know for sure which types should be allocation cloneable on a particular
 877          * platform but assume that at least totally trivial objects should be.
 878          */
 879         ResolvedJavaType trivialCloneable = metaAccess.lookupJavaType(TrivialCloneable.class);
 880         assertTrue(trivialCloneable.toString(), trivialCloneable.isCloneableWithAllocation());
 881     }
 882 
 883     @Test
 884     public void findMethodTest() {
 885         try {
 886             ResolvedJavaMethod findFoo = metaAccess.lookupJavaType(D.class).findMethod("foo", metaAccess.parseMethodDescriptor("()V"));
 887             ResolvedJavaMethod expectedFoo = metaAccess.lookupJavaMethod(D.class.getDeclaredMethod("foo"));
 888             assertEquals(expectedFoo, findFoo);
 889 
 890             ResolvedJavaMethod wrongReturnTypeFoo = metaAccess.lookupJavaType(D.class).findMethod("foo", metaAccess.parseMethodDescriptor("()I"));
 891             assertNull(wrongReturnTypeFoo);
 892 
 893             ResolvedJavaMethod wrongArgumentsFoo = metaAccess.lookupJavaType(D.class).findMethod("foo", metaAccess.parseMethodDescriptor("(I)V"));
 894             assertNull(wrongArgumentsFoo);
 895 
 896             ResolvedJavaMethod wrongNameFoo = metaAccess.lookupJavaType(D.class).findMethod("bar", metaAccess.parseMethodDescriptor("()V"));
 897             assertNull(wrongNameFoo);
 898 
 899             ResolvedJavaMethod wrongClassFoo = metaAccess.lookupJavaType(SubD.class).findMethod("foo", metaAccess.parseMethodDescriptor("()V"));
 900             assertNull(wrongClassFoo);
 901         } catch (NoSuchMethodException | SecurityException e) {
 902             throw new RuntimeException(e);
 903         }
 904     }
 905 
 906     private Method findTestMethod(Method apiMethod) {
 907         String testName = apiMethod.getName() + "Test";
 908         for (Method m : getClass().getDeclaredMethods()) {
 909             if (m.getName().equals(testName) &amp;&amp; m.getAnnotation(Test.class) != null) {
 910                 return m;
 911             }
 912         }
 913         return null;
 914     }
 915 
 916     // @formatter:off
 917     private static final String[] untestedApiMethods = {
 918         "initialize",
 919         "isPrimitive",
 920         "newArray",
 921         "getDeclaredConstructors",
 922         "isInitialized",
 923         "isLinked",
 924         "getJavaClass",
 925         "getObjectHub",
 926         "hasFinalizableSubclass",
 927         "hasFinalizer",
 928         "getSourceFileName",
 929         "getClassFilePath",
 930         "isLocal",
 931         "isJavaLangObject",
 932         "isMember",
 933         "getElementalType",
 934         "getEnclosingType",
 935         "$jacocoInit",
 936         "isCpiSet",
 937         "getCorrespondingCpi",
 938         "setCorrespondingCpi"
 939     };
 940     // @formatter:on
 941 
 942     /**
 943      * Ensures that any new methods added to {@link ResolvedJavaMethod} either have a test written
 944      * for them or are added to {@link #untestedApiMethods}.
 945      */
 946     @Test
 947     public void testCoverage() {
 948         Set&lt;String&gt; known = new HashSet&lt;&gt;(Arrays.asList(untestedApiMethods));
 949         for (Method m : ResolvedJavaType.class.getDeclaredMethods()) {
 950             if (findTestMethod(m) == null) {
 951                 assertTrue("test missing for " + m, known.contains(m.getName()));
 952             } else {
 953                 assertFalse("test should be removed from untestedApiMethods" + m, known.contains(m.getName()));
 954             }
 955         }
 956     }
 957 }
</pre></body></html>
