--- old/.mx.jvmci/suite.py	2016-05-12 09:40:36.000000000 +0200
+++ new/.mx.jvmci/suite.py	2016-05-12 09:40:36.000000000 +0200
@@ -1,5 +1,5 @@
 suite = {
-  "mxversion" : "5.6.16",
+  "mxversion" : "5.22.0",
   "name" : "jvmci",
   "url" : "http://openjdk.java.net/projects/graal",
   "developer" : {
@@ -58,14 +58,6 @@
 
     # ------------- JVMCI:API -------------
 
-    "jdk.vm.ci.common" : {
-      "subDir" : "src/jdk.vm.ci/share/classes",
-      "sourceDirs" : ["src"],
-      "checkstyle" : "jdk.vm.ci.services",
-      "javaCompliance" : "1.8",
-      "workingSets" : "API,JVMCI",
-    },
-
     "jdk.vm.ci.meta" : {
       "subDir" : "src/jdk.vm.ci/share/classes",
       "sourceDirs" : ["src"],
@@ -115,7 +107,6 @@
       "sourceDirs" : ["src"],
       "dependencies" : [
         "mx:JUNIT",
-        "jdk.vm.ci.common",
         "jdk.vm.ci.runtime",
       ],
       "checkstyle" : "jdk.vm.ci.services",
@@ -165,7 +156,6 @@
       "sourceDirs" : ["src"],
       "dependencies" : [
         "jdk.vm.ci.hotspotvmconfig",
-        "jdk.vm.ci.common",
         "jdk.vm.ci.inittimer",
         "jdk.vm.ci.runtime",
         "jdk.vm.ci.services",
@@ -252,7 +242,6 @@
       "dependencies" : [
         "jdk.vm.ci.inittimer",
         "jdk.vm.ci.runtime",
-        "jdk.vm.ci.common",
         "jdk.vm.ci.aarch64",
         "jdk.vm.ci.amd64",
         "jdk.vm.ci.sparc",
@@ -308,7 +297,6 @@
         "jdk.vm.ci.services",
         "jdk.vm.ci.inittimer",
         "jdk.vm.ci.runtime",
-        "jdk.vm.ci.common",
         "jdk.vm.ci.aarch64",
         "jdk.vm.ci.amd64",
         "jdk.vm.ci.sparc",
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotRegisterConfig.java	2016-05-12 09:40:37.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotRegisterConfig.java	2016-05-12 09:40:36.000000000 +0200
@@ -64,7 +64,6 @@
 import jdk.vm.ci.code.RegisterConfig;
 import jdk.vm.ci.code.StackSlot;
 import jdk.vm.ci.code.TargetDescription;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 import jdk.vm.ci.hotspot.HotSpotVMConfig;
 import jdk.vm.ci.meta.AllocatableValue;
@@ -226,7 +225,7 @@
             case Double:
                 return simdParameterRegisters;
             default:
-                throw JVMCIError.shouldNotReachHere();
+                throw new InternalError("should not reach here");
         }
     }
 
@@ -261,7 +260,7 @@
                     }
                     break;
                 default:
-                    throw JVMCIError.shouldNotReachHere();
+                    throw new InternalError("should not reach here");
             }
 
             if (locations[i] == null) {
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.amd64/src/jdk/vm/ci/hotspot/amd64/AMD64HotSpotRegisterConfig.java	2016-05-12 09:40:37.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.amd64/src/jdk/vm/ci/hotspot/amd64/AMD64HotSpotRegisterConfig.java	2016-05-12 09:40:37.000000000 +0200
@@ -56,7 +56,6 @@
 import jdk.vm.ci.code.RegisterConfig;
 import jdk.vm.ci.code.StackSlot;
 import jdk.vm.ci.code.TargetDescription;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 import jdk.vm.ci.hotspot.HotSpotVMConfig;
 import jdk.vm.ci.meta.AllocatableValue;
@@ -223,7 +222,7 @@
             case Double:
                 return xmmParameterRegisters;
             default:
-                throw JVMCIError.shouldNotReachHere();
+                throw new InternalError("should not reach here");
         }
     }
 
@@ -258,7 +257,7 @@
                     }
                     break;
                 default:
-                    throw JVMCIError.shouldNotReachHere();
+                    throw new InternalError("should not reach here");
             }
 
             if (locations[i] == null) {
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.sparc/src/jdk/vm/ci/hotspot/sparc/SPARCHotSpotRegisterConfig.java	2016-05-12 09:40:38.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot.sparc/src/jdk/vm/ci/hotspot/sparc/SPARCHotSpotRegisterConfig.java	2016-05-12 09:40:38.000000000 +0200
@@ -78,7 +78,6 @@
 import jdk.vm.ci.code.RegisterConfig;
 import jdk.vm.ci.code.StackSlot;
 import jdk.vm.ci.code.TargetDescription;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 import jdk.vm.ci.hotspot.HotSpotVMConfig;
 import jdk.vm.ci.meta.AllocatableValue;
@@ -211,7 +210,7 @@
         if (type == HotSpotCallingConventionType.JavaCallee) {
             return callingConvention(cpuCalleeParameterRegisters, returnType, parameterTypes, hotspotType, target);
         }
-        throw JVMCIError.shouldNotReachHere();
+        throw new InternalError("should not reach here");
     }
 
     @Override
@@ -230,7 +229,7 @@
             case Float:
                 return fpuFloatParameterRegisters;
             default:
-                throw JVMCIError.shouldNotReachHere("Unknown JavaKind " + kind);
+                throw new InternalError("Unknown JavaKind " + kind);
         }
     }
 
@@ -275,7 +274,7 @@
                     }
                     break;
                 default:
-                    throw JVMCIError.shouldNotReachHere();
+                    throw new InternalError("should not reach here");
             }
 
             if (locations[i] == null) {
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java	2016-05-12 09:40:39.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java	2016-05-12 09:40:38.000000000 +0200
@@ -29,17 +29,16 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 
+import jdk.internal.misc.Unsafe;
 import jdk.vm.ci.code.BytecodeFrame;
 import jdk.vm.ci.code.InstalledCode;
 import jdk.vm.ci.code.InvalidInstalledCodeException;
 import jdk.vm.ci.code.TargetDescription;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspotvmconfig.HotSpotVMField;
 import jdk.vm.ci.inittimer.InitTimer;
 import jdk.vm.ci.meta.JavaType;
 import jdk.vm.ci.meta.ResolvedJavaMethod;
 import jdk.vm.ci.meta.ResolvedJavaType;
-import jdk.internal.misc.Unsafe;
 
 /**
  * Calls from Java into HotSpot. The behavior of all the methods in this class that take a native
@@ -310,7 +309,7 @@
      *         {@link HotSpotVMConfig#codeInstallResultCodeTooLarge},
      *         {@link HotSpotVMConfig#codeInstallResultDependenciesFailed} or
      *         {@link HotSpotVMConfig#codeInstallResultDependenciesInvalid}.
-     * @throws JVMCIError if there is something wrong with the compiled code or the associated
+     * @throws InternalError if there is something wrong with the compiled code or the associated
      *             metadata.
      */
     native int installCode(TargetDescription target, HotSpotCompiledCode compiledCode, InstalledCode code, HotSpotSpeculationLog speculationLog);
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotConstantPool.java	2016-05-12 09:40:39.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotConstantPool.java	2016-05-12 09:40:39.000000000 +0200
@@ -29,7 +29,6 @@
 
 import java.lang.invoke.MethodHandle;
 
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.meta.ConstantPool;
 import jdk.vm.ci.meta.JavaConstant;
 import jdk.vm.ci.meta.JavaField;
@@ -158,7 +157,7 @@
                 if (res != null) {
                     return res;
                 }
-                throw new JVMCIError("Unknown JVM_CONSTANT tag %s", tag);
+                throw new InternalError("Unknown JVM_CONSTANT tag " + tag);
             }
         }
 
@@ -508,7 +507,7 @@
                 Object obj = compilerToVM().resolveConstantInPool(this, cpi);
                 return HotSpotObjectConstantImpl.forObject(obj);
             default:
-                throw new JVMCIError("Unknown constant pool tag %s", tag);
+                throw new InternalError("Unknown constant pool tag " + tag);
         }
     }
 
@@ -655,7 +654,7 @@
                 break;
             }
             default:
-                throw JVMCIError.shouldNotReachHere("Unexpected opcode " + opcode);
+                throw new InternalError("Unexpected opcode " + opcode);
         }
 
         final JVM_CONSTANT tag = getTagAt(index);
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotConstantReflectionProvider.java	2016-05-12 09:40:40.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotConstantReflectionProvider.java	2016-05-12 09:40:40.000000000 +0200
@@ -29,7 +29,6 @@
 import java.util.Objects;
 
 import jdk.internal.vm.annotation.Stable;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.Option;
 import jdk.vm.ci.meta.Constant;
 import jdk.vm.ci.meta.ConstantReflectionProvider;
@@ -369,7 +368,7 @@
         if (type instanceof HotSpotResolvedObjectType) {
             return ((HotSpotResolvedObjectType) type).klass();
         } else {
-            throw JVMCIError.unimplemented();
+            throw new InternalError();
         }
     }
 }
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCICompilerConfig.java	2016-05-12 09:40:41.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCICompilerConfig.java	2016-05-12 09:40:40.000000000 +0200
@@ -26,7 +26,6 @@
 
 import jdk.vm.ci.code.CompilationRequest;
 import jdk.vm.ci.code.CompilationRequestResult;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.Option;
 import jdk.vm.ci.runtime.JVMCICompiler;
 import jdk.vm.ci.runtime.JVMCIRuntime;
@@ -38,7 +37,7 @@
     private static class DummyCompilerFactory extends JVMCICompilerFactory implements JVMCICompiler {
 
         public CompilationRequestResult compileMethod(CompilationRequest request) {
-            throw new JVMCIError("no JVMCI compiler selected");
+            throw new InternalError("no JVMCI compiler selected");
         }
 
         @Override
@@ -76,7 +75,7 @@
                     }
                 }
                 if (factory == null) {
-                    throw new JVMCIError("JVMCI compiler '%s' not found", compilerName);
+                    throw new InternalError(String.format("JVMCI compiler '%s' not found", compilerName));
                 }
             } else {
                 factory = new DummyCompilerFactory();
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java	2016-05-12 09:40:41.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java	2016-05-12 09:40:41.000000000 +0200
@@ -37,11 +37,11 @@
 import java.util.Objects;
 import java.util.TreeMap;
 
+import jdk.internal.misc.VM;
 import jdk.vm.ci.code.Architecture;
 import jdk.vm.ci.code.CompilationRequestResult;
 import jdk.vm.ci.code.CompiledCode;
 import jdk.vm.ci.code.InstalledCode;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspot.services.HotSpotJVMCICompilerFactory;
 import jdk.vm.ci.hotspot.services.HotSpotVMEventListener;
 import jdk.vm.ci.inittimer.InitTimer;
@@ -55,7 +55,6 @@
 import jdk.vm.ci.runtime.JVMCICompiler;
 import jdk.vm.ci.runtime.services.JVMCICompilerFactory;
 import jdk.vm.ci.services.Services;
-import jdk.internal.misc.VM;
 
 //JaCoCo Exclude
 
@@ -141,7 +140,7 @@
                     } else if (type == String.class) {
                         this.value = propertyValue;
                     } else {
-                        throw new JVMCIError("Unexpected option type " + type);
+                        throw new InternalError("Unexpected option type " + type);
                     }
                     this.isDefault = false;
                 }
@@ -191,7 +190,7 @@
             }
         }
 
-        throw new JVMCIError("No JVMCI runtime available for the %s architecture", architecture);
+        throw new InternalError(String.format("No JVMCI runtime available for the %s architecture", architecture));
     }
 
     /**
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntimeProvider.java	2016-05-12 09:40:42.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntimeProvider.java	2016-05-12 09:40:42.000000000 +0200
@@ -24,13 +24,12 @@
 
 import java.io.OutputStream;
 
-import jdk.vm.ci.common.JVMCIError;
+import jdk.internal.misc.Unsafe;
 import jdk.vm.ci.meta.JVMCIMetaAccessContext;
 import jdk.vm.ci.meta.JavaKind;
 import jdk.vm.ci.meta.JavaType;
 import jdk.vm.ci.meta.ResolvedJavaType;
 import jdk.vm.ci.runtime.JVMCIRuntime;
-import jdk.internal.misc.Unsafe;
 
 //JaCoCo Exclude
 
@@ -98,7 +97,7 @@
             case Object:
                 return Unsafe.ARRAY_OBJECT_BASE_OFFSET;
             default:
-                throw new JVMCIError("%s", kind);
+                throw new InternalError(kind.toString());
         }
     }
 
@@ -128,7 +127,7 @@
             case Object:
                 return Unsafe.ARRAY_OBJECT_INDEX_SCALE;
             default:
-                throw new JVMCIError("%s", kind);
+                throw new InternalError(kind.toString());
         }
     }
 }
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMetaAccessProvider.java	2016-05-12 09:40:42.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMetaAccessProvider.java	2016-05-12 09:40:42.000000000 +0200
@@ -36,7 +36,6 @@
 
 import jdk.vm.ci.code.CodeUtil;
 import jdk.vm.ci.code.TargetDescription;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.meta.DeoptimizationAction;
 import jdk.vm.ci.meta.DeoptimizationReason;
 import jdk.vm.ci.meta.JavaConstant;
@@ -103,7 +102,7 @@
             field.setAccessible(true);
             return field;
         } catch (NoSuchFieldException | SecurityException e) {
-            throw new JVMCIError(e);
+            throw new InternalError(e);
         }
     }
 
@@ -114,7 +113,7 @@
             final int slot = slotField.getInt(reflectionMethod);
             return runtime.getCompilerToVM().getResolvedJavaMethodAtSlot(holder, slot);
         } catch (IllegalArgumentException | IllegalAccessException e) {
-            throw new JVMCIError(e);
+            throw new InternalError(e);
         }
     }
 
@@ -138,7 +137,7 @@
             }
         }
 
-        throw new JVMCIError("unresolved field %s", reflectionField);
+        throw new InternalError("unresolved field " + reflectionField);
     }
 
     private static int intMaskRight(int n) {
@@ -191,7 +190,7 @@
             case InvalidateStopCompiling:
                 return config.deoptActionMakeNotCompilable;
             default:
-                throw new JVMCIError("%s", action);
+                throw new InternalError(action.toString());
         }
     }
 
@@ -212,7 +211,7 @@
         if (action == config.deoptActionMakeNotCompilable) {
             return DeoptimizationAction.InvalidateStopCompiling;
         }
-        throw new JVMCIError("%d", action);
+        throw new InternalError(String.valueOf(action));
     }
 
     public int convertDeoptReason(DeoptimizationReason reason) {
@@ -251,7 +250,7 @@
             case TransferToInterpreter:
                 return config.deoptReasonTransferToInterpreter;
             default:
-                throw new JVMCIError("%s", reason);
+                throw new InternalError(reason.toString());
         }
     }
 
@@ -305,7 +304,7 @@
         if (reason == config.deoptReasonTransferToInterpreter) {
             return DeoptimizationReason.TransferToInterpreter;
         }
-        throw new JVMCIError("%x", reason);
+        throw new InternalError(String.format("%x", reason));
     }
 
     @Override
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodHandleAccessProvider.java	2016-05-12 09:40:43.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodHandleAccessProvider.java	2016-05-12 09:40:43.000000000 +0200
@@ -25,7 +25,7 @@
 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 import static jdk.vm.ci.hotspot.HotSpotResolvedObjectTypeImpl.fromObjectClass;
-import jdk.vm.ci.common.JVMCIError;
+
 import jdk.vm.ci.meta.ConstantReflectionProvider;
 import jdk.vm.ci.meta.JavaConstant;
 import jdk.vm.ci.meta.MethodHandleAccessProvider;
@@ -92,7 +92,7 @@
                 lambdaFormCompileToBytecodeMethod = findMethodInClass("java.lang.invoke.LambdaForm", "compileToBytecode");
                 memberNameVmtargetField = (HotSpotResolvedJavaField) findFieldInClass("java.lang.invoke.MemberName", "vmtarget");
             } catch (Throwable ex) {
-                throw new JVMCIError(ex);
+                throw new InternalError(ex);
             }
         }
     }
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaFieldImpl.java	2016-05-12 09:40:44.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaFieldImpl.java	2016-05-12 09:40:44.000000000 +0200
@@ -29,7 +29,6 @@
 import java.lang.reflect.Field;
 
 import jdk.internal.vm.annotation.Stable;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.Option;
 import jdk.vm.ci.meta.JavaType;
 import jdk.vm.ci.meta.LocationIdentity;
@@ -301,7 +300,7 @@
                 MetaAccessProvider metaAccess = runtime().getHostJVMCIBackend().getMetaAccess();
                 STRING_VALUE_FIELD = metaAccess.lookupJavaField(String.class.getDeclaredField("value"));
             } catch (SecurityException | NoSuchFieldException e) {
-                throw new JVMCIError(e);
+                throw new InternalError(e);
             }
         }
     }
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl.java	2016-05-12 09:40:44.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl.java	2016-05-12 09:40:44.000000000 +0200
@@ -36,7 +36,6 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.Option;
 import jdk.vm.ci.meta.Constant;
 import jdk.vm.ci.meta.ConstantPool;
@@ -614,7 +613,7 @@
      */
     public int vtableEntryOffset(ResolvedJavaType resolved) {
         if (!isInVirtualMethodTable(resolved)) {
-            throw new JVMCIError("%s does not have a vtable entry in type %s", this, resolved);
+            throw new InternalError(String.format("%s does not have a vtable entry in type %s", this, resolved));
         }
         HotSpotVMConfig config = config();
         final int vtableIndex = getVtableIndex((HotSpotResolvedObjectTypeImpl) resolved);
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java	2016-05-12 09:40:45.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java	2016-05-12 09:40:45.000000000 +0200
@@ -38,7 +38,6 @@
 import java.util.Arrays;
 import java.util.HashMap;
 
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
@@ -127,9 +126,9 @@
      */
     long getMetaspaceKlass() {
         if (HotSpotJVMCIRuntime.getHostWordKind() == JavaKind.Long) {
-            return UNSAFE.getLong(javaClass, (long) config().klassOffset);
+            return UNSAFE.getLong(javaClass, config().klassOffset);
         }
-        return UNSAFE.getInt(javaClass, (long) config().klassOffset) & 0xFFFFFFFFL;
+        return UNSAFE.getInt(javaClass, config().klassOffset) & 0xFFFFFFFFL;
     }
 
     public long getMetaspacePointer() {
@@ -256,7 +255,7 @@
     @Override
     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
         if (!isInterface()) {
-            throw new JVMCIError("Cannot call getSingleImplementor() on a non-interface type: %s", this);
+            throw new InternalError("Cannot call getSingleImplementor() on a non-interface type: " + this);
         }
         return compilerToVM().getImplementor(this);
     }
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedPrimitiveType.java	2016-05-12 09:40:46.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedPrimitiveType.java	2016-05-12 09:40:46.000000000 +0200
@@ -28,7 +28,6 @@
 import java.lang.reflect.Array;
 import java.lang.reflect.Modifier;
 
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 import jdk.vm.ci.meta.JavaConstant;
 import jdk.vm.ci.meta.JavaKind;
@@ -100,7 +99,7 @@
 
     @Override
     public ResolvedJavaType getSingleImplementor() {
-        throw new JVMCIError("Cannot call getSingleImplementor() on a non-interface type: %s", this);
+        throw new InternalError("Cannot call getSingleImplementor() on a non-interface type: " + this);
     }
 
     @Override
@@ -230,7 +229,7 @@
 
     @Override
     public String getSourceFileName() {
-        throw JVMCIError.unimplemented();
+        throw new InternalError();
     }
 
     @Override
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotSignature.java	2016-05-12 09:40:47.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotSignature.java	2016-05-12 09:40:46.000000000 +0200
@@ -25,7 +25,6 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.meta.JavaKind;
 import jdk.vm.ci.meta.JavaType;
 import jdk.vm.ci.meta.ResolvedJavaType;
@@ -105,7 +104,7 @@
             case 'Z':
                 break;
             default:
-                throw new JVMCIError("Invalid character at index %d in signature: %s", cur, signature);
+                throw new InternalError(String.format("Invalid character at index %d in signature: %s", cur, signature));
         }
         return cur;
     }
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfig.java	2016-05-12 09:40:47.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfig.java	2016-05-12 09:40:47.000000000 +0200
@@ -22,7 +22,6 @@
  */
 package jdk.vm.ci.hotspot;
 
-import static jdk.vm.ci.common.UnsafeUtil.readCString;
 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 
@@ -31,15 +30,14 @@
 import java.util.HashMap;
 import java.util.Iterator;
 
+import jdk.internal.misc.Unsafe;
 import jdk.internal.vm.annotation.Stable;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspotvmconfig.HotSpotVMAddress;
 import jdk.vm.ci.hotspotvmconfig.HotSpotVMConstant;
 import jdk.vm.ci.hotspotvmconfig.HotSpotVMData;
 import jdk.vm.ci.hotspotvmconfig.HotSpotVMField;
 import jdk.vm.ci.hotspotvmconfig.HotSpotVMFlag;
 import jdk.vm.ci.hotspotvmconfig.HotSpotVMType;
-import jdk.internal.misc.Unsafe;
 
 //JaCoCo Exclude
 
@@ -83,7 +81,7 @@
                 try {
                     f.setLong(this, value);
                 } catch (IllegalAccessException e) {
-                    throw new JVMCIError("index " + index, e);
+                    throw new InternalError("index " + index, e);
                 }
             }
         }
@@ -110,6 +108,27 @@
     }
 
     /**
+     * Reads a {@code '\0'} terminated C string from native memory and converts it to a
+     * {@link String}.
+     *
+     * @return a Java string
+     */
+    static String readCString(Unsafe unsafe, long address) {
+        if (address == 0) {
+            return null;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0;; i++) {
+            char c = (char) unsafe.getByte(address + i);
+            if (c == 0) {
+                break;
+            }
+            sb.append(c);
+        }
+        return sb.toString();
+    }
+
+    /**
      * Initialize fields by reading their values from vmStructs.
      */
     private void initialize() {
@@ -159,13 +178,13 @@
                     if (!isRequired(osArch, annotation.archs())) {
                         continue;
                     }
-                    throw new JVMCIError(f.getName() + ": expected VM field not found: " + name);
+                    throw new InternalError(f.getName() + ": expected VM field not found: " + name);
                 }
 
                 // Make sure the native type is still the type we expect.
                 if (!type.isEmpty()) {
                     if (!type.equals(entry.getTypeString())) {
-                        throw new JVMCIError(f.getName() + ": compiler expects type " + type + " but VM field " + name + " is of type " + entry.getTypeString());
+                        throw new InternalError(f.getName() + ": compiler expects type " + type + " but VM field " + name + " is of type " + entry.getTypeString());
                     }
                 }
 
@@ -180,14 +199,14 @@
                         setField(f, entry.getValue());
                         break;
                     default:
-                        throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
+                        throw new InternalError(f.getName() + ": unknown kind: " + annotation.get());
                 }
             } else if (f.isAnnotationPresent(HotSpotVMType.class)) {
                 HotSpotVMType annotation = f.getAnnotation(HotSpotVMType.class);
                 String name = annotation.name();
                 VMTypes.Type entry = vmTypes.get(name);
                 if (entry == null) {
-                    throw new JVMCIError(f.getName() + ": expected VM type not found: " + name);
+                    throw new InternalError(f.getName() + ": expected VM type not found: " + name);
                 }
 
                 switch (annotation.get()) {
@@ -195,7 +214,7 @@
                         setField(f, entry.getSize());
                         break;
                     default:
-                        throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
+                        throw new InternalError(f.getName() + ": unknown kind: " + annotation.get());
                 }
             } else if (f.isAnnotationPresent(HotSpotVMConstant.class)) {
                 HotSpotVMConstant annotation = f.getAnnotation(HotSpotVMConstant.class);
@@ -205,7 +224,7 @@
                     if (!isRequired(osArch, annotation.archs())) {
                         continue;
                     }
-                    throw new JVMCIError(f.getName() + ": expected VM constant not found: " + name);
+                    throw new InternalError(f.getName() + ": expected VM constant not found: " + name);
                 }
                 setField(f, entry.getValue());
             } else if (f.isAnnotationPresent(HotSpotVMAddress.class)) {
@@ -216,7 +235,7 @@
                     if (!isRequired(osName, annotation.os())) {
                         continue;
                     }
-                    throw new JVMCIError(f.getName() + ": expected VM address not found: " + name);
+                    throw new InternalError(f.getName() + ": expected VM address not found: " + name);
                 }
                 setField(f, entry.getValue());
             } else if (f.isAnnotationPresent(HotSpotVMFlag.class)) {
@@ -227,7 +246,7 @@
                     if (annotation.optional() || !isRequired(osArch, annotation.archs())) {
                         continue;
                     }
-                    throw new JVMCIError(f.getName() + ": expected VM flag not found: " + name);
+                    throw new InternalError(f.getName() + ": expected VM flag not found: " + name);
 
                 }
                 setField(f, entry.getValue());
@@ -257,13 +276,13 @@
                 } else if (value instanceof Long) {
                     field.setBoolean(this, ((long) value) != 0);
                 } else {
-                    throw new JVMCIError(value.getClass().getSimpleName());
+                    throw new InternalError(value.getClass().getSimpleName());
                 }
             } else if (fieldType == byte.class) {
                 if (value instanceof Long) {
                     field.setByte(this, (byte) (long) value);
                 } else {
-                    throw new JVMCIError(value.getClass().getSimpleName());
+                    throw new InternalError(value.getClass().getSimpleName());
                 }
             } else if (fieldType == int.class) {
                 if (value instanceof Integer) {
@@ -271,15 +290,15 @@
                 } else if (value instanceof Long) {
                     field.setInt(this, (int) (long) value);
                 } else {
-                    throw new JVMCIError(value.getClass().getSimpleName());
+                    throw new InternalError(value.getClass().getSimpleName());
                 }
             } else if (fieldType == long.class) {
                 field.setLong(this, (long) value);
             } else {
-                throw new JVMCIError(field.toString());
+                throw new InternalError(field.toString());
             }
         } catch (IllegalAccessException e) {
-            throw new JVMCIError("%s: %s", field, e);
+            throw new InternalError(String.format("%s: %s", field, e));
         }
     }
 
@@ -303,7 +322,7 @@
                 if (osName.startsWith("Windows")) {
                     osName = "windows";
                 } else {
-                    throw new JVMCIError("Unexpected OS name: " + osName);
+                    throw new InternalError("Unexpected OS name: " + osName);
                 }
         }
         return osName;
@@ -450,7 +469,7 @@
                         if (type.endsWith("*")) {
                             return UNSAFE.getAddress(getAddress());
                         }
-                        throw new JVMCIError(type);
+                        throw new InternalError(type);
                 }
             }
 
@@ -827,7 +846,7 @@
                     case "ccstrlist":
                         return readCString(UNSAFE, getAddr());
                     default:
-                        throw new JVMCIError(getType());
+                        throw new InternalError(getType());
                 }
             }
 
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfigVerifier.java	2016-05-12 09:40:48.000000000 +0200
+++ new/src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfigVerifier.java	2016-05-12 09:40:48.000000000 +0200
@@ -33,14 +33,13 @@
 import java.util.Arrays;
 import java.util.Objects;
 
-import jdk.vm.ci.common.JVMCIError;
+import jdk.internal.misc.Unsafe;
 import jdk.internal.org.objectweb.asm.ClassReader;
 import jdk.internal.org.objectweb.asm.ClassVisitor;
 import jdk.internal.org.objectweb.asm.Label;
 import jdk.internal.org.objectweb.asm.MethodVisitor;
 import jdk.internal.org.objectweb.asm.Opcodes;
 import jdk.internal.org.objectweb.asm.Type;
-import jdk.internal.misc.Unsafe;
 
 /**
  * A {@link ClassVisitor} that verifies {@link HotSpotVMConfig} does not access {@link Unsafe} from
@@ -61,7 +60,7 @@
             cr.accept(cv, 0);
             return true;
         } catch (IOException e) {
-            throw new JVMCIError(e);
+            throw new InternalError(e);
         }
     }
 
@@ -79,7 +78,7 @@
         try {
             return Class.forName(name.replace('/', '.'));
         } catch (ClassNotFoundException e) {
-            throw new JVMCIError(e);
+            throw new InternalError(e);
         }
     }
 
@@ -101,7 +100,7 @@
     void error(String message) {
         String errorMessage = format("%s:%d: %s is not allowed in the context of compilation replay. The unsafe access should be moved into the %s constructor and the result cached in a field",
                         sourceFile, lineNo, message, HotSpotVMConfig.class.getSimpleName());
-        throw new JVMCIError(errorMessage);
+        throw new InternalError(errorMessage);
 
     }
 
--- old/src/share/vm/jvmci/jvmciRuntime.hpp	2016-05-12 09:40:49.000000000 +0200
+++ new/src/share/vm/jvmci/jvmciRuntime.hpp	2016-05-12 09:40:49.000000000 +0200
@@ -30,10 +30,10 @@
 #include "runtime/deoptimization.hpp"
 
 #define JVMCI_ERROR(...)       \
-  { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return; }
+  { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_InternalError(), __VA_ARGS__); return; }
 
 #define JVMCI_ERROR_(ret, ...) \
-  { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return ret; }
+  { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_InternalError(), __VA_ARGS__); return ret; }
 
 #define JVMCI_ERROR_0(...)    JVMCI_ERROR_(0, __VA_ARGS__)
 #define JVMCI_ERROR_NULL(...) JVMCI_ERROR_(NULL, __VA_ARGS__)
--- old/src/share/vm/jvmci/vmSymbols_jvmci.hpp	2016-05-12 09:40:49.000000000 +0200
+++ new/src/share/vm/jvmci/vmSymbols_jvmci.hpp	2016-05-12 09:40:49.000000000 +0200
@@ -88,7 +88,6 @@
   template(jdk_vm_ci_code_site_Infopoint,                         "jdk/vm/ci/code/site/Infopoint")                         \
   template(jdk_vm_ci_code_site_Site,                              "jdk/vm/ci/code/site/Site")                              \
   template(jdk_vm_ci_code_site_InfopointReason,                   "jdk/vm/ci/code/site/InfopointReason")                   \
-  template(jdk_vm_ci_common_JVMCIError,                           "jdk/vm/ci/common/JVMCIError")                           \
   template(adjustCompilationLevel_name,                           "adjustCompilationLevel")                                \
   template(adjustCompilationLevel_signature,                      "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;ZI)I") \
   template(compileMethod_name,                                    "compileMethod")                                         \
--- old/test/compiler/jvmci/errors/TestInvalidCompilationResult.java	2016-05-12 09:40:50.000000000 +0200
+++ new/test/compiler/jvmci/errors/TestInvalidCompilationResult.java	2016-05-12 09:40:50.000000000 +0200
@@ -29,7 +29,6 @@
  *          jdk.vm.ci/jdk.vm.ci.code.site
  *          jdk.vm.ci/jdk.vm.ci.meta
  *          jdk.vm.ci/jdk.vm.ci.runtime
- *          jdk.vm.ci/jdk.vm.ci.common
  * @compile CodeInstallerTest.java
  * @build compiler.jvmci.errors.TestInvalidCompilationResult
  * @run junit/othervm -da:jdk.vm.ci... -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.jvmci.errors.TestInvalidCompilationResult
@@ -46,7 +45,6 @@
 import jdk.vm.ci.code.site.Mark;
 import jdk.vm.ci.code.site.Reference;
 import jdk.vm.ci.code.site.Site;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspot.HotSpotCompiledCode.Comment;
 import jdk.vm.ci.hotspot.HotSpotConstant;
 import jdk.vm.ci.meta.Assumptions.Assumption;
@@ -86,12 +84,12 @@
         }
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidAssumption() {
         installEmptyCode(new Site[0], new Assumption[]{new InvalidAssumption()}, new Comment[0], 16, new DataPatch[0], null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidAlignment() {
         installEmptyCode(new Site[0], new Assumption[0], new Comment[0], 7, new DataPatch[0], null);
     }
@@ -106,14 +104,14 @@
         installEmptyCode(new Site[0], new Assumption[0], new Comment[0], 16, new DataPatch[]{new DataPatch(0, null)}, null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidDataSectionReference() {
         DataSectionReference ref = new DataSectionReference();
         ref.setOffset(0);
         installEmptyCode(new Site[0], new Assumption[0], new Comment[0], 16, new DataPatch[]{new DataPatch(0, ref)}, null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidNarrowMethodInDataSection() {
         HotSpotConstant c = (HotSpotConstant) dummyMethod.getEncoding();
         ConstantReference ref = new ConstantReference((VMConstant) c.compress());
@@ -126,7 +124,7 @@
         installEmptyCode(new Site[0], new Assumption[0], new Comment[0], 16, new DataPatch[]{new DataPatch(0, ref)}, null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidConstantInDataSection() {
         ConstantReference ref = new ConstantReference(new InvalidVMConstant());
         installEmptyCode(new Site[0], new Assumption[0], new Comment[0], 16, new DataPatch[]{new DataPatch(0, ref)}, null);
@@ -143,31 +141,31 @@
         installEmptyCode(new Site[]{new DataPatch(0, ref)}, new Assumption[0], new Comment[0], 16, new DataPatch[0], null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidConstantInCode() {
         ConstantReference ref = new ConstantReference(new InvalidVMConstant());
         installEmptyCode(new Site[]{new DataPatch(0, ref)}, new Assumption[0], new Comment[0], 16, new DataPatch[0], null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidReference() {
         InvalidReference ref = new InvalidReference();
         installEmptyCode(new Site[]{new DataPatch(0, ref)}, new Assumption[0], new Comment[0], 16, new DataPatch[0], null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testOutOfBoundsDataSectionReference() {
         DataSectionReference ref = new DataSectionReference();
         ref.setOffset(0x1000);
         installEmptyCode(new Site[]{new DataPatch(0, ref)}, new Assumption[0], new Comment[0], 16, new DataPatch[0], null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidMark() {
         installEmptyCode(new Site[]{new Mark(0, new Object())}, new Assumption[0], new Comment[0], 16, new DataPatch[0], null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidMarkInt() {
         installEmptyCode(new Site[]{new Mark(0, -1)}, new Assumption[0], new Comment[0], 16, new DataPatch[0], null);
     }
@@ -177,20 +175,20 @@
         installEmptyCode(new Site[]{null}, new Assumption[0], new Comment[0], 16, new DataPatch[0], null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInfopointMissingDebugInfo() {
         Infopoint info = new Infopoint(0, null, InfopointReason.METHOD_START);
         installEmptyCode(new Site[]{info}, new Assumption[0], new Comment[0], 16, new DataPatch[0], null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testSafepointMissingDebugInfo() {
         Infopoint info = new Infopoint(0, null, InfopointReason.SAFEPOINT);
         StackSlot deoptRescueSlot = StackSlot.get(null, 0, true);
         installEmptyCode(new Site[]{info}, new Assumption[0], new Comment[0], 16, new DataPatch[0], deoptRescueSlot);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidDeoptRescueSlot() {
         StackSlot deoptRescueSlot = StackSlot.get(null, -1, false);
         installEmptyCode(new Site[]{}, new Assumption[0], new Comment[0], 16, new DataPatch[0], deoptRescueSlot);
--- old/test/compiler/jvmci/errors/TestInvalidDebugInfo.java	2016-05-12 09:40:51.000000000 +0200
+++ new/test/compiler/jvmci/errors/TestInvalidDebugInfo.java	2016-05-12 09:40:51.000000000 +0200
@@ -29,7 +29,6 @@
  *          jdk.vm.ci/jdk.vm.ci.code.site
  *          jdk.vm.ci/jdk.vm.ci.meta
  *          jdk.vm.ci/jdk.vm.ci.runtime
- *          jdk.vm.ci/jdk.vm.ci.common
  * @compile CodeInstallerTest.java
  * @run junit/othervm -da:jdk.vm.ci... -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.jvmci.errors.TestInvalidDebugInfo
  */
@@ -46,7 +45,6 @@
 import jdk.vm.ci.code.site.Infopoint;
 import jdk.vm.ci.code.site.InfopointReason;
 import jdk.vm.ci.code.site.Site;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspot.HotSpotCompiledCode.Comment;
 import jdk.vm.ci.hotspot.HotSpotReferenceMap;
 import jdk.vm.ci.meta.Assumptions.Assumption;
@@ -92,17 +90,17 @@
         test(new JavaValue[0], null, 0, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testMissingDeoptRescueSlot() {
         test(null, new JavaValue[0], new JavaKind[0], 0, 0, 0, null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUnexpectedScopeValuesLength() {
         test(new JavaValue[]{JavaConstant.FALSE}, new JavaKind[0], 0, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUnexpectedScopeSlotKindsLength() {
         test(new JavaValue[0], new JavaKind[]{JavaKind.Boolean}, 0, 0, 0);
     }
@@ -122,67 +120,67 @@
         test(new JavaValue[]{null}, new JavaKind[0], 0, 0, 1);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testWrongMonitorType() {
         test(new JavaValue[]{JavaConstant.INT_0}, new JavaKind[0], 0, 0, 1);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUnexpectedIllegalValue() {
         test(new JavaValue[]{Value.ILLEGAL}, new JavaKind[]{JavaKind.Int}, 1, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUnexpectedTypeInCPURegister() {
         Register reg = getRegister(arch.getPlatformKind(JavaKind.Int), 0);
         test(new JavaValue[]{reg.asValue()}, new JavaKind[]{JavaKind.Illegal}, 1, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUnexpectedTypeInFloatRegister() {
         Register reg = getRegister(arch.getPlatformKind(JavaKind.Float), 0);
         test(new JavaValue[]{reg.asValue()}, new JavaKind[]{JavaKind.Illegal}, 1, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUnexpectedTypeOnStack() {
         LIRKind kind = codeCache.getTarget().getLIRKind(JavaKind.Int);
         StackSlot value = StackSlot.get(kind, 8, false);
         test(new JavaValue[]{value}, new JavaKind[]{JavaKind.Illegal}, 1, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testWrongConstantType() {
         test(new JavaValue[]{JavaConstant.INT_0}, new JavaKind[]{JavaKind.Object}, 1, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUnsupportedConstantType() {
         test(new JavaValue[]{JavaConstant.forShort((short) 0)}, new JavaKind[]{JavaKind.Short}, 1, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUnexpectedNull() {
         test(new JavaValue[]{JavaConstant.NULL_POINTER}, new JavaKind[]{JavaKind.Int}, 1, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUnexpectedObject() {
         JavaValue wrapped = constantReflection.forObject(this);
         test(new JavaValue[]{wrapped}, new JavaKind[]{JavaKind.Int}, 1, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUnknownJavaValue() {
         test(new JavaValue[]{new UnknownJavaValue()}, new JavaKind[]{JavaKind.Int}, 1, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testMissingIllegalAfterDouble() {
         test(new JavaValue[]{JavaConstant.DOUBLE_0, JavaConstant.INT_0}, new JavaKind[]{JavaKind.Double, JavaKind.Int}, 2, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidVirtualObjectId() {
         ResolvedJavaType obj = metaAccess.lookupJavaType(Object.class);
         VirtualObject o = VirtualObject.get(obj, 5);
@@ -191,7 +189,7 @@
         test(new VirtualObject[]{o}, new JavaValue[0], new JavaKind[0], 0, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testDuplicateVirtualObject() {
         ResolvedJavaType obj = metaAccess.lookupJavaType(Object.class);
         VirtualObject o1 = VirtualObject.get(obj, 0);
@@ -203,7 +201,7 @@
         test(new VirtualObject[]{o1, o2}, new JavaValue[0], new JavaKind[0], 0, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUnexpectedVirtualObject() {
         ResolvedJavaType obj = metaAccess.lookupJavaType(Object.class);
         VirtualObject o = VirtualObject.get(obj, 0);
@@ -212,7 +210,7 @@
         test(new VirtualObject[]{o}, new JavaValue[]{o}, new JavaKind[]{JavaKind.Int}, 1, 0, 0);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testUndefinedVirtualObject() {
         ResolvedJavaType obj = metaAccess.lookupJavaType(Object.class);
         VirtualObject o0 = VirtualObject.get(obj, 0);
--- old/test/compiler/jvmci/errors/TestInvalidOopMap.java	2016-05-12 09:40:51.000000000 +0200
+++ new/test/compiler/jvmci/errors/TestInvalidOopMap.java	2016-05-12 09:40:51.000000000 +0200
@@ -29,7 +29,6 @@
  *          jdk.vm.ci/jdk.vm.ci.code.site
  *          jdk.vm.ci/jdk.vm.ci.meta
  *          jdk.vm.ci/jdk.vm.ci.runtime
- *          jdk.vm.ci/jdk.vm.ci.common
  * @compile CodeInstallerTest.java
  * @run junit/othervm -da:jdk.vm.ci... -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.jvmci.errors.TestInvalidOopMap
  */
@@ -46,7 +45,6 @@
 import jdk.vm.ci.code.site.Infopoint;
 import jdk.vm.ci.code.site.InfopointReason;
 import jdk.vm.ci.code.site.Site;
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.hotspot.HotSpotCompiledCode.Comment;
 import jdk.vm.ci.hotspot.HotSpotReferenceMap;
 import jdk.vm.ci.hotspot.HotSpotVMConfig;
@@ -76,7 +74,7 @@
         test(null);
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidReferenceMap() {
         test(new InvalidReferenceMap());
     }
@@ -96,12 +94,12 @@
         test(new HotSpotReferenceMap(new Location[0], new Location[0], null, 8));
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidLength() {
         test(new HotSpotReferenceMap(new Location[1], new Location[2], new int[3], 8));
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidShortOop() {
         PlatformKind kind = arch.getPlatformKind(JavaKind.Short);
         Register reg = getRegister(kind, 0);
@@ -113,10 +111,10 @@
         test(new HotSpotReferenceMap(oops, base, size, 8));
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void testInvalidNarrowDerivedOop() {
         if (!HotSpotVMConfig.config().useCompressedOops) {
-            throw new JVMCIError("skipping test");
+            throw new InternalError("skipping test");
         }
 
         PlatformKind kind = arch.getPlatformKind(JavaKind.Int);
--- old/test/compiler/jvmci/jdk.vm.ci.code.test/src/jdk/vm/ci/code/test/InterpreterFrameSizeTest.java	2016-05-12 09:40:52.000000000 +0200
+++ new/test/compiler/jvmci/jdk.vm.ci.code.test/src/jdk/vm/ci/code/test/InterpreterFrameSizeTest.java	2016-05-12 09:40:52.000000000 +0200
@@ -29,7 +29,6 @@
  *          jdk.vm.ci/jdk.vm.ci.code.site
  *          jdk.vm.ci/jdk.vm.ci.meta
  *          jdk.vm.ci/jdk.vm.ci.runtime
- *          jdk.vm.ci/jdk.vm.ci.common
  *          jdk.vm.ci/jdk.vm.ci.amd64
  *          jdk.vm.ci/jdk.vm.ci.sparc
  * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java amd64/AMD64TestAssembler.java sparc/SPARCTestAssembler.java
--- old/test/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestResolvedJavaType.java	2016-05-12 09:40:53.000000000 +0200
+++ new/test/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestResolvedJavaType.java	2016-05-12 09:40:53.000000000 +0200
@@ -28,7 +28,6 @@
  * @modules java.base/jdk.internal.reflect
  *          jdk.vm.ci/jdk.vm.ci.meta
  *          jdk.vm.ci/jdk.vm.ci.runtime
- *          jdk.vm.ci/jdk.vm.ci.common
  *          java.base/jdk.internal.misc
  * @build jdk.vm.ci.runtime.test.TestResolvedJavaType
  * @run junit/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI jdk.vm.ci.runtime.test.TestResolvedJavaType
@@ -60,7 +59,6 @@
 import java.util.Map;
 import java.util.Set;
 
-import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 import jdk.vm.ci.meta.JavaConstant;
 import jdk.vm.ci.meta.JavaKind;
@@ -462,13 +460,13 @@
         assertEquals(aSai2, iSai2.getSingleImplementor());
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void getSingleImplementorTestClassReceiver() {
         ResolvedJavaType base = metaAccess.lookupJavaType(Base.class);
         base.getSingleImplementor();
     }
 
-    @Test(expected = JVMCIError.class)
+    @Test(expected = InternalError.class)
     public void getSingleImplementorTestPrimitiveReceiver() {
         ResolvedJavaType primitive = metaAccess.lookupJavaType(int.class);
         primitive.getSingleImplementor();
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.common/src/jdk/vm/ci/common/JVMCIError.java	2016-05-12 09:40:53.000000000 +0200
+++ /dev/null	2016-05-12 09:40:53.000000000 +0200
@@ -1,149 +0,0 @@
-/*
- * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.vm.ci.common;
-
-import java.util.ArrayList;
-import java.util.Locale;
-
-/**
- * Indicates a condition in JVMCI related code that should never occur during normal operation.
- */
-public class JVMCIError extends Error {
-
-    private static final long serialVersionUID = 531632331813456233L;
-    private final ArrayList<String> context = new ArrayList<>();
-
-    public static RuntimeException unimplemented() {
-        throw new JVMCIError("unimplemented");
-    }
-
-    public static RuntimeException unimplemented(String msg) {
-        throw new JVMCIError("unimplemented: %s", msg);
-    }
-
-    public static RuntimeException shouldNotReachHere() {
-        throw new JVMCIError("should not reach here");
-    }
-
-    public static RuntimeException shouldNotReachHere(String msg) {
-        throw new JVMCIError("should not reach here: %s", msg);
-    }
-
-    public static RuntimeException shouldNotReachHere(Throwable cause) {
-        throw new JVMCIError(cause);
-    }
-
-    /**
-     * Checks a given condition and throws a {@link JVMCIError} if it is false. Guarantees are
-     * stronger than assertions in that they are always checked. Error messages for guarantee
-     * violations should clearly indicate the nature of the problem as well as a suggested solution
-     * if possible.
-     *
-     * @param condition the condition to check
-     * @param msg the message that will be associated with the error, in
-     *            {@link String#format(String, Object...)} syntax
-     * @param args arguments to the format string
-     */
-    public static void guarantee(boolean condition, String msg, Object... args) {
-        if (!condition) {
-            throw new JVMCIError("failed guarantee: " + msg, args);
-        }
-    }
-
-    /**
-     * This constructor creates a {@link JVMCIError} with a given message.
-     *
-     * @param msg the message that will be associated with the error
-     */
-    public JVMCIError(String msg) {
-        super(msg);
-    }
-
-    /**
-     * This constructor creates a {@link JVMCIError} with a message assembled via
-     * {@link String#format(String, Object...)}. It always uses the ENGLISH locale in order to
-     * always generate the same output.
-     *
-     * @param msg the message that will be associated with the error, in String.format syntax
-     * @param args parameters to String.format - parameters that implement {@link Iterable} will be
-     *            expanded into a [x, x, ...] representation.
-     */
-    public JVMCIError(String msg, Object... args) {
-        super(format(msg, args));
-    }
-
-    /**
-     * This constructor creates a {@link JVMCIError} for a given causing Throwable instance.
-     *
-     * @param cause the original exception that contains additional information on this error
-     */
-    public JVMCIError(Throwable cause) {
-        super(cause);
-    }
-
-    /**
-     * This constructor creates a {@link JVMCIError} and adds all the
-     * {@linkplain #addContext(String) context} of another {@link JVMCIError}.
-     *
-     * @param e the original {@link JVMCIError}
-     */
-    public JVMCIError(JVMCIError e) {
-        super(e);
-        context.addAll(e.context);
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder str = new StringBuilder();
-        str.append(super.toString());
-        for (String s : context) {
-            str.append("\n\tat ").append(s);
-        }
-        return str.toString();
-    }
-
-    private static String format(String msg, Object... args) {
-        if (args != null) {
-            // expand Iterable parameters into a list representation
-            for (int i = 0; i < args.length; i++) {
-                if (args[i] instanceof Iterable<?>) {
-                    ArrayList<Object> list = new ArrayList<>();
-                    for (Object o : (Iterable<?>) args[i]) {
-                        list.add(o);
-                    }
-                    args[i] = list.toString();
-                }
-            }
-        }
-        return String.format(Locale.ENGLISH, msg, args);
-    }
-
-    public JVMCIError addContext(String newContext) {
-        this.context.add(newContext);
-        return this;
-    }
-
-    public JVMCIError addContext(String name, Object obj) {
-        return addContext(format("%s: %s", name, obj));
-    }
-}
--- old/src/jdk.vm.ci/share/classes/jdk.vm.ci.common/src/jdk/vm/ci/common/UnsafeUtil.java	2016-05-12 09:40:54.000000000 +0200
+++ /dev/null	2016-05-12 09:40:54.000000000 +0200
@@ -1,81 +0,0 @@
-/*
- * Copyright (c) 2012, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.vm.ci.common;
-
-import jdk.internal.misc.Unsafe;
-
-/**
- * Utilities for operating on raw memory with {@link Unsafe}.
- */
-public class UnsafeUtil {
-
-    /**
-     * Copies the contents of a {@link String} to a native memory buffer as a {@code '\0'}
-     * terminated C string. The native memory buffer is allocated via
-     * {@link Unsafe#allocateMemory(long)}. The caller is responsible for releasing the buffer when
-     * it is no longer needed via {@link Unsafe#freeMemory(long)}.
-     *
-     * @return the native memory pointer of the C string created from {@code s}
-     */
-    public static long createCString(Unsafe unsafe, String s) {
-        return writeCString(unsafe, s, unsafe.allocateMemory(s.length() + 1));
-    }
-
-    /**
-     * Reads a {@code '\0'} terminated C string from native memory and converts it to a
-     * {@link String}.
-     *
-     * @return a Java string
-     */
-    public static String readCString(Unsafe unsafe, long address) {
-        if (address == 0) {
-            return null;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0;; i++) {
-            char c = (char) unsafe.getByte(address + i);
-            if (c == 0) {
-                break;
-            }
-            sb.append(c);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Writes the contents of a {@link String} to a native memory buffer as a {@code '\0'}
-     * terminated C string. The caller is responsible for ensuring the buffer is at least
-     * {@code s.length() + 1} bytes long. The caller is also responsible for releasing the buffer
-     * when it is no longer.
-     *
-     * @return the value of {@code buf}
-     */
-    public static long writeCString(Unsafe unsafe, String s, long buf) {
-        int size = s.length();
-        for (int i = 0; i < size; i++) {
-            unsafe.putByte(buf + i, (byte) s.charAt(i));
-        }
-        unsafe.putByte(buf + size, (byte) '\0');
-        return buf;
-    }
-}
