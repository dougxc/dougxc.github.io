<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/classLoaderData.inline.hpp"
  26 #include "classfile/javaClasses.inline.hpp"
  27 #include "classfile/stringTable.hpp"
  28 #include "classfile/symbolTable.hpp"
  29 #include "code/scopeDesc.hpp"
  30 #include "compiler/compileBroker.hpp"
  31 #include "compiler/disassembler.hpp"
  32 #include "interpreter/linkResolver.hpp"
  33 #include "interpreter/bytecodeStream.hpp"
  34 #include "jvmci/jvmciCompilerToVM.hpp"
  35 #include "jvmci/jvmciCodeInstaller.hpp"
  36 #include "jvmci/jvmciRuntime.hpp"
  37 #include "memory/oopFactory.hpp"
  38 #include "oops/constantPool.inline.hpp"
  39 #include "oops/method.inline.hpp"
  40 #include "oops/objArrayOop.inline.hpp"
  41 #include "oops/typeArrayOop.inline.hpp"
  42 #include "prims/nativeLookup.hpp"
  43 #include "runtime/deoptimization.hpp"
  44 #include "runtime/frame.inline.hpp"
  45 #include "runtime/interfaceSupport.inline.hpp"
  46 #include "runtime/jniHandles.inline.hpp"
  47 #include "runtime/timerTrace.hpp"
  48 #include "runtime/vframe_hp.hpp"
  49 
  50 JVMCIKlassHandle::JVMCIKlassHandle(Thread* thread, Klass* klass) {
  51   _thread = thread;
  52   _klass = klass;
  53   if (klass != NULL) {
  54     _holder = Handle(_thread, klass-&gt;holder_phantom());
  55   }
  56 }
  57 
  58 JVMCIKlassHandle&amp; JVMCIKlassHandle::operator=(Klass* klass) {
  59   _klass = klass;
  60   if (klass != NULL) {
  61     _holder = Handle(_thread, klass-&gt;holder_phantom());
  62   }
  63   return *this;
  64 }
  65 
  66 static void requireInHotSpot(const char* caller, JVMCI_TRAPS) {
  67   if (!JVMCIENV-&gt;is_hotspot()) {
  68     JVMCI_THROW_MSG(IllegalStateException, err_msg("Cannot call %s from JVMCI shared library", caller));
  69   }
  70 }
  71 
  72 void JNIHandleMark::push_jni_handle_block(JavaThread* thread) {
  73   if (thread != NULL) {
  74     // Allocate a new block for JNI handles.
  75     // Inlined code from jni_PushLocalFrame()
  76     JNIHandleBlock* java_handles = thread-&gt;active_handles();
  77     JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
  78     assert(compile_handles != NULL &amp;&amp; java_handles != NULL, "should not be NULL");
  79     compile_handles-&gt;set_pop_frame_link(java_handles);
  80     thread-&gt;set_active_handles(compile_handles);
  81   }
  82 }
  83 
  84 void JNIHandleMark::pop_jni_handle_block(JavaThread* thread) {
  85   if (thread != NULL) {
  86     // Release our JNI handle block
  87     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  88     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  89     thread-&gt;set_active_handles(java_handles);
  90     compile_handles-&gt;set_pop_frame_link(NULL);
  91     JNIHandleBlock::release_block(compile_handles, thread); // may block
  92   }
  93 }
  94 
  95 class JVMCITraceMark : public StackObj {
  96   const char* _msg;
  97  public:
  98   JVMCITraceMark(const char* msg) {
  99     _msg = msg;
 100     if (JVMCITraceLevel &gt;= 1) {
 101       tty-&gt;print_cr(PTR_FORMAT " JVMCITrace-1: Enter %s", p2i(JavaThread::current()), _msg);
 102     }
 103   }
 104   ~JVMCITraceMark() {
 105     if (JVMCITraceLevel &gt;= 1) {
 106       tty-&gt;print_cr(PTR_FORMAT " JVMCITrace-1: Exit %s", p2i(JavaThread::current()), _msg);
 107     }
 108   }
 109 };
 110 
 111 
 112 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 113   assert(_index &lt; _args-&gt;length(), "out of bounds");
 114   oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
 115   assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), "arg type mismatch");
 116   return Handle(Thread::current(), arg);
 117 }
 118 
 119 // Bring the JVMCI compiler thread into the VM state.
 120 #define JVMCI_VM_ENTRY_MARK                   \
 121   ThreadInVMfromNative __tiv(thread);         \
 122   ResetNoHandleMark rnhm;                     \
 123   HandleMarkCleaner __hm(thread);             \
 124   Thread* THREAD = thread;                    \
 125   debug_only(VMNativeEntryWrapper __vew;)
 126 
 127 // Native method block that transitions current thread to '_thread_in_vm'.
 128 #define C2V_BLOCK(result_type, name, signature)      \
 129   TRACE_CALL(result_type, jvmci_ ## name signature)  \
 130   JVMCI_VM_ENTRY_MARK;                               \
 131   ResourceMark rm;                                   \
 132   JNI_JVMCIENV(thread, env);
 133 
 134 static Thread* get_current_thread() {
 135   return Thread::current_or_null_safe();
 136 }
 137 
 138 // Entry to native method implementation that transitions
 139 // current thread to '_thread_in_vm'.
 140 #define C2V_VMENTRY(result_type, name, signature)        \
 141   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 142   Thread* base_thread = get_current_thread();            \
 143   if (base_thread == NULL) {                             \
 144     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 145         err_msg("Cannot call into HotSpot from JVMCI shared library without attaching current thread")); \
 146     return;                                              \
 147   }                                                      \
 148   assert(base_thread-&gt;is_Java_thread(), "just checking");\
 149   JavaThread* thread = (JavaThread*) base_thread;        \
 150   JVMCITraceMark jtm("CompilerToVM::" #name);            \
 151   C2V_BLOCK(result_type, name, signature)
 152 
 153 #define C2V_VMENTRY_(result_type, name, signature, result) \
 154   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 155   Thread* base_thread = get_current_thread();            \
 156   if (base_thread == NULL) {                             \
 157     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 158         err_msg("Cannot call into HotSpot from JVMCI shared library without attaching current thread")); \
 159     return result;                                       \
 160   }                                                      \
 161   assert(base_thread-&gt;is_Java_thread(), "just checking");\
 162   JavaThread* thread = (JavaThread*) base_thread;        \
 163   JVMCITraceMark jtm("CompilerToVM::" #name);            \
 164   C2V_BLOCK(result_type, name, signature)
 165 
 166 #define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)
 167 #define C2V_VMENTRY_0(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, 0)
 168 
 169 // Entry to native method implementation that does not transition
 170 // current thread to '_thread_in_vm'.
 171 #define C2V_VMENTRY_PREFIX(result_type, name, signature) \
 172   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 173   Thread* base_thread = get_current_thread();
 174 
 175 #define C2V_END }
 176 
 177 #define JNI_THROW(caller, name, msg) do {                                         \
 178     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 179     if (__throw_res != JNI_OK) {                                                  \
 180       tty-&gt;print_cr("Throwing " #name " in " caller " returned %d", __throw_res); \
 181     }                                                                             \
 182     return;                                                                       \
 183   } while (0);
 184 
 185 #define JNI_THROW_(caller, name, msg, result) do {                                \
 186     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 187     if (__throw_res != JNI_OK) {                                                  \
 188       tty-&gt;print_cr("Throwing " #name " in " caller " returned %d", __throw_res); \
 189     }                                                                             \
 190     return result;                                                                \
 191   } while (0)
 192 
 193 jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS);
 194 
 195 C2V_VMENTRY_NULL(jobjectArray, readConfiguration, (JNIEnv* env))
 196   jobjectArray config = readConfiguration0(env, JVMCI_CHECK_NULL);
 197   return config;
 198 }
 199 
 200 C2V_VMENTRY_NULL(jobject, getFlagValue, (JNIEnv* env, jobject c2vm, jobject name_handle))
 201 #define RETURN_BOXED_LONG(value) jvalue p; p.j = (jlong) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_LONG, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();
 202 #define RETURN_BOXED_DOUBLE(value) jvalue p; p.d = (jdouble) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_DOUBLE, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();
 203   JVMCIObject name = JVMCIENV-&gt;wrap(name_handle);
 204   if (name.is_null()) {
 205     JVMCI_THROW_NULL(NullPointerException);
 206   }
 207   const char* cstring = JVMCIENV-&gt;as_utf8_string(name);
 208   JVMFlag* flag = JVMFlag::find_flag(cstring, strlen(cstring), /* allow_locked */ true, /* return_flag */ true);
 209   if (flag == NULL) {
 210     return c2vm;
 211   }
 212   if (flag-&gt;is_bool()) {
 213     jvalue prim;
 214     prim.z = flag-&gt;get_bool();
 215     JVMCIObject box = JVMCIENV-&gt;create_box(T_BOOLEAN, &amp;prim, JVMCI_CHECK_NULL);
 216     return JVMCIENV-&gt;get_jobject(box);
 217   } else if (flag-&gt;is_ccstr()) {
 218     JVMCIObject value = JVMCIENV-&gt;create_string(flag-&gt;get_ccstr(), JVMCI_CHECK_NULL);
 219     return JVMCIENV-&gt;get_jobject(value);
 220   } else if (flag-&gt;is_intx()) {
 221     RETURN_BOXED_LONG(flag-&gt;get_intx());
 222   } else if (flag-&gt;is_int()) {
 223     RETURN_BOXED_LONG(flag-&gt;get_int());
 224   } else if (flag-&gt;is_uint()) {
 225     RETURN_BOXED_LONG(flag-&gt;get_uint());
 226   } else if (flag-&gt;is_uint64_t()) {
 227     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());
 228   } else if (flag-&gt;is_size_t()) {
 229     RETURN_BOXED_LONG(flag-&gt;get_size_t());
 230   } else if (flag-&gt;is_uintx()) {
 231     RETURN_BOXED_LONG(flag-&gt;get_uintx());
 232   } else if (flag-&gt;is_double()) {
 233     RETURN_BOXED_DOUBLE(flag-&gt;get_double());
 234   } else {
 235     JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
 236   }
 237 #undef RETURN_BOXED_LONG
 238 #undef RETURN_BOXED_DOUBLE
 239 C2V_END
 240 
 241 C2V_VMENTRY_NULL(jobject, getObjectAtAddress, (JNIEnv* env, jobject c2vm, jlong oop_address))
 242   requireInHotSpot("getObjectAtAddress", JVMCI_CHECK_NULL);
 243   if (oop_address == 0) {
 244     JVMCI_THROW_MSG_NULL(InternalError, "Handle must be non-zero");
 245   }
 246   oop obj = *((oopDesc**) oop_address);
 247   if (obj != NULL) {
 248     obj-&gt;verify();
 249   }
 250   return JNIHandles::make_local(obj);
 251 C2V_END
 252 
 253 C2V_VMENTRY_NULL(jbyteArray, getBytecode, (JNIEnv* env, jobject, jobject jvmci_method))
 254   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
 255 
 256   int code_size = method-&gt;code_size();
 257   jbyte* reconstituted_code = NEW_RESOURCE_ARRAY(jbyte, code_size);
 258 
 259   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 260   // iterate over all bytecodes and replace non-Java bytecodes
 261 
 262   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 263     Bytecodes::Code code = s.code();
 264     Bytecodes::Code raw_code = s.raw_code();
 265     int bci = s.bci();
 266     int len = s.instruction_size();
 267 
 268     // Restore original byte code.
 269     reconstituted_code[bci] =  (jbyte) (s.is_wide()? Bytecodes::_wide : code);
 270     if (len &gt; 1) {
 271       memcpy(reconstituted_code + (bci + 1), s.bcp()+1, len-1);
 272     }
 273 
 274     if (len &gt; 1) {
 275       // Restore the big-endian constant pool indexes.
 276       // Cf. Rewriter::scan_method
 277       switch (code) {
 278         case Bytecodes::_getstatic:
 279         case Bytecodes::_putstatic:
 280         case Bytecodes::_getfield:
 281         case Bytecodes::_putfield:
 282         case Bytecodes::_invokevirtual:
 283         case Bytecodes::_invokespecial:
 284         case Bytecodes::_invokestatic:
 285         case Bytecodes::_invokeinterface:
 286         case Bytecodes::_invokehandle: {
 287           int cp_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));
 288           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);
 289           break;
 290         }
 291 
 292         case Bytecodes::_invokedynamic: {
 293           int cp_index = Bytes::get_native_u4((address) reconstituted_code + (bci + 1));
 294           Bytes::put_Java_u4((address) reconstituted_code + (bci + 1), (u4) cp_index);
 295           break;
 296         }
 297 
 298         default:
 299           break;
 300       }
 301 
 302       // Not all ldc byte code are rewritten.
 303       switch (raw_code) {
 304         case Bytecodes::_fast_aldc: {
 305           int cpc_index = reconstituted_code[bci + 1] &amp; 0xff;
 306           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 307           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 308           reconstituted_code[bci + 1] = (jbyte) cp_index;
 309           break;
 310         }
 311 
 312         case Bytecodes::_fast_aldc_w: {
 313           int cpc_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));
 314           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 315           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 316           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);
 317           break;
 318         }
 319 
 320         default:
 321           break;
 322       }
 323     }
 324   }
 325 
 326   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);
 327   JVMCIENV-&gt;copy_bytes_from(reconstituted_code, result, 0, code_size);
 328   return JVMCIENV-&gt;get_jbyteArray(result);
 329 C2V_END
 330 
 331 C2V_VMENTRY_0(jint, getExceptionTableLength, (JNIEnv* env, jobject, jobject jvmci_method))
 332   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
 333   return method-&gt;exception_table_length();
 334 C2V_END
 335 
 336 C2V_VMENTRY_0(jlong, getExceptionTableStart, (JNIEnv* env, jobject, jobject jvmci_method))
 337   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
 338   if (method-&gt;exception_table_length() == 0) {
 339     return 0L;
 340   }
 341   return (jlong) (address) method-&gt;exception_table_start();
 342 C2V_END
 343 
 344 C2V_VMENTRY_NULL(jobject, asResolvedJavaMethod, (JNIEnv* env, jobject, jobject executable_handle))
 345   requireInHotSpot("asResolvedJavaMethod", JVMCI_CHECK_NULL);
 346   oop executable = JNIHandles::resolve(executable_handle);
 347   oop mirror = NULL;
 348   int slot = 0;
 349 
 350   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 351     mirror = java_lang_reflect_Constructor::clazz(executable);
 352     slot = java_lang_reflect_Constructor::slot(executable);
 353   } else {
 354     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), "wrong type");
 355     mirror = java_lang_reflect_Method::clazz(executable);
 356     slot = java_lang_reflect_Method::slot(executable);
 357   }
 358   Klass* holder = java_lang_Class::as_Klass(mirror);
 359   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 360   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);
 361   return JVMCIENV-&gt;get_jobject(result);
 362 }
 363 
 364 C2V_VMENTRY_NULL(jobject, getResolvedJavaMethod, (JNIEnv* env, jobject, jobject base, jlong offset))
 365   methodHandle method;
 366   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);
 367   if (base_object.is_null()) {
 368     method = *((Method**)(offset));
 369   } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 370     Handle obj = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 371     if (obj-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {
 372       method = (Method*) (intptr_t) obj-&gt;long_field(offset);
 373     } else {
 374       JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg("Unexpected type: %s", obj-&gt;klass()-&gt;external_name()));
 375     }
 376   } else if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {
 377     method = JVMCIENV-&gt;asMethod(base_object);
 378   }
 379   if (method.is_null()) {
 380     JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg("Unexpected type: %s", JVMCIENV-&gt;klass_name(base_object)));
 381   }
 382   assert (method.is_null() || method-&gt;is_method(), "invalid read");
 383   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);
 384   return JVMCIENV-&gt;get_jobject(result);
 385 }
 386 
 387 C2V_VMENTRY_NULL(jobject, getConstantPool, (JNIEnv* env, jobject, jobject object_handle))
 388   constantPoolHandle cp;
 389   JVMCIObject object = JVMCIENV-&gt;wrap(object_handle);
 390   if (object.is_null()) {
 391     JVMCI_THROW_NULL(NullPointerException);
 392   }
 393   if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(object)) {
 394     cp = JVMCIENV-&gt;asMethod(object)-&gt;constMethod()-&gt;constants();
 395   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(object)) {
 396     cp = InstanceKlass::cast(JVMCIENV-&gt;asKlass(object))-&gt;constants();
 397   } else {
 398     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 399                 err_msg("Unexpected type: %s", JVMCIENV-&gt;klass_name(object)));
 400   }
 401   assert(!cp.is_null(), "npe");
 402 
 403   JVMCIObject result = JVMCIENV-&gt;get_jvmci_constant_pool(cp, JVMCI_CHECK_NULL);
 404   return JVMCIENV-&gt;get_jobject(result);
 405 }
 406 
 407 C2V_VMENTRY_NULL(jobject, getResolvedJavaType0, (JNIEnv* env, jobject, jobject base, jlong offset, jboolean compressed))
 408   JVMCIKlassHandle klass(THREAD);
 409   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);
 410   jlong base_address = 0;
 411   if (base_object.is_non_null() &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 412     // klass = JVMCIENV-&gt;unhandle(base_object)-&gt;klass();
 413     if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 414       Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 415       klass = base_oop-&gt;klass();
 416     } else {
 417       assert(false, "What types are we actually expecting here?");
 418     }
 419   } else if (!compressed) {
 420     if (base_object.is_non_null()) {
 421       if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {
 422         base_address = (intptr_t) JVMCIENV-&gt;asMethod(base_object);
 423       } else if (JVMCIENV-&gt;isa_HotSpotConstantPool(base_object)) {
 424         base_address = (intptr_t) JVMCIENV-&gt;asConstantPool(base_object);
 425       } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {
 426         base_address = (intptr_t) JVMCIENV-&gt;asKlass(base_object);
 427       } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 428         Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 429         if (base_oop-&gt;is_a(SystemDictionary::Class_klass())) {
 430           base_address = (jlong) (address) base_oop();
 431         }
 432       }
 433       if (base_address == 0) {
 434         JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 435                     err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", JVMCIENV-&gt;klass_name(base_object), offset, compressed ? "true" : "false"));
 436       }
 437     }
 438     klass = *((Klass**) (intptr_t) (base_address + offset));
 439   } else {
 440     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 441                 err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s",
 442                         base_object.is_non_null() ? JVMCIENV-&gt;klass_name(base_object) : "null",
 443                         offset, compressed ? "true" : "false"));
 444   }
 445   assert (klass == NULL || klass-&gt;is_klass(), "invalid read");
 446   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 447   return JVMCIENV-&gt;get_jobject(result);
 448 }
 449 
 450 C2V_VMENTRY_NULL(jobject, findUniqueConcreteMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))
 451   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
 452   Klass* holder = JVMCIENV-&gt;asKlass(jvmci_type);
 453   if (holder-&gt;is_interface()) {
 454     JVMCI_THROW_MSG_NULL(InternalError, err_msg("Interface %s should be handled in Java code", holder-&gt;external_name()));
 455   }
 456 
 457   methodHandle ucm;
 458   {
 459     MutexLocker locker(Compile_lock);
 460     ucm = Dependencies::find_unique_concrete_method(holder, method());
 461   }
 462   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(ucm, JVMCI_CHECK_NULL);
 463   return JVMCIENV-&gt;get_jobject(result);
 464 C2V_END
 465 
 466 C2V_VMENTRY_NULL(jobject, getImplementor, (JNIEnv* env, jobject, jobject jvmci_type))
 467   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 468   if (!klass-&gt;is_interface()) {
 469     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 470         err_msg("Expected interface type, got %s", klass-&gt;external_name()));
 471   }
 472   InstanceKlass* iklass = InstanceKlass::cast(klass);
 473   JVMCIKlassHandle handle(THREAD);
 474   {
 475     // Need Compile_lock around implementor()
 476     MutexLocker locker(Compile_lock);
 477     handle = iklass-&gt;implementor();
 478   }
 479   JVMCIObject implementor = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
 480   return JVMCIENV-&gt;get_jobject(implementor);
 481 C2V_END
 482 
 483 C2V_VMENTRY_0(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv* env, jobject, jobject jvmci_method))
 484   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
 485   return method-&gt;is_ignored_by_security_stack_walk();
 486 C2V_END
 487 
 488 C2V_VMENTRY_0(jboolean, isCompilable,(JNIEnv* env, jobject, jobject jvmci_method))
 489   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
 490   constantPoolHandle cp = method-&gt;constMethod()-&gt;constants();
 491   assert(!cp.is_null(), "npe");
 492   // don't inline method when constant pool contains a CONSTANT_Dynamic
 493   return !method-&gt;is_not_compilable(CompLevel_full_optimization) &amp;&amp; !cp-&gt;has_dynamic_constant();
 494 C2V_END
 495 
 496 C2V_VMENTRY_0(jboolean, hasNeverInlineDirective,(JNIEnv* env, jobject, jobject jvmci_method))
 497   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
 498   return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 499 C2V_END
 500 
 501 C2V_VMENTRY_0(jboolean, shouldInlineMethod,(JNIEnv* env, jobject, jobject jvmci_method))
 502   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
 503   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 504 C2V_END
 505 
 506 C2V_VMENTRY_NULL(jobject, lookupType, (JNIEnv* env, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 507   JVMCIObject name = JVMCIENV-&gt;wrap(jname);
 508   const char* str = JVMCIENV-&gt;as_utf8_string(name);
 509   TempNewSymbol class_name = SymbolTable::new_symbol(str, CHECK_NULL);
 510 
 511   if (class_name-&gt;utf8_length() &lt;= 1) {
 512     JVMCI_THROW_MSG_0(InternalError, err_msg("Primitive type %s should be handled in Java code", class_name-&gt;as_C_string()));
 513   }
 514 
 515   JVMCIKlassHandle resolved_klass(THREAD);
 516   Klass* accessing_klass = NULL;
 517   Handle class_loader;
 518   Handle protection_domain;
 519   if (accessing_class != NULL) {
 520     accessing_klass = JVMCIENV-&gt;asKlass(accessing_class);
 521     class_loader = Handle(THREAD, accessing_klass-&gt;class_loader());
 522     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
 523   } else {
 524     // Use the System class loader
 525     class_loader = Handle(THREAD, SystemDictionary::java_system_loader());
 526     JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
 527   }
 528 
 529   if (resolve) {
 530     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 531     if (resolved_klass == NULL) {
 532       JVMCI_THROW_MSG_NULL(ClassNotFoundException, str);
 533     }
 534   } else {
 535     if (class_name-&gt;byte_at(0) == 'L' &amp;&amp;
 536       class_name-&gt;byte_at(class_name-&gt;utf8_length()-1) == ';') {
 537       // This is a name from a signature.  Strip off the trimmings.
 538       // Call recursive to keep scope of strippedsym.
 539       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 540                                                           class_name-&gt;utf8_length()-2,
 541                                                           CHECK_0);
 542       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 543     } else if (FieldType::is_array(class_name)) {
 544       FieldArrayInfo fd;
 545       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 546       // of this call
 547       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 548       if (t == T_OBJECT) {
 549         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 550                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 551                                                             CHECK_0);
 552         resolved_klass = SystemDictionary::find(strippedsym,
 553                                                              class_loader,
 554                                                              protection_domain,
 555                                                              CHECK_0);
 556         if (!resolved_klass.is_null()) {
 557           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 558         }
 559       } else {
 560         resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(t))-&gt;array_klass(fd.dimension(), CHECK_0);
 561       }
 562     } else {
 563       resolved_klass = SystemDictionary::find(class_name, class_loader, protection_domain, CHECK_0);
 564     }
 565   }
 566   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);
 567   return JVMCIENV-&gt;get_jobject(result);
 568 C2V_END
 569 
 570 C2V_VMENTRY_NULL(jobject, getArrayType, (JNIEnv* env, jobject, jobject jvmci_type))
 571   if (jvmci_type == NULL) {
 572     JVMCI_THROW_0(NullPointerException);
 573   }
 574 
 575   JVMCIObject jvmci_type_object = JVMCIENV-&gt;wrap(jvmci_type);
 576   JVMCIKlassHandle array_klass(THREAD);
 577   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(jvmci_type_object)) {
 578     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(jvmci_type_object), JVMCI_CHECK_0);
 579     if (type == T_VOID) {
 580       return NULL;
 581     }
 582     array_klass = Universe::typeArrayKlassObj(type);
 583     if (array_klass == NULL) {
 584       JVMCI_THROW_MSG_NULL(InternalError, err_msg("No array klass for primitive type %s", type2name(type)));
 585     }
 586   } else {
 587     Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 588     if (klass == NULL) {
 589       JVMCI_THROW_0(NullPointerException);
 590     }
 591     array_klass = klass-&gt;array_klass(CHECK_NULL);
 592   }
 593   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(array_klass, JVMCI_CHECK_NULL);
 594   return JVMCIENV-&gt;get_jobject(result);
 595 C2V_END
 596 
 597 C2V_VMENTRY_NULL(jobject, lookupClass, (JNIEnv* env, jobject, jclass mirror))
 598   requireInHotSpot("lookupClass", JVMCI_CHECK_NULL);
 599   if (mirror == NULL) {
 600     return NULL;
 601   }
 602   JVMCIKlassHandle klass(THREAD);
 603   klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
 604   if (klass == NULL) {
 605     JVMCI_THROW_MSG_NULL(IllegalArgumentException, "Primitive classes are unsupported");
 606   }
 607   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 608   return JVMCIENV-&gt;get_jobject(result);
 609 }
 610 
 611 C2V_VMENTRY_NULL(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 612   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
 613   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 614   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(result));
 615 C2V_END
 616 
 617 C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 618   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
 619   return cp-&gt;name_and_type_ref_index_at(index);
 620 C2V_END
 621 
 622 C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))
 623   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
 624   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;name_ref_at(which), JVMCI_CHECK_NULL);
 625   return JVMCIENV-&gt;get_jobject(sym);
 626 C2V_END
 627 
 628 C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))
 629   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
 630   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;signature_ref_at(which), JVMCI_CHECK_NULL);
 631   return JVMCIENV-&gt;get_jobject(sym);
 632 C2V_END
 633 
 634 C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 635   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
 636   return cp-&gt;klass_ref_index_at(index);
 637 C2V_END
 638 
 639 C2V_VMENTRY_NULL(jobject, resolveTypeInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 640   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
 641   Klass* klass = cp-&gt;klass_at(index, CHECK_NULL);
 642   JVMCIKlassHandle resolved_klass(THREAD, klass);
 643   if (resolved_klass-&gt;is_instance_klass()) {
 644     InstanceKlass::cast(resolved_klass())-&gt;link_class(CHECK_NULL);
 645     if (!InstanceKlass::cast(resolved_klass())-&gt;is_linked()) {
 646       // link_class() should not return here if there is an issue.
 647       JVMCI_THROW_MSG_NULL(InternalError, err_msg("Class %s must be linked", resolved_klass()-&gt;external_name()));
 648     }
 649   }
 650   JVMCIObject klassObject = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);
 651   return JVMCIENV-&gt;get_jobject(klassObject);
 652 C2V_END
 653 
 654 C2V_VMENTRY_NULL(jobject, lookupKlassInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 655   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
 656   Klass* loading_klass = cp-&gt;pool_holder();
 657   bool is_accessible = false;
 658   JVMCIKlassHandle klass(THREAD, JVMCIRuntime::get_klass_by_index(cp, index, is_accessible, loading_klass));
 659   Symbol* symbol = NULL;
 660   if (klass.is_null()) {
 661     constantTag tag = cp-&gt;tag_at(index);
 662     if (tag.is_klass()) {
 663       // The klass has been inserted into the constant pool
 664       // very recently.
 665       klass = cp-&gt;resolved_klass_at(index);
 666     } else if (tag.is_symbol()) {
 667       symbol = cp-&gt;symbol_at(index);
 668     } else {
 669       assert(cp-&gt;tag_at(index).is_unresolved_klass(), "wrong tag");
 670       symbol = cp-&gt;klass_name_at(index);
 671     }
 672   }
 673   JVMCIObject result;
 674   if (!klass.is_null()) {
 675     result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 676   } else {
 677     result = JVMCIENV-&gt;create_string(symbol, JVMCI_CHECK_NULL);
 678   }
 679   return JVMCIENV-&gt;get_jobject(result);
 680 C2V_END
 681 
 682 C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 683   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
 684   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 685   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(appendix_oop));
 686 C2V_END
 687 
 688 C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 689   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
 690   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 691   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 692   methodHandle method = JVMCIRuntime::get_method_by_index(cp, index, bc, pool_holder);
 693   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);
 694   return JVMCIENV-&gt;get_jobject(result);
 695 C2V_END
 696 
 697 C2V_VMENTRY_0(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 698   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
 699   return cp-&gt;remap_instruction_operand_from_cache(index);
 700 C2V_END
 701 
 702 C2V_VMENTRY_NULL(jobject, resolveFieldInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))
 703   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
 704   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 705   fieldDescriptor fd;
 706   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? JVMCIENV-&gt;asMethod(jvmci_method) : NULL, CHECK_0);
 707   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 708   JVMCIPrimitiveArray info = JVMCIENV-&gt;wrap(info_handle);
 709   if (info.is_null() || JVMCIENV-&gt;get_length(info) != 3) {
 710     JVMCI_ERROR_NULL("info must not be null and have a length of 3");
 711   }
 712   JVMCIENV-&gt;put_int_at(info, 0, fd.access_flags().as_int());
 713   JVMCIENV-&gt;put_int_at(info, 1, fd.offset());
 714   JVMCIENV-&gt;put_int_at(info, 2, fd.index());
 715   JVMCIKlassHandle handle(THREAD, fd.field_holder());
 716   JVMCIObject field_holder = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
 717   return JVMCIENV-&gt;get_jobject(field_holder);
 718 C2V_END
 719 
 720 C2V_VMENTRY_0(jint, getVtableIndexForInterfaceMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))
 721   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 722   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 723   if (klass-&gt;is_interface()) {
 724     JVMCI_THROW_MSG_0(InternalError, err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 725   }
 726   if (!method-&gt;method_holder()-&gt;is_interface()) {
 727     JVMCI_THROW_MSG_0(InternalError, err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 728   }
 729   if (!klass-&gt;is_instance_klass()) {
 730     JVMCI_THROW_MSG_0(InternalError, err_msg("Class %s must be instance klass", klass-&gt;external_name()));
 731   }
 732   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 733     JVMCI_THROW_MSG_0(InternalError, err_msg("Class %s must be linked", klass-&gt;external_name()));
 734   }
 735   return LinkResolver::vtable_index_of_interface_method(klass, method);
 736 C2V_END
 737 
 738 C2V_VMENTRY_NULL(jobject, resolveMethod, (JNIEnv* env, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 739   Klass* recv_klass = JVMCIENV-&gt;asKlass(receiver_jvmci_type);
 740   Klass* caller_klass = JVMCIENV-&gt;asKlass(caller_jvmci_type);
 741   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
 742 
 743   Klass* resolved     = method-&gt;method_holder();
 744   Symbol* h_name      = method-&gt;name();
 745   Symbol* h_signature = method-&gt;signature();
 746 
 747   if (MethodHandles::is_signature_polymorphic_method(method())) {
 748       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 749       return NULL;
 750   }
 751 
 752   if (method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 753       resolved == SystemDictionary::Object_klass() &amp;&amp;
 754       recv_klass-&gt;is_array_klass()) {
 755     // Resolution of the clone method on arrays always returns Object.clone even though that method
 756     // has protected access.  There's some trickery in the access checking to make this all work out
 757     // so it's necessary to pass in the array class as the resolved class to properly trigger this.
 758     // Otherwise it's impossible to resolve the array clone methods through JVMCI.  See
 759     // LinkResolver::check_method_accessability for the matching logic.
 760     resolved = recv_klass;
 761   }
 762 
 763   LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
 764   methodHandle m;
 765   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 766   // the vtable has not been setup, and the LinkResolver will fail.
 767   if (recv_klass-&gt;is_array_klass() ||
 768       (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
 769     if (resolved-&gt;is_interface()) {
 770       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 771     } else {
 772       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 773     }
 774   }
 775 
 776   if (m.is_null()) {
 777     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 778     return NULL;
 779   }
 780 
 781   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(m, JVMCI_CHECK_NULL);
 782   return JVMCIENV-&gt;get_jobject(result);
 783 C2V_END
 784 
 785 C2V_VMENTRY_0(jboolean, hasFinalizableSubclass,(JNIEnv* env, jobject, jobject jvmci_type))
 786   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 787   assert(klass != NULL, "method must not be called for primitive types");
 788   return Dependencies::find_finalizable_subclass(klass) != NULL;
 789 C2V_END
 790 
 791 C2V_VMENTRY_NULL(jobject, getClassInitializer, (JNIEnv* env, jobject, jobject jvmci_type))
 792   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 793   if (!klass-&gt;is_instance_klass()) {
 794     return NULL;
 795   }
 796   InstanceKlass* iklass = InstanceKlass::cast(klass);
 797   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(iklass-&gt;class_initializer(), JVMCI_CHECK_NULL);
 798   return JVMCIENV-&gt;get_jobject(result);
 799 C2V_END
 800 
 801 C2V_VMENTRY_0(jlong, getMaxCallTargetOffset, (JNIEnv* env, jobject, jlong addr))
 802   address target_addr = (address) addr;
 803   if (target_addr != 0x0) {
 804     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 805     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 806     return MAX2(ABS(off_low), ABS(off_high));
 807   }
 808   return -1;
 809 C2V_END
 810 
 811 C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv* env, jobject,  jobject jvmci_method))
 812   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
 813   method-&gt;set_not_c1_compilable();
 814   method-&gt;set_not_c2_compilable();
 815   method-&gt;set_dont_inline(true);
 816 C2V_END
 817 
 818 C2V_VMENTRY_0(jint, installCode, (JNIEnv *env, jobject, jobject target, jobject compiled_code,
 819             jobject installed_code, jlong failed_speculations_address, jbyteArray speculations_obj))
 820   HandleMark hm;
 821   JNIHandleMark jni_hm(thread);
 822 
 823   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 824   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 825   CodeBlob* cb = NULL;
 826   JVMCIObject installed_code_handle = JVMCIENV-&gt;wrap(installed_code);
 827   JVMCIPrimitiveArray speculations_handle = JVMCIENV-&gt;wrap(speculations_obj);
 828 
 829   int speculations_len = JVMCIENV-&gt;get_length(speculations_handle);
 830   char* speculations = NEW_RESOURCE_ARRAY(char, speculations_len);
 831   JVMCIENV-&gt;copy_bytes_to(speculations_handle, (jbyte*) speculations, 0, speculations_len);
 832 
 833   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
 834 
 835   TraceTime install_time("installCode", JVMCICompiler::codeInstallTimer());
 836   bool is_immutable_PIC = JVMCIENV-&gt;get_HotSpotCompiledCode_isImmutablePIC(compiled_code_handle) &gt; 0;
 837 
 838   CodeInstaller installer(JVMCIENV, is_immutable_PIC);
 839   JVMCI::CodeInstallResult result = installer.install(compiler,
 840       target_handle,
 841       compiled_code_handle,
 842       cb,
 843       installed_code_handle,
 844       (FailedSpeculation**)(address) failed_speculations_address,
 845       speculations,
 846       speculations_len,
 847       JVMCI_CHECK_0);
 848 
 849   if (PrintCodeCacheOnCompilation) {
 850     stringStream s;
 851     // Dump code cache into a buffer before locking the tty,
 852     {
 853       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 854       CodeCache::print_summary(&amp;s, false);
 855     }
 856     ttyLocker ttyl;
 857     tty-&gt;print_raw_cr(s.as_string());
 858   }
 859 
 860   if (result != JVMCI::ok) {
 861     assert(cb == NULL, "should be");
 862   } else {
 863     if (installed_code_handle.is_non_null()) {
 864       if (cb-&gt;is_nmethod()) {
 865         assert(JVMCIENV-&gt;isa_HotSpotNmethod(installed_code_handle), "wrong type");
 866         // Clear the link to an old nmethod first
 867         JVMCIObject nmethod_mirror = installed_code_handle;
 868         JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK_0);
 869       } else {
 870         assert(JVMCIENV-&gt;isa_InstalledCode(installed_code_handle), "wrong type");
 871       }
 872       // Initialize the link to the new code blob
 873       JVMCIENV-&gt;initialize_installed_code(installed_code_handle, cb, JVMCI_CHECK_0);
 874     }
 875   }
 876   return result;
 877 C2V_END
 878 
 879 C2V_VMENTRY_0(jint, getMetadata, (JNIEnv *env, jobject, jobject target, jobject compiled_code, jobject metadata))
 880 #if INCLUDE_AOT
 881   HandleMark hm;
 882   assert(JVMCIENV-&gt;is_hotspot(), "AOT code is executed only in HotSpot mode");
 883 
 884   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 885   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 886   JVMCIObject metadata_handle = JVMCIENV-&gt;wrap(metadata);
 887 
 888   CodeMetadata code_metadata;
 889 
 890   CodeInstaller installer(JVMCIENV, true /* immutable PIC compilation */);
 891   JVMCI::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, JVMCI_CHECK_0);
 892   if (result != JVMCI::ok) {
 893     return result;
 894   }
 895 
 896   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 897     int size = sizeof(PcDesc) * code_metadata.get_nr_pc_desc();
 898     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 899     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_pc_desc(), array, 0, size);
 900     HotSpotJVMCI::HotSpotMetaData::set_pcDescBytes(JVMCIENV, metadata_handle, array);
 901   }
 902 
 903   if (code_metadata.get_scopes_size() &gt; 0) {
 904     int size = code_metadata.get_scopes_size();
 905     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 906     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_scopes_desc(), array, 0, size);
 907     HotSpotJVMCI::HotSpotMetaData::set_scopesDescBytes(JVMCIENV, metadata_handle, array);
 908   }
 909 
 910   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
 911   int size = (int) reloc_buffer-&gt;size();
 912   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 913   JVMCIENV-&gt;copy_bytes_from((jbyte*) reloc_buffer-&gt;begin(), array, 0, size);
 914   HotSpotJVMCI::HotSpotMetaData::set_relocBytes(JVMCIENV, metadata_handle, array);
 915 
 916   const OopMapSet* oopMapSet = installer.oopMapSet();
 917   {
 918     ResourceMark mark;
 919     ImmutableOopMapBuilder builder(oopMapSet);
 920     int size = builder.heap_size();
 921     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 922     builder.generate_into((address) HotSpotJVMCI::resolve(array)-&gt;byte_at_addr(0));
 923     HotSpotJVMCI::HotSpotMetaData::set_oopMaps(JVMCIENV, metadata_handle, array);
 924   }
 925 
 926   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
 927 
 928   int nr_meta_refs = recorder-&gt;nr_meta_refs();
 929   JVMCIObjectArray metadataArray = JVMCIENV-&gt;new_Object_array(nr_meta_refs, JVMCI_CHECK_(JVMCI::cache_full));
 930   for (int i = 0; i &lt; nr_meta_refs; ++i) {
 931     jobject element = recorder-&gt;meta_element(i);
 932     if (element == NULL) {
 933       return JVMCI::cache_full;
 934     }
 935     JVMCIENV-&gt;put_object_at(metadataArray, i, JVMCIENV-&gt;wrap(element));
 936   }
 937   HotSpotJVMCI::HotSpotMetaData::set_metadata(JVMCIENV, metadata_handle, metadataArray);
 938 
 939   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 940   int table_size = handler-&gt;size_in_bytes();
 941   JVMCIPrimitiveArray exceptionArray = JVMCIENV-&gt;new_byteArray(table_size, JVMCI_CHECK_(JVMCI::cache_full));
 942   if (table_size &gt; 0) {
 943     handler-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(exceptionArray)-&gt;byte_at_addr(0));
 944   }
 945   HotSpotJVMCI::HotSpotMetaData::set_exceptionBytes(JVMCIENV, metadata_handle, exceptionArray);
 946 
 947   ImplicitExceptionTable* implicit = code_metadata.get_implicit_exception_table();
 948   int implicit_table_size = implicit-&gt;size_in_bytes();
 949   JVMCIPrimitiveArray implicitExceptionArray = JVMCIENV-&gt;new_byteArray(implicit_table_size, JVMCI_CHECK_(JVMCI::cache_full));
 950   if (implicit_table_size &gt; 0) {
 951     implicit-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(implicitExceptionArray)-&gt;byte_at_addr(0), implicit_table_size);
 952   }
 953   HotSpotJVMCI::HotSpotMetaData::set_implicitExceptionBytes(JVMCIENV, metadata_handle, implicitExceptionArray);
 954 
 955   return result;
 956 #else
 957   JVMCI_THROW_MSG_0(InternalError, "unimplemented");
 958 #endif
 959 C2V_END
 960 
 961 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv* env, jobject))
 962   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
 963   CompilerStatistics* stats = compiler-&gt;stats();
 964   stats-&gt;_standard.reset();
 965   stats-&gt;_osr.reset();
 966 C2V_END
 967 
 968 C2V_VMENTRY_NULL(jobject, disassembleCodeBlob, (JNIEnv* env, jobject, jobject installedCode))
 969   HandleMark hm;
 970 
 971   if (installedCode == NULL) {
 972     JVMCI_THROW_MSG_NULL(NullPointerException, "installedCode is null");
 973   }
 974 
 975   JVMCIObject installedCodeObject = JVMCIENV-&gt;wrap(installedCode);
 976   nmethodLocker locker;
 977   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(installedCodeObject, locker);
 978   if (cb == NULL) {
 979     return NULL;
 980   }
 981 
 982   // We don't want the stringStream buffer to resize during disassembly as it
 983   // uses scoped resource memory. If a nested function called during disassembly uses
 984   // a ResourceMark and the buffer expands within the scope of the mark,
 985   // the buffer becomes garbage when that scope is exited. Experience shows that
 986   // the disassembled code is typically about 10x the code size so a fixed buffer
 987   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 988   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 989   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 990   stringStream st(buffer, bufferSize);
 991   if (cb-&gt;is_nmethod()) {
 992     nmethod* nm = (nmethod*) cb;
 993     if (!nm-&gt;is_alive()) {
 994       return NULL;
 995     }
 996   }
 997   Disassembler::decode(cb, &amp;st);
 998   if (st.size() &lt;= 0) {
 999     return NULL;
1000   }
1001 
1002   JVMCIObject result = JVMCIENV-&gt;create_string(st.as_string(), JVMCI_CHECK_NULL);
1003   return JVMCIENV-&gt;get_jobject(result);
1004 C2V_END
1005 
1006 C2V_VMENTRY_NULL(jobject, getStackTraceElement, (JNIEnv* env, jobject, jobject jvmci_method, int bci))
1007   HandleMark hm;
1008 
1009   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
1010   JVMCIObject element = JVMCIENV-&gt;new_StackTraceElement(method, bci, JVMCI_CHECK_NULL);
1011   return JVMCIENV-&gt;get_jobject(element);
1012 C2V_END
1013 
1014 C2V_VMENTRY_NULL(jobject, executeHotSpotNmethod, (JNIEnv* env, jobject, jobject args, jobject hs_nmethod))
1015   // The incoming arguments array would have to contain JavaConstants instead of regular objects
1016   // and the return value would have to be wrapped as a JavaConstant.
1017   requireInHotSpot("executeHotSpotNmethod", JVMCI_CHECK_NULL);
1018 
1019   HandleMark hm;
1020 
1021   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);
1022   nmethodLocker locker;
1023   nmethod* nm = JVMCIENV-&gt;get_nmethod(nmethod_mirror, locker);
1024   if (nm == NULL) {
1025     JVMCI_THROW_NULL(InvalidInstalledCodeException);
1026   }
1027   methodHandle mh = nm-&gt;method();
1028   Symbol* signature = mh-&gt;signature();
1029   JavaCallArguments jca(mh-&gt;size_of_parameters());
1030 
1031   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1032   JavaValue result(jap.get_ret_type());
1033   jca.set_alternative_target(nm);
1034   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1035 
1036   if (jap.get_ret_type() == T_VOID) {
1037     return NULL;
1038   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
1039     return JNIHandles::make_local((oop) result.get_jobject());
1040   } else {
1041     jvalue *value = (jvalue *) result.get_value_addr();
1042     // Narrow the value down if required (Important on big endian machines)
1043     switch (jap.get_ret_type()) {
1044       case T_BOOLEAN:
1045        value-&gt;z = (jboolean) value-&gt;i;
1046        break;
1047       case T_BYTE:
1048        value-&gt;b = (jbyte) value-&gt;i;
1049        break;
1050       case T_CHAR:
1051        value-&gt;c = (jchar) value-&gt;i;
1052        break;
1053       case T_SHORT:
1054        value-&gt;s = (jshort) value-&gt;i;
1055        break;
1056       default:
1057         break;
1058     }
1059     JVMCIObject o = JVMCIENV-&gt;create_box(jap.get_ret_type(), value, JVMCI_CHECK_NULL);
1060     return JVMCIENV-&gt;get_jobject(o);
1061   }
1062 C2V_END
1063 
1064 C2V_VMENTRY_NULL(jlongArray, getLineNumberTable, (JNIEnv* env, jobject, jobject jvmci_method))
1065   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1066   if (!method-&gt;has_linenumber_table()) {
1067     return NULL;
1068   }
1069   u2 num_entries = 0;
1070   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1071   while (streamForSize.read_pair()) {
1072     num_entries++;
1073   }
1074 
1075   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1076   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(2 * num_entries, JVMCI_CHECK_NULL);
1077 
1078   int i = 0;
1079   jlong value;
1080   while (stream.read_pair()) {
1081     value = ((long) stream.bci());
1082     JVMCIENV-&gt;put_long_at(result, i, value);
1083     value = ((long) stream.line());
1084     JVMCIENV-&gt;put_long_at(result, i + 1, value);
1085     i += 2;
1086   }
1087 
1088   return (jlongArray) JVMCIENV-&gt;get_jobject(result);
1089 C2V_END
1090 
1091 C2V_VMENTRY_0(jlong, getLocalVariableTableStart, (JNIEnv* env, jobject, jobject jvmci_method))
1092   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1093   if (!method-&gt;has_localvariable_table()) {
1094     return 0;
1095   }
1096   return (jlong) (address) method-&gt;localvariable_table_start();
1097 C2V_END
1098 
1099 C2V_VMENTRY_0(jint, getLocalVariableTableLength, (JNIEnv* env, jobject, jobject jvmci_method))
1100   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1101   return method-&gt;localvariable_table_length();
1102 C2V_END
1103 
1104 C2V_VMENTRY(void, reprofile, (JNIEnv* env, jobject, jobject jvmci_method))
1105   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1106   MethodCounters* mcs = method-&gt;method_counters();
1107   if (mcs != NULL) {
1108     mcs-&gt;clear_counters();
1109   }
1110   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1111 
1112   CompiledMethod* code = method-&gt;code();
1113   if (code != NULL) {
1114     code-&gt;make_not_entrant();
1115   }
1116 
1117   MethodData* method_data = method-&gt;method_data();
1118   if (method_data == NULL) {
1119     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1120     method_data = MethodData::allocate(loader_data, method, CHECK);
1121     method-&gt;set_method_data(method_data);
1122   } else {
1123     method_data-&gt;initialize();
1124   }
1125 C2V_END
1126 
1127 
1128 C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod))
1129   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);
1130   JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK);
1131 C2V_END
1132 
1133 C2V_VMENTRY_NULL(jobject, readUncompressedOop, (JNIEnv* env, jobject, jlong addr))
1134   oop ret = RawAccess&lt;&gt;::oop_load((oop*)(address)addr);
1135   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(ret));
1136  C2V_END
1137 
1138 C2V_VMENTRY_NULL(jlongArray, collectCounters, (JNIEnv* env, jobject))
1139   // Returns a zero length array if counters aren't enabled
1140   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_longArray(JVMCICounterSize, JVMCI_CHECK_NULL);
1141   if (JVMCICounterSize &gt; 0) {
1142     jlong* temp_array = NEW_RESOURCE_ARRAY(jlong, JVMCICounterSize);
1143     JavaThread::collect_counters(temp_array, JVMCICounterSize);
1144     JVMCIENV-&gt;copy_longs_from(temp_array, array, 0, JVMCICounterSize);
1145   }
1146   return (jlongArray) JVMCIENV-&gt;get_jobject(array);
1147 C2V_END
1148 
1149 C2V_VMENTRY_0(jint, getCountersSize, (JNIEnv* env, jobject))
1150   return (jint) JVMCICounterSize;
1151 C2V_END
1152 
1153 C2V_VMENTRY_0(jboolean, setCountersSize, (JNIEnv* env, jobject, jint new_size))
1154   return JavaThread::resize_all_jvmci_counters(new_size);
1155 C2V_END
1156 
1157 C2V_VMENTRY_0(jint, allocateCompileId, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci))
1158   HandleMark hm;
1159   if (jvmci_method == NULL) {
1160     JVMCI_THROW_0(NullPointerException);
1161   }
1162   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1163   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1164     JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg("Unexpected bci %d", entry_bci));
1165   }
1166   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1167 C2V_END
1168 
1169 
1170 C2V_VMENTRY_0(jboolean, isMature, (JNIEnv* env, jobject, jlong metaspace_method_data))
1171   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);
1172   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1173 C2V_END
1174 
1175 C2V_VMENTRY_0(jboolean, hasCompiledCodeForOSR, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1176   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1177   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1178 C2V_END
1179 
1180 C2V_VMENTRY_NULL(jobject, getSymbol, (JNIEnv* env, jobject, jlong symbol))
1181   JVMCIObject sym = JVMCIENV-&gt;create_string((Symbol*)(address)symbol, JVMCI_CHECK_NULL);
1182   return JVMCIENV-&gt;get_jobject(sym);
1183 C2V_END
1184 
1185 bool matches(jobjectArray methods, Method* method, JVMCIEnv* JVMCIENV) {
1186   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1187 
1188   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1189     oop resolved = methods_oop-&gt;obj_at(i);
1190     if ((resolved-&gt;klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; HotSpotJVMCI::asMethod(JVMCIENV, resolved) == method) {
1191       return true;
1192     }
1193   }
1194   return false;
1195 }
1196 
1197 void call_interface(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
1198   CallInfo callinfo;
1199   Handle receiver = args-&gt;receiver();
1200   Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
1201   LinkInfo link_info(spec_klass, name, signature);
1202   LinkResolver::resolve_interface_call(
1203           callinfo, receiver, recvrKlass, link_info, true, CHECK);
1204   methodHandle method = callinfo.selected_method();
1205   assert(method.not_null(), "should have thrown exception");
1206 
1207   // Invoke the method
1208   JavaCalls::call(result, method, args, CHECK);
1209 }
1210 
1211 C2V_VMENTRY_NULL(jobject, iterateFrames, (JNIEnv* env, jobject compilerToVM, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, jobject visitor_handle))
1212 
1213   if (!thread-&gt;has_last_Java_frame()) {
1214     return NULL;
1215   }
1216   Handle visitor(THREAD, JNIHandles::resolve_non_null(visitor_handle));
1217 
1218   requireInHotSpot("iterateFrames", JVMCI_CHECK_NULL);
1219 
1220   HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1221   Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1222 
1223   StackFrameStream fst(thread);
1224   jobjectArray methods = initial_methods;
1225 
1226   int frame_number = 0;
1227   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1228 
1229   while (true) {
1230     // look for the given method
1231     bool realloc_called = false;
1232     while (true) {
1233       StackValueCollection* locals = NULL;
1234       if (vf-&gt;is_compiled_frame()) {
1235         // compiled method frame
1236         compiledVFrame* cvf = compiledVFrame::cast(vf);
1237         if (methods == NULL || matches(methods, cvf-&gt;method(), JVMCIENV)) {
1238           if (initialSkip &gt; 0) {
1239             initialSkip--;
1240           } else {
1241             ScopeDesc* scope = cvf-&gt;scope();
1242             // native wrappers do not have a scope
1243             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1244               GrowableArray&lt;ScopeValue*&gt;* objects;
1245               if (!realloc_called) {
1246                 objects = scope-&gt;objects();
1247               } else {
1248                 // some object might already have been re-allocated, only reallocate the non-allocated ones
1249                 objects = new GrowableArray&lt;ScopeValue*&gt;(scope-&gt;objects()-&gt;length());
1250                 for (int i = 0; i &lt; scope-&gt;objects()-&gt;length(); i++) {
1251                   ObjectValue* sv = (ObjectValue*) scope-&gt;objects()-&gt;at(i);
1252                   if (sv-&gt;value().is_null()) {
1253                     objects-&gt;append(sv);
1254                   }
1255                 }
1256               }
1257               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);
1258               Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);
1259               realloc_called = true;
1260 
1261               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1262               assert(local_values != NULL, "NULL locals");
1263               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1264               typeArrayHandle array(THREAD, array_oop);
1265               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1266                 ScopeValue* value = local_values-&gt;at(i);
1267                 if (value-&gt;is_object()) {
1268                   array-&gt;bool_at_put(i, true);
1269                 }
1270               }
1271               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());
1272             } else {
1273               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);
1274             }
1275 
1276             locals = cvf-&gt;locals();
1277             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf-&gt;bci());
1278             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(cvf-&gt;method(), JVMCI_CHECK_NULL);
1279             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));
1280           }
1281         }
1282       } else if (vf-&gt;is_interpreted_frame()) {
1283         // interpreted method frame
1284         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1285         if (methods == NULL || matches(methods, ivf-&gt;method(), JVMCIENV)) {
1286           if (initialSkip &gt; 0) {
1287             initialSkip--;
1288           } else {
1289             locals = ivf-&gt;locals();
1290             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), ivf-&gt;bci());
1291             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(ivf-&gt;method(), JVMCI_CHECK_NULL);
1292             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));
1293             HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);
1294           }
1295         }
1296       }
1297 
1298       // locals != NULL means that we found a matching frame and result is already partially initialized
1299       if (locals != NULL) {
1300         methods = match_methods;
1301         HotSpotJVMCI::HotSpotStackFrameReference::set_compilerToVM(JVMCIENV, frame_reference(), JNIHandles::resolve(compilerToVM));
1302         HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) fst.current()-&gt;sp());
1303         HotSpotJVMCI::HotSpotStackFrameReference::set_frameNumber(JVMCIENV, frame_reference(), frame_number);
1304 
1305         // initialize the locals array
1306         objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
1307         objArrayHandle array(THREAD, array_oop);
1308         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1309           StackValue* var = locals-&gt;at(i);
1310           if (var-&gt;type() == T_OBJECT) {
1311             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1312           }
1313         }
1314         HotSpotJVMCI::HotSpotStackFrameReference::set_locals(JVMCIENV, frame_reference(), array());
1315         HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, frame_reference(), JNI_FALSE);
1316 
1317         JavaValue result(T_OBJECT);
1318         JavaCallArguments args(visitor);
1319         args.push_oop(frame_reference);
1320         call_interface(&amp;result, HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &amp;args, CHECK_NULL);
1321         if (result.get_jobject() != NULL) {
1322           return JNIHandles::make_local(thread, (oop) result.get_jobject());
1323         }
1324         assert(initialSkip == 0, "There should be no match before initialSkip == 0");
1325         if (HotSpotJVMCI::HotSpotStackFrameReference::objectsMaterialized(JVMCIENV, frame_reference()) == JNI_TRUE) {
1326           // the frame has been deoptimized, we need to re-synchronize the frame and vframe
1327           intptr_t* stack_pointer = (intptr_t*) HotSpotJVMCI::HotSpotStackFrameReference::stackPointer(JVMCIENV, frame_reference());
1328           fst = StackFrameStream(thread);
1329           while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1330             fst.next();
1331           }
1332           if (fst.current()-&gt;sp() != stack_pointer) {
1333             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "stack frame not found after deopt")
1334           }
1335           vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1336           if (!vf-&gt;is_compiled_frame()) {
1337             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1338           }
1339           for (int i = 0; i &lt; frame_number; i++) {
1340             if (vf-&gt;is_top()) {
1341               THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "vframe not found after deopt")
1342             }
1343             vf = vf-&gt;sender();
1344             assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1345           }
1346         }
1347         frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1348         HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1349       }
1350 
1351       if (vf-&gt;is_top()) {
1352         break;
1353       }
1354       frame_number++;
1355       vf = vf-&gt;sender();
1356     } // end of vframe loop
1357 
1358     if (fst.is_done()) {
1359       break;
1360     }
1361     fst.next();
1362     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1363     frame_number = 0;
1364   } // end of frame loop
1365 
1366   // the end was reached without finding a matching method
1367   return NULL;
1368 C2V_END
1369 
1370 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1371   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
1372   CallInfo callInfo;
1373   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1374   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1375   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1376 C2V_END
1377 
1378 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1379   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
1380   Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
1381   Symbol* name = cp-&gt;name_ref_at(index);
1382   if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
1383     CallInfo callInfo;
1384     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1385     ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1386     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1387   }
1388 C2V_END
1389 
1390 C2V_VMENTRY_0(jint, isResolvedInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1391   constantPoolHandle cp = JVMCIENV-&gt;asConstantPool(jvmci_constant_pool);
1392   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1393   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
1394     // MethodHandle.invoke* --&gt; LambdaForm?
1395     ResourceMark rm;
1396 
1397     LinkInfo link_info(cp, index, CATCH);
1398 
1399     Klass* resolved_klass = link_info.resolved_klass();
1400 
1401     Symbol* name_sym = cp-&gt;name_ref_at(index);
1402 
1403     vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), "!");
1404     vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), "!");
1405 
1406     methodHandle adapter_method(cp_cache_entry-&gt;f1_as_method());
1407 
1408     methodHandle resolved_method(adapter_method);
1409 
1410     // Can we treat it as a regular invokevirtual?
1411     if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
1412       vmassert(!resolved_method-&gt;is_static(),"!");
1413       vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),"!");
1414       vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), "!");
1415       vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, "!");
1416       vmassert(cp_cache_entry-&gt;method_type_if_resolved(cp) == NULL, "!");
1417 
1418       methodHandle m(LinkResolver::linktime_resolve_virtual_method_or_null(link_info));
1419       vmassert(m == resolved_method, "!!");
1420       return -1;
1421     }
1422 
1423     return Bytecodes::_invokevirtual;
1424   }
1425   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokedynamic)) {
1426     return Bytecodes::_invokedynamic;
1427   }
1428   return -1;
1429 C2V_END
1430 
1431 
1432 C2V_VMENTRY_NULL(jobject, getSignaturePolymorphicHolders, (JNIEnv* env, jobject))
1433   JVMCIObjectArray holders = JVMCIENV-&gt;new_String_array(2, JVMCI_CHECK_NULL);
1434   JVMCIObject mh = JVMCIENV-&gt;create_string("Ljava/lang/invoke/MethodHandle;", JVMCI_CHECK_NULL);
1435   JVMCIObject vh = JVMCIENV-&gt;create_string("Ljava/lang/invoke/VarHandle;", JVMCI_CHECK_NULL);
1436   JVMCIENV-&gt;put_object_at(holders, 0, mh);
1437   JVMCIENV-&gt;put_object_at(holders, 1, vh);
1438   return JVMCIENV-&gt;get_jobject(holders);
1439 C2V_END
1440 
1441 C2V_VMENTRY_0(jboolean, shouldDebugNonSafepoints, (JNIEnv* env, jobject))
1442   //see compute_recording_non_safepoints in debugInfroRec.cpp
1443   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1444     return true;
1445   }
1446   return DebugNonSafepoints;
1447 C2V_END
1448 
1449 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1450 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv* env, jobject, jobject _hs_frame, bool invalidate))
1451   JVMCIObject hs_frame = JVMCIENV-&gt;wrap(_hs_frame);
1452   if (hs_frame.is_null()) {
1453     JVMCI_THROW_MSG(NullPointerException, "stack frame is null");
1454   }
1455 
1456   requireInHotSpot("materializeVirtualObjects", JVMCI_CHECK);
1457 
1458   JVMCIENV-&gt;HotSpotStackFrameReference_initialize(JVMCI_CHECK);
1459 
1460   // look for the given stack frame
1461   StackFrameStream fst(thread);
1462   intptr_t* stack_pointer = (intptr_t*) JVMCIENV-&gt;get_HotSpotStackFrameReference_stackPointer(hs_frame);
1463   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1464     fst.next();
1465   }
1466   if (fst.current()-&gt;sp() != stack_pointer) {
1467     JVMCI_THROW_MSG(IllegalStateException, "stack frame not found");
1468   }
1469 
1470   if (invalidate) {
1471     if (!fst.current()-&gt;is_compiled_frame()) {
1472       JVMCI_THROW_MSG(IllegalStateException, "compiled stack frame expected");
1473     }
1474     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), "nmethod expected");
1475     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1476   }
1477   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1478   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1479   StackFrameStream fstAfterDeopt(thread);
1480   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1481     fstAfterDeopt.next();
1482   }
1483   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1484     JVMCI_THROW_MSG(IllegalStateException, "stack frame not found after deopt");
1485   }
1486 
1487   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1488   if (!vf-&gt;is_compiled_frame()) {
1489     JVMCI_THROW_MSG(IllegalStateException, "compiled stack frame expected");
1490   }
1491 
1492   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1493   while (true) {
1494     assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1495     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1496     if (vf-&gt;is_top()) {
1497       break;
1498     }
1499     vf = vf-&gt;sender();
1500   }
1501 
1502   int last_frame_number = JVMCIENV-&gt;get_HotSpotStackFrameReference_frameNumber(hs_frame);
1503   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1504     JVMCI_THROW_MSG(IllegalStateException, "invalid frame number");
1505   }
1506 
1507   // Reallocate the non-escaping objects and restore their fields.
1508   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,"invalid scope");
1509   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1510 
1511   if (objects == NULL) {
1512     // no objects to materialize
1513     return;
1514   }
1515 
1516   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, CHECK);
1517   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1518 
1519   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1520     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1521 
1522     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1523     StackValueCollection* locals = cvf-&gt;locals();
1524     if (locals != NULL) {
1525       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1526         StackValue* var = locals-&gt;at(i2);
1527         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1528           jvalue val;
1529           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1530           cvf-&gt;update_local(T_OBJECT, i2, val);
1531         }
1532       }
1533     }
1534 
1535     GrowableArray&lt;ScopeValue*&gt;* scopeExpressions = cvf-&gt;scope()-&gt;expressions();
1536     StackValueCollection* expressions = cvf-&gt;expressions();
1537     if (expressions != NULL) {
1538       for (int i2 = 0; i2 &lt; expressions-&gt;size(); i2++) {
1539         StackValue* var = expressions-&gt;at(i2);
1540         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeExpressions-&gt;at(i2)-&gt;is_object()) {
1541           jvalue val;
1542           val.l = (jobject) expressions-&gt;at(i2)-&gt;get_obj()();
1543           cvf-&gt;update_stack(T_OBJECT, i2, val);
1544         }
1545       }
1546     }
1547 
1548     GrowableArray&lt;MonitorValue*&gt;* scopeMonitors = cvf-&gt;scope()-&gt;monitors();
1549     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
1550     if (monitors != NULL) {
1551       for (int i2 = 0; i2 &lt; monitors-&gt;length(); i2++) {
1552         cvf-&gt;update_monitor(i2, monitors-&gt;at(i2));
1553       }
1554     }
1555   }
1556 
1557   // all locals are materialized by now
1558   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);
1559   // update the locals array
1560   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);
1561   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1562   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1563     StackValue* var = locals-&gt;at(i);
1564     if (var-&gt;type() == T_OBJECT) {
1565       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));
1566     }
1567   }
1568   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);
1569 C2V_END
1570 
1571 // Creates a scope where the current thread is attached and detached
1572 // from HotSpot if it wasn't already attached when entering the scope.
1573 extern "C" void jio_printf(const char *fmt, ...);
1574 class AttachDetach : public StackObj {
1575  public:
1576   bool _attached;
1577   AttachDetach(JNIEnv* env, Thread* current_thread) {
1578     if (current_thread == NULL) {
1579       extern struct JavaVM_ main_vm;
1580       JNIEnv* hotspotEnv;
1581       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
1582       _attached = res == JNI_OK;
1583       static volatile int report_attach_error = 0;
1584       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(1, &amp;report_attach_error, 0) == 0) {
1585         // Only report an attach error once
1586         jio_printf("Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n", res);
1587       }
1588     } else {
1589       _attached = false;
1590     }
1591   }
1592   ~AttachDetach() {
1593     if (_attached &amp;&amp; get_current_thread() != NULL) {
1594       extern struct JavaVM_ main_vm;
1595       jint res = main_vm.DetachCurrentThread();
1596       static volatile int report_detach_error = 0;
1597       if (res != JNI_OK &amp;&amp; report_detach_error == 0 &amp;&amp; Atomic::cmpxchg(1, &amp;report_detach_error, 0) == 0) {
1598         // Only report an attach error once
1599         jio_printf("Warning: detaching current thread from VM failed with %d (future attach errors are suppressed)\n", res);
1600       }
1601     }
1602   }
1603 };
1604 
1605 C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))
1606   AttachDetach ad(env, base_thread);
1607   bool use_tty = true;
1608   if (base_thread == NULL) {
1609     if (!ad._attached) {
1610       // Can only use tty if the current thread is attached
1611       return 0;
1612     }
1613     base_thread = get_current_thread();
1614   }
1615   JVMCITraceMark jtm("writeDebugOutput");
1616   assert(base_thread-&gt;is_Java_thread(), "just checking");
1617   JavaThread* thread = (JavaThread*) base_thread;
1618   C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))
1619   if (bytes == NULL) {
1620     if (can_throw) {
1621       JVMCI_THROW_0(NullPointerException);
1622     }
1623     return -1;
1624   }
1625   JVMCIPrimitiveArray array = JVMCIENV-&gt;wrap(bytes);
1626 
1627   // Check if offset and length are non negative.
1628   if (offset &lt; 0 || length &lt; 0) {
1629     if (can_throw) {
1630       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1631     }
1632     return -2;
1633   }
1634   // Check if the range is valid.
1635   int array_length = JVMCIENV-&gt;get_length(array);
1636   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array_length)) {
1637     if (can_throw) {
1638       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1639     }
1640     return -2;
1641   }
1642   jbyte buffer[O_BUFLEN];
1643   while (length &gt; 0) {
1644     int copy_len = MIN2(length, (jint)O_BUFLEN);
1645     JVMCIENV-&gt;copy_bytes_to(array, buffer, offset, copy_len);
1646     tty-&gt;write((char*) buffer, copy_len);
1647     length -= O_BUFLEN;
1648     offset += O_BUFLEN;
1649   }
1650   if (flush) {
1651     tty-&gt;flush();
1652   }
1653   return 0;
1654 C2V_END
1655 
1656 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv* env, jobject))
1657   tty-&gt;flush();
1658 C2V_END
1659 
1660 C2V_VMENTRY_0(jint, methodDataProfileDataSize, (JNIEnv* env, jobject, jlong metaspace_method_data, jint position))
1661   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);
1662   ProfileData* profile_data = mdo-&gt;data_at(position);
1663   if (mdo-&gt;is_valid(profile_data)) {
1664     return profile_data-&gt;size_in_bytes();
1665   }
1666   DataLayout* data    = mdo-&gt;extra_data_base();
1667   DataLayout* end   = mdo-&gt;extra_data_limit();
1668   for (;; data = mdo-&gt;next_extra(data)) {
1669     assert(data &lt; end, "moved past end of extra data");
1670     profile_data = data-&gt;data_in();
1671     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1672       return profile_data-&gt;size_in_bytes();
1673     }
1674   }
1675   JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg("Invalid profile data position %d", position));
1676 C2V_END
1677 
1678 C2V_VMENTRY_0(jlong, getFingerprint, (JNIEnv* env, jobject, jlong metaspace_klass))
1679 #if INCLUDE_AOT
1680   Klass *k = (Klass*) (address) metaspace_klass;
1681   if (k-&gt;is_instance_klass()) {
1682     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1683   } else {
1684     return 0;
1685   }
1686 #else
1687   JVMCI_THROW_MSG_0(InternalError, "unimplemented");
1688 #endif
1689 C2V_END
1690 
1691 C2V_VMENTRY_NULL(jobject, getHostClass, (JNIEnv* env, jobject, jobject jvmci_type))
1692   InstanceKlass* k = InstanceKlass::cast(JVMCIENV-&gt;asKlass(jvmci_type));
1693   InstanceKlass* host = k-&gt;host_klass();
1694   JVMCIKlassHandle handle(THREAD, host);
1695   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
1696   return JVMCIENV-&gt;get_jobject(result);
1697 C2V_END
1698 
1699 C2V_VMENTRY_NULL(jobject, getInterfaces, (JNIEnv* env, jobject, jobject jvmci_type))
1700   if (jvmci_type == NULL) {
1701     JVMCI_THROW_0(NullPointerException);
1702   }
1703 
1704   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1705   if (klass == NULL) {
1706     JVMCI_THROW_0(NullPointerException);
1707   }
1708   if (!klass-&gt;is_instance_klass()) {
1709     JVMCI_THROW_MSG_0(InternalError, err_msg("Class %s must be instance klass", klass-&gt;external_name()));
1710   }
1711   InstanceKlass* iklass = InstanceKlass::cast(klass);
1712 
1713   // Regular instance klass, fill in all local interfaces
1714   int size = iklass-&gt;local_interfaces()-&gt;length();
1715   JVMCIObjectArray interfaces = JVMCIENV-&gt;new_HotSpotResolvedObjectTypeImpl_array(size, JVMCI_CHECK_NULL);
1716   for (int index = 0; index &lt; size; index++) {
1717     JVMCIKlassHandle klass(THREAD);
1718     Klass* k = iklass-&gt;local_interfaces()-&gt;at(index);
1719     klass = k;
1720     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
1721     JVMCIENV-&gt;put_object_at(interfaces, index, type);
1722   }
1723   return JVMCIENV-&gt;get_jobject(interfaces);
1724 C2V_END
1725 
1726 C2V_VMENTRY_NULL(jobject, getComponentType, (JNIEnv* env, jobject, jobject jvmci_type))
1727   if (jvmci_type == NULL) {
1728     JVMCI_THROW_0(NullPointerException);
1729   }
1730 
1731   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1732   oop mirror = klass-&gt;java_mirror();
1733   if (java_lang_Class::is_primitive(mirror) ||
1734       !java_lang_Class::as_Klass(mirror)-&gt;is_array_klass()) {
1735     return NULL;
1736   }
1737 
1738   oop component_mirror = java_lang_Class::component_mirror(mirror);
1739   if (component_mirror == NULL) {
1740     return NULL;
1741   }
1742   Klass* component_klass = java_lang_Class::as_Klass(component_mirror);
1743   if (component_klass != NULL) {
1744     JVMCIKlassHandle klass_handle(THREAD);
1745     klass_handle = component_klass;
1746     JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);
1747     return JVMCIENV-&gt;get_jobject(result);
1748   }
1749   BasicType type = java_lang_Class::primitive_type(component_mirror);
1750   JVMCIObject result = JVMCIENV-&gt;get_jvmci_primitive_type(type);
1751   return JVMCIENV-&gt;get_jobject(result);
1752 C2V_END
1753 
1754 C2V_VMENTRY(void, ensureInitialized, (JNIEnv* env, jobject, jobject jvmci_type))
1755   if (jvmci_type == NULL) {
1756     JVMCI_THROW(NullPointerException);
1757   }
1758 
1759   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1760   if (klass != NULL &amp;&amp; klass-&gt;should_be_initialized()) {
1761     InstanceKlass* k = InstanceKlass::cast(klass);
1762     k-&gt;initialize(CHECK);
1763   }
1764 C2V_END
1765 
1766 C2V_VMENTRY_0(jint, interpreterFrameSize, (JNIEnv* env, jobject, jobject bytecode_frame_handle))
1767   if (bytecode_frame_handle == NULL) {
1768     JVMCI_THROW_0(NullPointerException);
1769   }
1770 
1771   JVMCIObject top_bytecode_frame = JVMCIENV-&gt;wrap(bytecode_frame_handle);
1772   JVMCIObject bytecode_frame = top_bytecode_frame;
1773   int size = 0;
1774   int callee_parameters = 0;
1775   int callee_locals = 0;
1776   Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));
1777   int extra_args = method-&gt;max_stack() - JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);
1778 
1779   while (bytecode_frame.is_non_null()) {
1780     int locks = JVMCIENV-&gt;get_BytecodeFrame_numLocks(bytecode_frame);
1781     int temps = JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);
1782     bool is_top_frame = (JVMCIENV-&gt;equals(bytecode_frame, top_bytecode_frame));
1783     Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));
1784 
1785     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1786                                                                  temps + callee_parameters,
1787                                                                  extra_args,
1788                                                                  locks,
1789                                                                  callee_parameters,
1790                                                                  callee_locals,
1791                                                                  is_top_frame);
1792     size += frame_size;
1793 
1794     callee_parameters = method-&gt;size_of_parameters();
1795     callee_locals = method-&gt;max_locals();
1796     extra_args = 0;
1797     bytecode_frame = JVMCIENV-&gt;get_BytecodePosition_caller(bytecode_frame);
1798   }
1799   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1800 C2V_END
1801 
1802 C2V_VMENTRY(void, compileToBytecode, (JNIEnv* env, jobject, jobject lambda_form_handle))
1803   Handle lambda_form = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(lambda_form_handle), JVMCI_CHECK);
1804   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1805     TempNewSymbol compileToBytecode = SymbolTable::new_symbol("compileToBytecode", CHECK);
1806     JavaValue result(T_VOID);
1807     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1808   } else {
1809     JVMCI_THROW_MSG(IllegalArgumentException,
1810                     err_msg("Unexpected type: %s", lambda_form-&gt;klass()-&gt;external_name()))
1811   }
1812 C2V_END
1813 
1814 C2V_VMENTRY_0(jint, getIdentityHashCode, (JNIEnv* env, jobject, jobject object))
1815   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1816   return obj-&gt;identity_hash();
1817 C2V_END
1818 
1819 C2V_VMENTRY_0(jboolean, isInternedString, (JNIEnv* env, jobject, jobject object))
1820   Handle str = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1821   if (!java_lang_String::is_instance(str())) {
1822     return false;
1823   }
1824   int len;
1825   jchar* name = java_lang_String::as_unicode_string(str(), len, CHECK_0);
1826   return (StringTable::lookup(name, len) != NULL);
1827 C2V_END
1828 
1829 
1830 C2V_VMENTRY_NULL(jobject, unboxPrimitive, (JNIEnv* env, jobject, jobject object))
1831   if (object == NULL) {
1832     JVMCI_THROW_0(NullPointerException);
1833   }
1834   Handle box = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
1835   BasicType type = java_lang_boxing_object::basic_type(box());
1836   jvalue result;
1837   if (java_lang_boxing_object::get_value(box(), &amp;result) == T_ILLEGAL) {
1838     return NULL;
1839   }
1840   JVMCIObject boxResult = JVMCIENV-&gt;create_box(type, &amp;result, JVMCI_CHECK_NULL);
1841   return JVMCIENV-&gt;get_jobject(boxResult);
1842 C2V_END
1843 
1844 C2V_VMENTRY_NULL(jobject, boxPrimitive, (JNIEnv* env, jobject, jobject object))
1845   if (object == NULL) {
1846     JVMCI_THROW_0(NullPointerException);
1847   }
1848   JVMCIObject box = JVMCIENV-&gt;wrap(object);
1849   BasicType type = JVMCIENV-&gt;get_box_type(box);
1850   if (type == T_ILLEGAL) {
1851     return NULL;
1852   }
1853   jvalue value = JVMCIENV-&gt;get_boxed_value(type, box);
1854   JavaValue box_result(T_OBJECT);
1855   JavaCallArguments jargs;
1856   Klass* box_klass = NULL;
1857   Symbol* box_signature = NULL;
1858 #define BOX_CASE(bt, v, argtype, name)           \
1859   case bt: \
1860     jargs.push_##argtype(value.v); \
1861     box_klass = SystemDictionary::name##_klass(); \
1862     box_signature = vmSymbols::name##_valueOf_signature(); \
1863     break
1864 
1865   switch (type) {
1866     BOX_CASE(T_BOOLEAN, z, int, Boolean);
1867     BOX_CASE(T_BYTE, b, int, Byte);
1868     BOX_CASE(T_CHAR, c, int, Character);
1869     BOX_CASE(T_SHORT, s, int, Short);
1870     BOX_CASE(T_INT, i, int, Integer);
1871     BOX_CASE(T_LONG, j, long, Long);
1872     BOX_CASE(T_FLOAT, f, float, Float);
1873     BOX_CASE(T_DOUBLE, d, double, Double);
1874     default:
1875       ShouldNotReachHere();
1876   }
1877 #undef BOX_CASE
1878 
1879   JavaCalls::call_static(&amp;box_result,
1880                          box_klass,
1881                          vmSymbols::valueOf_name(),
1882                          box_signature, &amp;jargs, CHECK_NULL);
1883   oop hotspot_box = (oop) box_result.get_jobject();
1884   JVMCIObject result = JVMCIENV-&gt;get_object_constant(hotspot_box, false);
1885   return JVMCIENV-&gt;get_jobject(result);
1886 C2V_END
1887 
1888 C2V_VMENTRY_NULL(jobjectArray, getDeclaredConstructors, (JNIEnv* env, jobject, jobject holder))
1889   if (holder == NULL) {
1890     JVMCI_THROW_0(NullPointerException);
1891   }
1892   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1893   if (!klass-&gt;is_instance_klass()) {
1894     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1895     return JVMCIENV-&gt;get_jobjectArray(methods);
1896   }
1897 
1898   InstanceKlass* iklass = InstanceKlass::cast(klass);
1899   // Ensure class is linked
1900   iklass-&gt;link_class(CHECK_NULL);
1901 
1902   GrowableArray&lt;Method*&gt; constructors_array;
1903   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1904     Method* m = iklass-&gt;methods()-&gt;at(i);
1905     if (m-&gt;is_initializer() &amp;&amp; !m-&gt;is_static()) {
1906       constructors_array.append(m);
1907     }
1908   }
1909   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(constructors_array.length(), JVMCI_CHECK_NULL);
1910   for (int i = 0; i &lt; constructors_array.length(); i++) {
1911     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(constructors_array.at(i), JVMCI_CHECK_NULL);
1912     JVMCIENV-&gt;put_object_at(methods, i, method);
1913   }
1914   return JVMCIENV-&gt;get_jobjectArray(methods);
1915 C2V_END
1916 
1917 C2V_VMENTRY_NULL(jobjectArray, getDeclaredMethods, (JNIEnv* env, jobject, jobject holder))
1918   if (holder == NULL) {
1919     JVMCI_THROW_0(NullPointerException);
1920   }
1921   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1922   if (!klass-&gt;is_instance_klass()) {
1923     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1924     return JVMCIENV-&gt;get_jobjectArray(methods);
1925   }
1926 
1927   InstanceKlass* iklass = InstanceKlass::cast(klass);
1928   // Ensure class is linked
1929   iklass-&gt;link_class(CHECK_NULL);
1930 
1931   GrowableArray&lt;Method*&gt; methods_array;
1932   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1933     Method* m = iklass-&gt;methods()-&gt;at(i);
1934     if (!m-&gt;is_initializer() &amp;&amp; !m-&gt;is_overpass()) {
1935       methods_array.append(m);
1936     }
1937   }
1938   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(methods_array.length(), JVMCI_CHECK_NULL);
1939   for (int i = 0; i &lt; methods_array.length(); i++) {
1940     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(methods_array.at(i), JVMCI_CHECK_NULL);
1941     JVMCIENV-&gt;put_object_at(methods, i, method);
1942   }
1943   return JVMCIENV-&gt;get_jobjectArray(methods);
1944 C2V_END
1945 
1946 C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject field, jboolean is_volatile))
1947   if (object == NULL || field == NULL) {
1948     JVMCI_THROW_0(NullPointerException);
1949   }
1950   JVMCIObject field_object = JVMCIENV-&gt;wrap(field);
1951   JVMCIObject java_type = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_type(field_object);
1952   int modifiers = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_modifiers(field_object);
1953   Klass* holder = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_holder(field_object));
1954   if (!holder-&gt;is_instance_klass()) {
1955     JVMCI_THROW_MSG_0(InternalError, err_msg("Holder %s must be instance klass", holder-&gt;external_name()));
1956   }
1957   InstanceKlass* ik = InstanceKlass::cast(holder);
1958   BasicType constant_type;
1959   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(java_type)) {
1960     constant_type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(java_type), JVMCI_CHECK_NULL);
1961   } else {
1962     constant_type = T_OBJECT;
1963   }
1964   int displacement = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_offset(field_object);
1965   fieldDescriptor fd;
1966   if (!ik-&gt;find_local_field_from_offset(displacement, (modifiers &amp; JVM_ACC_STATIC) != 0, &amp;fd)) {
1967     JVMCI_THROW_MSG_0(InternalError, err_msg("Can't find field with displacement %d", displacement));
1968   }
1969   JVMCIObject base = JVMCIENV-&gt;wrap(object);
1970   Handle obj;
1971   if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base)) {
1972     obj = JVMCIENV-&gt;asConstant(base, JVMCI_CHECK_NULL);
1973   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base)) {
1974     Klass* klass = JVMCIENV-&gt;asKlass(base);
1975     obj = Handle(THREAD, klass-&gt;java_mirror());
1976   } else {
1977     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
1978                          err_msg("Unexpected type: %s", JVMCIENV-&gt;klass_name(base)));
1979   }
1980   jlong value = 0;
1981   JVMCIObject kind;
1982   switch (constant_type) {
1983     case T_OBJECT: {
1984       oop object = is_volatile ? obj-&gt;obj_field_acquire(displacement) : obj-&gt;obj_field(displacement);
1985       JVMCIObject result = JVMCIENV-&gt;get_object_constant(object);
1986       if (result.is_null()) {
1987         return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_JavaConstant_NULL_POINTER());
1988       }
1989       return JVMCIENV-&gt;get_jobject(result);
1990     }
1991     case T_FLOAT: {
1992       float f = is_volatile ? obj-&gt;float_field_acquire(displacement) : obj-&gt;float_field(displacement);
1993       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forFloat(f, JVMCI_CHECK_NULL);
1994       return JVMCIENV-&gt;get_jobject(result);
1995     }
1996     case T_DOUBLE: {
1997       double f = is_volatile ? obj-&gt;double_field_acquire(displacement) : obj-&gt;double_field(displacement);
1998       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forDouble(f, JVMCI_CHECK_NULL);
1999       return JVMCIENV-&gt;get_jobject(result);
2000     }
2001     case T_BOOLEAN: value = is_volatile ? obj-&gt;bool_field_acquire(displacement) : obj-&gt;bool_field(displacement); break;
2002     case T_BYTE: value = is_volatile ? obj-&gt;byte_field_acquire(displacement) : obj-&gt;byte_field(displacement); break;
2003     case T_SHORT: value = is_volatile ? obj-&gt;short_field_acquire(displacement) : obj-&gt;short_field(displacement); break;
2004     case T_CHAR: value = is_volatile ? obj-&gt;char_field_acquire(displacement) : obj-&gt;char_field(displacement); break;
2005     case T_INT: value = is_volatile ? obj-&gt;int_field_acquire(displacement) : obj-&gt;int_field(displacement); break;
2006     case T_LONG: value = is_volatile ? obj-&gt;long_field_acquire(displacement) : obj-&gt;long_field(displacement); break;
2007     default:
2008       ShouldNotReachHere();
2009   }
2010   JVMCIObject result = JVMCIENV-&gt;call_PrimitiveConstant_forTypeChar(type2char(constant_type), value, JVMCI_CHECK_NULL);
2011   return JVMCIENV-&gt;get_jobject(result);
2012 C2V_END
2013 
2014 C2V_VMENTRY_0(jboolean, isInstance, (JNIEnv* env, jobject, jobject holder, jobject object))
2015   if (object == NULL || holder == NULL) {
2016     JVMCI_THROW_0(NullPointerException);
2017   }
2018   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
2019   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));
2020   return obj-&gt;is_a(klass);
2021 C2V_END
2022 
2023 C2V_VMENTRY_0(jboolean, isAssignableFrom, (JNIEnv* env, jobject, jobject holder, jobject otherHolder))
2024   if (holder == NULL || otherHolder == NULL) {
2025     JVMCI_THROW_0(NullPointerException);
2026   }
2027   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));
2028   Klass* otherKlass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(otherHolder));
2029   return otherKlass-&gt;is_subtype_of(klass);
2030 C2V_END
2031 
2032 C2V_VMENTRY_0(jboolean, isTrustedForIntrinsics, (JNIEnv* env, jobject, jobject holder))
2033   if (holder == NULL) {
2034     JVMCI_THROW_0(NullPointerException);
2035   }
2036   InstanceKlass* ik = InstanceKlass::cast(JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder)));
2037   if (ik-&gt;class_loader_data()-&gt;is_boot_class_loader_data() || ik-&gt;class_loader_data()-&gt;is_platform_class_loader_data()) {
2038     return true;
2039   }
2040   return false;
2041 C2V_END
2042 
2043 C2V_VMENTRY_NULL(jobject, asJavaType, (JNIEnv* env, jobject, jobject object))
2044   if (object == NULL) {
2045     JVMCI_THROW_0(NullPointerException);
2046   }
2047   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
2048   if (java_lang_Class::is_instance(obj())) {
2049     if (java_lang_Class::is_primitive(obj())) {
2050       JVMCIObject type = JVMCIENV-&gt;get_jvmci_primitive_type(java_lang_Class::primitive_type(obj()));
2051       return JVMCIENV-&gt;get_jobject(type);
2052     }
2053     Klass* klass = java_lang_Class::as_Klass(obj());
2054     JVMCIKlassHandle klass_handle(THREAD);
2055     klass_handle = klass;
2056     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);
2057     return JVMCIENV-&gt;get_jobject(type);
2058   }
2059   return NULL;
2060 C2V_END
2061 
2062 
2063 C2V_VMENTRY_NULL(jobject, asString, (JNIEnv* env, jobject, jobject object))
2064   if (object == NULL) {
2065     JVMCI_THROW_0(NullPointerException);
2066   }
2067   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
2068   const char* str = java_lang_String::as_utf8_string(obj());
2069   JVMCIObject result = JVMCIENV-&gt;create_string(str, JVMCI_CHECK_NULL);
2070   return JVMCIENV-&gt;get_jobject(result);
2071 C2V_END
2072 
2073 
2074 C2V_VMENTRY_0(jboolean, equals, (JNIEnv* env, jobject, jobject x, jlong xHandle, jobject y, jlong yHandle))
2075   if (x == NULL || y == NULL) {
2076     JVMCI_THROW_0(NullPointerException);
2077   }
2078   return JVMCIENV-&gt;resolve_handle(xHandle) == JVMCIENV-&gt;resolve_handle(yHandle);
2079 C2V_END
2080 
2081 C2V_VMENTRY_NULL(jobject, getJavaMirror, (JNIEnv* env, jobject, jobject object))
2082   if (object == NULL) {
2083     JVMCI_THROW_0(NullPointerException);
2084   }
2085   JVMCIObject base_object = JVMCIENV-&gt;wrap(object);
2086   Handle mirror;
2087   if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {
2088     mirror = Handle(THREAD, JVMCIENV-&gt;asKlass(base_object)-&gt;java_mirror());
2089   } else if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(base_object)) {
2090     mirror = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_mirror(base_object), JVMCI_CHECK_NULL);
2091   } else {
2092     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2093                          err_msg("Unexpected type: %s", JVMCIENV-&gt;klass_name(base_object)));
2094  }
2095   JVMCIObject result = JVMCIENV-&gt;get_object_constant(mirror());
2096   return JVMCIENV-&gt;get_jobject(result);
2097 C2V_END
2098 
2099 
2100 C2V_VMENTRY_0(jint, getArrayLength, (JNIEnv* env, jobject, jobject x))
2101   if (x == NULL) {
2102     JVMCI_THROW_0(NullPointerException);
2103   }
2104   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2105   if (xobj-&gt;klass()-&gt;is_array_klass()) {
2106     return arrayOop(xobj())-&gt;length();
2107   }
2108   return -1;
2109  C2V_END
2110 
2111 
2112 C2V_VMENTRY_NULL(jobject, readArrayElement, (JNIEnv* env, jobject, jobject x, int index))
2113   if (x == NULL) {
2114     JVMCI_THROW_0(NullPointerException);
2115   }
2116   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_NULL);
2117   if (xobj-&gt;klass()-&gt;is_array_klass()) {
2118     arrayOop array = arrayOop(xobj());
2119     BasicType element_type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();
2120     if (index &lt; 0 || index &gt;= array-&gt;length()) {
2121       return NULL;
2122     }
2123     JVMCIObject result;
2124 
2125     if (element_type == T_OBJECT) {
2126       result = JVMCIENV-&gt;get_object_constant(objArrayOop(xobj())-&gt;obj_at(index));
2127       if (result.is_null()) {
2128         result = JVMCIENV-&gt;get_JavaConstant_NULL_POINTER();
2129       }
2130     } else {
2131       jvalue value;
2132       switch (element_type) {
2133         case T_DOUBLE:        value.d = typeArrayOop(xobj())-&gt;double_at(index);        break;
2134         case T_FLOAT:         value.f = typeArrayOop(xobj())-&gt;float_at(index);         break;
2135         case T_LONG:          value.j = typeArrayOop(xobj())-&gt;long_at(index);          break;
2136         case T_INT:           value.i = typeArrayOop(xobj())-&gt;int_at(index);            break;
2137         case T_SHORT:         value.s = typeArrayOop(xobj())-&gt;short_at(index);          break;
2138         case T_CHAR:          value.c = typeArrayOop(xobj())-&gt;char_at(index);           break;
2139         case T_BYTE:          value.b = typeArrayOop(xobj())-&gt;byte_at(index);           break;
2140         case T_BOOLEAN:       value.z = typeArrayOop(xobj())-&gt;byte_at(index) &amp; 1;       break;
2141         default:              ShouldNotReachHere();
2142       }
2143       result = JVMCIENV-&gt;create_box(element_type, &amp;value, JVMCI_CHECK_NULL);
2144     }
2145     assert(!result.is_null(), "must have a value");
2146     return JVMCIENV-&gt;get_jobject(result);
2147   }
2148   return NULL;;
2149 C2V_END
2150 
2151 
2152 C2V_VMENTRY_0(jint, arrayBaseOffset, (JNIEnv* env, jobject, jobject kind))
2153   if (kind == NULL) {
2154     JVMCI_THROW_0(NullPointerException);
2155   }
2156   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);
2157   return arrayOopDesc::header_size(type) * HeapWordSize;
2158 C2V_END
2159 
2160 C2V_VMENTRY_0(jint, arrayIndexScale, (JNIEnv* env, jobject, jobject kind))
2161   if (kind == NULL) {
2162     JVMCI_THROW_0(NullPointerException);
2163   }
2164   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);
2165   return type2aelembytes(type);
2166 C2V_END
2167 
2168 C2V_VMENTRY_0(jbyte, getByte, (JNIEnv* env, jobject, jobject x, long displacement))
2169   if (x == NULL) {
2170     JVMCI_THROW_0(NullPointerException);
2171   }
2172   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2173   return xobj-&gt;byte_field(displacement);
2174 }
2175 
2176 C2V_VMENTRY_0(jshort, getShort, (JNIEnv* env, jobject, jobject x, long displacement))
2177   if (x == NULL) {
2178     JVMCI_THROW_0(NullPointerException);
2179   }
2180   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2181   return xobj-&gt;short_field(displacement);
2182 }
2183 
2184 C2V_VMENTRY_0(jint, getInt, (JNIEnv* env, jobject, jobject x, long displacement))
2185   if (x == NULL) {
2186     JVMCI_THROW_0(NullPointerException);
2187   }
2188   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2189   return xobj-&gt;int_field(displacement);
2190 }
2191 
2192 C2V_VMENTRY_0(jlong, getLong, (JNIEnv* env, jobject, jobject x, long displacement))
2193   if (x == NULL) {
2194     JVMCI_THROW_0(NullPointerException);
2195   }
2196   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2197   return xobj-&gt;long_field(displacement);
2198 }
2199 
2200 C2V_VMENTRY_NULL(jobject, getObject, (JNIEnv* env, jobject, jobject x, long displacement))
2201   if (x == NULL) {
2202     JVMCI_THROW_0(NullPointerException);
2203   }
2204   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2205   oop res = xobj-&gt;obj_field(displacement);
2206   JVMCIObject result = JVMCIENV-&gt;get_object_constant(res);
2207   return JVMCIENV-&gt;get_jobject(result);
2208 }
2209 
2210 C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))
2211   jobject handle = (jobject)(address)h;
2212   if (handle != NULL) {
2213     JVMCI::destroy_global(handle);
2214   }
2215 }
2216 
2217 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {
2218   if (!UseJVMCINativeLibrary) {
2219     JVMCI_THROW_MSG(UnsupportedOperationException, "JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)");
2220   }
2221 }
2222 
2223 static JavaVM* requireNativeLibraryJavaVM(const char* caller, JVMCI_TRAPS) {
2224   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();
2225   if (javaVM == NULL) {
2226     JVMCI_THROW_MSG_NULL(IllegalStateException, err_msg("Require JVMCI shared library to be initialized in %s", caller));
2227   }
2228   return javaVM;
2229 }
2230 
2231 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))
2232   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2233   requireInHotSpot("registerNativeMethods", JVMCI_CHECK_NULL);
2234   void* shared_library = JVMCIEnv::get_shared_library_handle();
2235   if (shared_library == NULL) {
2236     // Ensure the JVMCI shared library runtime is initialized.
2237     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
2238     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2239     HandleMark hm;
2240     JVMCIRuntime* runtime = JVMCI::compiler_runtime();
2241     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);
2242     if (peerEnv-&gt;has_pending_exception()) {
2243       peerEnv-&gt;describe_pending_exception(true);
2244     }
2245     shared_library = JVMCIEnv::get_shared_library_handle();
2246     if (shared_library == NULL) {
2247       JVMCI_THROW_MSG_0(InternalError, "Error initializing JVMCI runtime");
2248     }
2249   }
2250 
2251   if (mirror == NULL) {
2252     JVMCI_THROW_0(NullPointerException);
2253   }
2254   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2255   if (klass == NULL || !klass-&gt;is_instance_klass()) {
2256     JVMCI_THROW_MSG_0(IllegalArgumentException, "clazz is for primitive type");
2257   }
2258 
2259   InstanceKlass* iklass = InstanceKlass::cast(klass);
2260   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
2261     Method* method = iklass-&gt;methods()-&gt;at(i);
2262     if (method-&gt;is_native()) {
2263 
2264       // Compute argument size
2265       int args_size = 1                             // JNIEnv
2266                     + (method-&gt;is_static() ? 1 : 0) // class for static methods
2267                     + method-&gt;size_of_parameters(); // actual parameters
2268 
2269       // 1) Try JNI short style
2270       stringStream st;
2271       char* pure_name = NativeLookup::pure_jni_name(method);
2272       os::print_jni_name_prefix_on(&amp;st, args_size);
2273       st.print_raw(pure_name);
2274       os::print_jni_name_suffix_on(&amp;st, args_size);
2275       char* jni_name = st.as_string();
2276 
2277       address entry = (address) os::dll_lookup(shared_library, jni_name);
2278       if (entry == NULL) {
2279         // 2) Try JNI long style
2280         st.reset();
2281         char* long_name = NativeLookup::long_jni_name(method);
2282         os::print_jni_name_prefix_on(&amp;st, args_size);
2283         st.print_raw(pure_name);
2284         st.print_raw(long_name);
2285         os::print_jni_name_suffix_on(&amp;st, args_size);
2286         char* jni_long_name = st.as_string();
2287         entry = (address) os::dll_lookup(shared_library, jni_long_name);
2288         if (entry == NULL) {
2289           JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg("%s [neither %s nor %s exist in %s]",
2290               method-&gt;name_and_sig_as_C_string(),
2291               jni_name, jni_long_name, JVMCIEnv::get_shared_library_path()));
2292         }
2293       }
2294 
2295       if (method-&gt;has_native_function() &amp;&amp; entry != method-&gt;native_function()) {
2296         JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg("%s [cannot re-link from " PTR_FORMAT " to " PTR_FORMAT "]",
2297             method-&gt;name_and_sig_as_C_string(), p2i(method-&gt;native_function()), p2i(entry)));
2298       }
2299       method-&gt;set_native_function(entry, Method::native_bind_event_is_interesting);
2300       if (PrintJNIResolving) {
2301         tty-&gt;print_cr("[Dynamic-linking native method %s.%s ... JNI]",
2302           method-&gt;method_holder()-&gt;external_name(),
2303           method-&gt;name()-&gt;as_C_string());
2304       }
2305     }
2306   }
2307 
2308   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();
2309   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(4, JVMCI_CHECK_NULL);
2310   JVMCIENV-&gt;put_long_at(result, 0, (jlong) (address) javaVM);
2311   JVMCIENV-&gt;put_long_at(result, 1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);
2312   JVMCIENV-&gt;put_long_at(result, 2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);
2313   JVMCIENV-&gt;put_long_at(result, 3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);
2314   return (jlongArray) JVMCIENV-&gt;get_jobject(result);
2315 }
2316 
2317 C2V_VMENTRY_PREFIX(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject c2vm))
2318   if (base_thread == NULL) {
2319     // Called from unattached JVMCI shared library thread
2320     return false;
2321   }
2322   JVMCITraceMark jtm("isCurrentThreadAttached");
2323   assert(base_thread-&gt;is_Java_thread(), "just checking");
2324   JavaThread* thread = (JavaThread*) base_thread;
2325   if (thread-&gt;jni_environment() == env) {
2326     C2V_BLOCK(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject))
2327     requireJVMCINativeLibrary(JVMCI_CHECK_0);
2328     JavaVM* javaVM = requireNativeLibraryJavaVM("isCurrentThreadAttached", JVMCI_CHECK_0);
2329     JNIEnv* peerEnv;
2330     return javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK;
2331   }
2332   return true;
2333 C2V_END
2334 
2335 C2V_VMENTRY_PREFIX(jlong, getCurrentJavaThread, (JNIEnv* env, jobject c2vm))
2336   if (base_thread == NULL) {
2337     // Called from unattached JVMCI shared library thread
2338     return 0L;
2339   }
2340   JVMCITraceMark jtm("getCurrentJavaThread");
2341   assert(base_thread-&gt;is_Java_thread(), "just checking");
2342   return (jlong) p2i(base_thread);
2343 C2V_END
2344 
2345 C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean as_daemon))
2346   if (base_thread == NULL) {
2347     // Called from unattached JVMCI shared library thread
2348     extern struct JavaVM_ main_vm;
2349     JNIEnv* hotspotEnv;
2350     jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**)&amp;hotspotEnv, NULL) :
2351                            main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
2352     if (res != JNI_OK) {
2353       JNI_THROW_("attachCurrentThread", InternalError, err_msg("Trying to attach thread returned %d", res), false);
2354     }
2355     return true;
2356   }
2357   JVMCITraceMark jtm("attachCurrentThread");
2358   assert(base_thread-&gt;is_Java_thread(), "just checking");\
2359   JavaThread* thread = (JavaThread*) base_thread;
2360   if (thread-&gt;jni_environment() == env) {
2361     // Called from HotSpot
2362     C2V_BLOCK(jboolean, attachCurrentThread, (JNIEnv* env, jobject, jboolean))
2363     requireJVMCINativeLibrary(JVMCI_CHECK_0);
2364     JavaVM* javaVM = requireNativeLibraryJavaVM("attachCurrentThread", JVMCI_CHECK_0);
2365     JavaVMAttachArgs attach_args;
2366     attach_args.version = JNI_VERSION_1_2;
2367     attach_args.name = thread-&gt;name();
2368     attach_args.group = NULL;
2369     JNIEnv* peerEnv;
2370     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK) {
2371       return false;
2372     }
2373     jint res = as_daemon ? javaVM-&gt;AttachCurrentThreadAsDaemon((void**)&amp;peerEnv, &amp;attach_args) :
2374                            javaVM-&gt;AttachCurrentThread((void**)&amp;peerEnv, &amp;attach_args);
2375     if (res == JNI_OK) {
2376       guarantee(peerEnv != NULL, "must be");
2377       return true;
2378     }
2379     JVMCI_THROW_MSG_0(InternalError, err_msg("Error %d while attaching %s", res, attach_args.name));
2380   }
2381   // Called from JVMCI shared library
2382   return false;
2383 C2V_END
2384 
2385 C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))
2386   if (base_thread == NULL) {
2387     // Called from unattached JVMCI shared library thread
2388     JNI_THROW("detachCurrentThread", IllegalStateException, err_msg("Cannot detach non-attached thread"));
2389   }
2390   JVMCITraceMark jtm("detachCurrentThread");
2391   assert(base_thread-&gt;is_Java_thread(), "just checking");\
2392   JavaThread* thread = (JavaThread*) base_thread;
2393   if (thread-&gt;jni_environment() == env) {
2394     // Called from HotSpot
2395     C2V_BLOCK(void, detachCurrentThread, (JNIEnv* env, jobject))
2396     requireJVMCINativeLibrary(JVMCI_CHECK);
2397     requireInHotSpot("detachCurrentThread", JVMCI_CHECK);
2398     JavaVM* javaVM = requireNativeLibraryJavaVM("detachCurrentThread", JVMCI_CHECK);
2399     JNIEnv* peerEnv;
2400     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) != JNI_OK) {
2401       JVMCI_THROW_MSG(IllegalStateException, err_msg("Cannot detach non-attached thread: %s", thread-&gt;name()));
2402     }
2403     jint res = javaVM-&gt;DetachCurrentThread();
2404     if (res != JNI_OK) {
2405       JVMCI_THROW_MSG(InternalError, err_msg("Error %d while attaching %s", res, thread-&gt;name()));
2406     }
2407   } else {
2408     // Called from attached JVMCI shared library thread
2409     extern struct JavaVM_ main_vm;
2410     jint res = main_vm.DetachCurrentThread();
2411     if (res != JNI_OK) {
2412       JNI_THROW("detachCurrentThread", InternalError, err_msg("Cannot detach non-attached thread"));
2413     }
2414   }
2415 C2V_END
2416 
2417 C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))
2418   requireJVMCINativeLibrary(JVMCI_CHECK_0);
2419   if (obj_handle == NULL) {
2420     return 0L;
2421   }
2422   JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV-&gt;is_hotspot(), __FILE__, __LINE__);
2423   JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2424   JVMCIEnv* thisEnv = JVMCIENV;
2425 
2426   JVMCIObject obj = thisEnv-&gt;wrap(obj_handle);
2427   JVMCIObject result;
2428   if (thisEnv-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {
2429     Method* method = thisEnv-&gt;asMethod(obj);
2430     result = peerEnv-&gt;get_jvmci_method(method, JVMCI_CHECK_0);
2431   } else if (thisEnv-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {
2432     Klass* klass = thisEnv-&gt;asKlass(obj);
2433     JVMCIKlassHandle klass_handle(THREAD);
2434     klass_handle = klass;
2435     result = peerEnv-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_0);
2436   } else if (thisEnv-&gt;isa_HotSpotResolvedPrimitiveType(obj)) {
2437     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(obj), JVMCI_CHECK_0);
2438     result = peerEnv-&gt;get_jvmci_primitive_type(type);
2439   } else if (thisEnv-&gt;isa_IndirectHotSpotObjectConstantImpl(obj) ||
2440              thisEnv-&gt;isa_DirectHotSpotObjectConstantImpl(obj)) {
2441     Handle constant = thisEnv-&gt;asConstant(obj, JVMCI_CHECK_0);
2442     result = peerEnv-&gt;get_object_constant(constant());
2443   } else if (thisEnv-&gt;isa_HotSpotNmethod(obj)) {
2444     nmethodLocker locker;
2445     nmethod* nm = JVMCIENV-&gt;get_nmethod(obj, locker);
2446     if (nm != NULL) {
2447       JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
2448       if (data != NULL) {
2449         if (peerEnv-&gt;is_hotspot()) {
2450           // Only the mirror in the HotSpot heap is accessible
2451           // through JVMCINMethodData
2452           oop nmethod_mirror = data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ true);
2453           if (nmethod_mirror != NULL) {
2454             result = HotSpotJVMCI::wrap(nmethod_mirror);
2455           }
2456         }
2457       }
2458     }
2459     if (result.is_null()) {
2460       JVMCIObject methodObject = thisEnv-&gt;get_HotSpotNmethod_method(obj);
2461       methodHandle mh = thisEnv-&gt;asMethod(methodObject);
2462       jboolean isDefault = thisEnv-&gt;get_HotSpotNmethod_isDefault(obj);
2463       jlong compileIdSnapshot = thisEnv-&gt;get_HotSpotNmethod_compileIdSnapshot(obj);
2464       JVMCIObject name_string = thisEnv-&gt;get_InstalledCode_name(obj);
2465       const char* cstring = name_string.is_null() ? NULL : thisEnv-&gt;as_utf8_string(name_string);
2466       // Create a new HotSpotNmethod instance in the peer runtime
2467       result = peerEnv-&gt;new_HotSpotNmethod(mh(), cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);
2468       if (nm == NULL) {
2469         // nmethod must have been unloaded
2470       } else {
2471         // Link the new HotSpotNmethod to the nmethod
2472         peerEnv-&gt;initialize_installed_code(result, nm, JVMCI_CHECK_0);
2473         // Only HotSpotNmethod instances in the HotSpot heap are tracked directly by the runtime.
2474         if (peerEnv-&gt;is_hotspot()) {
2475           JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
2476           if (data == NULL) {
2477             JVMCI_THROW_MSG_0(IllegalArgumentException, "Cannot set HotSpotNmethod mirror for default nmethod");
2478           }
2479           if (data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) != NULL) {
2480             JVMCI_THROW_MSG_0(IllegalArgumentException, "Cannot overwrite existing HotSpotNmethod mirror for nmethod");
2481           }
2482           oop nmethod_mirror = HotSpotJVMCI::resolve(result);
2483           data-&gt;set_nmethod_mirror(nm, nmethod_mirror);
2484         }
2485       }
2486     }
2487   } else {
2488     JVMCI_THROW_MSG_0(IllegalArgumentException,
2489                 err_msg("Cannot translate object of type: %s", thisEnv-&gt;klass_name(obj)));
2490   }
2491   return (jlong) peerEnv-&gt;make_global(result).as_jobject();
2492 }
2493 
2494 C2V_VMENTRY_NULL(jobject, unhand, (JNIEnv* env, jobject, jlong obj_handle))
2495   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2496   if (obj_handle == 0L) {
2497     return NULL;
2498   }
2499   jobject global_handle = (jobject) obj_handle;
2500   JVMCIObject global_handle_obj = JVMCIENV-&gt;wrap((jobject) obj_handle);
2501   jobject result = JVMCIENV-&gt;make_local(global_handle_obj).as_jobject();
2502 
2503   JVMCIENV-&gt;destroy_global(global_handle_obj);
2504   return result;
2505 }
2506 
2507 C2V_VMENTRY(void, updateHotSpotNmethod, (JNIEnv* env, jobject, jobject code_handle))
2508   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);
2509   // Execute this operation for the side effect of updating the InstalledCode state
2510   nmethodLocker locker;
2511   JVMCIENV-&gt;get_nmethod(code, locker);
2512 }
2513 
2514 C2V_VMENTRY_NULL(jbyteArray, getCode, (JNIEnv* env, jobject, jobject code_handle))
2515   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);
2516   nmethodLocker locker;
2517   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(code, locker);
2518   if (cb == NULL) {
2519     return NULL;
2520   }
2521   int code_size = cb-&gt;code_size();
2522   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);
2523   JVMCIENV-&gt;copy_bytes_from((jbyte*) cb-&gt;code_begin(), result, 0, code_size);
2524   return JVMCIENV-&gt;get_jbyteArray(result);
2525 }
2526 
2527 C2V_VMENTRY_NULL(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))
2528   requireInHotSpot("asReflectionExecutable", JVMCI_CHECK_NULL);
2529   methodHandle m = JVMCIENV-&gt;asMethod(jvmci_method);
2530   oop executable;
2531   if (m-&gt;is_initializer()) {
2532     if (m-&gt;is_static_initializer()) {
2533       JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2534           "Cannot create java.lang.reflect.Method for class initializer");
2535     }
2536     executable = Reflection::new_constructor(m, CHECK_NULL);
2537   } else {
2538     executable = Reflection::new_method(m, false, CHECK_NULL);
2539   }
2540   return JNIHandles::make_local(THREAD, executable);
2541 }
2542 
2543 C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))
2544   requireInHotSpot("asReflectionField", JVMCI_CHECK_NULL);
2545   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
2546   if (!klass-&gt;is_instance_klass()) {
2547     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2548         err_msg("Expected non-primitive type, got %s", klass-&gt;external_name()));
2549   }
2550   InstanceKlass* iklass = InstanceKlass::cast(klass);
2551   Array&lt;u2&gt;* fields = iklass-&gt;fields();
2552   if (index &lt; 0 ||index &gt; fields-&gt;length()) {
2553     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2554         err_msg("Field index %d out of bounds for %s", index, klass-&gt;external_name()));
2555   }
2556   fieldDescriptor fd(iklass, index);
2557   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2558   return JNIHandles::make_local(env, reflected);
2559 }
2560 
2561 C2V_VMENTRY_NULL(jobjectArray, getFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address, jobjectArray current))
2562   FailedSpeculation* head = *((FailedSpeculation**)(address) failed_speculations_address);
2563   int result_length = 0;
2564   for (FailedSpeculation* fs = head; fs != NULL; fs = fs-&gt;next()) {
2565     result_length++;
2566   }
2567   int current_length = 0;
2568   JVMCIObjectArray current_array = NULL;
2569   if (current != NULL) {
2570     current_array = JVMCIENV-&gt;wrap(current);
2571     current_length = JVMCIENV-&gt;get_length(current_array);
2572     if (current_length == result_length) {
2573       // No new failures
2574       return current;
2575     }
2576   }
2577   JVMCIObjectArray result = JVMCIENV-&gt;new_byte_array_array(result_length, JVMCI_CHECK_NULL);
2578   int result_index = 0;
2579   for (FailedSpeculation* fs = head; result_index &lt; result_length; fs = fs-&gt;next()) {
2580     assert(fs != NULL, "npe");
2581     JVMCIPrimitiveArray entry;
2582     if (result_index &lt; current_length) {
2583       entry = (JVMCIPrimitiveArray) JVMCIENV-&gt;get_object_at(current_array, result_index);
2584     } else {
2585       entry = JVMCIENV-&gt;new_byteArray(fs-&gt;data_len(), JVMCI_CHECK_NULL);
2586       JVMCIENV-&gt;copy_bytes_from((jbyte*) fs-&gt;data(), entry, 0, fs-&gt;data_len());
2587     }
2588     JVMCIENV-&gt;put_object_at(result, result_index++, entry);
2589   }
2590   return JVMCIENV-&gt;get_jobjectArray(result);
2591 }
2592 
2593 C2V_VMENTRY_0(jlong, getFailedSpeculationsAddress, (JNIEnv* env, jobject, jobject jvmci_method))
2594   methodHandle method = JVMCIENV-&gt;asMethod(jvmci_method);
2595   MethodData* method_data = method-&gt;method_data();
2596   if (method_data == NULL) {
2597     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
2598     method_data = MethodData::allocate(loader_data, method, CHECK_0);
2599     method-&gt;set_method_data(method_data);
2600   }
2601   return (jlong) method_data-&gt;get_failed_speculations_address();
2602 }
2603 
2604 C2V_VMENTRY(void, releaseFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address))
2605   FailedSpeculation::free_failed_speculations((FailedSpeculation**)(address) failed_speculations_address);
2606 }
2607 
2608 C2V_VMENTRY_0(jboolean, addFailedSpeculation, (JNIEnv* env, jobject, jlong failed_speculations_address, jbyteArray speculation_obj))
2609   JVMCIPrimitiveArray speculation_handle = JVMCIENV-&gt;wrap(speculation_obj);
2610   int speculation_len = JVMCIENV-&gt;get_length(speculation_handle);
2611   char* speculation = NEW_RESOURCE_ARRAY(char, speculation_len);
2612   JVMCIENV-&gt;copy_bytes_to(speculation_handle, (jbyte*) speculation, 0, speculation_len);
2613   return FailedSpeculation::add_failed_speculation(NULL, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);
2614 }
2615 
2616 C2V_VMENTRY(void, callSystemExit, (JNIEnv* env, jobject, jint status))
2617   JavaValue result(T_VOID);
2618   JavaCallArguments jargs(1);
2619   jargs.push_int(status);
2620   JavaCalls::call_static(&amp;result,
2621                        SystemDictionary::System_klass(),
2622                        vmSymbols::exit_method_name(),
2623                        vmSymbols::int_void_signature(),
2624                        &amp;jargs,
2625                        CHECK);
2626 }
2627 
2628 #define CC (char*)  /*cast a literal from (const char*)*/
2629 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
2630 
2631 #define STRING                  "Ljava/lang/String;"
2632 #define OBJECT                  "Ljava/lang/Object;"
2633 #define CLASS                   "Ljava/lang/Class;"
2634 #define OBJECTCONSTANT          "Ljdk/vm/ci/hotspot/HotSpotObjectConstantImpl;"
2635 #define HANDLECONSTANT          "Ljdk/vm/ci/hotspot/IndirectHotSpotObjectConstantImpl;"
2636 #define EXECUTABLE              "Ljava/lang/reflect/Executable;"
2637 #define STACK_TRACE_ELEMENT     "Ljava/lang/StackTraceElement;"
2638 #define INSTALLED_CODE          "Ljdk/vm/ci/code/InstalledCode;"
2639 #define TARGET_DESCRIPTION      "Ljdk/vm/ci/code/TargetDescription;"
2640 #define BYTECODE_FRAME          "Ljdk/vm/ci/code/BytecodeFrame;"
2641 #define JAVACONSTANT            "Ljdk/vm/ci/meta/JavaConstant;"
2642 #define INSPECTED_FRAME_VISITOR "Ljdk/vm/ci/code/stack/InspectedFrameVisitor;"
2643 #define RESOLVED_METHOD         "Ljdk/vm/ci/meta/ResolvedJavaMethod;"
2644 #define HS_RESOLVED_METHOD      "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;"
2645 #define HS_RESOLVED_KLASS       "Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;"
2646 #define HS_RESOLVED_TYPE        "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaType;"
2647 #define HS_RESOLVED_FIELD       "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaField;"
2648 #define HS_INSTALLED_CODE       "Ljdk/vm/ci/hotspot/HotSpotInstalledCode;"
2649 #define HS_NMETHOD              "Ljdk/vm/ci/hotspot/HotSpotNmethod;"
2650 #define HS_CONSTANT_POOL        "Ljdk/vm/ci/hotspot/HotSpotConstantPool;"
2651 #define HS_COMPILED_CODE        "Ljdk/vm/ci/hotspot/HotSpotCompiledCode;"
2652 #define HS_CONFIG               "Ljdk/vm/ci/hotspot/HotSpotVMConfig;"
2653 #define HS_METADATA             "Ljdk/vm/ci/hotspot/HotSpotMetaData;"
2654 #define HS_STACK_FRAME_REF      "Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;"
2655 #define HS_SPECULATION_LOG      "Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;"
2656 #define METASPACE_OBJECT        "Ljdk/vm/ci/hotspot/MetaspaceObject;"
2657 #define REFLECTION_EXECUTABLE   "Ljava/lang/reflect/Executable;"
2658 #define REFLECTION_FIELD        "Ljava/lang/reflect/Field;"
2659 #define METASPACE_METHOD_DATA   "J"
2660 
2661 JNINativeMethod CompilerToVM::methods[] = {
2662   {CC "getBytecode",                                  CC "(" HS_RESOLVED_METHOD ")[B",                                                      FN_PTR(getBytecode)},
2663   {CC "getExceptionTableStart",                       CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getExceptionTableStart)},
2664   {CC "getExceptionTableLength",                      CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getExceptionTableLength)},
2665   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
2666   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
2667   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
2668   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
2669   {CC "setNotInlinableOrCompilable",                  CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(setNotInlinableOrCompilable)},
2670   {CC "isCompilable",                                 CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(isCompilable)},
2671   {CC "hasNeverInlineDirective",                      CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(hasNeverInlineDirective)},
2672   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
2673   {CC "lookupType",                                   CC "(" STRING HS_RESOLVED_KLASS "Z)" HS_RESOLVED_TYPE,                                FN_PTR(lookupType)},
2674   {CC "getArrayType",                                 CC "(" HS_RESOLVED_TYPE ")" HS_RESOLVED_KLASS,                                        FN_PTR(getArrayType)},
2675   {CC "lookupClass",                                  CC "(" CLASS ")" HS_RESOLVED_TYPE,                                                    FN_PTR(lookupClass)},
2676   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
2677   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
2678   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
2679   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
2680   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
2681   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECTCONSTANT,                                          FN_PTR(lookupAppendixInPool)},
2682   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
2683   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
2684   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECTCONSTANT,                                          FN_PTR(resolvePossiblyCachedConstantInPool)},
2685   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
2686   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[I)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
2687   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
2688   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
2689   {CC "isResolvedInvokeHandleInPool",                 CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(isResolvedInvokeHandleInPool)},
2690   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
2691   {CC "getSignaturePolymorphicHolders",               CC "()[" STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
2692   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
2693   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
2694   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
2695   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
2696   {CC "asResolvedJavaMethod",                         CC "(" EXECUTABLE ")" HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
2697   {CC "getResolvedJavaMethod",                        CC "(" OBJECTCONSTANT "J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
2698   {CC "getConstantPool",                              CC "(" METASPACE_OBJECT ")" HS_CONSTANT_POOL,                                         FN_PTR(getConstantPool)},
2699   {CC "getResolvedJavaType0",                         CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType0)},
2700   {CC "readConfiguration",                            CC "()[" OBJECT,                                                                      FN_PTR(readConfiguration)},
2701   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE "J[B)I",                    FN_PTR(installCode)},
2702   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
2703   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
2704   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
2705   {CC "executeHotSpotNmethod",                        CC "([" OBJECT HS_NMETHOD ")" OBJECT,                                                 FN_PTR(executeHotSpotNmethod)},
2706   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
2707   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
2708   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
2709   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
2710   {CC "invalidateHotSpotNmethod",                     CC "(" HS_NMETHOD ")V",                                                               FN_PTR(invalidateHotSpotNmethod)},
2711   {CC "readUncompressedOop",                          CC "(J)" OBJECTCONSTANT,                                                              FN_PTR(readUncompressedOop)},
2712   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
2713   {CC "getCountersSize",                              CC "()I",                                                                             FN_PTR(getCountersSize)},
2714   {CC "setCountersSize",                              CC "(I)Z",                                                                            FN_PTR(setCountersSize)},
2715   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
2716   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
2717   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
2718   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
2719   {CC "iterateFrames",                                CC "([" RESOLVED_METHOD "[" RESOLVED_METHOD "I" INSPECTED_FRAME_VISITOR ")" OBJECT,   FN_PTR(iterateFrames)},
2720   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
2721   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
2722   {CC "writeDebugOutput",                             CC "([BIIZZ)I",                                                                       FN_PTR(writeDebugOutput)},
2723   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
2724   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
2725   {CC "getFingerprint",                               CC "(J)J",                                                                            FN_PTR(getFingerprint)},
2726   {CC "getHostClass",                                 CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
2727   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
2728   {CC "compileToBytecode",                            CC "(" OBJECTCONSTANT ")V",                                                           FN_PTR(compileToBytecode)},
2729   {CC "getFlagValue",                                 CC "(" STRING ")" OBJECT,                                                             FN_PTR(getFlagValue)},
2730   {CC "getObjectAtAddress",                           CC "(J)" OBJECT,                                                                      FN_PTR(getObjectAtAddress)},
2731   {CC "getInterfaces",                                CC "(" HS_RESOLVED_KLASS ")[" HS_RESOLVED_KLASS,                                      FN_PTR(getInterfaces)},
2732   {CC "getComponentType",                             CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_TYPE,                                        FN_PTR(getComponentType)},
2733   {CC "ensureInitialized",                            CC "(" HS_RESOLVED_KLASS ")V",                                                        FN_PTR(ensureInitialized)},
2734   {CC "getIdentityHashCode",                          CC "(" OBJECTCONSTANT ")I",                                                           FN_PTR(getIdentityHashCode)},
2735   {CC "isInternedString",                             CC "(" OBJECTCONSTANT ")Z",                                                           FN_PTR(isInternedString)},
2736   {CC "unboxPrimitive",                               CC "(" OBJECTCONSTANT ")" OBJECT,                                                     FN_PTR(unboxPrimitive)},
2737   {CC "boxPrimitive",                                 CC "(" OBJECT ")" OBJECTCONSTANT,                                                     FN_PTR(boxPrimitive)},
2738   {CC "getDeclaredConstructors",                      CC "(" HS_RESOLVED_KLASS ")[" RESOLVED_METHOD,                                        FN_PTR(getDeclaredConstructors)},
2739   {CC "getDeclaredMethods",                           CC "(" HS_RESOLVED_KLASS ")[" RESOLVED_METHOD,                                        FN_PTR(getDeclaredMethods)},
2740   {CC "readFieldValue",                               CC "(" HS_RESOLVED_KLASS HS_RESOLVED_FIELD "Z)" JAVACONSTANT,                         FN_PTR(readFieldValue)},
2741   {CC "readFieldValue",                               CC "(" OBJECTCONSTANT HS_RESOLVED_FIELD "Z)" JAVACONSTANT,                            FN_PTR(readFieldValue)},
2742   {CC "isInstance",                                   CC "(" HS_RESOLVED_KLASS OBJECTCONSTANT ")Z",                                         FN_PTR(isInstance)},
2743   {CC "isAssignableFrom",                             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_KLASS ")Z",                                      FN_PTR(isAssignableFrom)},
2744   {CC "isTrustedForIntrinsics",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(isTrustedForIntrinsics)},
2745   {CC "asJavaType",                                   CC "(" OBJECTCONSTANT ")" HS_RESOLVED_TYPE,                                           FN_PTR(asJavaType)},
2746   {CC "asString",                                     CC "(" OBJECTCONSTANT ")" STRING,                                                     FN_PTR(asString)},
2747   {CC "equals",                                       CC "(" OBJECTCONSTANT "J" OBJECTCONSTANT "J)Z",                                       FN_PTR(equals)},
2748   {CC "getJavaMirror",                                CC "(" HS_RESOLVED_TYPE ")" OBJECTCONSTANT,                                           FN_PTR(getJavaMirror)},
2749   {CC "getArrayLength",                               CC "(" OBJECTCONSTANT ")I",                                                           FN_PTR(getArrayLength)},
2750   {CC "readArrayElement",                             CC "(" OBJECTCONSTANT "I)Ljava/lang/Object;",                                         FN_PTR(readArrayElement)},
2751   {CC "arrayBaseOffset",                              CC "(Ljdk/vm/ci/meta/JavaKind;)I",                                                    FN_PTR(arrayBaseOffset)},
2752   {CC "arrayIndexScale",                              CC "(Ljdk/vm/ci/meta/JavaKind;)I",                                                    FN_PTR(arrayIndexScale)},
2753   {CC "getByte",                                      CC "(" OBJECTCONSTANT "J)B",                                                          FN_PTR(getByte)},
2754   {CC "getShort",                                     CC "(" OBJECTCONSTANT "J)S",                                                          FN_PTR(getShort)},
2755   {CC "getInt",                                       CC "(" OBJECTCONSTANT "J)I",                                                          FN_PTR(getInt)},
2756   {CC "getLong",                                      CC "(" OBJECTCONSTANT "J)J",                                                          FN_PTR(getLong)},
2757   {CC "getObject",                                    CC "(" OBJECTCONSTANT "J)" OBJECTCONSTANT,                                            FN_PTR(getObject)},
2758   {CC "deleteGlobalHandle",                           CC "(J)V",                                                                            FN_PTR(deleteGlobalHandle)},
2759   {CC "registerNativeMethods",                        CC "(" CLASS ")[J",                                                                   FN_PTR(registerNativeMethods)},
2760   {CC "isCurrentThreadAttached",                      CC "()Z",                                                                             FN_PTR(isCurrentThreadAttached)},
2761   {CC "getCurrentJavaThread",                         CC "()J",                                                                             FN_PTR(getCurrentJavaThread)},
2762   {CC "attachCurrentThread",                          CC "(Z)Z",                                                                            FN_PTR(attachCurrentThread)},
2763   {CC "detachCurrentThread",                          CC "()V",                                                                             FN_PTR(detachCurrentThread)},
2764   {CC "translate",                                    CC "(" OBJECT ")J",                                                                   FN_PTR(translate)},
2765   {CC "unhand",                                       CC "(J)" OBJECT,                                                                      FN_PTR(unhand)},
2766   {CC "updateHotSpotNmethod",                         CC "(" HS_NMETHOD ")V",                                                               FN_PTR(updateHotSpotNmethod)},
2767   {CC "getCode",                                      CC "(" HS_INSTALLED_CODE ")[B",                                                       FN_PTR(getCode)},
2768   {CC "asReflectionExecutable",                       CC "(" HS_RESOLVED_METHOD ")" REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},
2769   {CC "asReflectionField",                            CC "(" HS_RESOLVED_KLASS "I)" REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},
2770   {CC "getFailedSpeculations",                        CC "(J[[B)[[B",                                                                       FN_PTR(getFailedSpeculations)},
2771   {CC "getFailedSpeculationsAddress",                 CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getFailedSpeculationsAddress)},
2772   {CC "releaseFailedSpeculations",                    CC "(J)V",                                                                            FN_PTR(releaseFailedSpeculations)},
2773   {CC "addFailedSpeculation",                         CC "(J[B)Z",                                                                          FN_PTR(addFailedSpeculation)},
2774   {CC "callSystemExit",                               CC "(I)V",                                                                            FN_PTR(callSystemExit)},
2775 };
2776 
2777 int CompilerToVM::methods_count() {
2778   return sizeof(methods) / sizeof(JNINativeMethod);
2779 }
</pre></body></html>
