<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New graal/com.oracle.graal.hotspot/src/com/oracle/graal/hotspot/HotSpotVMConfig.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package com.oracle.graal.hotspot;
  24 
  25 import static com.oracle.graal.graph.UnsafeAccess.*;
  26 
  27 import java.lang.reflect.*;
  28 import java.util.*;
  29 
  30 import com.oracle.graal.graph.*;
  31 import com.oracle.graal.hotspot.bridge.*;
  32 import com.oracle.graal.hotspot.meta.*;
  33 
  34 /**
  35  * Used to access native configuration details.
  36  *
  37  * All non-static, public fields in this class are so that they can be compiled as constants.
  38  */
  39 public class HotSpotVMConfig extends CompilerObject {
  40 
  41     private static final long serialVersionUID = -4744897993263044184L;
  42 
  43     /**
  44      * Determines if the current architecture is included in a given architecture set specification.
  45      *
  46      * @param currentArch
  47      * @param archsSpecification specifies a set of architectures. A zero length value implies all
  48      *            architectures.
  49      */
  50     private static boolean isRequired(String currentArch, String[] archsSpecification) {
  51         if (archsSpecification.length == 0) {
  52             return true;
  53         }
  54         for (String arch : archsSpecification) {
  55             if (arch.equals(currentArch)) {
  56                 return true;
  57             }
  58         }
  59         return false;
  60     }
  61 
  62     /**
  63      * Maximum allowed size of allocated area for a frame.
  64      */
  65     public final int maxFrameSize = 16 * 1024;
  66 
  67     HotSpotVMConfig(CompilerToVM compilerToVm) {
  68         /** These fields are set in {@link CompilerToVM#initializeConfiguration}. */
  69         gHotSpotVMStructs = 0;
  70         gHotSpotVMTypes = 0;
  71         gHotSpotVMIntConstants = 0;
  72         gHotSpotVMLongConstants = 0;
  73 
  74         compilerToVm.initializeConfiguration(this);
  75 
  76         assert gHotSpotVMStructs != 0;
  77         assert gHotSpotVMTypes != 0;
  78         assert gHotSpotVMIntConstants != 0;
  79         assert gHotSpotVMLongConstants != 0;
  80 
  81         // Fill the VM fields hash map.
  82         HashMap&lt;String, VMFields.Field&gt; vmFields = new HashMap&lt;&gt;();
  83         for (VMFields.Field e : new VMFields(gHotSpotVMStructs)) {
  84             vmFields.put(e.getName(), e);
  85         }
  86 
  87         // Fill the VM types hash map.
  88         HashMap&lt;String, VMTypes.Type&gt; vmTypes = new HashMap&lt;&gt;();
  89         for (VMTypes.Type e : new VMTypes(gHotSpotVMTypes)) {
  90             vmTypes.put(e.getTypeName(), e);
  91         }
  92 
  93         // Fill the VM constants hash map.
  94         HashMap&lt;String, AbstractConstant&gt; vmConstants = new HashMap&lt;&gt;();
  95         for (AbstractConstant e : new VMIntConstants(gHotSpotVMIntConstants)) {
  96             vmConstants.put(e.getName(), e);
  97         }
  98         for (AbstractConstant e : new VMLongConstants(gHotSpotVMLongConstants)) {
  99             vmConstants.put(e.getName(), e);
 100         }
 101 
 102         // Fill the flags hash map.
 103         HashMap&lt;String, Flags.Flag&gt; flags = new HashMap&lt;&gt;();
 104         for (Flags.Flag e : new Flags(vmFields, vmTypes)) {
 105             flags.put(e.getName(), e);
 106         }
 107 
 108         String currentArch = getHostArchitectureName();
 109 
 110         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
 111             if (f.isAnnotationPresent(HotSpotVMField.class)) {
 112                 HotSpotVMField annotation = f.getAnnotation(HotSpotVMField.class);
 113                 String name = annotation.name();
 114                 String type = annotation.type();
 115                 VMFields.Field entry = vmFields.get(name);
 116                 if (entry == null) {
 117                     if (annotation.optional() || !isRequired(currentArch, annotation.archs())) {
 118                         continue;
 119                     }
 120                     throw new IllegalArgumentException("field not found: " + name);
 121                 }
 122 
 123                 // Make sure the native type is still the type we expect.
 124                 if (!type.equals("")) {
 125                     if (!type.equals(entry.getTypeString())) {
 126                         throw new IllegalArgumentException("compiler expects type " + type + " but field " + name + " is of type " + entry.getTypeString());
 127                     }
 128                 }
 129 
 130                 switch (annotation.get()) {
 131                     case OFFSET:
 132                         setField(f, entry.getOffset());
 133                         break;
 134                     case ADDRESS:
 135                         setField(f, entry.getAddress());
 136                         break;
 137                     case VALUE:
 138                         setField(f, entry.getValue());
 139                         break;
 140                     default:
 141                         throw GraalInternalError.shouldNotReachHere("unknown kind " + annotation.get());
 142                 }
 143             } else if (f.isAnnotationPresent(HotSpotVMType.class)) {
 144                 HotSpotVMType annotation = f.getAnnotation(HotSpotVMType.class);
 145                 String name = annotation.name();
 146                 VMTypes.Type entry = vmTypes.get(name);
 147                 if (entry == null) {
 148                     throw new IllegalArgumentException("type not found: " + name);
 149                 }
 150                 switch (annotation.get()) {
 151                     case SIZE:
 152                         setField(f, entry.getSize());
 153                         break;
 154                     default:
 155                         throw GraalInternalError.shouldNotReachHere("unknown kind " + annotation.get());
 156                 }
 157             } else if (f.isAnnotationPresent(HotSpotVMConstant.class)) {
 158                 HotSpotVMConstant annotation = f.getAnnotation(HotSpotVMConstant.class);
 159                 String name = annotation.name();
 160                 AbstractConstant entry = vmConstants.get(name);
 161                 if (entry == null) {
 162                     if (!isRequired(currentArch, annotation.archs())) {
 163                         continue;
 164                     }
 165                     throw new IllegalArgumentException("constant not found: " + name);
 166                 }
 167                 setField(f, entry.getValue());
 168             } else if (f.isAnnotationPresent(HotSpotVMFlag.class)) {
 169                 HotSpotVMFlag annotation = f.getAnnotation(HotSpotVMFlag.class);
 170                 String name = annotation.name();
 171                 Flags.Flag entry = flags.get(name);
 172                 if (entry == null) {
 173                     if (!isRequired(currentArch, annotation.archs())) {
 174                         continue;
 175                     }
 176                     throw new IllegalArgumentException("flag not found: " + name);
 177 
 178                 }
 179                 setField(f, entry.getValue());
 180             }
 181         }
 182 
 183         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift, logMinObjAlignment());
 184         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift, logKlassAlignment);
 185 
 186         assert check();
 187     }
 188 
 189     private final CompressEncoding oopEncoding;
 190     private final CompressEncoding klassEncoding;
 191 
 192     public CompressEncoding getOopEncoding() {
 193         return oopEncoding;
 194     }
 195 
 196     public CompressEncoding getKlassEncoding() {
 197         return klassEncoding;
 198     }
 199 
 200     private void setField(Field field, Object value) {
 201         try {
 202             Class&lt;?&gt; fieldType = field.getType();
 203             if (fieldType == boolean.class) {
 204                 if (value instanceof String) {
 205                     field.setBoolean(this, Boolean.valueOf((String) value));
 206                 } else if (value instanceof Boolean) {
 207                     field.setBoolean(this, (boolean) value);
 208                 } else if (value instanceof Long) {
 209                     field.setBoolean(this, ((long) value) != 0);
 210                 } else {
 211                     GraalInternalError.shouldNotReachHere(value.getClass().getSimpleName());
 212                 }
 213             } else if (fieldType == int.class) {
 214                 if (value instanceof Integer) {
 215                     field.setInt(this, (int) value);
 216                 } else if (value instanceof Long) {
 217                     field.setInt(this, (int) (long) value);
 218                 } else {
 219                     GraalInternalError.shouldNotReachHere(value.getClass().getSimpleName());
 220                 }
 221             } else if (fieldType == long.class) {
 222                 field.setLong(this, (long) value);
 223             } else {
 224                 GraalInternalError.shouldNotReachHere(field.toString());
 225             }
 226         } catch (IllegalAccessException e) {
 227             throw GraalInternalError.shouldNotReachHere(field.toString() + ": " + e);
 228         }
 229     }
 230 
 231     /**
 232      * Gets the host architecture name for the purpose of finding the corresponding
 233      * {@linkplain HotSpotBackendFactory backend}.
 234      */
 235     public String getHostArchitectureName() {
 236         String arch = System.getProperty("os.arch");
 237         switch (arch) {
 238             case "x86_64":
 239                 arch = "amd64";
 240                 break;
 241             case "sparcv9":
 242                 arch = "sparc";
 243                 break;
 244         }
 245         return arch;
 246     }
 247 
 248     /**
 249      * VMStructEntry (see vmStructs.hpp).
 250      */
 251     private long gHotSpotVMStructs;
 252     private long gHotSpotVMStructEntryTypeNameOffset;
 253     private long gHotSpotVMStructEntryFieldNameOffset;
 254     private long gHotSpotVMStructEntryTypeStringOffset;
 255     private long gHotSpotVMStructEntryIsStaticOffset;
 256     private long gHotSpotVMStructEntryOffsetOffset;
 257     private long gHotSpotVMStructEntryAddressOffset;
 258     private long gHotSpotVMStructEntryArrayStride;
 259 
 260     class VMFields implements Iterable&lt;VMFields.Field&gt; {
 261 
 262         private long address;
 263 
 264         public VMFields(long address) {
 265             this.address = address;
 266         }
 267 
 268         public Iterator&lt;VMFields.Field&gt; iterator() {
 269             return new Iterator&lt;VMFields.Field&gt;() {
 270 
 271                 private int index = 0;
 272 
 273                 private Field current() {
 274                     return new Field(address + gHotSpotVMStructEntryArrayStride * index);
 275                 }
 276 
 277                 /**
 278                  * The last entry is identified by a NULL fieldName.
 279                  */
 280                 public boolean hasNext() {
 281                     Field entry = current();
 282                     return entry.getFieldName() != null;
 283                 }
 284 
 285                 public Field next() {
 286                     Field entry = current();
 287                     index++;
 288                     return entry;
 289                 }
 290 
 291                 @Override
 292                 public void remove() {
 293                     throw GraalInternalError.unimplemented();
 294                 }
 295             };
 296         }
 297 
 298         class Field {
 299 
 300             private long entryAddress;
 301 
 302             Field(long address) {
 303                 this.entryAddress = address;
 304             }
 305 
 306             public String getTypeName() {
 307                 long typeNameAddress = unsafe.getAddress(entryAddress + gHotSpotVMStructEntryTypeNameOffset);
 308                 return readCString(typeNameAddress);
 309             }
 310 
 311             public String getFieldName() {
 312                 long fieldNameAddress = unsafe.getAddress(entryAddress + gHotSpotVMStructEntryFieldNameOffset);
 313                 return readCString(fieldNameAddress);
 314             }
 315 
 316             public String getTypeString() {
 317                 long typeStringAddress = unsafe.getAddress(entryAddress + gHotSpotVMStructEntryTypeStringOffset);
 318                 return readCString(typeStringAddress);
 319             }
 320 
 321             public boolean isStatic() {
 322                 return unsafe.getInt(entryAddress + gHotSpotVMStructEntryIsStaticOffset) != 0;
 323             }
 324 
 325             public long getOffset() {
 326                 return unsafe.getLong(entryAddress + gHotSpotVMStructEntryOffsetOffset);
 327             }
 328 
 329             public long getAddress() {
 330                 return unsafe.getAddress(entryAddress + gHotSpotVMStructEntryAddressOffset);
 331             }
 332 
 333             public String getName() {
 334                 String typeName = getTypeName();
 335                 String fieldName = getFieldName();
 336                 return typeName + "::" + fieldName;
 337             }
 338 
 339             public long getValue() {
 340                 String type = getTypeString();
 341                 switch (type) {
 342                     case "int":
 343                         return unsafe.getInt(getAddress());
 344                     case "address":
 345                     case "intptr_t":
 346                         return unsafe.getAddress(getAddress());
 347                     default:
 348                         // All foo* types are addresses.
 349                         if (type.endsWith("*")) {
 350                             return unsafe.getAddress(getAddress());
 351                         }
 352                         throw GraalInternalError.shouldNotReachHere(type);
 353                 }
 354             }
 355 
 356             @Override
 357             public String toString() {
 358                 return String.format("Field[typeName=%s, fieldName=%s, typeString=%s, isStatic=%b, offset=%d, address=0x%x]", getTypeName(), getFieldName(), getTypeString(), isStatic(), getOffset(),
 359                                 getAddress());
 360             }
 361         }
 362     }
 363 
 364     /**
 365      * VMTypeEntry (see vmStructs.hpp).
 366      */
 367     private long gHotSpotVMTypes;
 368     private long gHotSpotVMTypeEntryTypeNameOffset;
 369     private long gHotSpotVMTypeEntrySuperclassNameOffset;
 370     private long gHotSpotVMTypeEntryIsOopTypeOffset;
 371     private long gHotSpotVMTypeEntryIsIntegerTypeOffset;
 372     private long gHotSpotVMTypeEntryIsUnsignedOffset;
 373     private long gHotSpotVMTypeEntrySizeOffset;
 374     private long gHotSpotVMTypeEntryArrayStride;
 375 
 376     class VMTypes implements Iterable&lt;VMTypes.Type&gt; {
 377 
 378         private long address;
 379 
 380         public VMTypes(long address) {
 381             this.address = address;
 382         }
 383 
 384         public Iterator&lt;VMTypes.Type&gt; iterator() {
 385             return new Iterator&lt;VMTypes.Type&gt;() {
 386 
 387                 private int index = 0;
 388 
 389                 private Type current() {
 390                     return new Type(address + gHotSpotVMTypeEntryArrayStride * index);
 391                 }
 392 
 393                 /**
 394                  * The last entry is identified by a NULL type name.
 395                  */
 396                 public boolean hasNext() {
 397                     Type entry = current();
 398                     return entry.getTypeName() != null;
 399                 }
 400 
 401                 public Type next() {
 402                     Type entry = current();
 403                     index++;
 404                     return entry;
 405                 }
 406 
 407                 @Override
 408                 public void remove() {
 409                     throw GraalInternalError.unimplemented();
 410                 }
 411             };
 412         }
 413 
 414         class Type {
 415 
 416             private long entryAddress;
 417 
 418             Type(long address) {
 419                 this.entryAddress = address;
 420             }
 421 
 422             public String getTypeName() {
 423                 long typeNameAddress = unsafe.getAddress(entryAddress + gHotSpotVMTypeEntryTypeNameOffset);
 424                 return readCString(typeNameAddress);
 425             }
 426 
 427             public String getSuperclassName() {
 428                 long superclassNameAddress = unsafe.getAddress(entryAddress + gHotSpotVMTypeEntrySuperclassNameOffset);
 429                 return readCString(superclassNameAddress);
 430             }
 431 
 432             public boolean isOopType() {
 433                 return unsafe.getInt(entryAddress + gHotSpotVMTypeEntryIsOopTypeOffset) != 0;
 434             }
 435 
 436             public boolean isIntegerType() {
 437                 return unsafe.getInt(entryAddress + gHotSpotVMTypeEntryIsIntegerTypeOffset) != 0;
 438             }
 439 
 440             public boolean isUnsigned() {
 441                 return unsafe.getInt(entryAddress + gHotSpotVMTypeEntryIsUnsignedOffset) != 0;
 442             }
 443 
 444             public long getSize() {
 445                 return unsafe.getLong(entryAddress + gHotSpotVMTypeEntrySizeOffset);
 446             }
 447 
 448             @Override
 449             public String toString() {
 450                 return String.format("Type[typeName=%s, superclassName=%s, isOopType=%b, isIntegerType=%b, isUnsigned=%b, size=%d]", getTypeName(), getSuperclassName(), isOopType(), isIntegerType(),
 451                                 isUnsigned(), getSize());
 452             }
 453         }
 454     }
 455 
 456     public abstract class AbstractConstant {
 457 
 458         protected long address;
 459         protected long nameOffset;
 460         protected long valueOffset;
 461 
 462         AbstractConstant(long address, long nameOffset, long valueOffset) {
 463             this.address = address;
 464             this.nameOffset = nameOffset;
 465             this.valueOffset = valueOffset;
 466         }
 467 
 468         public String getName() {
 469             long nameAddress = unsafe.getAddress(address + nameOffset);
 470             return readCString(nameAddress);
 471         }
 472 
 473         public abstract long getValue();
 474     }
 475 
 476     /**
 477      * VMIntConstantEntry (see vmStructs.hpp).
 478      */
 479     private long gHotSpotVMIntConstants;
 480     private long gHotSpotVMIntConstantEntryNameOffset;
 481     private long gHotSpotVMIntConstantEntryValueOffset;
 482     private long gHotSpotVMIntConstantEntryArrayStride;
 483 
 484     class VMIntConstants implements Iterable&lt;VMIntConstants.Constant&gt; {
 485 
 486         private long address;
 487 
 488         public VMIntConstants(long address) {
 489             this.address = address;
 490         }
 491 
 492         public Iterator&lt;VMIntConstants.Constant&gt; iterator() {
 493             return new Iterator&lt;VMIntConstants.Constant&gt;() {
 494 
 495                 private int index = 0;
 496 
 497                 private Constant current() {
 498                     return new Constant(address + gHotSpotVMIntConstantEntryArrayStride * index);
 499                 }
 500 
 501                 /**
 502                  * The last entry is identified by a NULL name.
 503                  */
 504                 public boolean hasNext() {
 505                     Constant entry = current();
 506                     return entry.getName() != null;
 507                 }
 508 
 509                 public Constant next() {
 510                     Constant entry = current();
 511                     index++;
 512                     return entry;
 513                 }
 514 
 515                 @Override
 516                 public void remove() {
 517                     throw GraalInternalError.unimplemented();
 518                 }
 519             };
 520         }
 521 
 522         class Constant extends AbstractConstant {
 523 
 524             Constant(long address) {
 525                 super(address, gHotSpotVMIntConstantEntryNameOffset, gHotSpotVMIntConstantEntryValueOffset);
 526             }
 527 
 528             @Override
 529             public long getValue() {
 530                 return unsafe.getInt(address + valueOffset);
 531             }
 532 
 533             @Override
 534             public String toString() {
 535                 return String.format("IntConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 536             }
 537         }
 538     }
 539 
 540     /**
 541      * VMLongConstantEntry (see vmStructs.hpp).
 542      */
 543     private long gHotSpotVMLongConstants;
 544     private long gHotSpotVMLongConstantEntryNameOffset;
 545     private long gHotSpotVMLongConstantEntryValueOffset;
 546     private long gHotSpotVMLongConstantEntryArrayStride;
 547 
 548     class VMLongConstants implements Iterable&lt;VMLongConstants.Constant&gt; {
 549 
 550         private long address;
 551 
 552         public VMLongConstants(long address) {
 553             this.address = address;
 554         }
 555 
 556         public Iterator&lt;VMLongConstants.Constant&gt; iterator() {
 557             return new Iterator&lt;VMLongConstants.Constant&gt;() {
 558 
 559                 private int index = 0;
 560 
 561                 private Constant currentEntry() {
 562                     return new Constant(address + gHotSpotVMLongConstantEntryArrayStride * index);
 563                 }
 564 
 565                 /**
 566                  * The last entry is identified by a NULL name.
 567                  */
 568                 public boolean hasNext() {
 569                     Constant entry = currentEntry();
 570                     return entry.getName() != null;
 571                 }
 572 
 573                 public Constant next() {
 574                     Constant entry = currentEntry();
 575                     index++;
 576                     return entry;
 577                 }
 578 
 579                 @Override
 580                 public void remove() {
 581                     throw GraalInternalError.unimplemented();
 582                 }
 583             };
 584         }
 585 
 586         class Constant extends AbstractConstant {
 587 
 588             Constant(long address) {
 589                 super(address, gHotSpotVMLongConstantEntryNameOffset, gHotSpotVMLongConstantEntryValueOffset);
 590             }
 591 
 592             @Override
 593             public long getValue() {
 594                 return unsafe.getLong(address + valueOffset);
 595             }
 596 
 597             @Override
 598             public String toString() {
 599                 return String.format("LongConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 600             }
 601         }
 602     }
 603 
 604     class Flags implements Iterable&lt;Flags.Flag&gt; {
 605 
 606         private long address;
 607         private long entrySize;
 608         private long typeOffset;
 609         private long nameOffset;
 610         private long addrOffset;
 611 
 612         public Flags(HashMap&lt;String, VMFields.Field&gt; vmStructs, HashMap&lt;String, VMTypes.Type&gt; vmTypes) {
 613             address = vmStructs.get("Flag::flags").getValue();
 614             entrySize = vmTypes.get("Flag").getSize();
 615             typeOffset = vmStructs.get("Flag::_type").getOffset();
 616             nameOffset = vmStructs.get("Flag::_name").getOffset();
 617             addrOffset = vmStructs.get("Flag::_addr").getOffset();
 618 
 619             assert vmTypes.get("bool").getSize() == Byte.BYTES;
 620             assert vmTypes.get("intx").getSize() == Long.BYTES;
 621             assert vmTypes.get("uintx").getSize() == Long.BYTES;
 622         }
 623 
 624         public Iterator&lt;Flags.Flag&gt; iterator() {
 625             return new Iterator&lt;Flags.Flag&gt;() {
 626 
 627                 private int index = 0;
 628 
 629                 private Flag current() {
 630                     return new Flag(address + entrySize * index);
 631                 }
 632 
 633                 /**
 634                  * The last entry is identified by a NULL name.
 635                  */
 636                 public boolean hasNext() {
 637                     Flag entry = current();
 638                     return entry.getName() != null;
 639                 }
 640 
 641                 public Flag next() {
 642                     Flag entry = current();
 643                     index++;
 644                     return entry;
 645                 }
 646 
 647                 @Override
 648                 public void remove() {
 649                     throw GraalInternalError.unimplemented();
 650                 }
 651             };
 652         }
 653 
 654         class Flag {
 655 
 656             private long entryAddress;
 657 
 658             Flag(long address) {
 659                 this.entryAddress = address;
 660             }
 661 
 662             public String getType() {
 663                 long typeAddress = unsafe.getAddress(entryAddress + typeOffset);
 664                 return readCString(typeAddress);
 665             }
 666 
 667             public String getName() {
 668                 long nameAddress = unsafe.getAddress(entryAddress + nameOffset);
 669                 return readCString(nameAddress);
 670             }
 671 
 672             public long getAddr() {
 673                 return unsafe.getAddress(entryAddress + addrOffset);
 674             }
 675 
 676             public Object getValue() {
 677                 switch (getType()) {
 678                     case "bool":
 679                         return Boolean.valueOf(unsafe.getByte(getAddr()) != 0);
 680                     case "intx":
 681                     case "uintx":
 682                     case "uint64_t":
 683                         return Long.valueOf(unsafe.getLong(getAddr()));
 684                     case "double":
 685                         return Double.valueOf(unsafe.getDouble(getAddr()));
 686                     case "ccstr":
 687                     case "ccstrlist":
 688                         return readCString(getAddr());
 689                     default:
 690                         throw GraalInternalError.shouldNotReachHere(getType());
 691                 }
 692             }
 693 
 694             @Override
 695             public String toString() {
 696                 return String.format("Flag[type=%s, name=%s, value=%s]", getType(), getName(), getValue());
 697             }
 698         }
 699     }
 700 
 701     // os information, register layout, code generation, ...
 702     @HotSpotVMConstant(name = "ASSERT") @Stable public boolean cAssertions;
 703     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
 704 
 705     @HotSpotVMFlag(name = "CodeEntryAlignment") @Stable public int codeEntryAlignment;
 706     @HotSpotVMFlag(name = "VerifyOops") @Stable public boolean verifyOops;
 707     @HotSpotVMFlag(name = "CITime") @Stable public boolean ciTime;
 708     @HotSpotVMFlag(name = "CITimeEach") @Stable public boolean ciTimeEach;
 709     @HotSpotVMFlag(name = "CompileThreshold") @Stable public long compileThreshold;
 710     @HotSpotVMFlag(name = "CompileTheWorld") @Stable public boolean compileTheWorld;
 711     @HotSpotVMFlag(name = "CompileTheWorldStartAt") @Stable public int compileTheWorldStartAt;
 712     @HotSpotVMFlag(name = "CompileTheWorldStopAt") @Stable public int compileTheWorldStopAt;
 713     @HotSpotVMFlag(name = "DontCompileHugeMethods") @Stable public boolean dontCompileHugeMethods;
 714     @HotSpotVMFlag(name = "HugeMethodLimit") @Stable public int hugeMethodLimit;
 715     @HotSpotVMFlag(name = "PrintCompilation") @Stable public boolean printCompilation;
 716     @HotSpotVMFlag(name = "CIPrintCompilerName") @Stable public boolean printCompilerName;
 717     @HotSpotVMFlag(name = "PrintInlining") @Stable public boolean printInlining;
 718     @HotSpotVMFlag(name = "GraalUseFastLocking") @Stable public boolean useFastLocking;
 719     @HotSpotVMFlag(name = "ForceUnreachable") @Stable public boolean forceUnreachable;
 720     @HotSpotVMFlag(name = "GPUOffload") @Stable public boolean gpuOffload;
 721     @HotSpotVMFlag(name = "TieredCompilation") @Stable public boolean tieredCompilation;
 722 
 723     @HotSpotVMFlag(name = "UseTLAB") @Stable public boolean useTLAB;
 724     @HotSpotVMFlag(name = "UseBiasedLocking") @Stable public boolean useBiasedLocking;
 725     @HotSpotVMFlag(name = "UsePopCountInstruction") @Stable public boolean usePopCountInstruction;
 726     @HotSpotVMFlag(name = "UseCountLeadingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountLeadingZerosInstruction;
 727     @HotSpotVMFlag(name = "UseAESIntrinsics") @Stable public boolean useAESIntrinsics;
 728     @HotSpotVMFlag(name = "UseCRC32Intrinsics") @Stable public boolean useCRC32Intrinsics;
 729     @HotSpotVMFlag(name = "UseG1GC") @Stable public boolean useG1GC;
 730     @HotSpotVMFlag(name = "UseConcMarkSweepGC") @Stable public boolean useCMSGC;
 731 
 732     @HotSpotVMFlag(name = "AllocatePrefetchStyle") @Stable public int allocatePrefetchStyle;
 733     @HotSpotVMFlag(name = "AllocatePrefetchInstr") @Stable public int allocatePrefetchInstr;
 734     @HotSpotVMFlag(name = "AllocatePrefetchLines") @Stable public int allocatePrefetchLines;
 735     @HotSpotVMFlag(name = "AllocateInstancePrefetchLines") @Stable public int allocateInstancePrefetchLines;
 736     @HotSpotVMFlag(name = "AllocatePrefetchStepSize") @Stable public int allocatePrefetchStepSize;
 737     @HotSpotVMFlag(name = "AllocatePrefetchDistance") @Stable public int allocatePrefetchDistance;
 738 
 739     @HotSpotVMField(name = "Universe::_collectedHeap", type = "CollectedHeap*", get = HotSpotVMField.Type.VALUE) @Stable private long universeCollectedHeap;
 740     @HotSpotVMField(name = "CollectedHeap::_total_collections", type = "unsigned int", get = HotSpotVMField.Type.OFFSET) @Stable private int collectedHeapTotalCollectionsOffset;
 741 
 742     public long gcTotalCollectionsAddress() {
 743         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
 744     }
 745 
 746     @HotSpotVMFlag(name = "GraalDeferredInitBarriers") @Stable public boolean useDeferredInitBarriers;
 747     @HotSpotVMFlag(name = "GraalHProfEnabled") @Stable public boolean useHeapProfiler;
 748 
 749     // Compressed Oops related values.
 750     @HotSpotVMFlag(name = "UseCompressedOops") @Stable public boolean useCompressedOops;
 751     @HotSpotVMFlag(name = "UseCompressedClassPointers") @Stable public boolean useCompressedClassPointers;
 752 
 753     @HotSpotVMField(name = "Universe::_narrow_oop._base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowOopBase;
 754     @HotSpotVMField(name = "Universe::_narrow_oop._shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowOopShift;
 755     @HotSpotVMFlag(name = "ObjectAlignmentInBytes") @Stable public int objectAlignment;
 756 
 757     public int logMinObjAlignment() {
 758         return (int) (Math.log(objectAlignment) / Math.log(2));
 759     }
 760 
 761     @HotSpotVMField(name = "Universe::_narrow_klass._base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowKlassBase;
 762     @HotSpotVMField(name = "Universe::_narrow_klass._shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowKlassShift;
 763     @HotSpotVMConstant(name = "LogKlassAlignmentInBytes") @Stable public int logKlassAlignment;
 764 
 765     // CPU capabilities
 766     @HotSpotVMFlag(name = "UseSSE") @Stable public int useSSE;
 767     @HotSpotVMFlag(name = "UseAVX", archs = {"amd64"}) @Stable public int useAVX;
 768 
 769     // X86 specific values
 770     @HotSpotVMField(name = "VM_Version::_cpuFeatures", type = "int", get = HotSpotVMField.Type.VALUE, archs = {"amd64"}) @Stable public int x86CPUFeatures;
 771     @HotSpotVMConstant(name = "VM_Version::CPU_CX8", archs = {"amd64"}) @Stable public int cpuCX8;
 772     @HotSpotVMConstant(name = "VM_Version::CPU_CMOV", archs = {"amd64"}) @Stable public int cpuCMOV;
 773     @HotSpotVMConstant(name = "VM_Version::CPU_FXSR", archs = {"amd64"}) @Stable public int cpuFXSR;
 774     @HotSpotVMConstant(name = "VM_Version::CPU_HT", archs = {"amd64"}) @Stable public int cpuHT;
 775     @HotSpotVMConstant(name = "VM_Version::CPU_MMX", archs = {"amd64"}) @Stable public int cpuMMX;
 776     @HotSpotVMConstant(name = "VM_Version::CPU_3DNOW_PREFETCH", archs = {"amd64"}) @Stable public int cpu3DNOWPREFETCH;
 777     @HotSpotVMConstant(name = "VM_Version::CPU_SSE", archs = {"amd64"}) @Stable public int cpuSSE;
 778     @HotSpotVMConstant(name = "VM_Version::CPU_SSE2", archs = {"amd64"}) @Stable public int cpuSSE2;
 779     @HotSpotVMConstant(name = "VM_Version::CPU_SSE3", archs = {"amd64"}) @Stable public int cpuSSE3;
 780     @HotSpotVMConstant(name = "VM_Version::CPU_SSSE3", archs = {"amd64"}) @Stable public int cpuSSSE3;
 781     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4A", archs = {"amd64"}) @Stable public int cpuSSE4A;
 782     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_1", archs = {"amd64"}) @Stable public int cpuSSE41;
 783     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_2", archs = {"amd64"}) @Stable public int cpuSSE42;
 784     @HotSpotVMConstant(name = "VM_Version::CPU_POPCNT", archs = {"amd64"}) @Stable public int cpuPOPCNT;
 785     @HotSpotVMConstant(name = "VM_Version::CPU_LZCNT", archs = {"amd64"}) @Stable public int cpuLZCNT;
 786     @HotSpotVMConstant(name = "VM_Version::CPU_TSC", archs = {"amd64"}) @Stable public int cpuTSC;
 787     @HotSpotVMConstant(name = "VM_Version::CPU_TSCINV", archs = {"amd64"}) @Stable public int cpuTSCINV;
 788     @HotSpotVMConstant(name = "VM_Version::CPU_AVX", archs = {"amd64"}) @Stable public int cpuAVX;
 789     @HotSpotVMConstant(name = "VM_Version::CPU_AVX2", archs = {"amd64"}) @Stable public int cpuAVX2;
 790     @HotSpotVMConstant(name = "VM_Version::CPU_AES", archs = {"amd64"}) @Stable public int cpuAES;
 791     @HotSpotVMConstant(name = "VM_Version::CPU_ERMS", archs = {"amd64"}) @Stable public int cpuERMS;
 792     @HotSpotVMConstant(name = "VM_Version::CPU_CLMUL", archs = {"amd64"}) @Stable public int cpuCLMUL;
 793 
 794     // offsets, ...
 795     @HotSpotVMFlag(name = "StackShadowPages") @Stable public int stackShadowPages;
 796     @HotSpotVMFlag(name = "UseStackBanging") @Stable public boolean useStackBanging;
 797 
 798     @HotSpotVMField(name = "oopDesc::_mark", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int markOffset;
 799     @HotSpotVMField(name = "oopDesc::_metadata._klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int hubOffset;
 800 
 801     @HotSpotVMField(name = "Klass::_prototype_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int prototypeMarkWordOffset;
 802     @HotSpotVMField(name = "Klass::_subklass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int subklassOffset;
 803     @HotSpotVMField(name = "Klass::_next_sibling", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int nextSiblingOffset;
 804     @HotSpotVMField(name = "Klass::_super_check_offset", type = "juint", get = HotSpotVMField.Type.OFFSET) @Stable public int superCheckOffsetOffset;
 805     @HotSpotVMField(name = "Klass::_secondary_super_cache", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySuperCacheOffset;
 806     @HotSpotVMField(name = "Klass::_secondary_supers", type = "Array&lt;Klass*&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySupersOffset;
 807 
 808     /**
 809      * The offset of the _java_mirror field (of type {@link Class}) in a Klass.
 810      */
 811     @HotSpotVMField(name = "Klass::_java_mirror", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int classMirrorOffset;
 812 
 813     @HotSpotVMField(name = "Klass::_super", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int klassSuperKlassOffset;
 814     @HotSpotVMField(name = "Klass::_modifier_flags", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassModifierFlagsOffset;
 815     @HotSpotVMField(name = "Klass::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int klassAccessFlagsOffset;
 816     @HotSpotVMField(name = "Klass::_layout_helper", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassLayoutHelperOffset;
 817     @HotSpotVMField(name = "Klass::_layout_helper", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassInstanceSizeOffset;
 818 
 819     @HotSpotVMConstant(name = "Klass::_lh_neutral_value") @Stable public int klassLayoutHelperNeutralValue;
 820     @HotSpotVMConstant(name = "Klass::_lh_instance_slow_path_bit") @Stable public int klassLayoutHelperInstanceSlowPathBit;
 821     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_shift") @Stable public int layoutHelperLog2ElementSizeShift;
 822     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_mask") @Stable public int layoutHelperLog2ElementSizeMask;
 823     @HotSpotVMConstant(name = "Klass::_lh_element_type_shift") @Stable public int layoutHelperElementTypeShift;
 824     @HotSpotVMConstant(name = "Klass::_lh_element_type_mask") @Stable public int layoutHelperElementTypeMask;
 825     @HotSpotVMConstant(name = "Klass::_lh_header_size_shift") @Stable public int layoutHelperHeaderSizeShift;
 826     @HotSpotVMConstant(name = "Klass::_lh_header_size_mask") @Stable public int layoutHelperHeaderSizeMask;
 827     @HotSpotVMConstant(name = "Klass::_lh_array_tag_shift") @Stable public int layoutHelperArrayTagShift;
 828     @HotSpotVMConstant(name = "Klass::_lh_array_tag_type_value") @Stable public int layoutHelperArrayTagTypeValue;
 829     @HotSpotVMConstant(name = "Klass::_lh_array_tag_obj_value") @Stable public int layoutHelperArrayTagObjectValue;
 830 
 831     /**
 832      * This filters out the bit that differentiates a type array from an object array.
 833      */
 834     public int layoutHelperElementTypePrimitiveInPlace() {
 835         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
 836     }
 837 
 838     /**
 839      * Bit pattern in the klass layout helper that can be used to identify arrays.
 840      */
 841     public final int arrayKlassLayoutHelperIdentifier = 0x80000000;
 842 
 843     @HotSpotVMField(name = "ArrayKlass::_component_mirror", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayKlassComponentMirrorOffset;
 844 
 845     @HotSpotVMType(name = "vtableEntry", get = HotSpotVMType.Type.SIZE) @Stable public int vtableEntrySize;
 846     @HotSpotVMField(name = "vtableEntry::_method", type = "Method*", get = HotSpotVMField.Type.OFFSET) @Stable public int vtableEntryMethodOffset;
 847     @Stable public int instanceKlassVtableStartOffset;
 848 
 849     /**
 850      * The offset of the array length word in an array object's header.
 851      */
 852     @Stable public int arrayLengthOffset;
 853 
 854     @HotSpotVMField(name = "Array&lt;int&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1LengthOffset;
 855     @HotSpotVMField(name = "Array&lt;u1&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1DataOffset;
 856     @HotSpotVMField(name = "Array&lt;u2&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU2DataOffset;
 857     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayLengthOffset;
 858     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_data[0]", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayBaseOffset;
 859 
 860     @HotSpotVMField(name = "InstanceKlass::_graal_node_class", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int klassNodeClassOffset;
 861     @HotSpotVMField(name = "InstanceKlass::_source_file_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int klassSourceFileNameIndexOffset;
 862     @HotSpotVMField(name = "InstanceKlass::_init_state", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int klassStateOffset;
 863     @HotSpotVMField(name = "InstanceKlass::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassConstantsOffset;
 864     @HotSpotVMField(name = "InstanceKlass::_fields", type = "Array&lt;u2&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassFieldsOffset;
 865 
 866     @HotSpotVMConstant(name = "InstanceKlass::linked") @Stable public int klassStateLinked;
 867     @HotSpotVMConstant(name = "InstanceKlass::fully_initialized") @Stable public int klassStateFullyInitialized;
 868 
 869     @HotSpotVMField(name = "ObjArrayKlass::_element_klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayClassElementOffset;
 870 
 871     @HotSpotVMConstant(name = "FieldInfo::access_flags_offset") @Stable public int fieldInfoAccessFlagsOffset;
 872     @HotSpotVMConstant(name = "FieldInfo::name_index_offset") @Stable public int fieldInfoNameIndexOffset;
 873     @HotSpotVMConstant(name = "FieldInfo::signature_index_offset") @Stable public int fieldInfoSignatureIndexOffset;
 874     @HotSpotVMConstant(name = "FieldInfo::initval_index_offset") @Stable public int fieldInfoInitvalIndexOffset;
 875     @HotSpotVMConstant(name = "FieldInfo::low_packed_offset") @Stable public int fieldInfoLowPackedOffset;
 876     @HotSpotVMConstant(name = "FieldInfo::high_packed_offset") @Stable public int fieldInfoHighPackedOffset;
 877     @HotSpotVMConstant(name = "FieldInfo::field_slots") @Stable public int fieldInfoFieldSlots;
 878 
 879     @HotSpotVMConstant(name = "FIELDINFO_TAG_SIZE") @Stable public int fieldInfoTagSize;
 880 
 881     @HotSpotVMConstant(name = "JVM_ACC_FIELD_INTERNAL") @Stable public int jvmAccFieldInternal;
 882     @HotSpotVMConstant(name = "JVM_ACC_FIELD_STABLE") @Stable public int jvmAccFieldStable;
 883     @HotSpotVMConstant(name = "JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE") @Stable public int jvmAccFieldHasGenericSignature;
 884 
 885     @HotSpotVMField(name = "Thread::_tlab", type = "ThreadLocalAllocBuffer", get = HotSpotVMField.Type.OFFSET) @Stable public int threadTlabOffset;
 886 
 887     @HotSpotVMField(name = "JavaThread::_anchor", type = "JavaFrameAnchor", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadAnchorOffset;
 888     @HotSpotVMField(name = "JavaThread::_threadObj", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectOffset;
 889     @HotSpotVMField(name = "JavaThread::_osthread", type = "OSThread*", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadOffset;
 890     @HotSpotVMField(name = "JavaThread::_dirty_card_queue", type = "DirtyCardQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadDirtyCardQueueOffset;
 891     @HotSpotVMField(name = "JavaThread::_is_method_handle_return", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int threadIsMethodHandleReturnOffset;
 892     @HotSpotVMField(name = "JavaThread::_satb_mark_queue", type = "ObjPtrQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadSatbMarkQueueOffset;
 893     @HotSpotVMField(name = "JavaThread::_vm_result", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectResultOffset;
 894     @HotSpotVMField(name = "JavaThread::_graal_counters[0]", type = "jlong", get = HotSpotVMField.Type.OFFSET, optional = true) @Stable public int graalCountersThreadOffset;
 895 
 896     /**
 897      * An invalid value for {@link #rtldDefault}.
 898      */
 899     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
 900 
 901     /**
 902      * Address of the library lookup routine. The C signature of this routine is:
 903      *
 904      * &lt;pre&gt;
 905      *     void* (const char *filename, char *ebuf, int ebuflen)
 906      * &lt;/pre&gt;
 907      */
 908     @Stable public long dllLoad;
 909 
 910     /**
 911      * Address of the library lookup routine. The C signature of this routine is:
 912      *
 913      * &lt;pre&gt;
 914      *     void* (void* handle, const char* name)
 915      * &lt;/pre&gt;
 916      */
 917     @Stable public long dllLookup;
 918 
 919     /**
 920      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
 921      * return the first occurrence of the desired symbol using the default library search order. If
 922      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
 923      * the current platform.
 924      */
 925     @Stable public long rtldDefault = INVALID_RTLD_DEFAULT_HANDLE;
 926 
 927     /**
 928      * This field is used to pass exception objects into and out of the runtime system during
 929      * exception handling for compiled code.
 930      * &lt;p&gt;
 931      * &lt;b&gt;NOTE: This is not the same as {@link #pendingExceptionOffset}.&lt;/b&gt;
 932      */
 933     @HotSpotVMField(name = "JavaThread::_exception_oop", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionOopOffset;
 934     @HotSpotVMField(name = "JavaThread::_exception_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionPcOffset;
 935 
 936     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_sp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaSpOffset;
 937     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaPcOffset;
 938     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_fp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET, archs = {"amd64"}) @Stable private int javaFrameAnchorLastJavaFpOffset;
 939     @HotSpotVMField(name = "JavaFrameAnchor::_flags", type = "int", get = HotSpotVMField.Type.OFFSET, archs = {"sparc"}) @Stable private int javaFrameAnchorFlagsOffset;
 940 
 941     public int threadLastJavaSpOffset() {
 942         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
 943     }
 944 
 945     public int threadLastJavaPcOffset() {
 946         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
 947     }
 948 
 949     /**
 950      * This value is only valid on AMD64.
 951      */
 952     public int threadLastJavaFpOffset() {
 953         // TODO add an assert for AMD64
 954         return javaThreadAnchorOffset + javaFrameAnchorLastJavaFpOffset;
 955     }
 956 
 957     /**
 958      * This value is only valid on SPARC.
 959      */
 960     public int threadJavaFrameAnchorFlagsOffset() {
 961         // TODO add an assert for SPARC
 962         return javaThreadAnchorOffset + javaFrameAnchorFlagsOffset;
 963     }
 964 
 965     @HotSpotVMConstant(name = "frame::arg_reg_save_area_bytes", archs = {"amd64"}) @Stable public int runtimeCallStackSize;
 966 
 967     @HotSpotVMField(name = "PtrQueue::_active", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int ptrQueueActiveOffset;
 968     @HotSpotVMField(name = "PtrQueue::_buf", type = "void**", get = HotSpotVMField.Type.OFFSET) @Stable public int ptrQueueBufferOffset;
 969     @HotSpotVMField(name = "PtrQueue::_index", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable public int ptrQueueIndexOffset;
 970 
 971     @HotSpotVMField(name = "OSThread::_interrupted", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadInterruptedOffset;
 972 
 973     @HotSpotVMConstant(name = "markOopDesc::unlocked_value") @Stable public int unlockedMask;
 974     @HotSpotVMConstant(name = "markOopDesc::biased_lock_mask_in_place") @Stable public int biasedLockMaskInPlace;
 975     @HotSpotVMConstant(name = "markOopDesc::age_mask_in_place") @Stable public int ageMaskInPlace;
 976     @HotSpotVMConstant(name = "markOopDesc::epoch_mask_in_place") @Stable public int epochMaskInPlace;
 977 
 978     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public long markOopDescHashShift;
 979     @HotSpotVMConstant(name = "markOopDesc::hash_mask") @Stable public long markOopDescHashMask;
 980     @HotSpotVMConstant(name = "markOopDesc::hash_mask_in_place") @Stable public long markOopDescHashMaskInPlace;
 981 
 982     @HotSpotVMConstant(name = "markOopDesc::biased_lock_pattern") @Stable public int biasedLockPattern;
 983     @HotSpotVMConstant(name = "markOopDesc::no_hash_in_place") @Stable public int markWordNoHashInPlace;
 984     @HotSpotVMConstant(name = "markOopDesc::no_lock_in_place") @Stable public int markWordNoLockInPlace;
 985 
 986     /**
 987      * See markOopDesc::prototype().
 988      */
 989     public long arrayPrototypeMarkWord() {
 990         return markWordNoHashInPlace | markWordNoLockInPlace;
 991     }
 992 
 993     /**
 994      * See markOopDesc::copy_set_hash().
 995      */
 996     public long tlabIntArrayMarkWord() {
 997         long tmp = arrayPrototypeMarkWord() &amp; (~markOopDescHashMaskInPlace);
 998         tmp |= ((0x2 &amp; markOopDescHashMask) &lt;&lt; markOopDescHashShift);
 999         return tmp;
1000     }
1001 
1002     /**
1003      * Offset of the _pending_exception field in ThreadShadow (defined in exceptions.hpp). This
1004      * field is used to propagate exceptions through C/C++ calls.
1005      * &lt;p&gt;
1006      * &lt;b&gt;NOTE: This is not the same as {@link #threadExceptionOopOffset}.&lt;/b&gt;
1007      */
1008     @HotSpotVMField(name = "ThreadShadow::_pending_exception", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingExceptionOffset;
1009     @HotSpotVMField(name = "ThreadShadow::_pending_deoptimization", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingDeoptimizationOffset;
1010     @HotSpotVMField(name = "ThreadShadow::_pending_failed_speculation", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingFailedSpeculationOffset;
1011 
1012     @HotSpotVMFlag(name = "UseHSAILDeoptimization") @Stable public boolean useHSAILDeoptimization;
1013 
1014     /**
1015      * Offsets of Hsail deoptimization fields (defined in gpu_hsail.hpp). Used to propagate
1016      * exceptions from Hsail back to C++ runtime.
1017      */
1018     @HotSpotVMField(name = "Hsail::HSAILDeoptimizationInfo::_deopt_save_states[0]", type = "Hsail::HSAILKernelDeoptimization", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailSaveStatesOffset0;
1019     @HotSpotVMField(name = "Hsail::HSAILDeoptimizationInfo::_deopt_save_states[1]", type = "Hsail::HSAILKernelDeoptimization", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailSaveStatesOffset1;
1020     @HotSpotVMField(name = "Hsail::HSAILDeoptimizationInfo::_deopt_occurred", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailDeoptOccurredOffset;
1021     @HotSpotVMField(name = "Hsail::HSAILDeoptimizationInfo::_never_ran_array", type = "jboolean *", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailNeverRanArrayOffset;
1022     @HotSpotVMField(name = "Hsail::HSAILDeoptimizationInfo::_deopt_next_index", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailDeoptNextIndexOffset;
1023     @HotSpotVMField(name = "Hsail::HSAILDeoptimizationInfo::_donor_threads", type = "JavaThread**", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailDonorThreadsOffset;
1024 
1025     @HotSpotVMField(name = "Hsail::HSAILKernelDeoptimization::_workitemid", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailDeoptimizationWorkItem;
1026     @HotSpotVMField(name = "Hsail::HSAILKernelDeoptimization::_actionAndReason", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailDeoptimizationReason;
1027     @HotSpotVMField(name = "Hsail::HSAILKernelDeoptimization::_first_frame", type = "HSAILFrame", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailDeoptimizationFrame;
1028 
1029     @HotSpotVMField(name = "HSAILFrame::_pc_offset", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailFramePcOffset;
1030     @HotSpotVMField(name = "HSAILFrame::_num_s_regs", type = "jbyte", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailFrameNumSRegOffset;
1031     @HotSpotVMField(name = "HSAILFrame::_save_area[0]", type = "jlong", get = HotSpotVMField.Type.OFFSET) @Stable public int hsailFrameSaveAreaOffset;
1032 
1033     /**
1034      * Mark word right shift to get identity hash code.
1035      */
1036     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public int identityHashCodeShift;
1037 
1038     /**
1039      * Identity hash code value when uninitialized.
1040      */
1041     @HotSpotVMConstant(name = "markOopDesc::no_hash") @Stable public int uninitializedIdentityHashCodeValue;
1042 
1043     /**
1044      * Used for marking a Method object as queued for compilation.
1045      */
1046     @HotSpotVMConstant(name = "JVM_ACC_QUEUED") @Stable public int methodQueuedForCompilationBit;
1047 
1048     @HotSpotVMField(name = "Method::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int methodAccessFlagsOffset;
1049     @HotSpotVMField(name = "Method::_constMethod", type = "ConstMethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodConstMethodOffset;
1050     @HotSpotVMField(name = "Method::_intrinsic_id", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int methodIntrinsicIdOffset;
1051     @HotSpotVMField(name = "Method::_flags", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int methodFlagsOffset;
1052     @HotSpotVMField(name = "Method::_vtable_index", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodVtableIndexOffset;
1053 
1054     @HotSpotVMConstant(name = "Method::_jfr_towrite") @Stable public int methodFlagsJfrTowrite;
1055     @HotSpotVMConstant(name = "Method::_caller_sensitive") @Stable public int methodFlagsCallerSensitive;
1056     @HotSpotVMConstant(name = "Method::_force_inline") @Stable public int methodFlagsForceInline;
1057     @HotSpotVMConstant(name = "Method::_dont_inline") @Stable public int methodFlagsDontInline;
1058     @HotSpotVMConstant(name = "Method::_hidden") @Stable public int methodFlagsHidden;
1059 
1060     @HotSpotVMConstant(name = "JVM_ACC_MONITOR_MATCH") @Stable public int jvmAccMonitorMatch;
1061     @HotSpotVMConstant(name = "JVM_ACC_HAS_MONITOR_BYTECODES") @Stable public int jvmAccHasMonitorBytecodes;
1062 
1063     /**
1064      * Value of Method::extra_stack_entries().
1065      */
1066     @Stable public int extraStackEntries;
1067 
1068     @HotSpotVMField(name = "ConstMethod::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodConstantsOffset;
1069     @HotSpotVMField(name = "ConstMethod::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodFlagsOffset;
1070     @HotSpotVMField(name = "ConstMethod::_code_size", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodCodeSizeOffset;
1071     @HotSpotVMField(name = "ConstMethod::_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodNameIndexOffset;
1072     @HotSpotVMField(name = "ConstMethod::_signature_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodSignatureIndexOffset;
1073     @HotSpotVMField(name = "ConstMethod::_max_stack", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodMaxStackOffset;
1074     @HotSpotVMField(name = "ConstMethod::_max_locals", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodMaxLocalsOffset;
1075 
1076     @HotSpotVMConstant(name = "ConstMethod::_has_linenumber_table") @Stable public int constMethodHasLineNumberTable;
1077     @HotSpotVMConstant(name = "ConstMethod::_has_localvariable_table") @Stable public int constMethodHasLocalVariableTable;
1078     @HotSpotVMConstant(name = "ConstMethod::_has_exception_table") @Stable public int constMethodHasExceptionTable;
1079 
1080     @HotSpotVMType(name = "ExceptionTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int exceptionTableElementSize;
1081     @HotSpotVMField(name = "ExceptionTableElement::start_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementStartPcOffset;
1082     @HotSpotVMField(name = "ExceptionTableElement::end_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementEndPcOffset;
1083     @HotSpotVMField(name = "ExceptionTableElement::handler_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementHandlerPcOffset;
1084     @HotSpotVMField(name = "ExceptionTableElement::catch_type_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementCatchTypeIndexOffset;
1085 
1086     @HotSpotVMType(name = "LocalVariableTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int localVariableTableElementSize;
1087     @HotSpotVMField(name = "LocalVariableTableElement::start_bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementStartBciOffset;
1088     @HotSpotVMField(name = "LocalVariableTableElement::length", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementLengthOffset;
1089     @HotSpotVMField(name = "LocalVariableTableElement::name_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementNameCpIndexOffset;
1090     @HotSpotVMField(name = "LocalVariableTableElement::descriptor_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementDescriptorCpIndexOffset;
1091     @HotSpotVMField(name = "LocalVariableTableElement::signature_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSignatureCpIndexOffset;
1092     @HotSpotVMField(name = "LocalVariableTableElement::slot", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSlotOffset;
1093 
1094     @HotSpotVMType(name = "ConstantPool", get = HotSpotVMType.Type.SIZE) @Stable public int constantPoolSize;
1095     @HotSpotVMField(name = "ConstantPool::_tags", type = "Array&lt;u1&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolTagsOffset;
1096     @HotSpotVMField(name = "ConstantPool::_pool_holder", type = "InstanceKlass*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolHolderOffset;
1097     @HotSpotVMField(name = "ConstantPool::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolLengthOffset;
1098 
1099     @HotSpotVMConstant(name = "ConstantPool::CPCACHE_INDEX_TAG") @Stable public int constantPoolCpCacheIndexTag;
1100 
1101     @HotSpotVMConstant(name = "JVM_CONSTANT_Utf8") @Stable public int jvmConstantUtf8;
1102     @HotSpotVMConstant(name = "JVM_CONSTANT_Integer") @Stable public int jvmConstantInteger;
1103     @HotSpotVMConstant(name = "JVM_CONSTANT_Long") @Stable public int jvmConstantLong;
1104     @HotSpotVMConstant(name = "JVM_CONSTANT_Float") @Stable public int jvmConstantFloat;
1105     @HotSpotVMConstant(name = "JVM_CONSTANT_Double") @Stable public int jvmConstantDouble;
1106     @HotSpotVMConstant(name = "JVM_CONSTANT_Class") @Stable public int jvmConstantClass;
1107     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClass") @Stable public int jvmConstantUnresolvedClass;
1108     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClassInError") @Stable public int jvmConstantUnresolvedClassInError;
1109     @HotSpotVMConstant(name = "JVM_CONSTANT_String") @Stable public int jvmConstantString;
1110     @HotSpotVMConstant(name = "JVM_CONSTANT_Fieldref") @Stable public int jvmConstantFieldref;
1111     @HotSpotVMConstant(name = "JVM_CONSTANT_Methodref") @Stable public int jvmConstantMethodref;
1112     @HotSpotVMConstant(name = "JVM_CONSTANT_InterfaceMethodref") @Stable public int jvmConstantInterfaceMethodref;
1113     @HotSpotVMConstant(name = "JVM_CONSTANT_NameAndType") @Stable public int jvmConstantNameAndType;
1114     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandle") @Stable public int jvmConstantMethodHandle;
1115     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandleInError") @Stable public int jvmConstantMethodHandleInError;
1116     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodType") @Stable public int jvmConstantMethodType;
1117     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodTypeInError") @Stable public int jvmConstantMethodTypeInError;
1118     @HotSpotVMConstant(name = "JVM_CONSTANT_InvokeDynamic") @Stable public int jvmConstantInvokeDynamic;
1119 
1120     @HotSpotVMConstant(name = "HeapWordSize") @Stable public int heapWordSize;
1121 
1122     @HotSpotVMType(name = "Symbol*", get = HotSpotVMType.Type.SIZE) @Stable public int symbolPointerSize;
1123     @HotSpotVMField(name = "Symbol::_length", type = "unsigned short", get = HotSpotVMField.Type.OFFSET) @Stable public int symbolLengthOffset;
1124     @HotSpotVMField(name = "Symbol::_body[0]", type = "jbyte", get = HotSpotVMField.Type.OFFSET) @Stable public int symbolBodyOffset;
1125 
1126     @HotSpotVMField(name = "vmSymbols::_symbols[0]", type = "Symbol*", get = HotSpotVMField.Type.ADDRESS) @Stable public long vmSymbolsSymbols;
1127     @HotSpotVMConstant(name = "vmSymbols::FIRST_SID") @Stable public int vmSymbolsFirstSID;
1128     @HotSpotVMConstant(name = "vmSymbols::SID_LIMIT") @Stable public int vmSymbolsSIDLimit;
1129 
1130     @HotSpotVMConstant(name = "JVM_ACC_HAS_FINALIZER") @Stable public int klassHasFinalizerFlag;
1131 
1132     // Modifier.SYNTHETIC is not public so we get it via vmStructs.
1133     @HotSpotVMConstant(name = "JVM_ACC_SYNTHETIC") @Stable public int syntheticFlag;
1134 
1135     /**
1136      * @see HotSpotResolvedObjectType#createField
1137      */
1138     @HotSpotVMConstant(name = "JVM_RECOGNIZED_FIELD_MODIFIERS") @Stable public int recognizedFieldModifiers;
1139 
1140     /**
1141      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
1142      * are allowed to look like (respectively) the high or low bits of a real oop.
1143      */
1144     @HotSpotVMField(name = "Universe::_non_oop_bits", type = "intptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long nonOopBits;
1145 
1146     @HotSpotVMField(name = "StubRoutines::_verify_oop_count", type = "jint", get = HotSpotVMField.Type.ADDRESS) @Stable public long verifyOopCounterAddress;
1147     @Stable public long verifyOopMask;
1148     @Stable public long verifyOopBits;
1149 
1150     @HotSpotVMField(name = "CollectedHeap::_barrier_set", type = "BarrierSet*", get = HotSpotVMField.Type.OFFSET) @Stable public int collectedHeapBarrierSetOffset;
1151 
1152     @HotSpotVMField(name = "HeapRegion::LogOfHRGrainBytes", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int logOfHRGrainBytes;
1153 
1154     @HotSpotVMField(name = "BarrierSet::_kind", type = "BarrierSet::Name", get = HotSpotVMField.Type.OFFSET) @Stable private int barrierSetKindOffset;
1155     @HotSpotVMConstant(name = "BarrierSet::CardTableModRef") @Stable public int barrierSetCardTableModRef;
1156     @HotSpotVMConstant(name = "BarrierSet::CardTableExtension") @Stable public int barrierSetCardTableExtension;
1157     @HotSpotVMConstant(name = "BarrierSet::G1SATBCT") @Stable public int barrierSetG1SATBCT;
1158     @HotSpotVMConstant(name = "BarrierSet::G1SATBCTLogging") @Stable public int barrierSetG1SATBCTLogging;
1159     @HotSpotVMConstant(name = "BarrierSet::ModRef") @Stable public int barrierSetModRef;
1160     @HotSpotVMConstant(name = "BarrierSet::Other") @Stable public int barrierSetOther;
1161 
1162     @HotSpotVMField(name = "CardTableModRefBS::byte_map_base", type = "jbyte*", get = HotSpotVMField.Type.OFFSET) @Stable private int cardTableModRefBSByteMapBaseOffset;
1163     @HotSpotVMConstant(name = "CardTableModRefBS::card_shift") @Stable public int cardTableModRefBSCardShift;
1164 
1165     public long cardtableStartAddress() {
1166         final long barrierSetAddress = unsafe.getAddress(universeCollectedHeap + collectedHeapBarrierSetOffset);
1167         final int kind = unsafe.getInt(barrierSetAddress + barrierSetKindOffset);
1168         if ((kind == barrierSetCardTableModRef) || (kind == barrierSetCardTableExtension) || (kind == barrierSetG1SATBCT) || (kind == barrierSetG1SATBCTLogging)) {
1169             final long base = unsafe.getAddress(barrierSetAddress + cardTableModRefBSByteMapBaseOffset);
1170             assert base != 0 : "unexpected byte_map_base: " + base;
1171             return base;
1172         }
1173         if ((kind == barrierSetModRef) || (kind == barrierSetOther)) {
1174             // No post barriers
1175             return 0;
1176         }
1177         throw GraalInternalError.shouldNotReachHere("kind: " + kind);
1178     }
1179 
1180     public int cardtableShift() {
1181         final long barrierSetAddress = unsafe.getAddress(universeCollectedHeap + collectedHeapBarrierSetOffset);
1182         final int kind = unsafe.getInt(barrierSetAddress + barrierSetKindOffset);
1183         if ((kind == barrierSetCardTableModRef) || (kind == barrierSetCardTableExtension) || (kind == barrierSetG1SATBCT) || (kind == barrierSetG1SATBCTLogging)) {
1184             return cardTableModRefBSCardShift;
1185         }
1186         if ((kind == barrierSetModRef) || (kind == barrierSetOther)) {
1187             // No post barriers
1188             return 0;
1189         }
1190         throw GraalInternalError.shouldNotReachHere("kind: " + kind);
1191     }
1192 
1193     @HotSpotVMField(name = "os::_polling_page", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long safepointPollingAddress;
1194 
1195     // G1 Collector Related Values.
1196 
1197     public int g1CardQueueIndexOffset() {
1198         return javaThreadDirtyCardQueueOffset + ptrQueueIndexOffset;
1199     }
1200 
1201     public int g1CardQueueBufferOffset() {
1202         return javaThreadDirtyCardQueueOffset + ptrQueueBufferOffset;
1203     }
1204 
1205     public int g1SATBQueueMarkingOffset() {
1206         return javaThreadSatbMarkQueueOffset + ptrQueueActiveOffset;
1207     }
1208 
1209     public int g1SATBQueueIndexOffset() {
1210         return javaThreadSatbMarkQueueOffset + ptrQueueIndexOffset;
1211     }
1212 
1213     public int g1SATBQueueBufferOffset() {
1214         return javaThreadSatbMarkQueueOffset + ptrQueueBufferOffset;
1215     }
1216 
1217     @HotSpotVMField(name = "java_lang_Class::_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassOffset;
1218     @HotSpotVMField(name = "java_lang_Class::_array_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int arrayKlassOffset;
1219 
1220     @HotSpotVMField(name = "Method::_method_data", type = "MethodData*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOffset;
1221     @HotSpotVMField(name = "Method::_from_compiled_entry", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCompiledEntryOffset;
1222     @HotSpotVMField(name = "Method::_code", type = "nmethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCodeOffset;
1223 
1224     @HotSpotVMField(name = "MethodData::_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataSize;
1225     @HotSpotVMField(name = "MethodData::_data_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataDataSize;
1226     @HotSpotVMField(name = "MethodData::_data[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopDataOffset;
1227     @HotSpotVMField(name = "MethodData::_trap_hist._array[0]", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopTrapHistoryOffset;
1228     @HotSpotVMField(name = "MethodData::_graal_node_count", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataGraalNodeCountOffset;
1229 
1230     @HotSpotVMField(name = "nmethod::_verified_entry_point", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodEntryOffset;
1231     @HotSpotVMField(name = "nmethod::_comp_level", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodCompLevelOffset;
1232 
1233     @HotSpotVMConstant(name = "CompLevel_full_optimization") @Stable public int compilationLevelFullOptimization;
1234 
1235     @HotSpotVMType(name = "BasicLock", get = HotSpotVMType.Type.SIZE) @Stable public int basicLockSize;
1236     @HotSpotVMField(name = "BasicLock::_displaced_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int basicLockDisplacedHeaderOffset;
1237 
1238     @Stable public long heapEndAddress;
1239     @Stable public long heapTopAddress;
1240 
1241     @HotSpotVMField(name = "Thread::_allocated_bytes", type = "jlong", get = HotSpotVMField.Type.OFFSET) @Stable public int threadAllocatedBytesOffset;
1242 
1243     @HotSpotVMFlag(name = "TLABWasteIncrement") @Stable public int tlabRefillWasteIncrement;
1244     @Stable public int tlabAlignmentReserve;
1245 
1246     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_start", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferStartOffset;
1247     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_end", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferEndOffset;
1248     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferTopOffset;
1249     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_pf_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferPfTopOffset;
1250     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_slow_allocations", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferSlowAllocationsOffset;
1251     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_fast_refill_waste", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferFastRefillWasteOffset;
1252     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_number_of_refills", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferNumberOfRefillsOffset;
1253     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_refill_waste_limit", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferRefillWasteLimitOffset;
1254     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_desired_size", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferDesiredSizeOffset;
1255 
1256     public int tlabSlowAllocationsOffset() {
1257         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
1258     }
1259 
1260     public int tlabFastRefillWasteOffset() {
1261         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
1262     }
1263 
1264     public int tlabNumberOfRefillsOffset() {
1265         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
1266     }
1267 
1268     public int tlabRefillWasteLimitOffset() {
1269         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
1270     }
1271 
1272     public int threadTlabSizeOffset() {
1273         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
1274     }
1275 
1276     public int threadTlabStartOffset() {
1277         return threadTlabOffset + threadLocalAllocBufferStartOffset;
1278     }
1279 
1280     public int threadTlabEndOffset() {
1281         return threadTlabOffset + threadLocalAllocBufferEndOffset;
1282     }
1283 
1284     public int threadTlabTopOffset() {
1285         return threadTlabOffset + threadLocalAllocBufferTopOffset;
1286     }
1287 
1288     public int threadTlabPfTopOffset() {
1289         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
1290     }
1291 
1292     @HotSpotVMFlag(name = "TLABStats") @Stable public boolean tlabStats;
1293     @Stable public boolean inlineContiguousAllocationSupported;
1294 
1295     /**
1296      * The DataLayout header size is the same as the cell size.
1297      */
1298     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutHeaderSize;
1299     @HotSpotVMField(name = "DataLayout::_header._struct._tag", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutTagOffset;
1300     @HotSpotVMField(name = "DataLayout::_header._struct._flags", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutFlagsOffset;
1301     @HotSpotVMField(name = "DataLayout::_header._struct._bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutBCIOffset;
1302     @HotSpotVMField(name = "DataLayout::_cells[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutCellsOffset;
1303     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutCellSize;
1304 
1305     @HotSpotVMConstant(name = "DataLayout::no_tag") @Stable public int dataLayoutNoTag;
1306     @HotSpotVMConstant(name = "DataLayout::bit_data_tag") @Stable public int dataLayoutBitDataTag;
1307     @HotSpotVMConstant(name = "DataLayout::counter_data_tag") @Stable public int dataLayoutCounterDataTag;
1308     @HotSpotVMConstant(name = "DataLayout::jump_data_tag") @Stable public int dataLayoutJumpDataTag;
1309     @HotSpotVMConstant(name = "DataLayout::receiver_type_data_tag") @Stable public int dataLayoutReceiverTypeDataTag;
1310     @HotSpotVMConstant(name = "DataLayout::virtual_call_data_tag") @Stable public int dataLayoutVirtualCallDataTag;
1311     @HotSpotVMConstant(name = "DataLayout::ret_data_tag") @Stable public int dataLayoutRetDataTag;
1312     @HotSpotVMConstant(name = "DataLayout::branch_data_tag") @Stable public int dataLayoutBranchDataTag;
1313     @HotSpotVMConstant(name = "DataLayout::multi_branch_data_tag") @Stable public int dataLayoutMultiBranchDataTag;
1314     @HotSpotVMConstant(name = "DataLayout::arg_info_data_tag") @Stable public int dataLayoutArgInfoDataTag;
1315     @HotSpotVMConstant(name = "DataLayout::call_type_data_tag") @Stable public int dataLayoutCallTypeDataTag;
1316     @HotSpotVMConstant(name = "DataLayout::virtual_call_type_data_tag") @Stable public int dataLayoutVirtualCallTypeDataTag;
1317     @HotSpotVMConstant(name = "DataLayout::parameters_type_data_tag") @Stable public int dataLayoutParametersTypeDataTag;
1318 
1319     @HotSpotVMFlag(name = "BciProfileWidth") @Stable public int bciProfileWidth;
1320     @HotSpotVMFlag(name = "TypeProfileWidth") @Stable public int typeProfileWidth;
1321     @HotSpotVMFlag(name = "MethodProfileWidth") @Stable public int methodProfileWidth;
1322 
1323     @HotSpotVMField(name = "CodeBlob::_code_offset", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable private int codeBlobCodeOffsetOffset;
1324     @HotSpotVMField(name = "SharedRuntime::_ic_miss_blob", type = "RuntimeStub*", get = HotSpotVMField.Type.VALUE) @Stable private long inlineCacheMissBlob;
1325 
1326     public long inlineCacheMissStub() {
1327         return inlineCacheMissBlob + unsafe.getInt(inlineCacheMissBlob + codeBlobCodeOffsetOffset);
1328     }
1329 
1330     @HotSpotVMField(name = "CodeCache::_heap", type = "CodeHeap*", get = HotSpotVMField.Type.VALUE) @Stable private long codeCacheHeap;
1331     @HotSpotVMField(name = "CodeHeap::_memory", type = "VirtualSpace", get = HotSpotVMField.Type.OFFSET) @Stable private int codeHeapMemoryOffset;
1332     @HotSpotVMField(name = "VirtualSpace::_low_boundary", type = "char*", get = HotSpotVMField.Type.OFFSET) @Stable private int virtualSpaceLowBoundaryOffset;
1333     @HotSpotVMField(name = "VirtualSpace::_high_boundary", type = "char*", get = HotSpotVMField.Type.OFFSET) @Stable private int virtualSpaceHighBoundaryOffset;
1334 
1335     /**
1336      * @return CodeCache::_heap-&amp;gt;_memory._low_boundary
1337      */
1338     public long codeCacheLowBoundary() {
1339         return unsafe.getAddress(codeCacheHeap + codeHeapMemoryOffset + virtualSpaceLowBoundaryOffset);
1340     }
1341 
1342     /**
1343      * @return CodeCache::_heap-&amp;gt;_memory._high_boundary
1344      */
1345     public long codeCacheHighBoundary() {
1346         return unsafe.getAddress(codeCacheHeap + codeHeapMemoryOffset + virtualSpaceHighBoundaryOffset);
1347     }
1348 
1349     @Stable public long handleDeoptStub;
1350     @Stable public long uncommonTrapStub;
1351 
1352     @HotSpotVMField(name = "StubRoutines::_aescrypt_encryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptEncryptBlockStub;
1353     @HotSpotVMField(name = "StubRoutines::_aescrypt_decryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptDecryptBlockStub;
1354     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_encryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingEncryptAESCryptStub;
1355     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_decryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingDecryptAESCryptStub;
1356     @HotSpotVMField(name = "StubRoutines::_updateBytesCRC32", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long updateBytesCRC32Stub;
1357     @HotSpotVMField(name = "StubRoutines::_crc_table_adr", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long crcTableAddress;
1358 
1359     @HotSpotVMField(name = "StubRoutines::_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteArraycopy;
1360     @HotSpotVMField(name = "StubRoutines::_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortArraycopy;
1361     @HotSpotVMField(name = "StubRoutines::_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintArraycopy;
1362     @HotSpotVMField(name = "StubRoutines::_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongArraycopy;
1363     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopy;
1364     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopyUninit;
1365     @HotSpotVMField(name = "StubRoutines::_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteDisjointArraycopy;
1366     @HotSpotVMField(name = "StubRoutines::_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortDisjointArraycopy;
1367     @HotSpotVMField(name = "StubRoutines::_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintDisjointArraycopy;
1368     @HotSpotVMField(name = "StubRoutines::_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongDisjointArraycopy;
1369     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopy;
1370     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopyUninit;
1371     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedArraycopy;
1372     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedArraycopy;
1373     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedArraycopy;
1374     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedArraycopy;
1375     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long alignedOopAlignedArraycopy;
1376     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long alignedOopArraycopyUninit;
1377     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedDisjointArraycopy;
1378     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedDisjointArraycopy;
1379     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedDisjointArraycopy;
1380     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedDisjointArraycopy;
1381     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long alignedOopDisjointArraycopy;
1382     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long alignedOopDisjointArraycopyUninit;
1383     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopy;
1384     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopyUninit;
1385     @HotSpotVMField(name = "StubRoutines::_unsafe_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long unsafeArraycopy;
1386     @HotSpotVMField(name = "StubRoutines::_generic_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long genericArraycopy;
1387 
1388     @Stable public long newInstanceAddress;
1389     @Stable public long newArrayAddress;
1390     @Stable public long newMultiArrayAddress;
1391     @Stable public long dynamicNewArrayAddress;
1392     @Stable public long dynamicNewInstanceAddress;
1393     @Stable public long registerFinalizerAddress;
1394     @Stable public long threadIsInterruptedAddress;
1395     @Stable public long vmMessageAddress;
1396     @Stable public long identityHashCodeAddress;
1397     @Stable public long exceptionHandlerForPcAddress;
1398     @Stable public long exceptionHandlerForReturnAddressAddress;
1399     @Stable public long osrMigrationEndAddress;
1400     @Stable public long monitorenterAddress;
1401     @Stable public long monitorexitAddress;
1402     @Stable public long createNullPointerExceptionAddress;
1403     @Stable public long createOutOfBoundsExceptionAddress;
1404     @Stable public long logPrimitiveAddress;
1405     @Stable public long logObjectAddress;
1406     @Stable public long logPrintfAddress;
1407     @Stable public long vmErrorAddress;
1408     @Stable public long writeBarrierPreAddress;
1409     @Stable public long writeBarrierPostAddress;
1410     @Stable public long validateObject;
1411     @Stable public long javaTimeMillisAddress;
1412     @Stable public long javaTimeNanosAddress;
1413     @Stable public long arithmeticSinAddress;
1414     @Stable public long arithmeticCosAddress;
1415     @Stable public long arithmeticTanAddress;
1416     @Stable public long loadAndClearExceptionAddress;
1417 
1418     @Stable public int graalCountersSize;
1419 
1420     @HotSpotVMConstant(name = "Deoptimization::Reason_none") @Stable public int deoptReasonNone;
1421     @HotSpotVMConstant(name = "Deoptimization::Reason_null_check") @Stable public int deoptReasonNullCheck;
1422     @HotSpotVMConstant(name = "Deoptimization::Reason_range_check") @Stable public int deoptReasonRangeCheck;
1423     @HotSpotVMConstant(name = "Deoptimization::Reason_class_check") @Stable public int deoptReasonClassCheck;
1424     @HotSpotVMConstant(name = "Deoptimization::Reason_array_check") @Stable public int deoptReasonArrayCheck;
1425     @HotSpotVMConstant(name = "Deoptimization::Reason_null_assert") @Stable public int deoptReasonUnreached0;
1426     @HotSpotVMConstant(name = "Deoptimization::Reason_intrinsic") @Stable public int deoptReasonTypeCheckInlining;
1427     @HotSpotVMConstant(name = "Deoptimization::Reason_bimorphic") @Stable public int deoptReasonOptimizedTypeCheck;
1428     @HotSpotVMConstant(name = "Deoptimization::Reason_unhandled") @Stable public int deoptReasonNotCompiledExceptionHandler;
1429     @HotSpotVMConstant(name = "Deoptimization::Reason_uninitialized") @Stable public int deoptReasonUnresolved;
1430     @HotSpotVMConstant(name = "Deoptimization::Reason_age") @Stable public int deoptReasonJsrMismatch;
1431     @HotSpotVMConstant(name = "Deoptimization::Reason_div0_check") @Stable public int deoptReasonDiv0Check;
1432     @HotSpotVMConstant(name = "Deoptimization::Reason_constraint") @Stable public int deoptReasonConstraint;
1433     @HotSpotVMConstant(name = "Deoptimization::Reason_loop_limit_check") @Stable public int deoptReasonLoopLimitCheck;
1434     @HotSpotVMConstant(name = "Deoptimization::Reason_aliasing") @Stable public int deoptReasonAliasing;
1435     @HotSpotVMConstant(name = "Deoptimization::Reason_LIMIT") @Stable public int deoptReasonOSROffset;
1436 
1437     @HotSpotVMConstant(name = "Deoptimization::Action_none") @Stable public int deoptActionNone;
1438     @HotSpotVMConstant(name = "Deoptimization::Action_maybe_recompile") @Stable public int deoptActionMaybeRecompile;
1439     @HotSpotVMConstant(name = "Deoptimization::Action_reinterpret") @Stable public int deoptActionReinterpret;
1440     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_entrant") @Stable public int deoptActionMakeNotEntrant;
1441     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_compilable") @Stable public int deoptActionMakeNotCompilable;
1442 
1443     @HotSpotVMConstant(name = "Deoptimization::_action_bits") @Stable public int deoptimizationActionBits;
1444     @HotSpotVMConstant(name = "Deoptimization::_reason_bits") @Stable public int deoptimizationReasonBits;
1445     @HotSpotVMConstant(name = "Deoptimization::_debug_id_bits") @Stable public int deoptimizationDebugIdBits;
1446     @HotSpotVMConstant(name = "Deoptimization::_action_shift") @Stable public int deoptimizationActionShift;
1447     @HotSpotVMConstant(name = "Deoptimization::_reason_shift") @Stable public int deoptimizationReasonShift;
1448     @HotSpotVMConstant(name = "Deoptimization::_debug_id_shift") @Stable public int deoptimizationDebugIdShift;
1449 
1450     @HotSpotVMConstant(name = "vmIntrinsics::_invokeBasic") @Stable public int vmIntrinsicInvokeBasic;
1451     @HotSpotVMConstant(name = "vmIntrinsics::_linkToVirtual") @Stable public int vmIntrinsicLinkToVirtual;
1452     @HotSpotVMConstant(name = "vmIntrinsics::_linkToStatic") @Stable public int vmIntrinsicLinkToStatic;
1453     @HotSpotVMConstant(name = "vmIntrinsics::_linkToSpecial") @Stable public int vmIntrinsicLinkToSpecial;
1454     @HotSpotVMConstant(name = "vmIntrinsics::_linkToInterface") @Stable public int vmIntrinsicLinkToInterface;
1455 
1456     @HotSpotVMConstant(name = "GraalEnv::ok") @Stable public int codeInstallResultOk;
1457     @HotSpotVMConstant(name = "GraalEnv::dependencies_failed") @Stable public int codeInstallResultDependenciesFailed;
1458     @HotSpotVMConstant(name = "GraalEnv::cache_full") @Stable public int codeInstallResultCacheFull;
1459     @HotSpotVMConstant(name = "GraalEnv::code_too_large") @Stable public int codeInstallResultCodeTooLarge;
1460 
1461     @HotSpotVMConstant(name = "CompilerToVM::KLASS_TAG") @Stable public int compilerToVMKlassTag;
1462     @HotSpotVMConstant(name = "CompilerToVM::SYMBOL_TAG") @Stable public int compilerToVMSymbolTag;
1463 
1464     @HotSpotVMConstant(name = "CodeInstaller::VERIFIED_ENTRY") @Stable public int codeInstallerMarkIdVerifiedEntry;
1465     @HotSpotVMConstant(name = "CodeInstaller::UNVERIFIED_ENTRY") @Stable public int codeInstallerMarkIdUnverifiedEntry;
1466     @HotSpotVMConstant(name = "CodeInstaller::OSR_ENTRY") @Stable public int codeInstallerMarkIdOsrEntry;
1467     @HotSpotVMConstant(name = "CodeInstaller::EXCEPTION_HANDLER_ENTRY") @Stable public int codeInstallerMarkIdExceptionHandlerEntry;
1468     @HotSpotVMConstant(name = "CodeInstaller::DEOPT_HANDLER_ENTRY") @Stable public int codeInstallerMarkIdDeoptHandlerEntry;
1469     @HotSpotVMConstant(name = "CodeInstaller::INVOKEINTERFACE") @Stable public int codeInstallerMarkIdInvokeinterface;
1470     @HotSpotVMConstant(name = "CodeInstaller::INVOKEVIRTUAL") @Stable public int codeInstallerMarkIdInvokevirtual;
1471     @HotSpotVMConstant(name = "CodeInstaller::INVOKESTATIC") @Stable public int codeInstallerMarkIdInvokestatic;
1472     @HotSpotVMConstant(name = "CodeInstaller::INVOKESPECIAL") @Stable public int codeInstallerMarkIdInvokespecial;
1473     @HotSpotVMConstant(name = "CodeInstaller::INLINE_INVOKE") @Stable public int codeInstallerMarkIdInlineInvoke;
1474     @HotSpotVMConstant(name = "CodeInstaller::POLL_NEAR") @Stable public int codeInstallerMarkIdPollNear;
1475     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_NEAR") @Stable public int codeInstallerMarkIdPollReturnNear;
1476     @HotSpotVMConstant(name = "CodeInstaller::POLL_FAR") @Stable public int codeInstallerMarkIdPollFar;
1477     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_FAR") @Stable public int codeInstallerMarkIdPollReturnFar;
1478     @HotSpotVMConstant(name = "CodeInstaller::INVOKE_INVALID") @Stable public int codeInstallerMarkIdInvokeInvalid;
1479 
1480     public boolean check() {
1481         for (Field f : getClass().getDeclaredFields()) {
1482             int modifiers = f.getModifiers();
1483             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
1484                 assert Modifier.isFinal(modifiers) || f.getAnnotation(Stable.class) != null : "field should either be final or @Stable: " + f;
1485             }
1486         }
1487 
1488         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
1489         assert (layoutHelperArrayTagObjectValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "object array must have first bit set";
1490         assert (layoutHelperArrayTagTypeValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "type array must have first bit set";
1491 
1492         return true;
1493     }
1494 
1495     /**
1496      * A compact representation of the different encoding strategies for Objects and metadata.
1497      */
1498     public static class CompressEncoding {
1499         public final long base;
1500         public final int shift;
1501         public final int alignment;
1502 
1503         CompressEncoding(long base, int shift, int alignment) {
1504             this.base = base;
1505             this.shift = shift;
1506             this.alignment = alignment;
1507         }
1508 
1509         public int compress(long ptr) {
1510             if (ptr == 0L) {
1511                 return 0;
1512             } else {
1513                 return (int) ((ptr - base) &gt;&gt;&gt; shift);
1514             }
1515         }
1516 
1517         public long uncompress(int ptr) {
1518             if (ptr == 0) {
1519                 return 0L;
1520             } else {
1521                 return ((ptr &amp; 0xFFFFFFFFL) &lt;&lt; shift) + base;
1522             }
1523         }
1524 
1525         @Override
1526         public String toString() {
1527             return "base: " + base + " shift: " + shift + " alignment: " + alignment;
1528         }
1529 
1530         @Override
1531         public int hashCode() {
1532             final int prime = 31;
1533             int result = 1;
1534             result = prime * result + alignment;
1535             result = prime * result + (int) (base ^ (base &gt;&gt;&gt; 32));
1536             result = prime * result + shift;
1537             return result;
1538         }
1539 
1540         @Override
1541         public boolean equals(Object obj) {
1542             if (obj instanceof CompressEncoding) {
1543                 CompressEncoding other = (CompressEncoding) obj;
1544                 return alignment == other.alignment &amp;&amp; base == other.base &amp;&amp; shift == other.shift;
1545             } else {
1546                 return false;
1547             }
1548         }
1549     }
1550 }
</pre></body></html>
