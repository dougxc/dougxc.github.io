<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package com.oracle.graal.hotspot.hsail;
  24 
  25 import static com.oracle.graal.api.code.CallingConvention.Type.*;
  26 import static com.oracle.graal.api.code.CodeUtil.*;
  27 import static com.oracle.graal.api.code.ValueUtil.*;
  28 import static com.oracle.graal.api.meta.LocationIdentity.*;
  29 import static com.oracle.graal.compiler.GraalCompiler.*;
  30 
  31 import java.lang.reflect.*;
  32 import java.util.*;
  33 
  34 import com.amd.okra.*;
  35 import com.oracle.graal.api.code.*;
  36 import com.oracle.graal.api.code.Assumptions.Assumption;
  37 import com.oracle.graal.api.code.CallingConvention.Type;
  38 import com.oracle.graal.api.code.CompilationResult.Call;
  39 import com.oracle.graal.api.code.CompilationResult.CodeAnnotation;
  40 import com.oracle.graal.api.code.CompilationResult.DataPatch;
  41 import com.oracle.graal.api.code.CompilationResult.ExceptionHandler;
  42 import com.oracle.graal.api.code.CompilationResult.Infopoint;
  43 import com.oracle.graal.api.code.CompilationResult.Mark;
  44 import com.oracle.graal.api.meta.*;
  45 import com.oracle.graal.asm.*;
  46 import com.oracle.graal.asm.hsail.*;
  47 import com.oracle.graal.compiler.gen.*;
  48 import com.oracle.graal.debug.*;
  49 import com.oracle.graal.debug.Debug.Scope;
  50 import com.oracle.graal.gpu.*;
  51 import com.oracle.graal.graph.*;
  52 import com.oracle.graal.hotspot.*;
  53 import com.oracle.graal.hotspot.bridge.CompilerToVM.CodeInstallResult;
  54 import com.oracle.graal.hotspot.meta.*;
  55 import com.oracle.graal.hotspot.nodes.*;
  56 import com.oracle.graal.hsail.*;
  57 import com.oracle.graal.java.*;
  58 import com.oracle.graal.lir.*;
  59 import com.oracle.graal.lir.asm.*;
  60 import com.oracle.graal.lir.hsail.*;
<a name="1" id="anc1"></a><span class="new">  61 import com.oracle.graal.lir.hsail.HSAILMove.AtomicGetAndAddOp;</span>
  62 import com.oracle.graal.lir.hsail.HSAILControlFlow.DeoptimizeOp;
  63 import com.oracle.graal.nodes.*;
<a name="2" id="anc2"></a><span class="new">  64 import com.oracle.graal.nodes.cfg.*;</span>
  65 import com.oracle.graal.nodes.StructuredGraph.GuardsStage;
  66 import com.oracle.graal.nodes.calc.*;
  67 import com.oracle.graal.nodes.extended.*;
  68 import com.oracle.graal.nodes.java.*;
  69 import com.oracle.graal.nodes.type.*;
<a name="3" id="anc3"></a><span class="new">  70 import com.oracle.graal.options.*;</span>
  71 import com.oracle.graal.phases.*;
  72 import com.oracle.graal.phases.tiers.*;
  73 
<a name="4" id="anc4"></a><span class="new">  74 import static com.oracle.graal.hotspot.hsail.HSAILHotSpotBackend.Options.*;</span>
<span class="new">  75 import static com.oracle.graal.hotspot.hsail.replacements.HSAILNewObjectSnippets.Options.*;</span>
<span class="new">  76 </span>
  77 /**
  78  * HSAIL specific backend.
  79  */
  80 public class HSAILHotSpotBackend extends HotSpotBackend {
  81 
<a name="5" id="anc5"></a><span class="new">  82     public static class Options {</span>
<span class="new">  83 </span>
<span class="new">  84         // @formatter:off</span>
<span class="new">  85         @Option(help = "Number of donor threads for HSAIL kernel dispatch")</span>
<span class="new">  86         static public final OptionValue&lt;Integer&gt; HsailDonorThreads = new OptionValue&lt;&gt;(4);</span>
<span class="new">  87         // @formatter:on</span>
<span class="new">  88     }</span>
<span class="new">  89 </span>
  90     private Map&lt;String, String&gt; paramTypeMap = new HashMap&lt;&gt;();
  91     private final boolean deviceInitialized;
  92     // TODO: get maximum Concurrency from okra
  93     private int maxDeoptIndex = 8 * 40 * 64;   // see gpu_hsail.hpp
  94 
  95     public HSAILHotSpotBackend(HotSpotGraalRuntime runtime, HotSpotProviders providers) {
  96         super(runtime, providers);
  97         paramTypeMap.put("HotSpotResolvedPrimitiveType&lt;int&gt;", "s32");
  98         paramTypeMap.put("HotSpotResolvedPrimitiveType&lt;float&gt;", "f32");
  99         paramTypeMap.put("HotSpotResolvedPrimitiveType&lt;double&gt;", "f64");
 100         paramTypeMap.put("HotSpotResolvedPrimitiveType&lt;long&gt;", "s64");
 101 
 102         // The order of the conjunction below is important: the OkraUtil
 103         // call may provision the native library required by the initialize() call
 104         deviceInitialized = OkraUtil.okraLibExists() &amp;&amp; initialize();
 105     }
 106 
 107     @Override
 108     public boolean shouldAllocateRegisters() {
 109         return true;
 110     }
 111 
 112     /**
 113      * Initializes the GPU device.
 114      *
 115      * @return whether or not initialization was successful
 116      */
 117     private static native boolean initialize();
 118 
 119     /**
<a name="6" id="anc6"></a>











 120      * Determines if the GPU device (or simulator) is available and initialized.
 121      */
 122     public boolean isDeviceInitialized() {
 123         return deviceInitialized;
 124     }
 125 
 126     /**
 127      * Completes the initialization of the HSAIL backend. This includes initializing the providers
 128      * and registering any method substitutions specified by the HSAIL backend.
 129      */
 130     @Override
 131     public void completeInitialization() {
 132         final HotSpotProviders providers = getProviders();
 133         HotSpotVMConfig config = getRuntime().getConfig();
 134         // Initialize the lowering provider.
 135         final HotSpotLoweringProvider lowerer = (HotSpotLoweringProvider) providers.getLowerer();
 136         lowerer.initialize(providers, config);
 137 
 138         // Register the replacements used by the HSAIL backend.
 139         HSAILHotSpotReplacementsImpl replacements = (HSAILHotSpotReplacementsImpl) providers.getReplacements();
 140         replacements.completeInitialization();
 141     }
 142 
 143     /**
 144      * Compiles and installs a given method to a GPU binary.
 145      */
 146     public HotSpotNmethod compileAndInstallKernel(Method method) {
 147         ResolvedJavaMethod javaMethod = getProviders().getMetaAccess().lookupJavaMethod(method);
 148         return installKernel(javaMethod, compileKernel(javaMethod, true));
 149     }
 150 
 151     /**
 152      * Compiles a given method to HSAIL code.
 153      *
 154      * @param makeBinary specifies whether a GPU binary should also be generated for the HSAIL code.
 155      *            If true, the returned value is guaranteed to have a non-zero
 156      *            {@linkplain ExternalCompilationResult#getEntryPoint() entry point}.
 157      * @return the HSAIL code compiled from {@code method}'s bytecode
 158      */
 159     public ExternalCompilationResult compileKernel(ResolvedJavaMethod method, boolean makeBinary) {
 160         StructuredGraph graph = new StructuredGraph(method);
 161         HotSpotProviders providers = getProviders();
 162         MetaAccessProvider metaAccess = getProviders().getMetaAccess();
 163 
 164         // changed this from default to help us generate deopts when needed
 165         OptimisticOptimizations optimisticOpts = OptimisticOptimizations.ALL;
 166         optimisticOpts.remove(OptimisticOptimizations.Optimization.UseExceptionProbabilityForOperations);
 167         new GraphBuilderPhase.Instance(metaAccess, GraphBuilderConfiguration.getSnippetDefault(), optimisticOpts).apply(graph);
 168         PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = providers.getSuites().getDefaultGraphBuilderSuite();
 169         CallingConvention cc = getCallingConvention(providers.getCodeCache(), Type.JavaCallee, graph.method(), false);
 170 
 171         // append special HSAILNonNullParametersPhase
 172         int numArgs = cc.getArguments().length;
 173         graphBuilderSuite.appendPhase(new HSAILNonNullParametersPhase(numArgs));
 174 
 175         Suites suites = providers.getSuites().getDefaultSuites();
 176         ExternalCompilationResult hsailCode = compileGraph(graph, null, cc, method, providers, this, this.getTarget(), null, graphBuilderSuite, optimisticOpts, getProfilingInfo(graph), null, suites,
 177                         new ExternalCompilationResult(), CompilationResultBuilderFactory.Default);
 178 
 179         // this code added to dump infopoints
 180         try (Scope s = Debug.scope("CodeGen")) {
 181             if (Debug.isLogEnabled()) {
 182                 // show infopoints
 183                 List&lt;Infopoint&gt; infoList = hsailCode.getInfopoints();
 184                 Debug.log("%d HSAIL infopoints", infoList.size());
 185                 for (Infopoint info : infoList) {
 186                     Debug.log(info.toString());
 187                     Debug.log(info.debugInfo.frame().toString());
 188                 }
 189             }
 190         } catch (Throwable e) {
 191             throw Debug.handle(e);
 192         }
 193 
 194         if (makeBinary) {
 195             if (!deviceInitialized) {
 196                 throw new GraalInternalError("Cannot generate GPU kernel if device is not initialized");
 197             }
 198             try (Scope ds = Debug.scope("GeneratingKernelBinary")) {
 199                 long kernel = generateKernel(hsailCode.getTargetCode(), method.getName());
 200                 if (kernel == 0) {
 201                     throw new GraalInternalError("Failed to compile HSAIL kernel");
 202                 }
 203                 hsailCode.setEntryPoint(kernel);
 204             } catch (Throwable e) {
 205                 throw Debug.handle(e);
 206             }
 207         }
 208         return hsailCode;
 209     }
 210 
 211     private static class HSAILNonNullParametersPhase extends Phase {
 212         // we use this to limit the stamping to exclude the final argument in an obj stream method
 213         private int numArgs;
 214 
 215         public HSAILNonNullParametersPhase(int numArgs) {
 216             this.numArgs = numArgs;
 217         }
 218 
 219         @Override
 220         protected void run(StructuredGraph graph) {
 221             int argCount = 0;
 222             for (ParameterNode param : graph.getNodes(ParameterNode.class)) {
 223                 argCount++;
 224                 if (argCount &lt; numArgs &amp;&amp; param.stamp() instanceof ObjectStamp) {
 225                     param.setStamp(StampFactory.declaredNonNull(((ObjectStamp) param.stamp()).type()));
 226                 }
 227             }
 228         }
 229     }
 230 
 231     /**
 232      * Generates a GPU binary from HSAIL code.
 233      */
 234     private static native long generateKernel(byte[] hsailCode, String name);
 235 
 236     /**
 237      * Installs the {@linkplain ExternalCompilationResult#getEntryPoint() GPU binary} associated
 238      * with some given HSAIL code in the code cache and returns a {@link HotSpotNmethod} handle to
 239      * the installed code.
 240      *
 241      * @param hsailCode HSAIL compilation result for which a GPU binary has been generated
 242      * @return a handle to the binary as installed in the HotSpot code cache
 243      */
 244     public final HotSpotNmethod installKernel(ResolvedJavaMethod method, ExternalCompilationResult hsailCode) {
 245         assert hsailCode.getEntryPoint() != 0L;
 246         // code below here lifted from HotSpotCodeCacheProviders.addExternalMethod
 247         // used to be return getProviders().getCodeCache().addExternalMethod(method, hsailCode);
 248         HotSpotResolvedJavaMethod javaMethod = (HotSpotResolvedJavaMethod) method;
 249         if (hsailCode.getId() == -1) {
 250             hsailCode.setId(javaMethod.allocateCompileId(hsailCode.getEntryBCI()));
 251         }
 252         CompilationResult compilationResult = hsailCode;
 253         StructuredGraph hostGraph = hsailCode.getHostGraph();
 254         if (hostGraph != null) {
 255             // TODO get rid of the unverified entry point in the host code
 256             try (Scope ds = Debug.scope("GeneratingHostGraph")) {
 257                 HotSpotBackend hostBackend = getRuntime().getHostBackend();
 258                 JavaType[] parameterTypes = new JavaType[hostGraph.getNodes(ParameterNode.class).count()];
 259                 Debug.log("Param count: %d", parameterTypes.length);
 260                 for (int i = 0; i &lt; parameterTypes.length; i++) {
 261                     ParameterNode parameter = hostGraph.getParameter(i);
<a name="7" id="anc7"></a><span class="changed"> 262                     Debug.log("Param [%d]=%s", i, parameter);</span>
 263                     parameterTypes[i] = parameter.stamp().javaType(hostBackend.getProviders().getMetaAccess());
 264                     Debug.log(" %s", parameterTypes[i]);
 265                 }
 266                 CallingConvention cc = hostBackend.getProviders().getCodeCache().getRegisterConfig().getCallingConvention(Type.JavaCallee, method.getSignature().getReturnType(null), parameterTypes,
 267                                 hostBackend.getTarget(), false);
 268                 CompilationResult hostCode = compileGraph(hostGraph, null, cc, method, hostBackend.getProviders(), hostBackend, this.getTarget(), null,
 269                                 hostBackend.getProviders().getSuites().getDefaultGraphBuilderSuite(), OptimisticOptimizations.NONE, null, null,
 270                                 hostBackend.getProviders().getSuites().getDefaultSuites(), new CompilationResult(), CompilationResultBuilderFactory.Default);
 271                 compilationResult = merge(hostCode, hsailCode);
 272             } catch (Throwable e) {
 273                 throw Debug.handle(e);
 274             }
 275         }
 276 
 277         HotSpotNmethod code = new HotSpotNmethod(javaMethod, hsailCode.getName(), false, true);
 278         HotSpotCompiledNmethod compiled = new HotSpotCompiledNmethod(getTarget(), javaMethod, compilationResult);
 279         CodeInstallResult result = getRuntime().getCompilerToVM().installCode(compiled, code, null);
 280         if (result != CodeInstallResult.OK) {
 281             return null;
 282         }
 283         return code;
 284     }
 285 
 286     private static ExternalCompilationResult merge(CompilationResult hostCode, ExternalCompilationResult hsailCode) {
 287         ExternalCompilationResult result = new ExternalCompilationResult();
 288 
 289         // from hsail code
 290         result.setEntryPoint(hsailCode.getEntryPoint());
 291         result.setId(hsailCode.getId());
 292         result.setEntryBCI(hsailCode.getEntryBCI());
 293         assert hsailCode.getMarks().isEmpty();
 294         assert hsailCode.getExceptionHandlers().isEmpty();
 295         assert hsailCode.getDataReferences().isEmpty();
 296 
 297         // from host code
 298         result.setFrameSize(hostCode.getFrameSize());
 299         result.setCustomStackAreaOffset(hostCode.getCustomStackAreaOffset());
 300         result.setRegisterRestoreEpilogueOffset(hostCode.getRegisterRestoreEpilogueOffset());
 301         result.setTargetCode(hostCode.getTargetCode(), hostCode.getTargetCodeSize());
 302         for (CodeAnnotation annotation : hostCode.getAnnotations()) {
 303             result.addAnnotation(annotation);
 304         }
 305         CompilationResult.Mark[] noMarks = {};
 306         for (Mark mark : hostCode.getMarks()) {
 307             result.recordMark(mark.pcOffset, mark.id, noMarks);
 308         }
 309         for (ExceptionHandler handler : hostCode.getExceptionHandlers()) {
 310             result.recordExceptionHandler(handler.pcOffset, handler.handlerPos);
 311         }
 312         for (DataPatch patch : hostCode.getDataReferences()) {
 313             if (patch.data != null) {
 314                 if (patch.inline) {
 315                     result.recordInlineData(patch.pcOffset, patch.data);
 316                 } else {
 317                     result.recordDataReference(patch.pcOffset, patch.data);
 318                 }
 319             }
 320         }
 321         for (Infopoint infopoint : hostCode.getInfopoints()) {
 322             if (infopoint instanceof Call) {
 323                 Call call = (Call) infopoint;
 324                 result.recordCall(call.pcOffset, call.size, call.target, call.debugInfo, call.direct);
 325             } else {
 326                 result.recordInfopoint(infopoint.pcOffset, infopoint.debugInfo, infopoint.reason);
 327             }
 328         }
 329 
 330         // merged
 331         Assumptions mergedAssumptions = new Assumptions(true);
 332         if (hostCode.getAssumptions() != null) {
 333             for (Assumption assumption : hostCode.getAssumptions().getAssumptions()) {
 334                 if (assumption != null) {
 335                     mergedAssumptions.record(assumption);
 336                 }
 337             }
 338         }
 339         if (hsailCode.getAssumptions() != null) {
 340             for (Assumption assumption : hsailCode.getAssumptions().getAssumptions()) {
 341                 if (assumption != null) {
 342                     mergedAssumptions.record(assumption);
 343                 }
 344             }
 345         }
 346         if (!mergedAssumptions.isEmpty()) {
 347             result.setAssumptions(mergedAssumptions);
 348         }
 349         return result;
 350     }
 351 
<a name="8" id="anc8"></a><span class="new"> 352     private static final ThreadLocal&lt;DonorThreadPool&gt; donorThreadPool = new ThreadLocal&lt;DonorThreadPool&gt;() {</span>
<span class="new"> 353         @Override</span>
<span class="new"> 354         protected DonorThreadPool initialValue() {</span>
<span class="new"> 355             return new DonorThreadPool();</span>
<span class="new"> 356         }</span>
<span class="new"> 357     };</span>
<span class="new"> 358 </span>
 359     public boolean executeKernel(HotSpotInstalledCode kernel, int jobSize, Object[] args) throws InvalidInstalledCodeException {
 360         if (!deviceInitialized) {
 361             throw new GraalInternalError("Cannot execute GPU kernel if device is not initialized");
 362         }
 363         Object[] oopsSaveArea = new Object[maxDeoptIndex * 16];
<a name="9" id="anc9"></a><span class="changed"> 364         return executeKernel0(kernel, jobSize, args, oopsSaveArea, donorThreadPool.get().getThreads(), HsailAllocBytesPerWorkitem.getValue());</span>
 365     }
 366 
<a name="10" id="anc10"></a><span class="changed"> 367     private static native boolean executeKernel0(HotSpotInstalledCode kernel, int jobSize, Object[] args, Object[] oopsSave, Thread[] donorThreads, int allocBytesPerWorkitem)</span>
<span class="changed"> 368                     throws InvalidInstalledCodeException;</span>
 369 
 370     /**
 371      * Use the HSAIL register set when the compilation target is HSAIL.
 372      */
 373     @Override
 374     public FrameMap newFrameMap(RegisterConfig registerConfig) {
 375         return new HSAILFrameMap(getCodeCache(), registerConfig);
 376     }
 377 
 378     @Override
 379     public LIRGenerator newLIRGenerator(CallingConvention cc, LIRGenerationResult lirGenRes) {
 380         return new HSAILHotSpotLIRGenerator(getProviders(), getRuntime().getConfig(), cc, lirGenRes);
 381     }
 382 
 383     @Override
 384     public LIRGenerationResult newLIRGenerationResult(LIR lir, FrameMap frameMap, Object stub) {
 385         return new HSAILHotSpotLIRGenerationResult(lir, frameMap);
 386     }
 387 
 388     @Override
 389     public NodeLIRBuilder newNodeLIRGenerator(StructuredGraph graph, LIRGenerator lirGen) {
 390         return new HSAILHotSpotNodeLIRBuilder(graph, lirGen);
 391     }
 392 
 393     class HotSpotFrameContext implements FrameContext {
 394 
 395         public boolean hasFrame() {
 396             return true;
 397         }
 398 
 399         @Override
 400         public void enter(CompilationResultBuilder crb) {
 401             Debug.log("Nothing to do here");
 402         }
 403 
 404         @Override
 405         public void leave(CompilationResultBuilder crb) {
 406             Debug.log("Nothing to do here");
 407         }
 408     }
 409 
 410     /**
 411      * a class to allow us to save lirGen.
 412      */
 413     static class HSAILCompilationResultBuilder extends CompilationResultBuilder {
 414         public HSAILHotSpotLIRGenerationResult lirGenRes;
 415 
 416         public HSAILCompilationResultBuilder(CodeCacheProvider codeCache, ForeignCallsProvider foreignCalls, FrameMap frameMap, Assembler asm, FrameContext frameContext,
 417                         CompilationResult compilationResult, HSAILHotSpotLIRGenerationResult lirGenRes) {
 418             super(codeCache, foreignCalls, frameMap, asm, frameContext, compilationResult);
 419             this.lirGenRes = lirGenRes;
 420         }
 421     }
 422 
 423     @Override
 424     protected Assembler createAssembler(FrameMap frameMap) {
 425         return new HSAILHotSpotAssembler(getTarget());
 426     }
 427 
 428     @Override
 429     public CompilationResultBuilder newCompilationResultBuilder(LIRGenerationResult lirGenRes, CompilationResult compilationResult, CompilationResultBuilderFactory factory) {
 430         FrameMap frameMap = lirGenRes.getFrameMap();
 431         Assembler masm = createAssembler(frameMap);
 432         HotSpotFrameContext frameContext = new HotSpotFrameContext();
 433         // save lirGen for later use by setHostGraph
 434         CompilationResultBuilder crb = new HSAILCompilationResultBuilder(getCodeCache(), getForeignCalls(), frameMap, masm, frameContext, compilationResult,
 435                         (HSAILHotSpotLIRGenerationResult) lirGenRes);
 436         crb.setFrameSize(frameMap.frameSize());
 437         return crb;
 438     }
 439 
 440     @Override
 441     public void emitCode(CompilationResultBuilder crb, LIR lir, ResolvedJavaMethod method) {
 442         assert method != null : lir + " is not associated with a method";
<a name="11" id="anc11"></a><span class="new"> 443         Kind wordKind = getProviders().getCodeCache().getTarget().wordKind;</span>
<span class="new"> 444 </span>
<span class="new"> 445         HotSpotVMConfig config = getRuntime().getConfig();</span>
<span class="new"> 446         boolean useHSAILDeoptimization = config.useHSAILDeoptimization;</span>
 447 
<a name="12" id="anc12"></a><span class="changed"> 448         // see what graph nodes we have to see if we are using the thread register</span>
<span class="changed"> 449         // if not, we don't have to emit the code that sets that up</span>
<span class="changed"> 450         // maybe there is a better way to do this?</span>
<span class="changed"> 451         boolean usesThreadRegister = false;</span>
<span class="changed"> 452         search: for (AbstractBlock&lt;?&gt; b : lir.linearScanOrder()) {</span>
<span class="changed"> 453             for (LIRInstruction op : lir.getLIRforBlock(b)) {</span>
<span class="changed"> 454                 if (op instanceof AtomicGetAndAddOp &amp;&amp; ((AtomicGetAndAddOp) op).getAddress().toAddress().getBase() == HSAIL.threadRegister) {</span>
<span class="changed"> 455                     usesThreadRegister = true;</span>
<span class="changed"> 456                     assert useHSAILDeoptimization : "cannot use thread register if HSAIL deopt support is disabled";</span>
<span class="changed"> 457                     break search;</span>
<span class="changed"> 458                 }</span>
<span class="changed"> 459             }</span>
<span class="changed"> 460         }</span>
 461 
 462         // Emit the prologue.
 463         HSAILAssembler asm = (HSAILAssembler) crb.asm;
 464         asm.emitString0("version 0:95: $full : $large;\n");
 465 
 466         Signature signature = method.getSignature();
 467         int sigParamCount = signature.getParameterCount(false);
 468         // We're subtracting 1 because we're not making the final gid as a parameter.
 469 
 470         int nonConstantParamCount = sigParamCount - 1;
 471         boolean isStatic = (Modifier.isStatic(method.getModifiers()));
 472         // Determine if this is an object lambda.
 473         boolean isObjectLambda = true;
 474 
 475         if (signature.getParameterType(nonConstantParamCount, null).getKind() == Kind.Int) {
 476             isObjectLambda = false;
 477         } else {
 478             // Add space for gid int reg.
 479             nonConstantParamCount++;
 480         }
 481 
 482         // If this is an instance method, include mappings for the "this" parameter
 483         // as the first parameter.
 484         if (!isStatic) {
 485             nonConstantParamCount++;
 486         }
 487         // Add in any "constant" parameters (currently none).
 488         int totalParamCount = nonConstantParamCount;
 489         JavaType[] paramtypes = new JavaType[totalParamCount];
 490         String[] paramNames = new String[totalParamCount];
 491         int pidx = 0;
 492         MetaAccessProvider metaAccess = getProviders().getMetaAccess();
 493         for (int i = 0; i &lt; totalParamCount; i++) {
 494             if (i == 0 &amp;&amp; !isStatic) {
 495                 paramtypes[i] = metaAccess.lookupJavaType(Object.class);
 496                 paramNames[i] = "%_this";
 497             } else if (i &lt; nonConstantParamCount) {
 498                 if (isObjectLambda &amp;&amp; (i == (nonConstantParamCount))) {
 499                     // Set up the gid register mapping.
 500                     paramtypes[i] = metaAccess.lookupJavaType(int.class);
 501                     paramNames[i] = "%_gid";
 502                 } else {
 503                     paramtypes[i] = signature.getParameterType(pidx++, null);
 504                     paramNames[i] = "%_arg" + i;
 505                 }
 506             }
 507         }
 508 
 509         asm.emitString0("// " + (isStatic ? "static" : "instance") + " method " + method + "\n");
 510         asm.emitString0("kernel &amp;run ( \n");
 511 
 512         FrameMap frameMap = crb.frameMap;
 513         RegisterConfig regConfig = frameMap.registerConfig;
 514         // Build list of param types which does include the gid (for cc register mapping query).
 515         JavaType[] ccParamTypes = new JavaType[nonConstantParamCount + 1];
 516         // Include the gid.
 517         System.arraycopy(paramtypes, 0, ccParamTypes, 0, nonConstantParamCount);
 518 
 519         // Last entry is always int (its register gets used in the workitemabsid instruction)
 520         // this is true even for object stream labmdas
 521         if (sigParamCount &gt; 0) {
 522             ccParamTypes[ccParamTypes.length - 1] = metaAccess.lookupJavaType(int.class);
 523         }
 524         CallingConvention cc = regConfig.getCallingConvention(JavaCallee, null, ccParamTypes, getTarget(), false);
 525 
 526         /**
 527          * Compute the hsail size mappings up to but not including the last non-constant parameter
 528          * (which is the gid).
 529          *
 530          */
 531         String[] paramHsailSizes = new String[totalParamCount];
 532         for (int i = 0; i &lt; totalParamCount; i++) {
 533             String paramtypeStr = paramtypes[i].toString();
 534             String sizeStr = paramTypeMap.get(paramtypeStr);
 535             // Catch all for any unmapped paramtype that is u64 (address of an object).
 536             paramHsailSizes[i] = (sizeStr != null ? sizeStr : "u64");
 537         }
 538         // Emit the kernel function parameters.
 539         for (int i = 0; i &lt; totalParamCount; i++) {
 540             String str = "align 8 kernarg_" + paramHsailSizes[i] + " " + paramNames[i];
 541 
 542             if (useHSAILDeoptimization || (i != totalParamCount - 1)) {
 543                 str += ",";
 544             }
 545             asm.emitString(str);
 546         }
 547 
 548         if (useHSAILDeoptimization) {
 549             // add in the deoptInfo parameter
 550             asm.emitString("kernarg_u64 " + asm.getDeoptInfoName());
 551         }
 552 
 553         asm.emitString(") {");
 554 
 555         /*
 556          * End of parameters start of prolog code. Emit the load instructions for loading of the
 557          * kernel non-constant parameters into registers. The constant class parameters will not be
 558          * loaded up front but will be loaded as needed.
 559          */
 560         for (int i = 0; i &lt; nonConstantParamCount; i++) {
 561             asm.emitString("ld_kernarg_" + paramHsailSizes[i] + "  " + HSAIL.mapRegister(cc.getArgument(i)) + ", [" + paramNames[i] + "];");
 562         }
 563 
 564         /*
 565          * Emit the workitemaid instruction for loading the hidden gid parameter. This is assigned
 566          * the register as if it were the last of the nonConstant parameters.
 567          */
 568         String workItemReg = "$s" + Integer.toString(asRegister(cc.getArgument(nonConstantParamCount)).encoding());
 569         asm.emitString("workitemabsid_u32 " + workItemReg + ", 0;");
 570 
<a name="13" id="anc13"></a>
 571         final String deoptInProgressLabel = "@LHandleDeoptInProgress";
 572 
 573         if (useHSAILDeoptimization) {
<a name="14" id="anc14"></a><span class="changed"> 574             // Aliases for d16</span>
<span class="changed"> 575             RegisterValue d16_deoptInfo = HSAIL.d16.asValue(wordKind);</span>
<span class="changed"> 576             RegisterValue d16_donorThreads = d16_deoptInfo;</span>
<span class="changed"> 577 </span>
<span class="changed"> 578             // Aliases for d17</span>
<span class="changed"> 579             RegisterValue d17_donorThreadIndex = HSAIL.d17.asValue(wordKind);</span>
<span class="changed"> 580 </span>
<span class="changed"> 581             // Aliases for s34</span>
<span class="changed"> 582             RegisterValue s34_deoptOccurred = HSAIL.s34.asValue(Kind.Int);</span>
<span class="changed"> 583             RegisterValue s34_donorThreadIndex = s34_deoptOccurred;</span>
<span class="changed"> 584 </span>
<span class="changed"> 585             asm.emitLoadKernelArg(d16_deoptInfo, asm.getDeoptInfoName(), "u64");</span>
 586             asm.emitComment("// Check if a deopt has occurred and abort if true before doing any work");
<a name="15" id="anc15"></a><span class="changed"> 587             asm.emitLoadAcquire(s34_deoptOccurred, new HSAILAddressValue(Kind.Int, d16_deoptInfo, config.hsailDeoptOccurredOffset).toAddress());</span>
<span class="changed"> 588             asm.emitCompare(Kind.Int, s34_deoptOccurred, Constant.forInt(0), "ne", false, false);</span>
 589             asm.cbr(deoptInProgressLabel);
<a name="16" id="anc16"></a><span class="new"> 590             // load thread register if needed</span>
<span class="new"> 591             if (usesThreadRegister) {</span>
<span class="new"> 592                 assert HsailDonorThreads.getValue() &gt; 0;</span>
<span class="new"> 593                 asm.emitLoad(wordKind, d16_donorThreads, new HSAILAddressValue(wordKind, d16_deoptInfo, config.hsailDonorThreadsOffset).toAddress());</span>
<span class="new"> 594                 if (HsailDonorThreads.getValue() != 1) {</span>
<span class="new"> 595                     asm.emitComment("// map workitem to a donor thread");</span>
<span class="new"> 596                     asm.emitString(String.format("rem_u32  $%s, %s, %d;", s34_donorThreadIndex.getRegister(), workItemReg, HsailDonorThreads.getValue()));</span>
<span class="new"> 597                     asm.emitConvert(d17_donorThreadIndex, s34_donorThreadIndex, wordKind, Kind.Int);</span>
<span class="new"> 598                     asm.emit("mad", d16_donorThreads, d17_donorThreadIndex, Constant.forInt(8), d16_donorThreads);</span>
<span class="new"> 599                 } else {</span>
<span class="new"> 600                     // workitem is already mapped to solitary donor thread</span>
<span class="new"> 601                 }</span>
<span class="new"> 602                 AllocatableValue threadRegValue = getProviders().getRegisters().getThreadRegister().asValue(wordKind);</span>
<span class="new"> 603                 asm.emitComment("// $" + getProviders().getRegisters().getThreadRegister() + " will point to a donor thread for this workitem");</span>
<span class="new"> 604                 asm.emitLoad(wordKind, threadRegValue, new HSAILAddressValue(wordKind, d16_donorThreads).toAddress());</span>
<span class="new"> 605             }</span>
 606         }
 607 
 608         /*
 609          * Note the logic used for this spillseg size is to leave space and then go back and patch
 610          * in the correct size once we have generated all the instructions. This should probably be
 611          * done in a more robust way by implementing something like asm.insertString.
 612          */
 613         int spillsegDeclarationPosition = asm.position() + 1;
 614         String spillsegTemplate = "align 4 spill_u8 %spillseg[123456];";
 615         asm.emitString(spillsegTemplate);
 616         // Emit object array load prologue here.
 617         if (isObjectLambda) {
<a name="17" id="anc17"></a><span class="changed"> 618             boolean useCompressedOops = config.useCompressedOops;</span>
<span class="changed"> 619             final int arrayElementsOffset = HotSpotGraalRuntime.getArrayBaseOffset(wordKind);</span>
 620             String iterationObjArgReg = HSAIL.mapRegister(cc.getArgument(nonConstantParamCount - 1));
 621             // iterationObjArgReg will be the highest $d register in use (it is the last parameter)
 622             // so tempReg can be the next higher $d register
 623             String tmpReg = "$d" + (asRegister(cc.getArgument(nonConstantParamCount - 1)).encoding() + 1);
 624             // Convert gid to long.
 625             asm.emitString("cvt_u64_s32 " + tmpReg + ", " + workItemReg + "; // Convert gid to long");
 626             // Adjust index for sizeof ref. Where to pull this size from?
 627             asm.emitString("mul_u64 " + tmpReg + ", " + tmpReg + ", " + (useCompressedOops ? 4 : 8) + "; // Adjust index for sizeof ref");
 628             // Adjust for actual data start.
 629             asm.emitString("add_u64 " + tmpReg + ", " + tmpReg + ", " + arrayElementsOffset + "; // Adjust for actual elements data start");
 630             // Add to array ref ptr.
 631             asm.emitString("add_u64 " + tmpReg + ", " + tmpReg + ", " + iterationObjArgReg + "; // Add to array ref ptr");
 632             // Load the object into the parameter reg.
 633             if (useCompressedOops) {
 634 
 635                 // Load u32 into the d 64 reg since it will become an object address
 636                 asm.emitString("ld_global_u32 " + tmpReg + ", " + "[" + tmpReg + "]" + "; // Load compressed ptr from array");
 637 
<a name="18" id="anc18"></a><span class="changed"> 638                 long narrowOopBase = config.narrowOopBase;</span>
<span class="changed"> 639                 long narrowOopShift = config.narrowOopShift;</span>
 640 
 641                 if (narrowOopBase == 0 &amp;&amp; narrowOopShift == 0) {
 642                     // No more calculation to do, mov to target register
 643                     asm.emitString("mov_b64 " + iterationObjArgReg + ", " + tmpReg + "; // no shift or base addition");
 644                 } else {
 645                     if (narrowOopBase == 0) {
 646                         asm.emitString("shl_u64 " + iterationObjArgReg + ", " + tmpReg + ", " + narrowOopShift + "; // do narrowOopShift");
 647                     } else if (narrowOopShift == 0) {
 648                         // not sure if we ever get add with 0 shift but just in case
 649                         asm.emitString("cmp_eq_b1_u64  $c0, " + tmpReg + ", 0x0; // avoid add if compressed is null");
 650                         asm.emitString("add_u64 " + iterationObjArgReg + ", " + tmpReg + ", " + narrowOopBase + "; // add narrowOopBase");
 651                         asm.emitString("cmov_b64 " + iterationObjArgReg + ", $c0, 0x0, " + iterationObjArgReg + "; // avoid add if compressed is null");
 652                     } else {
 653                         asm.emitString("cmp_eq_b1_u64  $c0, " + tmpReg + ", 0x0; // avoid shift-add if compressed is null");
 654                         asm.emitString("mad_u64 " + iterationObjArgReg + ", " + tmpReg + ", " + (1 &lt;&lt; narrowOopShift) + ", " + narrowOopBase + "; // shift and add narrowOopBase");
 655                         asm.emitString("cmov_b64 " + iterationObjArgReg + ", $c0, 0x0, " + iterationObjArgReg + "; // avoid shift-add if compressed is null");
 656                     }
 657                 }
 658 
 659             } else {
 660                 asm.emitString("ld_global_u64 " + iterationObjArgReg + ", " + "[" + tmpReg + "]" + "; // Load from array element into parameter reg");
 661             }
 662         }
 663         // Prologue done, Emit code for the LIR.
 664         crb.emit(lir);
 665         // Now that code is emitted go back and figure out what the upper Bound stack size was.
 666         long maxStackSize = ((HSAILAssembler) crb.asm).upperBoundStackSize();
 667         String spillsegStringFinal;
 668         if (maxStackSize == 0) {
 669             // If no spilling, get rid of spillseg declaration.
 670             char[] array = new char[spillsegTemplate.length()];
 671             Arrays.fill(array, ' ');
 672             spillsegStringFinal = new String(array);
 673         } else {
 674             spillsegStringFinal = spillsegTemplate.replace("123456", String.format("%6d", maxStackSize));
 675         }
 676         asm.emitString(spillsegStringFinal, spillsegDeclarationPosition);
 677         // Emit the epilogue.
 678 
 679         // TODO: keep track of whether we need it
 680         if (useHSAILDeoptimization) {
<a name="19" id="anc19"></a><span class="changed"> 681             final int offsetToDeoptSaveStates = config.hsailSaveStatesOffset0;</span>
<span class="changed"> 682             final int sizeofKernelDeopt = config.hsailSaveStatesOffset1 - config.hsailSaveStatesOffset0;</span>
<span class="changed"> 683             final int offsetToNeverRanArray = config.hsailNeverRanArrayOffset;</span>
<span class="changed"> 684             final int offsetToDeoptNextIndex = config.hsailDeoptNextIndexOffset;</span>
<span class="changed"> 685             final int offsetToDeoptimizationWorkItem = config.hsailDeoptimizationWorkItem;</span>
<span class="changed"> 686             final int offsetToDeoptimizationReason = config.hsailDeoptimizationReason;</span>
<span class="changed"> 687             final int offsetToDeoptimizationFrame = config.hsailDeoptimizationFrame;</span>
<span class="changed"> 688             final int offsetToFramePc = config.hsailFramePcOffset;</span>
<span class="changed"> 689             final int offsetToNumSaves = config.hsailFrameNumSRegOffset;</span>
<span class="changed"> 690             final int offsetToSaveArea = config.hsailFrameSaveAreaOffset;</span>
<span class="changed"> 691 </span>
<span class="changed"> 692             AllocatableValue scratch64 = HSAIL.d16.asValue(wordKind);</span>
<span class="changed"> 693             AllocatableValue cuSaveAreaPtr = HSAIL.d17.asValue(wordKind);</span>
<span class="changed"> 694             AllocatableValue waveMathScratch1 = HSAIL.d18.asValue(wordKind);</span>
<span class="changed"> 695             AllocatableValue waveMathScratch2 = HSAIL.d19.asValue(wordKind);</span>
 696 
 697             AllocatableValue actionAndReasonReg = HSAIL.s32.asValue(Kind.Int);
 698             AllocatableValue codeBufferOffsetReg = HSAIL.s33.asValue(Kind.Int);
 699             AllocatableValue scratch32 = HSAIL.s34.asValue(Kind.Int);
 700             AllocatableValue workidreg = HSAIL.s35.asValue(Kind.Int);
 701             AllocatableValue dregOopMapReg = HSAIL.s39.asValue(Kind.Int);
 702 
 703             HSAILAddress deoptNextIndexAddr = new HSAILAddressValue(Kind.Int, scratch64, offsetToDeoptNextIndex).toAddress();
 704             HSAILAddress neverRanArrayAddr = new HSAILAddressValue(Kind.Int, scratch64, offsetToNeverRanArray).toAddress();
 705 
 706             // The just-started lanes that see the deopt flag will jump here
 707             asm.emitString0(deoptInProgressLabel + ":\n");
<a name="20" id="anc20"></a><span class="changed"> 708             asm.emitLoad(wordKind, waveMathScratch1, neverRanArrayAddr);</span>
 709             asm.emitWorkItemAbsId(workidreg);
<a name="21" id="anc21"></a><span class="changed"> 710             asm.emitConvert(waveMathScratch2, workidreg, wordKind, Kind.Int);</span>
 711             asm.emit("add", waveMathScratch1, waveMathScratch1, waveMathScratch2);
 712             HSAILAddress neverRanStoreAddr = new HSAILAddressValue(Kind.Byte, waveMathScratch1, 0).toAddress();
 713             asm.emitStore(Kind.Byte, Constant.forInt(1), neverRanStoreAddr);
 714             asm.emitString("ret;");
 715 
 716             // The deoptimizing lanes will jump here
 717             asm.emitString0(asm.getDeoptLabelName() + ":\n");
 718             String labelExit = asm.getDeoptLabelName() + "_Exit";
 719 
<a name="22" id="anc22"></a><span class="changed"> 720             HSAILAddress deoptInfoAddr = new HSAILAddressValue(Kind.Int, scratch64, config.hsailDeoptOccurredOffset).toAddress();</span>
 721             asm.emitLoadKernelArg(scratch64, asm.getDeoptInfoName(), "u64");
 722 
 723             // Set deopt occurred flag
 724             asm.emitMov(Kind.Int, scratch32, Constant.forInt(1));
 725             asm.emitStoreRelease(scratch32, deoptInfoAddr);
 726 
 727             asm.emitComment("// Determine next deopt save slot");
 728             asm.emitAtomicAdd(scratch32, deoptNextIndexAddr, Constant.forInt(1));
 729             // scratch32 now holds next index to use
 730             // set error condition if no room in save area
 731             asm.emitComment("// assert room to save deopt");
 732             asm.emitCompare(Kind.Int, scratch32, Constant.forInt(maxDeoptIndex), "lt", false, false);
 733             asm.cbr("@L_StoreDeopt");
 734             // if assert fails, store a guaranteed negative workitemid in top level deopt occurred
 735             // flag
 736             asm.emitWorkItemAbsId(scratch32);
 737             asm.emit("mad", scratch32, scratch32, Constant.forInt(-1), Constant.forInt(-1));
 738             asm.emitStore(scratch32, deoptInfoAddr);
 739             asm.emitString("ret;");
 740 
 741             asm.emitString0("@L_StoreDeopt" + ":\n");
 742 
 743             // Store deopt for this workitem into its slot in the HSAILComputeUnitSaveStates array
 744 
 745             asm.emitComment("// Convert id's for ptr math");
<a name="23" id="anc23"></a><span class="changed"> 746             asm.emitConvert(cuSaveAreaPtr, scratch32, wordKind, Kind.Int);</span>
 747             asm.emitComment("// multiply by sizeof KernelDeoptArea");
 748             asm.emit("mul", cuSaveAreaPtr, cuSaveAreaPtr, Constant.forInt(sizeofKernelDeopt));
 749             asm.emitComment("// Add computed offset to deoptInfoPtr base");
 750             asm.emit("add", cuSaveAreaPtr, cuSaveAreaPtr, scratch64);
 751             // Add offset to _deopt_save_states[0]
 752             asm.emit("add", scratch64, cuSaveAreaPtr, Constant.forInt(offsetToDeoptSaveStates));
 753 
 754             HSAILAddress workItemAddr = new HSAILAddressValue(Kind.Int, scratch64, offsetToDeoptimizationWorkItem).toAddress();
 755             HSAILAddress actionReasonStoreAddr = new HSAILAddressValue(Kind.Int, scratch64, offsetToDeoptimizationReason).toAddress();
 756 
 757             asm.emitComment("// Get _deopt_info._first_frame");
 758             asm.emit("add", waveMathScratch1, scratch64, Constant.forInt(offsetToDeoptimizationFrame));
 759             // Now scratch64 is the _deopt_info._first_frame
 760             HSAILAddress pcStoreAddr = new HSAILAddressValue(Kind.Int, waveMathScratch1, offsetToFramePc).toAddress();
 761             HSAILAddress regCountsAddr = new HSAILAddressValue(Kind.Int, waveMathScratch1, offsetToNumSaves).toAddress();
 762             HSAILAddress dregOopMapAddr = new HSAILAddressValue(Kind.Int, waveMathScratch1, offsetToNumSaves + 2).toAddress();
 763 
 764             asm.emitComment("// store deopting workitem");
 765             asm.emitWorkItemAbsId(scratch32);
 766             asm.emitStore(Kind.Int, scratch32, workItemAddr);
 767             asm.emitComment("// store actionAndReason");
 768             asm.emitStore(Kind.Int, actionAndReasonReg, actionReasonStoreAddr);
 769             asm.emitComment("// store PC");
 770             asm.emitStore(Kind.Int, codeBufferOffsetReg, pcStoreAddr);
 771             asm.emitComment("// store regCounts");
 772             asm.emitStore(Kind.Short, Constant.forInt(32 + (16 &lt;&lt; 8) + (0 &lt;&lt; 16)), regCountsAddr);
 773             asm.emitComment("// store dreg ref map bits");
 774             asm.emitStore(Kind.Short, dregOopMapReg, dregOopMapAddr);
 775 
 776             // get the union of registers needed to be saved at the infopoints
<a name="24" id="anc24"></a><span class="changed"> 777             boolean[] infoUsedRegs = new boolean[HSAIL.threadRegister.number + 1];</span>


 778             List&lt;Infopoint&gt; infoList = crb.compilationResult.getInfopoints();
 779             for (Infopoint info : infoList) {
 780                 BytecodeFrame frame = info.debugInfo.frame();
 781                 for (int i = 0; i &lt; frame.numLocals + frame.numStack; i++) {
 782                     Value val = frame.values[i];
 783                     if (isLegal(val) &amp;&amp; isRegister(val)) {
 784                         Register reg = asRegister(val);
 785                         infoUsedRegs[reg.number] = true;
 786                     }
 787                 }
 788             }
 789 
 790             // loop storing each of the 32 s registers that are used by infopoints
 791             // we always store in a fixed location, even if some registers are not stored
 792             asm.emitComment("// store used s regs");
 793             int ofst = offsetToSaveArea;
 794             for (Register sreg : HSAIL.sRegisters) {
 795                 if (infoUsedRegs[sreg.number]) {
 796                     Kind kind = Kind.Int;
 797                     HSAILAddress addr = new HSAILAddressValue(kind, waveMathScratch1, ofst).toAddress();
 798                     AllocatableValue sregValue = sreg.asValue(kind);
 799                     asm.emitStore(kind, sregValue, addr);
 800                 }
 801                 ofst += 4;
 802             }
 803 
 804             // loop storing each of the 16 d registers that are used by infopoints
 805             asm.emitComment("// store used d regs");
 806             for (Register dreg : HSAIL.dRegisters) {
 807                 if (infoUsedRegs[dreg.number]) {
 808                     Kind kind = Kind.Long;
 809                     HSAILAddress addr = new HSAILAddressValue(kind, waveMathScratch1, ofst).toAddress();
 810                     AllocatableValue dregValue = dreg.asValue(kind);
 811                     asm.emitStore(kind, dregValue, addr);
 812                 }
 813                 ofst += 8;
 814             }
 815 
 816             // for now, ignore saving the spill variables but that would come here
 817 
 818             asm.emitString0(labelExit + ":\n");
 819 
 820             // and emit the return
 821             crb.frameContext.leave(crb);
 822             asm.exit();
 823         } else {
 824             // Deoptimization is explicitly off, so emit simple return
 825             asm.emitString0(asm.getDeoptLabelName() + ":\n");
 826             asm.emitComment("// No deoptimization");
 827             asm.emitString("ret;");
 828         }
 829 
 830         asm.emitString0("}; \n");
 831 
 832         ExternalCompilationResult compilationResult = (ExternalCompilationResult) crb.compilationResult;
 833         HSAILHotSpotLIRGenerationResult lirGenRes = ((HSAILCompilationResultBuilder) crb).lirGenRes;
<a name="25" id="anc25"></a><span class="changed"> 834         compilationResult.setHostGraph(prepareHostGraph(method, lirGenRes.getDeopts(), getProviders(), config));</span>
 835     }
 836 
 837     private static StructuredGraph prepareHostGraph(ResolvedJavaMethod method, List&lt;DeoptimizeOp&gt; deopts, HotSpotProviders providers, HotSpotVMConfig config) {
 838         if (deopts.isEmpty()) {
 839             return null;
 840         }
 841         StructuredGraph hostGraph = new StructuredGraph(method, -2);
 842         ParameterNode deoptId = hostGraph.unique(new ParameterNode(0, StampFactory.intValue()));
 843         ParameterNode hsailFrame = hostGraph.unique(new ParameterNode(1, StampFactory.forKind(providers.getCodeCache().getTarget().wordKind)));
 844         ParameterNode reasonAndAction = hostGraph.unique(new ParameterNode(2, StampFactory.intValue()));
 845         ParameterNode speculation = hostGraph.unique(new ParameterNode(3, StampFactory.object()));
 846         AbstractBeginNode[] branches = new AbstractBeginNode[deopts.size() + 1];
 847         int[] keys = new int[deopts.size()];
 848         int[] keySuccessors = new int[deopts.size() + 1];
 849         double[] keyProbabilities = new double[deopts.size() + 1];
 850         int i = 0;
 851         Collections.sort(deopts, new Comparator&lt;DeoptimizeOp&gt;() {
 852             public int compare(DeoptimizeOp o1, DeoptimizeOp o2) {
 853                 return o1.getCodeBufferPos() - o2.getCodeBufferPos();
 854             }
 855         });
 856         for (DeoptimizeOp deopt : deopts) {
 857             keySuccessors[i] = i;
 858             keyProbabilities[i] = 1.0 / deopts.size();
 859             keys[i] = deopt.getCodeBufferPos();
 860             assert keys[i] &gt;= 0;
 861             branches[i] = createHostDeoptBranch(deopt, hsailFrame, reasonAndAction, speculation, providers, config);
 862 
 863             i++;
 864         }
 865         keyProbabilities[deopts.size()] = 0; // default
 866         keySuccessors[deopts.size()] = deopts.size();
 867         branches[deopts.size()] = createHostCrashBranch(hostGraph, deoptId);
 868         IntegerSwitchNode switchNode = hostGraph.add(new IntegerSwitchNode(deoptId, branches, keys, keyProbabilities, keySuccessors));
 869         StartNode start = hostGraph.start();
 870         start.setNext(switchNode);
 871         /*
 872          * printf.setNext(printf2); printf2.setNext(switchNode);
 873          */
 874         hostGraph.setGuardsStage(GuardsStage.AFTER_FSA);
 875         return hostGraph;
 876     }
 877 
 878     private static AbstractBeginNode createHostCrashBranch(StructuredGraph hostGraph, ValueNode deoptId) {
 879         VMErrorNode vmError = hostGraph.add(new VMErrorNode("Error in HSAIL deopt. DeoptId=%d", deoptId));
 880         // ConvertNode.convert(hostGraph, Kind.Long, deoptId)));
 881         vmError.setNext(hostGraph.add(new ReturnNode(ConstantNode.defaultForKind(hostGraph.method().getSignature().getReturnKind(), hostGraph))));
 882         return BeginNode.begin(vmError);
 883     }
 884 
 885     private static AbstractBeginNode createHostDeoptBranch(DeoptimizeOp deopt, ParameterNode hsailFrame, ValueNode reasonAndAction, ValueNode speculation, HotSpotProviders providers,
 886                     HotSpotVMConfig config) {
 887         BeginNode branch = hsailFrame.graph().add(new BeginNode());
 888         DynamicDeoptimizeNode deoptimization = hsailFrame.graph().add(new DynamicDeoptimizeNode(reasonAndAction, speculation));
 889         deoptimization.setStateBefore(createFrameState(deopt.getFrameState().topFrame, hsailFrame, providers, config));
 890         branch.setNext(deoptimization);
 891         return branch;
 892     }
 893 
 894     private static FrameState createFrameState(BytecodeFrame lowLevelFrame, ParameterNode hsailFrame, HotSpotProviders providers, HotSpotVMConfig config) {
 895         StructuredGraph hostGraph = hsailFrame.graph();
 896         ValueNode[] locals = new ValueNode[lowLevelFrame.numLocals];
 897         for (int i = 0; i &lt; lowLevelFrame.numLocals; i++) {
 898             locals[i] = getNodeForValueFromFrame(lowLevelFrame.getLocalValue(i), hsailFrame, hostGraph, providers, config);
 899         }
 900         List&lt;ValueNode&gt; stack = new ArrayList&lt;&gt;(lowLevelFrame.numStack);
 901         for (int i = 0; i &lt; lowLevelFrame.numStack; i++) {
 902             stack.add(getNodeForValueFromFrame(lowLevelFrame.getStackValue(i), hsailFrame, hostGraph, providers, config));
 903         }
 904         ValueNode[] locks = new ValueNode[lowLevelFrame.numLocks];
 905         MonitorIdNode[] monitorIds = new MonitorIdNode[lowLevelFrame.numLocks];
 906         for (int i = 0; i &lt; lowLevelFrame.numLocks; i++) {
 907             HotSpotMonitorValue lockValue = (HotSpotMonitorValue) lowLevelFrame.getLockValue(i);
 908             locks[i] = getNodeForValueFromFrame(lockValue, hsailFrame, hostGraph, providers, config);
 909             monitorIds[i] = getMonitorIdForHotSpotMonitorValueFromFrame(lockValue, hsailFrame, hostGraph);
 910         }
 911         FrameState frameState = hostGraph.add(new FrameState(lowLevelFrame.getMethod(), lowLevelFrame.getBCI(), locals, stack, locks, monitorIds, lowLevelFrame.rethrowException, false));
 912         if (lowLevelFrame.caller() != null) {
 913             frameState.setOuterFrameState(createFrameState(lowLevelFrame.caller(), hsailFrame, providers, config));
 914         }
 915         return frameState;
 916     }
 917 
<a name="26" id="anc26"></a><span class="changed"> 918     @SuppressWarnings("unused")</span>
 919     private static MonitorIdNode getMonitorIdForHotSpotMonitorValueFromFrame(HotSpotMonitorValue lockValue, ParameterNode hsailFrame, StructuredGraph hsailGraph) {
 920         if (lockValue.isEliminated()) {
 921             return null;
 922         }
 923         throw GraalInternalError.unimplemented();
 924     }
 925 
 926     private static ValueNode getNodeForValueFromFrame(Value localValue, ParameterNode hsailFrame, StructuredGraph hostGraph, HotSpotProviders providers, HotSpotVMConfig config) {
 927         ValueNode valueNode;
 928         if (localValue instanceof Constant) {
 929             valueNode = ConstantNode.forConstant((Constant) localValue, providers.getMetaAccess(), hostGraph);
 930         } else if (localValue instanceof VirtualObject) {
 931             throw GraalInternalError.unimplemented();
 932         } else if (localValue instanceof StackSlot) {
 933             throw GraalInternalError.unimplemented();
 934         } else if (localValue instanceof HotSpotMonitorValue) {
 935             HotSpotMonitorValue hotSpotMonitorValue = (HotSpotMonitorValue) localValue;
 936             return getNodeForValueFromFrame(hotSpotMonitorValue.getOwner(), hsailFrame, hostGraph, providers, config);
 937         } else if (localValue instanceof RegisterValue) {
 938             RegisterValue registerValue = (RegisterValue) localValue;
 939             int regNumber = registerValue.getRegister().number;
 940             valueNode = getNodeForRegisterFromFrame(regNumber, localValue.getKind(), hsailFrame, hostGraph, providers, config);
 941         } else if (Value.ILLEGAL.equals(localValue)) {
 942             valueNode = null;
 943         } else {
 944             throw GraalInternalError.shouldNotReachHere();
 945         }
 946         return valueNode;
 947     }
 948 
 949     private static ValueNode getNodeForRegisterFromFrame(int regNumber, Kind valueKind, ParameterNode hsailFrame, StructuredGraph hostGraph, HotSpotProviders providers, HotSpotVMConfig config) {
 950         ValueNode valueNode;
 951         LocationNode location;
 952         if (regNumber &gt;= HSAIL.s0.number &amp;&amp; regNumber &lt;= HSAIL.s31.number) {
 953             int intSize = providers.getCodeCache().getTarget().arch.getSizeInBytes(Kind.Int);
 954             long offset = config.hsailFrameSaveAreaOffset + intSize * (regNumber - HSAIL.s0.number);
 955             location = ConstantLocationNode.create(FINAL_LOCATION, valueKind, offset, hostGraph);
 956         } else if (regNumber &gt;= HSAIL.d0.number &amp;&amp; regNumber &lt;= HSAIL.d15.number) {
 957             int longSize = providers.getCodeCache().getTarget().arch.getSizeInBytes(Kind.Long);
 958             long offset = config.hsailFrameSaveAreaOffset + longSize * (regNumber - HSAIL.d0.number);
 959             LocationNode numSRegsLocation = ConstantLocationNode.create(FINAL_LOCATION, Kind.Byte, config.hsailFrameNumSRegOffset, hostGraph);
 960             ValueNode numSRegs = hostGraph.unique(new FloatingReadNode(hsailFrame, numSRegsLocation, null, StampFactory.forInteger(8, false)));
 961             numSRegs = SignExtendNode.convert(numSRegs, StampFactory.forKind(Kind.Byte));
 962             location = IndexedLocationNode.create(FINAL_LOCATION, valueKind, offset, numSRegs, hostGraph, 4);
 963         } else {
 964             throw GraalInternalError.shouldNotReachHere("unknown hsail register: " + regNumber);
 965         }
 966         valueNode = hostGraph.unique(new FloatingReadNode(hsailFrame, location, null, StampFactory.forKind(valueKind)));
 967         return valueNode;
 968     }
 969 
 970 }
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="27" type="hidden" /></form></body></html>
