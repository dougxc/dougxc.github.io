<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/jdk.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfig.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.UnsafeUtil.readCString;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  27 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  28 
  29 import java.lang.reflect.Field;
  30 import java.lang.reflect.Modifier;
  31 import java.util.HashMap;
  32 import java.util.Iterator;
  33 
  34 import jdk.vm.ci.common.JVMCIError;
  35 import jdk.vm.ci.hotspotvmconfig.HotSpotVMAddress;
  36 import jdk.vm.ci.hotspotvmconfig.HotSpotVMConstant;
  37 import jdk.vm.ci.hotspotvmconfig.HotSpotVMData;
  38 import jdk.vm.ci.hotspotvmconfig.HotSpotVMField;
  39 import jdk.vm.ci.hotspotvmconfig.HotSpotVMFlag;
  40 import jdk.vm.ci.hotspotvmconfig.HotSpotVMType;
  41 import jdk.internal.misc.Unsafe;
  42 
  43 //JaCoCo Exclude
  44 
  45 /**
  46  * Used to access native configuration details.
  47  *
  48  * All non-static, public fields in this class are so that they can be compiled as constants.
  49  */
  50 public class HotSpotVMConfig {
  51 
  52     /**
  53      * Gets the configuration associated with the singleton {@link HotSpotJVMCIRuntime}.
  54      */
  55     public static HotSpotVMConfig config() {
  56         return runtime().getConfig();
  57     }
  58 
  59     /**
  60      * Maximum allowed size of allocated area for a frame.
  61      */
  62     public final int maxFrameSize = 16 * 1024;
  63 
  64     public HotSpotVMConfig(CompilerToVM compilerToVm) {
  65         // Get raw pointer to the array that contains all gHotSpotVM values.
  66         final long gHotSpotVMData = compilerToVm.initializeConfiguration(this);
  67         assert gHotSpotVMData != 0;
  68 
  69         // Make FindBugs happy.
  70         jvmciHotSpotVMStructs = 0;
  71         jvmciHotSpotVMTypes = 0;
  72         jvmciHotSpotVMIntConstants = 0;
  73         jvmciHotSpotVMLongConstants = 0;
  74         jvmciHotSpotVMAddresses = 0;
  75 
  76         // Initialize the gHotSpotVM fields.
  77         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
  78             if (f.isAnnotationPresent(HotSpotVMData.class)) {
  79                 HotSpotVMData annotation = f.getAnnotation(HotSpotVMData.class);
  80                 final int index = annotation.index();
  81                 final long value = UNSAFE.getAddress(gHotSpotVMData + Unsafe.ADDRESS_SIZE * index);
  82                 try {
  83                     f.setLong(this, value);
  84                 } catch (IllegalAccessException e) {
  85                     throw new JVMCIError("index " + index, e);
  86                 }
  87             }
  88         }
  89 
  90         // Quick sanity check.
  91         assert jvmciHotSpotVMStructs != 0;
  92         assert jvmciHotSpotVMTypes != 0;
  93         assert jvmciHotSpotVMIntConstants != 0;
  94         assert jvmciHotSpotVMLongConstants != 0;
  95         assert jvmciHotSpotVMAddresses != 0;
  96 
  97         initialize();
  98 
  99         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift, logMinObjAlignment());
 100         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift, logKlassAlignment);
 101 
 102         assert check();
 103         assert HotSpotVMConfigVerifier.check();
 104     }
 105 
 106     @Override
 107     public String toString() {
 108         return getClass().getSimpleName();
 109     }
 110 
 111     /**
 112      * Initialize fields by reading their values from vmStructs.
 113      */
 114     private void initialize() {
 115         // Fill the VM fields hash map.
 116         HashMap&lt;String, VMFields.Field&gt; vmFields = new HashMap&lt;&gt;();
 117         for (VMFields.Field e : new VMFields(jvmciHotSpotVMStructs)) {
 118             vmFields.put(e.getName(), e);
 119         }
 120 
 121         // Fill the VM types hash map.
 122         HashMap&lt;String, VMTypes.Type&gt; vmTypes = new HashMap&lt;&gt;();
 123         for (VMTypes.Type e : new VMTypes(jvmciHotSpotVMTypes)) {
 124             vmTypes.put(e.getTypeName(), e);
 125         }
 126 
 127         // Fill the VM constants hash map.
 128         HashMap&lt;String, AbstractConstant&gt; vmConstants = new HashMap&lt;&gt;();
 129         for (AbstractConstant e : new VMIntConstants(jvmciHotSpotVMIntConstants)) {
 130             vmConstants.put(e.getName(), e);
 131         }
 132         for (AbstractConstant e : new VMLongConstants(jvmciHotSpotVMLongConstants)) {
 133             vmConstants.put(e.getName(), e);
 134         }
 135 
 136         // Fill the VM addresses hash map.
 137         HashMap&lt;String, VMAddresses.Address&gt; vmAddresses = new HashMap&lt;&gt;();
 138         for (VMAddresses.Address e : new VMAddresses(jvmciHotSpotVMAddresses)) {
 139             vmAddresses.put(e.getName(), e);
 140         }
 141 
 142         // Fill the flags hash map.
 143         HashMap&lt;String, Flags.Flag&gt; flags = new HashMap&lt;&gt;();
 144         for (Flags.Flag e : new Flags(vmFields, vmTypes)) {
 145             flags.put(e.getName(), e);
 146         }
 147 
 148         String osName = getHostOSName();
 149         String osArch = getHostArchitectureName();
 150 
 151         for (Field f : HotSpotVMConfig.class.getDeclaredFields()) {
 152             if (f.isAnnotationPresent(HotSpotVMField.class)) {
 153                 HotSpotVMField annotation = f.getAnnotation(HotSpotVMField.class);
 154                 String name = annotation.name();
 155                 String type = annotation.type();
 156                 VMFields.Field entry = vmFields.get(name);
 157                 if (entry == null) {
 158                     if (!isRequired(osArch, annotation.archs())) {
 159                         continue;
 160                     }
 161                     throw new JVMCIError(f.getName() + ": expected VM field not found: " + name);
 162                 }
 163 
 164                 // Make sure the native type is still the type we expect.
 165                 if (!type.isEmpty()) {
 166                     if (!type.equals(entry.getTypeString())) {
 167                         throw new JVMCIError(f.getName() + ": compiler expects type " + type + " but VM field " + name + " is of type " + entry.getTypeString());
 168                     }
 169                 }
 170 
 171                 switch (annotation.get()) {
 172                     case OFFSET:
 173                         setField(f, entry.getOffset());
 174                         break;
 175                     case ADDRESS:
 176                         setField(f, entry.getAddress());
 177                         break;
 178                     case VALUE:
 179                         setField(f, entry.getValue());
 180                         break;
 181                     default:
 182                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
 183                 }
 184             } else if (f.isAnnotationPresent(HotSpotVMType.class)) {
 185                 HotSpotVMType annotation = f.getAnnotation(HotSpotVMType.class);
 186                 String name = annotation.name();
 187                 VMTypes.Type entry = vmTypes.get(name);
 188                 if (entry == null) {
 189                     throw new JVMCIError(f.getName() + ": expected VM type not found: " + name);
 190                 }
 191 
 192                 switch (annotation.get()) {
 193                     case SIZE:
 194                         setField(f, entry.getSize());
 195                         break;
 196                     default:
 197                         throw new JVMCIError(f.getName() + ": unknown kind: " + annotation.get());
 198                 }
 199             } else if (f.isAnnotationPresent(HotSpotVMConstant.class)) {
 200                 HotSpotVMConstant annotation = f.getAnnotation(HotSpotVMConstant.class);
 201                 String name = annotation.name();
 202                 AbstractConstant entry = vmConstants.get(name);
 203                 if (entry == null) {
 204                     if (!isRequired(osArch, annotation.archs())) {
 205                         continue;
 206                     }
 207                     throw new JVMCIError(f.getName() + ": expected VM constant not found: " + name);
 208                 }
 209                 setField(f, entry.getValue());
 210             } else if (f.isAnnotationPresent(HotSpotVMAddress.class)) {
 211                 HotSpotVMAddress annotation = f.getAnnotation(HotSpotVMAddress.class);
 212                 String name = annotation.name();
 213                 VMAddresses.Address entry = vmAddresses.get(name);
 214                 if (entry == null) {
 215                     if (!isRequired(osName, annotation.os())) {
 216                         continue;
 217                     }
 218                     throw new JVMCIError(f.getName() + ": expected VM address not found: " + name);
 219                 }
 220                 setField(f, entry.getValue());
 221             } else if (f.isAnnotationPresent(HotSpotVMFlag.class)) {
 222                 HotSpotVMFlag annotation = f.getAnnotation(HotSpotVMFlag.class);
 223                 String name = annotation.name();
 224                 Flags.Flag entry = flags.get(name);
 225                 if (entry == null) {
 226                     if (annotation.optional() || !isRequired(osArch, annotation.archs())) {
 227                         continue;
 228                     }
 229                     throw new JVMCIError(f.getName() + ": expected VM flag not found: " + name);
 230 
 231                 }
 232                 setField(f, entry.getValue());
 233             }
 234         }
 235     }
 236 
 237     private final CompressEncoding oopEncoding;
 238     private final CompressEncoding klassEncoding;
 239 
 240     public CompressEncoding getOopEncoding() {
 241         return oopEncoding;
 242     }
 243 
 244     public CompressEncoding getKlassEncoding() {
 245         return klassEncoding;
 246     }
 247 
 248     private void setField(Field field, Object value) {
 249         try {
 250             Class&lt;?&gt; fieldType = field.getType();
 251             if (fieldType == boolean.class) {
 252                 if (value instanceof String) {
 253                     field.setBoolean(this, Boolean.valueOf((String) value));
 254                 } else if (value instanceof Boolean) {
 255                     field.setBoolean(this, (boolean) value);
 256                 } else if (value instanceof Long) {
 257                     field.setBoolean(this, ((long) value) != 0);
 258                 } else {
 259                     throw new JVMCIError(value.getClass().getSimpleName());
 260                 }
 261             } else if (fieldType == byte.class) {
 262                 if (value instanceof Long) {
 263                     field.setByte(this, (byte) (long) value);
 264                 } else {
 265                     throw new JVMCIError(value.getClass().getSimpleName());
 266                 }
 267             } else if (fieldType == int.class) {
 268                 if (value instanceof Integer) {
 269                     field.setInt(this, (int) value);
 270                 } else if (value instanceof Long) {
 271                     field.setInt(this, (int) (long) value);
 272                 } else {
 273                     throw new JVMCIError(value.getClass().getSimpleName());
 274                 }
 275             } else if (fieldType == long.class) {
 276                 field.setLong(this, (long) value);
 277             } else {
 278                 throw new JVMCIError(field.toString());
 279             }
 280         } catch (IllegalAccessException e) {
 281             throw new JVMCIError("%s: %s", field, e);
 282         }
 283     }
 284 
 285     /**
 286      * Gets the host operating system name.
 287      */
 288     private static String getHostOSName() {
 289         String osName = System.getProperty("os.name");
 290         switch (osName) {
 291             case "Linux":
 292                 osName = "linux";
 293                 break;
 294             case "SunOS":
 295                 osName = "solaris";
 296                 break;
 297             case "Mac OS X":
 298                 osName = "bsd";
 299                 break;
 300             default:
 301                 // Of course Windows is different...
 302                 if (osName.startsWith("Windows")) {
 303                     osName = "windows";
 304                 } else {
 305                     throw new JVMCIError("Unexpected OS name: " + osName);
 306                 }
 307         }
 308         return osName;
 309     }
 310 
 311     /**
 312      * Gets the host architecture name for the purpose of finding the corresponding
 313      * {@linkplain HotSpotJVMCIBackendFactory backend}.
 314      */
 315     public String getHostArchitectureName() {
 316         String arch = System.getProperty("os.arch");
 317         switch (arch) {
 318             case "x86_64":
 319                 arch = "amd64";
 320                 break;
 321             case "sparcv9":
 322                 arch = "sparc";
 323                 break;
 324         }
 325         return arch;
 326     }
 327 
 328     /**
 329      * Determines if the current specification is included in a given set of specifications.
 330      *
 331      * @param current
 332      * @param specification specifies a set of specifications, e.g. architectures or operating
 333      *            systems. A zero length value implies all.
 334      */
 335     private static boolean isRequired(String current, String[] specification) {
 336         if (specification.length == 0) {
 337             return true;
 338         }
 339         for (String arch : specification) {
 340             if (arch.equals(current)) {
 341                 return true;
 342             }
 343         }
 344         return false;
 345     }
 346 
 347     /**
 348      * VMStructEntry (see {@code vmStructs.hpp}).
 349      */
 350     @HotSpotVMData(index = 0) @Stable private long jvmciHotSpotVMStructs;
 351     @HotSpotVMData(index = 1) @Stable private long jvmciHotSpotVMStructEntryTypeNameOffset;
 352     @HotSpotVMData(index = 2) @Stable private long jvmciHotSpotVMStructEntryFieldNameOffset;
 353     @HotSpotVMData(index = 3) @Stable private long jvmciHotSpotVMStructEntryTypeStringOffset;
 354     @HotSpotVMData(index = 4) @Stable private long jvmciHotSpotVMStructEntryIsStaticOffset;
 355     @HotSpotVMData(index = 5) @Stable private long jvmciHotSpotVMStructEntryOffsetOffset;
 356     @HotSpotVMData(index = 6) @Stable private long jvmciHotSpotVMStructEntryAddressOffset;
 357     @HotSpotVMData(index = 7) @Stable private long jvmciHotSpotVMStructEntryArrayStride;
 358 
 359     final class VMFields implements Iterable&lt;VMFields.Field&gt; {
 360 
 361         private final long address;
 362 
 363         VMFields(long address) {
 364             this.address = address;
 365         }
 366 
 367         public Iterator&lt;VMFields.Field&gt; iterator() {
 368             return new Iterator&lt;VMFields.Field&gt;() {
 369 
 370                 private int index = 0;
 371 
 372                 private Field current() {
 373                     return new Field(address + jvmciHotSpotVMStructEntryArrayStride * index);
 374                 }
 375 
 376                 /**
 377                  * The last entry is identified by a NULL fieldName.
 378                  */
 379                 public boolean hasNext() {
 380                     Field entry = current();
 381                     return entry.getFieldName() != null;
 382                 }
 383 
 384                 public Field next() {
 385                     Field entry = current();
 386                     index++;
 387                     return entry;
 388                 }
 389             };
 390         }
 391 
 392         final class Field {
 393 
 394             private final long entryAddress;
 395 
 396             Field(long address) {
 397                 this.entryAddress = address;
 398             }
 399 
 400             public String getTypeName() {
 401                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeNameOffset);
 402                 return readCString(UNSAFE, typeNameAddress);
 403             }
 404 
 405             public String getFieldName() {
 406                 long fieldNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryFieldNameOffset);
 407                 return readCString(UNSAFE, fieldNameAddress);
 408             }
 409 
 410             public String getTypeString() {
 411                 long typeStringAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryTypeStringOffset);
 412                 return readCString(UNSAFE, typeStringAddress);
 413             }
 414 
 415             public boolean isStatic() {
 416                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMStructEntryIsStaticOffset) != 0;
 417             }
 418 
 419             public long getOffset() {
 420                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMStructEntryOffsetOffset);
 421             }
 422 
 423             public long getAddress() {
 424                 return UNSAFE.getAddress(entryAddress + jvmciHotSpotVMStructEntryAddressOffset);
 425             }
 426 
 427             public String getName() {
 428                 String typeName = getTypeName();
 429                 String fieldName = getFieldName();
 430                 return typeName + "::" + fieldName;
 431             }
 432 
 433             public long getValue() {
 434                 String type = getTypeString();
 435                 switch (type) {
 436                     case "bool":
 437                         return UNSAFE.getByte(getAddress());
 438                     case "int":
 439                         return UNSAFE.getInt(getAddress());
 440                     case "uint64_t":
 441                         return UNSAFE.getLong(getAddress());
 442                     case "address":
 443                     case "intptr_t":
 444                     case "uintptr_t":
 445                     case "size_t":
 446                         return UNSAFE.getAddress(getAddress());
 447                     default:
 448                         // All foo* types are addresses.
 449                         if (type.endsWith("*")) {
 450                             return UNSAFE.getAddress(getAddress());
 451                         }
 452                         throw new JVMCIError(type);
 453                 }
 454             }
 455 
 456             @Override
 457             public String toString() {
 458                 return String.format("Field[typeName=%s, fieldName=%s, typeString=%s, isStatic=%b, offset=%d, address=0x%x]", getTypeName(), getFieldName(), getTypeString(), isStatic(), getOffset(),
 459                                 getAddress());
 460             }
 461         }
 462     }
 463 
 464     /**
 465      * VMTypeEntry (see vmStructs.hpp).
 466      */
 467     @HotSpotVMData(index = 8) @Stable private long jvmciHotSpotVMTypes;
 468     @HotSpotVMData(index = 9) @Stable private long jvmciHotSpotVMTypeEntryTypeNameOffset;
 469     @HotSpotVMData(index = 10) @Stable private long jvmciHotSpotVMTypeEntrySuperclassNameOffset;
 470     @HotSpotVMData(index = 11) @Stable private long jvmciHotSpotVMTypeEntryIsOopTypeOffset;
 471     @HotSpotVMData(index = 12) @Stable private long jvmciHotSpotVMTypeEntryIsIntegerTypeOffset;
 472     @HotSpotVMData(index = 13) @Stable private long jvmciHotSpotVMTypeEntryIsUnsignedOffset;
 473     @HotSpotVMData(index = 14) @Stable private long jvmciHotSpotVMTypeEntrySizeOffset;
 474     @HotSpotVMData(index = 15) @Stable private long jvmciHotSpotVMTypeEntryArrayStride;
 475 
 476     final class VMTypes implements Iterable&lt;VMTypes.Type&gt; {
 477 
 478         private final long address;
 479 
 480         VMTypes(long address) {
 481             this.address = address;
 482         }
 483 
 484         public Iterator&lt;VMTypes.Type&gt; iterator() {
 485             return new Iterator&lt;VMTypes.Type&gt;() {
 486 
 487                 private int index = 0;
 488 
 489                 private Type current() {
 490                     return new Type(address + jvmciHotSpotVMTypeEntryArrayStride * index);
 491                 }
 492 
 493                 /**
 494                  * The last entry is identified by a NULL type name.
 495                  */
 496                 public boolean hasNext() {
 497                     Type entry = current();
 498                     return entry.getTypeName() != null;
 499                 }
 500 
 501                 public Type next() {
 502                     Type entry = current();
 503                     index++;
 504                     return entry;
 505                 }
 506             };
 507         }
 508 
 509         final class Type {
 510 
 511             private final long entryAddress;
 512 
 513             Type(long address) {
 514                 this.entryAddress = address;
 515             }
 516 
 517             public String getTypeName() {
 518                 long typeNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntryTypeNameOffset);
 519                 return readCString(UNSAFE, typeNameAddress);
 520             }
 521 
 522             public String getSuperclassName() {
 523                 long superclassNameAddress = UNSAFE.getAddress(entryAddress + jvmciHotSpotVMTypeEntrySuperclassNameOffset);
 524                 return readCString(UNSAFE, superclassNameAddress);
 525             }
 526 
 527             public boolean isOopType() {
 528                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsOopTypeOffset) != 0;
 529             }
 530 
 531             public boolean isIntegerType() {
 532                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsIntegerTypeOffset) != 0;
 533             }
 534 
 535             public boolean isUnsigned() {
 536                 return UNSAFE.getInt(entryAddress + jvmciHotSpotVMTypeEntryIsUnsignedOffset) != 0;
 537             }
 538 
 539             public long getSize() {
 540                 return UNSAFE.getLong(entryAddress + jvmciHotSpotVMTypeEntrySizeOffset);
 541             }
 542 
 543             @Override
 544             public String toString() {
 545                 return String.format("Type[typeName=%s, superclassName=%s, isOopType=%b, isIntegerType=%b, isUnsigned=%b, size=%d]", getTypeName(), getSuperclassName(), isOopType(), isIntegerType(),
 546                                 isUnsigned(), getSize());
 547             }
 548         }
 549     }
 550 
 551     public abstract class AbstractConstant {
 552 
 553         protected final long address;
 554         protected final long nameOffset;
 555         protected final long valueOffset;
 556 
 557         AbstractConstant(long address, long nameOffset, long valueOffset) {
 558             this.address = address;
 559             this.nameOffset = nameOffset;
 560             this.valueOffset = valueOffset;
 561         }
 562 
 563         public String getName() {
 564             long nameAddress = UNSAFE.getAddress(address + nameOffset);
 565             return readCString(UNSAFE, nameAddress);
 566         }
 567 
 568         public abstract long getValue();
 569     }
 570 
 571     /**
 572      * VMIntConstantEntry (see vmStructs.hpp).
 573      */
 574     @HotSpotVMData(index = 16) @Stable private long jvmciHotSpotVMIntConstants;
 575     @HotSpotVMData(index = 17) @Stable private long jvmciHotSpotVMIntConstantEntryNameOffset;
 576     @HotSpotVMData(index = 18) @Stable private long jvmciHotSpotVMIntConstantEntryValueOffset;
 577     @HotSpotVMData(index = 19) @Stable private long jvmciHotSpotVMIntConstantEntryArrayStride;
 578 
 579     final class VMIntConstants implements Iterable&lt;VMIntConstants.Constant&gt; {
 580 
 581         private final long address;
 582 
 583         VMIntConstants(long address) {
 584             this.address = address;
 585         }
 586 
 587         public Iterator&lt;VMIntConstants.Constant&gt; iterator() {
 588             return new Iterator&lt;VMIntConstants.Constant&gt;() {
 589 
 590                 private int index = 0;
 591 
 592                 private Constant current() {
 593                     return new Constant(address + jvmciHotSpotVMIntConstantEntryArrayStride * index);
 594                 }
 595 
 596                 /**
 597                  * The last entry is identified by a NULL name.
 598                  */
 599                 public boolean hasNext() {
 600                     Constant entry = current();
 601                     return entry.getName() != null;
 602                 }
 603 
 604                 public Constant next() {
 605                     Constant entry = current();
 606                     index++;
 607                     return entry;
 608                 }
 609             };
 610         }
 611 
 612         final class Constant extends AbstractConstant {
 613 
 614             Constant(long address) {
 615                 super(address, jvmciHotSpotVMIntConstantEntryNameOffset, jvmciHotSpotVMIntConstantEntryValueOffset);
 616             }
 617 
 618             @Override
 619             public long getValue() {
 620                 return UNSAFE.getInt(address + valueOffset);
 621             }
 622 
 623             @Override
 624             public String toString() {
 625                 return String.format("IntConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 626             }
 627         }
 628     }
 629 
 630     /**
 631      * VMLongConstantEntry (see vmStructs.hpp).
 632      */
 633     @HotSpotVMData(index = 20) @Stable private long jvmciHotSpotVMLongConstants;
 634     @HotSpotVMData(index = 21) @Stable private long jvmciHotSpotVMLongConstantEntryNameOffset;
 635     @HotSpotVMData(index = 22) @Stable private long jvmciHotSpotVMLongConstantEntryValueOffset;
 636     @HotSpotVMData(index = 23) @Stable private long jvmciHotSpotVMLongConstantEntryArrayStride;
 637 
 638     final class VMLongConstants implements Iterable&lt;VMLongConstants.Constant&gt; {
 639 
 640         private final long address;
 641 
 642         VMLongConstants(long address) {
 643             this.address = address;
 644         }
 645 
 646         public Iterator&lt;VMLongConstants.Constant&gt; iterator() {
 647             return new Iterator&lt;VMLongConstants.Constant&gt;() {
 648 
 649                 private int index = 0;
 650 
 651                 private Constant currentEntry() {
 652                     return new Constant(address + jvmciHotSpotVMLongConstantEntryArrayStride * index);
 653                 }
 654 
 655                 /**
 656                  * The last entry is identified by a NULL name.
 657                  */
 658                 public boolean hasNext() {
 659                     Constant entry = currentEntry();
 660                     return entry.getName() != null;
 661                 }
 662 
 663                 public Constant next() {
 664                     Constant entry = currentEntry();
 665                     index++;
 666                     return entry;
 667                 }
 668             };
 669         }
 670 
 671         final class Constant extends AbstractConstant {
 672 
 673             Constant(long address) {
 674                 super(address, jvmciHotSpotVMLongConstantEntryNameOffset, jvmciHotSpotVMLongConstantEntryValueOffset);
 675             }
 676 
 677             @Override
 678             public long getValue() {
 679                 return UNSAFE.getLong(address + valueOffset);
 680             }
 681 
 682             @Override
 683             public String toString() {
 684                 return String.format("LongConstant[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 685             }
 686         }
 687     }
 688 
 689     /**
 690      * VMAddressEntry (see vmStructs.hpp).
 691      */
 692     @HotSpotVMData(index = 24) @Stable private long jvmciHotSpotVMAddresses;
 693     @HotSpotVMData(index = 25) @Stable private long jvmciHotSpotVMAddressEntryNameOffset;
 694     @HotSpotVMData(index = 26) @Stable private long jvmciHotSpotVMAddressEntryValueOffset;
 695     @HotSpotVMData(index = 27) @Stable private long jvmciHotSpotVMAddressEntryArrayStride;
 696 
 697     final class VMAddresses implements Iterable&lt;VMAddresses.Address&gt; {
 698 
 699         private final long address;
 700 
 701         VMAddresses(long address) {
 702             this.address = address;
 703         }
 704 
 705         public Iterator&lt;VMAddresses.Address&gt; iterator() {
 706             return new Iterator&lt;VMAddresses.Address&gt;() {
 707 
 708                 private int index = 0;
 709 
 710                 private Address currentEntry() {
 711                     return new Address(address + jvmciHotSpotVMAddressEntryArrayStride * index);
 712                 }
 713 
 714                 /**
 715                  * The last entry is identified by a NULL name.
 716                  */
 717                 public boolean hasNext() {
 718                     Address entry = currentEntry();
 719                     return entry.getName() != null;
 720                 }
 721 
 722                 public Address next() {
 723                     Address entry = currentEntry();
 724                     index++;
 725                     return entry;
 726                 }
 727             };
 728         }
 729 
 730         final class Address extends AbstractConstant {
 731 
 732             Address(long address) {
 733                 super(address, jvmciHotSpotVMAddressEntryNameOffset, jvmciHotSpotVMAddressEntryValueOffset);
 734             }
 735 
 736             @Override
 737             public long getValue() {
 738                 return UNSAFE.getLong(address + valueOffset);
 739             }
 740 
 741             @Override
 742             public String toString() {
 743                 return String.format("Address[name=%s, value=%d (0x%x)]", getName(), getValue(), getValue());
 744             }
 745         }
 746     }
 747 
 748     final class Flags implements Iterable&lt;Flags.Flag&gt; {
 749 
 750         private final long address;
 751         private final long entrySize;
 752         private final long typeOffset;
 753         private final long nameOffset;
 754         private final long addrOffset;
 755 
 756         Flags(HashMap&lt;String, VMFields.Field&gt; vmStructs, HashMap&lt;String, VMTypes.Type&gt; vmTypes) {
 757             address = vmStructs.get("Flag::flags").getValue();
 758             entrySize = vmTypes.get("Flag").getSize();
 759             typeOffset = vmStructs.get("Flag::_type").getOffset();
 760             nameOffset = vmStructs.get("Flag::_name").getOffset();
 761             addrOffset = vmStructs.get("Flag::_addr").getOffset();
 762 
 763             assert vmTypes.get("bool").getSize() == Byte.BYTES;
 764             assert vmTypes.get("intx").getSize() == Long.BYTES;
 765             assert vmTypes.get("uintx").getSize() == Long.BYTES;
 766         }
 767 
 768         public Iterator&lt;Flags.Flag&gt; iterator() {
 769             return new Iterator&lt;Flags.Flag&gt;() {
 770 
 771                 private int index = 0;
 772 
 773                 private Flag current() {
 774                     return new Flag(address + entrySize * index);
 775                 }
 776 
 777                 /**
 778                  * The last entry is identified by a NULL name.
 779                  */
 780                 public boolean hasNext() {
 781                     Flag entry = current();
 782                     return entry.getName() != null;
 783                 }
 784 
 785                 public Flag next() {
 786                     Flag entry = current();
 787                     index++;
 788                     return entry;
 789                 }
 790             };
 791         }
 792 
 793         final class Flag {
 794 
 795             private final long entryAddress;
 796 
 797             Flag(long address) {
 798                 this.entryAddress = address;
 799             }
 800 
 801             public String getType() {
 802                 long typeAddress = UNSAFE.getAddress(entryAddress + typeOffset);
 803                 return readCString(UNSAFE, typeAddress);
 804             }
 805 
 806             public String getName() {
 807                 long nameAddress = UNSAFE.getAddress(entryAddress + nameOffset);
 808                 return readCString(UNSAFE, nameAddress);
 809             }
 810 
 811             public long getAddr() {
 812                 return UNSAFE.getAddress(entryAddress + addrOffset);
 813             }
 814 
 815             public Object getValue() {
 816                 switch (getType()) {
 817                     case "bool":
 818                         return Boolean.valueOf(UNSAFE.getByte(getAddr()) != 0);
 819                     case "intx":
 820                     case "uintx":
 821                     case "uint64_t":
 822                         return Long.valueOf(UNSAFE.getLong(getAddr()));
 823                     case "double":
 824                         return Double.valueOf(UNSAFE.getDouble(getAddr()));
 825                     case "ccstr":
 826                     case "ccstrlist":
 827                         return readCString(UNSAFE, getAddr());
 828                     default:
 829                         throw new JVMCIError(getType());
 830                 }
 831             }
 832 
 833             @Override
 834             public String toString() {
 835                 return String.format("Flag[type=%s, name=%s, value=%s]", getType(), getName(), getValue());
 836             }
 837         }
 838     }
 839 
 840     @HotSpotVMConstant(name = "ASSERT") @Stable public boolean cAssertions;
 841     public final boolean windowsOs = System.getProperty("os.name", "").startsWith("Windows");
 842     public final boolean linuxOs = System.getProperty("os.name", "").startsWith("Linux");
 843 
 844     @HotSpotVMFlag(name = "CodeEntryAlignment") @Stable public int codeEntryAlignment;
 845     @HotSpotVMFlag(name = "VerifyOops") @Stable public boolean verifyOops;
 846     @HotSpotVMFlag(name = "CITime") @Stable public boolean ciTime;
 847     @HotSpotVMFlag(name = "CITimeEach") @Stable public boolean ciTimeEach;
 848     @HotSpotVMFlag(name = "CompileTheWorldStartAt", optional = true) @Stable public int compileTheWorldStartAt;
 849     @HotSpotVMFlag(name = "CompileTheWorldStopAt", optional = true) @Stable public int compileTheWorldStopAt;
 850     @HotSpotVMFlag(name = "DontCompileHugeMethods") @Stable public boolean dontCompileHugeMethods;
 851     @HotSpotVMFlag(name = "HugeMethodLimit") @Stable public int hugeMethodLimit;
 852     @HotSpotVMFlag(name = "PrintInlining") @Stable public boolean printInlining;
 853     @HotSpotVMFlag(name = "Inline") @Stable public boolean inline;
 854     @HotSpotVMFlag(name = "JVMCIUseFastLocking") @Stable public boolean useFastLocking;
 855     @HotSpotVMFlag(name = "ForceUnreachable") @Stable public boolean forceUnreachable;
 856     @HotSpotVMFlag(name = "CodeCacheSegmentSize") @Stable public int codeSegmentSize;
 857     @HotSpotVMFlag(name = "FoldStableValues") @Stable public boolean foldStableValues;
 858 
 859     @HotSpotVMFlag(name = "UseTLAB") @Stable public boolean useTLAB;
 860     @HotSpotVMFlag(name = "UseBiasedLocking") @Stable public boolean useBiasedLocking;
 861     @HotSpotVMFlag(name = "UsePopCountInstruction") @Stable public boolean usePopCountInstruction;
 862     @HotSpotVMFlag(name = "UseCountLeadingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountLeadingZerosInstruction;
 863     @HotSpotVMFlag(name = "UseCountTrailingZerosInstruction", archs = {"amd64"}) @Stable public boolean useCountTrailingZerosInstruction;
 864     @HotSpotVMFlag(name = "UseAESIntrinsics") @Stable public boolean useAESIntrinsics;
 865     @HotSpotVMFlag(name = "UseCRC32Intrinsics") @Stable public boolean useCRC32Intrinsics;
 866     @HotSpotVMFlag(name = "UseG1GC") @Stable public boolean useG1GC;
 867     @HotSpotVMFlag(name = "UseConcMarkSweepGC") @Stable public boolean useCMSGC;
 868 
 869     @HotSpotVMFlag(name = "AllocatePrefetchStyle") @Stable public int allocatePrefetchStyle;
 870     @HotSpotVMFlag(name = "AllocatePrefetchInstr") @Stable public int allocatePrefetchInstr;
 871     @HotSpotVMFlag(name = "AllocatePrefetchLines") @Stable public int allocatePrefetchLines;
 872     @HotSpotVMFlag(name = "AllocateInstancePrefetchLines") @Stable public int allocateInstancePrefetchLines;
 873     @HotSpotVMFlag(name = "AllocatePrefetchStepSize") @Stable public int allocatePrefetchStepSize;
 874     @HotSpotVMFlag(name = "AllocatePrefetchDistance") @Stable public int allocatePrefetchDistance;
 875 
 876     @HotSpotVMFlag(name = "FlightRecorder", optional = true) @Stable public boolean flightRecorder;
 877 
 878     @HotSpotVMField(name = "CompilerToVM::Data::Universe_collectedHeap", type = "CollectedHeap*", get = HotSpotVMField.Type.VALUE) @Stable private long universeCollectedHeap;
 879     @HotSpotVMField(name = "CollectedHeap::_total_collections", type = "unsigned int", get = HotSpotVMField.Type.OFFSET) @Stable private int collectedHeapTotalCollectionsOffset;
 880 
 881     public long gcTotalCollectionsAddress() {
 882         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
 883     }
 884 
 885     @HotSpotVMFlag(name = "ReduceInitialCardMarks") @Stable public boolean useDeferredInitBarriers;
 886 
 887     // Compressed Oops related values.
 888     @HotSpotVMFlag(name = "UseCompressedOops") @Stable public boolean useCompressedOops;
 889     @HotSpotVMFlag(name = "UseCompressedClassPointers") @Stable public boolean useCompressedClassPointers;
 890 
 891     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowOopBase;
 892     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_oop_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowOopShift;
 893     @HotSpotVMFlag(name = "ObjectAlignmentInBytes") @Stable public int objectAlignment;
 894 
 895     public final int minObjAlignment() {
 896         return objectAlignment / heapWordSize;
 897     }
 898 
 899     public final int logMinObjAlignment() {
 900         return (int) (Math.log(objectAlignment) / Math.log(2));
 901     }
 902 
 903     @HotSpotVMType(name = "narrowKlass", get = HotSpotVMType.Type.SIZE) @Stable public int narrowKlassSize;
 904     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_base", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long narrowKlassBase;
 905     @HotSpotVMField(name = "CompilerToVM::Data::Universe_narrow_klass_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int narrowKlassShift;
 906     @HotSpotVMConstant(name = "LogKlassAlignmentInBytes") @Stable public int logKlassAlignment;
 907 
 908     // CPU capabilities
 909     @HotSpotVMFlag(name = "UseSSE") @Stable public int useSSE;
 910     @HotSpotVMFlag(name = "UseAVX", archs = {"amd64"}) @Stable public int useAVX;
 911 
 912     @HotSpotVMField(name = "Abstract_VM_Version::_features", type = "uint64_t", get = HotSpotVMField.Type.VALUE) @Stable public long vmVersionFeatures;
 913 
 914     // AMD64 specific values
 915     @HotSpotVMConstant(name = "VM_Version::CPU_CX8", archs = {"amd64"}) @Stable public long amd64CX8;
 916     @HotSpotVMConstant(name = "VM_Version::CPU_CMOV", archs = {"amd64"}) @Stable public long amd64CMOV;
 917     @HotSpotVMConstant(name = "VM_Version::CPU_FXSR", archs = {"amd64"}) @Stable public long amd64FXSR;
 918     @HotSpotVMConstant(name = "VM_Version::CPU_HT", archs = {"amd64"}) @Stable public long amd64HT;
 919     @HotSpotVMConstant(name = "VM_Version::CPU_MMX", archs = {"amd64"}) @Stable public long amd64MMX;
 920     @HotSpotVMConstant(name = "VM_Version::CPU_3DNOW_PREFETCH", archs = {"amd64"}) @Stable public long amd643DNOWPREFETCH;
 921     @HotSpotVMConstant(name = "VM_Version::CPU_SSE", archs = {"amd64"}) @Stable public long amd64SSE;
 922     @HotSpotVMConstant(name = "VM_Version::CPU_SSE2", archs = {"amd64"}) @Stable public long amd64SSE2;
 923     @HotSpotVMConstant(name = "VM_Version::CPU_SSE3", archs = {"amd64"}) @Stable public long amd64SSE3;
 924     @HotSpotVMConstant(name = "VM_Version::CPU_SSSE3", archs = {"amd64"}) @Stable public long amd64SSSE3;
 925     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4A", archs = {"amd64"}) @Stable public long amd64SSE4A;
 926     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_1", archs = {"amd64"}) @Stable public long amd64SSE41;
 927     @HotSpotVMConstant(name = "VM_Version::CPU_SSE4_2", archs = {"amd64"}) @Stable public long amd64SSE42;
 928     @HotSpotVMConstant(name = "VM_Version::CPU_POPCNT", archs = {"amd64"}) @Stable public long amd64POPCNT;
 929     @HotSpotVMConstant(name = "VM_Version::CPU_LZCNT", archs = {"amd64"}) @Stable public long amd64LZCNT;
 930     @HotSpotVMConstant(name = "VM_Version::CPU_TSC", archs = {"amd64"}) @Stable public long amd64TSC;
 931     @HotSpotVMConstant(name = "VM_Version::CPU_TSCINV", archs = {"amd64"}) @Stable public long amd64TSCINV;
 932     @HotSpotVMConstant(name = "VM_Version::CPU_AVX", archs = {"amd64"}) @Stable public long amd64AVX;
 933     @HotSpotVMConstant(name = "VM_Version::CPU_AVX2", archs = {"amd64"}) @Stable public long amd64AVX2;
 934     @HotSpotVMConstant(name = "VM_Version::CPU_AES", archs = {"amd64"}) @Stable public long amd64AES;
 935     @HotSpotVMConstant(name = "VM_Version::CPU_ERMS", archs = {"amd64"}) @Stable public long amd64ERMS;
 936     @HotSpotVMConstant(name = "VM_Version::CPU_CLMUL", archs = {"amd64"}) @Stable public long amd64CLMUL;
 937     @HotSpotVMConstant(name = "VM_Version::CPU_BMI1", archs = {"amd64"}) @Stable public long amd64BMI1;
 938     @HotSpotVMConstant(name = "VM_Version::CPU_BMI2", archs = {"amd64"}) @Stable public long amd64BMI2;
 939     @HotSpotVMConstant(name = "VM_Version::CPU_RTM", archs = {"amd64"}) @Stable public long amd64RTM;
 940     @HotSpotVMConstant(name = "VM_Version::CPU_ADX", archs = {"amd64"}) @Stable public long amd64ADX;
 941     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512F", archs = {"amd64"}) @Stable public long amd64AVX512F;
 942     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512DQ", archs = {"amd64"}) @Stable public long amd64AVX512DQ;
 943     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512PF", archs = {"amd64"}) @Stable public long amd64AVX512PF;
 944     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512ER", archs = {"amd64"}) @Stable public long amd64AVX512ER;
 945     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512CD", archs = {"amd64"}) @Stable public long amd64AVX512CD;
 946     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512BW", archs = {"amd64"}) @Stable public long amd64AVX512BW;
 947     @HotSpotVMConstant(name = "VM_Version::CPU_AVX512VL", archs = {"amd64"}) @Stable public long amd64AVX512VL;
 948     @HotSpotVMConstant(name = "VM_Version::CPU_SHA", archs = {"amd64"}) @Stable public long amd64SHA;
 949 
 950     // SPARC specific values
 951     @HotSpotVMConstant(name = "VM_Version::vis3_instructions_m", archs = {"sparc"}) @Stable public int sparcVis3Instructions;
 952     @HotSpotVMConstant(name = "VM_Version::vis2_instructions_m", archs = {"sparc"}) @Stable public int sparcVis2Instructions;
 953     @HotSpotVMConstant(name = "VM_Version::vis1_instructions_m", archs = {"sparc"}) @Stable public int sparcVis1Instructions;
 954     @HotSpotVMConstant(name = "VM_Version::cbcond_instructions_m", archs = {"sparc"}) @Stable public int sparcCbcondInstructions;
 955     @HotSpotVMConstant(name = "VM_Version::v8_instructions_m", archs = {"sparc"}) @Stable public int sparcV8Instructions;
 956     @HotSpotVMConstant(name = "VM_Version::hardware_mul32_m", archs = {"sparc"}) @Stable public int sparcHardwareMul32;
 957     @HotSpotVMConstant(name = "VM_Version::hardware_div32_m", archs = {"sparc"}) @Stable public int sparcHardwareDiv32;
 958     @HotSpotVMConstant(name = "VM_Version::hardware_fsmuld_m", archs = {"sparc"}) @Stable public int sparcHardwareFsmuld;
 959     @HotSpotVMConstant(name = "VM_Version::hardware_popc_m", archs = {"sparc"}) @Stable public int sparcHardwarePopc;
 960     @HotSpotVMConstant(name = "VM_Version::v9_instructions_m", archs = {"sparc"}) @Stable public int sparcV9Instructions;
 961     @HotSpotVMConstant(name = "VM_Version::sun4v_m", archs = {"sparc"}) @Stable public int sparcSun4v;
 962     @HotSpotVMConstant(name = "VM_Version::blk_init_instructions_m", archs = {"sparc"}) @Stable public int sparcBlkInitInstructions;
 963     @HotSpotVMConstant(name = "VM_Version::fmaf_instructions_m", archs = {"sparc"}) @Stable public int sparcFmafInstructions;
 964     @HotSpotVMConstant(name = "VM_Version::fmau_instructions_m", archs = {"sparc"}) @Stable public int sparcFmauInstructions;
 965     @HotSpotVMConstant(name = "VM_Version::sparc64_family_m", archs = {"sparc"}) @Stable public int sparcSparc64Family;
 966     @HotSpotVMConstant(name = "VM_Version::M_family_m", archs = {"sparc"}) @Stable public int sparcMFamily;
 967     @HotSpotVMConstant(name = "VM_Version::T_family_m", archs = {"sparc"}) @Stable public int sparcTFamily;
 968     @HotSpotVMConstant(name = "VM_Version::T1_model_m", archs = {"sparc"}) @Stable public int sparcT1Model;
 969     @HotSpotVMConstant(name = "VM_Version::sparc5_instructions_m", archs = {"sparc"}) @Stable public int sparcSparc5Instructions;
 970     @HotSpotVMConstant(name = "VM_Version::aes_instructions_m", archs = {"sparc"}) @Stable public int sparcAesInstructions;
 971     @HotSpotVMConstant(name = "VM_Version::sha1_instruction_m", archs = {"sparc"}) @Stable public int sparcSha1Instruction;
 972     @HotSpotVMConstant(name = "VM_Version::sha256_instruction_m", archs = {"sparc"}) @Stable public int sparcSha256Instruction;
 973     @HotSpotVMConstant(name = "VM_Version::sha512_instruction_m", archs = {"sparc"}) @Stable public int sparcSha512Instruction;
 974 
 975     @HotSpotVMFlag(name = "UseBlockZeroing", archs = {"sparc"}) @Stable public boolean useBlockZeroing;
 976     @HotSpotVMFlag(name = "BlockZeroingLowLimit", archs = {"sparc"}) @Stable public int blockZeroingLowLimit;
 977 
 978     @HotSpotVMFlag(name = "StackShadowPages") @Stable public int stackShadowPages;
 979     @HotSpotVMFlag(name = "StackReservedPages") @Stable public int stackReservedPages;
 980     @HotSpotVMFlag(name = "UseStackBanging") @Stable public boolean useStackBanging;
 981     @HotSpotVMConstant(name = "STACK_BIAS") @Stable public int stackBias;
 982     @HotSpotVMField(name = "CompilerToVM::Data::vm_page_size", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int vmPageSize;
 983 
 984     // offsets, ...
 985     @HotSpotVMField(name = "oopDesc::_mark", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int markOffset;
 986     @HotSpotVMField(name = "oopDesc::_metadata._klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int hubOffset;
 987 
 988     @HotSpotVMField(name = "Klass::_prototype_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int prototypeMarkWordOffset;
 989     @HotSpotVMField(name = "Klass::_subklass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int subklassOffset;
 990     @HotSpotVMField(name = "Klass::_next_sibling", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int nextSiblingOffset;
 991     @HotSpotVMField(name = "Klass::_super_check_offset", type = "juint", get = HotSpotVMField.Type.OFFSET) @Stable public int superCheckOffsetOffset;
 992     @HotSpotVMField(name = "Klass::_secondary_super_cache", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySuperCacheOffset;
 993     @HotSpotVMField(name = "Klass::_secondary_supers", type = "Array&lt;Klass*&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int secondarySupersOffset;
 994 
 995     /**
 996      * The offset of the _java_mirror field (of type {@link Class}) in a Klass.
 997      */
 998     @HotSpotVMField(name = "Klass::_java_mirror", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int classMirrorOffset;
 999 
1000     @HotSpotVMField(name = "Klass::_super", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int klassSuperKlassOffset;
1001     @HotSpotVMField(name = "Klass::_modifier_flags", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassModifierFlagsOffset;
1002     @HotSpotVMField(name = "Klass::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int klassAccessFlagsOffset;
1003     @HotSpotVMField(name = "Klass::_layout_helper", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int klassLayoutHelperOffset;
1004     @HotSpotVMField(name = "Klass::_name", type = "Symbol*", get = HotSpotVMField.Type.OFFSET) @Stable public int klassNameOffset;
1005 
1006     @HotSpotVMConstant(name = "Klass::_lh_neutral_value") @Stable public int klassLayoutHelperNeutralValue;
1007     @HotSpotVMConstant(name = "Klass::_lh_instance_slow_path_bit") @Stable public int klassLayoutHelperInstanceSlowPathBit;
1008     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_shift") @Stable public int layoutHelperLog2ElementSizeShift;
1009     @HotSpotVMConstant(name = "Klass::_lh_log2_element_size_mask") @Stable public int layoutHelperLog2ElementSizeMask;
1010     @HotSpotVMConstant(name = "Klass::_lh_element_type_shift") @Stable public int layoutHelperElementTypeShift;
1011     @HotSpotVMConstant(name = "Klass::_lh_element_type_mask") @Stable public int layoutHelperElementTypeMask;
1012     @HotSpotVMConstant(name = "Klass::_lh_header_size_shift") @Stable public int layoutHelperHeaderSizeShift;
1013     @HotSpotVMConstant(name = "Klass::_lh_header_size_mask") @Stable public int layoutHelperHeaderSizeMask;
1014     @HotSpotVMConstant(name = "Klass::_lh_array_tag_shift") @Stable public int layoutHelperArrayTagShift;
1015     @HotSpotVMConstant(name = "Klass::_lh_array_tag_type_value") @Stable public int layoutHelperArrayTagTypeValue;
1016     @HotSpotVMConstant(name = "Klass::_lh_array_tag_obj_value") @Stable public int layoutHelperArrayTagObjectValue;
1017 
1018     /**
1019      * This filters out the bit that differentiates a type array from an object array.
1020      */
1021     public int layoutHelperElementTypePrimitiveInPlace() {
1022         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
1023     }
1024 
1025     /**
1026      * Bit pattern in the klass layout helper that can be used to identify arrays.
1027      */
1028     public final int arrayKlassLayoutHelperIdentifier = 0x80000000;
1029 
1030     @HotSpotVMType(name = "vtableEntry", get = HotSpotVMType.Type.SIZE) @Stable public int vtableEntrySize;
1031     @HotSpotVMField(name = "vtableEntry::_method", type = "Method*", get = HotSpotVMField.Type.OFFSET) @Stable public int vtableEntryMethodOffset;
1032 
1033     @HotSpotVMType(name = "InstanceKlass", get = HotSpotVMType.Type.SIZE) @Stable public int instanceKlassSize;
1034     @HotSpotVMField(name = "InstanceKlass::_source_file_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassSourceFileNameIndexOffset;
1035     @HotSpotVMField(name = "InstanceKlass::_init_state", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassInitStateOffset;
1036     @HotSpotVMField(name = "InstanceKlass::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassConstantsOffset;
1037     @HotSpotVMField(name = "InstanceKlass::_fields", type = "Array&lt;u2&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int instanceKlassFieldsOffset;
1038     @HotSpotVMField(name = "CompilerToVM::Data::Klass_vtable_start_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassVtableStartOffset;
1039     @HotSpotVMField(name = "CompilerToVM::Data::Klass_vtable_length_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassVtableLengthOffset;
1040 
1041     @HotSpotVMConstant(name = "InstanceKlass::linked") @Stable public int instanceKlassStateLinked;
1042     @HotSpotVMConstant(name = "InstanceKlass::fully_initialized") @Stable public int instanceKlassStateFullyInitialized;
1043 
1044     @HotSpotVMType(name = "arrayOopDesc", get = HotSpotVMType.Type.SIZE) @Stable public int arrayOopDescSize;
1045 
1046     /**
1047      * The offset of the array length word in an array object's header.
1048      *
1049      * See {@code arrayOopDesc::length_offset_in_bytes()}.
1050      */
1051     public final int arrayOopDescLengthOffset() {
1052         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
1053     }
1054 
1055     @HotSpotVMField(name = "Array&lt;int&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1LengthOffset;
1056     @HotSpotVMField(name = "Array&lt;u1&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU1DataOffset;
1057     @HotSpotVMField(name = "Array&lt;u2&gt;::_data", type = "", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayU2DataOffset;
1058     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayLengthOffset;
1059     @HotSpotVMField(name = "Array&lt;Klass*&gt;::_data[0]", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int metaspaceArrayBaseOffset;
1060 
1061     @HotSpotVMField(name = "ObjArrayKlass::_element_klass", type = "Klass*", get = HotSpotVMField.Type.OFFSET) @Stable public int arrayClassElementOffset;
1062 
1063     @HotSpotVMConstant(name = "FieldInfo::access_flags_offset") @Stable public int fieldInfoAccessFlagsOffset;
1064     @HotSpotVMConstant(name = "FieldInfo::name_index_offset") @Stable public int fieldInfoNameIndexOffset;
1065     @HotSpotVMConstant(name = "FieldInfo::signature_index_offset") @Stable public int fieldInfoSignatureIndexOffset;
1066     @HotSpotVMConstant(name = "FieldInfo::initval_index_offset") @Stable public int fieldInfoInitvalIndexOffset;
1067     @HotSpotVMConstant(name = "FieldInfo::low_packed_offset") @Stable public int fieldInfoLowPackedOffset;
1068     @HotSpotVMConstant(name = "FieldInfo::high_packed_offset") @Stable public int fieldInfoHighPackedOffset;
1069     @HotSpotVMConstant(name = "FieldInfo::field_slots") @Stable public int fieldInfoFieldSlots;
1070 
1071     @HotSpotVMConstant(name = "FIELDINFO_TAG_SIZE") @Stable public int fieldInfoTagSize;
1072 
1073     @HotSpotVMConstant(name = "JVM_ACC_MONITOR_MATCH") @Stable public int jvmAccMonitorMatch;
1074     @HotSpotVMConstant(name = "JVM_ACC_HAS_MONITOR_BYTECODES") @Stable public int jvmAccHasMonitorBytecodes;
1075     @HotSpotVMConstant(name = "JVM_ACC_HAS_FINALIZER") @Stable public int jvmAccHasFinalizer;
1076     @HotSpotVMConstant(name = "JVM_ACC_FIELD_INTERNAL") @Stable public int jvmAccFieldInternal;
1077     @HotSpotVMConstant(name = "JVM_ACC_FIELD_STABLE") @Stable public int jvmAccFieldStable;
1078     @HotSpotVMConstant(name = "JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE") @Stable public int jvmAccFieldHasGenericSignature;
1079     @HotSpotVMConstant(name = "JVM_ACC_WRITTEN_FLAGS") @Stable public int jvmAccWrittenFlags;
1080     @HotSpotVMConstant(name = "JVM_ACC_IS_CLONEABLE_FAST") @Stable public int jvmAccIsCloneableFast;
1081 
1082     // Modifier.SYNTHETIC is not public so we get it via vmStructs.
1083     @HotSpotVMConstant(name = "JVM_ACC_SYNTHETIC") @Stable public int jvmAccSynthetic;
1084 
1085     /**
1086      * @see HotSpotResolvedObjectTypeImpl#createField
1087      */
1088     @HotSpotVMConstant(name = "JVM_RECOGNIZED_FIELD_MODIFIERS") @Stable public int recognizedFieldModifiers;
1089 
1090     @HotSpotVMField(name = "Thread::_tlab", type = "ThreadLocalAllocBuffer", get = HotSpotVMField.Type.OFFSET) @Stable public int threadTlabOffset;
1091 
1092     @HotSpotVMField(name = "JavaThread::_anchor", type = "JavaFrameAnchor", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadAnchorOffset;
1093     @HotSpotVMField(name = "JavaThread::_threadObj", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectOffset;
1094     @HotSpotVMField(name = "JavaThread::_osthread", type = "OSThread*", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadOffset;
1095     @HotSpotVMField(name = "JavaThread::_dirty_card_queue", type = "DirtyCardQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadDirtyCardQueueOffset;
1096     @HotSpotVMField(name = "JavaThread::_is_method_handle_return", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int threadIsMethodHandleReturnOffset;
1097     @HotSpotVMField(name = "JavaThread::_satb_mark_queue", type = "SATBMarkQueue", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadSatbMarkQueueOffset;
1098     @HotSpotVMField(name = "JavaThread::_vm_result", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadObjectResultOffset;
1099     @HotSpotVMField(name = "JavaThread::_jvmci_counters", type = "jlong*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciCountersThreadOffset;
1100     @HotSpotVMField(name = "JavaThread::_reserved_stack_activation", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int javaThreadReservedStackActivationOffset;
1101 
1102     /**
1103      * An invalid value for {@link #rtldDefault}.
1104      */
1105     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
1106 
1107     /**
1108      * Address of the library lookup routine. The C signature of this routine is:
1109      *
1110      * &lt;pre&gt;
1111      *     void* (const char *filename, char *ebuf, int ebuflen)
1112      * &lt;/pre&gt;
1113      */
1114     @HotSpotVMAddress(name = "os::dll_load") @Stable public long dllLoad;
1115 
1116     /**
1117      * Address of the library lookup routine. The C signature of this routine is:
1118      *
1119      * &lt;pre&gt;
1120      *     void* (void* handle, const char* name)
1121      * &lt;/pre&gt;
1122      */
1123     @HotSpotVMAddress(name = "os::dll_lookup") @Stable public long dllLookup;
1124 
1125     /**
1126      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
1127      * return the first occurrence of the desired symbol using the default library search order. If
1128      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
1129      * the current platform.
1130      */
1131     @HotSpotVMAddress(name = "RTLD_DEFAULT", os = {"bsd", "linux"}) @Stable public long rtldDefault = INVALID_RTLD_DEFAULT_HANDLE;
1132 
1133     /**
1134      * This field is used to pass exception objects into and out of the runtime system during
1135      * exception handling for compiled code.
1136      */
1137     @HotSpotVMField(name = "JavaThread::_exception_oop", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionOopOffset;
1138     @HotSpotVMField(name = "JavaThread::_exception_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int threadExceptionPcOffset;
1139     @HotSpotVMField(name = "ThreadShadow::_pending_exception", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingExceptionOffset;
1140 
1141     @HotSpotVMField(name = "JavaThread::_pending_deoptimization", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingDeoptimizationOffset;
1142     @HotSpotVMField(name = "JavaThread::_pending_failed_speculation", type = "oop", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingFailedSpeculationOffset;
1143     @HotSpotVMField(name = "JavaThread::_pending_transfer_to_interpreter", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int pendingTransferToInterpreterOffset;
1144 
1145     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_sp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaSpOffset;
1146     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_pc", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable private int javaFrameAnchorLastJavaPcOffset;
1147     @HotSpotVMField(name = "JavaFrameAnchor::_last_Java_fp", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET, archs = {"aarch64, amd64"}) @Stable private int javaFrameAnchorLastJavaFpOffset;
1148     @HotSpotVMField(name = "JavaFrameAnchor::_flags", type = "int", get = HotSpotVMField.Type.OFFSET, archs = {"sparc"}) @Stable private int javaFrameAnchorFlagsOffset;
1149 
1150     public int threadLastJavaSpOffset() {
1151         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
1152     }
1153 
1154     public int threadLastJavaPcOffset() {
1155         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
1156     }
1157 
1158     public int threadLastJavaFpOffset() {
1159         assert getHostArchitectureName().equals("aarch64") || getHostArchitectureName().equals("amd64");
1160         return javaThreadAnchorOffset + javaFrameAnchorLastJavaFpOffset;
1161     }
1162 
1163     /**
1164      * This value is only valid on SPARC.
1165      */
1166     public int threadJavaFrameAnchorFlagsOffset() {
1167         // TODO add an assert for SPARC
1168         return javaThreadAnchorOffset + javaFrameAnchorFlagsOffset;
1169     }
1170 
1171     // These are only valid on AMD64.
1172     @HotSpotVMConstant(name = "frame::arg_reg_save_area_bytes", archs = {"amd64"}) @Stable public int runtimeCallStackSize;
1173     @HotSpotVMConstant(name = "frame::interpreter_frame_sender_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameSenderSpOffset;
1174     @HotSpotVMConstant(name = "frame::interpreter_frame_last_sp_offset", archs = {"amd64"}) @Stable public int frameInterpreterFrameLastSpOffset;
1175 
1176     @HotSpotVMConstant(name = "dirtyCardQueueBufferOffset") @Stable private int dirtyCardQueueBufferOffset;
1177     @HotSpotVMConstant(name = "dirtyCardQueueIndexOffset") @Stable private int dirtyCardQueueIndexOffset;
1178 
1179     @HotSpotVMConstant(name = "satbMarkQueueBufferOffset") @Stable private int satbMarkQueueBufferOffset;
1180     @HotSpotVMConstant(name = "satbMarkQueueIndexOffset") @Stable private int satbMarkQueueIndexOffset;
1181     @HotSpotVMConstant(name = "satbMarkQueueActiveOffset") @Stable private int satbMarkQueueActiveOffset;
1182 
1183     @HotSpotVMField(name = "OSThread::_interrupted", type = "jint", get = HotSpotVMField.Type.OFFSET) @Stable public int osThreadInterruptedOffset;
1184 
1185     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public long markOopDescHashShift;
1186 
1187     @HotSpotVMConstant(name = "markOopDesc::biased_lock_mask_in_place") @Stable public int biasedLockMaskInPlace;
1188     @HotSpotVMConstant(name = "markOopDesc::age_mask_in_place") @Stable public int ageMaskInPlace;
1189     @HotSpotVMConstant(name = "markOopDesc::epoch_mask_in_place") @Stable public int epochMaskInPlace;
1190     @HotSpotVMConstant(name = "markOopDesc::hash_mask") @Stable public long markOopDescHashMask;
1191     @HotSpotVMConstant(name = "markOopDesc::hash_mask_in_place") @Stable public long markOopDescHashMaskInPlace;
1192 
1193     @HotSpotVMConstant(name = "markOopDesc::unlocked_value") @Stable public int unlockedMask;
1194     @HotSpotVMConstant(name = "markOopDesc::biased_lock_pattern") @Stable public int biasedLockPattern;
1195 
1196     @HotSpotVMConstant(name = "markOopDesc::no_hash_in_place") @Stable public int markWordNoHashInPlace;
1197     @HotSpotVMConstant(name = "markOopDesc::no_lock_in_place") @Stable public int markWordNoLockInPlace;
1198 
1199     /**
1200      * See {@code markOopDesc::prototype()}.
1201      */
1202     public long arrayPrototypeMarkWord() {
1203         return markWordNoHashInPlace | markWordNoLockInPlace;
1204     }
1205 
1206     /**
1207      * See {@code markOopDesc::copy_set_hash()}.
1208      */
1209     public long tlabIntArrayMarkWord() {
1210         long tmp = arrayPrototypeMarkWord() &amp; (~markOopDescHashMaskInPlace);
1211         tmp |= ((0x2 &amp; markOopDescHashMask) &lt;&lt; markOopDescHashShift);
1212         return tmp;
1213     }
1214 
1215     /**
1216      * Mark word right shift to get identity hash code.
1217      */
1218     @HotSpotVMConstant(name = "markOopDesc::hash_shift") @Stable public int identityHashCodeShift;
1219 
1220     /**
1221      * Identity hash code value when uninitialized.
1222      */
1223     @HotSpotVMConstant(name = "markOopDesc::no_hash") @Stable public int uninitializedIdentityHashCodeValue;
1224 
1225     @HotSpotVMField(name = "Method::_access_flags", type = "AccessFlags", get = HotSpotVMField.Type.OFFSET) @Stable public int methodAccessFlagsOffset;
1226     @HotSpotVMField(name = "Method::_constMethod", type = "ConstMethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodConstMethodOffset;
1227     @HotSpotVMField(name = "Method::_intrinsic_id", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodIntrinsicIdOffset;
1228     @HotSpotVMField(name = "Method::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodFlagsOffset;
1229     @HotSpotVMField(name = "Method::_vtable_index", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodVtableIndexOffset;
1230 
1231     @HotSpotVMField(name = "Method::_method_counters", type = "MethodCounters*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCountersOffset;
1232     @HotSpotVMField(name = "Method::_method_data", type = "MethodData*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOffset;
1233     @HotSpotVMField(name = "Method::_from_compiled_entry", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCompiledEntryOffset;
1234     @HotSpotVMField(name = "Method::_code", type = "CompiledMethod*", get = HotSpotVMField.Type.OFFSET) @Stable public int methodCodeOffset;
1235 
1236     @HotSpotVMConstant(name = "Method::_jfr_towrite") @Stable public int methodFlagsJfrTowrite;
1237     @HotSpotVMConstant(name = "Method::_caller_sensitive") @Stable public int methodFlagsCallerSensitive;
1238     @HotSpotVMConstant(name = "Method::_force_inline") @Stable public int methodFlagsForceInline;
1239     @HotSpotVMConstant(name = "Method::_dont_inline") @Stable public int methodFlagsDontInline;
1240     @HotSpotVMConstant(name = "Method::_hidden") @Stable public int methodFlagsHidden;
1241     @HotSpotVMConstant(name = "Method::_reserved_stack_access") @Stable public int methodFlagsReservedStackAccess;
1242     @HotSpotVMConstant(name = "Method::nonvirtual_vtable_index") @Stable public int nonvirtualVtableIndex;
1243     @HotSpotVMConstant(name = "Method::invalid_vtable_index") @Stable public int invalidVtableIndex;
1244 
1245     @HotSpotVMField(name = "MethodCounters::_invocation_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int invocationCounterOffset;
1246     @HotSpotVMField(name = "MethodCounters::_backedge_counter", type = "InvocationCounter", get = HotSpotVMField.Type.OFFSET) @Stable public int backedgeCounterOffset;
1247     @HotSpotVMConstant(name = "InvocationCounter::count_increment") @Stable public int invocationCounterIncrement;
1248     @HotSpotVMConstant(name = "InvocationCounter::count_shift") @Stable public int invocationCounterShift;
1249 
1250     @HotSpotVMField(name = "MethodData::_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataSize;
1251     @HotSpotVMField(name = "MethodData::_data_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataDataSize;
1252     @HotSpotVMField(name = "MethodData::_data[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopDataOffset;
1253     @HotSpotVMField(name = "MethodData::_trap_hist._array[0]", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataOopTrapHistoryOffset;
1254     @HotSpotVMField(name = "MethodData::_jvmci_ir_size", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int methodDataIRSizeOffset;
1255 
1256     @HotSpotVMField(name = "nmethod::_verified_entry_point", type = "address", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodEntryOffset;
1257     @HotSpotVMField(name = "nmethod::_comp_level", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int nmethodCompLevelOffset;
1258 
1259     @HotSpotVMConstant(name = "CompLevel_none") @Stable public int compilationLevelNone;
1260     @HotSpotVMConstant(name = "CompLevel_simple") @Stable public int compilationLevelSimple;
1261     @HotSpotVMConstant(name = "CompLevel_limited_profile") @Stable public int compilationLevelLimitedProfile;
1262     @HotSpotVMConstant(name = "CompLevel_full_profile") @Stable public int compilationLevelFullProfile;
1263     @HotSpotVMConstant(name = "CompLevel_full_optimization") @Stable public int compilationLevelFullOptimization;
1264 
1265     @HotSpotVMConstant(name = "JVMCIRuntime::none") @Stable public int compLevelAdjustmentNone;
1266     @HotSpotVMConstant(name = "JVMCIRuntime::by_holder") @Stable public int compLevelAdjustmentByHolder;
1267     @HotSpotVMConstant(name = "JVMCIRuntime::by_full_signature") @Stable public int compLevelAdjustmentByFullSignature;
1268 
1269     @HotSpotVMConstant(name = "InvocationEntryBci") @Stable public int invocationEntryBci;
1270 
1271     @HotSpotVMField(name = "JVMCIEnv::_task", type = "CompileTask*", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvTaskOffset;
1272     @HotSpotVMField(name = "JVMCIEnv::_jvmti_can_hotswap_or_post_breakpoint", type = "bool", get = HotSpotVMField.Type.OFFSET) @Stable public int jvmciEnvJvmtiCanHotswapOrPostBreakpointOffset;
1273     @HotSpotVMField(name = "CompileTask::_num_inlined_bytecodes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int compileTaskNumInlinedBytecodesOffset;
1274 
1275     @HotSpotVMField(name = "CompilerToVM::Data::Method_extra_stack_entries", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int extraStackEntries;
1276 
1277     @HotSpotVMField(name = "ConstMethod::_constants", type = "ConstantPool*", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodConstantsOffset;
1278     @HotSpotVMField(name = "ConstMethod::_flags", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodFlagsOffset;
1279     @HotSpotVMField(name = "ConstMethod::_code_size", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodCodeSizeOffset;
1280     @HotSpotVMField(name = "ConstMethod::_name_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodNameIndexOffset;
1281     @HotSpotVMField(name = "ConstMethod::_signature_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodSignatureIndexOffset;
1282     @HotSpotVMField(name = "ConstMethod::_max_stack", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int constMethodMaxStackOffset;
1283     @HotSpotVMField(name = "ConstMethod::_max_locals", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int methodMaxLocalsOffset;
1284 
1285     @HotSpotVMConstant(name = "ConstMethod::_has_linenumber_table") @Stable public int constMethodHasLineNumberTable;
1286     @HotSpotVMConstant(name = "ConstMethod::_has_localvariable_table") @Stable public int constMethodHasLocalVariableTable;
1287     @HotSpotVMConstant(name = "ConstMethod::_has_exception_table") @Stable public int constMethodHasExceptionTable;
1288 
1289     @HotSpotVMType(name = "ExceptionTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int exceptionTableElementSize;
1290     @HotSpotVMField(name = "ExceptionTableElement::start_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementStartPcOffset;
1291     @HotSpotVMField(name = "ExceptionTableElement::end_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementEndPcOffset;
1292     @HotSpotVMField(name = "ExceptionTableElement::handler_pc", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementHandlerPcOffset;
1293     @HotSpotVMField(name = "ExceptionTableElement::catch_type_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int exceptionTableElementCatchTypeIndexOffset;
1294 
1295     @HotSpotVMType(name = "LocalVariableTableElement", get = HotSpotVMType.Type.SIZE) @Stable public int localVariableTableElementSize;
1296     @HotSpotVMField(name = "LocalVariableTableElement::start_bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementStartBciOffset;
1297     @HotSpotVMField(name = "LocalVariableTableElement::length", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementLengthOffset;
1298     @HotSpotVMField(name = "LocalVariableTableElement::name_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementNameCpIndexOffset;
1299     @HotSpotVMField(name = "LocalVariableTableElement::descriptor_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementDescriptorCpIndexOffset;
1300     @HotSpotVMField(name = "LocalVariableTableElement::signature_cp_index", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSignatureCpIndexOffset;
1301     @HotSpotVMField(name = "LocalVariableTableElement::slot", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int localVariableTableElementSlotOffset;
1302 
1303     @HotSpotVMType(name = "ConstantPool", get = HotSpotVMType.Type.SIZE) @Stable public int constantPoolSize;
1304     @HotSpotVMField(name = "ConstantPool::_tags", type = "Array&lt;u1&gt;*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolTagsOffset;
1305     @HotSpotVMField(name = "ConstantPool::_pool_holder", type = "InstanceKlass*", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolHolderOffset;
1306     @HotSpotVMField(name = "ConstantPool::_length", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int constantPoolLengthOffset;
1307 
1308     @HotSpotVMConstant(name = "ConstantPool::CPCACHE_INDEX_TAG") @Stable public int constantPoolCpCacheIndexTag;
1309 
1310     @HotSpotVMConstant(name = "JVM_CONSTANT_Utf8") @Stable public int jvmConstantUtf8;
1311     @HotSpotVMConstant(name = "JVM_CONSTANT_Integer") @Stable public int jvmConstantInteger;
1312     @HotSpotVMConstant(name = "JVM_CONSTANT_Long") @Stable public int jvmConstantLong;
1313     @HotSpotVMConstant(name = "JVM_CONSTANT_Float") @Stable public int jvmConstantFloat;
1314     @HotSpotVMConstant(name = "JVM_CONSTANT_Double") @Stable public int jvmConstantDouble;
1315     @HotSpotVMConstant(name = "JVM_CONSTANT_Class") @Stable public int jvmConstantClass;
1316     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClass") @Stable public int jvmConstantUnresolvedClass;
1317     @HotSpotVMConstant(name = "JVM_CONSTANT_UnresolvedClassInError") @Stable public int jvmConstantUnresolvedClassInError;
1318     @HotSpotVMConstant(name = "JVM_CONSTANT_String") @Stable public int jvmConstantString;
1319     @HotSpotVMConstant(name = "JVM_CONSTANT_Fieldref") @Stable public int jvmConstantFieldref;
1320     @HotSpotVMConstant(name = "JVM_CONSTANT_Methodref") @Stable public int jvmConstantMethodref;
1321     @HotSpotVMConstant(name = "JVM_CONSTANT_InterfaceMethodref") @Stable public int jvmConstantInterfaceMethodref;
1322     @HotSpotVMConstant(name = "JVM_CONSTANT_NameAndType") @Stable public int jvmConstantNameAndType;
1323     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandle") @Stable public int jvmConstantMethodHandle;
1324     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodHandleInError") @Stable public int jvmConstantMethodHandleInError;
1325     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodType") @Stable public int jvmConstantMethodType;
1326     @HotSpotVMConstant(name = "JVM_CONSTANT_MethodTypeInError") @Stable public int jvmConstantMethodTypeInError;
1327     @HotSpotVMConstant(name = "JVM_CONSTANT_InvokeDynamic") @Stable public int jvmConstantInvokeDynamic;
1328 
1329     @HotSpotVMConstant(name = "JVM_CONSTANT_ExternalMax") @Stable public int jvmConstantExternalMax;
1330     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMin") @Stable public int jvmConstantInternalMin;
1331     @HotSpotVMConstant(name = "JVM_CONSTANT_InternalMax") @Stable public int jvmConstantInternalMax;
1332 
1333     @HotSpotVMConstant(name = "HeapWordSize") @Stable public int heapWordSize;
1334 
1335     @HotSpotVMType(name = "Symbol*", get = HotSpotVMType.Type.SIZE) @Stable public int symbolPointerSize;
1336 
1337     @HotSpotVMField(name = "vmSymbols::_symbols[0]", type = "Symbol*", get = HotSpotVMField.Type.ADDRESS) @Stable public long vmSymbolsSymbols;
1338     @HotSpotVMConstant(name = "vmSymbols::FIRST_SID") @Stable public int vmSymbolsFirstSID;
1339     @HotSpotVMConstant(name = "vmSymbols::SID_LIMIT") @Stable public int vmSymbolsSIDLimit;
1340 
1341     /**
1342      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
1343      * are allowed to look like (respectively) the high or low bits of a real oop.
1344      */
1345     @HotSpotVMField(name = "CompilerToVM::Data::Universe_non_oop_bits", type = "void*", get = HotSpotVMField.Type.VALUE) @Stable public long nonOopBits;
1346 
1347     @HotSpotVMField(name = "StubRoutines::_verify_oop_count", type = "jint", get = HotSpotVMField.Type.ADDRESS) @Stable public long verifyOopCounterAddress;
1348     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_mask", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopMask;
1349     @HotSpotVMField(name = "CompilerToVM::Data::Universe_verify_oop_bits", type = "uintptr_t", get = HotSpotVMField.Type.VALUE) @Stable public long verifyOopBits;
1350     @HotSpotVMField(name = "CompilerToVM::Data::Universe_base_vtable_size", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int universeBaseVtableSize;
1351 
1352     public final int baseVtableLength() {
1353         return universeBaseVtableSize / vtableEntrySize;
1354     }
1355 
1356     @HotSpotVMField(name = "HeapRegion::LogOfHRGrainBytes", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int logOfHRGrainBytes;
1357 
1358     @HotSpotVMConstant(name = "CardTableModRefBS::dirty_card") @Stable public byte dirtyCardValue;
1359     @HotSpotVMConstant(name = "G1SATBCardTableModRefBS::g1_young_gen") @Stable public byte g1YoungCardValue;
1360 
1361     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_start_address", type = "jbyte*", get = HotSpotVMField.Type.VALUE) @Stable private long cardtableStartAddress;
1362     @HotSpotVMField(name = "CompilerToVM::Data::cardtable_shift", type = "int", get = HotSpotVMField.Type.VALUE) @Stable private int cardtableShift;
1363 
1364     public long cardtableStartAddress() {
1365         return cardtableStartAddress;
1366     }
1367 
1368     public int cardtableShift() {
1369         return cardtableShift;
1370     }
1371 
1372     @HotSpotVMField(name = "os::_polling_page", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long safepointPollingAddress;
1373 
1374     // G1 Collector Related Values.
1375 
1376     public int g1CardQueueIndexOffset() {
1377         return javaThreadDirtyCardQueueOffset + dirtyCardQueueIndexOffset;
1378     }
1379 
1380     public int g1CardQueueBufferOffset() {
1381         return javaThreadDirtyCardQueueOffset + dirtyCardQueueBufferOffset;
1382     }
1383 
1384     public int g1SATBQueueMarkingOffset() {
1385         return javaThreadSatbMarkQueueOffset + satbMarkQueueActiveOffset;
1386     }
1387 
1388     public int g1SATBQueueIndexOffset() {
1389         return javaThreadSatbMarkQueueOffset + satbMarkQueueIndexOffset;
1390     }
1391 
1392     public int g1SATBQueueBufferOffset() {
1393         return javaThreadSatbMarkQueueOffset + satbMarkQueueBufferOffset;
1394     }
1395 
1396     @HotSpotVMField(name = "java_lang_Class::_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int klassOffset;
1397     @HotSpotVMField(name = "java_lang_Class::_array_klass_offset", type = "int", get = HotSpotVMField.Type.VALUE) @Stable public int arrayKlassOffset;
1398 
1399     @HotSpotVMType(name = "BasicLock", get = HotSpotVMType.Type.SIZE) @Stable public int basicLockSize;
1400     @HotSpotVMField(name = "BasicLock::_displaced_header", type = "markOop", get = HotSpotVMField.Type.OFFSET) @Stable public int basicLockDisplacedHeaderOffset;
1401 
1402     @HotSpotVMField(name = "Thread::_allocated_bytes", type = "jlong", get = HotSpotVMField.Type.OFFSET) @Stable public int threadAllocatedBytesOffset;
1403 
1404     @HotSpotVMFlag(name = "TLABWasteIncrement") @Stable public int tlabRefillWasteIncrement;
1405 
1406     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_start", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferStartOffset;
1407     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_end", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferEndOffset;
1408     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferTopOffset;
1409     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_pf_top", type = "HeapWord*", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferPfTopOffset;
1410     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_slow_allocations", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferSlowAllocationsOffset;
1411     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_fast_refill_waste", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferFastRefillWasteOffset;
1412     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_number_of_refills", type = "unsigned", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferNumberOfRefillsOffset;
1413     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_refill_waste_limit", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferRefillWasteLimitOffset;
1414     @HotSpotVMField(name = "ThreadLocalAllocBuffer::_desired_size", type = "size_t", get = HotSpotVMField.Type.OFFSET) @Stable private int threadLocalAllocBufferDesiredSizeOffset;
1415 
1416     public int tlabSlowAllocationsOffset() {
1417         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
1418     }
1419 
1420     public int tlabFastRefillWasteOffset() {
1421         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
1422     }
1423 
1424     public int tlabNumberOfRefillsOffset() {
1425         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
1426     }
1427 
1428     public int tlabRefillWasteLimitOffset() {
1429         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
1430     }
1431 
1432     public int threadTlabSizeOffset() {
1433         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
1434     }
1435 
1436     public int threadTlabStartOffset() {
1437         return threadTlabOffset + threadLocalAllocBufferStartOffset;
1438     }
1439 
1440     public int threadTlabEndOffset() {
1441         return threadTlabOffset + threadLocalAllocBufferEndOffset;
1442     }
1443 
1444     public int threadTlabTopOffset() {
1445         return threadTlabOffset + threadLocalAllocBufferTopOffset;
1446     }
1447 
1448     public int threadTlabPfTopOffset() {
1449         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
1450     }
1451 
1452     @HotSpotVMField(name = "CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve", type = "size_t", get = HotSpotVMField.Type.VALUE) @Stable public int tlabAlignmentReserve;
1453 
1454     @HotSpotVMFlag(name = "TLABStats") @Stable public boolean tlabStats;
1455 
1456     // FIXME This is only temporary until the GC code is changed.
1457     @HotSpotVMField(name = "CompilerToVM::Data::_supports_inline_contig_alloc", type = "bool", get = HotSpotVMField.Type.VALUE) @Stable public boolean inlineContiguousAllocationSupported;
1458     @HotSpotVMField(name = "CompilerToVM::Data::_heap_end_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapEndAddress;
1459     @HotSpotVMField(name = "CompilerToVM::Data::_heap_top_addr", type = "HeapWord**", get = HotSpotVMField.Type.VALUE) @Stable public long heapTopAddress;
1460 
1461     /**
1462      * The DataLayout header size is the same as the cell size.
1463      */
1464     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutHeaderSize;
1465     @HotSpotVMField(name = "DataLayout::_header._struct._tag", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutTagOffset;
1466     @HotSpotVMField(name = "DataLayout::_header._struct._flags", type = "u1", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutFlagsOffset;
1467     @HotSpotVMField(name = "DataLayout::_header._struct._bci", type = "u2", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutBCIOffset;
1468     @HotSpotVMField(name = "DataLayout::_cells[0]", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int dataLayoutCellsOffset;
1469     @HotSpotVMConstant(name = "DataLayout::cell_size") @Stable public int dataLayoutCellSize;
1470 
1471     @HotSpotVMConstant(name = "DataLayout::no_tag") @Stable public int dataLayoutNoTag;
1472     @HotSpotVMConstant(name = "DataLayout::bit_data_tag") @Stable public int dataLayoutBitDataTag;
1473     @HotSpotVMConstant(name = "DataLayout::counter_data_tag") @Stable public int dataLayoutCounterDataTag;
1474     @HotSpotVMConstant(name = "DataLayout::jump_data_tag") @Stable public int dataLayoutJumpDataTag;
1475     @HotSpotVMConstant(name = "DataLayout::receiver_type_data_tag") @Stable public int dataLayoutReceiverTypeDataTag;
1476     @HotSpotVMConstant(name = "DataLayout::virtual_call_data_tag") @Stable public int dataLayoutVirtualCallDataTag;
1477     @HotSpotVMConstant(name = "DataLayout::ret_data_tag") @Stable public int dataLayoutRetDataTag;
1478     @HotSpotVMConstant(name = "DataLayout::branch_data_tag") @Stable public int dataLayoutBranchDataTag;
1479     @HotSpotVMConstant(name = "DataLayout::multi_branch_data_tag") @Stable public int dataLayoutMultiBranchDataTag;
1480     @HotSpotVMConstant(name = "DataLayout::arg_info_data_tag") @Stable public int dataLayoutArgInfoDataTag;
1481     @HotSpotVMConstant(name = "DataLayout::call_type_data_tag") @Stable public int dataLayoutCallTypeDataTag;
1482     @HotSpotVMConstant(name = "DataLayout::virtual_call_type_data_tag") @Stable public int dataLayoutVirtualCallTypeDataTag;
1483     @HotSpotVMConstant(name = "DataLayout::parameters_type_data_tag") @Stable public int dataLayoutParametersTypeDataTag;
1484     @HotSpotVMConstant(name = "DataLayout::speculative_trap_data_tag") @Stable public int dataLayoutSpeculativeTrapDataTag;
1485 
1486     @HotSpotVMFlag(name = "BciProfileWidth") @Stable public int bciProfileWidth;
1487     @HotSpotVMFlag(name = "TypeProfileWidth") @Stable public int typeProfileWidth;
1488     @HotSpotVMFlag(name = "MethodProfileWidth") @Stable public int methodProfileWidth;
1489 
1490     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_ic_miss_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long inlineCacheMissStub;
1491     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleWrongMethodStub;
1492 
1493     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_unpack", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long handleDeoptStub;
1494     @HotSpotVMField(name = "CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long uncommonTrapStub;
1495 
1496     @HotSpotVMField(name = "CodeCache::_low_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheLowBound;
1497     @HotSpotVMField(name = "CodeCache::_high_bound", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long codeCacheHighBound;
1498 
1499     @HotSpotVMField(name = "StubRoutines::_aescrypt_encryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptEncryptBlockStub;
1500     @HotSpotVMField(name = "StubRoutines::_aescrypt_decryptBlock", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long aescryptDecryptBlockStub;
1501     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_encryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingEncryptAESCryptStub;
1502     @HotSpotVMField(name = "StubRoutines::_cipherBlockChaining_decryptAESCrypt", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long cipherBlockChainingDecryptAESCryptStub;
1503     @HotSpotVMField(name = "StubRoutines::_updateBytesCRC32", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long updateBytesCRC32Stub;
1504     @HotSpotVMField(name = "StubRoutines::_crc_table_adr", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long crcTableAddress;
1505 
1506     @HotSpotVMField(name = "StubRoutines::_throw_delayed_StackOverflowError_entry", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long throwDelayedStackOverflowErrorEntry;
1507 
1508     @HotSpotVMField(name = "StubRoutines::_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteArraycopy;
1509     @HotSpotVMField(name = "StubRoutines::_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortArraycopy;
1510     @HotSpotVMField(name = "StubRoutines::_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintArraycopy;
1511     @HotSpotVMField(name = "StubRoutines::_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongArraycopy;
1512     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopy;
1513     @HotSpotVMField(name = "StubRoutines::_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopArraycopyUninit;
1514     @HotSpotVMField(name = "StubRoutines::_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteDisjointArraycopy;
1515     @HotSpotVMField(name = "StubRoutines::_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortDisjointArraycopy;
1516     @HotSpotVMField(name = "StubRoutines::_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintDisjointArraycopy;
1517     @HotSpotVMField(name = "StubRoutines::_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongDisjointArraycopy;
1518     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopy;
1519     @HotSpotVMField(name = "StubRoutines::_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopDisjointArraycopyUninit;
1520     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedArraycopy;
1521     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedArraycopy;
1522     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedArraycopy;
1523     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedArraycopy;
1524     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopy;
1525     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedArraycopyUninit;
1526     @HotSpotVMField(name = "StubRoutines::_arrayof_jbyte_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jbyteAlignedDisjointArraycopy;
1527     @HotSpotVMField(name = "StubRoutines::_arrayof_jshort_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jshortAlignedDisjointArraycopy;
1528     @HotSpotVMField(name = "StubRoutines::_arrayof_jint_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jintAlignedDisjointArraycopy;
1529     @HotSpotVMField(name = "StubRoutines::_arrayof_jlong_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long jlongAlignedDisjointArraycopy;
1530     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopy;
1531     @HotSpotVMField(name = "StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long oopAlignedDisjointArraycopyUninit;
1532     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopy;
1533     @HotSpotVMField(name = "StubRoutines::_checkcast_arraycopy_uninit", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long checkcastArraycopyUninit;
1534     @HotSpotVMField(name = "StubRoutines::_unsafe_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long unsafeArraycopy;
1535     @HotSpotVMField(name = "StubRoutines::_generic_arraycopy", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long genericArraycopy;
1536 
1537     @HotSpotVMAddress(name = "JVMCIRuntime::new_instance") @Stable public long newInstanceAddress;
1538     @HotSpotVMAddress(name = "JVMCIRuntime::new_array") @Stable public long newArrayAddress;
1539     @HotSpotVMAddress(name = "JVMCIRuntime::new_multi_array") @Stable public long newMultiArrayAddress;
1540     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_array") @Stable public long dynamicNewArrayAddress;
1541     @HotSpotVMAddress(name = "JVMCIRuntime::dynamic_new_instance") @Stable public long dynamicNewInstanceAddress;
1542 
1543     @HotSpotVMAddress(name = "JVMCIRuntime::thread_is_interrupted") @Stable public long threadIsInterruptedAddress;
1544     @HotSpotVMAddress(name = "JVMCIRuntime::vm_message") @Stable public long vmMessageAddress;
1545     @HotSpotVMAddress(name = "JVMCIRuntime::identity_hash_code") @Stable public long identityHashCodeAddress;
1546     @HotSpotVMAddress(name = "JVMCIRuntime::exception_handler_for_pc") @Stable public long exceptionHandlerForPcAddress;
1547     @HotSpotVMAddress(name = "JVMCIRuntime::monitorenter") @Stable public long monitorenterAddress;
1548     @HotSpotVMAddress(name = "JVMCIRuntime::monitorexit") @Stable public long monitorexitAddress;
1549     @HotSpotVMAddress(name = "JVMCIRuntime::throw_and_post_jvmti_exception") @Stable public long throwAndPostJvmtiExceptionAddress;
1550     @HotSpotVMAddress(name = "JVMCIRuntime::throw_klass_external_name_exception") @Stable public long throwKlassExternalNameExceptionAddress;
1551     @HotSpotVMAddress(name = "JVMCIRuntime::throw_class_cast_exception") @Stable public long throwClassCastExceptionAddress;
1552     @HotSpotVMAddress(name = "JVMCIRuntime::log_primitive") @Stable public long logPrimitiveAddress;
1553     @HotSpotVMAddress(name = "JVMCIRuntime::log_object") @Stable public long logObjectAddress;
1554     @HotSpotVMAddress(name = "JVMCIRuntime::log_printf") @Stable public long logPrintfAddress;
1555     @HotSpotVMAddress(name = "JVMCIRuntime::vm_error") @Stable public long vmErrorAddress;
1556     @HotSpotVMAddress(name = "JVMCIRuntime::load_and_clear_exception") @Stable public long loadAndClearExceptionAddress;
1557     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_pre") @Stable public long writeBarrierPreAddress;
1558     @HotSpotVMAddress(name = "JVMCIRuntime::write_barrier_post") @Stable public long writeBarrierPostAddress;
1559     @HotSpotVMAddress(name = "JVMCIRuntime::validate_object") @Stable public long validateObject;
1560 
1561     @HotSpotVMAddress(name = "JVMCIRuntime::test_deoptimize_call_int") @Stable public long testDeoptimizeCallInt;
1562 
1563     @HotSpotVMAddress(name = "SharedRuntime::register_finalizer") @Stable public long registerFinalizerAddress;
1564     @HotSpotVMAddress(name = "SharedRuntime::exception_handler_for_return_address") @Stable public long exceptionHandlerForReturnAddressAddress;
1565     @HotSpotVMAddress(name = "SharedRuntime::OSR_migration_end") @Stable public long osrMigrationEndAddress;
1566     @HotSpotVMAddress(name = "SharedRuntime::enable_stack_reserved_zone") @Stable public long enableStackReservedZoneAddress;
1567 
1568     @HotSpotVMAddress(name = "os::javaTimeMillis") @Stable public long javaTimeMillisAddress;
1569     @HotSpotVMAddress(name = "os::javaTimeNanos") @Stable public long javaTimeNanosAddress;
1570     @HotSpotVMField(name = "CompilerToVM::Data::dsin", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticSinAddress;
1571     @HotSpotVMField(name = "CompilerToVM::Data::dcos", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticCosAddress;
1572     @HotSpotVMField(name = "CompilerToVM::Data::dtan", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticTanAddress;
1573     @HotSpotVMField(name = "CompilerToVM::Data::dexp", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticExpAddress;
1574     @HotSpotVMField(name = "CompilerToVM::Data::dlog", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticLogAddress;
1575     @HotSpotVMField(name = "CompilerToVM::Data::dlog10", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticLog10Address;
1576     @HotSpotVMField(name = "CompilerToVM::Data::dpow", type = "address", get = HotSpotVMField.Type.VALUE) @Stable public long arithmeticPowAddress;
1577 
1578     @HotSpotVMFlag(name = "JVMCICounterSize") @Stable public int jvmciCountersSize;
1579 
1580     @HotSpotVMAddress(name = "Deoptimization::fetch_unroll_info") @Stable public long deoptimizationFetchUnrollInfo;
1581     @HotSpotVMAddress(name = "Deoptimization::uncommon_trap") @Stable public long deoptimizationUncommonTrap;
1582     @HotSpotVMAddress(name = "Deoptimization::unpack_frames") @Stable public long deoptimizationUnpackFrames;
1583 
1584     @HotSpotVMConstant(name = "Deoptimization::Reason_none") @Stable public int deoptReasonNone;
1585     @HotSpotVMConstant(name = "Deoptimization::Reason_null_check") @Stable public int deoptReasonNullCheck;
1586     @HotSpotVMConstant(name = "Deoptimization::Reason_range_check") @Stable public int deoptReasonRangeCheck;
1587     @HotSpotVMConstant(name = "Deoptimization::Reason_class_check") @Stable public int deoptReasonClassCheck;
1588     @HotSpotVMConstant(name = "Deoptimization::Reason_array_check") @Stable public int deoptReasonArrayCheck;
1589     @HotSpotVMConstant(name = "Deoptimization::Reason_unreached0") @Stable public int deoptReasonUnreached0;
1590     @HotSpotVMConstant(name = "Deoptimization::Reason_type_checked_inlining") @Stable public int deoptReasonTypeCheckInlining;
1591     @HotSpotVMConstant(name = "Deoptimization::Reason_optimized_type_check") @Stable public int deoptReasonOptimizedTypeCheck;
1592     @HotSpotVMConstant(name = "Deoptimization::Reason_not_compiled_exception_handler") @Stable public int deoptReasonNotCompiledExceptionHandler;
1593     @HotSpotVMConstant(name = "Deoptimization::Reason_unresolved") @Stable public int deoptReasonUnresolved;
1594     @HotSpotVMConstant(name = "Deoptimization::Reason_jsr_mismatch") @Stable public int deoptReasonJsrMismatch;
1595     @HotSpotVMConstant(name = "Deoptimization::Reason_div0_check") @Stable public int deoptReasonDiv0Check;
1596     @HotSpotVMConstant(name = "Deoptimization::Reason_constraint") @Stable public int deoptReasonConstraint;
1597     @HotSpotVMConstant(name = "Deoptimization::Reason_loop_limit_check") @Stable public int deoptReasonLoopLimitCheck;
1598     @HotSpotVMConstant(name = "Deoptimization::Reason_aliasing") @Stable public int deoptReasonAliasing;
1599     @HotSpotVMConstant(name = "Deoptimization::Reason_transfer_to_interpreter") @Stable public int deoptReasonTransferToInterpreter;
1600     @HotSpotVMConstant(name = "Deoptimization::Reason_LIMIT") @Stable public int deoptReasonOSROffset;
1601 
1602     @HotSpotVMConstant(name = "Deoptimization::Action_none") @Stable public int deoptActionNone;
1603     @HotSpotVMConstant(name = "Deoptimization::Action_maybe_recompile") @Stable public int deoptActionMaybeRecompile;
1604     @HotSpotVMConstant(name = "Deoptimization::Action_reinterpret") @Stable public int deoptActionReinterpret;
1605     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_entrant") @Stable public int deoptActionMakeNotEntrant;
1606     @HotSpotVMConstant(name = "Deoptimization::Action_make_not_compilable") @Stable public int deoptActionMakeNotCompilable;
1607 
1608     @HotSpotVMConstant(name = "Deoptimization::_action_bits") @Stable public int deoptimizationActionBits;
1609     @HotSpotVMConstant(name = "Deoptimization::_reason_bits") @Stable public int deoptimizationReasonBits;
1610     @HotSpotVMConstant(name = "Deoptimization::_debug_id_bits") @Stable public int deoptimizationDebugIdBits;
1611     @HotSpotVMConstant(name = "Deoptimization::_action_shift") @Stable public int deoptimizationActionShift;
1612     @HotSpotVMConstant(name = "Deoptimization::_reason_shift") @Stable public int deoptimizationReasonShift;
1613     @HotSpotVMConstant(name = "Deoptimization::_debug_id_shift") @Stable public int deoptimizationDebugIdShift;
1614 
1615     @HotSpotVMConstant(name = "Deoptimization::Unpack_deopt") @Stable public int deoptimizationUnpackDeopt;
1616     @HotSpotVMConstant(name = "Deoptimization::Unpack_exception") @Stable public int deoptimizationUnpackException;
1617     @HotSpotVMConstant(name = "Deoptimization::Unpack_uncommon_trap") @Stable public int deoptimizationUnpackUncommonTrap;
1618     @HotSpotVMConstant(name = "Deoptimization::Unpack_reexecute") @Stable public int deoptimizationUnpackReexecute;
1619 
1620     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_size_of_deoptimized_frame", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockSizeOfDeoptimizedFrameOffset;
1621     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_caller_adjustment", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockCallerAdjustmentOffset;
1622     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_number_of_frames", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockNumberOfFramesOffset;
1623     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_total_frame_sizes", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockTotalFrameSizesOffset;
1624     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_unpack_kind", type = "int", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockUnpackKindOffset;
1625     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_sizes", type = "intptr_t*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFrameSizesOffset;
1626     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_frame_pcs", type = "address*", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockFramePcsOffset;
1627     @HotSpotVMField(name = "Deoptimization::UnrollBlock::_initial_info", type = "intptr_t", get = HotSpotVMField.Type.OFFSET) @Stable public int deoptimizationUnrollBlockInitialInfoOffset;
1628 
1629     @HotSpotVMConstant(name = "vmIntrinsics::_invokeBasic") @Stable public int vmIntrinsicInvokeBasic;
1630     @HotSpotVMConstant(name = "vmIntrinsics::_linkToVirtual") @Stable public int vmIntrinsicLinkToVirtual;
1631     @HotSpotVMConstant(name = "vmIntrinsics::_linkToStatic") @Stable public int vmIntrinsicLinkToStatic;
1632     @HotSpotVMConstant(name = "vmIntrinsics::_linkToSpecial") @Stable public int vmIntrinsicLinkToSpecial;
1633     @HotSpotVMConstant(name = "vmIntrinsics::_linkToInterface") @Stable public int vmIntrinsicLinkToInterface;
1634 
1635     @HotSpotVMConstant(name = "JVMCIEnv::ok") @Stable public int codeInstallResultOk;
1636     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_failed") @Stable public int codeInstallResultDependenciesFailed;
1637     @HotSpotVMConstant(name = "JVMCIEnv::dependencies_invalid") @Stable public int codeInstallResultDependenciesInvalid;
1638     @HotSpotVMConstant(name = "JVMCIEnv::cache_full") @Stable public int codeInstallResultCacheFull;
1639     @HotSpotVMConstant(name = "JVMCIEnv::code_too_large") @Stable public int codeInstallResultCodeTooLarge;
1640 
1641     public String getCodeInstallResultDescription(int codeInstallResult) {
1642         if (codeInstallResult == codeInstallResultOk) {
1643             return "ok";
1644         }
1645         if (codeInstallResult == codeInstallResultDependenciesFailed) {
1646             return "dependencies failed";
1647         }
1648         if (codeInstallResult == codeInstallResultDependenciesInvalid) {
1649             return "dependencies invalid";
1650         }
1651         if (codeInstallResult == codeInstallResultCacheFull) {
1652             return "code cache is full";
1653         }
1654         if (codeInstallResult == codeInstallResultCodeTooLarge) {
1655             return "code is too large";
1656         }
1657         assert false : codeInstallResult;
1658         return "unknown";
1659     }
1660 
1661     // Checkstyle: stop
1662     @HotSpotVMConstant(name = "CodeInstaller::VERIFIED_ENTRY") @Stable public int MARKID_VERIFIED_ENTRY;
1663     @HotSpotVMConstant(name = "CodeInstaller::UNVERIFIED_ENTRY") @Stable public int MARKID_UNVERIFIED_ENTRY;
1664     @HotSpotVMConstant(name = "CodeInstaller::OSR_ENTRY") @Stable public int MARKID_OSR_ENTRY;
1665     @HotSpotVMConstant(name = "CodeInstaller::EXCEPTION_HANDLER_ENTRY") @Stable public int MARKID_EXCEPTION_HANDLER_ENTRY;
1666     @HotSpotVMConstant(name = "CodeInstaller::DEOPT_HANDLER_ENTRY") @Stable public int MARKID_DEOPT_HANDLER_ENTRY;
1667     @HotSpotVMConstant(name = "CodeInstaller::INVOKEINTERFACE") @Stable public int MARKID_INVOKEINTERFACE;
1668     @HotSpotVMConstant(name = "CodeInstaller::INVOKEVIRTUAL") @Stable public int MARKID_INVOKEVIRTUAL;
1669     @HotSpotVMConstant(name = "CodeInstaller::INVOKESTATIC") @Stable public int MARKID_INVOKESTATIC;
1670     @HotSpotVMConstant(name = "CodeInstaller::INVOKESPECIAL") @Stable public int MARKID_INVOKESPECIAL;
1671     @HotSpotVMConstant(name = "CodeInstaller::INLINE_INVOKE") @Stable public int MARKID_INLINE_INVOKE;
1672     @HotSpotVMConstant(name = "CodeInstaller::POLL_NEAR") @Stable public int MARKID_POLL_NEAR;
1673     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_NEAR") @Stable public int MARKID_POLL_RETURN_NEAR;
1674     @HotSpotVMConstant(name = "CodeInstaller::POLL_FAR") @Stable public int MARKID_POLL_FAR;
1675     @HotSpotVMConstant(name = "CodeInstaller::POLL_RETURN_FAR") @Stable public int MARKID_POLL_RETURN_FAR;
1676     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_SHIFT") @Stable public int MARKID_CARD_TABLE_SHIFT;
1677     @HotSpotVMConstant(name = "CodeInstaller::CARD_TABLE_ADDRESS") @Stable public int MARKID_CARD_TABLE_ADDRESS;
1678     @HotSpotVMConstant(name = "CodeInstaller::HEAP_TOP_ADDRESS") @Stable public int MARKID_HEAP_TOP_ADDRESS;
1679     @HotSpotVMConstant(name = "CodeInstaller::HEAP_END_ADDRESS") @Stable public int MARKID_HEAP_END_ADDRESS;
1680     @HotSpotVMConstant(name = "CodeInstaller::NARROW_KLASS_BASE_ADDRESS") @Stable public int MARKID_NARROW_KLASS_BASE_ADDRESS;
1681     @HotSpotVMConstant(name = "CodeInstaller::CRC_TABLE_ADDRESS") @Stable public int MARKID_CRC_TABLE_ADDRESS;
1682     @HotSpotVMConstant(name = "CodeInstaller::INVOKE_INVALID") @Stable public int MARKID_INVOKE_INVALID;
1683 
1684     @HotSpotVMConstant(name = "BitData::exception_seen_flag") @Stable public int bitDataExceptionSeenFlag;
1685     @HotSpotVMConstant(name = "BitData::null_seen_flag") @Stable public int bitDataNullSeenFlag;
1686     @HotSpotVMConstant(name = "CounterData::count_off") @Stable public int methodDataCountOffset;
1687     @HotSpotVMConstant(name = "JumpData::taken_off_set") @Stable public int jumpDataTakenOffset;
1688     @HotSpotVMConstant(name = "JumpData::displacement_off_set") @Stable public int jumpDataDisplacementOffset;
1689     @HotSpotVMConstant(name = "ReceiverTypeData::nonprofiled_count_off_set") @Stable public int receiverTypeDataNonprofiledCountOffset;
1690     @HotSpotVMConstant(name = "ReceiverTypeData::receiver_type_row_cell_count") @Stable public int receiverTypeDataReceiverTypeRowCellCount;
1691     @HotSpotVMConstant(name = "ReceiverTypeData::receiver0_offset") @Stable public int receiverTypeDataReceiver0Offset;
1692     @HotSpotVMConstant(name = "ReceiverTypeData::count0_offset") @Stable public int receiverTypeDataCount0Offset;
1693     @HotSpotVMConstant(name = "BranchData::not_taken_off_set") @Stable public int branchDataNotTakenOffset;
1694     @HotSpotVMConstant(name = "ArrayData::array_len_off_set") @Stable public int arrayDataArrayLenOffset;
1695     @HotSpotVMConstant(name = "ArrayData::array_start_off_set") @Stable public int arrayDataArrayStartOffset;
1696     @HotSpotVMConstant(name = "MultiBranchData::per_case_cell_count") @Stable public int multiBranchDataPerCaseCellCount;
1697 
1698     // Checkstyle: resume
1699 
1700     private boolean check() {
1701         for (Field f : getClass().getDeclaredFields()) {
1702             int modifiers = f.getModifiers();
1703             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
1704                 assert Modifier.isFinal(modifiers) || f.getAnnotation(Stable.class) != null : "field should either be final or @Stable: " + f;
1705             }
1706         }
1707 
1708         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
1709         assert (layoutHelperArrayTagObjectValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "object array must have first bit set";
1710         assert (layoutHelperArrayTagTypeValue &amp; (1 &lt;&lt; (Integer.SIZE - 1))) != 0 : "type array must have first bit set";
1711 
1712         return true;
1713     }
1714 
1715     /**
1716      * A compact representation of the different encoding strategies for Objects and metadata.
1717      */
1718     public static class CompressEncoding {
1719         public final long base;
1720         public final int shift;
1721         public final int alignment;
1722 
1723         CompressEncoding(long base, int shift, int alignment) {
1724             this.base = base;
1725             this.shift = shift;
1726             this.alignment = alignment;
1727         }
1728 
1729         public int compress(long ptr) {
1730             if (ptr == 0L) {
1731                 return 0;
1732             } else {
1733                 return (int) ((ptr - base) &gt;&gt;&gt; shift);
1734             }
1735         }
1736 
1737         public long uncompress(int ptr) {
1738             if (ptr == 0) {
1739                 return 0L;
1740             } else {
1741                 return ((ptr &amp; 0xFFFFFFFFL) &lt;&lt; shift) + base;
1742             }
1743         }
1744 
1745         @Override
1746         public String toString() {
1747             return "base: " + base + " shift: " + shift + " alignment: " + alignment;
1748         }
1749 
1750         @Override
1751         public int hashCode() {
1752             final int prime = 31;
1753             int result = 1;
1754             result = prime * result + alignment;
1755             result = prime * result + (int) (base ^ (base &gt;&gt;&gt; 32));
1756             result = prime * result + shift;
1757             return result;
1758         }
1759 
1760         @Override
1761         public boolean equals(Object obj) {
1762             if (obj instanceof CompressEncoding) {
1763                 CompressEncoding other = (CompressEncoding) obj;
1764                 return alignment == other.alignment &amp;&amp; base == other.base &amp;&amp; shift == other.shift;
1765             } else {
1766                 return false;
1767             }
1768         }
1769     }
1770 
1771 }
</pre></body></html>
