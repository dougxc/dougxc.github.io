<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "classfile/javaClasses.inline.hpp"
  26 #include "code/codeCache.hpp"
  27 #include "code/scopeDesc.hpp"
  28 #include "interpreter/linkResolver.hpp"
  29 #include "memory/oopFactory.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "oops/generateOopMap.hpp"
  32 #include "oops/fieldStreams.hpp"
  33 #include "oops/oop.inline.hpp"
  34 #include "oops/objArrayOop.inline.hpp"
  35 #include "runtime/fieldDescriptor.hpp"
  36 #include "runtime/javaCalls.hpp"
  37 #include "jvmci/jvmciRuntime.hpp"
  38 #include "compiler/abstractCompiler.hpp"
  39 #include "compiler/compileBroker.hpp"
  40 #include "compiler/compilerOracle.hpp"
  41 #include "compiler/disassembler.hpp"
  42 #include "compiler/oopMap.hpp"
  43 #include "jvmci/jvmciCompilerToVM.hpp"
  44 #include "jvmci/jvmciCompiler.hpp"
  45 #include "jvmci/jvmciEnv.hpp"
  46 #include "jvmci/jvmciJavaClasses.hpp"
  47 #include "jvmci/jvmciCodeInstaller.hpp"
  48 #include "jvmci/vmStructs_jvmci.hpp"
  49 #include "gc/g1/heapRegion.hpp"
  50 #include "runtime/javaCalls.hpp"
  51 #include "runtime/deoptimization.hpp"
  52 #include "runtime/timerTrace.hpp"
  53 #include "runtime/vframe.hpp"
  54 #include "runtime/vframe_hp.hpp"
  55 #include "runtime/vmStructs.hpp"
  56 #include "utilities/resourceHash.hpp"
  57 
  58 
  59 void JNIHandleMark::push_jni_handle_block() {
  60   JavaThread* thread = JavaThread::current();
  61   if (thread != NULL) {
  62     // Allocate a new block for JNI handles.
  63     // Inlined code from jni_PushLocalFrame()
  64     JNIHandleBlock* java_handles = ((JavaThread*)thread)-&gt;active_handles();
  65     JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
  66     assert(compile_handles != NULL &amp;&amp; java_handles != NULL, "should not be NULL");
  67     compile_handles-&gt;set_pop_frame_link(java_handles);
  68     thread-&gt;set_active_handles(compile_handles);
  69   }
  70 }
  71 
  72 void JNIHandleMark::pop_jni_handle_block() {
  73   JavaThread* thread = JavaThread::current();
  74   if (thread != NULL) {
  75     // Release our JNI handle block
  76     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  77     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  78     thread-&gt;set_active_handles(java_handles);
  79     compile_handles-&gt;set_pop_frame_link(NULL);
  80     JNIHandleBlock::release_block(compile_handles, thread); // may block
  81   }
  82 }
  83 
  84 // Entry to native method implementation that transitions current thread to '_thread_in_vm'.
  85 #define C2V_VMENTRY(result_type, name, signature) \
  86   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  87   TRACE_jvmci_1("CompilerToVM::" #name); \
  88   TRACE_CALL(result_type, jvmci_ ## name signature) \
  89   JVMCI_VM_ENTRY_MARK; \
  90 
  91 #define C2V_END }
  92 
  93 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
  94   if (method() != NULL) {
  95     JavaValue result(T_OBJECT);
  96     JavaCallArguments args;
  97     args.push_long((jlong) (address) method());
  98     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
  99 
 100     return (oop)result.get_jobject();
 101   }
 102   return NULL;
 103 }
 104 
 105 oop CompilerToVM::get_jvmci_type(Klass* klass, TRAPS) {
 106   if (klass != NULL) {
 107     JavaValue result(T_OBJECT);
 108     JavaCallArguments args;
 109     args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
 110     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 111 
 112     return (oop)result.get_jobject();
 113   }
 114   return NULL;
 115 }
 116 
 117 
 118 int CompilerToVM::Data::Klass_vtable_start_offset;
 119 int CompilerToVM::Data::Klass_vtable_length_offset;
 120 
 121 int CompilerToVM::Data::Method_extra_stack_entries;
 122 
 123 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
 124 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
 125 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
 126 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 127 
 128 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 129 
 130 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 131 int CompilerToVM::Data::Universe_base_vtable_size;
 132 address CompilerToVM::Data::Universe_narrow_oop_base;
 133 int CompilerToVM::Data::Universe_narrow_oop_shift;
 134 address CompilerToVM::Data::Universe_narrow_klass_base;
 135 int CompilerToVM::Data::Universe_narrow_klass_shift;
 136 void* CompilerToVM::Data::Universe_non_oop_bits;
 137 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 138 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 139 
 140 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 141 HeapWord** CompilerToVM::Data::_heap_end_addr;
 142 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
 143 int CompilerToVM::Data::_max_oop_map_stack_offset;
 144 
 145 jbyte* CompilerToVM::Data::cardtable_start_address;
 146 int CompilerToVM::Data::cardtable_shift;
 147 
 148 int CompilerToVM::Data::vm_page_size;
 149 
 150 int CompilerToVM::Data::sizeof_vtableEntry = sizeof(vtableEntry);
 151 int CompilerToVM::Data::sizeof_ExceptionTableElement = sizeof(ExceptionTableElement);
 152 int CompilerToVM::Data::sizeof_LocalVariableTableElement = sizeof(LocalVariableTableElement);
 153 int CompilerToVM::Data::sizeof_ConstantPool = sizeof(ConstantPool);
 154 int CompilerToVM::Data::sizeof_SymbolPointer = sizeof(Symbol*);
 155 int CompilerToVM::Data::sizeof_narrowKlass = sizeof(narrowKlass);
 156 int CompilerToVM::Data::sizeof_arrayOopDesc = sizeof(arrayOopDesc);
 157 int CompilerToVM::Data::sizeof_BasicLock = sizeof(BasicLock);
 158 
 159 address CompilerToVM::Data::dsin;
 160 address CompilerToVM::Data::dcos;
 161 address CompilerToVM::Data::dtan;
 162 address CompilerToVM::Data::dexp;
 163 address CompilerToVM::Data::dlog;
 164 address CompilerToVM::Data::dlog10;
 165 address CompilerToVM::Data::dpow;
 166 
 167 address CompilerToVM::Data::symbol_init;
 168 address CompilerToVM::Data::symbol_clinit;
 169 
 170 void CompilerToVM::Data::initialize(TRAPS) {
 171   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 172   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 173 
 174   Method_extra_stack_entries = Method::extra_stack_entries();
 175 
 176   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 177   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 178   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
 179   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
 180 
 181   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
 182 
 183   Universe_collectedHeap = Universe::heap();
 184   Universe_base_vtable_size = Universe::base_vtable_size();
 185   Universe_narrow_oop_base = Universe::narrow_oop_base();
 186   Universe_narrow_oop_shift = Universe::narrow_oop_shift();
 187   Universe_narrow_klass_base = Universe::narrow_klass_base();
 188   Universe_narrow_klass_shift = Universe::narrow_klass_shift();
 189   Universe_non_oop_bits = Universe::non_oop_word();
 190   Universe_verify_oop_mask = Universe::verify_oop_mask();
 191   Universe_verify_oop_bits = Universe::verify_oop_bits();
 192 
 193   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
 194   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
 195   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
 196 
 197   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
 198   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
 199   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), "should be valid");
 200   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), "should be invalid");
 201 
 202   symbol_init = (address) vmSymbols::object_initializer_name();
 203   symbol_clinit = (address) vmSymbols::class_initializer_name();
 204 
 205   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 206   if (bs-&gt;is_a(BarrierSet::CardTableModRef)) {
 207     jbyte* base = barrier_set_cast&lt;CardTableModRefBS&gt;(bs)-&gt;byte_map_base;
 208     assert(base != 0, "unexpected byte_map_base");
 209     cardtable_start_address = base;
 210     cardtable_shift = CardTableModRefBS::card_shift;
 211   } else {
 212     // No card mark barriers
 213     cardtable_start_address = 0;
 214     cardtable_shift = 0;
 215   }
 216 
 217   vm_page_size = os::vm_page_size();
 218 
 219 #define SET_TRIGFUNC(name)                                      \
 220   if (StubRoutines::name() != NULL) {                           \
 221     name = StubRoutines::name();                                \
 222   } else {                                                      \
 223     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
 224   }
 225 
 226   SET_TRIGFUNC(dsin);
 227   SET_TRIGFUNC(dcos);
 228   SET_TRIGFUNC(dtan);
 229   SET_TRIGFUNC(dexp);
 230   SET_TRIGFUNC(dlog10);
 231   SET_TRIGFUNC(dlog);
 232   SET_TRIGFUNC(dpow);
 233 
 234 #undef SET_TRIGFUNC
 235 }
 236 
 237 objArrayHandle CompilerToVM::initialize_intrinsics(TRAPS) {
 238   objArrayHandle vmIntrinsics = oopFactory::new_objArray_handle(VMIntrinsicMethod::klass(), (vmIntrinsics::ID_LIMIT - 1), CHECK_(objArrayHandle()));
 239   int index = 0;
 240   // The intrinsics for a class are usually adjacent to each other.
 241   // When they are, the string for the class name can be reused.
 242   vmSymbols::SID kls_sid = vmSymbols::NO_SID;
 243   Handle kls_str;
 244 #define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)
 245 #define VM_SYMBOL_TO_STRING(s) \
 246   java_lang_String::create_from_symbol(vmSymbols::symbol_at(SID_ENUM(s)), CHECK_(objArrayHandle()))
 247 #define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \
 248     instanceHandle vmIntrinsicMethod = InstanceKlass::cast(VMIntrinsicMethod::klass())-&gt;allocate_instance_handle(CHECK_(objArrayHandle())); \
 249     if (kls_sid != SID_ENUM(kls)) {                                       \
 250       kls_str = VM_SYMBOL_TO_STRING(kls);                                 \
 251       kls_sid = SID_ENUM(kls);                                            \
 252     }                                                                     \
 253     Handle name_str = VM_SYMBOL_TO_STRING(name);                          \
 254     Handle sig_str = VM_SYMBOL_TO_STRING(sig);                            \
 255     VMIntrinsicMethod::set_declaringClass(vmIntrinsicMethod, kls_str());  \
 256     VMIntrinsicMethod::set_name(vmIntrinsicMethod, name_str());           \
 257     VMIntrinsicMethod::set_descriptor(vmIntrinsicMethod, sig_str());      \
 258     VMIntrinsicMethod::set_id(vmIntrinsicMethod, vmIntrinsics::id);       \
 259       vmIntrinsics-&gt;obj_at_put(index++, vmIntrinsicMethod());             \
 260   }
 261 
 262   VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
 263 #undef SID_ENUM
 264 #undef VM_SYMBOL_TO_STRING
 265 #undef VM_INTRINSIC_INFO
 266   assert(index == vmIntrinsics::ID_LIMIT - 1, "must be");
 267 
 268   return vmIntrinsics;
 269 }
 270 
 271 /**
 272  * The set of VM flags known to be used.
 273  */
 274 #define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_intx_flag, do_uintx_flag) \
 275   do_intx_flag(AllocateInstancePrefetchLines)                              \
 276   do_intx_flag(AllocatePrefetchDistance)                                   \
 277   do_intx_flag(AllocatePrefetchInstr)                                      \
 278   do_intx_flag(AllocatePrefetchLines)                                      \
 279   do_intx_flag(AllocatePrefetchStepSize)                                   \
 280   do_intx_flag(AllocatePrefetchStyle)                                      \
 281   do_intx_flag(BciProfileWidth)                                            \
 282   do_bool_flag(BootstrapJVMCI)                                             \
 283   do_bool_flag(CITime)                                                     \
 284   do_bool_flag(CITimeEach)                                                 \
 285   do_uintx_flag(CodeCacheSegmentSize)                                      \
 286   do_intx_flag(CodeEntryAlignment)                                         \
 287   do_bool_flag(CompactFields)                                              \
 288   NOT_PRODUCT(do_intx_flag(CompileTheWorldStartAt))                        \
 289   NOT_PRODUCT(do_intx_flag(CompileTheWorldStopAt))                         \
 290   do_intx_flag(ContendedPaddingWidth)                                      \
 291   do_bool_flag(DontCompileHugeMethods)                                     \
 292   do_bool_flag(EnableContended)                                            \
 293   do_intx_flag(FieldsAllocationStyle)                                      \
 294   do_bool_flag(FoldStableValues)                                           \
 295   do_bool_flag(ForceUnreachable)                                           \
 296   do_intx_flag(HugeMethodLimit)                                            \
 297   do_bool_flag(Inline)                                                     \
 298   do_intx_flag(JVMCICounterSize)                                           \
 299   do_bool_flag(JVMCIPrintProperties)                                       \
 300   do_bool_flag(JVMCIUseFastLocking)                                        \
 301   do_intx_flag(MethodProfileWidth)                                         \
 302   do_intx_flag(ObjectAlignmentInBytes)                                     \
 303   do_bool_flag(PrintInlining)                                              \
 304   do_bool_flag(ReduceInitialCardMarks)                                     \
 305   do_bool_flag(RestrictContended)                                          \
 306   do_intx_flag(StackReservedPages)                                         \
 307   do_intx_flag(StackShadowPages)                                           \
 308   do_bool_flag(TLABStats)                                                  \
 309   do_uintx_flag(TLABWasteIncrement)                                        \
 310   do_intx_flag(TypeProfileWidth)                                           \
 311   do_bool_flag(UseAESIntrinsics)                                           \
 312   X86_ONLY(do_intx_flag(UseAVX))                                           \
 313   do_bool_flag(UseBiasedLocking)                                           \
 314   do_bool_flag(UseCRC32Intrinsics)                                         \
 315   do_bool_flag(UseCompressedClassPointers)                                 \
 316   do_bool_flag(UseCompressedOops)                                          \
 317   do_bool_flag(UseConcMarkSweepGC)                                         \
 318   X86_ONLY(do_bool_flag(UseCountLeadingZerosInstruction))                  \
 319   X86_ONLY(do_bool_flag(UseCountTrailingZerosInstruction))                 \
 320   do_bool_flag(UseG1GC)                                                    \
 321   COMPILER2_PRESENT(do_bool_flag(UseMontgomeryMultiplyIntrinsic))          \
 322   COMPILER2_PRESENT(do_bool_flag(UseMontgomerySquareIntrinsic))            \
 323   COMPILER2_PRESENT(do_bool_flag(UseMulAddIntrinsic))                      \
 324   COMPILER2_PRESENT(do_bool_flag(UseMultiplyToLenIntrinsic))               \
 325   do_bool_flag(UsePopCountInstruction)                                     \
 326   do_bool_flag(UseSHA1Intrinsics)                                          \
 327   do_bool_flag(UseSHA256Intrinsics)                                        \
 328   do_bool_flag(UseSHA512Intrinsics)                                        \
 329   do_intx_flag(UseSSE)                                                     \
 330   COMPILER2_PRESENT(do_bool_flag(UseSquareToLenIntrinsic))                 \
 331   do_bool_flag(UseStackBanging)                                            \
 332   do_bool_flag(UseTLAB)                                                    \
 333   do_bool_flag(VerifyOops)                                                 \
 334 
 335 #define BOXED_BOOLEAN(name, value) oop name = ((jboolean)(value) ? boxedTrue() : boxedFalse())
 336 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)
 337 #define BOXED_LONG(name, value) \
 338   oop name; \
 339   do { \
 340     jvalue p; p.j = (jlong) (value); \
 341     Handle* e = longs.get(p.j); \
 342     if (e == NULL) { \
 343       oop o = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); \
 344       Handle h(THREAD, o); \
 345       longs.put(p.j, h); \
 346       name = h(); \
 347     } else { \
 348       name = (*e)(); \
 349     } \
 350   } while (0)
 351 
 352 #define CSTRING_TO_JSTRING(name, value) \
 353   Handle name; \
 354   do { \
 355     if (value != NULL) { \
 356       Handle* e = strings.get(value); \
 357       if (e == NULL) { \
 358         Handle h = java_lang_String::create_from_str(value, CHECK_NULL); \
 359         strings.put(value, h); \
 360         name = h; \
 361       } else { \
 362         name = (*e); \
 363       } \
 364     } \
 365   } while (0)
 366 
 367 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))
 368   ResourceMark rm;
 369   HandleMark hm;
 370 
 371   // Used to canonicalize Long and String values.
 372   ResourceHashtable&lt;jlong, Handle&gt; longs;
 373   ResourceHashtable&lt;const char*, Handle, &amp;CompilerToVM::cstring_hash, &amp;CompilerToVM::cstring_equals&gt; strings;
 374 
 375   jvalue prim;
 376   prim.z = true;  oop boxedTrueOop =  java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 377   Handle boxedTrue(THREAD, boxedTrueOop);
 378   prim.z = false; oop boxedFalseOop = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 379   Handle boxedFalse(THREAD, boxedFalseOop);
 380 
 381   CompilerToVM::Data::initialize(CHECK_NULL);
 382 
 383   VMField::klass()-&gt;initialize(CHECK_NULL);
 384   VMFlag::klass()-&gt;initialize(CHECK_NULL);
 385   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);
 386 
 387   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
 388   objArrayHandle vmFields = oopFactory::new_objArray_handle(VMField::klass(), len, CHECK_NULL);
 389   for (int i = 0; i &lt; len ; i++) {
 390     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
 391     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);
 392     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* "::" */;
 393     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
 394     sprintf(name_buf, "%s::%s", vmField.typeName, vmField.fieldName);
 395     CSTRING_TO_JSTRING(name, name_buf);
 396     CSTRING_TO_JSTRING(type, vmField.typeString);
 397     VMField::set_name(vmFieldObj, name());
 398     VMField::set_type(vmFieldObj, type());
 399     VMField::set_offset(vmFieldObj, vmField.offset);
 400     VMField::set_address(vmFieldObj, (jlong) vmField.address);
 401     if (vmField.isStatic &amp;&amp; vmField.typeString != NULL) {
 402       if (strcmp(vmField.typeString, "bool") == 0) {
 403         BOXED_BOOLEAN(box, *(jbyte*) vmField.address);
 404         VMField::set_value(vmFieldObj, box);
 405       } else if (strcmp(vmField.typeString, "int") == 0 ||
 406                  strcmp(vmField.typeString, "jint") == 0) {
 407         BOXED_LONG(box, *(jint*) vmField.address);
 408         VMField::set_value(vmFieldObj, box);
 409       } else if (strcmp(vmField.typeString, "uint64_t") == 0) {
 410         BOXED_LONG(box, *(uint64_t*) vmField.address);
 411         VMField::set_value(vmFieldObj, box);
 412       } else if (strcmp(vmField.typeString, "address") == 0 ||
 413                  strcmp(vmField.typeString, "intptr_t") == 0 ||
 414                  strcmp(vmField.typeString, "uintptr_t") == 0 ||
 415                  strcmp(vmField.typeString, "OopHandle") == 0 ||
 416                  strcmp(vmField.typeString, "size_t") == 0 ||
 417                  // All foo* types are addresses.
 418                  vmField.typeString[strlen(vmField.typeString) - 1] == '*') {
 419         BOXED_LONG(box, *((address*) vmField.address));
 420         VMField::set_value(vmFieldObj, box);
 421       } else {
 422         JVMCI_ERROR_NULL("VM field %s has unsupported type %s", name_buf, vmField.typeString);
 423       }
 424     }
 425     vmFields-&gt;obj_at_put(i, vmFieldObj());
 426   }
 427 
 428   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
 429   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
 430   len = ints_len + longs_len;
 431   objArrayHandle vmConstants = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 432   int insert = 0;
 433   for (int i = 0; i &lt; ints_len ; i++) {
 434     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
 435     CSTRING_TO_JSTRING(name, c.name);
 436     BOXED_LONG(value, c.value);
 437     vmConstants-&gt;obj_at_put(insert++, name());
 438     vmConstants-&gt;obj_at_put(insert++, value);
 439   }
 440   for (int i = 0; i &lt; longs_len ; i++) {
 441     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
 442     CSTRING_TO_JSTRING(name, c.name);
 443     BOXED_LONG(value, c.value);
 444     vmConstants-&gt;obj_at_put(insert++, name());
 445     vmConstants-&gt;obj_at_put(insert++, value);
 446   }
 447   assert(insert == len * 2, "must be");
 448 
 449   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
 450   objArrayHandle vmAddresses = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);
 451   for (int i = 0; i &lt; len ; i++) {
 452     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
 453     CSTRING_TO_JSTRING(name, a.name);
 454     BOXED_LONG(value, a.value);
 455     vmAddresses-&gt;obj_at_put(i * 2, name());
 456     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);
 457   }
 458 
 459 #define COUNT_FLAG(ignore) +1
 460 #ifdef ASSERT
 461 #define CHECK_FLAG(type, name) { \
 462   Flag* flag = Flag::find_flag(#name, strlen(#name), /*allow_locked*/ true, /* return_flag */ true); \
 463   assert(flag != NULL, "No such flag named " #name); \
 464   assert(flag-&gt;is_##type(), "Flag " #name " is not of type " #type); \
 465 }
 466 #else
 467 #define CHECK_FLAG(type, name)
 468 #endif
 469 
 470 #define ADD_FLAG(type, name, convert) { \
 471   CHECK_FLAG(type, name) \
 472   instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL); \
 473   CSTRING_TO_JSTRING(fname, #name); \
 474   CSTRING_TO_JSTRING(ftype, #type); \
 475   VMFlag::set_name(vmFlagObj, fname()); \
 476   VMFlag::set_type(vmFlagObj, ftype()); \
 477   convert(value, name); \
 478   VMFlag::set_value(vmFlagObj, value); \
 479   vmFlags-&gt;obj_at_put(i++, vmFlagObj()); \
 480 }
 481 #define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)
 482 #define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)
 483 #define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)
 484 
 485   len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);
 486   objArrayHandle vmFlags = oopFactory::new_objArray_handle(VMFlag::klass(), len, CHECK_NULL);
 487   int i = 0;
 488   PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)
 489 
 490   objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);
 491 
 492   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 5, CHECK_NULL);
 493   data-&gt;obj_at_put(0, vmFields());
 494   data-&gt;obj_at_put(1, vmConstants());
 495   data-&gt;obj_at_put(2, vmAddresses());
 496   data-&gt;obj_at_put(3, vmFlags());
 497   data-&gt;obj_at_put(4, vmIntrinsics());
 498 
 499   return (jobjectArray) JNIHandles::make_local(THREAD, data);
 500 #undef COUNT_FLAG
 501 #undef ADD_FLAG
 502 #undef ADD_BOOL_FLAG
 503 #undef ADD_INTX_FLAG
 504 #undef ADD_UINTX_FLAG
 505 #undef CHECK_FLAG
 506 C2V_END
 507 
 508 C2V_VMENTRY(jobject, getFlagValue, (JNIEnv *, jobject c2vm, jobject name_handle))
 509 #define RETURN_BOXED_LONG(value) oop box; jvalue p; p.j = (jlong) (value); box = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);
 510 #define RETURN_BOXED_DOUBLE(value) oop box; jvalue p; p.d = (jdouble) (value); box = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);
 511   Handle name(THREAD, JNIHandles::resolve(name_handle));
 512   if (name.is_null()) {
 513     THROW_0(vmSymbols::java_lang_NullPointerException());
 514   }
 515   ResourceMark rm;
 516   const char* cstring = java_lang_String::as_utf8_string(name());
 517   Flag* flag = Flag::find_flag(cstring, strlen(cstring), /* allow_locked */ true, /* return_flag */ true);
 518   if (flag == NULL) {
 519     return c2vm;
 520   }
 521   if (flag-&gt;is_bool()) {
 522     jvalue prim;
 523     prim.z = flag-&gt;get_bool();
 524     oop box = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 525     return JNIHandles::make_local(THREAD, box);
 526   } else if (flag-&gt;is_ccstr()) {
 527     Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
 528     return JNIHandles::make_local(THREAD, value());
 529   } else if (flag-&gt;is_intx()) {
 530     RETURN_BOXED_LONG(flag-&gt;get_intx());
 531   } else if (flag-&gt;is_int()) {
 532     RETURN_BOXED_LONG(flag-&gt;get_int());
 533   } else if (flag-&gt;is_uint()) {
 534     RETURN_BOXED_LONG(flag-&gt;get_uint());
 535   } else if (flag-&gt;is_uint64_t()) {
 536     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());
 537   } else if (flag-&gt;is_size_t()) {
 538     RETURN_BOXED_LONG(flag-&gt;get_size_t());
 539   } else if (flag-&gt;is_uintx()) {
 540     RETURN_BOXED_LONG(flag-&gt;get_uintx());
 541   } else if (flag-&gt;is_double()) {
 542     RETURN_BOXED_DOUBLE(flag-&gt;get_double());
 543   } else {
 544     JVMCI_ERROR_NULL("VM flag %s has unsupported type %s", flag-&gt;_name, flag-&gt;_type);
 545   }
 546 C2V_END
 547 
 548 #undef BOXED_LONG
 549 #undef BOXED_DOUBLE
 550 #undef CSTRING_TO_JSTRING
 551 
 552 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 553   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 554   ResourceMark rm;
 555 
 556   int code_size = method-&gt;code_size();
 557   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 558 
 559   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), "Method's holder should be rewritten");
 560   // iterate over all bytecodes and replace non-Java bytecodes
 561 
 562   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 563     Bytecodes::Code code = s.code();
 564     Bytecodes::Code raw_code = s.raw_code();
 565     int bci = s.bci();
 566     int len = s.instruction_size();
 567 
 568     // Restore original byte code.
 569     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 570     if (len &gt; 1) {
 571       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);
 572     }
 573 
 574     if (len &gt; 1) {
 575       // Restore the big-endian constant pool indexes.
 576       // Cf. Rewriter::scan_method
 577       switch (code) {
 578         case Bytecodes::_getstatic:
 579         case Bytecodes::_putstatic:
 580         case Bytecodes::_getfield:
 581         case Bytecodes::_putfield:
 582         case Bytecodes::_invokevirtual:
 583         case Bytecodes::_invokespecial:
 584         case Bytecodes::_invokestatic:
 585         case Bytecodes::_invokeinterface:
 586         case Bytecodes::_invokehandle: {
 587           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 588           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 589           break;
 590         }
 591 
 592         case Bytecodes::_invokedynamic: {
 593           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 594           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);
 595           break;
 596         }
 597 
 598         default:
 599           break;
 600       }
 601 
 602       // Not all ldc byte code are rewritten.
 603       switch (raw_code) {
 604         case Bytecodes::_fast_aldc: {
 605           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;
 606           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 607           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 608           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);
 609           break;
 610         }
 611 
 612         case Bytecodes::_fast_aldc_w: {
 613           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 614           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 615           assert(cp_index &lt; method-&gt;constants()-&gt;length(), "sanity check");
 616           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 617           break;
 618         }
 619 
 620         default:
 621           break;
 622       }
 623     }
 624   }
 625 
 626   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);
 627 C2V_END
 628 
 629 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 630   ResourceMark rm;
 631   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 632   return method-&gt;exception_table_length();
 633 C2V_END
 634 
 635 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 636   ResourceMark rm;
 637   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 638   if (method-&gt;exception_table_length() == 0) {
 639     return 0L;
 640   }
 641   return (jlong) (address) method-&gt;exception_table_start();
 642 C2V_END
 643 
 644 C2V_VMENTRY(jobject, asResolvedJavaMethod, (JNIEnv *, jobject, jobject executable_handle))
 645   oop executable = JNIHandles::resolve(executable_handle);
 646   oop mirror = NULL;
 647   int slot = 0;
 648 
 649   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 650     mirror = java_lang_reflect_Constructor::clazz(executable);
 651     slot = java_lang_reflect_Constructor::slot(executable);
 652   } else {
 653     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), "wrong type");
 654     mirror = java_lang_reflect_Method::clazz(executable);
 655     slot = java_lang_reflect_Method::slot(executable);
 656   }
 657   Klass* holder = java_lang_Class::as_Klass(mirror);
 658   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 659   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 660   return JNIHandles::make_local(THREAD, result);
 661 }
 662 
 663 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))
 664   methodHandle method;
 665   oop base_object = JNIHandles::resolve(base);
 666   if (base_object == NULL) {
 667     method = *((Method**)(offset));
 668   } else if (base_object-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {
 669     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);
 670   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 671     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));
 672   } else {
 673     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 674                 err_msg("Unexpected type: %s", base_object-&gt;klass()-&gt;external_name()));
 675   }
 676   assert (method.is_null() || method-&gt;is_method(), "invalid read");
 677   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 678   return JNIHandles::make_local(THREAD, result);
 679 }
 680 
 681 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject object_handle))
 682   constantPoolHandle cp;
 683   oop object = JNIHandles::resolve(object_handle);
 684   if (object == NULL) {
 685     THROW_0(vmSymbols::java_lang_NullPointerException());
 686   }
 687   if (object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 688     cp = CompilerToVM::asMethod(object)-&gt;constMethod()-&gt;constants();
 689   } else if (object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 690     cp = InstanceKlass::cast(CompilerToVM::asKlass(object))-&gt;constants();
 691   } else {
 692     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 693                 err_msg("Unexpected type: %s", object-&gt;klass()-&gt;external_name()));
 694   }
 695   assert(!cp.is_null(), "npe");
 696   JavaValue method_result(T_OBJECT);
 697   JavaCallArguments args;
 698   args.push_long((jlong) (address) cp());
 699   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 700   return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());
 701 }
 702 
 703 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))
 704   Klass* klass = NULL;
 705   oop base_object = JNIHandles::resolve(base);
 706   jlong base_address = 0;
 707   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 708     klass = base_object-&gt;klass();
 709   } else if (!compressed) {
 710     if (base_object != NULL) {
 711       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 712         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 713       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 714         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 715       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 716         base_address = (jlong) CompilerToVM::asKlass(base_object);
 717       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {
 718         base_address = (jlong) (address) base_object;
 719       } else {
 720         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 721                     err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 722       }
 723     }
 724     klass = *((Klass**) (intptr_t) (base_address + offset));
 725   } else {
 726     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 727                 err_msg("Unexpected arguments: %s " JLONG_FORMAT " %s", base_object-&gt;klass()-&gt;external_name(), offset, compressed ? "true" : "false"));
 728   }
 729   assert (klass == NULL || klass-&gt;is_klass(), "invalid read");
 730   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 731   return JNIHandles::make_local(THREAD, result);
 732 }
 733 
 734 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 735   ResourceMark rm;
 736   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 737   Klass* holder = CompilerToVM::asKlass(jvmci_type);
 738   if (holder-&gt;is_interface()) {
 739     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", holder-&gt;external_name()));
 740   }
 741 
 742   methodHandle ucm;
 743   {
 744     MutexLocker locker(Compile_lock);
 745     ucm = Dependencies::find_unique_concrete_method(holder, method());
 746   }
 747   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);
 748   return JNIHandles::make_local(THREAD, result);
 749 C2V_END
 750 
 751 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))
 752   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 753   oop implementor = CompilerToVM::get_jvmci_type(klass-&gt;implementor(), CHECK_NULL);
 754   return JNIHandles::make_local(THREAD, implementor);
 755 C2V_END
 756 
 757 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))
 758   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 759   return method-&gt;is_ignored_by_security_stack_walk();
 760 C2V_END
 761 
 762 C2V_VMENTRY(jboolean, isCompilable,(JNIEnv *, jobject, jobject jvmci_method))
 763   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 764   return !method-&gt;is_not_compilable(CompLevel_full_optimization);
 765 C2V_END
 766 
 767 C2V_VMENTRY(jboolean, hasNeverInlineDirective,(JNIEnv *, jobject, jobject jvmci_method))
 768   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 769   return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 770 C2V_END
 771 
 772 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 773   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 774   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 775 C2V_END
 776 
 777 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 778   ResourceMark rm;
 779   Handle name(THREAD, JNIHandles::resolve(jname));
 780   Symbol* class_name = java_lang_String::as_symbol(name(), CHECK_0);
 781   if (java_lang_String::length(name()) &lt;= 1) {
 782     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Primitive type %s should be handled in Java code", class_name-&gt;as_C_string()));
 783   }
 784 
 785   Klass* resolved_klass = NULL;
 786   if (JNIHandles::resolve(accessing_class) == NULL) {
 787     THROW_0(vmSymbols::java_lang_NullPointerException());
 788   }
 789   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));
 790   Handle class_loader(THREAD, accessing_klass-&gt;class_loader());
 791   Handle protection_domain(THREAD, accessing_klass-&gt;protection_domain());
 792 
 793   if (resolve) {
 794     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 795   } else {
 796     if (class_name-&gt;byte_at(0) == 'L' &amp;&amp;
 797       class_name-&gt;byte_at(class_name-&gt;utf8_length()-1) == ';') {
 798       // This is a name from a signature.  Strip off the trimmings.
 799       // Call recursive to keep scope of strippedsym.
 800       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 801                                                           class_name-&gt;utf8_length()-2,
 802                                                           CHECK_0);
 803       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 804     } else if (FieldType::is_array(class_name)) {
 805       FieldArrayInfo fd;
 806       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 807       // of this call
 808       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 809       if (t == T_OBJECT) {
 810         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 811                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 812                                                             CHECK_0);
 813         // naked oop "k" is OK here -- we assign back into it
 814         resolved_klass = SystemDictionary::find(strippedsym,
 815                                                              class_loader,
 816                                                              protection_domain,
 817                                                              CHECK_0);
 818         if (resolved_klass != NULL) {
 819           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 820         }
 821       } else {
 822         resolved_klass = Universe::typeArrayKlassObj(t);
 823         resolved_klass = TypeArrayKlass::cast(resolved_klass)-&gt;array_klass(fd.dimension(), CHECK_0);
 824       }
 825     }
 826   }
 827   oop result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 828   return JNIHandles::make_local(THREAD, result);
 829 C2V_END
 830 
 831 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 832   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 833   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);
 834   return JNIHandles::make_local(THREAD, result);
 835 C2V_END
 836 
 837 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 838   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 839   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 840   return JNIHandles::make_local(THREAD, result);
 841 C2V_END
 842 
 843 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 844   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 845   return cp-&gt;name_and_type_ref_index_at(index);
 846 C2V_END
 847 
 848 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 849   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 850   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);
 851   return JNIHandles::make_local(THREAD, sym());
 852 C2V_END
 853 
 854 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 855   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 856   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);
 857   return JNIHandles::make_local(THREAD, sym());
 858 C2V_END
 859 
 860 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 861   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 862   return cp-&gt;klass_ref_index_at(index);
 863 C2V_END
 864 
 865 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 866   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 867   Klass* resolved_klass = cp-&gt;klass_at(index, CHECK_NULL);
 868   oop klass = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 869   return JNIHandles::make_local(THREAD, klass);
 870 C2V_END
 871 
 872 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 873   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 874   Klass* loading_klass = cp-&gt;pool_holder();
 875   bool is_accessible = false;
 876   Klass* klass = JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass);
 877   Symbol* symbol = NULL;
 878   if (klass == NULL) {
 879     symbol = cp-&gt;klass_name_at(index);
 880   }
 881   oop result_oop;
 882   if (klass != NULL) {
 883     result_oop = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 884   } else {
 885     Handle result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
 886     result_oop = result();
 887   }
 888   return JNIHandles::make_local(THREAD, result_oop);
 889 C2V_END
 890 
 891 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 892   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 893   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 894   return JNIHandles::make_local(THREAD, appendix_oop);
 895 C2V_END
 896 
 897 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 898   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 899   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 900   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 901   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 902   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 903   return JNIHandles::make_local(THREAD, result);
 904 C2V_END
 905 
 906 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 907   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 908   return cp-&gt;remap_instruction_operand_from_cache(index);
 909 C2V_END
 910 
 911 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))
 912   ResourceMark rm;
 913   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 914   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 915   fieldDescriptor fd;
 916   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
 917   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 918   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
 919   if (info == NULL || info-&gt;length() != 3) {
 920     JVMCI_ERROR_NULL("info must not be null and have a length of 3");
 921   }
 922   info-&gt;int_at_put(0, fd.access_flags().as_int());
 923   info-&gt;int_at_put(1, fd.offset());
 924   info-&gt;int_at_put(2, fd.index());
 925   oop field_holder = CompilerToVM::get_jvmci_type(fd.field_holder(), CHECK_NULL);
 926   return JNIHandles::make_local(THREAD, field_holder);
 927 C2V_END
 928 
 929 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 930   ResourceMark rm;
 931   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 932   Method* method = CompilerToVM::asMethod(jvmci_method);
 933   if (klass-&gt;is_interface()) {
 934     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Interface %s should be handled in Java code", klass-&gt;external_name()));
 935   }
 936   if (!method-&gt;method_holder()-&gt;is_interface()) {
 937     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Method %s is not held by an interface, this case should be handled in Java code", method-&gt;name_and_sig_as_C_string()));
 938   }
 939   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 940     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg("Class %s must be linked", klass-&gt;external_name()));
 941   }
 942   return LinkResolver::vtable_index_of_interface_method(klass, method);
 943 C2V_END
 944 
 945 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 946   Klass* recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);
 947   Klass* caller_klass = CompilerToVM::asKlass(caller_jvmci_type);
 948   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 949 
 950   Klass* resolved     = method-&gt;method_holder();
 951   Symbol* h_name      = method-&gt;name();
 952   Symbol* h_signature = method-&gt;signature();
 953 
 954   if (MethodHandles::is_signature_polymorphic_method(method())) {
 955       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 956       return NULL;
 957   }
 958 
 959   LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
 960   methodHandle m;
 961   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 962   // the vtable has not been setup, and the LinkResolver will fail.
 963   if (recv_klass-&gt;is_array_klass() ||
 964       (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
 965     if (resolved-&gt;is_interface()) {
 966       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 967     } else {
 968       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 969     }
 970   }
 971 
 972   if (m.is_null()) {
 973     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 974     return NULL;
 975   }
 976 
 977   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);
 978   return JNIHandles::make_local(THREAD, result);
 979 C2V_END
 980 
 981 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))
 982   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 983   assert(klass != NULL, "method must not be called for primitive types");
 984   return Dependencies::find_finalizable_subclass(klass) != NULL;
 985 C2V_END
 986 
 987 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))
 988   InstanceKlass* klass = (InstanceKlass*) CompilerToVM::asKlass(jvmci_type);
 989   oop result = CompilerToVM::get_jvmci_method(klass-&gt;class_initializer(), CHECK_NULL);
 990   return JNIHandles::make_local(THREAD, result);
 991 C2V_END
 992 
 993 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))
 994   address target_addr = (address) addr;
 995   if (target_addr != 0x0) {
 996     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 997     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 998     return MAX2(ABS(off_low), ABS(off_high));
 999   }
1000   return -1;
1001 C2V_END
1002 
1003 C2V_VMENTRY(void, setNotInlineableOrCompileable,(JNIEnv *, jobject,  jobject jvmci_method))
1004   methodHandle method = CompilerToVM::asMethod(jvmci_method);
1005   method-&gt;set_not_c1_compilable();
1006   method-&gt;set_not_c2_compilable();
1007   method-&gt;set_dont_inline(true);
1008 C2V_END
1009 
1010 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))
1011   ResourceMark rm;
1012   HandleMark hm;
1013   JNIHandleMark jni_hm;
1014 
1015   Handle target_handle(THREAD, JNIHandles::resolve(target));
1016   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));
1017   CodeBlob* cb = NULL;
1018   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));
1019   Handle speculation_log_handle(THREAD, JNIHandles::resolve(speculation_log));
1020 
1021   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK_JNI_ERR);
1022 
1023   TraceTime install_time("installCode", JVMCICompiler::codeInstallTimer());
1024   bool is_immutable_PIC = HotSpotCompiledCode::isImmutablePIC(compiled_code_handle) &gt; 0;
1025   CodeInstaller installer(is_immutable_PIC);
1026   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);
1027 
1028   if (PrintCodeCacheOnCompilation) {
1029     stringStream s;
1030     // Dump code cache  into a buffer before locking the tty,
1031     {
1032       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1033       CodeCache::print_summary(&amp;s, false);
1034     }
1035     ttyLocker ttyl;
1036     tty-&gt;print_raw_cr(s.as_string());
1037   }
1038 
1039   if (result != JVMCIEnv::ok) {
1040     assert(cb == NULL, "should be");
1041   } else {
1042     if (installed_code_handle.not_null()) {
1043       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), "wrong type");
1044       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);
1045       {
1046         // Ensure that all updates to the InstalledCode fields are consistent.
1047         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
1048         InstalledCode::set_address(installed_code_handle, (jlong) cb);
1049         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);
1050         if (cb-&gt;is_nmethod()) {
1051           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());
1052         } else {
1053           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());
1054         }
1055         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {
1056           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());
1057           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());
1058           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());
1059         }
1060       }
1061     }
1062   }
1063   return result;
1064 C2V_END
1065 
1066 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))
1067   ResourceMark rm;
1068   HandleMark hm;
1069 
1070   Handle target_handle(THREAD, JNIHandles::resolve(target));
1071   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));
1072   Handle metadata_handle(THREAD, JNIHandles::resolve(metadata));
1073 
1074   CodeMetadata code_metadata;
1075   CodeBlob *cb = NULL;
1076   CodeInstaller installer(true /* immutable PIC compilation */);
1077 
1078   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);
1079   if (result != JVMCIEnv::ok) {
1080     return result;
1081   }
1082 
1083   if (code_metadata.get_nr_pc_desc() &gt; 0) {
1084     typeArrayHandle pcArrayOop = oopFactory::new_byteArray_handle(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));
1085     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());
1086     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());
1087   }
1088 
1089   if (code_metadata.get_scopes_size() &gt; 0) {
1090     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray_handle(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));
1091     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());
1092     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());
1093   }
1094 
1095   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
1096   typeArrayHandle relocArrayOop = oopFactory::new_byteArray_handle((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));
1097   if (reloc_buffer-&gt;size() &gt; 0) {
1098     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());
1099   }
1100   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());
1101 
1102   const OopMapSet* oopMapSet = installer.oopMapSet();
1103   {
1104     ResourceMark mark;
1105     ImmutableOopMapBuilder builder(oopMapSet);
1106     int oopmap_size = builder.heap_size();
1107     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray_handle(oopmap_size, CHECK_(JVMCIEnv::cache_full));
1108     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));
1109     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());
1110   }
1111 
1112   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
1113 
1114   int nr_meta_refs = recorder-&gt;nr_meta_refs();
1115   objArrayOop metadataArray = oopFactory::new_objectArray(nr_meta_refs, CHECK_(JVMCIEnv::cache_full));
1116   objArrayHandle metadataArrayHandle(THREAD, metadataArray);
1117   for (int i = 0; i &lt; nr_meta_refs; ++i) {
1118     jobject element = recorder-&gt;meta_element(i);
1119     if (element == NULL) {
1120       return JVMCIEnv::cache_full;
1121     }
1122     metadataArrayHandle-&gt;obj_at_put(i, JNIHandles::resolve(element));
1123   }
1124   HotSpotMetaData::set_metadata(metadata_handle, metadataArrayHandle());
1125 
1126   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
1127   int table_size = handler-&gt;size_in_bytes();
1128   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray_handle(table_size, CHECK_(JVMCIEnv::cache_full));
1129 
1130   if (table_size &gt; 0) {
1131     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));
1132   }
1133   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());
1134 
1135   return result;
1136 C2V_END
1137 
1138 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))
1139   JVMCICompiler* compiler = JVMCICompiler::instance(CHECK);
1140   CompilerStatistics* stats = compiler-&gt;stats();
1141   stats-&gt;_standard.reset();
1142   stats-&gt;_osr.reset();
1143 C2V_END
1144 
1145 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))
1146   ResourceMark rm;
1147   HandleMark hm;
1148 
1149   if (installedCode == NULL) {
1150     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), "installedCode is null");
1151   }
1152 
1153   jlong codeBlob = InstalledCode::address(installedCode);
1154   if (codeBlob == 0L) {
1155     return NULL;
1156   }
1157 
1158   CodeBlob* cb = (CodeBlob*) (address) codeBlob;
1159   if (cb == NULL) {
1160     return NULL;
1161   }
1162 
1163   // We don't want the stringStream buffer to resize during disassembly as it
1164   // uses scoped resource memory. If a nested function called during disassembly uses
1165   // a ResourceMark and the buffer expands within the scope of the mark,
1166   // the buffer becomes garbage when that scope is exited. Experience shows that
1167   // the disassembled code is typically about 10x the code size so a fixed buffer
1168   // sized to 20x code size plus a fixed amount for header info should be sufficient.
1169   int bufferSize = cb-&gt;code_size() * 20 + 1024;
1170   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
1171   stringStream st(buffer, bufferSize);
1172   if (cb-&gt;is_nmethod()) {
1173     nmethod* nm = (nmethod*) cb;
1174     if (!nm-&gt;is_alive()) {
1175       return NULL;
1176     }
1177   }
1178   Disassembler::decode(cb, &amp;st);
1179   if (st.size() &lt;= 0) {
1180     return NULL;
1181   }
1182 
1183   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);
1184   return JNIHandles::make_local(THREAD, result());
1185 C2V_END
1186 
1187 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))
1188   ResourceMark rm;
1189   HandleMark hm;
1190 
1191   methodHandle method = CompilerToVM::asMethod(jvmci_method);
1192   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);
1193   return JNIHandles::make_local(THREAD, element);
1194 C2V_END
1195 
1196 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))
1197   ResourceMark rm;
1198   HandleMark hm;
1199 
1200   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);
1201   if (nmethodValue == 0L) {
1202     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
1203   }
1204   nmethod* nm = (nmethod*) (address) nmethodValue;
1205   methodHandle mh = nm-&gt;method();
1206   Symbol* signature = mh-&gt;signature();
1207   JavaCallArguments jca(mh-&gt;size_of_parameters());
1208 
1209   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1210   JavaValue result(jap.get_ret_type());
1211   jca.set_alternative_target(nm);
1212   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1213 
1214   if (jap.get_ret_type() == T_VOID) {
1215     return NULL;
1216   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
1217     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
1218   } else {
1219     jvalue *value = (jvalue *) result.get_value_addr();
1220     // Narrow the value down if required (Important on big endian machines)
1221     switch (jap.get_ret_type()) {
1222       case T_BOOLEAN:
1223        value-&gt;z = (jboolean) value-&gt;i;
1224        break;
1225       case T_BYTE:
1226        value-&gt;b = (jbyte) value-&gt;i;
1227        break;
1228       case T_CHAR:
1229        value-&gt;c = (jchar) value-&gt;i;
1230        break;
1231       case T_SHORT:
1232        value-&gt;s = (jshort) value-&gt;i;
1233        break;
1234       default:
1235         break;
1236     }
1237     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);
1238     return JNIHandles::make_local(THREAD, o);
1239   }
1240 C2V_END
1241 
1242 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))
1243   Method* method = CompilerToVM::asMethod(jvmci_method);
1244   if (!method-&gt;has_linenumber_table()) {
1245     return NULL;
1246   }
1247   u2 num_entries = 0;
1248   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1249   while (streamForSize.read_pair()) {
1250     num_entries++;
1251   }
1252 
1253   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1254   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);
1255 
1256   int i = 0;
1257   jlong value;
1258   while (stream.read_pair()) {
1259     value = ((long) stream.bci());
1260     result-&gt;long_at_put(i, value);
1261     value = ((long) stream.line());
1262     result-&gt;long_at_put(i + 1, value);
1263     i += 2;
1264   }
1265 
1266   return (jlongArray) JNIHandles::make_local(THREAD, result);
1267 C2V_END
1268 
1269 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))
1270   ResourceMark rm;
1271   Method* method = CompilerToVM::asMethod(jvmci_method);
1272   if (!method-&gt;has_localvariable_table()) {
1273     return 0;
1274   }
1275   return (jlong) (address) method-&gt;localvariable_table_start();
1276 C2V_END
1277 
1278 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))
1279   ResourceMark rm;
1280   Method* method = CompilerToVM::asMethod(jvmci_method);
1281   return method-&gt;localvariable_table_length();
1282 C2V_END
1283 
1284 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))
1285   Method* method = CompilerToVM::asMethod(jvmci_method);
1286   MethodCounters* mcs = method-&gt;method_counters();
1287   if (mcs != NULL) {
1288     mcs-&gt;clear_counters();
1289   }
1290   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1291 
1292   CompiledMethod* code = method-&gt;code();
1293   if (code != NULL) {
1294     code-&gt;make_not_entrant();
1295   }
1296 
1297   MethodData* method_data = method-&gt;method_data();
1298   if (method_data == NULL) {
1299     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1300     method_data = MethodData::allocate(loader_data, method, CHECK);
1301     method-&gt;set_method_data(method_data);
1302   } else {
1303     method_data-&gt;initialize();
1304   }
1305 C2V_END
1306 
1307 
1308 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))
1309   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));
1310   nmethod::invalidate_installed_code(installed_code_handle, CHECK);
1311 C2V_END
1312 
1313 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))
1314   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);
1315   JavaThread::collect_counters(arrayOop);
1316   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);
1317 C2V_END
1318 
1319 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))
1320   HandleMark hm;
1321   ResourceMark rm;
1322   if (JNIHandles::resolve(jvmci_method) == NULL) {
1323     THROW_0(vmSymbols::java_lang_NullPointerException());
1324   }
1325   Method* method = CompilerToVM::asMethod(jvmci_method);
1326   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1327     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Unexpected bci %d", entry_bci));
1328   }
1329   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1330 C2V_END
1331 
1332 
1333 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))
1334   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1335   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1336 C2V_END
1337 
1338 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1339   Method* method = CompilerToVM::asMethod(jvmci_method);
1340   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1341 C2V_END
1342 
1343 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))
1344   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);
1345   return JNIHandles::make_local(THREAD, sym());
1346 C2V_END
1347 
1348 bool matches(jobjectArray methods, Method* method) {
1349   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1350 
1351   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1352     oop resolved = methods_oop-&gt;obj_at(i);
1353     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {
1354       return true;
1355     }
1356   }
1357   return false;
1358 }
1359 
1360 C2V_VMENTRY(jobject, getNextStackFrame, (JNIEnv*, jobject compilerToVM, jobject hs_frame, jobjectArray methods, jint initialSkip))
1361   ResourceMark rm;
1362 
1363   if (!thread-&gt;has_last_Java_frame()) return NULL;
1364   Handle result = HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1365   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1366 
1367   StackFrameStream fst(thread);
1368   if (hs_frame != NULL) {
1369     // look for the correct stack frame if one is given
1370     intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1371     while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1372       fst.next();
1373     }
1374     if (fst.current()-&gt;sp() != stack_pointer) {
1375       THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1376     }
1377   }
1378 
1379   int frame_number = 0;
1380   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1381   if (hs_frame != NULL) {
1382     // look for the correct vframe within the stack frame if one is given
1383     int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1384     while (frame_number &lt; last_frame_number) {
1385       if (vf-&gt;is_top()) {
1386         THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1387       }
1388       vf = vf-&gt;sender();
1389       frame_number ++;
1390     }
1391     // move one frame forward
1392     if (vf-&gt;is_top()) {
1393       if (fst.is_done()) {
1394         return NULL;
1395       }
1396       fst.next();
1397       vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1398       frame_number = 0;
1399     } else {
1400       vf = vf-&gt;sender();
1401       frame_number++;
1402     }
1403   }
1404 
1405   while (true) {
1406     // look for the given method
1407     while (true) {
1408       StackValueCollection* locals = NULL;
1409       if (vf-&gt;is_compiled_frame()) {
1410         // compiled method frame
1411         compiledVFrame* cvf = compiledVFrame::cast(vf);
1412         if (methods == NULL || matches(methods, cvf-&gt;method())) {
1413           if (initialSkip &gt; 0) {
1414             initialSkip --;
1415           } else {
1416             ScopeDesc* scope = cvf-&gt;scope();
1417             // native wrappers do not have a scope
1418             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1419               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), scope-&gt;objects(), CHECK_NULL);
1420               Deoptimization::reassign_fields(fst.current(), fst.register_map(), scope-&gt;objects(), realloc_failures, false);
1421 
1422               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1423               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1424               typeArrayHandle array(THREAD, array_oop);
1425               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1426                 ScopeValue* value = local_values-&gt;at(i);
1427                 if (value-&gt;is_object()) {
1428                   array-&gt;bool_at_put(i, true);
1429                 }
1430               }
1431               HotSpotStackFrameReference::set_localIsVirtual(result, array());
1432             } else {
1433               HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1434             }
1435 
1436             locals = cvf-&gt;locals();
1437             HotSpotStackFrameReference::set_bci(result, cvf-&gt;bci());
1438             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);
1439             HotSpotStackFrameReference::set_method(result, method);
1440           }
1441         }
1442       } else if (vf-&gt;is_interpreted_frame()) {
1443         // interpreted method frame
1444         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1445         if (methods == NULL || matches(methods, ivf-&gt;method())) {
1446           if (initialSkip &gt; 0) {
1447             initialSkip --;
1448           } else {
1449             locals = ivf-&gt;locals();
1450             HotSpotStackFrameReference::set_bci(result, ivf-&gt;bci());
1451             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);
1452             HotSpotStackFrameReference::set_method(result, method);
1453             HotSpotStackFrameReference::set_localIsVirtual(result, NULL);
1454           }
1455         }
1456       }
1457 
1458       // locals != NULL means that we found a matching frame and result is already partially initialized
1459       if (locals != NULL) {
1460         HotSpotStackFrameReference::set_compilerToVM(result, JNIHandles::resolve(compilerToVM));
1461         HotSpotStackFrameReference::set_stackPointer(result, (jlong) fst.current()-&gt;sp());
1462         HotSpotStackFrameReference::set_frameNumber(result, frame_number);
1463 
1464         // initialize the locals array
1465         objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
1466         objArrayHandle array(THREAD, array_oop);
1467         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1468           StackValue* var = locals-&gt;at(i);
1469           if (var-&gt;type() == T_OBJECT) {
1470             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1471           }
1472         }
1473         HotSpotStackFrameReference::set_locals(result, array());
1474 
1475         return JNIHandles::make_local(thread, result());
1476       }
1477 
1478       if (vf-&gt;is_top()) {
1479         break;
1480       }
1481       frame_number++;
1482       vf = vf-&gt;sender();
1483     } // end of vframe loop
1484 
1485     if (fst.is_done()) {
1486       break;
1487     }
1488     fst.next();
1489     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1490     frame_number = 0;
1491   } // end of frame loop
1492 
1493   // the end was reached without finding a matching method
1494   return NULL;
1495 C2V_END
1496 
1497 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1498   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1499   CallInfo callInfo;
1500   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1501   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1502   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1503 C2V_END
1504 
1505 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1506   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1507   Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
1508   Symbol* name = cp-&gt;name_ref_at(index);
1509   if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
1510     CallInfo callInfo;
1511     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1512     ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1513     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1514   }
1515 C2V_END
1516 
1517 C2V_VMENTRY(jint, isResolvedInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1518   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1519   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1520   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
1521     // MethodHandle.invoke* --&gt; LambdaForm?
1522     ResourceMark rm;
1523 
1524     LinkInfo link_info(cp, index, CATCH);
1525 
1526     Klass* resolved_klass = link_info.resolved_klass();
1527 
1528     Symbol* name_sym = cp-&gt;name_ref_at(index);
1529 
1530     vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), "!");
1531     vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), "!");
1532 
1533     methodHandle adapter_method(cp_cache_entry-&gt;f1_as_method());
1534 
1535     methodHandle resolved_method(adapter_method);
1536 
1537     // Can we treat it as a regular invokevirtual?
1538     if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
1539       vmassert(!resolved_method-&gt;is_static(),"!");
1540       vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),"!");
1541       vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), "!");
1542       vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, "!");
1543       vmassert(cp_cache_entry-&gt;method_type_if_resolved(cp) == NULL, "!");
1544 
1545       methodHandle m(LinkResolver::linktime_resolve_virtual_method_or_null(link_info));
1546       vmassert(m == resolved_method, "!!");
1547       return -1;
1548     }
1549 
1550     return Bytecodes::_invokevirtual;
1551   }
1552   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokedynamic)) {
1553     return Bytecodes::_invokedynamic;
1554   }
1555   return -1;
1556 C2V_END
1557 
1558 
1559 C2V_VMENTRY(jobject, getSignaturePolymorphicHolders, (JNIEnv*, jobject))
1560   objArrayHandle holders = oopFactory::new_objArray_handle(SystemDictionary::String_klass(), 2, CHECK_NULL);
1561   Handle mh = java_lang_String::create_from_str("Ljava/lang/invoke/MethodHandle;", CHECK_NULL);
1562   Handle vh = java_lang_String::create_from_str("Ljava/lang/invoke/VarHandle;", CHECK_NULL);
1563   holders-&gt;obj_at_put(0, mh());
1564   holders-&gt;obj_at_put(1, vh());
1565   return JNIHandles::make_local(THREAD, holders());
1566 C2V_END
1567 
1568 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))
1569   //see compute_recording_non_safepoints in debugInfroRec.cpp
1570   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1571     return true;
1572   }
1573   return DebugNonSafepoints;
1574 C2V_END
1575 
1576 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1577 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))
1578   ResourceMark rm;
1579 
1580   if (hs_frame == NULL) {
1581     THROW_MSG(vmSymbols::java_lang_NullPointerException(), "stack frame is null")
1582   }
1583 
1584   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK);
1585 
1586   // look for the given stack frame
1587   StackFrameStream fst(thread);
1588   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1589   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1590     fst.next();
1591   }
1592   if (fst.current()-&gt;sp() != stack_pointer) {
1593     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found")
1594   }
1595 
1596   if (invalidate) {
1597     if (!fst.current()-&gt;is_compiled_frame()) {
1598       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1599     }
1600     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), "nmethod expected");
1601     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1602   }
1603   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1604   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1605   StackFrameStream fstAfterDeopt(thread);
1606   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1607     fstAfterDeopt.next();
1608   }
1609   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1610     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "stack frame not found after deopt")
1611   }
1612 
1613   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1614   if (!vf-&gt;is_compiled_frame()) {
1615     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "compiled stack frame expected")
1616   }
1617 
1618   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1619   while (true) {
1620     assert(vf-&gt;is_compiled_frame(), "Wrong frame type");
1621     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1622     if (vf-&gt;is_top()) {
1623       break;
1624     }
1625     vf = vf-&gt;sender();
1626   }
1627 
1628   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1629   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1630     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), "invalid frame number")
1631   }
1632 
1633   // Reallocate the non-escaping objects and restore their fields.
1634   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,"invalid scope");
1635   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1636 
1637   if (objects == NULL) {
1638     // no objects to materialize
1639     return;
1640   }
1641 
1642   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, CHECK);
1643   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1644 
1645   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1646     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1647 
1648     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1649     StackValueCollection* locals = cvf-&gt;locals();
1650 
1651     if (locals != NULL) {
1652       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1653         StackValue* var = locals-&gt;at(i2);
1654         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1655           jvalue val;
1656           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1657           cvf-&gt;update_local(T_OBJECT, i2, val);
1658         }
1659       }
1660     }
1661   }
1662 
1663   // all locals are materialized by now
1664   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);
1665 
1666   // update the locals array
1667   objArrayHandle array(THREAD, HotSpotStackFrameReference::locals(hs_frame));
1668   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1669   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1670     StackValue* var = locals-&gt;at(i);
1671     if (var-&gt;type() == T_OBJECT) {
1672       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1673     }
1674   }
1675 C2V_END
1676 
1677 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))
1678   if (bytes == NULL) {
1679     THROW(vmSymbols::java_lang_NullPointerException());
1680   }
1681   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);
1682 
1683   // Check if offset and length are non negative.
1684   if (offset &lt; 0 || length &lt; 0) {
1685     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1686   }
1687   // Check if the range is valid.
1688   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {
1689     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1690   }
1691   while (length &gt; 0) {
1692     jbyte* start = array-&gt;byte_at_addr(offset);
1693     tty-&gt;write((char*) start, MIN2(length, O_BUFLEN));
1694     length -= O_BUFLEN;
1695     offset += O_BUFLEN;
1696   }
1697 C2V_END
1698 
1699 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))
1700   tty-&gt;flush();
1701 C2V_END
1702 
1703 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))
1704   ResourceMark rm;
1705   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1706   ProfileData* profile_data = mdo-&gt;data_at(position);
1707   if (mdo-&gt;is_valid(profile_data)) {
1708     return profile_data-&gt;size_in_bytes();
1709   }
1710   DataLayout* data    = mdo-&gt;extra_data_base();
1711   DataLayout* end   = mdo-&gt;extra_data_limit();
1712   for (;; data = mdo-&gt;next_extra(data)) {
1713     assert(data &lt; end, "moved past end of extra data");
1714     profile_data = data-&gt;data_in();
1715     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1716       return profile_data-&gt;size_in_bytes();
1717     }
1718   }
1719   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("Invalid profile data position %d", position));
1720 C2V_END
1721 
1722 C2V_VMENTRY(jlong, getFingerprint, (JNIEnv*, jobject, jlong metaspace_klass))
1723   Klass *k = CompilerToVM::asKlass(metaspace_klass);
1724   if (k-&gt;is_instance_klass()) {
1725     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1726   } else {
1727     return 0;
1728   }
1729 C2V_END
1730 
1731 C2V_VMENTRY(jobject, getHostClass, (JNIEnv*, jobject, jobject jvmci_type))
1732   InstanceKlass* k = InstanceKlass::cast(CompilerToVM::asKlass(jvmci_type));
1733   InstanceKlass* host = k-&gt;host_klass();
1734   oop result = CompilerToVM::get_jvmci_type(host, CHECK_NULL);
1735   return JNIHandles::make_local(THREAD, result);
1736 C2V_END
1737 
1738 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))
1739   if (bytecode_frame_handle == NULL) {
1740     THROW_0(vmSymbols::java_lang_NullPointerException());
1741   }
1742 
1743   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);
1744   oop bytecode_frame = top_bytecode_frame;
1745   int size = 0;
1746   int callee_parameters = 0;
1747   int callee_locals = 0;
1748   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1749   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);
1750 
1751   while (bytecode_frame != NULL) {
1752     int locks = BytecodeFrame::numLocks(bytecode_frame);
1753     int temps = BytecodeFrame::numStack(bytecode_frame);
1754     bool is_top_frame = (bytecode_frame == top_bytecode_frame);
1755     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1756 
1757     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1758                                                                  temps + callee_parameters,
1759                                                                  extra_args,
1760                                                                  locks,
1761                                                                  callee_parameters,
1762                                                                  callee_locals,
1763                                                                  is_top_frame);
1764     size += frame_size;
1765 
1766     callee_parameters = method-&gt;size_of_parameters();
1767     callee_locals = method-&gt;max_locals();
1768     extra_args = 0;
1769     bytecode_frame = BytecodePosition::caller(bytecode_frame);
1770   }
1771   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1772 C2V_END
1773 
1774 C2V_VMENTRY(void, compileToBytecode, (JNIEnv*, jobject, jobject lambda_form_handle))
1775   Handle lambda_form(THREAD, JNIHandles::resolve_non_null(lambda_form_handle));
1776   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1777     TempNewSymbol compileToBytecode = SymbolTable::new_symbol("compileToBytecode", CHECK);
1778     JavaValue result(T_VOID);
1779     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1780   } else {
1781     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1782                 err_msg("Unexpected type: %s", lambda_form-&gt;klass()-&gt;external_name()));
1783   }
1784 C2V_END
1785 
1786 #define CC (char*)  /*cast a literal from (const char*)*/
1787 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1788 
1789 #define STRING                "Ljava/lang/String;"
1790 #define OBJECT                "Ljava/lang/Object;"
1791 #define CLASS                 "Ljava/lang/Class;"
1792 #define EXECUTABLE            "Ljava/lang/reflect/Executable;"
1793 #define STACK_TRACE_ELEMENT   "Ljava/lang/StackTraceElement;"
1794 #define INSTALLED_CODE        "Ljdk/vm/ci/code/InstalledCode;"
1795 #define TARGET_DESCRIPTION    "Ljdk/vm/ci/code/TargetDescription;"
1796 #define BYTECODE_FRAME        "Ljdk/vm/ci/code/BytecodeFrame;"
1797 #define RESOLVED_METHOD       "Ljdk/vm/ci/meta/ResolvedJavaMethod;"
1798 #define HS_RESOLVED_METHOD    "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;"
1799 #define HS_RESOLVED_KLASS     "Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;"
1800 #define HS_CONSTANT_POOL      "Ljdk/vm/ci/hotspot/HotSpotConstantPool;"
1801 #define HS_COMPILED_CODE      "Ljdk/vm/ci/hotspot/HotSpotCompiledCode;"
1802 #define HS_CONFIG             "Ljdk/vm/ci/hotspot/HotSpotVMConfig;"
1803 #define HS_METADATA           "Ljdk/vm/ci/hotspot/HotSpotMetaData;"
1804 #define HS_STACK_FRAME_REF    "Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;"
1805 #define HS_SPECULATION_LOG    "Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;"
1806 #define METASPACE_METHOD_DATA "J"
1807 
1808 JNINativeMethod CompilerToVM::methods[] = {
1809   {CC "getBytecode",                                  CC "(" HS_RESOLVED_METHOD ")[B",                                                      FN_PTR(getBytecode)},
1810   {CC "getExceptionTableStart",                       CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getExceptionTableStart)},
1811   {CC "getExceptionTableLength",                      CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getExceptionTableLength)},
1812   {CC "findUniqueConcreteMethod",                     CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1813   {CC "getImplementor",                               CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1814   {CC "getStackTraceElement",                         CC "(" HS_RESOLVED_METHOD "I)" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1815   {CC "methodIsIgnoredBySecurityStackWalk",           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1816   {CC "setNotInlineableOrCompileable",                CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(setNotInlineableOrCompileable)},
1817   {CC "isCompilable",                                 CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(isCompilable)},
1818   {CC "hasNeverInlineDirective",                      CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(hasNeverInlineDirective)},
1819   {CC "shouldInlineMethod",                           CC "(" HS_RESOLVED_METHOD ")Z",                                                       FN_PTR(shouldInlineMethod)},
1820   {CC "lookupType",                                   CC "(" STRING CLASS "Z)" HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1821   {CC "lookupNameInPool",                             CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupNameInPool)},
1822   {CC "lookupNameAndTypeRefIndexInPool",              CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1823   {CC "lookupSignatureInPool",                        CC "(" HS_CONSTANT_POOL "I)" STRING,                                                  FN_PTR(lookupSignatureInPool)},
1824   {CC "lookupKlassRefIndexInPool",                    CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(lookupKlassRefIndexInPool)},
1825   {CC "lookupKlassInPool",                            CC "(" HS_CONSTANT_POOL "I)Ljava/lang/Object;",                                       FN_PTR(lookupKlassInPool)},
1826   {CC "lookupAppendixInPool",                         CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1827   {CC "lookupMethodInPool",                           CC "(" HS_CONSTANT_POOL "IB)" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1828   {CC "constantPoolRemapInstructionOperandFromCache", CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1829   {CC "resolveConstantInPool",                        CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1830   {CC "resolvePossiblyCachedConstantInPool",          CC "(" HS_CONSTANT_POOL "I)" OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1831   {CC "resolveTypeInPool",                            CC "(" HS_CONSTANT_POOL "I)" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
1832   {CC "resolveFieldInPool",                           CC "(" HS_CONSTANT_POOL "I" HS_RESOLVED_METHOD "B[I)" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
1833   {CC "resolveInvokeDynamicInPool",                   CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeDynamicInPool)},
1834   {CC "resolveInvokeHandleInPool",                    CC "(" HS_CONSTANT_POOL "I)V",                                                        FN_PTR(resolveInvokeHandleInPool)},
1835   {CC "isResolvedInvokeHandleInPool",                 CC "(" HS_CONSTANT_POOL "I)I",                                                        FN_PTR(isResolvedInvokeHandleInPool)},
1836   {CC "resolveMethod",                                CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1837   {CC "getSignaturePolymorphicHolders",               CC "()[" STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
1838   {CC "getVtableIndexForInterfaceMethod",             CC "(" HS_RESOLVED_KLASS HS_RESOLVED_METHOD ")I",                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1839   {CC "getClassInitializer",                          CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1840   {CC "hasFinalizableSubclass",                       CC "(" HS_RESOLVED_KLASS ")Z",                                                        FN_PTR(hasFinalizableSubclass)},
1841   {CC "getMaxCallTargetOffset",                       CC "(J)J",                                                                            FN_PTR(getMaxCallTargetOffset)},
1842   {CC "asResolvedJavaMethod",                         CC "(" EXECUTABLE ")" HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
1843   {CC "getResolvedJavaMethod",                        CC "(Ljava/lang/Object;J)" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1844   {CC "getConstantPool",                              CC "(Ljava/lang/Object;)" HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},
1845   {CC "getResolvedJavaType",                          CC "(Ljava/lang/Object;JZ)" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1846   {CC "readConfiguration",                            CC "()[" OBJECT,                                                                      FN_PTR(readConfiguration)},
1847   {CC "installCode",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG ")I",    FN_PTR(installCode)},
1848   {CC "getMetadata",                                  CC "(" TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA ")I",                          FN_PTR(getMetadata)},
1849   {CC "resetCompilationStatistics",                   CC "()V",                                                                             FN_PTR(resetCompilationStatistics)},
1850   {CC "disassembleCodeBlob",                          CC "(" INSTALLED_CODE ")" STRING,                                                     FN_PTR(disassembleCodeBlob)},
1851   {CC "executeInstalledCode",                         CC "([" OBJECT INSTALLED_CODE ")" OBJECT,                                             FN_PTR(executeInstalledCode)},
1852   {CC "getLineNumberTable",                           CC "(" HS_RESOLVED_METHOD ")[J",                                                      FN_PTR(getLineNumberTable)},
1853   {CC "getLocalVariableTableStart",                   CC "(" HS_RESOLVED_METHOD ")J",                                                       FN_PTR(getLocalVariableTableStart)},
1854   {CC "getLocalVariableTableLength",                  CC "(" HS_RESOLVED_METHOD ")I",                                                       FN_PTR(getLocalVariableTableLength)},
1855   {CC "reprofile",                                    CC "(" HS_RESOLVED_METHOD ")V",                                                       FN_PTR(reprofile)},
1856   {CC "invalidateInstalledCode",                      CC "(" INSTALLED_CODE ")V",                                                           FN_PTR(invalidateInstalledCode)},
1857   {CC "collectCounters",                              CC "()[J",                                                                            FN_PTR(collectCounters)},
1858   {CC "allocateCompileId",                            CC "(" HS_RESOLVED_METHOD "I)I",                                                      FN_PTR(allocateCompileId)},
1859   {CC "isMature",                                     CC "(" METASPACE_METHOD_DATA ")Z",                                                    FN_PTR(isMature)},
1860   {CC "hasCompiledCodeForOSR",                        CC "(" HS_RESOLVED_METHOD "II)Z",                                                     FN_PTR(hasCompiledCodeForOSR)},
1861   {CC "getSymbol",                                    CC "(J)" STRING,                                                                      FN_PTR(getSymbol)},
1862   {CC "getNextStackFrame",                            CC "(" HS_STACK_FRAME_REF "[" RESOLVED_METHOD "I)" HS_STACK_FRAME_REF,                FN_PTR(getNextStackFrame)},
1863   {CC "materializeVirtualObjects",                    CC "(" HS_STACK_FRAME_REF "Z)V",                                                      FN_PTR(materializeVirtualObjects)},
1864   {CC "shouldDebugNonSafepoints",                     CC "()Z",                                                                             FN_PTR(shouldDebugNonSafepoints)},
1865   {CC "writeDebugOutput",                             CC "([BII)V",                                                                         FN_PTR(writeDebugOutput)},
1866   {CC "flushDebugOutput",                             CC "()V",                                                                             FN_PTR(flushDebugOutput)},
1867   {CC "methodDataProfileDataSize",                    CC "(JI)I",                                                                           FN_PTR(methodDataProfileDataSize)},
1868   {CC "getFingerprint",                               CC "(J)J",                                                                            FN_PTR(getFingerprint)},
1869   {CC "getHostClass",                                 CC "(" HS_RESOLVED_KLASS ")" HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
1870   {CC "interpreterFrameSize",                         CC "(" BYTECODE_FRAME ")I",                                                           FN_PTR(interpreterFrameSize)},
1871   {CC "compileToBytecode",                            CC "(" OBJECT ")V",                                                                   FN_PTR(compileToBytecode)},
1872   {CC "getFlagValue",                                 CC "(" STRING ")" OBJECT,                                                             FN_PTR(getFlagValue)},
1873 };
1874 
1875 int CompilerToVM::methods_count() {
1876   return sizeof(methods) / sizeof(JNINativeMethod);
1877 }
</pre></body></html>
