<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #ifndef SHARE_VM_JVMCI_JVMCI_RUNTIME_HPP
  25 #define SHARE_VM_JVMCI_JVMCI_RUNTIME_HPP
  26 
  27 #include "interpreter/interpreter.hpp"
  28 #include "memory/allocation.hpp"
  29 #include "runtime/arguments.hpp"
  30 #include "runtime/deoptimization.hpp"
  31 
  32 #define JVMCI_ERROR(...)       \
  33   { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return; }
  34 
  35 #define JVMCI_ERROR_(ret, ...) \
  36   { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return ret; }
  37 
  38 #define JVMCI_ERROR_0(...)    JVMCI_ERROR_(0, __VA_ARGS__)
  39 #define JVMCI_ERROR_NULL(...) JVMCI_ERROR_(NULL, __VA_ARGS__)
  40 #define JVMCI_ERROR_OK(...)   JVMCI_ERROR_(JVMCIEnv::ok, __VA_ARGS__)
  41 #define CHECK_OK              CHECK_(JVMCIEnv::ok)
  42 
  43 class JVMCIRuntime: public AllStatic {
  44  public:
  45   // Constants describing whether JVMCI wants to be able to adjust the compilation
  46   // level selected for a method by the VM compilation policy and if so, based on
  47   // what information about the method being schedule for compilation.
  48   enum CompLevelAdjustment {
  49      none = 0,             // no adjustment
  50      by_holder = 1,        // adjust based on declaring class of method
  51      by_full_signature = 2 // adjust based on declaring class, name and signature of method
  52   };
  53 
  54  private:
  55   static jobject _HotSpotJVMCIRuntime_instance;
  56   static bool _HotSpotJVMCIRuntime_initialized;
  57   static bool _well_known_classes_initialized;
  58 
  59   static int _trivial_prefixes_count;
  60   static char** _trivial_prefixes;
  61 
  62   static CompLevelAdjustment _comp_level_adjustment;
  63 
  64   static bool _shutdown_called;
  65 
  66   static CompLevel adjust_comp_level_inner(methodHandle method, bool is_osr, CompLevel level, JavaThread* thread);
  67 
  68  public:
  69   static bool is_HotSpotJVMCIRuntime_initialized() {
  70     return _HotSpotJVMCIRuntime_initialized;
  71   }
  72 
  73   /**
  74    * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary
  75    */
  76   static Handle get_HotSpotJVMCIRuntime(TRAPS) {
  77     initialize_JVMCI(CHECK_(Handle()));
  78     return Handle(JNIHandles::resolve_non_null(_HotSpotJVMCIRuntime_instance));
  79   }
  80 
  81   static jobject get_HotSpotJVMCIRuntime_jobject(TRAPS) {
  82     initialize_JVMCI(CHECK_NULL);
  83     assert(_HotSpotJVMCIRuntime_initialized, "must be");
  84     return _HotSpotJVMCIRuntime_instance;
  85   }
  86 
  87   static Handle callStatic(const char* className, const char* methodName, const char* returnType, JavaCallArguments* args, TRAPS);
  88 
  89   /**
<a name="1" id="anc1"></a>




  90    * Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()
  91    */
  92   static void initialize_JVMCI(TRAPS);
  93 
  94   /**
  95    * Explicitly initialize HotSpotJVMCIRuntime itself
  96    */
  97   static void initialize_HotSpotJVMCIRuntime(TRAPS);
  98 
  99   static void initialize_well_known_classes(TRAPS);
 100 
 101   static void metadata_do(void f(Metadata*));
 102 
 103   static void shutdown(TRAPS);
 104 
 105   static void bootstrap_finished(TRAPS);
 106 
 107   static bool shutdown_called() {
 108     return _shutdown_called;
 109   }
 110 
 111   static bool treat_as_trivial(Method* method);
 112 
 113   /**
 114    * Lets JVMCI modify the compilation level currently selected for a method by
 115    * the VM compilation policy.
 116    *
 117    * @param method the method being scheduled for compilation
 118    * @param is_osr specifies if the compilation is an OSR compilation
 119    * @param level the compilation level currently selected by the VM compilation policy
 120    * @param thread the current thread
 121    * @return the compilation level to use for the compilation
 122    */
 123   static CompLevel adjust_comp_level(methodHandle method, bool is_osr, CompLevel level, JavaThread* thread);
 124 
 125   static BasicType kindToBasicType(Handle kind, TRAPS);
 126 
 127   // The following routines are all called from compiled JVMCI code
 128 
 129   static void new_instance(JavaThread* thread, Klass* klass);
 130   static void new_array(JavaThread* thread, Klass* klass, jint length);
 131   static void new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims);
 132   static void dynamic_new_array(JavaThread* thread, oopDesc* element_mirror, jint length);
 133   static void dynamic_new_instance(JavaThread* thread, oopDesc* type_mirror);
 134   static jboolean thread_is_interrupted(JavaThread* thread, oopDesc* obj, jboolean clear_interrupted);
 135   static void vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3);
 136   static jint identity_hash_code(JavaThread* thread, oopDesc* obj);
 137   static address exception_handler_for_pc(JavaThread* thread);
 138   static void monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock);
 139   static void monitorexit (JavaThread* thread, oopDesc* obj, BasicLock* lock);
 140   static void vm_error(JavaThread* thread, jlong where, jlong format, jlong value);
 141   static oopDesc* load_and_clear_exception(JavaThread* thread);
 142   static void log_printf(JavaThread* thread, oopDesc* format, jlong v1, jlong v2, jlong v3);
 143   static void log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline);
 144   // Print the passed in object, optionally followed by a newline.  If
 145   // as_string is true and the object is a java.lang.String then it
 146   // printed as a string, otherwise the type of the object is printed
 147   // followed by its address.
 148   static void log_object(JavaThread* thread, oopDesc* object, bool as_string, bool newline);
 149   static void write_barrier_pre(JavaThread* thread, oopDesc* obj);
 150   static void write_barrier_post(JavaThread* thread, void* card);
 151   static jboolean validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child);
 152   static void new_store_pre_barrier(JavaThread* thread);
 153 
 154   // used to throw exceptions from compiled JVMCI code
 155   static void throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message);
 156   // helper methods to throw exception with complex messages
 157   static void throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass);
 158   static void throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);
 159 
 160   // Forces initialization of the JVMCI runtime.
 161   static void force_initialization(TRAPS);
 162 
 163   // Test only function
 164   static int test_deoptimize_call_int(JavaThread* thread, int value);
 165 };
 166 
 167 // Tracing macros.
 168 
 169 #define IF_TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1)) ; else
 170 #define IF_TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2)) ; else
 171 #define IF_TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3)) ; else
 172 #define IF_TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4)) ; else
 173 #define IF_TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5)) ; else
 174 
 175 #define TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1 &amp;&amp; (tty-&gt;print("JVMCITrace-1: "), true))) ; else tty-&gt;print_cr
 176 #define TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2 &amp;&amp; (tty-&gt;print("   JVMCITrace-2: "), true))) ; else tty-&gt;print_cr
 177 #define TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3 &amp;&amp; (tty-&gt;print("      JVMCITrace-3: "), true))) ; else tty-&gt;print_cr
 178 #define TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4 &amp;&amp; (tty-&gt;print("         JVMCITrace-4: "), true))) ; else tty-&gt;print_cr
 179 #define TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5 &amp;&amp; (tty-&gt;print("            JVMCITrace-5: "), true))) ; else tty-&gt;print_cr
 180 
 181 #endif // SHARE_VM_JVMCI_JVMCI_RUNTIME_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
